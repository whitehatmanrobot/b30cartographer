_TO_B:
            query = GL_PIXEL_MAP_I_TO_B_SIZE;
            break;
        case GL_PIXEL_MAP_I_TO_A:
            query = GL_PIXEL_MAP_I_TO_A_SIZE;
            break;
        case GL_PIXEL_MAP_R_TO_R:
            query = GL_PIXEL_MAP_R_TO_R_SIZE;
            break;
        case GL_PIXEL_MAP_G_TO_G:
            query = GL_PIXEL_MAP_G_TO_G_SIZE;
            break;
        case GL_PIXEL_MAP_B_TO_B:
            query = GL_PIXEL_MAP_B_TO_B_SIZE;
            break;
        case GL_PIXEL_MAP_A_TO_A:
            query = GL_PIXEL_MAP_A_TO_A_SIZE;
            break;
        default:
            return 0;
    }
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetIntegerv);
    glGetIntegerv(query, &size);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetIntegerv);
    return size;
}

static GLint __glsGetSize(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

static GLint __glsImageSize(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    GLint elemCount;
    
    if (inWidth < 0 || inHeight < 0) return 0;
    switch (inFormat) {
        case GL_ALPHA:
        case GL_BLUE:
        case GL_COLOR_INDEX:
        case GL_DEPTH_COMPONENT:
        case GL_GREEN:
        case GL_LUMINANCE:
        case GL_RED:
        case GL_STENCIL_INDEX:
            elemCount = 1;
            break;
        case GL_LUMINANCE_ALPHA:
            elemCount = 2;
            break;
        case GL_RGB:
#if __GL_EXT_bgra
        case GL_BGR_EXT:
#endif
            elemCount = 3;
            break;
        case GL_RGBA:
#if __GL_EXT_bgra
        case GL_BGRA_EXT:
#endif
            elemCount = 4;
            break;
        #if __GL_EXT_abgr
            case GL_ABGR_EXT:
                elemCount = 4;
                break;
        #endif /* __GL_EXT_abgr */
        #if __GL_EXT_cmyka
            case GL_CMYK_EXT:
                elemCount = 4;
                break;
            case GL_CMYKA_EXT:
                elemCount = 5;
                break;
        #endif /* __GL_EXT_cmyka */
        default:
            return 0;
    }
    #if __GL_EXT_packed_pixels
        switch (inType) {
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
                if (elemCount != 3) return 0;
                break;
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
                if (elemCount != 4) return 0;
                break;
        }
    #endif /* __GL_EXT_packed_pixels */
    switch (inType) {
        case GL_BITMAP:
            if (inFormat != GL_COLOR_INDEX && inFormat != GL_STENCIL_INDEX) {
                return 0;
            }
            return inHeight * ((inWidth + 7) / 8);
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return elemCount * inWidth * inHeight;
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return elemCount * 2 * inWidth * inHeight;
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return elemCount * 4 * inWidth * inHeight;
    }
    return 0;
}

static GLint __glsTextureSize(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    switch (inFormat) {
        case GL_DEPTH_COMPONENT:
        case GL_STENCIL_INDEX:
            return 0;
    }
    if (inType == GL_BITMAP) return 0;
    return __glsImageSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glBitmap_bitmap_size(GLint inWidth, GLint inHeight) {
    return __glsImageSize(GL_COLOR_INDEX, GL_BITMAP, inWidth, inHeight);
}

GLint __gls_glCallLists_lists_size(GLint inCount, GLenum inType) {
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
            return inCount;
        case GL_2_BYTES:
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
            return 2 * inCount;
        case GL_3_BYTES:
            return 3 * inCount;
        case GL_4_BYTES:
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
            return 4 * inCount;
    }
    return 0;
}

GLint __gls_glDrawPixels_pixels_size(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    return __glsImageSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glFogfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_FOG_DENSITY:
        case GL_FOG_END:
        case GL_FOG_INDEX:
        case GL_FOG_MODE:
        case GL_FOG_START:
            return 1;
        case GL_FOG_COLOR:
            return 4;
    }
    return 0;
}

GLint __gls_glFogiv_params_size(GLenum inPname) {
    return __gls_glFogfv_params_size(inPname);
}

GLint __gls_glGetBooleanv_params_size(GLenum inPname) {
    return __glsGetSize(inPname);
}

GLint __gls_glGetDoublev_params_size(GLenum inPname) {
    return __glsGetSize(inPname);
}

GLint __gls_glGetFloatv_params_size(GLenum inPname) {
    return __glsGetSize(inPname);
}

GLint __gls_glGetIntegerv_params_size(GLenum inPname) {
    return __glsGetSize(inPname);
}

GLint __gls_glGetLightfv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetLightiv_params_size(GLenum inPname) {
    return __gls_glGetLightfv_params_size(inPname);
}

GLint __gls_glGetMapdv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery) {
    return __glsGetMapSize(ctx, inTarget, inQuery);
}

GLint __gls_glGetMapfv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery) {
    return __glsGetMapSize(ctx, inTarget, inQuery);
}

GLint __gls_glGetMapiv_v_size(__GLScontext *ctx, GLenum inTarget, GLenum inQuery) {
    return __glsGetMapSize(ctx, inTarget, inQuery);
}

GLint __gls_glGetMaterialfv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetMaterialiv_params_size(GLenum inPname) {
    return __gls_glGetMaterialfv_params_size(inPname);
}

GLint __gls_glGetPixelMapfv_values_size(__GLScontext *ctx, GLenum inMap) {
    return __glsGetPixelMapSize(ctx, inMap);
}

GLint __gls_glGetPixelMapuiv_values_size(__GLScontext *ctx, GLenum inMap) {
    return __glsGetPixelMapSize(ctx, inMap);
}

GLint __gls_glGetPixelMapusv_values_size(__GLScontext *ctx, GLenum inMap) {
    return __glsGetPixelMapSize(ctx, inMap);
}

GLint __gls_glGetPolygonStipple_mask_size(void) {
    return 128;
}

GLint __gls_glGetTexEnvfv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetTexEnviv_params_size(GLenum inPname) {
    return __gls_glGetTexEnvfv_params_size(inPname);
}

GLint __gls_glGetTexGendv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetTexGenfv_params_size(GLenum inPname) {
    return __gls_glGetTexGendv_params_size(inPname);
}

GLint __gls_glGetTexGeniv_params_size(GLenum inPname) {
    return __gls_glGetTexGendv_params_size(inPname);
}

GLint __gls_glGetTexImage_pixels_size(
    __GLScontext *ctx,
    GLenum inTarget, GLint inLevel, GLenum inFormat, GLenum inType
) {
    GLint width, height, depth, size4d;

    switch (inTarget) {
        case GL_TEXTURE_1D:
        case GL_TEXTURE_2D:
        #if __GL_EXT_texture3D
            case GL_TEXTURE_3D_EXT:
        #endif /* __GL_EXT_texture3D */
        #if __GL_SGIS_detail_texture
            case GL_DETAIL_TEXTURE_2D_SGIS:
        #endif /* __GL_SGIS_detail_texture */
        #if __GL_SGIS_texture4D
            case GL_TEXTURE_4D_SGIS:
        #endif /* __GL_SGIS_texture4D */
            break;
        default:
            return 0;
    }
    if (inLevel < 0) return 0;
    width = height = 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetTexLevelParameteriv);
    glGetTexLevelParameteriv(inTarget, inLevel, GL_TEXTURE_WIDTH, &width);
    glGetTexLevelParameteriv(inTarget, inLevel, GL_TEXTURE_HEIGHT, &height);
    #if __GL_EXT_texture3D
        depth = 0;
        glGetTexLevelParameteriv(
            inTarget, inLevel, GL_TEXTURE_DEPTH_EXT, &depth
        );
    #else /* !__GL_EXT_texture3D */
        depth = 1;
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        size4d = 0;
        glGetTexLevelParameteriv(
            inTarget, inLevel, GL_TEXTURE_4DSIZE_SGIS, &size4d
        );
    #else /* !__GL_SGIS_texture4D */
        size4d = 1;
    #endif /* __GL_SGIS_texture4D */
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetTexLevelParameteriv);
    return __glsTextureSize(inFormat, inType, width, height) * depth * size4d;
}

GLint __gls_glGetTexLevelParameterfv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetTexLevelParameteriv_params_size(GLenum inPname) {
    return __gls_glGetTexLevelParameterfv_params_size(inPname);
}

GLint __gls_glGetTexParameterfv_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetTexParameteriv_params_size(GLenum inPname) {
    return __gls_glGetTexParameterfv_params_size(inPname);
}

GLint __gls_glLightfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_CONSTANT_ATTENUATION:
        case GL_LINEAR_ATTENUATION:
        case GL_QUADRATIC_ATTENUATION:
        case GL_SPOT_CUTOFF:
        case GL_SPOT_EXPONENT:
            return 1;
        case GL_SPOT_DIRECTION:
            return 3;
        case GL_AMBIENT:
        case GL_DIFFUSE:
        case GL_POSITION:
        case GL_SPECULAR:
            return 4;
    }
    return 0;
}

GLint __gls_glLightiv_params_size(GLenum inPname) {
    return __gls_glLightfv_params_size(inPname);
}

GLint __gls_glLightModelfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_LIGHT_MODEL_LOCAL_VIEWER:
        case GL_LIGHT_MODEL_TWO_SIDE:
            return 1;
        case GL_LIGHT_MODEL_AMBIENT:
            return 4;
    }
    return 0;
}

GLint __gls_glLightModeliv_params_size(GLenum inPname) {
    return __gls_glLightModelfv_params_size(inPname);
}

GLint __gls_glMap1d_points_size(
    GLenum inTarget, GLint inStride, GLint inOrder
) {
    const GLint k = __glsEvalComputeK(inTarget);

    if (inStride < k || inOrder < 0) return 0;
    return k * inOrder;
}

GLint __gls_glMap1f_points_size(
    GLenum inTarget, GLint inStride, GLint inOrder
) {
    const GLint k = __glsEvalComputeK(inTarget);

    if (inStride < k || inOrder < 0) return 0;
    return k * inOrder;
}

GLint __gls_glMap2d_points_size(
    GLenum inTarget, GLint inUstride, GLint inUorder, GLint inVstride,
    GLint inVorder
) {
    const GLint k = __glsEvalComputeK(inTarget);

    if (inUstride < k || inUorder < 0 || inVstride < k || inVorder < 0) {
        return 0;
    }
    return k * inUorder * inVorder;
}

GLint __gls_glMap2f_points_size(
    GLenum inTarget, GLint inUstride, GLint inUorder, GLint inVstride,
    GLint inVorder
) {
    const GLint k = __glsEvalComputeK(inTarget);

    if (inUstride < k || inUorder < 0 || inVstride < k || inVorder < 0) {
        return 0;
    }
    return k * inUorder * inVorder;
}

GLint __gls_glMaterialfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_SHININESS:
            return 1;
        case GL_COLOR_INDEXES:
            return 3;
        case GL_AMBIENT:
        case GL_AMBIENT_AND_DIFFUSE:
        case GL_DIFFUSE:
        case GL_EMISSION:
        case GL_SPECULAR:
            return 4;
    }
    return 0;
}

GLint __gls_glMaterialiv_params_size(GLenum inPname) {
    return __gls_glMaterialfv_params_size(inPname);
}

GLint __gls_glPolygonStipple_mask_size(void) {
    return 128;
}

GLint __gls_glReadPixels_pixels_size(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    return __glsImageSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glTexEnvfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_TEXTURE_ENV_MODE:
            return 1;
        case GL_TEXTURE_ENV_COLOR:
            return 4;
    }
    return 0;
}

GLint __gls_glTexEnviv_params_size(GLenum inPname) {
    return __gls_glTexEnvfv_params_size(inPname);
}

GLint __gls_glTexGendv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_TEXTURE_GEN_MODE:
            return 1;
        case GL_EYE_PLANE:
        case GL_OBJECT_PLANE:
            return 4;
    }
    return 0;
}

GLint __gls_glTexGenfv_params_size(GLenum inPname) {
    return __gls_glTexGendv_params_size(inPname);
}

GLint __gls_glTexGeniv_params_size(GLenum inPname) {
    return __gls_glTexGendv_params_size(inPname);
}

GLint __gls_glTexImage1D_pixels_size(
    GLenum inFormat, GLenum inType, GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

GLint __gls_glTexImage2D_pixels_size(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    return __glsTextureSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glColorSubTableEXT_entries_size(
    GLenum inFormat, GLenum inType, GLint inCount
) {
    return __glsTextureSize(inFormat, inType, inCount, 1);
}

GLint __gls_glTexParameterfv_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_TEXTURE_MAG_FILTER:
        case GL_TEXTURE_MIN_FILTER:
        case GL_TEXTURE_WRAP_S:
        case GL_TEXTURE_WRAP_T:
            return 1;
        case GL_TEXTURE_BORDER_COLOR:
            return 4;
        #if __GL_SGIS_component_select
            case GL_TEXTURE_SS_SELECT_SGIS:
            case GL_TEXTURE_SSSS_SELECT_SGIS:
                return 1;
        #endif /* __GL_SGIS_component_select */
        #if __GL_SGIS_detail_texture
            case GL_DETAIL_TEXTURE_LEVEL_SGIS:
            case GL_DETAIL_TEXTURE_MODE_SGIS:
                return 1;
        #endif /* __GL_SGIS_detail_texture */
        #if __GL_EXT_texture_object
            case GL_TEXTURE_PRIORITY_EXT:
                return 1;
        #endif /* __GL_EXT_texture_object */
        #if __GL_EXT_texture3D
            case GL_TEXTURE_WRAP_R_EXT:
                return 1;
        #endif /* __GL_EXT_texture3D */
        #if __GL_SGIS_texture_lod
            case GL_TEXTURE_MIN_LOD_SGIS:
            case GL_TEXTURE_MAX_LOD_SGIS:
            case GL_TEXTURE_BASE_LEVEL_SGIS:
            case GL_TEXTURE_MAX_LEVEL_SGIS:
                return 1;
        #endif /* __GL_SGIS_texture_lod */
        #if __GL_SGIS_texture4D
            case GL_TEXTURE_WRAP_Q_SGIS:
                return 1;
        #endif /* __GL_SGIS_texture4D */
    }
    return 0;
}

GLint __gls_glTexParameteriv_params_size(GLenum inPname) {
    return __gls_glTexParameterfv_params_size(inPname);
}

GLint __gls_glsHeaderfv_inVec_size(GLenum inAttrib) {
    switch (inAttrib) {
        case GLS_ORIGIN:
        case GLS_PAGE_SIZE:
        case GLS_RED_POINT:
        case GLS_GREEN_POINT:
        case GLS_BLUE_POINT:
        case GLS_WHITE_POINT:
            return 2;
        case GLS_BORDER_COLOR:
        case GLS_GAMMA:
        case GLS_PAGE_COLOR:
            return 4;
    }
    return 0;
}

GLint __gls_glsHeaderiv_inVec_size(GLenum inAttrib) {
    switch (inAttrib) {
        case GLS_CREATE_TIME:
        case GLS_MODIFY_TIME:
            return 6;
    }
    return 0;
}

#if __GL_EXT_convolution

GLint __gls_glConvolutionFilter1DEXT_image_size(
    GLenum inFormat, GLenum inType, GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

GLint __gls_glConvolutionFilter2DEXT_image_size(
    GLenum inFormat, GLenum inType, GLint inWidth, GLint inHeight
) {
    return __glsTextureSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glConvolutionParameterfvEXT_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_CONVOLUTION_BORDER_MODE_EXT:
            return 1;
        case GL_CONVOLUTION_FILTER_SCALE_EXT:
        case GL_CONVOLUTION_FILTER_BIAS_EXT:
            return 4;
    }
    return 0;
}

GLint __gls_glConvolutionParameterivEXT_params_size(GLenum inPname) {
    return __gls_glConvolutionParameterfvEXT_params_size(inPname);
}

GLint __gls_glGetConvolutionFilterEXT_image_size(
    __GLScontext *ctx,
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    GLint width, height;

    switch (inTarget) {
        case GL_CONVOLUTION_1D_EXT:
        case GL_CONVOLUTION_2D_EXT:
            break;
        default:
            return 0;
    }
    width = height = 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    glGetConvolutionParameterivEXT(
        inTarget, GL_CONVOLUTION_WIDTH_EXT, &width
    );
    glGetConvolutionParameterivEXT(
        inTarget, GL_CONVOLUTION_HEIGHT_EXT, &height
    );
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    return __glsTextureSize(inFormat, inType, width, height);
}

GLint __gls_glGetConvolutionParameterfvEXT_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetConvolutionParameterivEXT_params_size(GLenum inPname) {
    return __gls_glGetConvolutionParameterfvEXT_params_size(inPname);
}

GLint __gls_glGetSeparableFilterEXT_row_size(
    __GLScontext *ctx,
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    GLint width = 0;

    if (inTarget != GL_SEPARABLE_2D_EXT) return 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    glGetConvolutionParameterivEXT(inTarget, GL_CONVOLUTION_WIDTH_EXT, &width);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    return __glsTextureSize(inFormat, inType, width, 1);
}

GLint __gls_glGetSeparableFilterEXT_column_size(
    __GLScontext *ctx,
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    GLint height = 0;

    if (inTarget != GL_SEPARABLE_2D_EXT) return 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    glGetConvolutionParameterivEXT(
        inTarget, GL_CONVOLUTION_HEIGHT_EXT, &height
    );
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetConvolutionParameterivEXT);
    return __glsTextureSize(inFormat, inType, 1, height);
}

GLint __gls_glGetSeparableFilterEXT_span_size(
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    return 0;
}

GLint __gls_glSeparableFilter2DEXT_row_size(
    GLenum inTarget, GLenum inFormat, GLenum inType, GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

GLint __gls_glSeparableFilter2DEXT_column_size(
    GLenum inTarget, GLenum inFormat, GLenum inType, GLint inHeight
) {
    return __glsTextureSize(inFormat, inType, 1, inHeight);
}

#endif /* __GL_EXT_convolution */

#if __GL_EXT_histogram

GLint __gls_glGetHistogramEXT_values_size(
    __GLScontext *ctx,
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    GLint width = 0;

    if (inTarget != GL_HISTOGRAM_EXT) return 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetHistogramParameterivEXT);
    glGetHistogramParameterivEXT(inTarget, GL_HISTOGRAM_WIDTH_EXT, &width);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetHistogramParameterivEXT);
    return __glsTextureSize(inFormat, inType, width, 1);
}

GLint __gls_glGetHistogramParameterfvEXT_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetHistogramParameterivEXT_params_size(GLenum inPname) {
    return __gls_glGetHistogramParameterfvEXT_params_size(inPname);
}

GLint __gls_glGetMinmaxEXT_values_size(
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    return __glsTextureSize(inFormat, inType, 2, 1);
}

GLint __gls_glGetMinmaxParameterfvEXT_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetMinmaxParameterivEXT_params_size(GLenum inPname) {
    return __gls_glGetMinmaxParameterfvEXT_params_size(inPname);
}

#endif /* __GL_EXT_histogram */

GLint __gls_glTexSubImage1D_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

GLint __gls_glTexSubImage2D_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight
) {
    return __glsTextureSize(inFormat, inType, inWidth, inHeight);
}

#if __GL_EXT_subtexture

GLint __gls_glTexSubImage1DEXT_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

GLint __gls_glTexSubImage2DEXT_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight
) {
    return __glsTextureSize(inFormat, inType, inWidth, inHeight);
}

GLint __gls_glTexSubImage3DEXT_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    GLint inDepth
) {
    if (inDepth < 0) return 0;
    return __glsTextureSize(inFormat, inType, inWidth, inHeight) * inDepth;
}

#endif /* __GL_EXT_subtexture */

#if __GL_EXT_texture3D
GLint __gls_glTexImage3DEXT_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    GLint inDepth
) {
    if (inDepth < 0) return 0;
    return __glsTextureSize(inFormat, inType, inWidth, inHeight) * inDepth;
}
#endif /* __GL_EXT_texture3D */

#if __GL_EXT_vertex_array

GLint __gls_glColorPointerEXT_pointer_size(
    GLint inSize, GLenum inType, GLint inStride, GLint inCount
) {
    if (inSize < 3 || inSize > 4) return 0;
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
            return inSize * inCount;
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
            return 2 * inSize * inCount;
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
            return 4 * inSize * inCount;
        case GL_DOUBLE_EXT:
            return 8 * inSize * inCount;
    }
    return 0;
}

GLint __gls_glEdgeFlagPointerEXT_pointer_size(
    GLint inStride, GLint inCount
) {
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    return inCount;
}

GLint __gls_glIndexPointerEXT_pointer_size(
    GLenum inType, GLint inStride, GLint inCount
) {
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_SHORT:
            return 2 * inCount;
        case GL_FLOAT:
        case GL_INT:
            return 4 * inCount;
        case GL_DOUBLE_EXT:
            return 8 * inCount;
    }
    return 0;
}

GLint __gls_glNormalPointerEXT_pointer_size(
    GLenum inType, GLint inStride, GLint inCount
) {
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_BYTE:
            return 3 * inCount;
        case GL_SHORT:
            return 2 * 3 * inCount;
        case GL_FLOAT:
        case GL_INT:
            return 4 * 3 * inCount;
        case GL_DOUBLE_EXT:
            return 8 * 3 * inCount;
    }
    return 0;
}

GLint __gls_glTexCoordPointerEXT_pointer_size(
    GLint inSize, GLenum inType, GLint inStride, GLint inCount
) {
    if (inSize < 1 || inSize > 4) return 0;
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_SHORT:
            return 2 * inSize * inCount;
        case GL_FLOAT:
        case GL_INT:
            return 4 * inSize * inCount;
        case GL_DOUBLE_EXT:
            return 8 * inSize * inCount;
    }
    return 0;
}

GLint __gls_glVertexPointerEXT_pointer_size(
    GLint inSize, GLenum inType, GLint inStride, GLint inCount
) {
    if (inSize < 2 || inSize > 4) return 0;
    if (inStride < 0) return 0;
    if (inCount < 0) return 0;
    switch (inType) {
        case GL_SHORT:
            return 2 * inSize * inCount;
        case GL_FLOAT:
        case GL_INT:
            return 4 * inSize * inCount;
        case GL_DOUBLE_EXT:
            return 8 * inSize * inCount;
    }
    return 0;
}

#endif /* __GL_EXT_vertex_array */

#if __GL_SGI_color_table

GLint __gls_glColorTableParameterfvSGI_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_COLOR_TABLE_BIAS_SGI:
        case GL_COLOR_TABLE_SCALE_SGI:
            return 4;
    }
    return 0;
}

GLint __gls_glColorTableParameterivSGI_params_size(GLenum inPname) {
    return __gls_glColorTableParameterfvSGI_params_size(inPname);
}

#endif // __GL_SGI_color_table

#if __GL_EXT_paletted_texture

GLint __gls_glColorTableEXT_table_size(
    GLenum inFormat, GLenum inType, GLint inWidth
) {
    return __glsTextureSize(inFormat, inType, inWidth, 1);
}

void glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params);
GLint __gls_glGetColorTableEXT_table_size(
    __GLScontext *ctx,
    GLenum inTarget, GLenum inFormat, GLenum inType
) {
    GLint width = 0;

    switch (inTarget) {
#if __GL_SGI_color_table
        case GL_COLOR_TABLE_SGI:
        case GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI:
        case GL_POST_CONVOLUTION_COLOR_TABLE_SGI:
#endif
        #if __GL_SGI_texture_color_table
            case GL_TEXTURE_COLOR_TABLE_SGI:
        #endif /* __GL_SGI_texture_color_table */
#if __GL_EXT_paletted_texture
    case GL_TEXTURE_1D:
    case GL_TEXTURE_2D:
    case GL_PROXY_TEXTURE_1D:
    case GL_PROXY_TEXTURE_2D:
#endif
            break;
        default:
            return 0;
    }
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetColorTableParameterivEXT);
    glGetColorTableParameterivEXT(inTarget, GL_COLOR_TABLE_WIDTH_EXT, &width);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetColorTableParameterivEXT);
    return __glsTextureSize(inFormat, inType, width, 1);
}

GLint __gls_glGetColorTableParameterfvEXT_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetColorTableParameterivEXT_params_size(GLenum inPname) {
    return __gls_glGetColorTableParameterfvEXT_params_size(inPname);
}

#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_texture_color_table

GLint __gls_glTexColorTableParameterfvSGI_params_size(GLenum inPname) {
    switch (inPname) {
        case GL_TEXTURE_COLOR_TABLE_BIAS_SGI:
        case GL_TEXTURE_COLOR_TABLE_SCALE_SGI:
            return 4;
    }
    return 0;
}

GLint __gls_glTexColorTableParameterivSGI_params_size(GLenum inPname) {
    return __gls_glTexColorTableParameterfvSGI_params_size(inPname);
}

GLint __gls_glGetTexColorTableParameterfvSGI_params_size(GLenum inPname) {
    switch (inPname) {
        default:
            return 16;
    }
}

GLint __gls_glGetTexColorTableParameterivSGI_params_size(GLenum inPname) {
    return __gls_glGetColorTableParameterfvSGI_params_size(inPname);
}

#endif /* __GL_SGI_texture_color_table */

#if __GL_SGIS_detail_texture
GLint __gls_glGetDetailTexFuncSGIS_points_size(__GLScontext *ctx, GLenum inTarget) {
    GLint points = 0;

    switch (inTarget) {
        case GL_TEXTURE_2D:
            break;
        default:
            return 0;
    }
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetTexParameteriv);
    glGetTexParameteriv(inTarget, GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS, &points);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetTexParameteriv);
    return points * 2;
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_sharpen_texture
GLint __gls_glGetSharpenTexFuncSGIS_points_size(__GLScontext *ctx, GLenum inTarget) {
    GLint points = 0;

    switch (inTarget) {
        case GL_TEXTURE_1D:
        case GL_TEXTURE_2D:
        #if __GL_EXT_texture3D
            case GL_TEXTURE_3D_EXT:
        #endif /* __GL_EXT_texture3D */
            break;
        default:
            return 0;
    }
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetTexParameteriv);
    glGetTexParameteriv(
        inTarget, GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS, &points
    );
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetTexParameteriv);
    return points * 2;
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_SGIS_texture4D

GLint __gls_glTexImage4DSGIS_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    GLint inDepth,
    GLint inSize4d
) {
    if (inDepth < 0 || inSize4d < 0) return 0;
    return (
        __glsTextureSize(inFormat, inType, inWidth, inHeight) *
        inDepth *
        inSize4d
    );
}

GLint __gls_glTexSubImage4DSGIS_pixels_size(
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    GLint inDepth,
    GLint inSize4d
) {
    if (inDepth < 0 || inSize4d < 0) return 0;
    return (
        __glsTextureSize(inFormat, inType, inWidth, inHeight) *
         inDepth *
         inSize4d
    );
}

#endif /* __GL_SGIS_texture4D */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\writebin.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <limits.h>
#include <stdlib.h>

/******************************************************************************
Helpers
******************************************************************************/

#define __GLS_PUT_BIN(inType, inSize) \
    __GLS_PUT_BIN_VAL(inType, inSize) \
    __GLS_PUT_BIN_VEC(inType, inSize) \
    __GLS_PUT_BIN_VECSTRIDE(inType, inSize)

#define __GLS_PUT_BIN_ENUM(inType, inEnum) \
    __GLS_PUT_BIN_ENUM_VAL(inType, inEnum) \
    __GLS_PUT_BIN_ENUM_VEC(inType, inEnum)

#define __GLS_PUT_BIN_SWAP(inType, inSize) \
    __GLS_PUT_BIN(inType, inSize) \
    __GLS_PUT_BIN_SWAP_VAL(inType, inSize) \
    __GLS_PUT_BIN_SWAP_VEC(inType, inSize) \
    __GLS_PUT_BIN_SWAP_VECSTRIDE(inType, inSize)

#define __GLS_PUT_BIN_ENUM_VAL(inType, inEnum) \
static void __glsWriter_put##inType##Or##inEnum##_bin( \
    __GLSwriter *inoutWriter, inEnum inParam, inType inVal \
) { \
    inoutWriter->put##inType(inoutWriter, inVal); \
}

#define __GLS_PUT_BIN_ENUM_VEC(inType, inEnum) \
static void __glsWriter_put##inType##Or##inEnum##v_bin( \
    __GLSwriter *inoutWriter, \
    inEnum inParam, \
    GLuint inCount, \
    const inType *inVec \
) { \
    inoutWriter->put##inType##v(inoutWriter, inCount, inVec); \
}

#define __GLS_PUT_BIN_SWAP_VAL(inType, inSize) \
static void __glsWriter_put##inType##_bin_swap( \
    __GLSwriter *inoutWriter, inType inVal \
) { \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += inSize; \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    *(inType *)bufPtr = inVal; \
    __glsSwap##inSize(bufPtr); \
}

#define __GLS_PUT_BIN_SWAP_VEC(inType, inSize) \
static void __glsWriter_put##inType##v_bin_swap( \
    __GLSwriter *inoutWriter, GLuint inCount, const inType *inVec \
) { \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += inSize * inCount; \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    while (inCount-- > 0) { \
        *(inType *)bufPtr = *inVec++; \
        __glsSwap##inSize(bufPtr); \
        bufPtr += inSize; \
    } \
}

#define __GLS_PUT_BIN_SWAP_VECSTRIDE(inType, inSize) \
static void __glsWriter_put##inType##vs_bin_swap( \
    __GLSwriter *inoutWriter, \
    GLboolean inItemSwap, \
    GLint inStride1DataItems, \
    GLint inStride1PadBytes, \
    GLint inStride1Count, \
    GLint inStride2PadBytes, \
    GLint inStride2Count, \
    const inType *inVec \
) { \
    GLint i, j; \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += ( \
        inSize * inStride1DataItems * inStride1Count * inStride2Count \
    ); \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    if (inItemSwap) while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, bufPtr += inSize) { \
                *(inType *)bufPtr = *inVec++; \
            } \
        } \
        inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
    } else  while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, bufPtr += inSize) { \
                *(inType *)bufPtr = *inVec++; \
                __glsSwap##inSize(bufPtr); \
            } \
        } \
        inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
    } \
}

#define __GLS_PUT_BIN_VAL(inType, inSize) \
static void __glsWriter_put##inType##_bin( \
    __GLSwriter *inoutWriter, inType inVal \
) { \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += inSize; \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    *(inType *)bufPtr = inVal; \
}

#define __GLS_PUT_BIN_VEC(inType, inSize) \
static void __glsWriter_put##inType##v_bin( \
    __GLSwriter *inoutWriter, GLuint inCount, const inType *inVec \
) { \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += inSize * inCount; \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    while (inCount-- > 0) { \
        *(inType *)bufPtr = *inVec++; \
        bufPtr += inSize; \
    } \
}

#define __GLS_PUT_BIN_VECSTRIDE(inType, inSize) \
static void __glsWriter_put##inType##vs_bin( \
    __GLSwriter *inoutWriter, \
    GLboolean inItemSwap, \
    GLint inStride1DataItems, \
    GLint inStride1PadBytes, \
    GLint inStride1Count, \
    GLint inStride2PadBytes, \
    GLint inStride2Count, \
    const inType *inVec \
) { \
    GLint i, j; \
    GLubyte *bufPtr = inoutWriter->bufPtr; \
    inoutWriter->bufPtr += ( \
        inSize * inStride1DataItems * inStride1Count * inStride2Count \
    ); \
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return; \
    if (inItemSwap) while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, bufPtr += inSize) { \
                *(inType *)bufPtr = *inVec++; \
                __glsSwap##inSize(bufPtr); \
            } \
        } \
        inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
    } else  while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, bufPtr += inSize) { \
                *(inType *)bufPtr = *inVec++; \
            } \
        } \
        inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
    } \
}

/******************************************************************************
Writers
******************************************************************************/

static GLboolean __glsWriter_alloc_bin(
    __GLSwriter *inoutWriter, size_t inWordCount
) {
    if (!__glsWriter_flush(inoutWriter)) return GL_FALSE;
    if (inoutWriter->bufPtr + inWordCount * 4 <= inoutWriter->bufTail) {
        return GL_TRUE;
    }
    free(inoutWriter->externBuf);
    if (inoutWriter->wordCount & 1) ++inWordCount;
    if (
        inoutWriter->externBuf = inoutWriter->externBufHead = __glsMalloc(
            inWordCount * 4
        )
    ) {
        if (inoutWriter->wordCount & 1) inoutWriter->externBufHead += 4;
        inoutWriter->bufPtr = inoutWriter->externBufHead;
        inoutWriter->bufTail = inoutWriter->externBuf + inWordCount * 4;
        return GL_TRUE;
    } else {
        inoutWriter->bufPtr = GLS_NONE;
        inoutWriter->bufTail = GLS_NONE;
        inoutWriter->error = GL_TRUE;
        return GL_FALSE;
    }
}

static GLboolean __glsWriter_alloc_context(
    __GLSwriter *inoutWriter, size_t inWordCount
) {
    __GLScontextStream *const stream = inoutWriter->contextStream;
    __GLScontextStreamBlock *const block = __glsContextStream_lastBlock(
        stream
    );
    const size_t fillBytes = (size_t)((ULONG_PTR)(inoutWriter->bufPtr - block->buf));
    const GLfloat fillFrac = (
        (GLfloat)(fillBytes + __GLS_JUMP_ALLOC) /
        (GLfloat)(block->bufTail - block->buf)
    );
    const size_t reqBytes = (inWordCount + 1) * 4 + __GLS_JUMP_ALLOC;

    __glsWriter_flush(inoutWriter);
    block->writeTail = inoutWriter->bufPtr;
    if (fillFrac < __GLS_FULL_CONTEXT_STREAM_BLOCK) {
        GLubyte *const buf = __glsMalloc(fillBytes + reqBytes);

        if (buf) {
            size_t i = fillBytes;
            __GLS_LIST_ITER(__GLScontextStreamBlock) iter;

            while (i-- > 0) buf[i] = block->buf[i];
            free(block->buf);
            block->buf = buf;
            block->bufTail = buf + fillBytes + reqBytes;
            block->writeTail = buf + fillBytes;
            inoutWriter->bufPtr = block->writeTail;
            inoutWriter->bufTail = block->bufTail - __GLS_JUMP_ALLOC;
            iter.elem = block;
            __GLS_LIST_PREV(&stream->blockList, &iter);
            if (iter.elem) {
                __glsContextStreamBlock_removeJump(iter.elem);
                __glsContextStreamBlock_addJump(iter.elem, buf);
            }
            return GL_TRUE;
        } else {
            inoutWriter->error = GL_TRUE;
            return GL_FALSE;
        }
    } else {
        __GLScontextStreamBlock *const newBlock = (
            __glsContextStream_appendBlock(
                stream, __GLS_MAX(__GLS_CONTEXT_STREAM_BLOCK_BYTES, reqBytes)
            )
        );

        if (newBlock) {
            if (inoutWriter->wordCount & 1) {
                __glsContextStreamBlock_addPad(newBlock);
            }
            inoutWriter->bufPtr = newBlock->writeTail;
            __glsContextStreamBlock_addJump(block, inoutWriter->bufPtr);
            inoutWriter->bufTail = newBlock->bufTail - __GLS_JUMP_ALLOC;
            return GL_TRUE;
        } else {
            inoutWriter->error = GL_TRUE;
            return GL_FALSE;
        }
    }
}

static GLboolean __glsWriter_beginCommand_bin(
    __GLSwriter *inoutWriter, GLSopcode inOpcode, size_t inByteCount
) {
    size_t wordCount = (inByteCount + 3) >> 2;
    GLboolean longForm;
    GLSopcode opcode;

    if (inoutWriter->error) return GL_FALSE;
    if (inoutWriter->type == GLS_CONTEXT) {
        opcode = __glsMapOpcode(inOpcode);
    } else {
        opcode = inOpcode;
    }
    longForm = (GLboolean)(
        opcode == GLS_OP_glsBeginGLS ||
        opcode == GLS_OP_glsEndGLS ||
        opcode >= 65536 ||
        wordCount >= 65535
    );
    wordCount += longForm ? 3 : 1;
    if (wordCount > UINT_MAX) {
        glsError(inOpcode, GLS_ENCODE_ERROR);
        return GL_FALSE;
    }
    if (
        inoutWriter->bufPtr + wordCount * 4 > inoutWriter->bufTail &&
        !inoutWriter->alloc(inoutWriter, wordCount)
    ) {
        return GL_FALSE;
    }
    inoutWriter->commandOpcode = inOpcode;
    inoutWriter->commandHead = inoutWriter->bufPtr;
    inoutWriter->commandTail = inoutWriter->bufPtr + wordCount * 4;
    inoutWriter->prevCommand = (
        (__GLSbinCommandHead_large *)inoutWriter->bufPtr
    );
    if (longForm) {
        inoutWriter->putGLushort(inoutWriter, GLS_NONE);
        inoutWriter->putGLushort(inoutWriter, 0);
        inoutWriter->putGLuint(inoutWriter, opcode);
        inoutWriter->putGLuint(inoutWriter, (GLuint)wordCount);
    } else {
        inoutWriter->putGLushort(inoutWriter, (GLushort)opcode);
        inoutWriter->putGLushort(inoutWriter, (GLushort)wordCount);
    }
    inoutWriter->wordCount += wordCount;
    return GL_TRUE;
}

static void __glsWriter_endCommand_bin(__GLSwriter *inoutWriter) {
    ptrdiff_t mod4 = ((ptrdiff_t)(inoutWriter->bufPtr - (GLubyte *)0)) & 3;

    if (mod4) while (mod4++ <  4) *inoutWriter->bufPtr++ = 0;
    if (inoutWriter->bufPtr != inoutWriter->commandTail) {
        inoutWriter->bufPtr = inoutWriter->commandHead;
        fprintf(
            stderr,
            "GLS encoder error on command %s\n",
            __glsOpcodeString[__glsMapOpcode(inoutWriter->commandOpcode)]
        );
        exit(EXIT_FAILURE);
    }
}

static void __glsWriter_nextList_bin(__GLSwriter *inoutWriter) {
}

static GLboolean __glsWriter_padWordCount_bin(
    __GLSwriter *inoutWriter, GLboolean inCountMod2
) {
    if (inoutWriter->error) return GL_FALSE;
    if ((inoutWriter->wordCount & 1) == inCountMod2) return GL_TRUE;
    if (inoutWriter->bufPtr + 4 > inoutWriter->bufTail) {
        if (!inoutWriter->alloc(inoutWriter, 1)) return GL_FALSE;
    }
    if (
        inoutWriter->prevCommand &&
        inoutWriter->prevCommand->opSmall &&
        inoutWriter->prevCommand->countSmall != USHRT_MAX
    ) {
        ++inoutWriter->prevCommand->countSmall;
        inoutWriter->commandTail += 4;
        inoutWriter->putGLuint(inoutWriter, 0);
        ++inoutWriter->wordCount;
        return GL_TRUE;
    } else  if (
        inoutWriter->prevCommand &&
        inoutWriter->prevCommand->opLarge != GLS_OP_glsBeginGLS &&
        inoutWriter->prevCommand->countLarge != ULONG_MAX
    ) {
        ++inoutWriter->prevCommand->countLarge;
        inoutWriter->commandTail += 4;
        inoutWriter->putGLuint(inoutWriter, 0);
        ++inoutWriter->wordCount;
        return GL_TRUE;
    } else {
        if (inoutWriter->beginCommand(inoutWriter, GLS_OP_glsPad, 0)) {
            inoutWriter->endCommand(inoutWriter);
            return GL_TRUE;
        } else {
            return GL_FALSE;
        }
    }
}

static GLboolean __glsWriter_padWordCount_bin_swap(
    __GLSwriter *inoutWriter, GLboolean inCountMod2
) {
    if (inoutWriter->error) return GL_FALSE;
    if ((inoutWriter->wordCount & 1) == inCountMod2) return GL_TRUE;
    if (inoutWriter->bufPtr + 4 > inoutWriter->bufTail) {
        if (!inoutWriter->alloc(inoutWriter, 1)) return GL_FALSE;
    }
    if (
        inoutWriter->prevCommand &&
        inoutWriter->prevCommand->opSmall &&
        inoutWriter->prevCommand->countSmall != USHRT_MAX
    ) {
        __glsSwap2(&inoutWriter->prevCommand->countSmall);
        ++inoutWriter->prevCommand->countSmall;
        __glsSwap2(&inoutWriter->prevCommand->countSmall);
        inoutWriter->commandTail += 4;
        inoutWriter->putGLuint(inoutWriter, 0);
        ++inoutWriter->wordCount;
        return GL_TRUE;
    } else  if (
        inoutWriter->prevCommand &&
        (
            __glsSwapi((GLint)inoutWriter->prevCommand->opLarge) !=
            GLS_OP_glsBeginGLS
        ) &&
        inoutWriter->prevCommand->countLarge != ULONG_MAX
    ) {
        __glsSwap4(&inoutWriter->prevCommand->countLarge);
        ++inoutWriter->prevCommand->countLarge;
        __glsSwap4(&inoutWriter->prevCommand->countLarge);
        inoutWriter->commandTail += 4;
        inoutWriter->putGLuint(inoutWriter, 0);
        ++inoutWriter->wordCount;
        return GL_TRUE;
    } else {
        if (inoutWriter->beginCommand(inoutWriter, GLS_OP_glsPad, 0)) {
            inoutWriter->endCommand(inoutWriter);
            return GL_TRUE;
        } else {
            return GL_FALSE;
        }
    }
}

static void __glsWriter_putGLbitvs_bin(
    __GLSwriter *inoutWriter,
    GLboolean inItemSwap,
    GLint inItemLeftShift,
    GLint inStrideDataItems,
    GLint inStridePadItems,
    GLint inStrideCount,
    const GLubyte *inVec
) {
    GLubyte *bufPtr = inoutWriter->bufPtr;
    GLint i;
    const GLint highShift = inItemLeftShift;
    const GLint lowShift = 8 - inItemLeftShift;
    GLubyte lastMask = 0xffu;
    
    if (inStrideDataItems & 7) lastMask <<= 8 - (inStrideDataItems & 7);
    inStrideDataItems = (inStrideDataItems + 7) >> 3;
    inStridePadItems >>= 3;
    inoutWriter->bufPtr += inStrideDataItems * inStrideCount;
    if (inoutWriter->bufPtr > inoutWriter->commandTail) return;
    if (!inItemSwap && !inItemLeftShift) while (inStrideCount-- > 0) {
        i = inStrideDataItems;
        while (i-- > 1) *bufPtr++ = *inVec++;
        if (!i) *bufPtr++ = (GLubyte)(*inVec++ & lastMask);
        inVec += inStridePadItems;
    } else if (!inItemLeftShift) while (inStrideCount-- > 0) {
        i = inStrideDataItems;
        while (i-- > 1) *bufPtr++ = __glsBitReverse[*inVec++];
        if (!i) *bufPtr++ = (GLubyte)(__glsBitReverse[*inVec++] & lastMask);
        inVec += inStridePadItems;
    } else if (!inItemSwap) while (inStrideCount-- > 0) {
        i = inStrideDataItems;
        while (i-- > 1) {
            *bufPtr++ = (GLubyte)(*inVec++ << highShift | *inVec >> lowShift);
        }
        if (!i) *bufPtr++ = (GLubyte)((*inVec++ & lastMask) << highShift);
        inVec += inStridePadItems;
    } else while (inStrideCount-- > 0) {
        i = inStrideDataItems;
        while (i-- > 1) *bufPtr++ = (GLubyte)(
            __glsBitReverse[*inVec++] << highShift |
            __glsBitReverse[*inVec] >> lowShift
        );
        if (!i) {
            *bufPtr++ = (GLubyte)(
                (__glsBitReverse[*inVec++] & lastMask) << highShift
            );
        }
        inVec += inStridePadItems;
    }
}

__GLS_PUT_BIN(GLbyte, 1)
__GLS_PUT_BIN(GLubyte, 1)
__GLS_PUT_BIN_ENUM(GLint, GLenum)
__GLS_PUT_BIN_ENUM(GLfloat, GLenum)
__GLS_PUT_BIN_ENUM(GLdouble, GLenum)
__GLS_PUT_BIN_ENUM_VAL(GLint, GLSenum)
__GLS_PUT_BIN_SWAP(GLshort, 2)
__GLS_PUT_BIN_SWAP(GLushort, 2)
__GLS_PUT_BIN_SWAP(GLint, 4)
__GLS_PUT_BIN_SWAP(GLuint, 4)
__GLS_PUT_BIN_SWAP(GLfloat, 4)
__GLS_PUT_BIN_SWAP(GLdouble, 8)
__GLS_PUT_BIN_SWAP_VAL(GLlong, 8)
__GLS_PUT_BIN_SWAP_VAL(GLulong, 8)
__GLS_PUT_BIN_SWAP_VEC(GLlong, 8)
__GLS_PUT_BIN_SWAP_VEC(GLulong, 8)
__GLS_PUT_BIN_VAL(GLlong, 8)
__GLS_PUT_BIN_VAL(GLulong, 8)
__GLS_PUT_BIN_VEC(GLlong, 8)
__GLS_PUT_BIN_VEC(GLulong, 8)

static void __glsWriter_putGLdoublem_bin(
    __GLSwriter *inoutWriter, const GLdouble *inMat
) {
    __glsWriter_putGLdoublev_bin(inoutWriter, 16, inMat);
}

static void __glsWriter_putGLdoublem_bin_swap(
    __GLSwriter *inoutWriter, const GLdouble *inMat
) {
    __glsWriter_putGLdoublev_bin_swap(inoutWriter, 16, inMat);
}

static void __glsWriter_putGLfloatm_bin(
    __GLSwriter *inoutWriter, const GLfloat *inMat
) {
    __glsWriter_putGLfloatv_bin(inoutWriter, 16, inMat);
}

static void __glsWriter_putGLfloatm_bin_swap(
    __GLSwriter *inoutWriter, const GLfloat *inMat
) {
    __glsWriter_putGLfloatv_bin_swap(inoutWriter, 16, inMat);
}

static void __glsWriter_putGLoutArg_bin(
    __GLSwriter *inoutWriter, GLuint inIndex, const GLvoid *inVal
) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    __glsWriter_putGLulong_bin(
        inoutWriter,
        (
            ctx->callNesting &&
            !ctx->commandFuncs[__glsMapOpcode(inoutWriter->commandOpcode)]
        ) ?
        ctx->outArgs.vals[inIndex] :
        __glsPtrToULong(inVal)
    );
}

static void __glsWriter_putGLoutArg_bin_swap(
    __GLSwriter *inoutWriter, GLuint inIndex, const GLvoid *inVal
) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    __glsWriter_putGLulong_bin_swap(
        inoutWriter,
        (
            ctx->callNesting &&
            !ctx->commandFuncs[__glsMapOpcode(inoutWriter->commandOpcode)]
        ) ?
        ctx->outArgs.vals[inIndex] :
        __glsPtrToULong(inVal)
    );
}

/******************************************************************************
Dispatch setup
******************************************************************************/

#define __GLS_INIT_PUT_BIN(inDst, inSrc) \
    __GLS_INIT_PUT_BIN_VAL(inDst, inSrc); \
    __GLS_INIT_PUT_BIN_VEC(inDst, inSrc); \
    __GLS_INIT_PUT_BIN_VECSTRIDE(inDst, inSrc);

#define __GLS_INIT_PUT_BIN_SWAP(inDst, inSrc) \
    __GLS_INIT_PUT_BIN_SWAP_VAL(inDst, inSrc); \
    __GLS_INIT_PUT_BIN_SWAP_VEC(inDst, inSrc); \
    __GLS_INIT_PUT_BIN_SWAP_VECSTRIDE(inDst, inSrc);

#define __GLS_INIT_PUT_BIN_SWAP_MAT(inDst, inSrc) \
    inoutWriter->put##inDst##m = ( \
        swap ? \
        __glsWriter_put##inSrc##m_bin_swap : __glsWriter_put##inSrc##m_bin \
    );

#define __GLS_INIT_PUT_BIN_SWAP_VAL(inDst, inSrc) \
    inoutWriter->put##inDst = ( \
        swap ? \
        __glsWriter_put##inSrc##_bin_swap : __glsWriter_put##inSrc##_bin \
    );

#define __GLS_INIT_PUT_BIN_SWAP_VEC(inDst, inSrc) \
    inoutWriter->put##inDst##v = ( \
        swap ? \
        __glsWriter_put##inSrc##v_bin_swap : __glsWriter_put##inSrc##v_bin \
    );

#define __GLS_INIT_PUT_BIN_SWAP_VECSTRIDE(inDst, inSrc) \
    inoutWriter->put##inDst##vs = ( \
        swap ? \
        __glsWriter_put##inSrc##vs_bin_swap : __glsWriter_put##inSrc##vs_bin \
    );

#define __GLS_INIT_PUT_BIN_VAL(inDst, inSrc) \
    inoutWriter->put##inDst = __glsWriter_put##inSrc##_bin;

#define __GLS_INIT_PUT_BIN_VEC(inDst, inSrc) \
    inoutWriter->put##inDst##v = __glsWriter_put##inSrc##v_bin;

#define __GLS_INIT_PUT_BIN_VECSTRIDE(inDst, inSrc) \
    inoutWriter->put##inDst##vs = __glsWriter_put##inSrc##vs_bin;

void __glsWriter_initDispatch_bin(
    __GLSwriter *inoutWriter, GLSenum inStreamType
) {
    const GLboolean swap = (GLboolean)(inStreamType == __GLS_BINARY_SWAP1);

    if (inStreamType == GLS_CONTEXT) {
        inoutWriter->alloc = __glsWriter_alloc_context;
    } else {
        inoutWriter->alloc = __glsWriter_alloc_bin;
    }
    inoutWriter->beginCommand = __glsWriter_beginCommand_bin;
    inoutWriter->endCommand = __glsWriter_endCommand_bin;
    inoutWriter->nextList = __glsWriter_nextList_bin;
    inoutWriter->padWordCount = (
        swap ? __glsWriter_padWordCount_bin_swap : __glsWriter_padWordCount_bin
    );
    __GLS_INIT_PUT_BIN(GLbyte, GLbyte);
    __GLS_INIT_PUT_BIN(GLubyte, GLubyte);
    __GLS_INIT_PUT_BIN_SWAP(GLdouble, GLdouble);
    __GLS_INIT_PUT_BIN_SWAP(GLfloat, GLfloat);
    __GLS_INIT_PUT_BIN_SWAP(GLint, GLint);
    __GLS_INIT_PUT_BIN_SWAP(GLshort, GLshort);
    __GLS_INIT_PUT_BIN_SWAP(GLuint, GLuint);
    __GLS_INIT_PUT_BIN_SWAP(GLushort, GLushort);
    __GLS_INIT_PUT_BIN_SWAP_MAT(GLdouble, GLdouble);
    __GLS_INIT_PUT_BIN_SWAP_MAT(GLfloat, GLfloat);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLSenum, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLSimageFlags, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLSopcode, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLattribMask, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLblendingFactor, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLclearBufferMask, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLdrawBufferMode, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLenum, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLlong, GLlong);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLoutArg, GLoutArg);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLstencilOp, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLtextureComponentCount, GLint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLuinthex, GLuint);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLulong, GLulong);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLulonghex, GLulong);
    __GLS_INIT_PUT_BIN_SWAP_VAL(GLushorthex, GLushort);
    __GLS_INIT_PUT_BIN_SWAP_VEC(GLlong, GLlong);
    __GLS_INIT_PUT_BIN_SWAP_VEC(GLulong, GLulong);
    __GLS_INIT_PUT_BIN_VAL(GLboolean, GLubyte);
    __GLS_INIT_PUT_BIN_VAL(GLdoubleOrGLenum, GLdoubleOrGLenum);
    __GLS_INIT_PUT_BIN_VAL(GLfloatOrGLenum, GLfloatOrGLenum);
    __GLS_INIT_PUT_BIN_VAL(GLintOrGLSenum, GLintOrGLSenum);
    __GLS_INIT_PUT_BIN_VAL(GLintOrGLenum, GLintOrGLenum);
    __GLS_INIT_PUT_BIN_VEC(GLboolean, GLubyte);
    __GLS_INIT_PUT_BIN_VEC(GLchar, GLubyte);
    __GLS_INIT_PUT_BIN_VEC(GLdoubleOrGLenum, GLdoubleOrGLenum);
    __GLS_INIT_PUT_BIN_VEC(GLfloatOrGLenum, GLfloatOrGLenum);
    __GLS_INIT_PUT_BIN_VEC(GLintOrGLenum, GLintOrGLenum);
    __GLS_INIT_PUT_BIN_VECSTRIDE(GLbit, GLbit);
    __GLS_INIT_PUT_BIN_VECSTRIDE(GLboolean, GLubyte);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\read.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

/******************************************************************************
__GLSreadStream
******************************************************************************/

__GLSreadStream* __glsReadStream_create(const GLubyte *inName) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSreadStream *const outStream = __glsCalloc(
        1, sizeof(__GLSreadStream)
    );

    if (!outStream) return GLS_NONE;
    __glsString_init(&outStream->name);
    outStream->unreadFunc = ctx->unreadFunc;
    if (inName[0]) {
        const GLubyte *openName;

        __GLS_ITERLIST_FIRST(&ctx->readPrefixList);
        while (ctx->readPrefixList.iterElem) {
            if (
                !__glsListString_prefix(
                    ctx->readPrefixList.iterElem, inName, &outStream->name
                ) ||
                !(openName = __glsUCS1String(outStream->name.head))
            ) {
                return __glsReadStream_destroy(outStream);
            }
            outStream->channel = fopen((const char *)openName, "rb");
            if (openName != outStream->name.head) free((GLvoid *)openName);
            if (outStream->channel) {
                setbuf(outStream->channel, GLS_NONE);
                outStream->opened = GL_TRUE;
                return outStream;
            }
            __GLS_ITERLIST_NEXT(&ctx->readPrefixList);
        }
        if (
            !__glsListString_prefix(
                ctx->writePrefix, inName, &outStream->name
            ) ||
            !(openName = __glsUCS1String(outStream->name.head))
        ) {
            return __glsReadStream_destroy(outStream);
        }
        outStream->channel = fopen((const char *)openName, "rb");
        if (openName != outStream->name.head) free((GLvoid *)openName);
        if (outStream->channel) {
            setbuf(outStream->channel, GLS_NONE);
            outStream->opened = GL_TRUE;
            return outStream;
        }
        return __glsReadStream_destroy(outStream);
    } else {
        outStream->readFunc = ctx->readFunc;
        if (!outStream->readFunc) outStream->channel = ctx->defaultReadChannel;
        return outStream;
    }
}

__GLSreadStream* __glsReadStream_destroy(__GLSreadStream *inStream) {
    if (!inStream) return GLS_NONE;

    if (inStream->opened && fclose(inStream->channel)) {
        __GLS_RAISE_ERROR(GLS_STREAM_CLOSE_ERROR);
    }
    __glsString_final(&inStream->name);
    free(inStream);
    return GLS_NONE;
}

GLbitfield __glsReadStream_getAttrib(const __GLSreadStream *inStream) {
    GLbitfield outVal = GLS_STREAM_READABLE_BIT;

    if (inStream->opened) {
        const GLubyte *const openName = __glsUCS1String(inStream->name.head);
        FILE *channel;

        if (!openName) return GLS_NONE;
        channel = fopen((const char *)openName, "ab");
        if (openName != inStream->name.head) free((GLvoid *)openName);
        if (channel) {
            fclose(channel);
            outVal |= GLS_STREAM_WRITABLE_BIT;
        }
        outVal |= GLS_STREAM_NAMED_BIT;
    }
    if (!fseek(inStream->channel, 0, SEEK_CUR)) {
        outVal |= GLS_STREAM_SEEKABLE_BIT;
    }
    return outVal;
}

size_t __glsReadStream_getByteCount(const __GLSreadStream *inStream) {
    long outVal;
    fpos_t pos;

    if (!inStream->channel) return 0;
    if (
        fgetpos(inStream->channel, &pos) ||
        fseek(inStream->channel, 0, SEEK_END)
    ) {
        return 0;
    }
    outVal = ftell(inStream->channel);
    fsetpos(inStream->channel, &pos);
    return outVal == -1L ? 0 : (size_t)outVal;
}

GLuint __glsReadStream_getCRC32(const __GLSreadStream *inStream) {
    GLubyte buf[__GLS_CHECKSUM_BUF_BYTES];
    size_t i, n;
    GLuint outVal = 0xffffffff;
    fpos_t pos;

    if (!inStream->channel) return 0;
    if (
        fgetpos(inStream->channel, &pos) ||
        fseek(inStream->channel, 0, SEEK_SET)
    ) {
        return 0;
    }
    while (n = fread(buf, 1, __GLS_CHECKSUM_BUF_BYTES, inStream->channel)) {
        for (i = 0 ; i < n ; ++i) __GLS_CRC32_STEP(outVal, buf[i]);
    }
    fsetpos(inStream->channel, &pos);
    if (ferror(inStream->channel)) {
        __GLS_RAISE_ERROR(GLS_STREAM_READ_ERROR);
        clearerr(inStream->channel);
        return 0;
    }
    return ~outVal;
}

GLSenum __glsReadStream_getType(const __GLSreadStream *inStream) {
    __GLSreader reader;

    if (!inStream->channel) return GLS_NONE;
    if (fseek(inStream->channel, 0, SEEK_CUR)) return GLS_UNKNOWN;
    if (__glsReader_init_stream(&reader, inStream, 256)) {
        const GLenum outType = reader.type;

        __glsReader_final(&reader);
        return outType;
    } else {
        return GLS_NONE;
    }
}

/******************************************************************************
__GLSreader
******************************************************************************/

GLvoid* __glsReader_allocCallBuf(
    __GLSreader *inoutReader, size_t inByteCount
) {
    GLvoid *outVal;

    if (inoutReader->error) return GLS_NONE;
    outVal = __glsMalloc(inByteCount);
    if (!outVal) __glsReader_raiseError(inoutReader, GLS_OUT_OF_MEMORY);
    return outVal;
}

GLvoid* __glsReader_allocFeedbackBuf(
    __GLSreader *inoutReader, size_t inByteCount
) {
    GLvoid *outVal;

    if (inoutReader->error) return GLS_NONE;
    outVal = __glsContext_allocFeedbackBuf(__GLS_CONTEXT, inByteCount);
    if (!outVal) __glsReader_raiseError(inoutReader, GLS_OUT_OF_MEMORY);
    return outVal;
}

GLvoid* __glsReader_allocSelectBuf(
    __GLSreader *inoutReader, size_t inByteCount
) {
    GLvoid *outVal;

    if (inoutReader->error) return GLS_NONE;
    outVal = __glsContext_allocSelectBuf(__GLS_CONTEXT, inByteCount);
    if (!outVal) __glsReader_raiseError(inoutReader, GLS_OUT_OF_MEMORY);
    return outVal;
}

#if __GL_EXT_vertex_array
GLvoid* __glsReader_allocVertexArrayBuf(
    __GLSreader *inoutReader, GLSopcode inOpcode, size_t inByteCount
) {
    GLvoid *outVal;

    if (inoutReader->error) return GLS_NONE;
    outVal = __glsContext_allocVertexArrayBuf(
        __GLS_CONTEXT, inOpcode, inByteCount
    );
    if (!outVal) __glsReader_raiseError(inoutReader, GLS_OUT_OF_MEMORY);
    return outVal;
}
#endif /* __GL_EXT_vertex_array */

void __glsReader_call(__GLSreader *inoutReader) {
    GLboolean callSave;
    __GLScontext *const ctx = __GLS_CONTEXT;

    callSave = ctx->contextCall;
    ctx->contextCall = GL_FALSE;
    while (inoutReader->type != GLS_NONE) {
#ifndef __GLS_PLATFORM_WIN32
        // DrewB
        ctx->dispatchDecode_bin[GLS_OP_glsBeginGLS](
            (GLubyte *)&inoutReader->version
        );
#else
        ctx->dispatchDecode_bin[GLS_OP_glsBeginGLS](
            ctx, (GLubyte *)&inoutReader->version
        );
#endif
        if (inoutReader->type == GLS_TEXT) {
            if (!__glsReader_call_text(inoutReader)) break;
            inoutReader->readHead = inoutReader->readPtr;
            __GLS_GET_SPACE(inoutReader);
        } else if (inoutReader->type == __GLS_BINARY_SWAP0) {
            if (!__glsReader_call_bin(inoutReader)) break;
            inoutReader->readHead = inoutReader->readPtr;
        } else {
            if (!__glsReader_call_bin_swap(inoutReader)) break;
            inoutReader->readHead = inoutReader->readPtr;
        }
#ifndef __GLS_PLATFORM_WIN32
        // DrewB
        ctx->dispatchDecode_bin[GLS_OP_glsEndGLS](GLS_NONE);
#else
        ctx->dispatchDecode_bin[GLS_OP_glsEndGLS](ctx, GLS_NONE);
#endif
        inoutReader->type = __glsReader_readBeginGLS_bin(
            inoutReader, &inoutReader->version
        );
        if (inoutReader->type == GLS_NONE) {
            inoutReader->type = __glsReader_readBeginGLS_text(
                inoutReader, &inoutReader->version
            );
        }
        if (inoutReader->type == GLS_NONE) {
            inoutReader->readPtr = inoutReader->readHead;
        }
        inoutReader->readHead = GLS_NONE;
    }
    ctx->contextCall = callSave;
}

__GLSreader* __glsReader_final(__GLSreader *inoutReader) {
    if (inoutReader && inoutReader->stream) {
        const ptrdiff_t excess = inoutReader->readTail - inoutReader->readPtr;
        if (excess > 0) {
            if (
                (
                    !inoutReader->stream->channel ||
                    fseek(
                        inoutReader->stream->channel,
                        -1 * (long)excess,
                        SEEK_CUR
                    )
                ) &&
                __GLS_CONTEXT->unreadFunc
            ) {
                __GLS_CONTEXT->unreadFunc(
                    (size_t)excess, inoutReader->readPtr
                );
            }
        }
        free(inoutReader->buf);
    }
    return GLS_NONE;
}

GLboolean __glsReader_fillBuf(
    __GLSreader *inoutReader, size_t inMinBytes, GLboolean inRealign
) {
    FILE *channel;
    size_t keepBytes, needBytes, padBytes, unreadBytes;
    GLubyte *ptr, *readHead;

    if (!inoutReader->readPtr || !inoutReader->stream) return GL_FALSE;
    readHead = (
        inoutReader->readHead ? inoutReader->readHead : inoutReader->readPtr
    );
    keepBytes = (size_t)((ULONG_PTR)(inoutReader->readPtr - readHead));
    unreadBytes = (size_t)((ULONG_PTR)(inoutReader->readTail - inoutReader->readPtr));
    if (inRealign) {
        padBytes = (size_t)((ULONG_PTR)(readHead - inoutReader->buf) & (__GLS_MAX_ALIGN_BYTES - 4));
    } else if (keepBytes % __GLS_MAX_ALIGN_BYTES) {
        padBytes = __GLS_MAX_ALIGN_BYTES - keepBytes % __GLS_MAX_ALIGN_BYTES;
    } else {
        padBytes = 0;
    }
    needBytes = padBytes + keepBytes + __GLS_MAX(inMinBytes, unreadBytes);
    if (needBytes > inoutReader->bufSize) {
        GLubyte *const buf = __glsMalloc(needBytes);

        if (!buf) goto eos;
        ptr = buf + padBytes;
        while (readHead < inoutReader->readTail) *ptr++ = *readHead++;
        free(inoutReader->buf);
        inoutReader->buf = buf;
        inoutReader->bufSize = needBytes;
    } else {
        ptr = inoutReader->buf + padBytes;
        if (ptr != readHead) memmove(ptr, readHead, keepBytes + unreadBytes);
    }
    readHead = inoutReader->buf + padBytes;
    if (inoutReader->readHead) inoutReader->readHead = readHead;
    inoutReader->readPtr = readHead + keepBytes;
    inoutReader->readTail = inoutReader->readPtr + unreadBytes;
    channel = inoutReader->stream->channel;
    for (;;) {
        if (
            (size_t)(inoutReader->readTail - inoutReader->readPtr) >=
            inMinBytes
        ) {
            return GL_TRUE;
        }
        ptr = inoutReader->readTail;
        if (channel) {
            inoutReader->readTail += fread(
                ptr,
                1,
                (size_t)((ULONG_PTR)(inoutReader->buf + inoutReader->bufSize - ptr)),
                channel
            );
            if (ferror(channel)) {
                __GLS_RAISE_ERROR(GLS_STREAM_READ_ERROR);
                clearerr(channel);
            }
        } else {
            inoutReader->readTail += inoutReader->stream->readFunc(
                (size_t)((ULONG_PTR)(inoutReader->buf + inoutReader->bufSize - ptr)), ptr
            );
        }
        if (inoutReader->readTail <= ptr) break;
    }
eos:
    inoutReader->readHead = GLS_NONE;
    inoutReader->readPtr = GLS_NONE;
    inoutReader->readTail = GLS_NONE;
    return GL_FALSE;
}

__GLSreader* __glsReader_init_array(
    __GLSreader *outReader, const GLubyte *inArray, size_t inCount
) {
    memset(outReader, 0, sizeof(__GLSreader));
    outReader->buf = (GLubyte *)inArray;
    outReader->bufSize = inCount;
    outReader->readPtr = outReader->buf;
    outReader->readTail = outReader->buf + inCount;
    return outReader;
}

__GLSreader* __glsReader_init_stream(
    __GLSreader *outReader, const __GLSreadStream *inStream, size_t inBufSize
) {
    memset(outReader, 0, sizeof(__GLSreader));
    outReader->stream = inStream;
    outReader->buf = __glsMalloc(inBufSize);
    if (!outReader->buf) return __glsReader_final(outReader);
    outReader->bufSize = inBufSize;
    outReader->readPtr = outReader->buf;
    outReader->readTail = outReader->buf;
    outReader->readHead = outReader->readPtr;
    outReader->type = __glsReader_readBeginGLS_bin(
        outReader, &outReader->version
    );
    if (outReader->type == GLS_NONE) {
        outReader->type = __glsReader_readBeginGLS_text(
            outReader, &outReader->version
        );
    }
    if (outReader->type == GLS_NONE) {
        outReader->readPtr = outReader->readHead;
        return __glsReader_final(outReader);
    }
    outReader->readHead = GLS_NONE;
    return outReader;
}

void __glsReader_raiseError(__GLSreader *inoutReader, GLSenum inError) {
    if (!inoutReader->error) inoutReader->error = inError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\writetxt.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <limits.h>
#include <locale.h>
#include <math.h>
#include <string.h>

/******************************************************************************
Helpers
******************************************************************************/

#define __GLS_ALLOC(inoutWriter, inReturn) \
    if ( \
        inoutWriter->bufPtr >= inoutWriter->bufTail && \
        !__glsWriter_flush(inoutWriter) \
    ) { \
        return inReturn; \
    }

#define __GLS_PARAM_SEP(inoutWriter) \
    if (inoutWriter->paramCount++) { \
        __GLS_PUT_CHAR(inoutWriter, ','); \
        __GLS_PUT_CHAR(inoutWriter, ' '); \
    }

#define __GLS_PARAM_SETUP(inoutWriter) \
    __GLS_ALLOC(inoutWriter, __GLS_NULL); \
    __GLS_PARAM_SEP(inoutWriter);

#define __GLS_PUT_BOOLEAN(inoutWriter, inVal) \
    if (!__glsWriter_putGLbooleanVal_text(inoutWriter, inVal)) { \
        __GLS_PUT_INT(inoutWriter, inVal); \
    }

#define __GLS_PUT_CHAR(inoutWriter, inChar) \
    *inoutWriter->bufPtr++ = inChar;

#define __GLS_PUT_DOUBLE(inoutWriter, inVal) \
    if (__GLS_FINITE(inVal)) { \
        __GLS_C_LOCALE_DECLARE; \
        __GLS_C_LOCALE_BEGIN; \
        __GLS_PUT_NUM(inoutWriter, "%.16g", inVal); \
        __GLS_C_LOCALE_END; \
    } else { \
        __GLS_PUT_HEX16(inoutWriter, *(const GLulong *)&(inVal)); \
    }

#define __GLS_PUT_DOUBLE17(inoutWriter, inVal) \
    if (__GLS_FINITE(inVal)) { \
        __GLS_C_LOCALE_DECLARE; \
        __GLS_C_LOCALE_BEGIN; \
        __GLS_PUT_NUM(inoutWriter, "%-17.16g", inVal); \
        __GLS_C_LOCALE_END; \
    } else { \
        __GLS_PUT_HEX16(inoutWriter, *(const GLulong *)&(inVal)); \
    }

#define __GLS_PUT_FLOAT(inoutWriter, inVal) \
    if (__GLS_FINITE((GLdouble)inVal)) { \
        __GLS_C_LOCALE_DECLARE; \
        __GLS_C_LOCALE_BEGIN; \
        __GLS_PUT_NUM(inoutWriter, "%.7g", inVal); \
        __GLS_C_LOCALE_END; \
    } else { \
        __GLS_PUT_HEX8(inoutWriter, *(const GLuint *)&(inVal)); \
    }

#define __GLS_PUT_FLOAT11(inoutWriter, inVal) \
    if (__GLS_FINITE((GLdouble)inVal)) { \
        __GLS_C_LOCALE_DECLARE; \
        __GLS_C_LOCALE_BEGIN; \
        __GLS_PUT_NUM(inoutWriter, "%-11.7g", inVal); \
        __GLS_C_LOCALE_END; \
    } else { \
        __GLS_PUT_HEX8(inoutWriter, *(const GLuint *)&(inVal)); \
    }

#define __GLS_PUT_HEX2(inoutWriter, inVal) \
    __GLS_PUT_NUM(inoutWriter, "0x%.2x", inVal);

#define __GLS_PUT_HEX4(inoutWriter, inVal) \
    __GLS_PUT_NUM(inoutWriter, "0x%.4x", inVal);

#define __GLS_PUT_HEX8(inoutWriter, inVal) \
    __GLS_PUT_NUM(inoutWriter, "0x%.8x", inVal);

#if __GLS_SPRINTF_INT64
    #define __GLS_PUT_HEX16(inoutWriter, inVal) \
        __GLS_PUT_NUM(inoutWriter, __GLS_OUT_FORMAT_INT64HEX, inVal);
#else /* !__GLS_SPRINTF_INT64 */
    #define __GLS_PUT_HEX16(inoutWriter, inVal) \
        __GLS_PUT_NUM( \
            inoutWriter, "0x%.8x", glsULongHigh(*(const GLulong *)&(inVal)) \
        ); \
        __GLS_PUT_NUM( \
            inoutWriter, "%.8x", glsULongLow(*(const GLulong *)&(inVal)) \
        );
#endif /* __GLS_SPRINTF_INT64 */

#define __GLS_PUT_INT(inoutWriter, inVal) \
    __GLS_PUT_NUM(inoutWriter, "%d", inVal);

#if __GLS_SPRINTF_INT64
    #define __GLS_PUT_LONG(inoutWriter, inVal) \
        __GLS_PUT_NUM(inoutWriter, __GLS_OUT_FORMAT_INT64, inVal);
#elif defined(__GLS_INT64_TO_STR)
    #define __GLS_PUT_LONG(inoutWriter, inVal) \
        inoutWriter->bufPtr += \
            strlen(__GLS_INT64_TO_STR(inVal, (char *)inoutWriter->bufPtr));
#else /* !__GLS_SPRINTF_INT64 && !defined(__GLS_INT64_TO_STR) */
    #define __GLS_PUT_LONG(inoutWriter, inVal) \
        __GLS_PUT_HEX16(inoutWriter, inVal);
#endif /* __GLS_SPRINTF_INT64 */

#define __GLS_PUT_NUM(inoutWriter, inFormat, inVal) \
    inoutWriter->bufPtr += sprintf( \
        (char *)inoutWriter->bufPtr, (const char *)(inFormat), inVal \
    );

#define __GLS_PUT_STRING(inoutWriter, inString) { \
    size_t __count = strlen((const char *)inString); \
    const GLubyte *ptr = glsCSTR(inString); \
    while (__count-- > 0) { \
        if (*ptr == '\\' || *ptr == '\"') *inoutWriter->bufPtr++ = '\\'; \
        *inoutWriter->bufPtr++ = *ptr++; \
    } \
}

#define __GLS_PUT_TEXT(inType, inSize, inCategory) \
    __GLS_PUT_TEXT_VAL(inType, inSize, inCategory) \
    __GLS_PUT_TEXT_VEC(inType, inSize, inCategory) \
    __GLS_PUT_TEXT_VECSTRIDE(inType, inSize, inCategory)

#define __GLS_PUT_TEXT_ENUM(inType, inEnum, inCategory) \
    __GLS_PUT_TEXT_ENUM_VAL(inType, inEnum, inCategory) \
    __GLS_PUT_TEXT_ENUM_VEC(inType, inEnum, inCategory)

#define __GLS_PUT_TEXT_ENUM_VAL(inType, inEnum, inCategory) \
static void __glsWriter_put##inType##Or##inEnum##_text( \
    __GLSwriter *inoutWriter, \
    GLenum inParam, \
    inType inVal \
) { \
    __GLS_PARAM_SETUP(inoutWriter); \
    if ( \
        !__GLS_FINITE((GLdouble)inVal) || \
        floor((GLdouble)inVal) != (GLdouble)inVal || \
        (GLdouble)inVal < 0. || \
        (GLdouble)inVal > (GLdouble)UINT_MAX || \
        !__glsWriter_put##inEnum##ParamVal_text( \
            inoutWriter, inParam, (inEnum)inVal \
        ) \
    ) { \
        __GLS_PUT_##inCategory(inoutWriter, inVal); \
    } \
}

#define __GLS_PUT_TEXT_ENUM_VEC(inType, inEnum, inCategory) \
static void __glsWriter_put##inType##Or##inEnum##v_text( \
    __GLSwriter *inoutWriter, \
    GLenum inParam, \
    GLuint inCount, \
    const inType *inVec \
) { \
    GLuint i; \
    const GLboolean multiLine = (GLboolean)(inCount > 4); \
    __GLS_PARAM_SETUP(inoutWriter); \
    __GLS_PUT_CHAR(inoutWriter, '{'); \
    for (i = 0 ; i < inCount ; ++i) { \
        __GLS_ALLOC(inoutWriter, __GLS_NULL); \
        if (i) __GLS_PUT_CHAR(inoutWriter, ','); \
        if (multiLine && !(i & 7)) { \
            __GLS_PUT_STRING(inoutWriter, "\n    "); \
        } else if (i) { \
            __GLS_PUT_CHAR(inoutWriter, ' '); \
        } \
        if ( \
            !__GLS_FINITE((GLdouble)inVec[i]) || \
            floor((GLdouble)inVec[i]) != (GLdouble)inVec[i] || \
            (GLdouble)inVec[i] < 0. || \
            (GLdouble)inVec[i] > (GLdouble)UINT_MAX || \
            !__glsWriter_put##inEnum##ParamVal_text( \
                inoutWriter, inParam, (inEnum)inVec[i] \
            ) \
        ) { \
            __GLS_PUT_##inCategory(inoutWriter, inVec[i]); \
        } \
    } \
    if (multiLine) __GLS_PUT_CHAR(inoutWriter, '\n'); \
    __GLS_PUT_CHAR(inoutWriter, '}'); \
}

#define __GLS_PUT_TEXT_MAT(inType, inCategory) \
static void __glsWriter_put##inType##m_text( \
    __GLSwriter *inoutWriter, \
    const inType *inMat \
) { \
    GLuint i, j; \
    __GLS_PARAM_SETUP(inoutWriter); \
    __GLS_PUT_CHAR(inoutWriter, '{'); \
    for (i = 0 ; i < 4 ; ++i) { \
        __GLS_ALLOC(inoutWriter, __GLS_NULL); \
        if (i) __GLS_PUT_CHAR(inoutWriter, ','); \
        __GLS_PUT_STRING(inoutWriter, "\n    "); \
        for (j = 0 ; j < 4 ; ++j) { \
            if (j) __GLS_PUT_STRING(inoutWriter, ", "); \
            __GLS_PUT_##inCategory(inoutWriter, inMat[i * 4 + j]); \
        } \
    } \
    __GLS_PUT_STRING(inoutWriter, "\n}"); \
}

#define __GLS_PUT_TEXT_VAL(inType, inSize, inCategory) \
static void __glsWriter_put##inType##_text( \
    __GLSwriter *inoutWriter, inType inVal \
) { \
    __GLS_PARAM_SETUP(inoutWriter); \
    __GLS_PUT_##inCategory(inoutWriter, inVal); \
}

#define __GLS_PUT_TEXT_VEC(inType, inSize, inCategory) \
static void __glsWriter_put##inType##v_text( \
    __GLSwriter *inoutWriter, \
    GLuint inCount, \
    const inType *inVec \
) { \
    GLuint i; \
    const GLboolean multiLine = (GLboolean)(inCount > 4); \
    __GLS_PARAM_SETUP(inoutWriter); \
    __GLS_PUT_CHAR(inoutWriter, '{'); \
    for (i = 0 ; i < inCount ; ++i) { \
        __GLS_ALLOC(inoutWriter, __GLS_NULL); \
        if (i) __GLS_PUT_CHAR(inoutWriter, ','); \
        if (multiLine && !(i & 7)) { \
            __GLS_PUT_STRING(inoutWriter, "\n    "); \
        } else if (i) { \
            __GLS_PUT_CHAR(inoutWriter, ' '); \
        } \
        __GLS_PUT_##inCategory(inoutWriter, inVec[i]); \
    } \
    if (multiLine) __GLS_PUT_CHAR(inoutWriter, '\n'); \
    __GLS_PUT_CHAR(inoutWriter, '}'); \
}

#define __GLS_PUT_TEXT_VECSTRIDE(inType, inSize, inCategory) \
static void __glsWriter_put##inType##vs_text( \
    __GLSwriter *inoutWriter, \
    GLboolean inItemSwap, \
    GLint inStride1DataItems, \
    GLint inStride1PadBytes, \
    GLint inStride1Count, \
    GLint inStride2PadBytes, \
    GLint inStride2Count, \
    const inType *inVec \
) { \
    GLint i, j, param = 0; \
    const GLboolean multiLine = (GLboolean)( \
        inStride1DataItems * inStride1Count * inStride2Count > 4 \
    ); \
    __GLS_PARAM_SETUP(inoutWriter); \
    __GLS_PUT_CHAR(inoutWriter, '{'); \
    if (inItemSwap) while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, ++param) { \
                inType val = *inVec++; \
                __GLS_ALLOC(inoutWriter, __GLS_NULL); \
                if (param) __GLS_PUT_CHAR(inoutWriter, ','); \
                if (multiLine && !(param & 7)) { \
                    __GLS_PUT_STRING(inoutWriter, "\n    "); \
                } else if (param) { \
                    __GLS_PUT_CHAR(inoutWriter, ' '); \
                } \
                __glsSwap##inSize(&val); \
                __GLS_PUT_##inCategory(inoutWriter, val); \
            } \
        } \
        inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
    } else while (inStride2Count-- > 0) { \
        for ( \
            i = 0 ; \
            i < inStride1Count ; \
            ++i, \
            inVec = \
            (const inType *)((const GLubyte *)inVec + inStride1PadBytes) \
        ) { \
            for (j = 0 ; j < inStride1DataItems ; ++j, ++param) { \
                inType val = *inVec++; \
                __GLS_ALLOC(inoutWriter, __GLS_NULL); \
                if (param) __GLS_PUT_CHAR(inoutWriter, ','); \
                if (multiLine && !(param & 7)) { \
                    __GLS_PUT_STRING(inoutWriter, "\n    "); \
                } else if (param) { \
                    __GLS_PUT_CHAR(inoutWriter, ' '); \
                } \
                __GLS_PUT_##inCategory(inoutWriter, val); \
            } \
       } \
       inVec = (const inType *)((const GLubyte *)inVec + inStride2PadBytes); \
     } \
    if (multiLine) __GLS_PUT_CHAR(inoutWriter, '\n'); \
    __GLS_PUT_CHAR(inoutWriter, '}'); \
}

#define __GLS_PUT_UNSIGNED_INT(inoutWriter, inVal) \
    __GLS_PUT_NUM(inoutWriter, "%u", inVal);

#if __GLS_SPRINTF_INT64
    #define __GLS_PUT_UNSIGNED_LONG(inoutWriter, inVal) \
        __GLS_PUT_NUM(inoutWriter, __GLS_OUT_FORMAT_INT64U, inVal);
#elif defined(__GLS_INT64U_TO_STR)
    #define __GLS_PUT_UNSIGNED_LONG(inoutWriter, inVal) \
        inoutWriter->bufPtr += \
            strlen(__GLS_INT64U_TO_STR(inVal, (char *)inoutWriter->bufPtr));
#else /* !__GLS_SPRINTF_INT64 && !defined(__GLS_INT64U_TO_STR) */
    #define __GLS_PUT_UNSIGNED_LONG(inoutWriter, inVal) \
        __GLS_PUT_HEX16(inoutWriter, inVal);
#endif /* __GLS_SPRINTF_INT64 */

__GLS_FORWARD static GLboolean __glsWriter_putGLbooleanVal_text(
    __GLSwriter *inoutWriter, GLboolean inVal
);

__GLS_FORWARD static GLboolean __glsWriter_putGLenumVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
);

__GLS_FORWARD static GLboolean __glsWriter_putGLstencilOpVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
);

__GLS_FORWARD static GLboolean __glsWriter_putGLtextureComponentCountVal_text(
    __GLSwriter *inoutWriter, GLint inVal
);

static void __glsWriter_putBitfield_text(
    __GLSwriter *inoutWriter,
    GLbitfield inBits,
    GLint inCount,
    const GLubyte *const inString[],
    const GLbitfield inVal[]
) {
    GLint i, putCount;

    __GLS_PARAM_SETUP(inoutWriter);
    for (i = 0 ; i < inCount ; ++i) {
        if (inBits == inVal[i]) {
            __GLS_PUT_STRING(inoutWriter, inString[i]);
            return;
        }
    }
    for (putCount = i = 0 ; i < inCount ; ++i) {
        if (inBits & inVal[i]) {
            inBits &= ~inVal[i];
            __GLS_ALLOC(inoutWriter, __GLS_NULL);
            if (putCount++) __GLS_PUT_STRING(inoutWriter, " | ");
            __GLS_PUT_STRING(inoutWriter, inString[i]);
        }
    }
    if (inBits) {
        __GLS_ALLOC(inoutWriter, __GLS_NULL);
        if (putCount) __GLS_PUT_STRING(inoutWriter, " | ");
        __GLS_PUT_HEX8(inoutWriter, inBits);
    }
}

static GLboolean __glsWriter_putGLSenumVal_text(
    __GLSwriter *inoutWriter, GLSenum inVal
) {
    const GLint page = __GLS_ENUM_PAGE(inVal);
    const GLint offset = __GLS_ENUM_OFFSET(inVal);

    if (
        page < __GLS_ENUM_PAGE_COUNT &&
        offset < __glsEnumStringCount[page] &&
        __glsEnumString[page][offset]
    ) {
        __GLS_PUT_STRING(inoutWriter, __glsEnumString[page][offset]);
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

static GLboolean __glsWriter_putGLSenumParamVal_text(
    __GLSwriter *inoutWriter, GLSenum inParam, GLSenum inVal
) {
    switch (inParam) {
        case GLS_DISPLAY_FORMAT:
            return __glsWriter_putGLSenumVal_text(inoutWriter, inVal);
        case GLS_DOUBLEBUFFER:
        case GLS_INVISIBLE:
        case GLS_STEREO:
        case GLS_TILEABLE:
        case GLS_TRANSPARENT:
            return (
                __glsWriter_putGLbooleanVal_text(inoutWriter, (GLboolean)inVal)
            );
        default:
            return GL_FALSE;
    }
}

static GLboolean __glsWriter_putGLblendingFactorVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    switch (inVal) {
        case GL_ZERO:
            __GLS_PUT_STRING(inoutWriter, "GL_ZERO");
            return GL_TRUE;
        case GL_ONE:
            __GLS_PUT_STRING(inoutWriter, "GL_ONE");
            return GL_TRUE;
        default:
            return __glsWriter_putGLenumVal_text(inoutWriter, inVal);
    }
}

static GLboolean __glsWriter_putGLbooleanVal_text(
    __GLSwriter *inoutWriter, GLboolean inVal
) {
    switch (inVal) {
        case GL_FALSE:
            __GLS_PUT_STRING(inoutWriter, "GL_FALSE");
            return GL_TRUE;
        case GL_TRUE:
            __GLS_PUT_STRING(inoutWriter, "GL_TRUE");
            return GL_TRUE;
        default:
            return GL_FALSE;
    }
}

static GLboolean __glsWriter_putGLdrawBufferModeVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    if (inVal) {
        return __glsWriter_putGLenumVal_text(inoutWriter, inVal);
    } else {
        __GLS_PUT_STRING(inoutWriter, "GL_NONE");
        return GL_TRUE;
    }
}

static GLboolean __glsWriter_putGLenumParamVal_text(
    __GLSwriter *inoutWriter, GLenum inParam, GLenum inVal
) {
    switch (inParam) {
        case GL_FOG_MODE:
        case GL_TEXTURE_ENV_MODE:
        case GL_TEXTURE_GEN_MODE:
        case GL_TEXTURE_MAG_FILTER:
        case GL_TEXTURE_MIN_FILTER:
        case GL_TEXTURE_WRAP_S:
        case GL_TEXTURE_WRAP_T:
        #if __GL_EXT_convolution
            case GL_CONVOLUTION_BORDER_MODE_EXT:
        #endif /* __GL_EXT_convolution */
        #if __GL_EXT_texture3D
            case GL_TEXTURE_WRAP_R_EXT:
        #endif /* __GL_EXT_texture3D */
        #if __GL_SGIS_component_select
            case GL_TEXTURE_SS_SELECT_SGIS:
            case GL_TEXTURE_SSSS_SELECT_SGIS:
        #endif /* __GL_SGIS_component_select */
        #if __GL_SGIS_detail_texture
            case GL_DETAIL_TEXTURE_MODE_SGIS:
        #endif /* __GL_SGIS_detail_texture */
        #if __GL_SGIS_texture4D
            case GL_TEXTURE_WRAP_Q_SGIS:
        #endif /* __GL_SGIS_texture4D */
        #if __GL_SGIX_sprite
            case GL_SPRITE_MODE_SGIX:
        #endif /* __GL_SGIX_sprite */
            return __glsWriter_putGLenumVal_text(inoutWriter, inVal);
        case GL_LIGHT_MODEL_LOCAL_VIEWER:
        case GL_LIGHT_MODEL_TWO_SIDE:
        case GL_MAP_COLOR:
        case GL_MAP_STENCIL:
        case GL_PACK_LSB_FIRST:
        case GL_PACK_SWAP_BYTES:
        case GL_UNPACK_LSB_FIRST:
        case GL_UNPACK_SWAP_BYTES:
            return (
                __glsWriter_putGLbooleanVal_text(inoutWriter, (GLboolean)inVal)
            );
        default:
            return GL_FALSE;
    }
}

static GLboolean __glsWriter_putGLenumVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    const GLint page = __GL_ENUM_PAGE(inVal);
    const GLint offset = __GL_ENUM_OFFSET(inVal);

    if (
        page < __GL_ENUM_PAGE_COUNT &&
        offset < __glEnumStringCount[page] &&
        __glEnumString[page][offset]
    ) {
        __GLS_PUT_STRING(inoutWriter, __glEnumString[page][offset]);
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

static GLboolean __glsWriter_putGLstencilOpVal_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    if (inVal) {
        return __glsWriter_putGLenumVal_text(inoutWriter, inVal);
    } else {
        __GLS_PUT_STRING(inoutWriter, "GL_ZERO");
        return GL_TRUE;
    }
}

static GLboolean __glsWriter_putGLtextureComponentCountVal_text(
    __GLSwriter *inoutWriter, GLint inVal
) {
    if (inVal > 4) {
        return __glsWriter_putGLenumVal_text(inoutWriter, inVal);
    } else {
        return GL_FALSE;
    }
}

typedef GLuint GLuinthex;
typedef GLulong GLulonghex;
typedef GLushort GLushorthex;

__GLS_PUT_TEXT(GLbyte, 1, INT)
__GLS_PUT_TEXT(GLubyte, 1, UNSIGNED_INT)
__GLS_PUT_TEXT(GLshort, 2, INT)
__GLS_PUT_TEXT(GLushort, 2, UNSIGNED_INT)
__GLS_PUT_TEXT(GLint, 4, INT)
__GLS_PUT_TEXT(GLuint, 4, UNSIGNED_INT)
__GLS_PUT_TEXT(GLfloat, 4, FLOAT)
__GLS_PUT_TEXT(GLdouble, 8, DOUBLE)
__GLS_PUT_TEXT_ENUM(GLfloat, GLenum, FLOAT)
__GLS_PUT_TEXT_ENUM(GLdouble, GLenum, DOUBLE)
__GLS_PUT_TEXT_ENUM(GLint, GLenum, INT)
__GLS_PUT_TEXT_ENUM_VAL(GLint, GLSenum, INT)
__GLS_PUT_TEXT_MAT(GLfloat, FLOAT11)
__GLS_PUT_TEXT_MAT(GLdouble, DOUBLE17)
__GLS_PUT_TEXT_VAL(GLlong, 8, LONG)
__GLS_PUT_TEXT_VAL(GLuinthex, 4, HEX8)
__GLS_PUT_TEXT_VAL(GLulong, 8, UNSIGNED_LONG)
__GLS_PUT_TEXT_VAL(GLulonghex, 8, HEX16)
__GLS_PUT_TEXT_VAL(GLushorthex, 2, HEX4)
__GLS_PUT_TEXT_VEC(GLboolean, 1, BOOLEAN)
__GLS_PUT_TEXT_VEC(GLlong, 8, LONG)
__GLS_PUT_TEXT_VEC(GLulong, 8, UNSIGNED_LONG)
__GLS_PUT_TEXT_VECSTRIDE(GLboolean, 1, BOOLEAN)

/******************************************************************************
Writers
******************************************************************************/

static GLboolean __glsWriter_beginCommand_text(
    __GLSwriter *inoutWriter, GLSopcode inOpcode, size_t inByteCount
) {
    if (!inoutWriter || inoutWriter->error) return GL_FALSE;
    __GLS_ALLOC(inoutWriter, GL_FALSE);
    inoutWriter->commandOpcode = inOpcode;
    inoutWriter->paramCount = 0;
    __GLS_PUT_STRING(inoutWriter, __glsOpcodeString[__glsMapOpcode(inOpcode)]);
    __GLS_PUT_CHAR(inoutWriter, '(');
    return GL_TRUE;
}

static void __glsWriter_endCommand_text(__GLSwriter *inoutWriter) {
    __GLS_ALLOC(inoutWriter, __GLS_NULL);
    __GLS_PUT_CHAR(inoutWriter, ')');
    __GLS_PUT_CHAR(inoutWriter, ';');
    __GLS_PUT_CHAR(inoutWriter, '\n');
}

static void __glsWriter_nextList_text(__GLSwriter *inoutWriter) {
    __GLS_ALLOC(inoutWriter, __GLS_NULL);
    __GLS_PUT_STRING(inoutWriter, ")(");
    inoutWriter->paramCount = 0;
}

static GLboolean __glsWriter_padWordCount_text(
    __GLSwriter *inoutWriter, GLboolean inCountMod2
) {
    return GL_TRUE;
}

static void __glsWriter_putGLSenum_text(
    __GLSwriter *inoutWriter, GLSenum inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLSenumVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLSimageFlags_text(
    __GLSwriter *inoutWriter, GLbitfield inVal
) {
    __glsWriter_putBitfield_text(
        inoutWriter,
        inVal,
        __GLS_IMAGE_FLAGS_COUNT,
        __glsImageFlagsString,
        __glsImageFlagsVal
    );
}

static void __glsWriter_putGLSopcode_text(
    __GLSwriter *inoutWriter, GLSopcode inVal
) {
    const GLSopcode opcode = __glsMapOpcode(inVal);

    __GLS_PARAM_SETUP(inoutWriter);
    if (
        opcode >= __GLS_OPCODES_PER_PAGE &&
        opcode < __GLS_OPCODE_COUNT &&
        __glsOpcodeString[opcode]
    ) {
        __GLS_PUT_STRING(inoutWriter, "GLS_OP_");
        __GLS_PUT_STRING(inoutWriter, __glsOpcodeString[opcode]);
    } else {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLattribMask_text(
    __GLSwriter *inoutWriter, GLbitfield inVal
) {
    __glsWriter_putBitfield_text(
        inoutWriter,
        inVal,
        __GL_ATTRIB_MASK_COUNT,
        __glAttribMaskString,
        __glAttribMaskVal
    );
}

static void __glsWriter_putGLbitvs_text(
    __GLSwriter *inoutWriter,
    GLboolean inItemSwap,
    GLint inItemLeftShift,
    GLint inStrideDataItems,
    GLint inStridePadItems,
    GLint inStrideCount,
    const GLubyte *inVec
) {
    GLint i, param = 0;
    const GLboolean multiLine = (GLboolean)(
        inStrideDataItems * inStrideCount / 8 > 4
    );
    const GLint highShift = inItemLeftShift;
    const GLint lowShift = 8 - inItemLeftShift;
    GLubyte lastMask = 0xffu;

    if (inStrideDataItems & 7) lastMask <<= 8 - (inStrideDataItems & 7);
    inStrideDataItems = (inStrideDataItems + 7) >> 3;
    inStridePadItems >>= 3;
    __GLS_PARAM_SETUP(inoutWriter);
    __GLS_PUT_CHAR(inoutWriter, '{');
    while (inStrideCount-- > 0) {
        GLubyte val;

        i = inStrideDataItems;
        while (i-- > 0) {
            if (inItemSwap) {
                val = __glsBitReverse[*inVec++];
                if (inItemLeftShift) {
                    if (i) {
                        val <<= highShift;
                        val |= __glsBitReverse[*inVec] >> lowShift;
                    } else {
                        val = (GLubyte)((val & lastMask) << highShift);
                    }
                } else if (!i) {
                    val &= lastMask;
                }
            } else {
                val = *inVec++;
                if (inItemLeftShift) {
                    if (i) {
                        val = (GLubyte)(val << highShift | *inVec >> lowShift);
                    } else {
                        val = (GLubyte)((val & lastMask) << highShift);
                    }
                } else if (!i) {
                    val &= lastMask;
                }
            }
            __GLS_ALLOC(inoutWriter, __GLS_NULL);
            if (param) __GLS_PUT_CHAR(inoutWriter, ',');
            if (multiLine && !(param & 7)) {
                __GLS_PUT_STRING(inoutWriter, "\n    ");
            } else if (param) {
                __GLS_PUT_CHAR(inoutWriter, ' ');
            }
            __GLS_PUT_HEX2(inoutWriter, val);
            ++param;
        }
        inVec += inStridePadItems;
    }
    if (multiLine) __GLS_PUT_CHAR(inoutWriter, '\n');
    __GLS_PUT_CHAR(inoutWriter, '}');
}

static void __glsWriter_putGLblendingFactor_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLblendingFactorVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLboolean_text(
    __GLSwriter *inoutWriter, GLboolean inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLbooleanVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLcharv_text(
    __GLSwriter *inoutWriter, GLuint inCount, const GLubyte *inString
) {
    size_t count = strlen((const char *)inString);
    const GLubyte *ptr = inString;

    __GLS_PARAM_SETUP(inoutWriter);
    __GLS_PUT_CHAR(inoutWriter, '"');
    while (count-- > 0) {
        __GLS_ALLOC(inoutWriter, __GLS_NULL);
        if (__GLS_CHAR_IS_GRAPHIC(*ptr)) {
            if (*ptr == '\\' || *ptr == '\"') *inoutWriter->bufPtr++ = '\\';
            *inoutWriter->bufPtr++ = *ptr++;
        } else {
            __GLS_PUT_NUM(inoutWriter, "\\x%.2x", *ptr++);
        }
    }
    __GLS_PUT_CHAR(inoutWriter, '"');
}

static void __glsWriter_putGLclearBufferMask_text(
    __GLSwriter *inoutWriter, GLbitfield inVal
) {
    __glsWriter_putGLattribMask_text(inoutWriter, inVal);
}

static void __glsWriter_putGLdrawBufferMode_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLdrawBufferModeVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLenum_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLenumVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLoutArg_text(
    __GLSwriter *inoutWriter, GLuint inIndex, const GLvoid *inVal
) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    __glsWriter_putGLulonghex_text(
        inoutWriter,
        (
            ctx->callNesting &&
            !ctx->commandFuncs[__glsMapOpcode(inoutWriter->commandOpcode)]
        ) ?
        ctx->outArgs.vals[inIndex] :
        __glsPtrToULong(inVal)
    );
}

static void __glsWriter_putGLstencilOp_text(
    __GLSwriter *inoutWriter, GLenum inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLstencilOpVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

static void __glsWriter_putGLtextureComponentCount_text(
    __GLSwriter *inoutWriter, GLint inVal
) {
    __GLS_PARAM_SETUP(inoutWriter);
    if (!__glsWriter_putGLtextureComponentCountVal_text(inoutWriter, inVal)) {
        __GLS_PUT_INT(inoutWriter, inVal);
    }
}

/******************************************************************************
Dispatch setup
******************************************************************************/

#define __GLS_INIT_PUT_TEXT(inType) \
    inoutWriter->put##inType = __glsWriter_put##inType##_text

void __glsWriter_initDispatch_text(__GLSwriter *inoutWriter) {
    inoutWriter->beginCommand = __glsWriter_beginCommand_text;
    inoutWriter->endCommand = __glsWriter_endCommand_text;
    inoutWriter->nextList = __glsWriter_nextList_text;
    inoutWriter->padWordCount = __glsWriter_padWordCount_text;
    __GLS_INIT_PUT_TEXT(GLSenum);
    __GLS_INIT_PUT_TEXT(GLSimageFlags);
    __GLS_INIT_PUT_TEXT(GLSopcode);
    __GLS_INIT_PUT_TEXT(GLattribMask);
    __GLS_INIT_PUT_TEXT(GLbitvs);
    __GLS_INIT_PUT_TEXT(GLblendingFactor);
    __GLS_INIT_PUT_TEXT(GLboolean);
    __GLS_INIT_PUT_TEXT(GLbooleanv);
    __GLS_INIT_PUT_TEXT(GLbooleanvs);
    __GLS_INIT_PUT_TEXT(GLbyte);
    __GLS_INIT_PUT_TEXT(GLbytev);
    __GLS_INIT_PUT_TEXT(GLbytevs);
    __GLS_INIT_PUT_TEXT(GLcharv);
    __GLS_INIT_PUT_TEXT(GLclearBufferMask);
    __GLS_INIT_PUT_TEXT(GLdouble);
    __GLS_INIT_PUT_TEXT(GLdoubleOrGLenum);
    __GLS_INIT_PUT_TEXT(GLdoubleOrGLenumv);
    __GLS_INIT_PUT_TEXT(GLdoublem);
    __GLS_INIT_PUT_TEXT(GLdoublev);
    __GLS_INIT_PUT_TEXT(GLdoublevs);
    __GLS_INIT_PUT_TEXT(GLdrawBufferMode);
    __GLS_INIT_PUT_TEXT(GLenum);
    __GLS_INIT_PUT_TEXT(GLfloat);
    __GLS_INIT_PUT_TEXT(GLfloatOrGLenum);
    __GLS_INIT_PUT_TEXT(GLfloatOrGLenumv);
    __GLS_INIT_PUT_TEXT(GLfloatm);
    __GLS_INIT_PUT_TEXT(GLfloatv);
    __GLS_INIT_PUT_TEXT(GLfloatvs);
    __GLS_INIT_PUT_TEXT(GLint);
    __GLS_INIT_PUT_TEXT(GLintOrGLSenum);
    __GLS_INIT_PUT_TEXT(GLintOrGLenum);
    __GLS_INIT_PUT_TEXT(GLintOrGLenumv);
    __GLS_INIT_PUT_TEXT(GLintv);
    __GLS_INIT_PUT_TEXT(GLintvs);
    __GLS_INIT_PUT_TEXT(GLlong);
    __GLS_INIT_PUT_TEXT(GLlongv);
    __GLS_INIT_PUT_TEXT(GLoutArg);
    __GLS_INIT_PUT_TEXT(GLshort);
    __GLS_INIT_PUT_TEXT(GLshortv);
    __GLS_INIT_PUT_TEXT(GLshortvs);
    __GLS_INIT_PUT_TEXT(GLstencilOp);
    __GLS_INIT_PUT_TEXT(GLtextureComponentCount);
    __GLS_INIT_PUT_TEXT(GLubyte);
    __GLS_INIT_PUT_TEXT(GLubytev);
    __GLS_INIT_PUT_TEXT(GLubytevs);
    __GLS_INIT_PUT_TEXT(GLuint);
    __GLS_INIT_PUT_TEXT(GLuinthex);
    __GLS_INIT_PUT_TEXT(GLuintv);
    __GLS_INIT_PUT_TEXT(GLuintvs);
    __GLS_INIT_PUT_TEXT(GLulong);
    __GLS_INIT_PUT_TEXT(GLulonghex);
    __GLS_INIT_PUT_TEXT(GLulongv);
    __GLS_INIT_PUT_TEXT(GLushort);
    __GLS_INIT_PUT_TEXT(GLushorthex);
    __GLS_INIT_PUT_TEXT(GLushortv);
    __GLS_INIT_PUT_TEXT(GLushortvs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\test\tcapture.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <GL/gls.h>

#if __GLS_PLATFORM_WIN32
    #include <fcntl.h>
    #include <io.h>
    #define __MAIN_LINKAGE __cdecl
#else /* !__GLS_PLATFORM_WIN32 */
    #define __MAIN_LINKAGE
#endif /* __GLS_PLATFORM_WIN32 */

static void configStdio(void) {
    setbuf(stdout, GLS_NONE);
    #if __GLS_PLATFORM_WIN32
        _setmode(_fileno(stdout), _O_BINARY);
        _setmode(_fileno(stderr), _O_BINARY);
    #endif /* __GLS_PLATFORM_WIN32 */
}

GLint __MAIN_LINKAGE main(const GLsizei inArgc, const GLubyte *inArgv[]) {
    configStdio();
    glsContext(glsGenContext());
    glsBeginCapture(glsCSTR(""), GLS_TEXT, GLS_NONE);
    glsComment(glsCSTR("GLS test"));
    glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
    glBegin(GL_POINTS);
    glVertex3f((GLfloat)1.3, (GLfloat)2.4, (GLfloat)5.6);
    glEnd();
    glsEndCapture();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\test\tcallarr.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <GL/gls.h>
#include <stdlib.h>

#if __GLS_PLATFORM_WIN32
    #include <fcntl.h>
    #include <io.h>
    #define __MAIN_LINKAGE __cdecl
#else /* !__GLS_PLATFORM_WIN32 */
    #define __MAIN_LINKAGE
#endif /* __GLS_PLATFORM_WIN32 */

static void configStdio(void) {
    setbuf(stdout, GLS_NONE);
    #if __GLS_PLATFORM_WIN32
        _setmode(_fileno(stdout), _O_BINARY);
        _setmode(_fileno(stderr), _O_BINARY);
    #endif /* __GLS_PLATFORM_WIN32 */
}

GLint __MAIN_LINKAGE main(const GLsizei inArgc, const GLubyte *inArgv[]) {
    GLubyte *array;
    size_t count;
    GLSenum streamType;

    configStdio();
    if (inArgc != 2) {
        fprintf(stderr, "usage: %s <streamName>\n", inArgv[0]);
        exit(EXIT_FAILURE);
    }
    glsContext(glsGenContext());
    streamType = glsGetStreamType(inArgv[1]);
    if (!streamType) {
        fprintf(stderr, "%s: invalid stream %s\n", inArgv[0], inArgv[1]);
        exit(EXIT_FAILURE);
    }
    count = glsGetStreamSize(inArgv[1]);
    if (!count) {
        fprintf(
            stderr,
            "%s: could not determine size of stream %s\n",
            inArgv[0],
            inArgv[1]
        );
        exit(EXIT_FAILURE);
    }
    array = (GLubyte *)malloc(count);
    if (!array) {
        fprintf(stderr, "%s: malloc(%u) failed\n", inArgv[0], count);
        exit(EXIT_FAILURE);
    }
    fread(array, 1, count, fopen((const char *)inArgv[1], "rb"));
    glsBeginCapture(glsCSTR(""), GLS_TEXT, GLS_NONE);
    glsCallArray(streamType, count, array);
    glsEndCapture();
    return EXIT_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\inc\glstring.h ===
/******************************Module*Header*******************************\
* Module Name: glstring.h
*
* String resource IDs.
*
* Created: 17-Feb-1994 15:54:45
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#ifndef _GLSTRING_H_
#define _GLSTRING_H_

#define STR_GLU_NO_ERROR                1
#define STR_GLU_INVALID_ENUM            2
#define STR_GLU_INVALID_VAL             3
#define STR_GLU_INVALID_OP              4
#define STR_GLU_STACK_OVER              5
#define STR_GLU_STACK_UNDER             6
#define STR_GLU_OUT_OF_MEM              7

#define STR_TESS_BEGIN_POLY             40
#define STR_TESS_BEGIN_CONTOUR          41
#define STR_TESS_END_POLY               42
#define STR_TESS_END_CONTOUR            43
#define STR_TESS_COORD_TOO_LARGE        44
#define STR_TESS_NEED_COMBINE_CALLBACK  45

#define STR_NURB_00             100
#define STR_NURB_01             101
#define STR_NURB_02             102
#define STR_NURB_03             103
#define STR_NURB_04             104
#define STR_NURB_05             105
#define STR_NURB_06             106
#define STR_NURB_07             107
#define STR_NURB_08             108
#define STR_NURB_09             109
#define STR_NURB_10             110
#define STR_NURB_11             111
#define STR_NURB_12             112
#define STR_NURB_13             113
#define STR_NURB_14             114
#define STR_NURB_15             115
#define STR_NURB_16             116
#define STR_NURB_17             117
#define STR_NURB_18             118
#define STR_NURB_19             119
#define STR_NURB_20             120
#define STR_NURB_21             121
#define STR_NURB_22             122
#define STR_NURB_23             123
#define STR_NURB_24             124
#define STR_NURB_25             125
#define STR_NURB_26             126
#define STR_NURB_27             127
#define STR_NURB_28             128
#define STR_NURB_29             129
#define STR_NURB_30             130
#define STR_NURB_31             131
#define STR_NURB_32             132
#define STR_NURB_33             133
#define STR_NURB_34             134
#define STR_NURB_35             135
#define STR_NURB_36             136
#define STR_NURB_37             137

extern char *pszGetResourceStringA(HINSTANCE hMod, UINT uiID);
extern WCHAR *pwszGetResourceStringW(HINSTANCE hMod, UINT uiID);
extern VOID vInitGluStrings(HINSTANCE hMod, BOOL bAnsi);
extern VOID vInitNurbStrings(HINSTANCE hMod, BOOL bAnsi);
extern VOID vInitTessStrings(HINSTANCE hMod, BOOL bAnsi);

#endif //_GLSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\test\tparser.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

#if __GLS_PLATFORM_WIN32
    #include <fcntl.h>
    #include <io.h>
    #define __MAIN_LINKAGE __cdecl
#else /* !__GLS_PLATFORM_WIN32 */
    #define __MAIN_LINKAGE
#endif /* __GLS_PLATFORM_WIN32 */

static void configStdio(void) {
    setbuf(stdout, GLS_NONE);
    #if __GLS_PLATFORM_WIN32
        _setmode(_fileno(stdout), _O_BINARY);
        _setmode(_fileno(stderr), _O_BINARY);
    #endif /* __GLS_PLATFORM_WIN32 */
}

GLint __MAIN_LINKAGE main(const GLsizei inArgc, const GLubyte *inArgv[]) {
    configStdio();
    __glsParser_print(__glsParser_create());
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\inc\winmem.h ===
#include <windows.h>

#define malloc(size)        gluAlloc((UINT)(size))
#define calloc(nobj, size)  gluCalloc((UINT)(nobj), (UINT)(size))
#define realloc(p, size)    gluReAlloc((HLOCAL)(p), (UINT)(size))
#define free(p)             LocalFree((HLOCAL)(p))

HLOCAL gluAlloc (UINT size);
HLOCAL gluCalloc (UINT nobj, UINT size);
HLOCAL gluReAlloc (HLOCAL p, UINT size);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\dict-lis.h ===
#ifndef __dict_list_h_
#define __dict_list_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

/* Use #define's so that another heap implementation can use this one */

#define DictKey		DictListKey
#define Dict		DictList
#define DictNode	DictListNode

#define dictNewDict(frame,leq)		__gl_dictListNewDict(frame,leq)
#define dictDeleteDict(dict)		__gl_dictListDeleteDict(dict)

#define dictSearch(dict,key)		__gl_dictListSearch(dict,key)
#define dictInsert(dict,key)		__gl_dictListInsert(dict,key)
#define dictInsertBefore(dict,node,key)	__gl_dictListInsertBefore(dict,node,key)
#define dictDelete(dict,node)		__gl_dictListDelete(dict,node)

#define dictKey(n)			__gl_dictListKey(n)
#define dictSucc(n)			__gl_dictListSucc(n)
#define dictPred(n)			__gl_dictListPred(n)
#define dictMin(d)			__gl_dictListMin(d)
#define dictMax(d)			__gl_dictListMax(d)



typedef void *DictKey;
typedef struct Dict Dict;
typedef struct DictNode DictNode;

Dict		*dictNewDict(
			void *frame,
			int (*leq)(void *frame, DictKey key1, DictKey key2) );
			
void		dictDeleteDict( Dict *dict );

/* Search returns the node with the smallest key greater than or equal
 * to the given key.  If there is no such key, returns a node whose
 * key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
 */
DictNode	*dictSearch( Dict *dict, DictKey key );
DictNode	*dictInsertBefore( Dict *dict, DictNode *node, DictKey key );
void		dictDelete( Dict *dict, DictNode *node );

#define		__gl_dictListKey(n)	((n)->key)
#define		__gl_dictListSucc(n)	((n)->next)
#define		__gl_dictListPred(n)	((n)->prev)
#define		__gl_dictListMin(d)	((d)->head.next)
#define		__gl_dictListMax(d)	((d)->head.prev)
#define	       __gl_dictListInsert(d,k) (dictInsertBefore((d),&(d)->head,(k)))


/*** Private data structures ***/

struct DictNode {
  DictKey	key;
  DictNode	*next;
  DictNode	*prev;
};

struct Dict {
  DictNode	head;
  void		*frame;
  int		(*leq)(void *frame, DictKey key1, DictKey key2);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\dict.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <stddef.h>
#ifdef NT
#include "dict-lis.h"
#else
#include "dict-list.h"
#endif
#include "memalloc.h"


Dict *dictNewDict( void *frame,
		   int (*leq)(void *frame, DictKey key1, DictKey key2) )
{
  Dict *dict = (Dict *) memAlloc( sizeof( Dict ));
  DictNode *head = &dict->head;

  head->key = NULL;
  head->next = head;
  head->prev = head;

  dict->frame = frame;
  dict->leq = leq;

  return dict;
}


void dictDeleteDict( Dict *dict )
{
  DictNode *node;

  for( node = dict->head.next; node != &dict->head; node = node->next ) {
    memFree( node );
  }
  memFree( dict );
}


DictNode *dictInsertBefore( Dict *dict, DictNode *node, DictKey key )
{
  DictNode *newNode;

  do {
    node = node->prev;
  } while( node->key != NULL && ! (*dict->leq)(dict->frame, node->key, key));

  newNode = (DictNode *) memAlloc( sizeof( DictNode ));
  newNode->key = key;
  newNode->next = node->next;
  node->next->prev = newNode;
  newNode->prev = node;
  node->next = newNode;

  return newNode;
}

void dictDelete( Dict *dict, DictNode *node ) /*ARGSUSED*/
{
  node->next->prev = node->prev;
  node->prev->next = node->next;
  memFree( node );
}

DictNode *dictSearch( Dict *dict, DictKey key )
{
  DictNode *node = &dict->head;

  do {
    node = node->next;
  } while( node->key != NULL && ! (*dict->leq)(dict->frame, key, node->key));

  return node;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\dict.h ===
#ifndef __dict_list_h_
#define __dict_list_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

/* Use #define's so that another heap implementation can use this one */

#define DictKey		DictListKey
#define Dict		DictList
#define DictNode	DictListNode

#define dictNewDict(frame,leq)		__gl_dictListNewDict(frame,leq)
#define dictDeleteDict(dict)		__gl_dictListDeleteDict(dict)

#define dictSearch(dict,key)		__gl_dictListSearch(dict,key)
#define dictInsert(dict,key)		__gl_dictListInsert(dict,key)
#define dictInsertBefore(dict,node,key)	__gl_dictListInsertBefore(dict,node,key)
#define dictDelete(dict,node)		__gl_dictListDelete(dict,node)

#define dictKey(n)			__gl_dictListKey(n)
#define dictSucc(n)			__gl_dictListSucc(n)
#define dictPred(n)			__gl_dictListPred(n)
#define dictMin(d)			__gl_dictListMin(d)
#define dictMax(d)			__gl_dictListMax(d)



typedef void *DictKey;
typedef struct Dict Dict;
typedef struct DictNode DictNode;

Dict		*dictNewDict(
			void *frame,
			int (*leq)(void *frame, DictKey key1, DictKey key2) );
			
void		dictDeleteDict( Dict *dict );

/* Search returns the node with the smallest key greater than or equal
 * to the given key.  If there is no such key, returns a node whose
 * key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
 */
DictNode	*dictSearch( Dict *dict, DictKey key );
DictNode	*dictInsertBefore( Dict *dict, DictNode *node, DictKey key );
void		dictDelete( Dict *dict, DictNode *node );

#define		__gl_dictListKey(n)	((n)->key)
#define		__gl_dictListSucc(n)	((n)->next)
#define		__gl_dictListPred(n)	((n)->prev)
#define		__gl_dictListMin(d)	((d)->head.next)
#define		__gl_dictListMax(d)	((d)->head.prev)
#define	       __gl_dictListInsert(d,k) (dictInsertBefore((d),&(d)->head,(k)))


/*** Private data structures ***/

struct DictNode {
  DictKey	key;
  DictNode	*next;
  DictNode	*prev;
};

struct Dict {
  DictNode	head;
  void		*frame;
  int		(*leq)(void *frame, DictKey key1, DictKey key2);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\mem-fast.h ===
#ifndef __memalloc_fast_h_
#define __memalloc_fast_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include "winmem.h"
#else
#include "malloc.h"
#endif

#define memAlloc	__gl_memAlloc
#define memRealloc	__gl_memRealloc
#define memFree		__gl_memFree
#define memInit		__gl_memInit

extern void *__gl_memAlloc( size_t );
extern void *__gl_memRealloc( void *, size_t );
extern void __gl_memFree( void * );
extern void __gl_memInit( size_t );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\mem-simp.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "memalloc.h"
#include "string.h"

int __gl_memInit( size_t maxFast )
{
#ifndef NO_MALLOPT
/*  mallopt( M_MXFAST, maxFast );*/
#ifdef MEMORY_DEBUG
  mallopt( M_DEBUG, 1 );
#endif
#endif
   return 1;
}

#ifdef MEMORY_DEBUG
void *__gl_memAlloc( size_t n )
{
  return memset( malloc( n ), 0xa5, n );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\mem-mf.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <stdio.h>
#include <glos.h>
#include <GL/gl.h>
#include "memalloc.h"
#include "string.h"

// mf!
//#define MF_DEBUG 1
#define MEM_DEBUG 1
#ifdef MEM_DEBUG
ULONG DbgPrint(PSZ Format, ...);
#include "\nt\private\windows\gdi\opengl\client\debug.h"
#endif

static GLuint  AllocCount = 0;
static GLuint  FreeCount = 0;
static BOOL    bFree = TRUE;
extern GLuint EdgeAlloc;
extern GLuint VertexAlloc;
extern GLuint FaceAlloc;
extern GLuint MeshAlloc;
extern GLuint RegionAlloc;
extern GLuint EdgeFree;
extern GLuint VertexFree;
extern GLuint FaceFree;
extern GLuint MeshFree;
extern GLuint RegionFree;

void mfmemInit( size_t maxFast )
{
#ifdef MF_DEBUG
    DBGPRINT1( "Init    %p\n", maxFast );
#endif
#ifndef NO_MALLOPT
  mallopt( M_MXFAST, maxFast );
#ifdef MEMORY_DEBUG
  mallopt( M_DEBUG, 1 );
#endif
#endif
//#ifdef MF_DEBUG
#if 1
    DBGPRINT2( "AllocCount = %d, FreeCount = %d\n", AllocCount, FreeCount );
    DBGPRINT2( "EdgeAlloc = %d, EdgeFree = %d\n", EdgeAlloc, EdgeFree );
    DBGPRINT2( "VertexAlloc = %d, VertexFree = %d\n", VertexAlloc, VertexFree );
    DBGPRINT2( "FaceAlloc = %d, FaceFree = %d\n", FaceAlloc, FaceFree );
    DBGPRINT2( "MeshAlloc = %d, MeshFree = %d\n", MeshAlloc, MeshFree );
    DBGPRINT2( "RegionAlloc = %d, RegionFree = %d\n", RegionAlloc, RegionFree );
#endif
    AllocCount = 0;
    FreeCount = 0;
    EdgeAlloc = EdgeFree = VertexAlloc = VertexFree = FaceAlloc = FaceFree = 0;
    MeshAlloc = MeshFree = 0;
    RegionAlloc = RegionFree = 0;
}

void *mfmemAlloc( size_t size )
{
    void *p;

    p = (void *) LocalAlloc(LMEM_FIXED, (UINT)(size));
#ifdef MF_DEBUG
    DBGPRINT2( "Alloc   %p, %d\n", p, size );
#endif
    AllocCount++;
    return p;
}

void *mfmemRealloc( void *p, size_t size )
{
    p = (void *) LocalReAlloc((HLOCAL)(p), (UINT)(size), LMEM_MOVEABLE);
#ifdef MF_DEBUG
    DBGPRINT2( "Realloc %p, %d\n", p, size );
#endif
    return p;
}

void mfmemFree( void *p )
{
#ifdef MF_DEBUG
    DBGPRINT1( "Free    %p\n", p );
#endif
    if( bFree )
        LocalFree((HLOCAL)(p));
    FreeCount++;
}

//mf: calloc not appear to be used
#if 0
#define calloc(nobj, size)  LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, (UINT)((nobj) * (size)))
#endif

/******************************Public*Routine******************************\
* DbgPrint()
*
*  go to the user mode debugger in checked builds
*
* Effects:
*
* Warnings:
*
* History:
*  09-Aug-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#if DBG

VOID DoRip(PSZ psz)
{
    DbgPrint("GDI Assertion Failure: ");
    DbgPrint(psz);
    DbgPrint("\n");
    DbgBreakPoint();
}


ULONG
DbgPrint(
    PCH DebugMessage,
    ...
    )
{
    va_list ap;
    char buffer[256];

    va_start(ap, DebugMessage);

    vsprintf(buffer, DebugMessage, ap);

    OutputDebugStringA(buffer);

    va_end(ap);

    return(0);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\geom.h ===
#ifndef __geom_h_
#define __geom_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "mesh.h"

#ifdef NO_BRANCH_CONDITIONS
/* MIPS architecture has special instructions to evaluate boolean
 * conditions -- more efficient than branching, IF you can get the
 * compiler to generate the right instructions (SGI compiler doesn't)
 */
#define VertEq(u,v)	(((u)->s == (v)->s) & ((u)->t == (v)->t))
#define VertLeq(u,v)	(((u)->s < (v)->s) | \
                         ((u)->s == (v)->s & (u)->t <= (v)->t))
#else
#define VertEq(u,v)	((u)->s == (v)->s && (u)->t == (v)->t)
#define VertLeq(u,v)	(((u)->s < (v)->s) || \
                         ((u)->s == (v)->s && (u)->t <= (v)->t))
#endif

#define EdgeEval(u,v,w)	__gl_edgeEval(u,v,w)
#define EdgeSign(u,v,w)	__gl_edgeSign(u,v,w)

/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */

#define TransLeq(u,v)	(((u)->t < (v)->t) || \
                         ((u)->t == (v)->t && (u)->s <= (v)->s))
#define TransEval(u,v,w)	__gl_transEval(u,v,w)
#define TransSign(u,v,w)	__gl_transSign(u,v,w)


#define EdgeGoesLeft(e)		VertLeq( (e)->Dst, (e)->Org )
#define EdgeGoesRight(e)	VertLeq( (e)->Org, (e)->Dst )

#define ABS(x)	((x) < 0 ? -(x) : (x))
#define VertL1dist(u,v)	(ABS(u->s - v->s) + ABS(u->t - v->t))

#define VertCCW(u,v,w)	__gl_vertCCW(u,v,w)

int		__gl_vertLeq( GLUvertex *u, GLUvertex *v );
GLdouble	__gl_edgeEval( GLUvertex *u, GLUvertex *v, GLUvertex *w );
GLdouble	__gl_edgeSign( GLUvertex *u, GLUvertex *v, GLUvertex *w );
GLdouble	__gl_transEval( GLUvertex *u, GLUvertex *v, GLUvertex *w );
GLdouble	__gl_transSign( GLUvertex *u, GLUvertex *v, GLUvertex *w );
int		__gl_vertCCW( GLUvertex *u, GLUvertex *v, GLUvertex *w );
void		__gl_edgeIntersect( GLUvertex *o1, GLUvertex *d1,
				    GLUvertex *o2, GLUvertex *d2,
				    GLUvertex *v );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\mem-mf.h ===
#ifndef __memalloc_simple_h_
#define __memalloc_simple_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
//#include "winmem.h"
#else
#include "malloc.h"
#endif

#include <windows.h>

// MF memory defines
#define memAlloc(size)        mfmemAlloc(size)
#if 0
//mf: calloc not appear to be used
#define calloc(nobj, size)  LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, (UINT)((nobj) * (size)))
#endif
#define memRealloc(p, size)   mfmemRealloc(p, size)
#define memFree(p)            mfmemFree(p) 
#define memInit(size)	      mfmemInit(size)	

// MF memory function externs
extern void mfmemInit( size_t maxFast );
extern void *mfmemAlloc( size_t size );
extern void *mfmemRealloc( void *p, size_t size );
extern void mfmemFree( void *p );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\errorstr.c ===
#include <glos.h>

#ifdef NT
#include "glstring.h"
#endif

#ifndef NT

static const char *errors[] = {
    "missing gluTessBeginPolygon",
    "missing gluTessBeginContour",
    "missing gluTessEndPolygon",
    "missing gluTessEndContour",
    "tesselation coordinate too large",
    "need combine callback"
};

#else

static UINT auiTessErrors[] = {
    STR_TESS_BEGIN_POLY           ,   // "missing gluTessBeginPolygon",
    STR_TESS_BEGIN_CONTOUR        ,   // "missing gluTessBeginContour",
    STR_TESS_END_POLY             ,   // "missing gluTessEndPolygon",
    STR_TESS_END_CONTOUR          ,   // "missing gluTessEndContour",
    STR_TESS_COORD_TOO_LARGE      ,   // "tesselation coordinate too large",
    STR_TESS_NEED_COMBINE_CALLBACK    // "need combine callback"
};

#define NERRORS ( sizeof(auiTessErrors)/sizeof(auiTessErrors[0]) )

static char *errors[NERRORS];
static WCHAR *errorsW[NERRORS];

#endif

const char *__glTessErrorString(int errno)
{
    return (const char *) errors[errno];
}


#ifdef NT

const WCHAR *__glTessErrorStringW(int errno)
{
    return (const WCHAR *) errorsW[errno];
}

VOID vInitTessStrings(HINSTANCE hMod, BOOL bAnsi)
{
    int i;

    if (bAnsi)
    {
        for (i = 0; i < NERRORS; i++)
            errors[i] = pszGetResourceStringA(hMod, auiTessErrors[i]);
    }
    else
    {
        for (i = 0; i < NERRORS; i++)
            errorsW[i] = pwszGetResourceStringW(hMod, auiTessErrors[i]);
    }
}

#endif /* NT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\geom.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <assert.h>
#include "mesh.h"
#include "geom.h"

int __gl_vertLeq( GLUvertex *u, GLUvertex *v )
{
  /* Returns TRUE if u is lexicographically <= v. */

  return VertLeq( u, v );
}

GLdouble __gl_edgeEval( GLUvertex *u, GLUvertex *v, GLUvertex *w )
{
  /* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
   * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
   * Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
   * If uw is vertical (and thus passes thru v), the result is zero.
   *
   * The calculation is extremely accurate and stable, even when v
   * is very close to u or w.  In particular if we set v->t = 0 and
   * let r be the negated result (this evaluates (uw)(v->s)), then
   * r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
   */
  GLdouble gapL, gapR;

  assert( VertLeq( u, v ) && VertLeq( v, w ));
  
  gapL = v->s - u->s;
  gapR = w->s - v->s;

  if( gapL + gapR > 0 ) {
    if( gapL < gapR ) {
      return (v->t - u->t) + (u->t - w->t) * (gapL / (gapL + gapR));
    } else {
      return (v->t - w->t) + (w->t - u->t) * (gapR / (gapL + gapR));
    }
  }
  /* vertical line */
  return 0;
}

GLdouble __gl_edgeSign( GLUvertex *u, GLUvertex *v, GLUvertex *w )
{
  /* Returns a number whose sign matches EdgeEval(u,v,w) but which
   * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
   * as v is above, on, or below the edge uw.
   */
  GLdouble gapL, gapR;

  assert( VertLeq( u, v ) && VertLeq( v, w ));
  
  gapL = v->s - u->s;
  gapR = w->s - v->s;

  if( gapL + gapR > 0 ) {
    return (v->t - w->t) * gapL + (v->t - u->t) * gapR;
  }
  /* vertical line */
  return 0;
}


/***********************************************************************
 * Define versions of EdgeSign, EdgeEval with s and t transposed.
 */

GLdouble __gl_transEval( GLUvertex *u, GLUvertex *v, GLUvertex *w )
{
  /* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),
   * evaluates the t-coord of the edge uw at the s-coord of the vertex v.
   * Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.
   * If uw is vertical (and thus passes thru v), the result is zero.
   *
   * The calculation is extremely accurate and stable, even when v
   * is very close to u or w.  In particular if we set v->s = 0 and
   * let r be the negated result (this evaluates (uw)(v->t)), then
   * r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).
   */
  GLdouble gapL, gapR;

  assert( TransLeq( u, v ) && TransLeq( v, w ));
  
  gapL = v->t - u->t;
  gapR = w->t - v->t;

  if( gapL + gapR > 0 ) {
    if( gapL < gapR ) {
      return (v->s - u->s) + (u->s - w->s) * (gapL / (gapL + gapR));
    } else {
      return (v->s - w->s) + (w->s - u->s) * (gapR / (gapL + gapR));
    }
  }
  /* vertical line */
  return 0;
}

GLdouble __gl_transSign( GLUvertex *u, GLUvertex *v, GLUvertex *w )
{
  /* Returns a number whose sign matches TransEval(u,v,w) but which
   * is cheaper to evaluate.  Returns > 0, == 0 , or < 0
   * as v is above, on, or below the edge uw.
   */
  GLdouble gapL, gapR;

  assert( TransLeq( u, v ) && TransLeq( v, w ));
  
  gapL = v->t - u->t;
  gapR = w->t - v->t;

  if( gapL + gapR > 0 ) {
    return (v->s - w->s) * gapL + (v->s - u->s) * gapR;
  }
  /* vertical line */
  return 0;
}


int __gl_vertCCW( GLUvertex *u, GLUvertex *v, GLUvertex *w )
{
  /* For almost-degenerate situations, the results are not reliable.
   * Unless the floating-point arithmetic can be performed without
   * rounding errors, *any* implementation will give incorrect results
   * on some degenerate inputs, so the client must have some way to
   * handle this situation.
   */
  return (u->s*(v->t - w->t) + v->s*(w->t - u->t) + w->s*(u->t - v->t)) >= 0;
}

/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
 * or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
 * this in the rare case that one argument is slightly negative.
 * The implementation is extremely stable numerically.
 * In particular it guarantees that the result r satisfies
 * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
 * even when a and b differ greatly in magnitude.
 */
#define RealInterpolate(a,x,b,y)			\
  (a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b,		\
  ((a <= b) ? ((b == 0) ? ((x+y) / 2)			\
                        : (x + (y-x) * (a/(a+b))))	\
            : (y + (x-y) * (b/(a+b)))))

#ifndef DEBUG
#define Interpolate(a,x,b,y)	RealInterpolate(a,x,b,y)
#else

/* Claim: the ONLY property the sweep algorithm relies on is that
 * MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.
 */
#include <stdlib.h>
extern int RandomInterpolate;

GLdouble Interpolate( GLdouble a, GLdouble x, GLdouble b, GLdouble y)
{
#ifndef NT
printf("*********************%d\n",RandomInterpolate);
#endif
  if( RandomInterpolate ) {
    a = 1.2 * drand48() - 0.1;
    a = (a < 0) ? 0 : ((a > 1) ? 1 : a);
    b = 1.0 - a;
  }
  return RealInterpolate(a,x,b,y);
}

#endif

#define Swap(a,b)	if (1) { GLUvertex *t = a; a = b; b = t; } else

void __gl_edgeIntersect( GLUvertex *o1, GLUvertex *d1,
			 GLUvertex *o2, GLUvertex *d2,
			 GLUvertex *v )
/* Given edges (o1,d1) and (o2,d2), compute their point of intersection.
 * The computed point is guaranteed to lie in the intersection of the
 * bounding rectangles defined by each edge.
 */
{
  GLdouble z1, z2;

  /* This is certainly not the most efficient way to find the intersection
   * of two line segments, but it is very numerically stable.
   *
   * Strategy: find the two middle vertices in the VertLeq ordering,
   * and interpolate the intersection s-value from these.  Then repeat
   * using the TransLeq ordering to find the intersection t-value.
   */

  if( ! VertLeq( o1, d1 )) { Swap( o1, d1 ); }
  if( ! VertLeq( o2, d2 )) { Swap( o2, d2 ); }
  if( ! VertLeq( o1, o2 )) { Swap( o1, o2 ); Swap( d1, d2 ); }

  if( ! VertLeq( o2, d1 )) {
    /* Technically, no intersection -- do our best */
    v->s = (o2->s + d1->s) / 2;
  } else if( VertLeq( d1, d2 )) {
    /* Interpolate between o2 and d1 */
    z1 = EdgeEval( o1, o2, d1 );
    z2 = EdgeEval( o2, d1, d2 );
    if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
    v->s = Interpolate( z1, o2->s, z2, d1->s );
  } else {
    /* Interpolate between o2 and d2 */
    z1 = EdgeSign( o1, o2, d1 );
    z2 = -EdgeSign( o1, d2, d1 );
    if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
    v->s = Interpolate( z1, o2->s, z2, d2->s );
  }

  /* Now repeat the process for t */

  if( ! TransLeq( o1, d1 )) { Swap( o1, d1 ); }
  if( ! TransLeq( o2, d2 )) { Swap( o2, d2 ); }
  if( ! TransLeq( o1, o2 )) { Swap( o1, o2 ); Swap( d1, d2 ); }

  if( ! TransLeq( o2, d1 )) {
    /* Technically, no intersection -- do our best */
    v->t = (o2->t + d1->t) / 2;
  } else if( TransLeq( d1, d2 )) {
    /* Interpolate between o2 and d1 */
    z1 = TransEval( o1, o2, d1 );
    z2 = TransEval( o2, d1, d2 );
    if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
    v->t = Interpolate( z1, o2->t, z2, d1->t );
  } else {
    /* Interpolate between o2 and d2 */
    z1 = TransSign( o1, o2, d1 );
    z2 = -TransSign( o1, d2, d1 );
    if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
    v->t = Interpolate( z1, o2->t, z2, d2->t );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\norm-sim.h ===
#ifndef __normal_h_
#define __normal_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "tess.h"

/* __gl_projectPolygon( tess ) determines the polygon normal
 * and project vertices onto the plane of the polygon.
 */
void __gl_projectPolygon( GLUtesselator *tess );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\mesh.h ===
#ifndef __mesh_h_
#define __mesh_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include <glos.h>
#endif
#include <GL/glu.h>

typedef struct GLUmesh GLUmesh;

typedef struct GLUvertex GLUvertex;
typedef struct GLUface GLUface;
typedef struct GLUhalfEdge GLUhalfEdge;

typedef struct ActiveRegion ActiveRegion;	/* Internal data */

/* The mesh structure is similar in spirit, notation, and operations
 * to the "quad-edge" structure (see L. Guibas and J. Stolfi, Primitives
 * for the manipulation of general subdivisions and the computation of
 * Voronoi diagrams, ACM Transactions on Graphics, 4(2):74-123, April 1985).
 * For a simplified description, see the course notes for CS348a,
 * "Mathematical Foundations of Computer Graphics", available at the
 * Stanford bookstore (and taught during the fall quarter).
 * The implementation also borrows a tiny subset of the graph-based approach
 * use in Mantyla's Geometric Work Bench (see M. Mantyla, An Introduction
 * to Sold Modeling, Computer Science Press, Rockville, Maryland, 1988).
 *
 * The fundamental data structure is the "half-edge".  Two half-edges
 * go together to make an edge, but they point in opposite directions.
 * Each half-edge has a pointer to its mate (the "symmetric" half-edge Sym),
 * its origin vertex (Org), the face on its left side (Lface), and the
 * adjacent half-edges in the CCW direction around the origin vertex
 * (Onext) and around the left face (Lnext).  There is also a "next"
 * pointer for the global edge list (see below).
 *
 * The notation used for mesh navigation:
 *	Sym   = the mate of a half-edge (same edge, but opposite direction)
 *	Onext = edge CCW around origin vertex (keep same origin)
 *	Dnext = edge CCW around destination vertex (keep same dest)
 *	Lnext = edge CCW around left face (dest becomes new origin)
 *	Rnext = edge CCW around right face (origin becomes new dest)
 *
 * "prev" means to substitute CW for CCW in the definitions above.
 *
 * The mesh keeps global lists of all vertices, faces, and edges,
 * stored as doubly-linked circular lists with a dummy header node.
 * The mesh stores pointers to these dummy headers (vHead, fHead, eHead).
 *
 * The circular edge list is special; since half-edges always occur
 * in pairs (e and e->Sym), each half-edge stores a pointer in only
 * one direction.  Starting at eHead and following the e->next pointers
 * will visit each *edge* once (ie. e or e->Sym, but not both).
 * e->Sym stores a pointer in the opposite direction, thus it is
 * always true that e->Sym->next->Sym->next == e.
 *
 * Each vertex has a pointer to next and previous vertices in the
 * circular list, and a pointer to a half-edge with this vertex as
 * the origin (NULL if this is the dummy header).  There is also a
 * field "data" for client data.
 *
 * Each face has a pointer to the next and previous faces in the
 * circular list, and a pointer to a half-edge with this face as
 * the left face (NULL if this is the dummy header).  There is also
 * a field "data" for client data.
 *
 * Note that what we call a "face" is really a loop; faces may consist
 * of more than one loop (ie. not simply connected), but there is no
 * record of this in the data structure.  The mesh may consist of
 * several disconnected regions, so it may not be possible to visit
 * the entire mesh by starting at a half-edge and traversing the edge
 * structure.
 *
 * The mesh does NOT support isolated vertices; a vertex is deleted along
 * with its last edge.  Similarly when two faces are merged, one of the
 * faces is deleted (see __gl_meshDelete below).  For mesh operations,
 * all face (loop) and vertex pointers must not be NULL.  However, once
 * mesh manipulation is finished, __gl_MeshZapFace can be used to delete
 * faces of the mesh, one at a time.  All external faces can be "zapped"
 * before the mesh is returned to the client; then a NULL face indicates
 * a region which is not part of the output polygon.
 */

struct GLUvertex {
  GLUvertex	*next;		/* next vertex (never NULL) */
  GLUvertex	*prev;		/* previous vertex (never NULL) */
  GLUhalfEdge	*anEdge;	/* a half-edge with this origin */
  void		*data;		/* client's data */

  /* Internal data (keep hidden) */
  GLdouble  coords[3];	/* vertex location in 3D */
  GLdouble  s, t;		/* projection onto the sweep plane */
  long		pqHandle;	/* to allow deletion from priority queue */
};

struct GLUface {
  GLUface	*next;		/* next face (never NULL) */
  GLUface	*prev;		/* previous face (never NULL) */
  GLUhalfEdge	*anEdge;	/* a half edge with this left face */
  void		*data;		/* room for client's data */

  /* Internal data (keep hidden) */
  GLUface	*trail;		/* "stack" for conversion to strips */
  GLboolean	marked;		/* flag for conversion to strips */
  GLboolean	inside;		/* this face is in the polygon interior */
};

struct GLUhalfEdge {
  GLUhalfEdge	*next;		/* doubly-linked list (prev==Sym->next) */
  GLUhalfEdge	*Sym;		/* same edge, opposite direction */
  GLUhalfEdge	*Onext;		/* next edge CCW around origin */
  GLUhalfEdge	*Lnext;		/* next edge CCW around left face */
  GLUvertex	*Org;		/* origin vertex (Overtex too long) */
  GLUface	*Lface;		/* left face */

  /* Internal data (keep hidden) */
  ActiveRegion	*activeRegion;	/* a region with this upper edge (sweep.c) */
  int		winding;	/* change in winding number when crossing
                                   from the right face to the left face */
};

#define	Rface	Sym->Lface
#define Dst	Sym->Org

#define Oprev	Sym->Lnext
#define Lprev   Onext->Sym
#define Dprev	Lnext->Sym
#define Rprev	Sym->Onext
#define Dnext	Rprev->Sym	/* 3 pointers */
#define Rnext	Oprev->Sym	/* 3 pointers */


struct GLUmesh {
  GLUvertex	vHead;		/* dummy header for vertex list */
  GLUface	fHead;		/* dummy header for face list */
  GLUhalfEdge	eHead;		/* dummy header for edge list */
  GLUhalfEdge	eHeadSym;	/* and its symmetric counterpart */
};

/* The mesh operations below have three motivations: completeness,
 * convenience, and efficiency.  The basic mesh operations are MakeEdge,
 * Splice, and Delete.  All the other edge operations can be implemented
 * in terms of these.  The other operations are provided for convenience
 * and/or efficiency.
 *
 * When a face is split or a vertex is added, they are inserted into the
 * global list *before* the existing vertex or face (ie. e->Org or e->Lface).
 * This makes it easier to process all vertices or faces in the global lists
 * without worrying about processing the same data twice.  As a convenience,
 * when a face is split, the "inside" flag is copied from the old face.
 * Other internal data (v->data, v->activeRegion, f->data, f->marked,
 * f->trail, e->winding) is set to zero.
 *
 * ********************** Basic Edge Operations **************************
 *
 * __gl_meshMakeEdge( mesh ) creates one edge, two vertices, and a loop.
 * The loop (face) consists of the two new half-edges.
 *
 * __gl_meshSplice( eOrg, eDst ) is the basic operation for changing the
 * mesh connectivity and topology.  It changes the mesh so that
 *	eOrg->Onext <- OLD( eDst->Onext )
 *	eDst->Onext <- OLD( eOrg->Onext )
 * where OLD(...) means the value before the meshSplice operation.
 *
 * This can have two effects on the vertex structure:
 *  - if eOrg->Org != eDst->Org, the two vertices are merged together
 *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
 * In both cases, eDst->Org is changed and eOrg->Org is untouched.
 *
 * Similarly (and independently) for the face structure,
 *  - if eOrg->Lface == eDst->Lface, one loop is split into two
 *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
 * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
 *
 * __gl_meshDelete( eDel ) removes the edge eDel.  There are several cases:
 * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
 * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
 * the newly created loop will contain eDel->Dst.  If the deletion of eDel
 * would create isolated vertices, those are deleted as well.
 *
 * ********************** Other Edge Operations **************************
 *
 * __gl_meshAddEdgeVertex( eOrg ) creates a new edge eNew such that
 * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
 * eOrg and eNew will have the same left face.
 *
 * __gl_meshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
 * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
 * eOrg and eNew will have the same left face.
 *
 * __gl_meshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
 * to eDst->Org, and returns the corresponding half-edge eNew.
 * If eOrg->Lface == eDst->Lface, this splits one loop into two,
 * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
 * loops are merged into one, and the loop eDst->Lface is destroyed.
 *
 * ************************ Other Operations *****************************
 *
 * __gl_meshNewMesh() creates a new mesh with no edges, no vertices,
 * and no loops (what we usually call a "face").
 *
 * __gl_meshUnion( mesh1, mesh2 ) forms the union of all structures in
 * both meshes, and returns the new mesh (the old meshes are destroyed).
 *
 * __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.
 *
 * __gl_meshZapFace( fZap ) destroys a face and removes it from the
 * global face list.  All edges of fZap will have a NULL pointer as their
 * left face.  Any edges which also have a NULL pointer as their right face
 * are deleted entirely (along with any isolated vertices this produces).
 * An entire mesh can be deleted by zapping its faces, one at a time,
 * in any order.  Zapped faces cannot be used in further mesh operations!
 *
 * __gl_meshCheckMesh( mesh ) checks a mesh for self-consistency.
 */

GLUhalfEdge	*__gl_meshMakeEdge( GLUmesh *mesh );
void		__gl_meshSplice( GLUhalfEdge *eOrg, GLUhalfEdge *eDst );
void		__gl_meshDelete( GLUhalfEdge *eDel );

GLUhalfEdge	*__gl_meshAddEdgeVertex( GLUhalfEdge *eOrg );
GLUhalfEdge	*__gl_meshSplitEdge( GLUhalfEdge *eOrg );
GLUhalfEdge	*__gl_meshConnect( GLUhalfEdge *eOrg, GLUhalfEdge *eDst );

GLUmesh		*__gl_meshNewMesh( void );
GLUmesh		*__gl_meshUnion( GLUmesh *mesh1, GLUmesh *mesh2 );
void		__gl_meshDeleteMesh( GLUmesh *mesh );
void		__gl_meshZapFace( GLUface *fZap );

#ifdef NDEBUG
#define		__gl_meshCheckMesh( mesh )
#else
void		__gl_meshCheckMesh( GLUmesh *mesh );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\normal.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "mesh.h"
#include "tess.h"
#include "normal.h"
#include <math.h>
#include <assert.h>

#define TRUE 1
#define FALSE 0

#define Dot(u,v)	(u[0]*v[0] + u[1]*v[1] + u[2]*v[2])

static void Normalize( GLdouble v[3] )
{
  GLdouble len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];

  assert( len > 0 );
  len = sqrt( len );
  v[0] /= len;
  v[1] /= len;
  v[2] /= len;
}

#define ABS(x)	((x) < 0 ? -(x) : (x))

static int LongAxis( GLdouble v[3] )
{
  int i = 0;

  if( ABS(v[1]) > ABS(v[0]) ) { i = 1; }
  if( ABS(v[2]) > ABS(v[i]) ) { i = 2; }
  return i;
}

static void ComputeNormal( GLUtesselator *tess, GLdouble norm[3] )
{
  GLUvertex *v, *v1, *v2;
  GLdouble c, tLen2, maxLen2;
  GLdouble maxVal[3], minVal[3], d1[3], d2[3], tNorm[3];
  GLUvertex *maxVert[3], *minVert[3];
  GLUvertex *vHead = &tess->mesh->vHead;
  int i;

  maxVal[0] = maxVal[1] = maxVal[2] = -2 * GLU_TESS_MAX_COORD;
  minVal[0] = minVal[1] = minVal[2] = 2 * GLU_TESS_MAX_COORD;

  for( v = vHead->next; v != vHead; v = v->next ) {
    for( i = 0; i < 3; ++i ) {
      c = v->coords[i];
      if( c < minVal[i] ) { minVal[i] = c; minVert[i] = v; }
      if( c > maxVal[i] ) { maxVal[i] = c; maxVert[i] = v; }
    }
  }

  /* Find two vertices separated by at least 1/sqrt(3) of the maximum
   * distance between any two vertices
   */
  i = 0;
  if( maxVal[1] - minVal[1] > maxVal[0] - minVal[0] ) { i = 1; }
  if( maxVal[2] - minVal[2] > maxVal[i] - minVal[i] ) { i = 2; }
  if( minVal[i] >= maxVal[i] ) {
    /* All vertices are the same -- normal doesn't matter */
    norm[0] = 0; norm[1] = 0; norm[2] = 1;
    return;
  }

  /* Look for a third vertex which forms the triangle with maximum area
   * (Length of normal == twice the triangle area)
   */
  maxLen2 = 0;
  v1 = minVert[i];
  v2 = maxVert[i];
  d1[0] = v1->coords[0] - v2->coords[0];
  d1[1] = v1->coords[1] - v2->coords[1];
  d1[2] = v1->coords[2] - v2->coords[2];
  for( v = vHead->next; v != vHead; v = v->next ) {
    d2[0] = v->coords[0] - v2->coords[0];
    d2[1] = v->coords[1] - v2->coords[1];
    d2[2] = v->coords[2] - v2->coords[2];
    tNorm[0] = d1[1]*d2[2] - d1[2]*d2[1];
    tNorm[1] = d1[2]*d2[0] - d1[0]*d2[2];
    tNorm[2] = d1[0]*d2[1] - d1[1]*d2[0];
    tLen2 = tNorm[0]*tNorm[0] + tNorm[1]*tNorm[1] + tNorm[2]*tNorm[2];
    if( tLen2 > maxLen2 ) {
      maxLen2 = tLen2;
      norm[0] = tNorm[0];
      norm[1] = tNorm[1];
      norm[2] = tNorm[2];
    }
  }

  if( maxLen2 <= 0 ) {
    /* All points lie on a single line -- any decent normal will do */
    norm[0] = norm[1] = norm[2] = 0;
    norm[LongAxis(d1)] = 1;
  }
}
  

static void CheckOrientation( GLUtesselator *tess )
{
  GLdouble area;
  GLUface *f, *fHead = &tess->mesh->fHead;
  GLUvertex *v, *vHead = &tess->mesh->vHead;
  GLUhalfEdge *e;

  /* When we compute the normal automatically, we choose the orientation
   * so that the the sum of the signed areas of all contours is non-negative.
   */
  area = 0;
  for( f = fHead->next; f != fHead; f = f->next ) {
    e = f->anEdge;
    if( e->winding <= 0 ) continue;
    do {
      area += (e->Org->s - e->Dst->s) * (e->Org->t + e->Dst->t);
      e = e->Lnext;
    } while( e != f->anEdge );
  }
  if( area < 0 ) {
    /* Reverse the orientation by flipping all the t-coordinates */
    for( v = vHead->next; v != vHead; v = v->next ) {
      v->t = - v->t;
    }
    tess->tUnit[0] = - tess->tUnit[0];
    tess->tUnit[1] = - tess->tUnit[1];
    tess->tUnit[2] = - tess->tUnit[2];
  }
}

#ifdef DEBUG
#include <stdlib.h>
extern int RandomSweep;
#define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
#define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
#else
#if defined(SLANTED_SWEEP) 
/* The "feature merging" is not intended to be complete.  There are
 * special cases where edges are nearly parallel to the sweep line
 * which are not implemented.  The algorithm should still behave
 * robustly (ie. produce a reasonable tesselation) in the presence
 * of such edges, however it may miss features which could have been
 * merged.  We could minimize this effect by choosing the sweep line
 * direction to be something unusual (ie. not parallel to one of the
 * coordinate axes).
 */
#define S_UNIT_X	0.50941539564955385	/* Pre-normalized */
#define S_UNIT_Y	0.86052074622010633
#else
#define S_UNIT_X	1.0
#define S_UNIT_Y	0.0
#endif
#endif

/* Determine the polygon normal and project vertices onto the plane
 * of the polygon.
 */
void __gl_projectPolygon( GLUtesselator *tess )
{
  GLUvertex *v, *vHead = &tess->mesh->vHead;
  GLdouble w, norm[3];
  GLdouble *sUnit, *tUnit;
  int i, computedNormal = FALSE;

  norm[0] = tess->normal[0];
  norm[1] = tess->normal[1];
  norm[2] = tess->normal[2];
  if( norm[0] == 0 && norm[1] == 0 && norm[2] == 0 ) {
    ComputeNormal( tess, norm );
    computedNormal = TRUE;
  }
  sUnit = tess->sUnit;
  tUnit = tess->tUnit;
  i = LongAxis( norm );

#if defined(DEBUG) || defined(TRUE_PROJECT)
  /* Choose the initial sUnit vector to be approximately perpendicular
   * to the normal.
   */
  Normalize( norm );

  sUnit[i] = 0;
  sUnit[(i+1)%3] = S_UNIT_X;
  sUnit[(i+2)%3] = S_UNIT_Y;

  /* Now make it exactly perpendicular */
  w = Dot( sUnit, norm );
  sUnit[0] -= w * norm[0];
  sUnit[1] -= w * norm[1];
  sUnit[2] -= w * norm[2];
  Normalize( sUnit );

  /* Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame */
  tUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];
  tUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];
  tUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];
  Normalize( tUnit );
#else
  /* Project perpendicular to a coordinate axis -- better numerically */
  sUnit[i] = 0;
  sUnit[(i+1)%3] = S_UNIT_X;
  sUnit[(i+2)%3] = S_UNIT_Y;
  
  tUnit[i] = 0;
  tUnit[(i+1)%3] = (norm[i] > 0) ? -S_UNIT_Y : S_UNIT_Y;
  tUnit[(i+2)%3] = (norm[i] > 0) ? S_UNIT_X : -S_UNIT_X;
#endif

  /* Project the vertices onto the sweep plane */
  for( v = vHead->next; v != vHead; v = v->next ) {
    v->s = Dot( v->coords, sUnit );
    v->t = Dot( v->coords, tUnit );
  }
  if( computedNormal ) {
    CheckOrientation( tess );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\mem-simp.h ===
#ifndef __memalloc_simple_h_
#define __memalloc_simple_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include "winmem.h"
#else
#include "malloc.h"
#endif

#define memRealloc	realloc
#define memFree		free

#define memInit		__gl_memInit
/*extern void		__gl_memInit( size_t );*/
extern int      __gl_memInit( size_t );

#ifndef MEMORY_DEBUG
#define memAlloc	malloc
#else
#define memAlloc	__gl_memAlloc
extern void *		__gl_memAlloc( size_t );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\mesh.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/


#include <assert.h>
#include "mesh.h"
#include "memalloc.h"

#define TRUE 1
#define FALSE 0

/************************ Utility Routines ************************/

/* Allocate and free half-edges in pairs for efficiency.
 * The *only* place that should use this fact is allocation/free.
 */
typedef struct { GLUhalfEdge e, eSym; } EdgePair;

/* MakeEdge creates a new pair of half-edges which form their own loop.
 * No vertex or face structures are allocated, but these must be assigned
 * before the current edge operation is completed.
 */
static GLUhalfEdge *MakeEdge( GLUhalfEdge *eNext )
{
  EdgePair *pair = (EdgePair *)memAlloc( sizeof( EdgePair ));
  GLUhalfEdge *e = &pair->e;
  GLUhalfEdge *eSym = &pair->eSym;
  GLUhalfEdge *ePrev;

  /* Make sure eNext points to the first edge of the edge pair */
  if( eNext->Sym < eNext ) { eNext = eNext->Sym; }

  /* Insert in circular doubly-linked list before eNext.
   * Note that the prev pointer is stored in Sym->next.
   */
  ePrev = eNext->Sym->next;
  eSym->next = ePrev;
  ePrev->Sym->next = e;
  e->next = eNext;
  eNext->Sym->next = eSym;

  e->Sym = eSym;
  e->Onext = e;
  e->Lnext = eSym;
  e->Org = NULL;
  e->Lface = NULL;
  e->winding = 0;
  e->activeRegion = NULL;

  eSym->Sym = e;
  eSym->Onext = eSym;
  eSym->Lnext = e;
  eSym->Org = NULL;
  eSym->Lface = NULL;
  eSym->winding = 0;
  eSym->activeRegion = NULL;

  return e;
}

/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
 * CS348a notes (see mesh.h).  Basically it modifies the mesh so that
 * a->Onext and b->Onext are exchanged.  This can have various effects
 * depending on whether a and b belong to different face or vertex rings.
 * For more explanation see __gl_meshSplice() below.
 */
static void Splice( GLUhalfEdge *a, GLUhalfEdge *b )
{
  GLUhalfEdge *aOnext = a->Onext;
  GLUhalfEdge *bOnext = b->Onext;

  aOnext->Sym->Lnext = b;
  bOnext->Sym->Lnext = a;
  a->Onext = bOnext;
  b->Onext = aOnext;
}

/* MakeVertex( eOrig, vNext ) creates a new vertex and makes it the origin
 * of all edges in the vertex loop to which eOrig belongs.  "vNext" gives
 * a place to insert the new vertex in the global vertex list.  We insert
 * the new vertex *before* vNext so that algorithms which walk the vertex
 * list will not see the newly created vertices.
 */
static void MakeVertex( GLUhalfEdge *eOrig, GLUvertex *vNext )
{
  GLUvertex *vNew = (GLUvertex *)memAlloc( sizeof( GLUvertex ));
  GLUhalfEdge *e;
  GLUvertex *vPrev;

  /* insert in circular doubly-linked list before vNext */
  vPrev = vNext->prev;
  vNew->prev = vPrev;
  vPrev->next = vNew;
  vNew->next = vNext;
  vNext->prev = vNew;

  vNew->anEdge = eOrig;
  vNew->data = NULL;
  /* leave coords, s, t undefined */

  /* fix other edges on this vertex loop */
  e = eOrig;
  do {
    e->Org = vNew;
    e = e->Onext;
  } while( e != eOrig );
}

/* MakeFace( eOrig, fNext ) creates a new face and makes it the left face
 * of all edges in the face loop to which eOrig belongs.  "fNext" gives
 * a place to insert the new face in the global face list.  We insert
 * the new face *before* fNext so that algorithms which walk the face
 * list will not see the newly created faces.
 */
static void MakeFace( GLUhalfEdge *eOrig, GLUface *fNext )
{
  GLUface *fNew = (GLUface *)memAlloc( sizeof( GLUface ));
  GLUhalfEdge *e;
  GLUface *fPrev;

  /* insert in circular doubly-linked list before fNext */
  fPrev = fNext->prev;
  fNew->prev = fPrev;
  fPrev->next = fNew;
  fNew->next = fNext;
  fNext->prev = fNew;

  fNew->anEdge = eOrig;
  fNew->data = NULL;
  fNew->trail = NULL;
  fNew->marked = FALSE;

  /* The new face is marked "inside" if the old one was.  This is a
   * convenience for the common case where a face has been split in two.
   */
  fNew->inside = fNext->inside;

  /* fix other edges on this face loop */
  e = eOrig;
  do {
    e->Lface = fNew;
    e = e->Lnext;
  } while( e != eOrig );
}

/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
 * and removes from the global edge list.
 */
static void KillEdge( GLUhalfEdge *eDel )
{
  GLUhalfEdge *ePrev, *eNext;

  /* Half-edges are allocated in pairs, see EdgePair above */
  if( eDel->Sym < eDel ) { eDel = eDel->Sym; }

  /* delete from circular doubly-linked list */
  eNext = eDel->next;
  ePrev = eDel->Sym->next;
  eNext->Sym->next = ePrev;
  ePrev->Sym->next = eNext;

  memFree( eDel );
}


/* KillVertex( vDel ) destroys a vertex and removes it from the global
 * vertex list.  It updates the vertex loop to point to a given new vertex.
 */
static void KillVertex( GLUvertex *vDel, GLUvertex *newOrg )
{
  GLUhalfEdge *e, *eStart = vDel->anEdge;
  GLUvertex *vPrev, *vNext;

  /* change the origin of all affected edges */
  e = eStart;
  do {
    e->Org = newOrg;
    e = e->Onext;
  } while( e != eStart );

  /* delete from circular doubly-linked list */
  vPrev = vDel->prev;
  vNext = vDel->next;
  vNext->prev = vPrev;
  vPrev->next = vNext;

  memFree( vDel );
}

/* KillFace( fDel ) destroys a face and removes it from the global face
 * list.  It updates the face loop to point to a given new face.
 */
static void KillFace( GLUface *fDel, GLUface *newLface )
{
  GLUhalfEdge *e, *eStart = fDel->anEdge;
  GLUface *fPrev, *fNext;

  /* change the left face of all affected edges */
  e = eStart;
  do {
    e->Lface = newLface;
    e = e->Lnext;
  } while( e != eStart );

  /* delete from circular doubly-linked list */
  fPrev = fDel->prev;
  fNext = fDel->next;
  fNext->prev = fPrev;
  fPrev->next = fNext;

  memFree( fDel );
}


/****************** Basic Edge Operations **********************/

/* __gl_meshMakeEdge creates one edge, two vertices, and a loop (face).
 * The loop consists of the two new half-edges.
 */
GLUhalfEdge *__gl_meshMakeEdge( GLUmesh *mesh )
{
  GLUhalfEdge *e = MakeEdge( &mesh->eHead );

  MakeVertex( e, &mesh->vHead );
  MakeVertex( e->Sym, &mesh->vHead );
  MakeFace( e, &mesh->fHead );
  return e;
}
  

/* __gl_meshSplice( eOrg, eDst ) is the basic operation for changing the
 * mesh connectivity and topology.  It changes the mesh so that
 *	eOrg->Onext <- OLD( eDst->Onext )
 *	eDst->Onext <- OLD( eOrg->Onext )
 * where OLD(...) means the value before the meshSplice operation.
 *
 * This can have two effects on the vertex structure:
 *  - if eOrg->Org != eDst->Org, the two vertices are merged together
 *  - if eOrg->Org == eDst->Org, the origin is split into two vertices
 * In both cases, eDst->Org is changed and eOrg->Org is untouched.
 *
 * Similarly (and independently) for the face structure,
 *  - if eOrg->Lface == eDst->Lface, one loop is split into two
 *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
 * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
 *
 * Some special cases:
 * If eDst == eOrg, the operation has no effect.
 * If eDst == eOrg->Lnext, the new face will have a single edge.
 * If eDst == eOrg->Lprev, the old face will have a single edge.
 * If eDst == eOrg->Onext, the new vertex will have a single edge.
 * If eDst == eOrg->Oprev, the old vertex will have a single edge.
 */
void __gl_meshSplice( GLUhalfEdge *eOrg, GLUhalfEdge *eDst )
{
  int joiningLoops = FALSE;
  int joiningVertices = FALSE;

  if( eOrg == eDst ) return;

  if( eDst->Org != eOrg->Org ) {
    /* We are merging two disjoint vertices -- destroy eDst->Org */
    joiningVertices = TRUE;
    KillVertex( eDst->Org, eOrg->Org );
  }
  if( eDst->Lface != eOrg->Lface ) {
    /* We are connecting two disjoint loops -- destroy eDst->Lface */
    joiningLoops = TRUE;
    KillFace( eDst->Lface, eOrg->Lface );
  }

  /* Change the edge structure */
  Splice( eDst, eOrg );

  if( ! joiningVertices ) {
    /* We split one vertex into two -- the new vertex is eDst->Org.
     * Make sure the old vertex points to a valid half-edge.
     */
    MakeVertex( eDst, eOrg->Org );
    eOrg->Org->anEdge = eOrg;
  }
  if( ! joiningLoops ) {
    /* We split one loop into two -- the new loop is eDst->Lface.
     * Make sure the old face points to a valid half-edge.
     */
    MakeFace( eDst, eOrg->Lface );
    eOrg->Lface->anEdge = eOrg;
  }
}


/* __gl_meshDelete( eDel ) removes the edge eDel.  There are several cases:
 * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
 * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
 * the newly created loop will contain eDel->Dst.  If the deletion of eDel
 * would create isolated vertices, those are deleted as well.
 *
 * This function could be implemented as two calls to __gl_meshSplice
 * plus a few calls to memFree, but this would allocate and delete
 * unnecessary vertices and faces.
 */
void __gl_meshDelete( GLUhalfEdge *eDel )
{
  GLUhalfEdge *eDelSym = eDel->Sym;
  int joiningLoops = FALSE;

  /* First step: disconnect the origin vertex eDel->Org.  We make all
   * changes to get a consistent mesh in this "intermediate" state.
   */
  if( eDel->Lface != eDel->Rface ) {
    /* We are joining two loops into one -- remove the left face */
    joiningLoops = TRUE;
    KillFace( eDel->Lface, eDel->Rface );
  }

  if( eDel->Onext == eDel ) {
    KillVertex( eDel->Org, NULL );
  } else {
    /* Make sure that eDel->Org and eDel->Rface point to valid half-edges */
    eDel->Rface->anEdge = eDel->Oprev;
    eDel->Org->anEdge = eDel->Onext;

    Splice( eDel, eDel->Oprev );
    if( ! joiningLoops ) {
      /* We are splitting one loop into two -- create a new loop for eDel. */
      MakeFace( eDel, eDel->Lface );
    }
  }

  /* Claim: the mesh is now in a consistent state, except that eDel->Org
   * may have been deleted.  Now we disconnect eDel->Dst.
   */
  if( eDelSym->Onext == eDelSym ) {
    KillVertex( eDelSym->Org, NULL );
    KillFace( eDelSym->Lface, NULL );
  } else {
    /* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */
    eDel->Lface->anEdge = eDelSym->Oprev;
    eDelSym->Org->anEdge = eDelSym->Onext;
    Splice( eDelSym, eDelSym->Oprev );
  }

  /* Any isolated vertices or faces have already been freed. */
  KillEdge( eDel );
}


/******************** Other Edge Operations **********************/

/* All these routines can be implemented with the basic edge
 * operations above.  They are provided for convenience and efficiency.
 */


/* __gl_meshAddEdgeVertex( eOrg ) creates a new edge eNew such that
 * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
 * eOrg and eNew will have the same left face.
 */
GLUhalfEdge *__gl_meshAddEdgeVertex( GLUhalfEdge *eOrg )
{
  GLUhalfEdge *eNew = MakeEdge( eOrg );
  GLUhalfEdge *eNewSym = eNew->Sym;

  /* Connect the new edge appropriately */
  Splice( eNew, eOrg->Lnext );

  /* Set the vertex and face information */
  eNew->Org = eOrg->Dst;
  MakeVertex( eNewSym, eNew->Org );
  eNew->Lface = eNewSym->Lface = eOrg->Lface;

  return eNew;
}


/* __gl_meshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
 * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
 * eOrg and eNew will have the same left face.
 */
GLUhalfEdge *__gl_meshSplitEdge( GLUhalfEdge *eOrg )
{
  GLUhalfEdge *eNew = __gl_meshAddEdgeVertex( eOrg )->Sym;

  /* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */
  Splice( eOrg->Sym, eOrg->Sym->Oprev );
  Splice( eOrg->Sym, eNew );

  /* Set the vertex and face information */
  eOrg->Dst = eNew->Org;
  eNew->Dst->anEdge = eNew->Sym;	/* may have pointed to eOrg->Sym */
  eNew->Rface = eOrg->Rface;
  eNew->winding = eOrg->winding;	/* copy old winding information */
  eNew->Sym->winding = eOrg->Sym->winding;

  return eNew;
}


/* __gl_meshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
 * to eDst->Org, and returns the corresponding half-edge eNew.
 * If eOrg->Lface == eDst->Lface, this splits one loop into two,
 * and the newly created loop is eNew->Lface.  Otherwise, two disjoint
 * loops are merged into one, and the loop eDst->Lface is destroyed.
 *
 * If (eOrg == eDst), the new face will have only two edges.
 * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
 * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
 */
GLUhalfEdge *__gl_meshConnect( GLUhalfEdge *eOrg, GLUhalfEdge *eDst )
{
  GLUhalfEdge *eNew = MakeEdge( eOrg );
  GLUhalfEdge *eNewSym = eNew->Sym;
  int joiningLoops = FALSE;

  if( eDst->Lface != eOrg->Lface ) {
    /* We are connecting two disjoint loops -- destroy eDst->Lface */
    joiningLoops = TRUE;
    KillFace( eDst->Lface, eOrg->Lface );
  }

  /* Connect the new edge appropriately */
  Splice( eNew, eOrg->Lnext );
  Splice( eNewSym, eDst );

  /* Set the vertex and face information */
  eNew->Org = eOrg->Dst;
  eNewSym->Org = eDst->Org;
  eNew->Lface = eNewSym->Lface = eOrg->Lface;

  /* Make sure the old face points to a valid half-edge */
  eOrg->Lface->anEdge = eNewSym;

  if( ! joiningLoops ) {
    /* We split one loop into two -- the new loop is eNew->Lface */
    MakeFace( eNew, eOrg->Lface );
  }
  return eNew;
}


/******************** Other Operations **********************/

/* __gl_meshZapFace( fZap ) destroys a face and removes it from the
 * global face list.  All edges of fZap will have a NULL pointer as their
 * left face.  Any edges which also have a NULL pointer as their right face
 * are deleted entirely (along with any isolated vertices this produces).
 * An entire mesh can be deleted by zapping its faces, one at a time,
 * in any order.  Zapped faces cannot be used in further mesh operations!
 */
void __gl_meshZapFace( GLUface *fZap )
{
  GLUhalfEdge *eStart = fZap->anEdge;
  GLUhalfEdge *e, *eNext, *eSym;
  GLUface *fPrev, *fNext;

  /* walk around face, deleting edges whose right face is also NULL */
  eNext = eStart->Lnext;
  do {
    e = eNext;
    eNext = e->Lnext;

    e->Lface = NULL;
    if( e->Rface == NULL ) {
      /* delete the edge -- see __gl_MeshDelete above */

      if( e->Onext == e ) {
	KillVertex( e->Org, NULL );
      } else {
	/* Make sure that e->Org points to a valid half-edge */
	e->Org->anEdge = e->Onext;
	Splice( e, e->Oprev );
      }
      eSym = e->Sym;
      if( eSym->Onext == eSym ) {
	KillVertex( eSym->Org, NULL );
      } else {
	/* Make sure that eSym->Org points to a valid half-edge */
	eSym->Org->anEdge = eSym->Onext;
	Splice( eSym, eSym->Oprev );
      }
      KillEdge( e );
    }
  } while( e != eStart );

  /* delete from circular doubly-linked list */
  fPrev = fZap->prev;
  fNext = fZap->next;
  fNext->prev = fPrev;
  fPrev->next = fNext;

  memFree( fZap );
}


/* __gl_meshNewMesh() creates a new mesh with no edges, no vertices,
 * and no loops (what we usually call a "face").
 */
GLUmesh *__gl_meshNewMesh( void )
{
  GLUmesh *mesh = (GLUmesh *)memAlloc( sizeof( GLUmesh ));
  GLUvertex *v = &mesh->vHead;
  GLUface *f = &mesh->fHead;
  GLUhalfEdge *e = &mesh->eHead;
  GLUhalfEdge *eSym = &mesh->eHeadSym;

  v->next = v->prev = v;
  v->anEdge = NULL;
  v->data = NULL;

  f->next = f->prev = f;
  f->anEdge = NULL;
  f->data = NULL;
  f->trail = NULL;
  f->marked = FALSE;
  f->inside = FALSE;

  e->next = e;
  e->Sym = eSym;
  e->Onext = NULL;
  e->Lnext = NULL;
  e->Org = NULL;
  e->Lface = NULL;
  e->winding = 0;
  e->activeRegion = NULL;

  eSym->next = eSym;
  eSym->Sym = e;
  eSym->Onext = NULL;
  eSym->Lnext = NULL;
  eSym->Org = NULL;
  eSym->Lface = NULL;
  eSym->winding = 0;
  eSym->activeRegion = NULL;

  return mesh;
}


/* __gl_meshUnion( mesh1, mesh2 ) forms the union of all structures in
 * both meshes, and returns the new mesh (the old meshes are destroyed).
 */
GLUmesh *__gl_meshUnion( GLUmesh *mesh1, GLUmesh *mesh2 )
{
  GLUface *f1 = &mesh1->fHead;
  GLUvertex *v1 = &mesh1->vHead;
  GLUhalfEdge *e1 = &mesh1->eHead;
  GLUface *f2 = &mesh2->fHead;
  GLUvertex *v2 = &mesh2->vHead;
  GLUhalfEdge *e2 = &mesh2->eHead;

  /* Add the faces, vertices, and edges of mesh2 to those of mesh1 */
  if( f2->next != f2 ) {
    f1->prev->next = f2->next;
    f2->next->prev = f1->prev;
    f2->prev->next = f1;
    f1->prev = f2->prev;
  }

  if( v2->next != v2 ) {
    v1->prev->next = v2->next;
    v2->next->prev = v1->prev;
    v2->prev->next = v1;
    v1->prev = v2->prev;
  }

  if( e2->next != e2 ) {
    e1->Sym->next->Sym->next = e2->next;
    e2->next->Sym->next = e1->Sym->next;
    e2->Sym->next->Sym->next = e1;
    e1->Sym->next = e2->Sym->next;
  }

  memFree( mesh2 );
  return mesh1;
}


#ifdef DELETE_BY_ZAPPING

/* __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.
 */
void __gl_meshDeleteMesh( GLUmesh *mesh )
{
  GLUface *fHead = &mesh->fHead;

  while( fHead->next != fHead ) {
    __gl_meshZapFace( fHead->next );
  }
  assert( mesh->vHead.next == &mesh->vHead );

  memFree( mesh );
}

#else

/* __gl_meshDeleteMesh( mesh ) will free all storage for any valid mesh.
 */
void __gl_meshDeleteMesh( GLUmesh *mesh )
{
  GLUface *f, *fNext;
  GLUvertex *v, *vNext;
  GLUhalfEdge *e, *eNext;

  for( f = mesh->fHead.next; f != &mesh->fHead; f = fNext ) {
    fNext = f->next;
    memFree( f );
  }

  for( v = mesh->vHead.next; v != &mesh->vHead; v = vNext ) {
    vNext = v->next;
    memFree( v );
  }

  for( e = mesh->eHead.next; e != &mesh->eHead; e = eNext ) {
    /* One call frees both e and e->Sym (see EdgePair above) */
    eNext = e->next;
    memFree( e );
  }

  memFree( mesh );
}

#endif

#ifndef NDEBUG

/* __gl_meshCheckMesh( mesh ) checks a mesh for self-consistency.
 */
void __gl_meshCheckMesh( GLUmesh *mesh )
{
  GLUface *fHead = &mesh->fHead;
  GLUvertex *vHead = &mesh->vHead;
  GLUhalfEdge *eHead = &mesh->eHead;
  GLUface *f, *fPrev;
  GLUvertex *v, *vPrev;
  GLUhalfEdge *e, *ePrev;

  fPrev = fHead;
  for( fPrev = fHead ; (f = fPrev->next) != fHead; fPrev = f) {
    assert( f->prev == fPrev );
    e = f->anEdge;
    do {
      assert( e->Sym != e );
      assert( e->Sym->Sym == e );
      assert( e->Lnext->Onext->Sym == e );
      assert( e->Onext->Sym->Lnext == e );
      assert( e->Lface == f );
      e = e->Lnext;
    } while( e != f->anEdge );
  }
  assert( f->prev == fPrev && f->anEdge == NULL && f->data == NULL );

  vPrev = vHead;
  for( vPrev = vHead ; (v = vPrev->next) != vHead; vPrev = v) {
    assert( v->prev == vPrev );
    e = v->anEdge;
    do {
      assert( e->Sym != e );
      assert( e->Sym->Sym == e );
      assert( e->Lnext->Onext->Sym == e );
      assert( e->Onext->Sym->Lnext == e );
      assert( e->Org == v );
      e = e->Onext;
    } while( e != v->anEdge );
  }
  assert( v->prev == vPrev && v->anEdge == NULL && v->data == NULL );

  ePrev = eHead;
  for( ePrev = eHead ; (e = ePrev->next) != eHead; ePrev = e) {
    assert( e->Sym->next == ePrev->Sym );
    assert( e->Sym != e );
    assert( e->Sym->Sym == e );
    assert( e->Org != NULL );
    assert( e->Dst != NULL );
    assert( e->Lnext->Onext->Sym == e );
    assert( e->Onext->Sym->Lnext == e );
  }
  assert( e->Sym->next == ePrev->Sym
       && e->Sym == &mesh->eHeadSym
       && e->Sym->Sym == e
       && e->Org == NULL && e->Dst == NULL
       && e->Lface == NULL && e->Rface == NULL );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\memalloc.h ===
#ifndef __memalloc_fast_h_
#define __memalloc_fast_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

//mf: ! this switch controls memalloc scheme !
#if 1
// slow alloc
#include "winmem.h"

#define memAlloc      	malloc
#define memRealloc      realloc
#define memFree         free
#define memInit(a)      1
#else
// fast alloc (used to be buggy, but fixed with v1.2)
// Still not thread-safe, though
#include "malloc.h"

#define memAlloc	__gl_memAlloc
#define memRealloc	__gl_memRealloc
#define memFree		__gl_memFree
#define memInit		__gl_memInit

extern void *__gl_memAlloc( size_t );
extern void *__gl_memRealloc( void *, size_t );
extern void __gl_memFree( void * );
extern int __gl_memInit( size_t );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\normal.h ===
#ifndef __normal_h_
#define __normal_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "tess.h"

/* __gl_projectPolygon( tess ) determines the polygon normal
 * and project vertices onto the plane of the polygon.
 */
void __gl_projectPolygon( GLUtesselator *tess );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\memalloc.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include <glos.h>
#endif
#include "memalloc.h"
#include <assert.h>

#ifdef NO_MALLOPT
#define memalign(a,n)	malloc(n)
#define mallopt(t,v)
#endif

#define Pool mPool

typedef struct Pool {
  char *prevAlloc;
  char *lastAlloc;
  int usedCount;
  int chunkSize;
} Pool;

typedef struct Chunk {
  Pool *pool;
} Chunk;

static Pool **Pools;
static size_t MaxFast;

#define POOL_SIZE	200
#define CHUNK_PAD	sizeof(Chunk)

#define ALIGN_SHIFT	3
#define ALIGN		(1 << ALIGN_SHIFT)

#define CHUNK_SIZE(n)	(((n) + CHUNK_PAD + ALIGN - 1) & (-ALIGN))
#define ALIGNED_CHUNK_PAD	((CHUNK_PAD + ALIGN - 1) & (-ALIGN))

static int NewPool( size_t n, int poolSize )
{
  Pool *p;
  char *base;

  /* We want the *returned* chunks to be aligned on ALIGN boundaries.
   * The Chunk structures will be located just before these boundaries.
   */
  p = (Pool *)malloc( CHUNK_SIZE(sizeof(Pool)) + poolSize * n );
  if (p == NULL) {
     return 0;
  }
  base = (char *)p + CHUNK_SIZE(sizeof(Pool)) - CHUNK_PAD;
  p->prevAlloc = base - n;
  p->lastAlloc = base + (poolSize-1) * n;
  p->usedCount = poolSize;
  p->chunkSize = n;
  Pools[n>>ALIGN_SHIFT] = p;

  return 1;
}

int __gl_memInit( size_t maxFast )
{
  int i, numPools;

  if( Pools == NULL ) {
#ifdef MEMORY_DEBUG
    mallopt( M_DEBUG, 1 );
#endif
    MaxFast = CHUNK_SIZE(maxFast) - CHUNK_PAD;
    numPools = ((MaxFast + CHUNK_PAD) >> ALIGN_SHIFT) + 1;
    Pools = (struct Pool **)malloc( numPools * sizeof(Pools[0]) );
    if (Pools == NULL)
       return 0;

    /* Create a tiny pool for every size, to avoid a check for NULL
     * in memAlloc().
     */
    for( i = 1; i < numPools; ++i ) {
      if (NewPool( i << ALIGN_SHIFT, 1 ) == 0) {
         return 0;
      }
    }
  }
  return 1;
}

void *__gl_memAlloc( size_t n )
{
  Pool *p;
  Chunk *c;

  if( n <= MaxFast ) {
    n = CHUNK_SIZE( n );
    p = Pools[n >> ALIGN_SHIFT];
    assert ( p->chunkSize == n );
    c = (Chunk *)(p->prevAlloc + n);
    p->prevAlloc = (char *) c;
    c->pool = p;
    if( c >= (Chunk *) p->lastAlloc ) {
      if (NewPool( n, POOL_SIZE ) == 0) {
         return 0;
      }
    }
    assert( ((size_t)(c + 1) & (ALIGN - 1)) == 0 );
  } else {
    char* v;
/*    v = (char*) malloc( n + ALIGNED_CHUNK_PAD ) + ALIGNED_CHUNK_PAD;*/
    v = (char*) malloc( n + ALIGNED_CHUNK_PAD );
    if (v == NULL) {
       return 0;
    }
    v = v + ALIGNED_CHUNK_PAD;

    c = ((Chunk*) v) - 1;
    c->pool = NULL;
    assert( ((size_t)(c + 1) & (ALIGN - 1)) == 0 );
  }
  return (c + 1);
}

extern void *__gl_memRealloc( void *v1, size_t n )
{
  Chunk *c = ((Chunk *) v1) - 1;
  Pool *p = c->pool;
  void *v2;
#ifdef NT
  size_t len;
#else
  int len;
#endif

  if( p == NULL ) {
    char* v;
/*    v = (char*) realloc( (char*)v1 - ALIGNED_CHUNK_PAD, n + ALIGNED_CHUNK_PAD )
      + ALIGNED_CHUNK_PAD; */
    v = (char*) realloc( (char*)v1 - ALIGNED_CHUNK_PAD, n + ALIGNED_CHUNK_PAD);
    if (v == NULL) {
       return 0;
    }
    v = v + ALIGNED_CHUNK_PAD;
    c = ((Chunk*) v) - 1;
    assert( ((size_t)(c + 1) & (ALIGN - 1)) == 0 );
    return (c+1);
  }
  len = p->chunkSize - CHUNK_PAD;
  if( n <= len ) { return v1; }

  v2 = memAlloc( n );
  if (v2 == NULL) {
     return 0;
  }
  (void) memcpy( v2, v1, len );
  memFree( v1 );
  return v2;
}

extern void __gl_memFree( void *v )
{
  Chunk *c = ((Chunk *) v) - 1;
  Pool *p = c->pool;

  if( p == NULL ) {
    free( ((char*) v) - ALIGNED_CHUNK_PAD );
  } else {
    if( --p->usedCount <= 0 ) {
      free( p );
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\render.h ===
#ifndef __render_h_
#define __render_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "mesh.h"

/* __gl_renderMesh( tess, mesh ) takes a mesh and breaks it into triangle
 * fans, strips, and separate triangles.  A substantial effort is made
 * to use as few rendering primitives as possible (ie. to make the fans
 * and strips as large as possible).
 *
 * The rendering output is provided as callbacks (see the api).
 */
void __gl_renderMesh( GLUtesselator *tess, GLUmesh *mesh );
void __gl_renderBoundary( GLUtesselator *tess, GLUmesh *mesh );

GLboolean __gl_renderCache( GLUtesselator *tess );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\prq-heap.h ===
#ifndef __priorityq_heap_h_
#define __priorityq_heap_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

/* Use #define's so that another heap implementation can use this one */

#define PQkey			PQHeapKey
#define PQhandle		PQHeapHandle
#define PriorityQ		PriorityQHeap

#define pqNewPriorityQ(leq)	__gl_pqHeapNewPriorityQ(leq)
#define pqDeletePriorityQ(pq)	__gl_pqHeapDeletePriorityQ(pq)

/* The basic operations are insertion of a new key (pqInsert),
 * and examination/extraction of a key whose value is minimum
 * (pqMinimum/pqExtractMin).  Deletion is also allowed (pqDelete);
 * for this purpose pqInsert returns a "handle" which is supplied
 * as the argument.
 *
 * An initial heap may be created efficiently by calling pqInsert
 * repeatedly, then calling pqInit.  In any case pqInit must be called
 * before any operations other than pqInsert are used.
 *
 * If the heap is empty, pqMinimum/pqExtractMin will return a NULL key.
 * This may also be tested with pqIsEmpty.
 */
#define pqInit(pq)		__gl_pqHeapInit(pq)
#define pqInsert(pq,key)	__gl_pqHeapInsert(pq,key)
#define pqMinimum(pq)		__gl_pqHeapMinimum(pq)
#define pqExtractMin(pq)	__gl_pqHeapExtractMin(pq)
#define pqDelete(pq,handle)	__gl_pqHeapDelete(pq,handle)
#define pqIsEmpty(pq)		__gl_pqHeapIsEmpty(pq)


/* Since we support deletion the data structure is a little more
 * complicated than an ordinary heap.  "nodes" is the heap itself;
 * active nodes are stored in the range 1..pq->size.  When the
 * heap exceeds its allocated size (pq->max), its size doubles.
 * The children of node i are nodes 2i and 2i+1.
 *
 * Each node stores an index into an array "handles".  Each handle
 * stores a key, plus a pointer back to the node which currently
 * represents that key (ie. nodes[handles[i].node].handle == i).
 */

typedef void *PQkey;
typedef long PQhandle;
typedef struct PriorityQ PriorityQ;

typedef struct { PQhandle handle; } PQnode;
typedef struct { PQkey key; PQhandle node; } PQhandleElem;

struct PriorityQ {
  PQnode	*nodes;
  PQhandleElem	*handles;
  long		size, max;
  PQhandle	freeList;
  int		initialized;
  int		(*leq)(PQkey key1, PQkey key2);
};
  
PriorityQ	*pqNewPriorityQ( int (*leq)(PQkey key1, PQkey key2) );
void		pqDeletePriorityQ( PriorityQ *pq );

void		pqInit( PriorityQ *pq );
PQhandle	pqInsert( PriorityQ *pq, PQkey key );
PQkey		pqExtractMin( PriorityQ *pq );
void		pqDelete( PriorityQ *pq, PQhandle handle );


#define __gl_pqHeapMinimum(pq)	((pq)->handles[(pq)->nodes[1].handle].key)
#define __gl_pqHeapIsEmpty(pq)	((pq)->size == 0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\prq-sort.h ===
#ifndef __priorityq_sort_h_
#define __priorityq_sort_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include "prq-heap.h"
#else
#include "priorityq-heap.h"
#endif

#undef PQkey
#undef PQhandle
#undef PriorityQ
#undef pqNewPriorityQ
#undef pqDeletePriorityQ
#undef pqInit
#undef pqInsert
#undef pqMinimum
#undef pqExtractMin
#undef pqDelete
#undef pqIsEmpty

/* Use #define's so that another heap implementation can use this one */

#define PQkey			PQSortKey
#define PQhandle		PQSortHandle
#define PriorityQ		PriorityQSort

#define pqNewPriorityQ(leq)	__gl_pqSortNewPriorityQ(leq)
#define pqDeletePriorityQ(pq)	__gl_pqSortDeletePriorityQ(pq)

/* The basic operations are insertion of a new key (pqInsert),
 * and examination/extraction of a key whose value is minimum
 * (pqMinimum/pqExtractMin).  Deletion is also allowed (pqDelete);
 * for this purpose pqInsert returns a "handle" which is supplied
 * as the argument.
 *
 * An initial heap may be created efficiently by calling pqInsert
 * repeatedly, then calling pqInit.  In any case pqInit must be called
 * before any operations other than pqInsert are used.
 *
 * If the heap is empty, pqMinimum/pqExtractMin will return a NULL key.
 * This may also be tested with pqIsEmpty.
 */
#define pqInit(pq)		__gl_pqSortInit(pq)
#define pqInsert(pq,key)	__gl_pqSortInsert(pq,key)
#define pqMinimum(pq)		__gl_pqSortMinimum(pq)
#define pqExtractMin(pq)	__gl_pqSortExtractMin(pq)
#define pqDelete(pq,handle)	__gl_pqSortDelete(pq,handle)
#define pqIsEmpty(pq)		__gl_pqSortIsEmpty(pq)


/* Since we support deletion the data structure is a little more
 * complicated than an ordinary heap.  "nodes" is the heap itself;
 * active nodes are stored in the range 1..pq->size.  When the
 * heap exceeds its allocated size (pq->max), its size doubles.
 * The children of node i are nodes 2i and 2i+1.
 *
 * Each node stores an index into an array "handles".  Each handle
 * stores a key, plus a pointer back to the node which currently
 * represents that key (ie. nodes[handles[i].node].handle == i).
 */

typedef PQHeapKey PQkey;
typedef PQHeapHandle PQhandle;
typedef struct PriorityQ PriorityQ;

struct PriorityQ {
  PriorityQHeap	*heap;
  PQkey		*keys;
  PQkey		**order;
  PQhandle	size, max;
  int		initialized;
  int		(*leq)(PQkey key1, PQkey key2);
};
  
PriorityQ	*pqNewPriorityQ( int (*leq)(PQkey key1, PQkey key2) );
void		pqDeletePriorityQ( PriorityQ *pq );

void		pqInit( PriorityQ *pq );
PQhandle	pqInsert( PriorityQ *pq, PQkey key );
PQkey		pqExtractMin( PriorityQ *pq );
void		pqDelete( PriorityQ *pq, PQhandle handle );

PQkey		pqMinimum( PriorityQ *pq );
int		pqIsEmpty( PriorityQ *pq );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\priority.h ===
#ifndef __priorityq_sort_h_
#define __priorityq_sort_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include "prq-heap.h"
#else
#include "priorityq-heap.h"
#endif

#undef PQkey
#undef PQhandle
#undef PriorityQ
#undef pqNewPriorityQ
#undef pqDeletePriorityQ
#undef pqInit
#undef pqInsert
#undef pqMinimum
#undef pqExtractMin
#undef pqDelete
#undef pqIsEmpty

/* Use #define's so that another heap implementation can use this one */

#define PQkey			PQSortKey
#define PQhandle		PQSortHandle
#define PriorityQ		PriorityQSort

#define pqNewPriorityQ(leq)	__gl_pqSortNewPriorityQ(leq)
#define pqDeletePriorityQ(pq)	__gl_pqSortDeletePriorityQ(pq)

/* The basic operations are insertion of a new key (pqInsert),
 * and examination/extraction of a key whose value is minimum
 * (pqMinimum/pqExtractMin).  Deletion is also allowed (pqDelete);
 * for this purpose pqInsert returns a "handle" which is supplied
 * as the argument.
 *
 * An initial heap may be created efficiently by calling pqInsert
 * repeatedly, then calling pqInit.  In any case pqInit must be called
 * before any operations other than pqInsert are used.
 *
 * If the heap is empty, pqMinimum/pqExtractMin will return a NULL key.
 * This may also be tested with pqIsEmpty.
 */
#define pqInit(pq)		__gl_pqSortInit(pq)
#define pqInsert(pq,key)	__gl_pqSortInsert(pq,key)
#define pqMinimum(pq)		__gl_pqSortMinimum(pq)
#define pqExtractMin(pq)	__gl_pqSortExtractMin(pq)
#define pqDelete(pq,handle)	__gl_pqSortDelete(pq,handle)
#define pqIsEmpty(pq)		__gl_pqSortIsEmpty(pq)


/* Since we support deletion the data structure is a little more
 * complicated than an ordinary heap.  "nodes" is the heap itself;
 * active nodes are stored in the range 1..pq->size.  When the
 * heap exceeds its allocated size (pq->max), its size doubles.
 * The children of node i are nodes 2i and 2i+1.
 *
 * Each node stores an index into an array "handles".  Each handle
 * stores a key, plus a pointer back to the node which currently
 * represents that key (ie. nodes[handles[i].node].handle == i).
 */

typedef PQHeapKey PQkey;
typedef PQHeapHandle PQhandle;
typedef struct PriorityQ PriorityQ;

struct PriorityQ {
  PriorityQHeap	*heap;
  PQkey		*keys;
  PQkey		**order;
  PQhandle	size, max;
  int		initialized;
  int		(*leq)(PQkey key1, PQkey key2);
};
  
PriorityQ	*pqNewPriorityQ( int (*leq)(PQkey key1, PQkey key2) );
void		pqDeletePriorityQ( PriorityQ *pq );

void		pqInit( PriorityQ *pq );
PQhandle	pqInsert( PriorityQ *pq, PQkey key );
PQkey		pqExtractMin( PriorityQ *pq );
void		pqDelete( PriorityQ *pq, PQhandle handle );

PQkey		pqMinimum( PriorityQ *pq );
int		pqIsEmpty( PriorityQ *pq );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\render.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/


#include <assert.h>
#include <stddef.h>
#include "mesh.h"
#include "tess.h"
#include "render.h"

#define TRUE 1
#define FALSE 0

/* This structure remembers the information we need about a primitive
 * to be able to render it later, once we have determined which
 * primitive is able to use the most triangles.
 */
struct FaceCount {
  long		size;		/* number of triangles used */
  GLUhalfEdge	*eStart;	/* edge where this primitive starts */
  void		(*render)(GLUtesselator *, GLUhalfEdge *, long);
                                /* routine to render this primitive */
};

static struct FaceCount MaximumFan( GLUhalfEdge *eOrig );
static struct FaceCount MaximumStrip( GLUhalfEdge *eOrig );

static void RenderFan( GLUtesselator *tess, GLUhalfEdge *eStart, long size );
static void RenderStrip( GLUtesselator *tess, GLUhalfEdge *eStart, long size );
static void RenderTriangle( GLUtesselator *tess, GLUhalfEdge *eStart,
			    long size );

static void RenderMaximumFaceGroup( GLUtesselator *tess, GLUface *fOrig );
static void RenderLonelyTriangles( GLUtesselator *tess, GLUface *head );



/************************ Strips and Fans decomposition ******************/

/* __gl_renderMesh( tess, mesh ) takes a mesh and breaks it into triangle
 * fans, strips, and separate triangles.  A substantial effort is made
 * to use as few rendering primitives as possible (ie. to make the fans
 * and strips as large as possible).
 *
 * The rendering output is provided as callbacks (see the api).
 */
void __gl_renderMesh( GLUtesselator *tess, GLUmesh *mesh )
{
  GLUface *f;

  /* Make a list of separate triangles so we can render them all at once */
  tess->lonelyTriList = NULL;

  for( f = mesh->fHead.next; f != &mesh->fHead; f = f->next ) {
    f->marked = FALSE;
  }
  for( f = mesh->fHead.next; f != &mesh->fHead; f = f->next ) {

    /* We examine all faces in an arbitrary order.  Whenever we find
     * an unprocessed face F, we output a group of faces including F
     * whose size is maximum.
     */
    if( f->inside && ! f->marked ) {
      RenderMaximumFaceGroup( tess, f );
      assert( f->marked );
    }
  }
  if( tess->lonelyTriList != NULL ) {
    RenderLonelyTriangles( tess, tess->lonelyTriList );
    tess->lonelyTriList = NULL;
  }
}


static void RenderMaximumFaceGroup( GLUtesselator *tess, GLUface *fOrig )
{
  /* We want to find the largest triangle fan or strip of unmarked faces
   * which includes the given face fOrig.  There are 3 possible fans
   * passing through fOrig (one centered at each vertex), and 3 possible
   * strips (one for each CCW permutation of the vertices).  Our strategy
   * is to try all of these, and take the primitive which uses the most
   * triangles (a greedy approach).
   */
  GLUhalfEdge *e = fOrig->anEdge;
  struct FaceCount max, newFace;

  max.size = 1;
  max.eStart = e;
  max.render = &RenderTriangle;

  if( ! tess->flagBoundary ) {
    newFace = MaximumFan( e ); if( newFace.size > max.size ) { max = newFace; }
    newFace = MaximumFan( e->Lnext ); if( newFace.size > max.size ) { max = newFace; }
    newFace = MaximumFan( e->Lprev ); if( newFace.size > max.size ) { max = newFace; }

    newFace = MaximumStrip( e ); if( newFace.size > max.size ) { max = newFace; }
    newFace = MaximumStrip( e->Lnext ); if( newFace.size > max.size ) { max = newFace; }
    newFace = MaximumStrip( e->Lprev ); if( newFace.size > max.size ) { max = newFace; }
  }
  (*(max.render))( tess, max.eStart, max.size );
}


/* Macros which keep track of faces we have marked temporarily, and allow
 * us to backtrack when necessary.  With triangle fans, this is not
 * really necessary, since the only awkward case is a loop of triangles
 * around a single origin vertex.  However with strips the situation is
 * more complicated, and we need a general tracking method like the
 * one here.
 */
#define Marked(f)	(! (f)->inside || (f)->marked)

#define AddToTrail(f,t)	((f)->trail = (t), (t) = (f), (f)->marked = TRUE)

#define FreeTrail(t)	if( 1 ) { \
			  while( (t) != NULL ) { \
			    (t)->marked = FALSE; t = (t)->trail; \
			  } \
			} else /* absorb trailing semicolon */



static struct FaceCount MaximumFan( GLUhalfEdge *eOrig )
{
  /* eOrig->Lface is the face we want to render.  We want to find the size
   * of a maximal fan around eOrig->Org.  To do this we just walk around
   * the origin vertex as far as possible in both directions.
   */
  struct FaceCount newFace = { 0, NULL, &RenderFan };
  GLUface *trail = NULL;
  GLUhalfEdge *e;

  for( e = eOrig; ! Marked( e->Lface ); e = e->Onext ) {
    AddToTrail( e->Lface, trail );
    ++newFace.size;
  }
  for( e = eOrig; ! Marked( e->Rface ); e = e->Oprev ) {
    AddToTrail( e->Rface, trail );
    ++newFace.size;
  }
  newFace.eStart = e;
  /*LINTED*/
  FreeTrail( trail );
  return newFace;
}


#define IsEven(n)	(((n) & 1) == 0)

static struct FaceCount MaximumStrip( GLUhalfEdge *eOrig )
{
  /* Here we are looking for a maximal strip that contains the vertices
   * eOrig->Org, eOrig->Dst, eOrig->Lnext->Dst (in that order or the
   * reverse, such that all triangles are oriented CCW).
   *
   * Again we walk forward and backward as far as possible.  However for
   * strips there is a twist: to get CCW orientations, there must be
   * an *even* number of triangles in the strip on one side of eOrig.
   * We walk the strip starting on a side with an even number of triangles;
   * if both side have an odd number, we are forced to shorten one side.
   */
  struct FaceCount newFace = { 0, NULL, &RenderStrip };
  long headSize = 0, tailSize = 0;
  GLUface *trail = NULL;
  GLUhalfEdge *e, *eTail, *eHead;

  for( e = eOrig; ! Marked( e->Lface ); ++tailSize, e = e->Onext ) {
    AddToTrail( e->Lface, trail );
    ++tailSize;
    e = e->Dprev;
    if( Marked( e->Lface )) break;
    AddToTrail( e->Lface, trail );
  }
  eTail = e;

  for( e = eOrig; ! Marked( e->Rface ); ++headSize, e = e->Dnext ) {
    AddToTrail( e->Rface, trail );
    ++headSize;
    e = e->Oprev;
    if( Marked( e->Rface )) break;
    AddToTrail( e->Rface, trail );
  }
  eHead = e;

  newFace.size = tailSize + headSize;
  if( IsEven( tailSize )) {
    newFace.eStart = eTail->Sym;
  } else if( IsEven( headSize )) {
    newFace.eStart = eHead;
  } else {
    /* Both sides have odd length, we must shorten one of them.  In fact,
     * we must start from eHead to guarantee inclusion of eOrig->Lface.
     */
    --newFace.size;
    newFace.eStart = eHead->Onext;
  }
  /*LINTED*/
  FreeTrail( trail );
  return newFace;
}


static void RenderTriangle( GLUtesselator *tess, GLUhalfEdge *e, long size )
{
  /* Just add the triangle to a triangle list, so we can render all
   * the separate triangles at once.
   */
  assert( size == 1 );
  AddToTrail( e->Lface, tess->lonelyTriList );
}


static void RenderLonelyTriangles( GLUtesselator *tess, GLUface *f )
{
  /* Now we render all the separate triangles which could not be
   * grouped into a triangle fan or strip.
   */
  GLUhalfEdge *e;
  int newState;
  int edgeState = -1;	/* force edge state output for first vertex */

  CALL_BEGIN_OR_BEGIN_DATA( GL_TRIANGLES );

  for( ; f != NULL; f = f->trail ) {
    /* Loop once for each edge (there will always be 3 edges) */

    e = f->anEdge;
    do {
      if( tess->flagBoundary ) {
	/* Set the "edge state" to TRUE just before we output the
	 * first vertex of each edge on the polygon boundary.
	 */
	newState = ! e->Rface->inside;
	if( edgeState != newState ) {
	  edgeState = newState;
          CALL_EDGE_FLAG_OR_EDGE_FLAG_DATA( (GLboolean)edgeState );
	}
      }
      CALL_VERTEX_OR_VERTEX_DATA( e->Org->data );

      e = e->Lnext;
    } while( e != f->anEdge );
  }
  CALL_END_OR_END_DATA();
}


static void RenderFan( GLUtesselator *tess, GLUhalfEdge *e, long size )
{
  /* Render as many CCW triangles as possible in a fan starting from
   * edge "e".  The fan *should* contain exactly "size" triangles
   * (otherwise we've goofed up somewhere).
   */
  CALL_BEGIN_OR_BEGIN_DATA( GL_TRIANGLE_FAN ); 
  CALL_VERTEX_OR_VERTEX_DATA( e->Org->data ); 
  CALL_VERTEX_OR_VERTEX_DATA( e->Dst->data ); 

  while( ! Marked( e->Lface )) {
    e->Lface->marked = TRUE;
    --size;
    e = e->Onext;
    CALL_VERTEX_OR_VERTEX_DATA( e->Dst->data ); 
  }

  assert( size == 0 );
  CALL_END_OR_END_DATA();
}


static void RenderStrip( GLUtesselator *tess, GLUhalfEdge *e, long size )
{
  /* Render as many CCW triangles as possible in a strip starting from
   * edge "e".  The strip *should* contain exactly "size" triangles
   * (otherwise we've goofed up somewhere).
   */
  CALL_BEGIN_OR_BEGIN_DATA( GL_TRIANGLE_STRIP );
  CALL_VERTEX_OR_VERTEX_DATA( e->Org->data ); 
  CALL_VERTEX_OR_VERTEX_DATA( e->Dst->data ); 

  while( ! Marked( e->Lface )) {
    e->Lface->marked = TRUE;
    --size;
    e = e->Dprev;
    CALL_VERTEX_OR_VERTEX_DATA( e->Org->data ); 
    if( Marked( e->Lface )) break;

    e->Lface->marked = TRUE;
    --size;
    e = e->Onext;
    CALL_VERTEX_OR_VERTEX_DATA( e->Dst->data ); 
  }

  assert( size == 0 );
  CALL_END_OR_END_DATA();
}


/************************ Boundary contour decomposition ******************/

/* __gl_renderBoundary( tess, mesh ) takes a mesh, and outputs one
 * contour for each face marked "inside".  The rendering output is
 * provided as callbacks (see the api).
 */
void __gl_renderBoundary( GLUtesselator *tess, GLUmesh *mesh )
{
  GLUface *f;
  GLUhalfEdge *e;

  for( f = mesh->fHead.next; f != &mesh->fHead; f = f->next ) {
    if( f->inside ) {
      CALL_BEGIN_OR_BEGIN_DATA( GL_LINE_LOOP );
      e = f->anEdge;
      do {
        CALL_VERTEX_OR_VERTEX_DATA( e->Org->data ); 
	e = e->Lnext;
      } while( e != f->anEdge );
      CALL_END_OR_END_DATA();
    }
  }
}


/************************ Quick-and-dirty decomposition ******************/

#define SIGN_INCONSISTENT 2

static int ComputeNormal( GLUtesselator *tess, GLdouble norm[3], int check )
/*
 * If check==FALSE, we compute the polygon normal and place it in norm[].
 * If check==TRUE, we check that each triangle in the fan from v0 has a
 * consistent orientation with respect to norm[].  If triangles are
 * consistently oriented CCW, return 1; if CW, return -1; if all triangles
 * are degenerate return 0; otherwise (no consistent orientation) return
 * SIGN_INCONSISTENT.
 */
{
  CachedVertex *v0 = tess->cache;
  CachedVertex *vn = v0 + tess->cacheCount;
  CachedVertex *vc;
  GLdouble dot, xc, yc, zc, xp, yp, zp, n[3];
  int sign = 0;

  /* Find the polygon normal.  It is important to get a reasonable
   * normal even when the polygon is self-intersecting (eg. a bowtie).
   * Otherwise, the computed normal could be very tiny, but perpendicular
   * to the true plane of the polygon due to numerical noise.  Then all
   * the triangles would appear to be degenerate and we would incorrectly
   * decompose the polygon as a fan (or simply not render it at all).
   *
   * We use a sum-of-triangles normal algorithm rather than the more
   * efficient sum-of-trapezoids method (used in CheckOrientation()
   * in normal.c).  This lets us explicitly reverse the signed area
   * of some triangles to get a reasonable normal in the self-intersecting
   * case.
   */
  if( ! check ) {
    norm[0] = norm[1] = norm[2] = 0.0;
  }

  vc = v0 + 1;
  xc = vc->coords[0] - v0->coords[0];
  yc = vc->coords[1] - v0->coords[1];
  zc = vc->coords[2] - v0->coords[2];
  while( ++vc < vn ) {
    xp = xc; yp = yc; zp = zc;
    xc = vc->coords[0] - v0->coords[0];
    yc = vc->coords[1] - v0->coords[1];
    zc = vc->coords[2] - v0->coords[2];

    /* Compute (vp - v0) cross (vc - v0) */
    n[0] = yp*zc - zp*yc;
    n[1] = zp*xc - xp*zc;
    n[2] = xp*yc - yp*xc;

    dot = n[0]*norm[0] + n[1]*norm[1] + n[2]*norm[2];
    if( ! check ) {
      /* Reverse the contribution of back-facing triangles to get
       * a reasonable normal for self-intersecting polygons (see above)
       */
      if( dot >= 0 ) {
	norm[0] += n[0]; norm[1] += n[1]; norm[2] += n[2];
      } else {
	norm[0] -= n[0]; norm[1] -= n[1]; norm[2] -= n[2];
      }
    } else if( dot != 0 ) {
      /* Check the new orientation for consistency with previous triangles */
      if( dot > 0 ) {
	if( sign < 0 ) return SIGN_INCONSISTENT;
	sign = 1;
      } else {
	if( sign > 0 ) return SIGN_INCONSISTENT;
	sign = -1;
      }
    }
  }
  return sign;
}

/* __gl_renderCache( tess ) takes a single contour and tries to render it
 * as a triangle fan.  This handles convex polygons, as well as some
 * non-convex polygons if we get lucky.
 *
 * Returns TRUE if the polygon was successfully rendered.  The rendering
 * output is provided as callbacks (see the api).
 */
GLboolean __gl_renderCache( GLUtesselator *tess )
{
  CachedVertex *v0 = tess->cache;
  CachedVertex *vn = v0 + tess->cacheCount;
  CachedVertex *vc;
  GLdouble norm[3];
  int sign;

  if( tess->cacheCount < 3 ) {
    /* Degenerate contour -- no output */
    return TRUE;
  }

  norm[0] = tess->normal[0];
  norm[1] = tess->normal[1];
  norm[2] = tess->normal[2];
  if( norm[0] == 0 && norm[1] == 0 && norm[2] == 0 ) {
    ComputeNormal( tess, norm, FALSE );
  }

  sign = ComputeNormal( tess, norm, TRUE );
  if( sign == SIGN_INCONSISTENT ) {
    /* Fan triangles did not have a consistent orientation */
    return FALSE;
  }
  if( sign == 0 ) {
    /* All triangles were degenerate */
    return TRUE;
  }

  /* Make sure we do the right thing for each winding rule */
  switch( tess->windingRule ) {
  case GLU_TESS_WINDING_ODD:
  case GLU_TESS_WINDING_NONZERO:
    break;
  case GLU_TESS_WINDING_POSITIVE:
    if( sign < 0 ) return TRUE;
    break;
  case GLU_TESS_WINDING_NEGATIVE:
    if( sign > 0 ) return TRUE;
    break;
  case GLU_TESS_WINDING_ABS_GEQ_TWO:
    return TRUE;
  }

  CALL_BEGIN_OR_BEGIN_DATA( tess->boundaryOnly ? GL_LINE_LOOP
			  : (tess->cacheCount > 3) ? GL_TRIANGLE_FAN
			  : GL_TRIANGLES );

  CALL_VERTEX_OR_VERTEX_DATA( v0->data ); 
  if( sign > 0 ) {
    for( vc = v0+1; vc < vn; ++vc ) {
      CALL_VERTEX_OR_VERTEX_DATA( vc->data ); 
    }
  } else {
    for( vc = vn-1; vc > v0; --vc ) {
      CALL_VERTEX_OR_VERTEX_DATA( vc->data ); 
    }
  }
  CALL_END_OR_END_DATA();
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\stack.h ===
#ifndef __stack_h_
#define __stack_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/


typedef struct Stack Stack;

struct Stack {
  int	size;
  int	max;
  void	**data;
};

Stack	*__gl_StackNew( void );
void	__gl_StackGrow( Stack *s );
void	__gl_StackFree( Stack *s );

#define StackNew()	__gl_StackNew()
#define StackFree(s)	__gl_StackFree( s )

#define StackSize(s)	((s)->size)
#define StackPush(s,d)	{ if ((s)->size >= (s)->max) __gl_StackGrow( s ); \
			    (s)->data[((s)->size)++] = (d); }
#define StackPop(s)	((s)->data[--((s)->size)])
#define StackTop(s)	((s)->data[(s)->size - 1])
#define StackNth(s,n)	((s)->data[(s)->size - (n) - 1])

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\priority.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <stddef.h>
#include <assert.h>
#include "memalloc.h"

/* Include all the code for the regular heap-based queue here. */

#ifdef NT
#include "prq-heap.c"
#else
#include "priorityq-heap.c"
#endif

/* Now redefine all the function names to map to their "Sort" versions. */

#ifdef NT
#include "prq-sort.h"
#else
#include "priorityq-sort.h"
#endif


PriorityQ *pqNewPriorityQ( int (*leq)(PQkey key1, PQkey key2) )
{
  PriorityQ *pq = (PriorityQ *)memAlloc( sizeof( PriorityQ ));

  pq->heap = __gl_pqHeapNewPriorityQ( leq );
  pq->keys = (PQHeapKey *)memAlloc( INIT_SIZE * sizeof(pq->keys[0]) );
  pq->size = 0;
  pq->max = INIT_SIZE;
  pq->initialized = FALSE;
  pq->leq = leq;
  return pq;
}


void pqDeletePriorityQ( PriorityQ *pq )
{
  __gl_pqHeapDeletePriorityQ( pq->heap );
#ifdef NT
  memFree( pq->order );
#endif
  memFree( pq->keys );
  memFree( pq );
}


#define LT(x,y)		(! LEQ(y,x))
#define GT(x,y)		(! LEQ(x,y))
#define Swap(a,b)	if(1){PQkey *tmp = *a; *a = *b; *b = tmp;}else

void pqInit( PriorityQ *pq )
{
  PQkey **p, **r, **i, **j, *piv;
  struct { PQkey **p, **r; } Stack[50], *top = Stack;
  unsigned long seed = 2016473283;

  /* Create an array of indirect pointers to the keys, so that we
   * the handles we have returned are still valid.
   */
  pq->order = (PQHeapKey **)memAlloc( (size_t) 
	                                  (pq->size * sizeof(pq->order[0])) );
  p = pq->order;
  r = p + pq->size - 1;
  for( piv = pq->keys, i = p; i <= r; ++piv, ++i ) {
    *i = piv;
  }

  /* Sort the indirect pointers in descending order,
   * using randomized Quicksort
   */
  top->p = p; top->r = r; ++top;
  while( --top >= Stack ) {
    p = top->p;
    r = top->r;
    while( r > p + 10 ) {
      seed = seed * 1539415821 + 1;
      i = p + seed % (r - p + 1);
      piv = *i;
      *i = *p;
      *p = piv;
      i = p - 1;
      j = r + 1;
      do {
	do { ++i; } while( GT( **i, *piv ));
	do { --j; } while( LT( **j, *piv ));
	Swap( i, j );
      } while( i < j );
      Swap( i, j );	/* Undo last swap */
      if( i - p < r - j ) {
	top->p = j+1; top->r = r; ++top;
	r = i-1;
      } else {
	top->p = p; top->r = i-1; ++top;
	p = j+1;
      }
    }
    /* Insertion sort small lists */
    for( i = p+1; i <= r; ++i ) {
      piv = *i;
      for( j = i; j > p && LT( **(j-1), *piv ); --j ) {
	*j = *(j-1);
      }
      *j = piv;
    }
  }
  pq->max = pq->size;
  pq->initialized = TRUE;
  __gl_pqHeapInit( pq->heap );

#ifndef NDEBUG
  p = pq->order;
  r = p + pq->size - 1;
  for( i = p; i < r; ++i ) {
    assert( LEQ( **(i+1), **i ));
  }
#endif
}


PQhandle pqInsert( PriorityQ *pq, PQkey keyNew )
{
  long curr;

  if( pq->initialized ) {
    return __gl_pqHeapInsert( pq->heap, keyNew );
  }
  curr = pq->size;
  if( ++ pq->size >= pq->max ) {
    /* If the heap overflows, double its size. */
    pq->max <<= 1;
    pq->keys = (PQHeapKey *)memRealloc( pq->keys, 
	 	                        (size_t)
	                                 (pq->max * sizeof( pq->keys[0] )));
  }
  pq->keys[curr] = keyNew;

  /* Negative handles index the sorted array. */
  return -(curr+1);
}


PQkey pqExtractMin( PriorityQ *pq )
{
  PQkey sortMin, heapMin;

  if( pq->size == 0 ) {
    return __gl_pqHeapExtractMin( pq->heap );
  }
  sortMin = *(pq->order[pq->size-1]);
  if( ! __gl_pqHeapIsEmpty( pq->heap )) {
    heapMin = __gl_pqHeapMinimum( pq->heap );
    if( LEQ( heapMin, sortMin )) {
      return __gl_pqHeapExtractMin( pq->heap );
    }
  }
  do {
    -- pq->size;
  } while( pq->size > 0 && *(pq->order[pq->size-1]) == NULL );
  return sortMin;
}


PQkey pqMinimum( PriorityQ *pq )
{
  PQkey sortMin, heapMin;

  if( pq->size == 0 ) {
    return __gl_pqHeapMinimum( pq->heap );
  }
  sortMin = *(pq->order[pq->size-1]);
  if( ! __gl_pqHeapIsEmpty( pq->heap )) {
    heapMin = __gl_pqHeapMinimum( pq->heap );
    if( LEQ( heapMin, sortMin )) {
      return heapMin;
    }
  }
  return sortMin;
}


int pqIsEmpty( PriorityQ *pq )
{
  return (pq->size == 0) && __gl_pqHeapIsEmpty( pq->heap );
}


void pqDelete( PriorityQ *pq, PQhandle curr )
{
  if( curr >= 0 ) {
    __gl_pqHeapDelete( pq->heap, curr );
    return;
  }
  curr = -(curr+1);
  assert( curr < pq->max && pq->keys[curr] != NULL );

  pq->keys[curr] = NULL;
  while( pq->size > 0 && *(pq->order[pq->size-1]) == NULL ) {
    -- pq->size;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\prq-heap.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <stddef.h>
#include <assert.h>
#ifdef NT
#include "prq-heap.h"
#else
#include "priorityq-heap.h"
#endif
#include "memalloc.h"

#define INIT_SIZE	32

#define TRUE 1
#define FALSE 0

#ifdef DEBUG
#define LEQ(x,y)	(*pq->leq)(x,y)
#else
/* Violates modularity, but a little faster */
#include "geom.h"
#define LEQ(x,y)	VertLeq((GLUvertex *)x, (GLUvertex *)y)
#endif

PriorityQ *pqNewPriorityQ( int (*leq)(PQkey key1, PQkey key2) )
{
  PriorityQ *pq = (PriorityQ *)memAlloc( sizeof( PriorityQ ));

  pq->size = 0;
  pq->max = INIT_SIZE;
  pq->nodes = (PQnode *)memAlloc( (INIT_SIZE + 1) * sizeof(pq->nodes[0]) );
  pq->handles = (PQhandleElem *)memAlloc( (INIT_SIZE + 1) * sizeof(pq->handles[0]) );
  pq->initialized = FALSE;
  pq->freeList = 0;
  pq->leq = leq;

  pq->nodes[1].handle = 1;	/* so that Minimum() returns NULL */
  pq->handles[1].key = NULL;
  return pq;
}


void pqDeletePriorityQ( PriorityQ *pq )
{
  memFree( pq->handles );
  memFree( pq->nodes );
  memFree( pq );
}


static void FloatDown( PriorityQ *pq, long curr )
{
  PQnode *n = pq->nodes;
  PQhandleElem *h = pq->handles;
  PQhandle hCurr, hChild;
  long child;

  hCurr = n[curr].handle;
  for( ;; ) {
    child = curr << 1;
    if( child < pq->size && LEQ( h[n[child+1].handle].key,
				 h[n[child].handle].key )) {
      ++child;
    }
    hChild = n[child].handle;
    if( child > pq->size || LEQ( h[hCurr].key, h[hChild].key )) {
      n[curr].handle = hCurr;
      h[hCurr].node = curr;
      break;
    }
    n[curr].handle = hChild;
    h[hChild].node = curr;
    curr = child;
  }
}


static void FloatUp( PriorityQ *pq, long curr )
{
  PQnode *n = pq->nodes;
  PQhandleElem *h = pq->handles;
  PQhandle hCurr, hParent;
  long parent;

  hCurr = n[curr].handle;
  for( ;; ) {
    parent = curr >> 1;
    hParent = n[parent].handle;
    if( parent == 0 || LEQ( h[hParent].key, h[hCurr].key )) {
      n[curr].handle = hCurr;
      h[hCurr].node = curr;
      break;
    }
    n[curr].handle = hParent;
    h[hParent].node = curr;
    curr = parent;
  }
}


void pqInit( PriorityQ *pq )
{
  long i;

  /* This method of building a heap is O(n), rather than O(n lg n). */

  for( i = pq->size; i >= 1; --i ) {
    FloatDown( pq, i );
  }
  pq->initialized = TRUE;
}


PQhandle pqInsert( PriorityQ *pq, PQkey keyNew )
{
  long curr;
  PQhandle free;

  curr = ++ pq->size;
  if( curr > pq->max ) {
    /* If the heap overflows, double its size. */
    pq->max <<= 1;
    pq->nodes = (PQnode *)memRealloc( pq->nodes, 
				     (size_t) 
				     ((pq->max + 1) * sizeof( pq->nodes[0] )));
    pq->handles = (PQhandleElem *)memRealloc( pq->handles,
			                     (size_t)
			                      ((pq->max + 1) * 
					       sizeof( pq->handles[0] )));
  }

  if( pq->freeList == 0 ) {
    free = curr;
  } else {
    free = pq->freeList;
    pq->freeList = pq->handles[free].node;
  }

  pq->nodes[curr].handle = free;
  pq->handles[free].node = curr;
  pq->handles[free].key = keyNew;

  if( pq->initialized ) {
    FloatUp( pq, curr );
  }
  return free;
}


PQkey pqExtractMin( PriorityQ *pq )
{
  PQnode *n = pq->nodes;
  PQhandleElem *h = pq->handles;
  PQhandle hMin = n[1].handle;
  PQkey min = h[hMin].key;

  if( pq->size > 0 ) {
    n[1].handle = n[pq->size].handle;
    h[n[1].handle].node = 1;

    h[hMin].key = NULL;
    h[hMin].node = pq->freeList;
    pq->freeList = hMin;

    if( -- pq->size > 0 ) {
      FloatDown( pq, 1 );
    }
  }
  return min;
}


void pqDelete( PriorityQ *pq, PQhandle hCurr )
{
  PQnode *n = pq->nodes;
  PQhandleElem *h = pq->handles;
  long curr;

  assert( hCurr >= 1 && hCurr <= pq->max && h[hCurr].key != NULL );

  curr = h[hCurr].node;
  n[curr].handle = n[pq->size].handle;
  h[n[curr].handle].node = curr;

  if( curr <= -- pq->size ) {
    if( curr <= 1 || LEQ( h[n[curr>>1].handle].key, h[n[curr].handle].key )) {
      FloatDown( pq, curr );
    } else {
      FloatUp( pq, curr );
    }
  }
  h[hCurr].key = NULL;
  h[hCurr].node = pq->freeList;
  pq->freeList = hCurr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\sweep.h ===
#ifndef __sweep_h_
#define __sweep_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "mesh.h"

/* __gl_computeInterior( tess ) computes the planar arrangement specified
 * by the given contours, and further subdivides this arrangement
 * into regions.  Each region is marked "inside" if it belongs
 * to the polygon, according to the rule given by tess->windingRule.
 * Each interior region is guaranteed be monotone.
 */
void __gl_computeInterior( GLUtesselator *tess );


/* The following is here *only* for access by debugging routines */

#include "dict.h"

/* For each pair of adjacent edges crossing the sweep line, there is
 * an ActiveRegion to represent the region between them.  The active
 * regions are kept in sorted order in a dynamic dictionary.  As the
 * sweep line crosses each vertex, we update the affected regions.
 */

struct ActiveRegion {
  GLUhalfEdge	*eUp;		/* upper edge, directed right to left */
  DictNode	*nodeUp;	/* dictionary node corresponding to eUp */
  int		windingNumber;	/* used to determine which regions are
                                 * inside the polygon */
  GLboolean	inside;		/* is this region inside the polygon? */
  GLboolean	sentinel;	/* marks fake edges at t = +/-infinity */
  GLboolean	dirty;		/* marks regions where the upper or lower
                                 * edge has changed, but we haven't checked
                                 * whether they intersect yet */
  GLboolean	fixUpperEdge;	/* marks temporary edges introduced when
                                 * we process a "right vertex" (one without
                                 * any edges leaving to the right) */
};

#define RegionBelow(r)	((ActiveRegion *) dictKey(dictPred((r)->nodeUp)))
#define RegionAbove(r)	((ActiveRegion *) dictKey(dictSucc((r)->nodeUp)))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\tessmono.h ===
#ifndef __tessmono_h_
#define __tessmono_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/


/* __gl_meshTesselateMonoRegion( face ) tesselates a monotone region
 * (what else would it do??)  The region must consist of a single
 * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
 * case means that any vertical line intersects the interior of the
 * region in a single interval.  
 *
 * Tesselation consists of adding interior edges (actually pairs of
 * half-edges), to split the region into non-overlapping triangles.
 *
 * __gl_meshTesselateInterior( mesh ) tesselates each region of
 * the mesh which is marked "inside" the polygon.  Each such region
 * must be monotone.
 *
 * __gl_meshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
 * which are not marked "inside" the polygon.  Since further mesh operations
 * on NULL faces are not allowed, the main purpose is to clean up the
 * mesh so that exterior loops are not represented in the data structure.
 *
 * __gl_meshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
 * winding numbers on all edges so that regions marked "inside" the
 * polygon have a winding number of "value", and regions outside
 * have a winding number of 0.
 *
 * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
 * separate an interior region from an exterior one.
 */

void __gl_meshTesselateMonoRegion( GLUface *face );
void __gl_meshTesselateInterior( GLUmesh *mesh );
void __gl_meshDiscardExterior( GLUmesh *mesh );
void __gl_meshSetWindingNumber( GLUmesh *mesh, int value,
			        GLboolean keepOnlyBoundary );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\tessmono.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include "geom.h"
#include "mesh.h"
#include "tessmono.h"
#include <assert.h>

#define AddWinding(eDst,eSrc)	(eDst->winding += eSrc->winding, \
				 eDst->Sym->winding += eSrc->Sym->winding)

/* __gl_meshTesselateMonoRegion( face ) tesselates a monotone region
 * (what else would it do??)  The region must consist of a single
 * loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
 * case means that any vertical line intersects the interior of the
 * region in a single interval.  
 *
 * Tesselation consists of adding interior edges (actually pairs of
 * half-edges), to split the region into non-overlapping triangles.
 *
 * The basic idea is explained in Preparata and Shamos (which I don''t
 * have handy right now), although their implementation is more
 * complicated than this one.  The are two edge chains, an upper chain
 * and a lower chain.  We process all vertices from both chains in order,
 * from right to left.
 *
 * The algorithm ensures that the following invariant holds after each
 * vertex is processed: the untesselated region consists of two
 * chains, where one chain (say the upper) is a single edge, and
 * the other chain is concave.  The left vertex of the single edge
 * is always to the left of all vertices in the concave chain.
 *
 * Each step consists of adding the rightmost unprocessed vertex to one
 * of the two chains, and forming a fan of triangles from the rightmost
 * of two chain endpoints.  Determining whether we can add each triangle
 * to the fan is a simple orientation test.  By making the fan as large
 * as possible, we restore the invariant (check it yourself).
 */
void __gl_meshTesselateMonoRegion( GLUface *face )
{
  GLUhalfEdge *up, *lo;

  /* All edges are oriented CCW around the boundary of the region.
   * First, find the half-edge whose origin vertex is rightmost.
   * Since the sweep goes from left to right, face->anEdge should
   * be close to the edge we want.
   */
  up = face->anEdge;
  assert( up->Lnext != up && up->Lnext->Lnext != up );

  for( ; VertLeq( up->Dst, up->Org ); up = up->Lprev )
    ;
  for( ; VertLeq( up->Org, up->Dst ); up = up->Lnext )
    ;
  lo = up->Lprev;

  while( up->Lnext != lo ) {
    if( VertLeq( up->Dst, lo->Org )) {
      /* up->Dst is on the left.  It is safe to form triangles from lo->Org.
       * The EdgeGoesLeft test guarantees progress even when some triangles
       * are CW, given that the upper and lower chains are truly monotone.
       */
      while( lo->Lnext != up && (EdgeGoesLeft( lo->Lnext )
	     || EdgeSign( lo->Org, lo->Dst, lo->Lnext->Dst ) <= 0 )) {
	lo = __gl_meshConnect( lo->Lnext, lo )->Sym;
      }
      lo = lo->Lprev;
    } else {
      /* lo->Org is on the left.  We can make CCW triangles from up->Dst. */
      while( lo->Lnext != up && (EdgeGoesRight( up->Lprev )
	     || EdgeSign( up->Dst, up->Org, up->Lprev->Org ) >= 0 )) {
	up = __gl_meshConnect( up, up->Lprev )->Sym;
      }
      up = up->Lnext;
    }
  }

  /* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region
   * can be tesselated in a fan from this leftmost vertex.
   */
  assert( lo->Lnext != up );
  while( lo->Lnext->Lnext != up ) {
    lo = __gl_meshConnect( lo->Lnext, lo )->Sym;
  }
}


/* __gl_meshTesselateInterior( mesh ) tesselates each region of
 * the mesh which is marked "inside" the polygon.  Each such region
 * must be monotone.
 */
void __gl_meshTesselateInterior( GLUmesh *mesh )
{
  GLUface *f, *next;

  /*LINTED*/
  for( f = mesh->fHead.next; f != &mesh->fHead; f = next ) {
    /* Make sure we don''t try to tesselate the new triangles. */
    next = f->next;
    if( f->inside ) {
      __gl_meshTesselateMonoRegion( f );
    }
  }
}


/* __gl_meshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
 * which are not marked "inside" the polygon.  Since further mesh operations
 * on NULL faces are not allowed, the main purpose is to clean up the
 * mesh so that exterior loops are not represented in the data structure.
 */
void __gl_meshDiscardExterior( GLUmesh *mesh )
{
  GLUface *f, *next;

  /*LINTED*/
  for( f = mesh->fHead.next; f != &mesh->fHead; f = next ) {
    /* Since f will be destroyed, save its next pointer. */
    next = f->next;
    if( ! f->inside ) {
      __gl_meshZapFace( f );
    }
  }
}

#define MARKED_FOR_DELETION	0x7fffffff

/* __gl_meshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
 * winding numbers on all edges so that regions marked "inside" the
 * polygon have a winding number of "value", and regions outside
 * have a winding number of 0.
 *
 * If keepOnlyBoundary is TRUE, it also deletes all edges which do not
 * separate an interior region from an exterior one.
 */
void __gl_meshSetWindingNumber( GLUmesh *mesh, int value,
			        GLboolean keepOnlyBoundary )
{
  GLUhalfEdge *e, *eNext;

  for( e = mesh->eHead.next; e != &mesh->eHead; e = eNext ) {
    eNext = e->next;
    if( e->Rface->inside != e->Lface->inside ) {

      /* This is a boundary edge (one side is interior, one is exterior). */
      e->winding = (e->Lface->inside) ? value : -value;
    } else {

      /* Both regions are interior, or both are exterior. */
      if( ! keepOnlyBoundary ) {
	e->winding = 0;
      } else {
	__gl_meshDelete( e );
      }
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\tesselat.h ===
#ifndef __tesselator_h_
#define __tesselator_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

/* General polygon tesselation.
 *
 * Tesselates polygons consisting of one or more contours, which can
 * be concave, self-intersecting, or degenerate.
 */

#include <stddef.h>
#ifdef NT
#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#else
#include "GL/gl.h"
#endif

/* GLU_TESS_MAX_COORD must be small enough that we can multiply
 * and add coordinates without overflow.
 */

#ifdef GLU_TESS_API_FLOAT
typedef float  GLUcoord;
#define GLU_TESS_MAX_COORD		1.0e18
#define GLU_TESS_DEFAULT_TOLERANCE	0.0

#else
typedef GLdouble GLUcoord;
#define GLU_TESS_MAX_COORD		1.0e150
#define GLU_TESS_DEFAULT_TOLERANCE	0.0

#endif

// mesh stuff that is not included in glu.h:
typedef struct GLUmesh GLUmesh;
// void    gluTessDeleteMesh(  GLUmesh *mesh );
// #define GLU_TESS_MESH		100106	/* void (*)(GLUmesh *mesh) */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libutil\error.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.4 $
** $Date: 1994/09/09 06:03:33 $
*/
#ifdef NT
#include <glos.h>
#endif
#include "gluint.h"
#include <GL/glu.h>

#ifndef NT
#include <stdio.h>
#include <stdlib.h>
#else
#include "glstring.h"
#endif

#ifndef NT

static const char *glErrorStrings[GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1] = {
    "invalid enumerant",
    "invalid value",
    "invalid operation",
    "stack overflow",
    "stack underflow",
    "out of memory",
};

static const char *gluErrorStrings[GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1] = {
    "invalid enumerant",
    "invalid value",
    "out of memory",
};

#define NERRORS (sizeof(errorStrings)/sizeof(errorStrings[0]))

#else

// For NT, rather using statically allocated strings, we use statically
// allocated string resource identifiers.  The string arrays are dynamically
// initialized using the resource ids to load the appropriate string resource.
// This make localization of the strings easier.

static char  *pszNoError;   // "no error"
static WCHAR *pwszNoError;  // L"no error"

static UINT auiGlErrorStrings[GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1] = {
    STR_GLU_INVALID_ENUM,   // "invalid enumerant"
    STR_GLU_INVALID_VAL ,   // "invalid value"
    STR_GLU_INVALID_OP  ,   // "invalid operation"
    STR_GLU_STACK_OVER  ,   // "stack overflow"
    STR_GLU_STACK_UNDER ,   // "stack underflow"
    STR_GLU_OUT_OF_MEM      // "out of memory"
};

static const char *glErrorStrings[GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1];
static const WCHAR *glErrorStringsW[GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1];

static UINT auiGluErrorStrings[GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1] = {
    STR_GLU_INVALID_ENUM,   // "invalid enumerant"
    STR_GLU_INVALID_VAL ,   // "invalid value"
    STR_GLU_OUT_OF_MEM      // "out of memory"
};
static const char *gluErrorStrings[GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1];
static const WCHAR *gluErrorStringsW[GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1];

char *pszGetResourceStringA(HINSTANCE hMod, UINT uiID)
{
    char *pch;
    char ach[MAX_PATH+1];

    if (!LoadStringA(hMod, uiID, ach, MAX_PATH+1))
        ach[0] = '\0';

    pch = (char *) LocalAlloc(LMEM_FIXED, (lstrlenA(ach)+1) * sizeof(char));
    if (pch)
        lstrcpyA(pch, ach);

    return pch;
}

WCHAR *pwszGetResourceStringW(HINSTANCE hMod, UINT uiID)
{
    WCHAR *pwch;
    WCHAR awch[MAX_PATH+1];

    if (!LoadStringW(hMod, uiID, awch, MAX_PATH+1))
        awch[0] = L'\0';

    pwch = (WCHAR *) LocalAlloc(LMEM_FIXED, (lstrlenW(awch)+1) * sizeof(WCHAR));
    if (pwch)
        lstrcpyW(pwch, awch);

    return pwch;
}

VOID vInitGluStrings(HINSTANCE hMod, BOOL bAnsi)
{
    int i;

    if (bAnsi)
    {
        pszNoError = pszGetResourceStringA(hMod, STR_GLU_NO_ERROR);

        for (i = 0; i < (GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1); i++)
            glErrorStrings[i] = pszGetResourceStringA(hMod, auiGlErrorStrings[i]);

        for (i = 0; i < (GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1); i++)
            gluErrorStrings[i] = pszGetResourceStringA(hMod, auiGluErrorStrings[i]);
    }
    else
    {
        pwszNoError = pwszGetResourceStringW(hMod, STR_GLU_NO_ERROR);

        for (i = 0; i < (GL_OUT_OF_MEMORY - GL_INVALID_ENUM + 1); i++)
            glErrorStringsW[i] = pwszGetResourceStringW(hMod, auiGlErrorStrings[i]);

        for (i = 0; i < (GLU_OUT_OF_MEMORY - GLU_INVALID_ENUM + 1); i++)
            gluErrorStringsW[i] = pwszGetResourceStringW(hMod, auiGluErrorStrings[i]);
    }
}

VOID vInitErrorStrings(BOOL bAnsi)
{
    static BOOL bInitializedAnsi = FALSE;
    static BOOL bInitializedUnicode = FALSE;

    if ( (bAnsi && !bInitializedAnsi) ||
         (!bAnsi && !bInitializedUnicode) )
    {
        HINSTANCE hMod = (HINSTANCE) GetModuleHandle("glu32.dll");

        vInitGluStrings(hMod, bAnsi);
        vInitNurbStrings(hMod, bAnsi);
        vInitTessStrings(hMod, bAnsi);

        if (bAnsi)
            bInitializedAnsi = TRUE;
        else
            bInitializedUnicode = TRUE;
    }
}

const wchar_t* APIENTRY gluErrorUnicodeStringEXT(GLenum errorCode)
{
    vInitErrorStrings(FALSE);

    if (errorCode == 0) {
        return (LPCWSTR) pwszNoError;
    }
    if ((errorCode >= GL_INVALID_ENUM) && (errorCode <= GL_OUT_OF_MEMORY)) {
        return (LPCWSTR) glErrorStringsW[errorCode - GL_INVALID_ENUM];
    }
    if ((errorCode >= GLU_INVALID_ENUM) && (errorCode <= GLU_OUT_OF_MEMORY)) {
        return (LPCWSTR) gluErrorStringsW[errorCode - GLU_INVALID_ENUM];
    }
    if ((errorCode >= GLU_NURBS_ERROR1) && (errorCode <= GLU_NURBS_ERROR37)) {
        return (LPCWSTR) __glNURBSErrorStringW(errorCode - (GLU_NURBS_ERROR1 - 1));
    }
    if ((errorCode >= GLU_TESS_ERROR1) && (errorCode <= GLU_TESS_ERROR8)) {
        return (LPCWSTR) __glTessErrorStringW(errorCode - GLU_TESS_ERROR1);
    }
    return 0;
}

#endif

const GLubyte* APIENTRY gluErrorString(GLenum errorCode)
{
#ifdef NT
    vInitErrorStrings(TRUE);
#endif

    if (errorCode == 0) {
#ifdef NT
        return (const unsigned char *) pszNoError;
#else
	return (const unsigned char *) "no error";
#endif
    }
    if ((errorCode >= GL_INVALID_ENUM) && (errorCode <= GL_OUT_OF_MEMORY)) {
	return (const unsigned char *) glErrorStrings[errorCode - GL_INVALID_ENUM];
    }
    if ((errorCode >= GLU_INVALID_ENUM) && (errorCode <= GLU_OUT_OF_MEMORY)) {
	return (const unsigned char *) gluErrorStrings[errorCode - GLU_INVALID_ENUM];
    }
    if ((errorCode >= GLU_NURBS_ERROR1) && (errorCode <= GLU_NURBS_ERROR37)) {
	return (const unsigned char *) __glNURBSErrorString(errorCode - (GLU_NURBS_ERROR1 - 1));
    }
    if ((errorCode >= GLU_TESS_ERROR1) && (errorCode <= GLU_TESS_ERROR8)) {
	return (const unsigned char *) __glTessErrorString(errorCode - GLU_TESS_ERROR1);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\tess.h ===
#ifndef __tess_h_
#define __tess_h_

/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#ifdef NT
#include <glos.h>
#endif
#include <GL/glu.h>
#include "mesh.h"
#include "dict.h"
#ifdef NT
#include "priority.h"
#else
#include "priorityq.h"
#endif

/* The begin/end calls must be properly nested.  We keep track of
 * the current state to enforce the ordering.
 */
enum TessState { T_DORMANT, T_IN_POLYGON, T_IN_CONTOUR };

/* We cache vertex data for single-contour polygons so that we can
 * try a quick-and-dirty decomposition first.
 */
#define TESS_MAX_CACHE	100

typedef struct CachedVertex {
  GLdouble	coords[3];
  void		*data;
} CachedVertex;

struct GLUtesselator {

  /*** state needed for collecting the input data ***/

  GLenum	state;		/* what begin/end calls have we seen? */

  GLUhalfEdge	*lastEdge;	/* lastEdge->Org is the most recent vertex */
  GLUmesh	*mesh;		/* stores the input contours, and eventually
                                   the tesselation itself */

  void		(*callError)( GLenum errno );

  /*** state needed for projecting onto the sweep plane ***/

  GLdouble	normal[3];	/* user-specified normal (if provided) */
  GLdouble	sUnit[3];	/* unit vector in s-direction (debugging) */
  GLdouble	tUnit[3];	/* unit vector in t-direction (debugging) */

  /*** state needed for the line sweep ***/

  GLdouble	relTolerance;	/* tolerance for merging features */
  GLenum	windingRule;	/* rule for determining polygon interior */
  GLboolean	fatalError;	/* fatal error: needed combine callback */

  Dict		*dict;		/* edge dictionary for sweep line */
  PriorityQ	*pq;		/* priority queue of vertex events */
  GLUvertex	*event;		/* current sweep event being processed */

  void		(*callCombine)( GLdouble coords[3], void *data[4],
			        GLfloat weight[4], void **outData );

  /*** state needed for rendering callbacks (see render.c) ***/

  GLboolean	flagBoundary;	/* mark boundary edges (use EdgeFlag) */
  GLboolean	boundaryOnly;	/* Extract contours, not triangles */
  GLUface	*lonelyTriList;
    /* list of triangles which could not be rendered as strips or fans */

  void		(*callBegin)( GLenum type );
  void		(*callEdgeFlag)( GLboolean boundaryEdge );
  void		(*callVertex)( void *data );
  void		(*callEnd)( void );
  void      (*callMesh)( GLUmesh *mesh );  // not part of NT api

  /*** state needed to cache single-contour polygons for renderCache() */

  GLboolean	emptyCache;		/* empty cache on next vertex() call */
  int		cacheCount;		/* number of cached vertices */
  CachedVertex	cache[TESS_MAX_CACHE];	/* the vertex data */

  /*** rendering callbacks that also pass polygon data  ***/ 
  void		(*callBeginData)( GLenum type, void *polygonData );
  void		(*callEdgeFlagData)( GLboolean boundaryEdge, 
				     void *polygonData );
  void		(*callVertexData)( void *data, void *polygonData );
  void		(*callEndData)( void *polygonData );
  void		(*callErrorData)( GLenum errno, void *polygonData );
  void		(*callCombineData)( GLdouble coords[3], void *data[4],
				    GLfloat weight[4], void **outData,
				    void *polygonData );

  void *polygonData;		/* client data for current polygon */
};

void __gl_noBeginData( GLenum type, void *polygonData );
void __gl_noEdgeFlagData( GLboolean boundaryEdge, void *polygonData );
void __gl_noVertexData( void *data, void *polygonData );
void __gl_noEndData( void *polygonData );
void __gl_noErrorData( GLenum errno, void *polygonData );
void __gl_noCombineData( GLdouble coords[3], void *data[4],
			 GLfloat weight[4], void **outData,
			 void *polygonData );

#define CALL_BEGIN_OR_BEGIN_DATA(a) \
   if (tess->callBeginData != &__gl_noBeginData) \
      (*tess->callBeginData)((a),tess->polygonData); \
   else (*tess->callBegin)((a));

#define CALL_VERTEX_OR_VERTEX_DATA(a) \
   if (tess->callVertexData != &__gl_noVertexData) \
      (*tess->callVertexData)((a),tess->polygonData); \
   else (*tess->callVertex)((a));

#define CALL_EDGE_FLAG_OR_EDGE_FLAG_DATA(a) \
   if (tess->callEdgeFlagData != &__gl_noEdgeFlagData) \
      (*tess->callEdgeFlagData)((a),tess->polygonData); \
   else (*tess->callEdgeFlag)((a));

#define CALL_END_OR_END_DATA() \
   if (tess->callEndData != &__gl_noEndData) \
      (*tess->callEndData)(tess->polygonData); \
   else (*tess->callEnd)();

#define CALL_COMBINE_OR_COMBINE_DATA(a,b,c,d) \
   if (tess->callCombineData != &__gl_noCombineData) \
      (*tess->callCombineData)((a),(b),(c),(d),tess->polygonData); \
   else (*tess->callCombine)((a),(b),(c),(d));

#define CALL_ERROR_OR_ERROR_DATA(a) \
   if (tess->callErrorData != &__gl_noErrorData) \
      (*tess->callErrorData)((a),tess->polygonData); \
   else (*tess->callError)((a));

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\tess.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <assert.h>
#include "memalloc.h"
#include "tess.h"
#include "mesh.h"
#include "normal.h"
#include "sweep.h"
#include "tessmono.h"
#include "render.h"

#define GLU_TESS_DEFAULT_TOLERANCE 0.0
#ifndef NT
#define GLU_TESS_MESH		100112	/* void (*)(GLUmesh *mesh)	    */
#endif

#define TRUE 1
#define FALSE 0

/*ARGSUSED*/ static void noBegin( GLenum type ) {}
/*ARGSUSED*/ static void noEdgeFlag( GLboolean boundaryEdge ) {}
/*ARGSUSED*/ static void noVertex( void *data ) {}
/*ARGSUSED*/ static void noEnd( void ) {}
/*ARGSUSED*/ static void noError( GLenum errno ) {}
/*ARGSUSED*/ static void noCombine( GLdouble coords[3], void *data[4],
                                    GLfloat weight[4], void **dataOut ) {}
/*ARGSUSED*/ static void noMesh( GLUmesh *mesh ) {}


/*ARGSUSED*/ void __gl_noBeginData( GLenum type, void *polygonData ) {}
/*ARGSUSED*/ void __gl_noEdgeFlagData( GLboolean boundaryEdge, 
				       void *polygonData ) {}
/*ARGSUSED*/ void __gl_noVertexData( void *data, void *polygonData ) {}
/*ARGSUSED*/ void __gl_noEndData( void *polygonData ) {}
/*ARGSUSED*/ void __gl_noErrorData( GLenum errno, void *polygonData ) {}
/*ARGSUSED*/ void __gl_noCombineData( GLdouble coords[3], void *data[4],
			 GLfloat weight[4], void **outData,
			 void *polygonData ) {}

/* Half-edges are allocated in pairs (see mesh.c) */
typedef struct { GLUhalfEdge e, eSym; } EdgePair;

#define MAX(a,b)	((a) > (b) ? (a) : (b))
#define MAX_FAST_ALLOC	(MAX(sizeof(EdgePair), \
			 MAX(sizeof(GLUvertex),sizeof(GLUface))))


#ifdef NT
GLUtesselator* APIENTRY gluNewTess( void )
#else
GLUtesselator *gluNewTess( void )
#endif
{
  GLUtesselator *tess;

  /* Only initialize fields which can be changed by the api.  Other fields
   * are initialized where they are used.
   */

  if (memInit( MAX_FAST_ALLOC ) == 0) {
     return 0;			/* out of memory */
  }
  tess = (GLUtesselator *)memAlloc( sizeof( GLUtesselator ));
  if (tess == NULL) {
     return 0;			/* out of memory */
  }

  tess->state = T_DORMANT;

  tess->normal[0] = 0;
  tess->normal[1] = 0;
  tess->normal[2] = 0;

  tess->relTolerance = GLU_TESS_DEFAULT_TOLERANCE;
  tess->windingRule = GLU_TESS_WINDING_ODD;
  tess->flagBoundary = FALSE;
  tess->boundaryOnly = FALSE;

  tess->callBegin = &noBegin;
  tess->callEdgeFlag = &noEdgeFlag;
  tess->callVertex = &noVertex;
  tess->callEnd = &noEnd;

  tess->callError = &noError;
  tess->callCombine = &noCombine;
  tess->callMesh = &noMesh;

  tess->callBeginData= &__gl_noBeginData;
  tess->callEdgeFlagData= &__gl_noEdgeFlagData;
  tess->callVertexData= &__gl_noVertexData;
  tess->callEndData= &__gl_noEndData;
  tess->callErrorData= &__gl_noErrorData;
  tess->callCombineData= &__gl_noCombineData;

  tess->polygonData= NULL;

  return tess;
}

static void MakeDormant( GLUtesselator *tess )
{
  /* Return the tesselator to its original dormant state. */

  if( tess->mesh != NULL ) {
    __gl_meshDeleteMesh( tess->mesh );
  }
  tess->state = T_DORMANT;
  tess->lastEdge = NULL;
  tess->mesh = NULL;
}

#define RequireState( tess, s )   if( tess->state != s ) GotoState(tess,s)

static void GotoState( GLUtesselator *tess, enum TessState newState )
{
#ifdef NT
  while( tess->state != (GLenum) newState ) {
#else
  while( tess->state != newState ) {
#endif
    /* We change the current state one level at a time, to get to
     * the desired state.
     */
#ifdef NT
    if( tess->state < (GLenum) newState ) {
#else
    if( tess->state < newState ) {
#endif
      switch( tess->state ) {
      case T_DORMANT:
	CALL_ERROR_OR_ERROR_DATA( GLU_TESS_MISSING_BEGIN_POLYGON );
	gluTessBeginPolygon( tess, NULL );
	break;
      case T_IN_POLYGON:
	CALL_ERROR_OR_ERROR_DATA( GLU_TESS_MISSING_BEGIN_CONTOUR );
	gluTessBeginContour( tess );
	break;
      }
    } else {
      switch( tess->state ) {
      case T_IN_CONTOUR:
	CALL_ERROR_OR_ERROR_DATA( GLU_TESS_MISSING_END_CONTOUR );
	gluTessEndContour( tess );
	break;
      case T_IN_POLYGON:
	CALL_ERROR_OR_ERROR_DATA( GLU_TESS_MISSING_END_POLYGON );
	/* gluTessEndPolygon( tess ) is too much work! */
	MakeDormant( tess );
	break;
      }
    }
  }
}


#ifdef NT
void APIENTRY gluDeleteTess( GLUtesselator *tess )
#else
void gluDeleteTess( GLUtesselator *tess )
#endif
{
  RequireState( tess, T_DORMANT );
  memFree( tess );
}


#ifdef NT
void APIENTRY gluTessProperty( GLUtesselator *tess, GLenum which, GLdouble value )
#else
void gluTessProperty( GLUtesselator *tess, GLenum which, GLdouble value )
#endif
{
  GLenum windingRule;

  switch( which ) {
  case GLU_TESS_TOLERANCE:
    if( value < 0.0 || value > 1.0 ) break;
    tess->relTolerance = value;
    return;

  case GLU_TESS_WINDING_RULE:
    windingRule = (GLenum) value;
    if( windingRule != value ) break;	/* not an integer */

    switch( windingRule ) {
    case GLU_TESS_WINDING_ODD:
    case GLU_TESS_WINDING_NONZERO:
    case GLU_TESS_WINDING_POSITIVE:
    case GLU_TESS_WINDING_NEGATIVE:
    case GLU_TESS_WINDING_ABS_GEQ_TWO:
      tess->windingRule = windingRule;
      return;
    default:
      break;
    }

  case GLU_TESS_BOUNDARY_ONLY:
    tess->boundaryOnly = (value != 0);
    return;

  default:
    CALL_ERROR_OR_ERROR_DATA( GLU_INVALID_ENUM );
    return;
  }
  CALL_ERROR_OR_ERROR_DATA( GLU_INVALID_VALUE );
}

/* Returns tesselator property */
#ifdef NT
void APIENTRY gluGetTessProperty( GLUtesselator *tess, GLenum which, GLdouble *value )
#else
void gluGetTessProperty( GLUtesselator *tess, GLenum which, GLdouble *value )
#endif
{
   switch (which) {
   case GLU_TESS_TOLERANCE:
      /* tolerance should be in range [0..1] */
      assert(0.0 <= tess->relTolerance && tess->relTolerance <= 1.0);
      *value= tess->relTolerance;
      break;    
   case GLU_TESS_WINDING_RULE:
      assert(tess->windingRule == GLU_TESS_WINDING_ODD ||
	     tess->windingRule == GLU_TESS_WINDING_NONZERO ||
	     tess->windingRule == GLU_TESS_WINDING_POSITIVE ||
	     tess->windingRule == GLU_TESS_WINDING_NEGATIVE ||
	     tess->windingRule == GLU_TESS_WINDING_ABS_GEQ_TWO);
      *value= tess->windingRule;
      break;
   case GLU_TESS_BOUNDARY_ONLY:
      assert(tess->boundaryOnly == TRUE || tess->boundaryOnly == FALSE);
      *value= tess->boundaryOnly;
      break;
   default:
      *value= 0.0;
      CALL_ERROR_OR_ERROR_DATA( GLU_INVALID_ENUM );
      break;
   }
} /* gluGetTessProperty() */

#ifdef NT
void APIENTRY gluTessNormal( GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z )
#else
void gluTessNormal( GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z )
#endif
{
  tess->normal[0] = x;
  tess->normal[1] = y;
  tess->normal[2] = z;
}

#ifdef NT
void APIENTRY gluTessCallback( GLUtesselator *tess, GLenum which, void (*fn)())
#else
void gluTessCallback( GLUtesselator *tess, GLenum which, void (*fn)())
#endif
{
  switch( which ) {
  case GLU_TESS_BEGIN:
    tess->callBegin = (fn == NULL) ? &noBegin : (void (*)(GLenum)) fn;
    return;
  case GLU_TESS_BEGIN_DATA:
    tess->callBeginData = (fn == NULL) ? &__gl_noBeginData : 
                                         (void (*)(GLenum, void *)) fn;
    return;
  case GLU_TESS_EDGE_FLAG:
    tess->callEdgeFlag = (fn == NULL) ? &noEdgeFlag : (void (*)(GLboolean)) fn;
    /* If the client wants boundary edges to be flagged,
     * we render everything as separate triangles (no strips or fans).
     */
    tess->flagBoundary = (fn != NULL);
    return;
  case GLU_TESS_EDGE_FLAG_DATA:
    tess->callEdgeFlagData= (fn == NULL) ? &__gl_noEdgeFlagData :
                                           (void (*)(GLboolean, void *)) fn; 
    /* If the client wants boundary edges to be flagged,
     * we render everything as separate triangles (no strips or fans).
     */
    tess->flagBoundary = (fn != NULL);
    return;
  case GLU_TESS_VERTEX:
    tess->callVertex = (fn == NULL) ? &noVertex : (void (*)(void *)) fn;
    return;
  case GLU_TESS_VERTEX_DATA:
    tess->callVertexData = (fn == NULL) ? &__gl_noVertexData : 
                                          (void (*)(void *, void *)) fn;
    return;
  case GLU_TESS_END:
    tess->callEnd = (fn == NULL) ? &noEnd : (void (*)(void)) fn;
    return;
  case GLU_TESS_END_DATA:
    tess->callEndData = (fn == NULL) ? &__gl_noEndData : 
                                       (void (*)(void *)) fn;
    return;
  case GLU_TESS_ERROR:
    tess->callError = (fn == NULL) ? &noError : (void (*)(GLenum)) fn;
    return;
  case GLU_TESS_ERROR_DATA:
    tess->callErrorData = (fn == NULL) ? &__gl_noErrorData : 
                                         (void (*)(GLenum, void *)) fn;
    return;
  case GLU_TESS_COMBINE:
    tess->callCombine = (fn == NULL) ? &noCombine :
	(void (*)(GLdouble [3],void *[4], GLfloat [4], void ** )) fn;
    return;
  case GLU_TESS_COMBINE_DATA:
    tess->callCombineData = (fn == NULL) ? &__gl_noCombineData :
                                           (void (*)(GLdouble [3],
						     void *[4], 
						     GLfloat [4], 
						     void **,
						     void *)) fn;
    return;
#ifndef NT
  case GLU_TESS_MESH:
    tess->callMesh = (fn == NULL) ? &noMesh : (void (*)(GLUmesh *)) fn;
    return;
#endif
  default:
    CALL_ERROR_OR_ERROR_DATA( GLU_INVALID_ENUM );
    return;
  }
}

static void AddVertex( GLUtesselator *tess, GLdouble coords[3], void *data )
{
  GLUhalfEdge *e;

  e = tess->lastEdge;
  if( e == NULL ) {
    /* Make a self-loop (one vertex, one edge). */

    e = __gl_meshMakeEdge( tess->mesh );
    __gl_meshSplice( e, e->Sym );
  } else {
    /* Create a new vertex and edge which immediately follow e
     * in the ordering around the left face.
     */
    (void) __gl_meshSplitEdge( e );
    e = e->Lnext;
  }

  /* The new vertex is now e->Org. */
  e->Org->data = data;
  e->Org->coords[0] = coords[0];
  e->Org->coords[1] = coords[1];
  e->Org->coords[2] = coords[2];
  
  /* The winding of an edge says how the winding number changes as we
   * cross from the edge''s right face to its left face.  We add the
   * vertices in such an order that a CCW contour will add +1 to
   * the winding number of the region inside the contour.
   */
  e->winding = 1;
  e->Sym->winding = -1;

  tess->lastEdge = e;
}


static void CacheVertex( GLUtesselator *tess, GLdouble coords[3], void *data )
{
  CachedVertex *v = &tess->cache[tess->cacheCount];

  v->data = data;
  v->coords[0] = coords[0];
  v->coords[1] = coords[1];
  v->coords[2] = coords[2];
  ++tess->cacheCount;
}


static void EmptyCache( GLUtesselator *tess )
{
  CachedVertex *v = tess->cache;
  CachedVertex *vLast;

  tess->mesh = __gl_meshNewMesh();

  for( vLast = v + tess->cacheCount; v < vLast; ++v ) {
    AddVertex( tess, v->coords, v->data );
  }
  tess->cacheCount = 0;
  tess->emptyCache = FALSE;
}


#ifdef NT
void APIENTRY gluTessVertex( GLUtesselator *tess, GLdouble coords[3], void *data )
#else
void gluTessVertex( GLUtesselator *tess, GLdouble coords[3], void *data )
#endif
{
  int i, tooLarge = FALSE;
  GLdouble x, clamped[3];

  RequireState( tess, T_IN_CONTOUR );

  if( tess->emptyCache ) {
    EmptyCache( tess );
    tess->lastEdge = NULL;
  }
  for( i = 0; i < 3; ++i ) {
    x = coords[i];
    if( x < - GLU_TESS_MAX_COORD ) {
      x = - GLU_TESS_MAX_COORD;
      tooLarge = TRUE;
    }
    if( x > GLU_TESS_MAX_COORD ) {
      x = GLU_TESS_MAX_COORD;
      tooLarge = TRUE;
    }
    clamped[i] = x;
  }
  if( tooLarge ) {
    CALL_ERROR_OR_ERROR_DATA( GLU_TESS_COORD_TOO_LARGE );
  }

  if( tess->mesh == NULL ) {
    if( tess->cacheCount < TESS_MAX_CACHE ) {
      CacheVertex( tess, clamped, data );
      return;
    }
    EmptyCache( tess );
  }
  AddVertex( tess, clamped, data );
}


#ifdef NT
void APIENTRY gluTessBeginPolygon( GLUtesselator *tess, void *data )
#else
void gluTessBeginPolygon( GLUtesselator *tess, void *data )
#endif
{
  RequireState( tess, T_DORMANT );

  tess->state = T_IN_POLYGON;
  tess->cacheCount = 0;
  tess->emptyCache = FALSE;
  tess->mesh = NULL;

  tess->polygonData= data;
}


#ifdef NT
void APIENTRY gluTessBeginContour( GLUtesselator *tess )
#else
void gluTessBeginContour( GLUtesselator *tess )
#endif
{
  RequireState( tess, T_IN_POLYGON );

  tess->state = T_IN_CONTOUR;
  tess->lastEdge = NULL;
  if( tess->cacheCount > 0 ) {
    /* Just set a flag so we don't get confused by empty contours
     * -- these can be generated accidentally with the obsolete
     * NextContour() interface.
     */
    tess->emptyCache = TRUE;
  }
}


#ifdef NT
void APIENTRY gluTessEndContour( GLUtesselator *tess )
#else
void gluTessEndContour( GLUtesselator *tess )
#endif
{
  RequireState( tess, T_IN_CONTOUR );
  tess->state = T_IN_POLYGON;
}


#ifdef NT
void APIENTRY gluTessEndPolygon( GLUtesselator *tess )
#else
void gluTessEndPolygon( GLUtesselator *tess )
#endif
{
  GLUmesh *mesh;

  RequireState( tess, T_IN_POLYGON );
  tess->state = T_DORMANT;

  if( tess->mesh == NULL ) {
    if( ! tess->flagBoundary && tess->callMesh == &noMesh ) {

      /* Try some special code to make the easy cases go quickly
       * (eg. convex polygons).  This code does NOT handle multiple contours,
       * intersections, edge flags, and of course it does not generate
       * an explicit mesh either.
       */
      if( __gl_renderCache( tess )) {
	tess->polygonData= NULL; 
	return;
      }
    }
    EmptyCache( tess );
  }

  /* Determine the polygon normal and project vertices onto the plane
   * of the polygon.
   */
  __gl_projectPolygon( tess );

  /* __gl_computeInterior( tess ) computes the planar arrangement specified
   * by the given contours, and further subdivides this arrangement
   * into regions.  Each region is marked "inside" if it belongs
   * to the polygon, according to the rule given by tess->windingRule.
   * Each interior region is guaranteed be monotone.
   */
  __gl_computeInterior( tess );

  mesh = tess->mesh;
  if( ! tess->fatalError ) {
    /* If the user wants only the boundary contours, we throw away all edges
     * except those which separate the interior from the exterior.
     * Otherwise we tesselate all the regions marked "inside".
     */
    if( tess->boundaryOnly ) {
      __gl_meshSetWindingNumber( mesh, 1, TRUE );
    } else {
      __gl_meshTesselateInterior( mesh );
    }
    __gl_meshCheckMesh( mesh );

    if( tess->callBegin != &noBegin || tess->callEnd != &noEnd
       || tess->callVertex != &noVertex || tess->callEdgeFlag != &noEdgeFlag 
       || tess->callBeginData != &__gl_noBeginData 
       || tess->callEndData != &__gl_noEndData
       || tess->callVertexData != &__gl_noVertexData
       || tess->callEdgeFlagData != &__gl_noEdgeFlagData )
    {
      if( tess->boundaryOnly ) {
	__gl_renderBoundary( tess, mesh );  /* output boundary contours */
      } else {
	__gl_renderMesh( tess, mesh );	   /* output strips and fans */
      }
    }
    if( tess->callMesh != &noMesh ) {

      /* Throw away the exterior faces, so that all faces are interior.
       * This way the user doesn't have to check the "inside" flag,
       * and we don't need to even reveal its existence.  It also leaves
       * the freedom for an implementation to not generate the exterior
       * faces in the first place.
       */
      __gl_meshDiscardExterior( mesh );
      (*tess->callMesh)( mesh );		/* user wants the mesh itself */
      tess->mesh = NULL;
      tess->polygonData= NULL;
      return;
    }
  }
  __gl_meshDeleteMesh( mesh );
  tess->polygonData= NULL;
  tess->mesh = NULL;
}


#ifndef NT
void gluDeleteMesh( GLUmesh *mesh )
{
  __gl_meshDeleteMesh( mesh );
}
#endif


/*******************************************************/

/* Obsolete calls -- for backward compatibility */

#ifdef NT
void APIENTRY gluBeginPolygon( GLUtesselator *tess )
#else
void gluBeginPolygon( GLUtesselator *tess )
#endif
{
  gluTessBeginPolygon( tess, NULL );
  gluTessBeginContour( tess );
}


/*ARGSUSED*/
#ifdef NT
void APIENTRY gluNextContour( GLUtesselator *tess, GLenum type )
#else
void gluNextContour( GLUtesselator *tess, GLenum type )
#endif
{
  gluTessEndContour( tess );
  gluTessBeginContour( tess );
}


#ifdef NT
void APIENTRY gluEndPolygon( GLUtesselator *tess )
#else
void gluEndPolygon( GLUtesselator *tess )
#endif
{
  gluTessEndContour( tess );
  gluTessEndPolygon( tess );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libtess\sweep.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Author: Eric Veach, July 1994.
*/

#include <assert.h>
#include <stddef.h>

#include "mesh.h"
#include "geom.h"
#include "tess.h"
#include "dict.h"
#ifdef NT
#include "priority.h"
#else
#include "priorityq.h"
#endif
#include "memalloc.h"
#include "sweep.h"

#define TRUE 1
#define FALSE 0

#ifdef DEBUG
extern void DebugEvent( GLUtesselator *tess );
#else
#define DebugEvent( tess )
#endif

/*
 * Invariants for the Edge Dictionary.
 * - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
 *   at any valid location of the sweep event
 * - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
 *   share a common endpoint
 * - for each e, e->Dst has been processed, but not e->Org
 * - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)
 *   where "event" is the current sweep line event.
 * - no edge e has zero length
 *
 * Invariants for the Mesh (the processed portion).
 * - the portion of the mesh left of the sweep line is a planar graph,
 *   ie. there is *some* way to embed it in the plane
 * - no processed edge has zero length
 * - no two processed vertices have identical coordinates
 * - each "inside" region is monotone, ie. can be broken into two chains
 *   of monotonically increasing vertices according to VertLeq(v1,v2)
 *   - a non-invariant: these chains may intersect (very slightly)
 *
 * Invariants for the Sweep.
 * - if none of the edges incident to the event vertex have an activeRegion
 *   (ie. none of these edges are in the edge dictionary), then the vertex
 *   has only right-going edges.
 * - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
 *   by ConnectRightVertex), then it is the only right-going edge from
 *   its associated vertex.  (This says that these edges exist only
 *   when it is necessary.)
 */

#define MAX(x,y)	((x) >= (y) ? (x) : (y))
#define MIN(x,y)	((x) <= (y) ? (x) : (y))

/* When we merge two edges into one, we need to compute the combined
 * winding of the new edge.
 */
#define AddWinding(eDst,eSrc)	(eDst->winding += eSrc->winding, \
				 eDst->Sym->winding += eSrc->Sym->winding)

static void SweepEvent( GLUtesselator *tess, GLUvertex *vEvent );
static void WalkDirtyRegions( GLUtesselator *tess, ActiveRegion *regUp );
static int CheckForRightSplice( GLUtesselator *tess, ActiveRegion *regUp );

static int EdgeLeq( GLUtesselator *tess, ActiveRegion *reg1,
		    ActiveRegion *reg2 )
/*
 * Both edges must be directed from right to left (this is the canonical
 * direction for the upper edge of each region).
 *
 * The strategy is to evaluate a "t" value for each edge at the
 * current sweep line position, given by tess->event.  The calculations
 * are designed to be very stable, but of course they are not perfect.
 *
 * Special case: if both edge destinations are at the sweep event,
 * we sort the edges by slope (they would otherwise compare equally).
 */
{
  GLUvertex *event = tess->event;
  GLUhalfEdge *e1, *e2;
  GLdouble t1, t2;

  e1 = reg1->eUp;
  e2 = reg2->eUp;

  if( e1->Dst == event ) {
    if( e2->Dst == event ) {
      /* Two edges right of the sweep line which meet at the sweep event.
       * Sort them by slope.
       */
      if( VertLeq( e1->Org, e2->Org )) {
	return EdgeSign( e2->Dst, e1->Org, e2->Org ) <= 0;
      }
      return EdgeSign( e1->Dst, e2->Org, e1->Org ) >= 0;
    }
    return EdgeSign( e2->Dst, event, e2->Org ) <= 0;
  }
  if( e2->Dst == event ) {
    return EdgeSign( e1->Dst, event, e1->Org ) >= 0;
  }

  /* General case - compute signed distance *from* e1, e2 to event */
  t1 = EdgeEval( e1->Dst, event, e1->Org );
  t2 = EdgeEval( e2->Dst, event, e2->Org );
  return (t1 >= t2);
}


static void DeleteRegion( GLUtesselator *tess, ActiveRegion *reg )
{
  if( reg->fixUpperEdge ) {
    /* It was created with zero winding number, so it better be
     * deleted with zero winding number (ie. it better not get merged
     * with a real edge).
     */
    assert( reg->eUp->winding == 0 );
  }
  reg->eUp->activeRegion = NULL;
  dictDelete( tess->dict, reg->nodeUp );
  memFree( reg );
}


static void FixUpperEdge( ActiveRegion *reg, GLUhalfEdge *newEdge )
/*
 * Replace an upper edge which needs fixing (see ConnectRightVertex).
 */
{
  assert( reg->fixUpperEdge );
  __gl_meshDelete( reg->eUp );
  reg->fixUpperEdge = FALSE;
  reg->eUp = newEdge;
  newEdge->activeRegion = reg;
}

static ActiveRegion *TopLeftRegion( ActiveRegion *reg )
{
  GLUvertex *org = reg->eUp->Org;
  GLUhalfEdge *e;

  /* Find the region above the uppermost edge with the same origin */
  do {
    reg = RegionAbove( reg );
  } while( reg->eUp->Org == org );

  /* If the edge above was a temporary edge introduced by ConnectRightVertex,
   * now is the time to fix it.
   */
  if( reg->fixUpperEdge ) {
    e = __gl_meshConnect( RegionBelow(reg)->eUp->Sym, reg->eUp->Lnext );
    FixUpperEdge( reg, e );
    reg = RegionAbove( reg );
  }
  return reg;
}

static ActiveRegion *TopRightRegion( ActiveRegion *reg )
{
  GLUvertex *dst = reg->eUp->Dst;

  /* Find the region above the uppermost edge with the same destination */
  do {
    reg = RegionAbove( reg );
  } while( reg->eUp->Dst == dst );
  return reg;
}

static ActiveRegion *AddRegionBelow( GLUtesselator *tess,
				     ActiveRegion *regAbove,
				     GLUhalfEdge *eNewUp )
/*
 * Add a new active region to the sweep line, *somewhere* below "regAbove"
 * (according to where the new edge belongs in the sweep-line dictionary).
 * The upper edge of the new region will be "eNewUp".
 * Winding number and "inside" flag are not updated.
 */
{
  ActiveRegion *regNew = (ActiveRegion *)memAlloc( sizeof( ActiveRegion ));

  regNew->eUp = eNewUp;
  regNew->nodeUp = dictInsertBefore( tess->dict, regAbove->nodeUp, regNew );
  regNew->fixUpperEdge = FALSE;
  regNew->sentinel = FALSE;
  regNew->dirty = FALSE;

  eNewUp->activeRegion = regNew;
  return regNew;
}

static GLboolean IsWindingInside( GLUtesselator *tess, int n )
{
  switch( tess->windingRule ) {
  case GLU_TESS_WINDING_ODD:
    return (n & 1);
  case GLU_TESS_WINDING_NONZERO:
    return (n != 0);
  case GLU_TESS_WINDING_POSITIVE:
    return (n > 0);
  case GLU_TESS_WINDING_NEGATIVE:
    return (n < 0);
  case GLU_TESS_WINDING_ABS_GEQ_TWO:
    return (n >= 2) || (n <= -2);
  }
  /*LINTED*/
  assert( FALSE );
  return 0;
  /*NOTREACHED*/
}


static void ComputeWinding( GLUtesselator *tess, ActiveRegion *reg )
{
  reg->windingNumber = RegionAbove(reg)->windingNumber + reg->eUp->winding;
  reg->inside = IsWindingInside( tess, reg->windingNumber );
}


static void FinishRegion( GLUtesselator *tess, ActiveRegion *reg )
/*
 * Delete a region from the sweep line.  This happens when the upper
 * and lower chains of a region meet (at a vertex on the sweep line).
 * The "inside" flag is copied to the appropriate mesh face (we could
 * not do this before -- since the structure of the mesh is always
 * changing, this face may not have even existed until now).
 */
{
  GLUhalfEdge *e = reg->eUp;
  GLUface *f = e->Lface;

  f->inside = reg->inside;
  f->anEdge = e;   /* optimization for __gl_meshTesselateMonoRegion() */
  DeleteRegion( tess, reg );
}


static GLUhalfEdge *FinishLeftRegions( GLUtesselator *tess,
	       ActiveRegion *regFirst, ActiveRegion *regLast )
/*
 * We are given a vertex with one or more left-going edges.  All affected
 * edges should be in the edge dictionary.  Starting at regFirst->eUp,
 * we walk down deleting all regions where both edges have the same
 * origin vOrg.  At the same time we copy the "inside" flag from the
 * active region to the face, since at this point each face will belong
 * to at most one region (this was not necessarily true until this point
 * in the sweep).  The walk stops at the region above regLast; if regLast
 * is NULL we walk as far as possible.  At the same time we relink the
 * mesh if necessary, so that the ordering of edges around vOrg is the
 * same as in the dictionary.
 */
{
  ActiveRegion *reg, *regPrev;
  GLUhalfEdge *e, *ePrev;

  regPrev = regFirst;
  ePrev = regFirst->eUp;
  while( regPrev != regLast ) {
    regPrev->fixUpperEdge = FALSE;	/* placement was OK */
    reg = RegionBelow( regPrev );
    e = reg->eUp;
    if( e->Org != ePrev->Org ) {
      if( ! reg->fixUpperEdge ) {
	/* Remove the last left-going edge.  Even though there are no further
	 * edges in the dictionary with this origin, there may be further
	 * such edges in the mesh (if we are adding left edges to a vertex
	 * that has already been processed).  Thus it is important to call
	 * FinishRegion rather than just DeleteRegion.
	 */
	FinishRegion( tess, regPrev );
	break;
      }
      /* If the edge below was a temporary edge introduced by
       * ConnectRightVertex, now is the time to fix it.
       */
      e = __gl_meshConnect( ePrev->Lprev, e->Sym );
      FixUpperEdge( reg, e );
    }

    /* Relink edges so that ePrev->Onext == e */
    if( ePrev->Onext != e ) {
      __gl_meshSplice( e->Oprev, e );
      __gl_meshSplice( ePrev, e );
    }
    FinishRegion( tess, regPrev );	/* may change reg->eUp */
    ePrev = reg->eUp;
    regPrev = reg;
  }
  return ePrev;
}


static void AddRightEdges( GLUtesselator *tess, ActiveRegion *regUp,
       GLUhalfEdge *eFirst, GLUhalfEdge *eLast, GLUhalfEdge *eTopLeft,
       GLboolean cleanUp )
/*
 * Purpose: insert right-going edges into the edge dictionary, and update
 * winding numbers and mesh connectivity appropriately.  All right-going
 * edges share a common origin vOrg.  Edges are inserted CCW starting at
 * eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any
 * left-going edges already processed, then eTopLeft must be the edge
 * such that an imaginary upward vertical segment from vOrg would be
 * contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft
 * should be NULL.
 */
{
  ActiveRegion *reg, *regPrev;
  GLUhalfEdge *e, *ePrev;
  int firstTime = TRUE;

  /* Insert the new right-going edges in the dictionary */
  e = eFirst;
  do {
    assert( VertLeq( e->Org, e->Dst ));
    AddRegionBelow( tess, regUp, e->Sym );
    e = e->Onext;
  } while ( e != eLast );

  /* Walk *all* right-going edges from e->Org, in the dictionary order,
   * updating the winding numbers of each region, and re-linking the mesh
   * edges to match the dictionary ordering (if necessary).
   */
  if( eTopLeft == NULL ) {
    eTopLeft = RegionBelow( regUp )->eUp->Rprev;
  }
  regPrev = regUp;
  ePrev = eTopLeft;
  for( ;; ) {
    reg = RegionBelow( regPrev );
    e = reg->eUp->Sym;
    if( e->Org != ePrev->Org ) break;

    if( e->Onext != ePrev ) {
      /* Unlink e from its current position, and relink below ePrev */
      __gl_meshSplice( e->Oprev, e );
      __gl_meshSplice( ePrev->Oprev, e );
    }
    /* Compute the winding number and "inside" flag for the new regions */
    reg->windingNumber = regPrev->windingNumber - e->winding;
    reg->inside = IsWindingInside( tess, reg->windingNumber );

    /* Check for two outgoing edges with same slope -- process these
     * before any intersection tests (see example in __gl_computeInterior).
     */
    regPrev->dirty = TRUE;
    if( ! firstTime && CheckForRightSplice( tess, regPrev )) {
      AddWinding( e, ePrev );
      DeleteRegion( tess, regPrev );
      __gl_meshDelete( ePrev );
    }
    firstTime = FALSE;
    regPrev = reg;
    ePrev = e;
  }
  regPrev->dirty = TRUE;
  assert( regPrev->windingNumber - e->winding == reg->windingNumber );

  if( cleanUp ) {
    /* Check for intersections between newly adjacent edges. */
    WalkDirtyRegions( tess, regPrev );
  }
}


static void CallCombine( GLUtesselator *tess, GLUvertex *isect,
			 void *data[4], GLfloat weights[4], int needed )
{
  GLdouble coords[3];

  /* Copy coord data in case the callback changes it. */
  coords[0] = isect->coords[0];
  coords[1] = isect->coords[1];
  coords[2] = isect->coords[2];

  isect->data = NULL;
  CALL_COMBINE_OR_COMBINE_DATA( coords, data, weights, &isect->data );
  if( isect->data == NULL ) {
    if( ! needed ) {
      isect->data = data[0];
    } else if( ! tess->fatalError ) {
      /* The only way fatal error is when two edges are found to intersect,
       * but the user has not provided the callback necessary to handle
       * generated intersection points.
       */
      CALL_ERROR_OR_ERROR_DATA( GLU_TESS_NEED_COMBINE_CALLBACK );
      tess->fatalError = TRUE;
    }
  }
}

static void SpliceMergeVertices( GLUtesselator *tess, GLUhalfEdge *e1,
				 GLUhalfEdge *e2 )
/*
 * Two vertices with idential coordinates are combined into one.
 * e1->Org is kept, while e2->Org is discarded.
 */
{
  void *data[4] = { NULL, NULL, NULL, NULL };
  GLfloat weights[4] = { 0.5, 0.5, 0.0, 0.0 };

  data[0] = e1->Org->data;
  data[1] = e2->Org->data;
  CallCombine( tess, e1->Org, data, weights, FALSE );
  __gl_meshSplice( e1, e2 );
}

static void VertexWeights( GLUvertex *isect, GLUvertex *org, GLUvertex *dst,
                           GLfloat *weights )
/*
 * Find some weights which describe how the intersection vertex is
 * a linear combination of "org" and "dest".  Each of the two edges
 * which generated "isect" is allocated 50% of the weight; each edge
 * splits the weight between its org and dst according to the
 * relative distance to "isect".
 */
{
  GLdouble t1 = VertL1dist( org, isect );
  GLdouble t2 = VertL1dist( dst, isect );

  weights[0] = 0.5 * t2 / (t1 + t2);
  weights[1] = 0.5 * t1 / (t1 + t2);
  isect->coords[0] += weights[0]*org->coords[0] + weights[1]*dst->coords[0];
  isect->coords[1] += weights[0]*org->coords[1] + weights[1]*dst->coords[1];
  isect->coords[2] += weights[0]*org->coords[2] + weights[1]*dst->coords[2];
}


static void GetIntersectData( GLUtesselator *tess, GLUvertex *isect,
       GLUvertex *orgUp, GLUvertex *dstUp,
       GLUvertex *orgLo, GLUvertex *dstLo )
/*
 * We've computed a new intersection point, now we need a "data" pointer
 * from the user so that we can refer to this new vertex in the
 * rendering callbacks.
 */
{
  void *data[4];
  GLfloat weights[4];

  data[0] = orgUp->data;
  data[1] = dstUp->data;
  data[2] = orgLo->data;
  data[3] = dstLo->data;

  isect->coords[0] = isect->coords[1] = isect->coords[2] = 0;
  VertexWeights( isect, orgUp, dstUp, &weights[0] );
  VertexWeights( isect, orgLo, dstLo, &weights[2] );

  CallCombine( tess, isect, data, weights, TRUE );
}

static int CheckForRightSplice( GLUtesselator *tess, ActiveRegion *regUp )
/*
 * Check the upper and lower edge of "regUp", to make sure that the
 * eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
 * origin is leftmost).
 *
 * The main purpose is to splice right-going edges with the same
 * dest vertex and nearly identical slopes (ie. we can't distinguish
 * the slopes numerically).  However the splicing can also help us
 * to recover from numerical errors.  For example, suppose at one
 * point we checked eUp and eLo, and decided that eUp->Org is barely
 * above eLo.  Then later, we split eLo into two edges (eg. from
 * a splice operation like this one).  This can change the result of
 * our test so that now eUp->Org is incident to eLo, or barely below it.
 * We must correct this condition to maintain the dictionary invariants.
 *
 * One possibility is to check these edges for intersection again
 * (ie. CheckForIntersect).  This is what we do if possible.  However
 * CheckForIntersect requires that tess->event lies between eUp and eLo,
 * so that it has something to fall back on when the intersection
 * calculation gives us an unusable answer.  So, for those cases where
 * we can't check for intersection, this routine fixes the problem
 * by just splicing the offending vertex into the other edge.
 * This is a guaranteed solution, no matter how degenerate things get.
 * Basically this is a combinatorial solution to a numerical problem.
 */
{
  ActiveRegion *regLo = RegionBelow(regUp);
  GLUhalfEdge *eUp = regUp->eUp;
  GLUhalfEdge *eLo = regLo->eUp;

  if( VertLeq( eUp->Org, eLo->Org )) {
    if( EdgeSign( eLo->Dst, eUp->Org, eLo->Org ) > 0 ) return FALSE;

    /* eUp->Org appears to be below eLo */
    if( ! VertEq( eUp->Org, eLo->Org )) {
      /* Splice eUp->Org into eLo */
      __gl_meshSplitEdge( eLo->Sym );
      __gl_meshSplice( eUp, eLo->Oprev );
      regUp->dirty = regLo->dirty = TRUE;

    } else if( eUp->Org != eLo->Org ) {
      /* merge the two vertices, discarding eUp->Org */
      pqDelete( tess->pq, eUp->Org->pqHandle );
      SpliceMergeVertices( tess, eLo->Oprev, eUp );
    }
  } else {
    if( EdgeSign( eUp->Dst, eLo->Org, eUp->Org ) < 0 ) return FALSE;

    /* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */
    RegionAbove(regUp)->dirty = regUp->dirty = TRUE;
    __gl_meshSplitEdge( eUp->Sym );
    __gl_meshSplice( eLo->Oprev, eUp );
  }
  return TRUE;
}

static int CheckForLeftSplice( GLUtesselator *tess, ActiveRegion *regUp )
/*
 * Check the upper and lower edge of "regUp", to make sure that the
 * eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
 * destination is rightmost).
 *
 * Theoretically, this should always be true.  However, splitting an edge
 * into two pieces can change the results of previous tests.  For example,
 * suppose at one point we checked eUp and eLo, and decided that eUp->Dst
 * is barely above eLo.  Then later, we split eLo into two edges (eg. from
 * a splice operation like this one).  This can change the result of
 * the test so that now eUp->Dst is incident to eLo, or barely below it.
 * We must correct this condition to maintain the dictionary invariants
 * (otherwise new edges might get inserted in the wrong place in the
 * dictionary, and bad stuff will happen).
 *
 * We fix the problem by just splicing the offending vertex into the
 * other edge.
 */
{
  ActiveRegion *regLo = RegionBelow(regUp);
  GLUhalfEdge *eUp = regUp->eUp;
  GLUhalfEdge *eLo = regLo->eUp;
  GLUhalfEdge *e;

  assert( ! VertEq( eUp->Dst, eLo->Dst ));

  if( VertLeq( eUp->Dst, eLo->Dst )) {
    if( EdgeSign( eUp->Dst, eLo->Dst, eUp->Org ) < 0 ) return FALSE;

    /* eLo->Dst is above eUp, so splice eLo->Dst into eUp */
    RegionAbove(regUp)->dirty = regUp->dirty = TRUE;
    e = __gl_meshSplitEdge( eUp );
    __gl_meshSplice( eLo->Sym, e );
    e->Lface->inside = regUp->inside;
  } else {
    if( EdgeSign( eLo->Dst, eUp->Dst, eLo->Org ) > 0 ) return FALSE;

    /* eUp->Dst is below eLo, so splice eUp->Dst into eLo */
    regUp->dirty = regLo->dirty = TRUE;
    e = __gl_meshSplitEdge( eLo );
    __gl_meshSplice( eUp->Lnext, eLo->Sym );
    e->Rface->inside = regUp->inside;
  }
  return TRUE;
}


static int CheckForIntersect( GLUtesselator *tess, ActiveRegion *regUp )
/*
 * Check the upper and lower edges of the given region to see if
 * they intersect.  If so, create the intersection and add it
 * to the data structures.
 *
 * Returns TRUE if adding the new intersection resulted in a recursive
 * call to AddRightEdges(); in this case all "dirty" regions have been
 * checked for intersections, and possibly regUp has been deleted.
 */
{
  ActiveRegion *regLo = RegionBelow(regUp);
  GLUhalfEdge *eUp = regUp->eUp;
  GLUhalfEdge *eLo = regLo->eUp;
  GLUvertex *orgUp = eUp->Org;
  GLUvertex *orgLo = eLo->Org;
  GLUvertex *dstUp = eUp->Dst;
  GLUvertex *dstLo = eLo->Dst;
  GLdouble tMinUp, tMaxLo;
  GLUvertex isect, *orgMin;
  GLUhalfEdge *e;

  assert( ! VertEq( dstLo, dstUp ));
  assert( EdgeSign( dstUp, tess->event, orgUp ) <= 0 );
  assert( EdgeSign( dstLo, tess->event, orgLo ) >= 0 );
  assert( orgUp != tess->event && orgLo != tess->event );
  assert( ! regUp->fixUpperEdge && ! regLo->fixUpperEdge );

  if( orgUp == orgLo ) return FALSE;	/* right endpoints are the same */

  tMinUp = MIN( orgUp->t, dstUp->t );
  tMaxLo = MAX( orgLo->t, dstLo->t );
  if( tMinUp > tMaxLo ) return FALSE;	/* t ranges do not overlap */

  if( VertLeq( orgUp, orgLo )) {
    if( EdgeSign( dstLo, orgUp, orgLo ) > 0 ) return FALSE;
  } else {
    if( EdgeSign( dstUp, orgLo, orgUp ) < 0 ) return FALSE;
  }

  /* At this point the edges intersect, at least marginally */
  DebugEvent( tess );

  __gl_edgeIntersect( dstUp, orgUp, dstLo, orgLo, &isect );
  /* The following properties are guaranteed: */
  assert( MIN( orgUp->t, dstUp->t ) <= isect.t );
  assert( isect.t <= MAX( orgLo->t, dstLo->t ));
  assert( MIN( dstLo->s, dstUp->s ) <= isect.s );
  assert( isect.s <= MAX( orgLo->s, orgUp->s ));

  if( VertLeq( &isect, tess->event )) {
    /* The intersection point lies slightly to the left of the sweep line,
     * so move it until it''s slightly to the right of the sweep line.
     * (If we had perfect numerical precision, this would never happen
     * in the first place).  The easiest and safest thing to do is
     * replace the intersection by tess->event.
     */
    isect.s = tess->event->s;
    isect.t = tess->event->t;
  }
  /* Similarly, if the computed intersection lies to the right of the
   * rightmost origin (which should rarely happen), it can cause
   * unbelievable inefficiency on sufficiently degenerate inputs.
   * (If you have the test program, try running test54.d with the
   * "X zoom" option turned on).
   */
  orgMin = VertLeq( orgUp, orgLo ) ? orgUp : orgLo;
  if( VertLeq( orgMin, &isect )) {
    isect.s = orgMin->s;
    isect.t = orgMin->t;
  }

  if( VertEq( &isect, orgUp ) || VertEq( &isect, orgLo )) {
    /* Easy case -- intersection at one of the right endpoints */
    (void) CheckForRightSplice( tess, regUp );
    return FALSE;
  }

  if(    (! VertEq( dstUp, tess->event )
	  && EdgeSign( dstUp, tess->event, &isect ) >= 0)
      || (! VertEq( dstLo, tess->event )
	  && EdgeSign( dstLo, tess->event, &isect ) <= 0 ))
  {
    /* Very unusual -- the new upper or lower edge would pass on the
     * wrong side of the sweep event, or through it.  This can happen
     * due to very small numerical errors in the intersection calculation.
     */
    if( dstLo == tess->event ) {
      /* Splice dstLo into eUp, and process the new region(s) */
      __gl_meshSplitEdge( eUp->Sym );
      __gl_meshSplice( eLo->Sym, eUp );
      regUp = TopLeftRegion( regUp );
      eUp = RegionBelow(regUp)->eUp;
      FinishLeftRegions( tess, RegionBelow(regUp), regLo );
      AddRightEdges( tess, regUp, eUp->Oprev, eUp, eUp, TRUE );
      return TRUE;
    }
    if( dstUp == tess->event ) {
      /* Splice dstUp into eLo, and process the new region(s) */
      __gl_meshSplitEdge( eLo->Sym );
      __gl_meshSplice( eUp->Lnext, eLo->Oprev );
      regLo = regUp;
      regUp = TopRightRegion( regUp );
      e = RegionBelow(regUp)->eUp->Rprev;
      regLo->eUp = eLo->Oprev;
      eLo = FinishLeftRegions( tess, regLo, NULL );
      AddRightEdges( tess, regUp, eLo->Onext, eUp->Rprev, e, TRUE );
      return TRUE;
    }
    /* Special case: called from ConnectRightVertex.  If either
     * edge passes on the wrong side of tess->event, split it
     * (and wait for ConnectRightVertex to splice it appropriately).
     */
    if( EdgeSign( dstUp, tess->event, &isect ) >= 0 ) {
      RegionAbove(regUp)->dirty = regUp->dirty = TRUE;
      __gl_meshSplitEdge( eUp->Sym );
      eUp->Org->s = tess->event->s;
      eUp->Org->t = tess->event->t;
    }
    if( EdgeSign( dstLo, tess->event, &isect ) <= 0 ) {
      regUp->dirty = regLo->dirty = TRUE;
      __gl_meshSplitEdge( eLo->Sym );
      eLo->Org->s = tess->event->s;
      eLo->Org->t = tess->event->t;
    }
    /* leave the rest for ConnectRightVertex */
    return FALSE;
  }

  /* General case -- split both edges, splice into new vertex.
   * When we do the splice operation, the order of the arguments is
   * arbitrary as far as correctness goes.  However, when the operation
   * creates a new face, the work done is proportional to the size of
   * the new face.  We expect the faces in the processed part of
   * the mesh (ie. eUp->Lface) to be smaller than the faces in the
   * unprocessed original contours (which will be eLo->Oprev->Lface).
   */
  __gl_meshSplitEdge( eUp->Sym );
  __gl_meshSplitEdge( eLo->Sym );
  __gl_meshSplice( eLo->Oprev, eUp );
  eUp->Org->s = isect.s;
  eUp->Org->t = isect.t;
  eUp->Org->pqHandle = pqInsert( tess->pq, eUp->Org );
  GetIntersectData( tess, eUp->Org, orgUp, dstUp, orgLo, dstLo );
  RegionAbove(regUp)->dirty = regUp->dirty = regLo->dirty = TRUE;
  return FALSE;
}

static void WalkDirtyRegions( GLUtesselator *tess, ActiveRegion *regUp )
/*
 * When the upper or lower edge of any region changes, the region is
 * marked "dirty".  This routine walks through all the dirty regions
 * and makes sure that the dictionary invariants are satisfied
 * (see the comments at the beginning of this file).  Of course
 * new dirty regions can be created as we make changes to restore
 * the invariants.
 */
{
  ActiveRegion *regLo = RegionBelow(regUp);
  GLUhalfEdge *eUp, *eLo;

  for( ;; ) {
    /* Find the lowest dirty region (we walk from the bottom up). */
    while( regLo->dirty ) {
      regUp = regLo;
      regLo = RegionBelow(regLo);
    }
    if( ! regUp->dirty ) {
      regLo = regUp;
      regUp = RegionAbove( regUp );
      if( regUp == NULL || ! regUp->dirty ) {
	/* We've walked all the dirty regions */
	return;
      }
    }
    regUp->dirty = FALSE;
    eUp = regUp->eUp;
    eLo = regLo->eUp;

    if( eUp->Dst != eLo->Dst ) {
      /* Check that the edge ordering is obeyed at the Dst vertices. */
      if( CheckForLeftSplice( tess, regUp )) {

	/* If the upper or lower edge was marked fixUpperEdge, then
	 * we no longer need it (since these edges are needed only for
	 * vertices which otherwise have no right-going edges).
	 */
	if( regLo->fixUpperEdge ) {
	  DeleteRegion( tess, regLo );
	  __gl_meshDelete( eLo );
	  regLo = RegionBelow( regUp );
	  eLo = regLo->eUp;
	} else if( regUp->fixUpperEdge ) {
	  DeleteRegion( tess, regUp );
	  __gl_meshDelete( eUp );
	  regUp = RegionAbove( regLo );
	  eUp = regUp->eUp;
	}
      }
    }
    if( eUp->Org != eLo->Org ) {
      if(    eUp->Dst != eLo->Dst
	  && ! regUp->fixUpperEdge && ! regLo->fixUpperEdge
          && (eUp->Dst == tess->event || eLo->Dst == tess->event) )
      {
	/* When all else fails in CheckForIntersect(), it uses tess->event
	 * as the intersection location.  To make this possible, it requires
	 * that tess->event lie between the upper and lower edges, and also
	 * that neither of these is marked fixUpperEdge (since in the worst
	 * case it might splice one of these edges into tess->event, and
	 * violate the invariant that fixable edges are the only right-going
	 * edge from their associated vertex).
         */
	if( CheckForIntersect( tess, regUp )) {
	  /* WalkDirtyRegions() was called recursively; we're done */
	  return;
	}
      } else {
	/* Even though we can't use CheckForIntersect(), the Org vertices
	 * may violate the dictionary edge ordering.  Check and correct this.
	 */
	(void) CheckForRightSplice( tess, regUp );
      }
    }
    if( eUp->Org == eLo->Org && eUp->Dst == eLo->Dst ) {
      /* A degenerate loop consisting of only two edges -- delete it. */
      AddWinding( eLo, eUp );
      DeleteRegion( tess, regUp );
      __gl_meshDelete( eUp );
      regUp = RegionAbove( regLo );
    }
  }
}


static void ConnectRightVertex( GLUtesselator *tess, ActiveRegion *regUp,
			        GLUhalfEdge *eBottomLeft )
/*
 * Purpose: connect a "right" vertex vEvent (one where all edges go left)
 * to the unprocessed portion of the mesh.  Since there are no right-going
 * edges, two regions (one above vEvent and one below) are being merged
 * into one.  "regUp" is the upper of these two regions.
 *
 * There are two reasons for doing this (adding a right-going edge):
 *  - if the two regions being merged are "inside", we must add an edge
 *    to keep them separated (the combined region would not be monotone).
 *  - in any case, we must leave some record of vEvent in the dictionary,
 *    so that we can merge vEvent with features that we have not seen yet.
 *    For example, maybe there is a vertical edge which passes just to
 *    the right of vEvent; we would like to splice vEvent into this edge.
 *
 * However, we don't want to connect vEvent to just any vertex.  We don''t
 * want the new edge to cross any other edges; otherwise we will create
 * intersection vertices even when the input data had no self-intersections.
 * (This is a bad thing; if the user's input data has no intersections,
 * we don't want to generate any false intersections ourselves.)
 *
 * Our eventual goal is to connect vEvent to the leftmost unprocessed
 * vertex of the combined region (the union of regUp and regLo).
 * But because of unseen vertices with all right-going edges, and also
 * new vertices which may be created by edge intersections, we don''t
 * know where that leftmost unprocessed vertex is.  In the meantime, we
 * connect vEvent to the closest vertex of either chain, and mark the region
 * as "fixUpperEdge".  This flag says to delete and reconnect this edge
 * to the next processed vertex on the boundary of the combined region.
 * Quite possibly the vertex we connected to will turn out to be the
 * closest one, in which case we won''t need to make any changes.
 */
{
  GLUhalfEdge *eNew;
  GLUhalfEdge *eTopLeft = eBottomLeft->Onext;
  ActiveRegion *regLo = RegionBelow(regUp);
  GLUhalfEdge *eUp = regUp->eUp;
  GLUhalfEdge *eLo = regLo->eUp;
  int degenerate = FALSE;

  if( eUp->Dst != eLo->Dst ) {
    (void) CheckForIntersect( tess, regUp );
  }

  /* Possible new degeneracies: upper or lower edge of regUp may pass
   * through vEvent, or may coincide with new intersection vertex
   */
  if( VertEq( eUp->Org, tess->event )) {
    __gl_meshSplice( eTopLeft->Oprev, eUp );
    regUp = TopLeftRegion( regUp );
    eTopLeft = RegionBelow( regUp )->eUp;
    FinishLeftRegions( tess, RegionBelow(regUp), regLo );
    degenerate = TRUE;
  }
  if( VertEq( eLo->Org, tess->event )) {
    __gl_meshSplice( eBottomLeft, eLo->Oprev );
    eBottomLeft = FinishLeftRegions( tess, regLo, NULL );
    degenerate = TRUE;
  }
  if( degenerate ) {
    AddRightEdges( tess, regUp, eBottomLeft->Onext, eTopLeft, eTopLeft, TRUE );
    return;
  }

  /* Non-degenerate situation -- need to add a temporary, fixable edge.
   * Connect to the closer of eLo->Org, eUp->Org.
   */
  if( VertLeq( eLo->Org, eUp->Org )) {
    eNew = eLo->Oprev;
  } else {
    eNew = eUp;
  }
  eNew = __gl_meshConnect( eBottomLeft->Lprev, eNew );

  /* Prevent cleanup, otherwise eNew might disappear before we've even
   * had a chance to mark it as a temporary edge.
   */
  AddRightEdges( tess, regUp, eNew, eNew->Onext, eNew->Onext, FALSE );
  eNew->Sym->activeRegion->fixUpperEdge = TRUE;
  WalkDirtyRegions( tess, regUp );
}

/* Because vertices at exactly the same location are merged together
 * before we process the sweep event, some degenerate cases can't occur.
 * However if someone eventually makes the modifications required to
 * merge features which are close together, the cases below marked
 * TOLERANCE_NONZERO will be useful.  They were debugged before the
 * code to merge identical vertices in the main loop was added.
 */
#define TOLERANCE_NONZERO	FALSE

static void ConnectLeftDegenerate( GLUtesselator *tess,
				   ActiveRegion *regUp, GLUvertex *vEvent )
/*
 * The event vertex lies exacty on an already-processed edge or vertex.
 * Adding the new vertex involves splicing it into the already-processed
 * part of the mesh.
 */
{
  GLUhalfEdge *e, *eTopLeft, *eTopRight, *eLast;
  ActiveRegion *reg;

  e = regUp->eUp;
  if( VertEq( e->Org, vEvent )) {
    /* e->Org is an unprocessed vertex - just combine them, and wait
     * for e->Org to be pulled from the queue
     */
    assert( TOLERANCE_NONZERO );
    SpliceMergeVertices( tess, e, vEvent->anEdge );
    return;
  }
  
  if( ! VertEq( e->Dst, vEvent )) {
    /* General case -- splice vEvent into edge e which passes through it */
    __gl_meshSplitEdge( e->Sym );
    if( regUp->fixUpperEdge ) {
      /* This edge was fixable -- delete unused portion of original edge */
      __gl_meshDelete( e->Onext );
      regUp->fixUpperEdge = FALSE;
    }
    __gl_meshSplice( vEvent->anEdge, e );
    SweepEvent( tess, vEvent );	/* recurse */
    return;
  }

  /* vEvent coincides with e->Dst, which has already been processed.
   * Splice in the additional right-going edges.
   */
  assert( TOLERANCE_NONZERO );
  regUp = TopRightRegion( regUp );
  reg = RegionBelow( regUp );
  eTopRight = reg->eUp->Sym;
  eTopLeft = eLast = eTopRight->Onext;
  if( reg->fixUpperEdge ) {
    /* Here e->Dst has only a single fixable edge going right.
     * We can delete it since now we have some real right-going edges.
     */
    assert( eTopLeft != eTopRight );   /* there are some left edges too */
    DeleteRegion( tess, reg );
    __gl_meshDelete( eTopRight );
    eTopRight = eTopLeft->Oprev;
  }
  __gl_meshSplice( vEvent->anEdge, eTopRight );
  if( ! EdgeGoesLeft( eTopLeft )) {
    /* e->Dst had no left-going edges -- indicate this to AddRightEdges() */
    eTopLeft = NULL;
  }
  AddRightEdges( tess, regUp, eTopRight->Onext, eLast, eTopLeft, TRUE );
}


static void ConnectLeftVertex( GLUtesselator *tess, GLUvertex *vEvent )
/*
 * Purpose: connect a "left" vertex (one where both edges go right)
 * to the processed portion of the mesh.  Let R be the active region
 * containing vEvent, and let U and L be the upper and lower edge
 * chains of R.  There are two possibilities:
 *
 * - the normal case: split R into two regions, by connecting vEvent to
 *   the rightmost vertex of U or L lying to the left of the sweep line
 *
 * - the degenerate case: if vEvent is close enough to U or L, we
 *   merge vEvent into that edge chain.  The subcases are:
 *	- merging with the rightmost vertex of U or L
 *	- merging with the active edge of U or L
 *	- merging with an already-processed portion of U or L
 */
{
  ActiveRegion *regUp, *regLo, *reg;
  GLUhalfEdge *eUp, *eLo, *eNew;
  ActiveRegion tmp;

  /* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */

  /* Get a pointer to the active region containing vEvent */
  tmp.eUp = vEvent->anEdge->Sym;
  regUp = (ActiveRegion *)dictKey( dictSearch( tess->dict, &tmp ));
  regLo = RegionBelow( regUp );
  eUp = regUp->eUp;
  eLo = regLo->eUp;

  /* Try merging with U or L first */
  if( EdgeSign( eUp->Dst, vEvent, eUp->Org ) == 0 ) {
    ConnectLeftDegenerate( tess, regUp, vEvent );
    return;
  }

  /* Connect vEvent to rightmost processed vertex of either chain.
   * e->Dst is the vertex that we will connect to vEvent.
   */
  reg = VertLeq( eLo->Dst, eUp->Dst ) ? regUp : regLo;

  if( regUp->inside || reg->fixUpperEdge) {
    if( reg == regUp ) {
      eNew = __gl_meshConnect( vEvent->anEdge->Sym, eUp->Lnext );
    } else {
      eNew = __gl_meshConnect( eLo->Dnext, vEvent->anEdge )->Sym;
    }
    if( reg->fixUpperEdge ) {
      FixUpperEdge( reg, eNew );
    } else {
      ComputeWinding( tess, AddRegionBelow( tess, regUp, eNew ));
    }
    SweepEvent( tess, vEvent );
  } else {
    /* The new vertex is in a region which does not belong to the polygon.
     * We don''t need to connect this vertex to the rest of the mesh.
     */
    AddRightEdges( tess, regUp, vEvent->anEdge, vEvent->anEdge, NULL, TRUE );
  }
}


static void SweepEvent( GLUtesselator *tess, GLUvertex *vEvent )
/*
 * Does everything necessary when the sweep line crosses a vertex.
 * Updates the mesh and the edge dictionary.
 */
{
  ActiveRegion *regUp, *reg;
  GLUhalfEdge *e, *eTopLeft, *eBottomLeft;

  tess->event = vEvent;		/* for access in EdgeLeq() */
  DebugEvent( tess );
  
  /* Check if this vertex is the right endpoint of an edge that is
   * already in the dictionary.  In this case we don't need to waste
   * time searching for the location to insert new edges.
   */
  e = vEvent->anEdge;
  while( e->activeRegion == NULL ) {
    e = e->Onext;
    if( e == vEvent->anEdge ) {
      /* All edges go right -- not incident to any processed edges */
      ConnectLeftVertex( tess, vEvent );
      return;
    }
  }

  /* Processing consists of two phases: first we "finish" all the
   * active regions where both the upper and lower edges terminate
   * at vEvent (ie. vEvent is closing off these regions).
   * We mark these faces "inside" or "outside" the polygon according
   * to their winding number, and delete the edges from the dictionary.
   * This takes care of all the left-going edges from vEvent.
   */
  regUp = TopLeftRegion( e->activeRegion );
  reg = RegionBelow( regUp );
  eTopLeft = reg->eUp;
  eBottomLeft = FinishLeftRegions( tess, reg, NULL );

  /* Next we process all the right-going edges from vEvent.  This
   * involves adding the edges to the dictionary, and creating the
   * associated "active regions" which record information about the
   * regions between adjacent dictionary edges.
   */
  if( eBottomLeft->Onext == eTopLeft ) {
    /* No right-going edges -- add a temporary "fixable" edge */
    ConnectRightVertex( tess, regUp, eBottomLeft );
  } else {
    AddRightEdges( tess, regUp, eBottomLeft->Onext, eTopLeft, eTopLeft, TRUE );
  }
}


/* Make the sentinel coordinates big enough that they will never be
 * merged with real input features.  (Even with the largest possible
 * input contour and the maximum tolerance of 1.0, no merging will be
 * done with coordinates larger than 3 * GLU_TESS_MAX_COORD).
 */
#define SENTINEL_COORD	(4 * GLU_TESS_MAX_COORD)

static void AddSentinel( GLUtesselator *tess, GLdouble t )
/*
 * We add two sentinel edges above and below all other edges,
 * to avoid special cases at the top and bottom.
 */
{
  ActiveRegion *reg = (ActiveRegion *)memAlloc( sizeof( ActiveRegion ));
  GLUhalfEdge *e = __gl_meshMakeEdge( tess->mesh );

  e->Org->s = SENTINEL_COORD;
  e->Org->t = t;
  e->Dst->s = -SENTINEL_COORD;
  e->Dst->t = t;
  tess->event = e->Dst;		/* initialize it */

  reg->eUp = e;
  reg->windingNumber = 0;
  reg->inside = FALSE;
  reg->fixUpperEdge = FALSE;
  reg->sentinel = TRUE;
  reg->dirty = FALSE;
  reg->nodeUp = dictInsert( tess->dict, reg );
}


static void InitEdgeDict( GLUtesselator *tess )
/*
 * We maintain an ordering of edge intersections with the sweep line.
 * This order is maintained in a dynamic dictionary.
 */
{
  tess->dict = dictNewDict( tess, (int (*)(void *, DictKey, DictKey)) EdgeLeq );
  AddSentinel( tess, -SENTINEL_COORD );
  AddSentinel( tess, SENTINEL_COORD );
}


static void DoneEdgeDict( GLUtesselator *tess )
{
  ActiveRegion *reg;
  int fixedEdges = 0;

  while( (reg = (ActiveRegion *)dictKey( dictMin( tess->dict ))) != NULL ) {
    /*
     * At the end of all processing, the dictionary should contain
     * only the two sentinel edges, plus at most one "fixable" edge
     * created by ConnectRightVertex().
     */
    if( ! reg->sentinel ) {
      assert( reg->fixUpperEdge );
      assert( ++fixedEdges == 1 );
    }
    assert( reg->windingNumber == 0 );
    DeleteRegion( tess, reg );
/*    __gl_meshDelete( reg->eUp );*/
  }
  dictDeleteDict( tess->dict );
}


static void RemoveDegenerateEdges( GLUtesselator *tess )
/*
 * Remove zero-length edges, and contours with fewer than 3 vertices.
 */
{
  GLUhalfEdge *e, *eNext, *eLnext;
  GLUhalfEdge *eHead = &tess->mesh->eHead;

  /*LINTED*/
  for( e = eHead->next; e != eHead; e = eNext ) {
    eNext = e->next;
    eLnext = e->Lnext;
    
    if( VertEq( e->Org, e->Dst ) && e->Lnext->Lnext != e ) {
      /* Zero-length edge, contour has at least 3 edges */
      
      SpliceMergeVertices( tess, eLnext, e );	/* deletes e->Org */
      __gl_meshDelete( e );			/* e is a self-loop */
      e = eLnext;
      eLnext = e->Lnext;
    }
    if( eLnext->Lnext == e ) {
      /* Degenerate contour (one or two edges) */
      
      if( eLnext != e ) {
	if( eLnext == eNext || eLnext == eNext->Sym ) { eNext = eNext->next; }
	__gl_meshDelete( eLnext );
      }
      if( e == eNext || e == eNext->Sym ) { eNext = eNext->next; }
      __gl_meshDelete( e );
    }
  }
}

static void InitPriorityQ( GLUtesselator *tess )
/*
 * Insert all vertices into the priority queue which determines the
 * order in which vertices cross the sweep line.
 */
{
  PriorityQ *pq;
  GLUvertex *v, *vHead;

  pq = tess->pq = pqNewPriorityQ( (int (*)(PQkey, PQkey)) __gl_vertLeq );

  vHead = &tess->mesh->vHead;
  for( v = vHead->next; v != vHead; v = v->next ) {
    v->pqHandle = pqInsert( pq, v );
  }
  pqInit( pq );
}


static void DonePriorityQ( GLUtesselator *tess )
{
  pqDeletePriorityQ( tess->pq );
}


static void RemoveDegenerateFaces( GLUmesh *mesh )
/*
 * Delete any degenerate faces with only two edges.  WalkDirtyRegions()
 * will catch almost all of these, but it won't catch degenerate faces
 * produced by splice operations on already-processed edges.
 * The two places this can happen are in FinishLeftRegions(), when
 * we splice in a "temporary" edge produced by ConnectRightVertex(),
 * and in CheckForLeftSplice(), where we splice already-processed
 * edges to ensure that our dictionary invariants are not violated
 * by numerical errors.
 *
 * In both these cases it is *very* dangerous to delete the offending
 * edge at the time, since one of the routines further up the stack
 * will sometimes be keeping a pointer to that edge.
 */
{
  GLUface *f, *fNext;
  GLUhalfEdge *e;

  /*LINTED*/
  for( f = mesh->fHead.next; f != &mesh->fHead; f = fNext ) {
    fNext = f->next;
    e = f->anEdge;
    assert( e->Lnext != e );

    if( e->Lnext->Lnext == e ) {
      /* A face with only two edges */
      AddWinding( e->Onext, e );
      __gl_meshDelete( e );
    }
  }
}

void __gl_computeInterior( GLUtesselator *tess )
/*
 * __gl_computeInterior( tess ) computes the planar arrangement specified
 * by the given contours, and further subdivides this arrangement
 * into regions.  Each region is marked "inside" if it belongs
 * to the polygon, according to the rule given by tess->windingRule.
 * Each interior region is guaranteed be monotone.
 */
{
  GLUvertex *v, *vNext;

  tess->fatalError = FALSE;

  /* Each vertex defines an event for our sweep line.  Start by inserting
   * all the vertices in a priority queue.  Events are processed in
   * lexicographic order, ie.
   *
   *	e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
   */
  RemoveDegenerateEdges( tess );
  InitPriorityQ( tess );
  InitEdgeDict( tess );

  while( (v = (GLUvertex *)pqExtractMin( tess->pq )) != NULL ) {
    for( ;; ) {
      vNext = (GLUvertex *)pqMinimum( tess->pq );
      if( vNext == NULL || ! VertEq( vNext, v )) break;
      
      /* Merge together all vertices at exactly the same location.
       * This is more efficient than processing them one at a time,
       * simplifies the code (see ConnectLeftDegenerate), and is also
       * important for correct handling of certain degenerate cases.
       * For example, suppose there are two identical edges A and B
       * that belong to different contours (so without this code they would
       * be processed by separate sweep events).  Suppose another edge C
       * crosses A and B from above.  When A is processed, we split it
       * at its intersection point with C.  However this also splits C,
       * so when we insert B we may compute a slightly different
       * intersection point.  This might leave two edges with a small
       * gap between them.  This kind of error is especially obvious
       * when using boundary extraction (GLU_TESS_BOUNDARY_ONLY).
       */
      vNext = (GLUvertex *)pqExtractMin( tess->pq );
      SpliceMergeVertices( tess, v->anEdge, vNext->anEdge );
    }
    SweepEvent( tess, v );
  }

  /* Set tess->event for debugging purposes */
  tess->event = ((ActiveRegion *) dictKey( dictMin( tess->dict )))->eUp->Org;
  DebugEvent( tess );
  DoneEdgeDict( tess );
  DonePriorityQ( tess );

  RemoveDegenerateFaces( tess->mesh );
  __gl_meshCheckMesh( tess->mesh );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libutil\memory.c ===
#ifdef NT
#include <glos.h>
#endif
#include "gluint.h"
#include <GL/glu.h>

#ifndef NT
#include <stdio.h>
#include <stdlib.h>
#else
#include "glstring.h"
#endif

DWORD gluMemoryAllocationFailed = 0;

HLOCAL gluAlloc (UINT size)
{
    HLOCAL tmp;
    
    tmp = LocalAlloc(LMEM_FIXED, size);
    if (tmp == NULL) gluMemoryAllocationFailed++;
    return tmp;
}


HLOCAL gluCalloc (UINT nobj, UINT size)
{
    HLOCAL tmp;
    
    tmp = LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, nobj*size);
    if (tmp == NULL) gluMemoryAllocationFailed++;
    return tmp;
}


HLOCAL gluReAlloc (HLOCAL p, UINT size)
{
    HLOCAL tmp;
    
    tmp = LocalReAlloc(p, size, LMEM_MOVEABLE);
    if (tmp == NULL) gluMemoryAllocationFailed++;
    return tmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libutil\quad.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.5 $
** $Date: 1996/04/02 00:42:17 $
*/

#ifdef NT
#include <glos.h>
#endif
#include "gluint.h"
#include <stdio.h>

#ifndef NT
#include <stdlib.h>
#else
#include "winmem.h"
#endif

#include <math.h>
#include <GL/gl.h>
#include <GL/glu.h>

/* Make it not a power of two to avoid cache thrashing on the chip */
#define CACHE_SIZE	240

#define PI            3.14159265358979323846

struct GLUquadric {
    GLint 	normals;
    GLboolean	textureCoords;
    GLint	orientation;
    GLint	drawStyle;
#ifdef NT
    GLUquadricErrorProc errorCallback;
#else
    void	(*errorCallback)( GLint );
#endif
};

GLUquadric * APIENTRY gluNewQuadric(void)
{
    GLUquadric *newstate;

    newstate = (GLUquadric *) malloc(sizeof(GLUquadric));
    if (newstate == NULL) {
	/* Can't report an error at this point... */
	return NULL;
    }
    newstate->normals = GLU_SMOOTH;
    newstate->textureCoords = GL_FALSE;
    newstate->orientation = GLU_OUTSIDE;
    newstate->drawStyle = GLU_FILL;
#ifdef NT
    newstate->errorCallback = (GLUquadricErrorProc)NULL;
#endif
    return newstate;
}


void APIENTRY gluDeleteQuadric(GLUquadric *state)
{
    free(state);
}

static void gluQuadricError(GLUquadric *qobj, GLenum which)
{
    if (qobj->errorCallback) {
	qobj->errorCallback(which);
    }
}

void APIENTRY gluQuadricCallback(GLUquadric *qobj, GLenum which, void (CALLBACK *fn)())
{
    switch (which) {
      case GLU_ERROR:
#ifdef NT
        qobj->errorCallback = (GLUquadricErrorProc) fn;
#else
	qobj->errorCallback = (void (*)(GLint)) fn;
#endif
	break;
      default:
	gluQuadricError(qobj, GLU_INVALID_ENUM);
	return;
    }
}

void APIENTRY gluQuadricNormals(GLUquadric *qobj, GLenum normals)
{
    switch (normals) {
      case GLU_SMOOTH:
      case GLU_FLAT:
      case GLU_NONE:
	break;
      default:
	gluQuadricError(qobj, GLU_INVALID_ENUM);
	return;
    }
    qobj->normals = normals;
}

void APIENTRY gluQuadricTexture(GLUquadric *qobj, GLboolean textureCoords)
{
    qobj->textureCoords = textureCoords;
}

void APIENTRY gluQuadricOrientation(GLUquadric *qobj, GLenum orientation)
{
    switch(orientation) {
      case GLU_OUTSIDE:
      case GLU_INSIDE:
	break;
      default:
	gluQuadricError(qobj, GLU_INVALID_ENUM);
	return;
    }
    qobj->orientation = orientation;
}

void APIENTRY gluQuadricDrawStyle(GLUquadric *qobj, GLenum drawStyle)
{
    switch(drawStyle) {
      case GLU_POINT:
      case GLU_LINE:
      case GLU_FILL:
      case GLU_SILHOUETTE:
	break;
      default:
	gluQuadricError(qobj, GLU_INVALID_ENUM);
	return;
    }
    qobj->drawStyle = drawStyle;
}

void APIENTRY gluCylinder(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, 
		GLdouble height, GLint slices, GLint stacks)
{
    GLint i,j,max;
    GLfloat sinCache[CACHE_SIZE];
    GLfloat cosCache[CACHE_SIZE];
    GLfloat sinCache2[CACHE_SIZE];
    GLfloat cosCache2[CACHE_SIZE];
    GLfloat sinCache3[CACHE_SIZE];
    GLfloat cosCache3[CACHE_SIZE];
    GLfloat angle;
    GLfloat x, y, zLow, zHigh;
    GLfloat sintemp, costemp;
    GLfloat length;
    GLfloat deltaRadius;
    GLfloat zNormal;
    GLfloat xyNormalRatio;
    GLfloat radiusLow, radiusHigh;
    int needCache2, needCache3;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;

    if (slices < 2 || stacks < 1 || baseRadius < 0.0 || topRadius < 0.0 ||
	    height < 0.0) {
	gluQuadricError(qobj, GLU_INVALID_VALUE);
	return;
    }

    /* Compute length (needed for normal calculations) */
    deltaRadius = baseRadius - topRadius;
    length = SQRT(deltaRadius*deltaRadius + height*height);
#ifdef NT
    if (length == (GLfloat)0.0) {
#else
    if (length == 0.0) {
#endif
	gluQuadricError(qobj, GLU_INVALID_VALUE);
	return;
    }

    /* Cache is the vertex locations cache */
    /* Cache2 is the various normals at the vertices themselves */
    /* Cache3 is the various normals for the faces */
    needCache2 = needCache3 = 0;
    if (qobj->normals == GLU_SMOOTH) {
	needCache2 = 1;
    }

    if (qobj->normals == GLU_FLAT) {
	if (qobj->drawStyle != GLU_POINT) {
	    needCache3 = 1;
	}
	if (qobj->drawStyle == GLU_LINE) {
	    needCache2 = 1;
	}
    }

    zNormal = deltaRadius / length;
    xyNormalRatio = height / length;

    for (i = 0; i < slices; i++) {
	angle = 2 * PI * i / slices;
	if (needCache2) {
	    if (qobj->orientation == GLU_OUTSIDE) {
		sinCache2[i] = xyNormalRatio * SIN(angle);
		cosCache2[i] = xyNormalRatio * COS(angle);
	    } else {
		sinCache2[i] = -xyNormalRatio * SIN(angle);
		cosCache2[i] = -xyNormalRatio * COS(angle);
	    }
	} 
	sinCache[i] = SIN(angle);
	cosCache[i] = COS(angle);
    }

    if (needCache3) {
	for (i = 0; i < slices; i++) {
	    angle = 2 * PI * (i-0.5) / slices;
	    if (qobj->orientation == GLU_OUTSIDE) {
		sinCache3[i] = xyNormalRatio * SIN(angle);
		cosCache3[i] = xyNormalRatio * COS(angle);
	    } else {
		sinCache3[i] = -xyNormalRatio * SIN(angle);
		cosCache3[i] = -xyNormalRatio * COS(angle);
	    }
	}
    } 

    sinCache[slices] = sinCache[0];
    cosCache[slices] = cosCache[0];
    if (needCache2) {
	sinCache2[slices] = sinCache2[0];
	cosCache2[slices] = cosCache2[0];
    }
    if (needCache3) {
	sinCache3[slices] = sinCache3[0];
	cosCache3[slices] = cosCache3[0];
    }

    switch (qobj->drawStyle) {
      case GLU_FILL:
	/* Note:
	** An argument could be made for using a TRIANGLE_FAN for the end
	** of the cylinder of either radii is 0.0 (a cone).  However, a 
	** TRIANGLE_FAN would not work in smooth shading mode (the common 
	** case) because the normal for the apex is different for every
	** triangle (and TRIANGLE_FAN doesn't let me respecify that normal).
	** Now, my choice is GL_TRIANGLES, or leave the GL_QUAD_STRIP and
	** just let the GL trivially reject one of the two triangles of the
	** QUAD.  GL_QUAD_STRIP is probably faster, so I will leave this code
	** alone.
	*/
	for (j = 0; j < stacks; j++) {
	    zLow = j * height / stacks;
	    zHigh = (j + 1) * height / stacks;
	    radiusLow = baseRadius - deltaRadius * ((float) j / stacks);
	    radiusHigh = baseRadius - deltaRadius * ((float) (j + 1) / stacks);

	    glBegin(GL_QUAD_STRIP);
	    for (i = 0; i <= slices; i++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		    glNormal3f(sinCache3[i], cosCache3[i], zNormal);
		    break;
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2[i], cosCache2[i], zNormal);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->orientation == GLU_OUTSIDE) {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				(float) j / stacks);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], zLow);
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				(float) (j+1) / stacks);
		    }
		    glVertex3f(radiusHigh * sinCache[i], 
			    radiusHigh * cosCache[i], zHigh);
		} else {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				(float) (j+1) / stacks);
		    }
		    glVertex3f(radiusHigh * sinCache[i], 
			    radiusHigh * cosCache[i], zHigh);
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				(float) j / stacks);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], zLow);
		}
	    }
	    glEnd();
	}
	break;
      case GLU_POINT:
	glBegin(GL_POINTS);
	for (i = 0; i < slices; i++) {
	    switch(qobj->normals) {
	      case GLU_FLAT:
	      case GLU_SMOOTH:
		glNormal3f(sinCache2[i], cosCache2[i], zNormal);
		break;
	      case GLU_NONE:
	      default:
		break;
	    }
	    sintemp = sinCache[i];
	    costemp = cosCache[i];
	    for (j = 0; j <= stacks; j++) {
		zLow = j * height / stacks;
		radiusLow = baseRadius - deltaRadius * ((float) j / stacks);

		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    (float) j / stacks);
		}
		glVertex3f(radiusLow * sintemp, 
			radiusLow * costemp, zLow);
	    }
	}
	glEnd();
	break;
      case GLU_LINE:
	for (j = 1; j < stacks; j++) {
	    zLow = j * height / stacks;
	    radiusLow = baseRadius - deltaRadius * ((float) j / stacks);

	    glBegin(GL_LINE_STRIP);
	    for (i = 0; i <= slices; i++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		    glNormal3f(sinCache3[i], cosCache3[i], zNormal);
		    break;
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2[i], cosCache2[i], zNormal);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    (float) j / stacks);
		}
		glVertex3f(radiusLow * sinCache[i], 
			radiusLow * cosCache[i], zLow);
	    }
	    glEnd();
	}
	/* Intentionally fall through here... */
      case GLU_SILHOUETTE:
	for (j = 0; j <= stacks; j += stacks) {
	    zLow = j * height / stacks;
	    radiusLow = baseRadius - deltaRadius * ((float) j / stacks);

	    glBegin(GL_LINE_STRIP);
	    for (i = 0; i <= slices; i++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		    glNormal3f(sinCache3[i], cosCache3[i], zNormal);
		    break;
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2[i], cosCache2[i], zNormal);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    (float) j / stacks);
		}
		glVertex3f(radiusLow * sinCache[i], radiusLow * cosCache[i], 
			zLow);
	    }
	    glEnd();
	}
	for (i = 0; i < slices; i++) {
	    switch(qobj->normals) {
	      case GLU_FLAT:
	      case GLU_SMOOTH:
		glNormal3f(sinCache2[i], cosCache2[i], 0.0);
		break;
	      case GLU_NONE:
	      default:
		break;
	    }
	    sintemp = sinCache[i];
	    costemp = cosCache[i];
	    glBegin(GL_LINE_STRIP);
	    for (j = 0; j <= stacks; j++) {
		zLow = j * height / stacks;
		radiusLow = baseRadius - deltaRadius * ((float) j / stacks);

		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    (float) j / stacks);
		}
		glVertex3f(radiusLow * sintemp, 
			radiusLow * costemp, zLow);
	    }
	    glEnd();
	}
	break;
      default:
	break;
    }
}

void APIENTRY gluDisk(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, 
	    GLint slices, GLint loops)
{
    gluPartialDisk(qobj, innerRadius, outerRadius, slices, loops, 0.0, 360.0);
}

void APIENTRY gluPartialDisk(GLUquadric *qobj, GLdouble innerRadius, 
		   GLdouble outerRadius, GLint slices, GLint loops,
		   GLdouble startAngle, GLdouble sweepAngle)
{
    GLint i,j,max;
    GLfloat sinCache[CACHE_SIZE];
    GLfloat cosCache[CACHE_SIZE];
    GLfloat angle;
    GLfloat x, y;
    GLfloat sintemp, costemp;
    GLfloat deltaRadius;
    GLfloat radiusLow, radiusHigh;
    GLfloat texLow, texHigh;
    GLfloat angleOffset;
    GLint slices2;
    GLint finish;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (slices < 2 || loops < 1 || outerRadius <= 0.0 || innerRadius < 0.0 ||
	    innerRadius > outerRadius) {
	gluQuadricError(qobj, GLU_INVALID_VALUE);
	return;
    }

    if (sweepAngle < -360.0) sweepAngle = 360.0;
    if (sweepAngle > 360.0) sweepAngle = 360.0;
    if (sweepAngle < 0) {
	startAngle += sweepAngle;
	sweepAngle = -sweepAngle;
    }

    if (sweepAngle == 360.0) {
	slices2 = slices;
    } else {
	slices2 = slices + 1;
    }

    /* Compute length (needed for normal calculations) */
    deltaRadius = outerRadius - innerRadius;

    /* Cache is the vertex locations cache */

    angleOffset = startAngle / 180.0 * PI;
    for (i = 0; i <= slices; i++) {
	angle = angleOffset + ((PI * sweepAngle) / 180.0) * i / slices;
	sinCache[i] = SIN(angle);
	cosCache[i] = COS(angle);
    }

    if (sweepAngle == 360.0) {
	sinCache[slices] = sinCache[0];
	cosCache[slices] = cosCache[0];
    }

    switch(qobj->normals) {
      case GLU_FLAT:
      case GLU_SMOOTH:
	if (qobj->orientation == GLU_OUTSIDE) {
	    glNormal3f(0.0, 0.0, 1.0);
	} else {
	    glNormal3f(0.0, 0.0, -1.0);
	}
	break;
      default:
      case GLU_NONE:
	break;
    }

    switch (qobj->drawStyle) {
      case GLU_FILL:
	if (innerRadius == 0.0) {
	    finish = loops - 1;
	    /* Triangle strip for inner polygons */
	    glBegin(GL_TRIANGLE_FAN);
	    if (qobj->textureCoords) {
		glTexCoord2f(0.5, 0.5);
	    }
	    glVertex3f(0.0, 0.0, 0.0);
	    radiusLow = outerRadius - 
		    deltaRadius * ((float) (loops-1) / loops);
	    if (qobj->textureCoords) {
		texLow = radiusLow / outerRadius / 2;
	    }

	    if (qobj->orientation == GLU_OUTSIDE) {
		for (i = slices; i >= 0; i--) {
		    if (qobj->textureCoords) {
			glTexCoord2f(texLow * sinCache[i] + 0.5,
				texLow * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], 0.0);
		}
	    } else {
		for (i = 0; i <= slices; i++) {
		    if (qobj->textureCoords) {
			glTexCoord2f(texLow * sinCache[i] + 0.5,
				texLow * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], 0.0);
		}
	    }
	    glEnd();
	} else {
	    finish = loops;
	}
	for (j = 0; j < finish; j++) {
	    radiusLow = outerRadius - deltaRadius * ((float) j / loops);
	    radiusHigh = outerRadius - deltaRadius * ((float) (j + 1) / loops);
	    if (qobj->textureCoords) {
		texLow = radiusLow / outerRadius / 2;
		texHigh = radiusHigh / outerRadius / 2;
	    }

	    glBegin(GL_QUAD_STRIP);
	    for (i = 0; i <= slices; i++) {
		if (qobj->orientation == GLU_OUTSIDE) {
		    if (qobj->textureCoords) {
			glTexCoord2f(texLow * sinCache[i] + 0.5,
				texLow * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], 0.0);

		    if (qobj->textureCoords) {
			glTexCoord2f(texHigh * sinCache[i] + 0.5,
				texHigh * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusHigh * sinCache[i], 
			    radiusHigh * cosCache[i], 0.0);
		} else {
		    if (qobj->textureCoords) {
			glTexCoord2f(texHigh * sinCache[i] + 0.5,
				texHigh * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusHigh * sinCache[i], 
			    radiusHigh * cosCache[i], 0.0);

		    if (qobj->textureCoords) {
			glTexCoord2f(texLow * sinCache[i] + 0.5,
				texLow * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusLow * sinCache[i], 
			    radiusLow * cosCache[i], 0.0);
		}
	    }
	    glEnd();
	}
	break;
      case GLU_POINT:
	glBegin(GL_POINTS);
	for (i = 0; i < slices2; i++) {
	    sintemp = sinCache[i];
	    costemp = cosCache[i];
	    for (j = 0; j <= loops; j++) {
		radiusLow = outerRadius - deltaRadius * ((float) j / loops);

		if (qobj->textureCoords) {
		    texLow = radiusLow / outerRadius / 2;

		    glTexCoord2f(texLow * sinCache[i] + 0.5,
			    texLow * cosCache[i] + 0.5);
		}
		glVertex3f(radiusLow * sintemp, radiusLow * costemp, 0.0);
	    }
	}
	glEnd();
	break;
      case GLU_LINE:
	if (innerRadius == outerRadius) {
	    glBegin(GL_LINE_STRIP);

	    for (i = 0; i <= slices; i++) {
		if (qobj->textureCoords) {
		    glTexCoord2f(sinCache[i] / 2 + 0.5,
			    cosCache[i] / 2 + 0.5);
		}
		glVertex3f(innerRadius * sinCache[i],
			innerRadius * cosCache[i], 0.0);
	    }
	    glEnd();
	    break;
	}
	for (j = 0; j <= loops; j++) {
	    radiusLow = outerRadius - deltaRadius * ((float) j / loops);
	    if (qobj->textureCoords) {
		texLow = radiusLow / outerRadius / 2;
	    }

	    glBegin(GL_LINE_STRIP);
	    for (i = 0; i <= slices; i++) {
		if (qobj->textureCoords) {
		    glTexCoord2f(texLow * sinCache[i] + 0.5,
			    texLow * cosCache[i] + 0.5);
		}
		glVertex3f(radiusLow * sinCache[i], 
			radiusLow * cosCache[i], 0.0);
	    }
	    glEnd();
	}
	for (i=0; i < slices2; i++) {
	    sintemp = sinCache[i];
	    costemp = cosCache[i];
	    glBegin(GL_LINE_STRIP);
	    for (j = 0; j <= loops; j++) {
		radiusLow = outerRadius - deltaRadius * ((float) j / loops);
		if (qobj->textureCoords) {
		    texLow = radiusLow / outerRadius / 2;
		}

		if (qobj->textureCoords) {
		    glTexCoord2f(texLow * sinCache[i] + 0.5,
			    texLow * cosCache[i] + 0.5);
		}
		glVertex3f(radiusLow * sintemp, radiusLow * costemp, 0.0);
	    }
	    glEnd();
	}
	break;
      case GLU_SILHOUETTE:
	if (sweepAngle < 360.0) {
	    for (i = 0; i <= slices; i+= slices) {
		sintemp = sinCache[i];
		costemp = cosCache[i];
		glBegin(GL_LINE_STRIP);
		for (j = 0; j <= loops; j++) {
		    radiusLow = outerRadius - deltaRadius * ((float) j / loops);

		    if (qobj->textureCoords) {
			texLow = radiusLow / outerRadius / 2;
			glTexCoord2f(texLow * sinCache[i] + 0.5,
				texLow * cosCache[i] + 0.5);
		    }
		    glVertex3f(radiusLow * sintemp, radiusLow * costemp, 0.0);
		}
		glEnd();
	    }
	}
	for (j = 0; j <= loops; j += loops) {
	    radiusLow = outerRadius - deltaRadius * ((float) j / loops);
	    if (qobj->textureCoords) {
		texLow = radiusLow / outerRadius / 2;
	    }

	    glBegin(GL_LINE_STRIP);
	    for (i = 0; i <= slices; i++) {
		if (qobj->textureCoords) {
		    glTexCoord2f(texLow * sinCache[i] + 0.5,
			    texLow * cosCache[i] + 0.5);
		}
		glVertex3f(radiusLow * sinCache[i], 
			radiusLow * cosCache[i], 0.0);
	    }
	    glEnd();
	    if (innerRadius == outerRadius) break;
	}
	break;
      default:
	break;
    }
}

void APIENTRY gluSphere(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks)
{
    GLint i,j,max;
    GLfloat sinCache1a[CACHE_SIZE];
    GLfloat cosCache1a[CACHE_SIZE];
    GLfloat sinCache2a[CACHE_SIZE];
    GLfloat cosCache2a[CACHE_SIZE];
    GLfloat sinCache3a[CACHE_SIZE];
    GLfloat cosCache3a[CACHE_SIZE];
    GLfloat sinCache1b[CACHE_SIZE];
    GLfloat cosCache1b[CACHE_SIZE];
    GLfloat sinCache2b[CACHE_SIZE];
    GLfloat cosCache2b[CACHE_SIZE];
    GLfloat sinCache3b[CACHE_SIZE];
    GLfloat cosCache3b[CACHE_SIZE];
    GLfloat angle;
    GLfloat x, y, zLow, zHigh;
    GLfloat sintemp1, sintemp2, sintemp3, sintemp4;
    GLfloat costemp1, costemp2, costemp3, costemp4;
    GLfloat zNormal;
    GLfloat xyNormalRatio;
    GLboolean needCache2, needCache3;
    GLint start, finish;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;
    if (slices < 2 || stacks < 1 || radius < 0.0) {
	gluQuadricError(qobj, GLU_INVALID_VALUE);
	return;
    }

    /* Cache is the vertex locations cache */
    /* Cache2 is the various normals at the vertices themselves */
    /* Cache3 is the various normals for the faces */
    needCache2 = needCache3 = GL_FALSE;

    if (qobj->normals == GLU_SMOOTH) {
	needCache2 = GL_TRUE;
    }

    if (qobj->normals == GLU_FLAT) {
	if (qobj->drawStyle != GLU_POINT) {
	    needCache3 = GL_TRUE;
	}
	if (qobj->drawStyle == GLU_LINE) {
	    needCache2 = GL_TRUE;
	}
    }

    for (i = 0; i < slices; i++) {
	angle = 2 * PI * i / slices;
	sinCache1a[i] = SIN(angle);
	cosCache1a[i] = COS(angle);
	if (needCache2) {
	    sinCache2a[i] = sinCache1a[i];
	    cosCache2a[i] = cosCache1a[i];
	}
    }

    for (j = 0; j <= stacks; j++) {
	angle = PI * j / stacks;
	if (needCache2) {
	    if (qobj->orientation == GLU_OUTSIDE) {
		sinCache2b[j] = SIN(angle);
		cosCache2b[j] = COS(angle);
	    } else {
		sinCache2b[j] = -SIN(angle);
		cosCache2b[j] = -COS(angle);
	    }
	}
	sinCache1b[j] = radius * SIN(angle);
	cosCache1b[j] = radius * COS(angle);
    }
    /* Make sure it comes to a point */
    sinCache1b[0] = 0;
    sinCache1b[stacks] = 0;

    if (needCache3) {
	for (i = 0; i < slices; i++) {
	    angle = 2 * PI * (i-0.5) / slices;
	    sinCache3a[i] = SIN(angle);
	    cosCache3a[i] = COS(angle);
	}
	for (j = 0; j <= stacks; j++) {
	    angle = PI * (j - 0.5) / stacks;
	    if (qobj->orientation == GLU_OUTSIDE) {
		sinCache3b[j] = SIN(angle);
		cosCache3b[j] = COS(angle);
	    } else {
		sinCache3b[j] = -SIN(angle);
		cosCache3b[j] = -COS(angle);
	    }
	}
    } 

    sinCache1a[slices] = sinCache1a[0];
    cosCache1a[slices] = cosCache1a[0];
    if (needCache2) {
	sinCache2a[slices] = sinCache2a[0];
	cosCache2a[slices] = cosCache2a[0];
    }
    if (needCache3) {
	sinCache3a[slices] = sinCache3a[0];
	cosCache3a[slices] = cosCache3a[0];
    }

    switch (qobj->drawStyle) {
      case GLU_FILL:
	/* Do ends of sphere as TRIANGLE_FAN's (if not texturing)
	** We don't do it when texturing because we need to respecify the
	** texture coordinates of the apex for every adjacent vertex (because
	** it isn't a constant for that point)
	*/
	if (!(qobj->textureCoords)) {
	    start = 1;
	    finish = stacks - 1;

	    /* Low end first (j == 0 iteration) */
	    sintemp2 = sinCache1b[1];
	    zHigh = cosCache1b[1];
	    switch(qobj->normals) {
	      case GLU_FLAT:
		sintemp3 = sinCache3b[1];
		costemp3 = cosCache3b[1];
		break;
	      case GLU_SMOOTH:
		sintemp3 = sinCache2b[1];
		costemp3 = cosCache2b[1];
		glNormal3f(sinCache2a[0] * sinCache2b[0],
			cosCache2a[0] * sinCache2b[0],
			cosCache2b[0]);
		break;
	      default:
		break;
	    }
	    glBegin(GL_TRIANGLE_FAN);
	    glVertex3f(0.0, 0.0, radius);
	    if (qobj->orientation == GLU_OUTSIDE) {
		for (i = slices; i >= 0; i--) {
		    switch(qobj->normals) {
		      case GLU_SMOOTH:
			glNormal3f(sinCache2a[i] * sintemp3,
				cosCache2a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_FLAT:
			if (i != slices) {
			    glNormal3f(sinCache3a[i+1] * sintemp3,
				    cosCache3a[i+1] * sintemp3,
				    costemp3);
			}
			break;
		      case GLU_NONE:
		      default:
			break;
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		}
	    } else {
		for (i = 0; i <= slices; i++) {
		    switch(qobj->normals) {
		      case GLU_SMOOTH:
			glNormal3f(sinCache2a[i] * sintemp3,
				cosCache2a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_FLAT:
			glNormal3f(sinCache3a[i] * sintemp3,
				cosCache3a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_NONE:
		      default:
			break;
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		}
	    }
	    glEnd();

	    /* High end next (j == stacks-1 iteration) */
	    sintemp2 = sinCache1b[stacks-1];
	    zHigh = cosCache1b[stacks-1];
	    switch(qobj->normals) {
	      case GLU_FLAT:
		sintemp3 = sinCache3b[stacks];
		costemp3 = cosCache3b[stacks];
		break;
	      case GLU_SMOOTH:
		sintemp3 = sinCache2b[stacks-1];
		costemp3 = cosCache2b[stacks-1];
		glNormal3f(sinCache2a[stacks] * sinCache2b[stacks],
			cosCache2a[stacks] * sinCache2b[stacks],
			cosCache2b[stacks]);
		break;
	      default:
		break;
	    }
	    glBegin(GL_TRIANGLE_FAN);
	    glVertex3f(0.0, 0.0, -radius);
	    if (qobj->orientation == GLU_OUTSIDE) {
		for (i = 0; i <= slices; i++) {
		    switch(qobj->normals) {
		      case GLU_SMOOTH:
			glNormal3f(sinCache2a[i] * sintemp3,
				cosCache2a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_FLAT:
			glNormal3f(sinCache3a[i] * sintemp3,
				cosCache3a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_NONE:
		      default:
			break;
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		}
	    } else {
		for (i = slices; i >= 0; i--) {
		    switch(qobj->normals) {
		      case GLU_SMOOTH:
			glNormal3f(sinCache2a[i] * sintemp3,
				cosCache2a[i] * sintemp3,
				costemp3);
			break;
		      case GLU_FLAT:
			if (i != slices) {
			    glNormal3f(sinCache3a[i+1] * sintemp3,
				    cosCache3a[i+1] * sintemp3,
				    costemp3);
			}
			break;
		      case GLU_NONE:
		      default:
			break;
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		}
	    }
	    glEnd();
	} else {
	    start = 0;
	    finish = stacks;
	}
	for (j = start; j < finish; j++) {
	    zLow = cosCache1b[j];
	    zHigh = cosCache1b[j+1];
	    sintemp1 = sinCache1b[j];
	    sintemp2 = sinCache1b[j+1];
	    switch(qobj->normals) {
	      case GLU_FLAT:
		sintemp4 = sinCache3b[j+1];
		costemp4 = cosCache3b[j+1];
		break;
	      case GLU_SMOOTH:
		if (qobj->orientation == GLU_OUTSIDE) {
		    sintemp3 = sinCache2b[j+1];
		    costemp3 = cosCache2b[j+1];
		    sintemp4 = sinCache2b[j];
		    costemp4 = cosCache2b[j];
		} else {
		    sintemp3 = sinCache2b[j];
		    costemp3 = cosCache2b[j];
		    sintemp4 = sinCache2b[j+1];
		    costemp4 = cosCache2b[j+1];
		}
		break;
	      default:
	        break;
	    }

	    glBegin(GL_QUAD_STRIP);
	    for (i = 0; i <= slices; i++) {
		switch(qobj->normals) {
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2a[i] * sintemp3,
			    cosCache2a[i] * sintemp3,
			    costemp3);
		    break;
		  case GLU_FLAT:
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->orientation == GLU_OUTSIDE) {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				1 - (float) (j+1) / stacks);
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		} else {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				1 - (float) j / stacks);
		    }
		    glVertex3f(sintemp1 * sinCache1a[i],
			    sintemp1 * cosCache1a[i], zLow);
		}
		switch(qobj->normals) {
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2a[i] * sintemp4,
			    cosCache2a[i] * sintemp4,
			    costemp4);
		    break;
		  case GLU_FLAT:
		    glNormal3f(sinCache3a[i] * sintemp4,
			    cosCache3a[i] * sintemp4,
			    costemp4);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->orientation == GLU_OUTSIDE) {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				1 - (float) j / stacks);
		    }
		    glVertex3f(sintemp1 * sinCache1a[i],
			    sintemp1 * cosCache1a[i], zLow);
		} else {
		    if (qobj->textureCoords) {
			glTexCoord2f(1 - (float) i / slices,
				1 - (float) (j+1) / stacks);
		    }
		    glVertex3f(sintemp2 * sinCache1a[i],
			    sintemp2 * cosCache1a[i], zHigh);
		}
	    }
	    glEnd();
	}
	break;
      case GLU_POINT:
	glBegin(GL_POINTS);
	for (j = 0; j <= stacks; j++) {
	    sintemp1 = sinCache1b[j];
	    costemp1 = cosCache1b[j];
	    switch(qobj->normals) {
	      case GLU_FLAT:
	      case GLU_SMOOTH:
		sintemp2 = sinCache2b[j];
		costemp2 = cosCache2b[j];
		break;
	      default:
	        break;
	    }
	    for (i = 0; i < slices; i++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2a[i] * sintemp2,
			    cosCache2a[i] * sintemp2,
			    costemp2);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}

		zLow = j * radius / stacks;

		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    1 - (float) j / stacks);
		}
		glVertex3f(sintemp1 * sinCache1a[i], 
			sintemp1 * cosCache1a[i], costemp1);
	    }
	}
	glEnd();
	break;
      case GLU_LINE:
      case GLU_SILHOUETTE:
	for (j = 1; j < stacks; j++) {
	    sintemp1 = sinCache1b[j];
	    costemp1 = cosCache1b[j];
	    switch(qobj->normals) {
	      case GLU_FLAT:
	      case GLU_SMOOTH:
		sintemp2 = sinCache2b[j];
		costemp2 = cosCache2b[j];
		break;
	      default:
		break;
	    }

	    glBegin(GL_LINE_STRIP);
	    for (i = 0; i <= slices; i++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		    glNormal3f(sinCache3a[i] * sintemp2,
			    cosCache3a[i] * sintemp2,
			    costemp2);
		    break;
		  case GLU_SMOOTH:
		    glNormal3f(sinCache2a[i] * sintemp2,
			    cosCache2a[i] * sintemp2,
			    costemp2);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}
		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    1 - (float) j / stacks);
		}
		glVertex3f(sintemp1 * sinCache1a[i], 
			sintemp1 * cosCache1a[i], costemp1);
	    }
	    glEnd();
	}
	for (i = 0; i < slices; i++) {
	    sintemp1 = sinCache1a[i];
	    costemp1 = cosCache1a[i];
	    switch(qobj->normals) {
	      case GLU_FLAT:
	      case GLU_SMOOTH:
		sintemp2 = sinCache2a[i];
		costemp2 = cosCache2a[i];
		break;
	      default:
		break;
	    }

	    glBegin(GL_LINE_STRIP);
	    for (j = 0; j <= stacks; j++) {
		switch(qobj->normals) {
		  case GLU_FLAT:
		    glNormal3f(sintemp2 * sinCache3b[j],
			    costemp2 * sinCache3b[j],
			    cosCache3b[j]);
		    break;
		  case GLU_SMOOTH:
		    glNormal3f(sintemp2 * sinCache2b[j],
			    costemp2 * sinCache2b[j],
			    cosCache2b[j]);
		    break;
		  case GLU_NONE:
		  default:
		    break;
		}

		if (qobj->textureCoords) {
		    glTexCoord2f(1 - (float) i / slices,
			    1 - (float) j / stacks);
		}
		glVertex3f(sintemp1 * sinCache1b[j], 
			costemp1 * sinCache1b[j], cosCache1b[j]);
	    }
	    glEnd();
	}
	break;
      default:
	break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libutil\project.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.2 $
** $Date: 1995/06/23 21:27:54 $
*/
#ifdef NT
#include <glos.h>
#endif
#include <math.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "gluint.h"

/*
** Make m an identity matrix
*/
void __gluMakeIdentityd(GLdouble m[16])
{
    m[0+4*0] = 1; m[0+4*1] = 0; m[0+4*2] = 0; m[0+4*3] = 0;
    m[1+4*0] = 0; m[1+4*1] = 1; m[1+4*2] = 0; m[1+4*3] = 0;
    m[2+4*0] = 0; m[2+4*1] = 0; m[2+4*2] = 1; m[2+4*3] = 0;
    m[3+4*0] = 0; m[3+4*1] = 0; m[3+4*2] = 0; m[3+4*3] = 1;
}

void __gluMakeIdentityf(GLfloat m[16])
{
    m[0+4*0] = 1; m[0+4*1] = 0; m[0+4*2] = 0; m[0+4*3] = 0;
    m[1+4*0] = 0; m[1+4*1] = 1; m[1+4*2] = 0; m[1+4*3] = 0;
    m[2+4*0] = 0; m[2+4*1] = 0; m[2+4*2] = 1; m[2+4*3] = 0;
    m[3+4*0] = 0; m[3+4*1] = 0; m[3+4*2] = 0; m[3+4*3] = 1;
}

void APIENTRY gluOrtho2D(GLdouble left, GLdouble right,
	       GLdouble bottom, GLdouble top)

{
    glOrtho(left, right, bottom, top, -1, 1);
}

#define __glPi 3.14159265358979323846

void APIENTRY gluPerspective(GLdouble fovy, GLdouble aspect,
		  GLdouble zNear, GLdouble zFar)
{
    GLdouble m[4][4];
    double sine, cotangent, deltaZ;
    double radians = fovy / 2 * __glPi / 180;

    deltaZ = zFar - zNear;
    sine = sin(radians);
    if ((deltaZ == 0) || (sine == 0) || (aspect == 0)) {
	return;
    }
    cotangent = COS(radians) / sine;

    __gluMakeIdentityd(&m[0][0]);
    m[0][0] = cotangent / aspect;
    m[1][1] = cotangent;
    m[2][2] = -(zFar + zNear) / deltaZ;
    m[2][3] = -1;
    m[3][2] = -2 * zNear * zFar / deltaZ;
    m[3][3] = 0;
    glMultMatrixd(&m[0][0]);
}

static void normalize(float v[3])
{
    float r;

    r = sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    if (r == 0.0) return;

    v[0] /= r;
    v[1] /= r;
    v[2] /= r;
}

static void cross(float v1[3], float v2[3], float result[3])
{
    result[0] = v1[1]*v2[2] - v1[2]*v2[1];
    result[1] = v1[2]*v2[0] - v1[0]*v2[2];
    result[2] = v1[0]*v2[1] - v1[1]*v2[0];
}

void APIENTRY gluLookAt(GLdouble eyex, GLdouble eyey, GLdouble eyez,
	      GLdouble centerx, GLdouble centery, GLdouble centerz,
	      GLdouble upx, GLdouble upy, GLdouble upz)
{
    int i;
    float forward[3], side[3], up[3];
    GLfloat m[4][4];

    forward[0] = centerx - eyex;
    forward[1] = centery - eyey;
    forward[2] = centerz - eyez;

    up[0] = upx;
    up[1] = upy;
    up[2] = upz;

    normalize(forward);

    /* Side = forward x up */
    cross(forward, up, side);
    normalize(side);

    /* Recompute up as: up = side x forward */
    cross(side, forward, up);

    __gluMakeIdentityf(&m[0][0]);
    m[0][0] = side[0];
    m[1][0] = side[1];
    m[2][0] = side[2];

    m[0][1] = up[0];
    m[1][1] = up[1];
    m[2][1] = up[2];

    m[0][2] = -forward[0];
    m[1][2] = -forward[1];
    m[2][2] = -forward[2];

    glMultMatrixf(&m[0][0]);
    glTranslated(-eyex, -eyey, -eyez);
}

void __gluMultMatrixVecd(const GLdouble matrix[16], const GLdouble in[4],
		      GLdouble out[4])
{
    int i;

    for (i=0; i<4; i++) {
	out[i] = 
	    in[0] * matrix[0*4+i] +
	    in[1] * matrix[1*4+i] +
	    in[2] * matrix[2*4+i] +
	    in[3] * matrix[3*4+i];
    }
}

/*
** inverse = invert(src)
*/
int __gluInvertMatrixd(const GLdouble src[16], GLdouble inverse[16])
{
    int i, j, k, swap;
    double t;
    GLdouble temp[4][4];

    for (i=0; i<4; i++) {
	for (j=0; j<4; j++) {
	    temp[i][j] = src[i*4+j];
	}
    }
    __gluMakeIdentityd(inverse);

    for (i = 0; i < 4; i++) {
	/*
	** Look for largest element in column
	*/
	swap = i;
	for (j = i + 1; j < 4; j++) {
	    if (fabs(temp[j][i]) > fabs(temp[i][i])) {
		swap = j;
	    }
	}

	if (swap != i) {
	    /*
	    ** Swap rows.
	    */
	    for (k = 0; k < 4; k++) {
		t = temp[i][k];
		temp[i][k] = temp[swap][k];
		temp[swap][k] = t;

		t = inverse[i*4+k];
		inverse[i*4+k] = inverse[swap*4+k];
		inverse[swap*4+k] = t;
	    }
	}

	if (temp[i][i] == 0) {
	    /*
	    ** No non-zero pivot.  The matrix is singular, which shouldn't
	    ** happen.  This means the user gave us a bad matrix.
	    */
	    return GL_FALSE;
	}

	t = temp[i][i];
	for (k = 0; k < 4; k++) {
	    temp[i][k] /= t;
	    inverse[i*4+k] /= t;
	}
	for (j = 0; j < 4; j++) {
	    if (j != i) {
		t = temp[j][i];
		for (k = 0; k < 4; k++) {
		    temp[j][k] -= temp[i][k]*t;
		    inverse[j*4+k] -= inverse[i*4+k]*t;
		}
	    }
	}
    }
    return GL_TRUE;
}

void __gluMultMatricesd(const GLdouble a[16], const GLdouble b[16], GLdouble r[16])
{
    int i, j;

    for (i = 0; i < 4; i++) {
	for (j = 0; j < 4; j++) {
	    r[i*4+j] = 
		a[i*4+0]*b[0*4+j] +
		a[i*4+1]*b[1*4+j] +
		a[i*4+2]*b[2*4+j] +
		a[i*4+3]*b[3*4+j];
	}
    }
}

GLint APIENTRY gluProject(GLdouble objx, GLdouble objy, GLdouble objz,
	      const GLdouble modelMatrix[16], 
	      const GLdouble projMatrix[16],
              const GLint viewport[4],
	      GLdouble *winx, GLdouble *winy, GLdouble *winz)
{
    double in[4];
    double out[4];

    in[0]=objx;
    in[1]=objy;
    in[2]=objz;
    in[3]=1.0;
    __gluMultMatrixVecd(modelMatrix, in, out);
    __gluMultMatrixVecd(projMatrix, out, in);
    if (in[3] == 0.0) return(GL_FALSE);
    in[0] /= in[3];
    in[1] /= in[3];
    in[2] /= in[3];
    /* Map x, y and z to range 0-1 */
    in[0] = in[0] * 0.5 + 0.5;
    in[1] = in[1] * 0.5 + 0.5;
    in[2] = in[2] * 0.5 + 0.5;

    /* Map x,y to viewport */
    in[0] = in[0] * viewport[2] + viewport[0];
    in[1] = in[1] * viewport[3] + viewport[1];

    *winx=in[0];
    *winy=in[1];
    *winz=in[2];
    return(GL_TRUE);
}

GLint APIENTRY gluUnProject(GLdouble winx, GLdouble winy, GLdouble winz,
		const GLdouble modelMatrix[16], 
		const GLdouble projMatrix[16],
                const GLint viewport[4],
	        GLdouble *objx, GLdouble *objy, GLdouble *objz)
{
    double finalMatrix[16];
    double in[4];
    double out[4];

    __gluMultMatricesd(modelMatrix, projMatrix, finalMatrix);
    if (!__gluInvertMatrixd(finalMatrix, finalMatrix)) return(GL_FALSE);

    in[0]=winx;
    in[1]=winy;
    in[2]=winz;
    in[3]=1.0;

    /* Map x and y from window coordinates */
    in[0] = (in[0] - viewport[0]) / viewport[2];
    in[1] = (in[1] - viewport[1]) / viewport[3];

    /* Map to range -1 to 1 */
    in[0] = in[0] * 2 - 1;
    in[1] = in[1] * 2 - 1;
    in[2] = in[2] * 2 - 1;

    __gluMultMatrixVecd(finalMatrix, in, out);
    if (out[3] == 0.0) return(GL_FALSE);
    out[0] /= out[3];
    out[1] /= out[3];
    out[2] /= out[3];
    *objx = out[0];
    *objy = out[1];
    *objz = out[2];
    return(GL_TRUE);
}

void APIENTRY gluPickMatrix(GLdouble x, GLdouble y, GLdouble deltax, GLdouble deltay,
		  GLint viewport[4])
{
    if (deltax <= 0 || deltay <= 0) { 
	return;
    }

    /* Translate and scale the picked region to the entire window */
    glTranslatef((viewport[2] - 2 * (x - viewport[0])) / deltax,
	    (viewport[3] - 2 * (y - viewport[1])) / deltay, 0);
    glScalef(viewport[2] / deltax, viewport[3] / deltay, 1.0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\clients\glcurvev.h ===
#ifndef __gluglcurveval_h_
#define __gluglcurveval_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glcurveval.h
 *
 * $Revision: 1.3 $
 */

#ifndef NT
#pragma once
#endif

#include "basiccrv.h"

class CurveMap;

class OpenGLCurveEvaluator : public BasicCurveEvaluator  {  
public:
			OpenGLCurveEvaluator(void);
			~OpenGLCurveEvaluator(void);
    void		range1f(long, REAL *, REAL *);
    void		domain1f(REAL, REAL);
    void		addMap(CurveMap *);

    void		enable(long);
    void		disable(long);
    void		bgnmap1f(long);
    void		map1f(long, REAL, REAL, long, long, REAL *);
    void		mapgrid1f(long, REAL, REAL);
    void		mapmesh1f(long, long, long);
    void		evalpoint1i(long);
    void		evalcoord1f(long, REAL);
    void		endmap1f(void);

    void		bgnline(void);
    void		endline(void);
};

#endif /* __gluglcurveval_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\clients\glcurvev.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glcurveval.c++ - curve evaluator
 *
 * $Revision: 1.1 $
 */

/* Polynomial Evaluator Interface */

#include <glos.h>
#include <GL/gl.h>
#include "glimport.h"
#include "glrender.h"
#include "glcurvev.h"
#include "nurbscon.h"
 
OpenGLCurveEvaluator::OpenGLCurveEvaluator(void) 
{ 
}

OpenGLCurveEvaluator::~OpenGLCurveEvaluator(void) 
{ 
}

/* added nonsense to avoid the warning messages at compile time */
void
OpenGLCurveEvaluator::addMap(CurveMap *m)
{
	m = m;
}

void
OpenGLCurveEvaluator::range1f(long type, REAL *from, REAL *to)
{
	type = type;
	from = from;
	to = to;
}

void
OpenGLCurveEvaluator::domain1f(REAL ulo, REAL uhi)
{
	ulo = ulo;
	uhi = uhi;
}

void
OpenGLCurveEvaluator::bgnline(void)
{
    glBegin((GLenum) GL_LINE_STRIP);
}

void
OpenGLCurveEvaluator::endline(void)
{
    glEnd();
}

/*---------------------------------------------------------------------------
 * disable - turn off a curve map
 *---------------------------------------------------------------------------
 */
void
OpenGLCurveEvaluator::disable(long type)
{
    glDisable((GLenum) type);
}

/*---------------------------------------------------------------------------
 * enable - turn on a curve map
 *---------------------------------------------------------------------------
 */
void
OpenGLCurveEvaluator::enable(long type)
{
    glEnable((GLenum) type);
}

/*-------------------------------------------------------------------------
 * mapgrid1f - define a lattice of points with origin and offset
 *-------------------------------------------------------------------------
 */
void 
OpenGLCurveEvaluator::mapgrid1f(long nu, REAL u0, REAL u1)
{
    glMapGrid1f((GLint) nu, (GLfloat) u0, (GLfloat) u1);
}

/*-------------------------------------------------------------------------
 * bgnmap1 - preamble to curve definition and evaluations
 *-------------------------------------------------------------------------
 */
void
OpenGLCurveEvaluator::bgnmap1f(long)
{
    glPushAttrib((GLbitfield) GL_EVAL_BIT);
}

/*-------------------------------------------------------------------------
 * endmap1 - postamble to a curve map
 *-------------------------------------------------------------------------
 */
void
OpenGLCurveEvaluator::endmap1f(void)
{
    glPopAttrib();
}

/*-------------------------------------------------------------------------
 * map1f - pass a desription of a curve map
 *-------------------------------------------------------------------------
 */
void
OpenGLCurveEvaluator::map1f(
    long type,		 	/* map type */
    REAL ulo,			/* lower parametric bound */
    REAL uhi,			/* upper parametric bound */
    long stride, 		/* distance to next point in REALS */
    long order,			/* parametric order */
    REAL *pts 			/* control points */
)
{
    glMap1f((GLenum) type, (GLfloat) ulo, (GLfloat) uhi, (GLint) stride, 
	    (GLint) order, (const GLfloat *) pts);
}

/*-------------------------------------------------------------------------
 * mapmesh1f - evaluate a mesh of points on lattice
 *-------------------------------------------------------------------------
 */
void OpenGLCurveEvaluator::mapmesh1f(long style, long from, long to)
{
    switch(style) {
    default:
    case N_MESHFILL:
    case N_MESHLINE:
	glEvalMesh1((GLenum) GL_LINE, (GLint) from, (GLint) to);
	break;
    case N_MESHPOINT:
	glEvalMesh1((GLenum) GL_POINT, (GLint) from, (GLint) to);
	break;
    }
}

/*-------------------------------------------------------------------------
 * evalpoint1i - evaluate a point on a curve
 *-------------------------------------------------------------------------
 */
void OpenGLCurveEvaluator::evalpoint1i(long i)
{
    glEvalPoint1((GLint) i);
}

/*-------------------------------------------------------------------------
 * evalcoord1f - evaluate a point on a curve
 *-------------------------------------------------------------------------
 */
void OpenGLCurveEvaluator::evalcoord1f(long, REAL u)
{
    glEvalCoord1f((GLfloat) u);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libutil\gluint.h ===
#ifndef __gluint_h__
#define __gluint_h__

/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.1 $
** $Date: 1995/06/08 22:28:21 $
*/

#include <glos.h>

extern const char *__glNURBSErrorString( int errno );
extern const char *__glTessErrorString( int errno );

#ifdef NT
extern LPCWSTR __glNURBSErrorStringW( int errno );
extern LPCWSTR __glTessErrorStringW( int errno );
#endif

#ifdef _EXTENSIONS_
#define COS cosf
#define SIN sinf
#define SQRT sqrtf
#else
#define COS cos
#define SIN sin
#define SQRT sqrt
#endif

#endif /* __gluint_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libutil\mipmap.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.4 $
** $Date: 1996/03/29 01:55:31 $
*/
#ifdef NT
#include <glos.h>
#endif
#include <assert.h>
#include "gluint.h"
#include <GL/glu.h>
#include <stdio.h>
#ifdef NT
#include "winmem.h"
#else
#include <stdlib.h>
#endif
#include <string.h>
#include <math.h>

typedef union {
    unsigned char ub[4];
    unsigned short us[2];
    unsigned long ui;
    char b[4];
    short s[2];
    long i;
    float f;
} Type_Widget;

/* Pixel storage modes */ 
typedef struct {
   GLint pack_alignment;
   GLint pack_row_length; 
   GLint pack_skip_rows;  
   GLint pack_skip_pixels;
   GLint pack_lsb_first;
   GLint pack_swap_bytes;

   GLint unpack_alignment;
   GLint unpack_row_length;
   GLint unpack_skip_rows;
   GLint unpack_skip_pixels;
   GLint unpack_lsb_first;
   GLint unpack_swap_bytes;
} PixelStorageModes;

/*
 * internal function declarations
 */
static GLfloat bytes_per_element(GLenum type);
static GLint elements_per_group(GLenum format);
#ifdef NT
static GLboolean is_index(GLenum format);
#else
static GLint is_index(GLenum format);
#endif
static GLint image_size(GLint width, GLint height, GLenum format, GLenum type);
static void fill_image(const PixelStorageModes *,
		       GLint width, GLint height, GLenum format, 
		       GLenum type, GLboolean index_format, 
		       const void *userdata, GLushort *newimage);
static void empty_image(const PixelStorageModes *,
			GLint width, GLint height, GLenum format, 
		        GLenum type, GLboolean index_format, 
			const GLushort *oldimage, void *userdata);
static void scale_internal(GLint components, GLint widthin, GLint heightin, 
			   const GLushort *datain, 
			   GLint widthout, GLint heightout, 
			   GLushort *dataout);

static GLint retrieveStoreModes(PixelStorageModes *psm)
{
    glGetError();
    glGetIntegerv(GL_UNPACK_ALIGNMENT, &psm->unpack_alignment);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_UNPACK_ROW_LENGTH, &psm->unpack_row_length);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_UNPACK_SKIP_ROWS, &psm->unpack_skip_rows);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_UNPACK_SKIP_PIXELS, &psm->unpack_skip_pixels);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_UNPACK_LSB_FIRST, &psm->unpack_lsb_first);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_UNPACK_SWAP_BYTES, &psm->unpack_swap_bytes);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_ALIGNMENT, &psm->pack_alignment);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_ROW_LENGTH, &psm->pack_row_length);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_SKIP_ROWS, &psm->pack_skip_rows);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_SKIP_PIXELS, &psm->pack_skip_pixels);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_LSB_FIRST, &psm->pack_lsb_first);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    glGetIntegerv(GL_PACK_SWAP_BYTES, &psm->pack_swap_bytes);
    if (glGetError() != GL_NO_ERROR)
    {
        return 1;
    }
    return 0;
}

static int computeLog(GLuint value)
{
    int i;

    i = 0;

    /* Error! */
    if (value == 0) return -1;

    for (;;) {
	if (value & 1) {
	    /* Error ! */
	    if (value != 1) return -1;
	    return i;
	}
	value = value >> 1;
	i++;
    }
}

/* 
** Compute the nearest power of 2 number.  This algorithm is a little 
** strange, but it works quite well.
*/
static int nearestPower(GLuint value)
{
    int i;

    i = 1;

    /* Error! */
    if (value == 0) return -1;

    for (;;) {
	if (value == 1) {
	    return i;
	} else if (value == 3) {
	    return i*4;
	}
	value = value >> 1;
	i *= 2;
    }
}

static void halveImage(GLint components, GLuint width, GLuint height, 
		       const GLushort *datain, GLushort *dataout)
{
    int i, j, k;
    int newwidth, newheight;
    int delta;
    GLushort *s;
    const GLushort *t;

    newwidth = width / 2;
    newheight = height / 2;
    delta = width * components;
    s = dataout;
    t = datain;

    /* Piece o' cake! */
    for (i = 0; i < newheight; i++) {
	for (j = 0; j < newwidth; j++) {
	    for (k = 0; k < components; k++) {
		s[0] = (t[0] + t[components] + t[delta] + 
			t[delta+components] + 2) / 4;
		s++; t++;
	    }
	    t += components;
	}
	t += delta;
    }
}

static void scale_internal(GLint components, GLint widthin, GLint heightin, 
			   const GLushort *datain, 
			   GLint widthout, GLint heightout, 
			   GLushort *dataout)
{
    float x, lowx, highx, convx, halfconvx;
    float y, lowy, highy, convy, halfconvy;
    float xpercent,ypercent;
    float percent;
    /* Max components in a format is 4, so... */
    float totals[4];
    float area;
    int i,j,k,yint,xint,xindex,yindex;
    int temp;

    if (widthin == widthout*2 && heightin == heightout*2) {
	halveImage(components, widthin, heightin, datain, dataout);
	return;
    }
    convy = (float) heightin/heightout;
    convx = (float) widthin/widthout;
    halfconvx = convx/2;
    halfconvy = convy/2;
    for (i = 0; i < heightout; i++) {
	y = convy * (i+0.5);
	if (heightin > heightout) {
	    highy = y + halfconvy;
	    lowy = y - halfconvy;
	} else {
	    highy = y + 0.5;
	    lowy = y - 0.5;
	}
	for (j = 0; j < widthout; j++) {
	    x = convx * (j+0.5);
	    if (widthin > widthout) {
		highx = x + halfconvx;
		lowx = x - halfconvx;
	    } else {
		highx = x + 0.5;
		lowx = x - 0.5;
	    }

	    /*
	    ** Ok, now apply box filter to box that goes from (lowx, lowy)
	    ** to (highx, highy) on input data into this pixel on output
	    ** data.
	    */
	    totals[0] = totals[1] = totals[2] = totals[3] = 0.0;
	    area = 0.0;

	    y = lowy;
	    yint = floor(y);
	    while (y < highy) {
		yindex = (yint + heightin) % heightin;
		if (highy < yint+1) {
		    ypercent = highy - y;
		} else {
		    ypercent = yint+1 - y;
		}

		x = lowx;
		xint = floor(x);

		while (x < highx) {
		    xindex = (xint + widthin) % widthin;
		    if (highx < xint+1) {
			xpercent = highx - x;
		    } else {
			xpercent = xint+1 - x;
		    }

		    percent = xpercent * ypercent;
		    area += percent;
		    temp = (xindex + (yindex * widthin)) * components;
		    for (k = 0; k < components; k++) {
			totals[k] += datain[temp + k] * percent;
		    }

		    xint++;
		    x = xint;
		}
		yint++;
		y = yint;
	    }

	    temp = (j + (i * widthout)) * components;
	    for (k = 0; k < components; k++) {
		dataout[temp + k] = totals[k]/area;
	    }
	}
    }
}

static GLboolean legalFormat(GLenum format)
{
    switch(format) {
      case GL_COLOR_INDEX:
      case GL_STENCIL_INDEX:
      case GL_DEPTH_COMPONENT:
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
      case GL_BGRA_EXT:
#endif
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
	return GL_TRUE;
      default:
	return GL_FALSE;
    }
}

static GLboolean legalType(GLenum type)
{
    switch(type) {
      case GL_BITMAP:
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	return GL_TRUE;
      default:
	return GL_FALSE;
    }
}

GLint gluScaleImage(GLenum format, GLint widthin, GLint heightin, 
		 GLenum typein, const void *datain, 
		 GLint widthout, GLint heightout, GLenum typeout,
		 void *dataout)
{
    int components;
    GLushort *beforeImage;
    GLushort *afterImage;
    PixelStorageModes psm;

    if (widthin == 0 || heightin == 0 || widthout == 0 || heightout == 0) {
	    return 0;
    }
    if (widthin < 0 || heightin < 0 || widthout < 0 || heightout < 0) {
	    return GLU_INVALID_VALUE;
    }
    if (!legalFormat(format) || !legalType(typein) || !legalType(typeout)) {
        return GLU_INVALID_ENUM;
    }

    if (retrieveStoreModes(&psm)) {
        return GL_OUT_OF_MEMORY;
    }
    
    beforeImage =
	malloc(image_size(widthin, heightin, format, GL_UNSIGNED_SHORT)); 
    afterImage =
	malloc(image_size(widthout, heightout, format, GL_UNSIGNED_SHORT));
    if (beforeImage == NULL || afterImage == NULL) {
	return GLU_OUT_OF_MEMORY;
    }

    fill_image(&psm,widthin, heightin, format, typein, is_index(format),
	    datain, beforeImage);

    components = elements_per_group(format);
    scale_internal(components, widthin, heightin, beforeImage, 
	    widthout, heightout, afterImage);

    empty_image(&psm,widthout, heightout, format, typeout, 
	    is_index(format), afterImage, dataout);
    free((GLbyte *) beforeImage);
    free((GLbyte *) afterImage);

    return 0;
}

GLint gluBuild1DMipmaps(GLenum target, GLint components, GLint width,
		     GLenum format, GLenum type, const void *data)
{
    GLint newwidth;
    GLint level, levels;
    GLushort *newImage;
    GLint newImage_width;
    GLushort *otherImage;
    GLushort *imageTemp;
    GLint memreq;
    GLint maxsize;
    GLint cmpts;
    PixelStorageModes psm;
    GLboolean error = GL_FALSE;
    
    if (width < 1) {
        return GLU_INVALID_VALUE;
    }
    if (!legalFormat(format) || !legalType(type)) {
        return GLU_INVALID_ENUM;
    }
    if (format == GL_STENCIL_INDEX) {
       return GLU_INVALID_ENUM;
    }
    if (format == GL_DEPTH_COMPONENT) {
       return GLU_INVALID_ENUM;
    }

    if (retrieveStoreModes(&psm)) {
       return GL_OUT_OF_MEMORY;
    }

    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxsize);
    if (glGetError() != GL_NO_ERROR)
    {
       return GL_OUT_OF_MEMORY;
    }

    newwidth = nearestPower(width);
    if (newwidth > maxsize) newwidth = maxsize;
    levels = computeLog(newwidth);

    otherImage = NULL;
    newImage = (GLushort *)
	malloc(image_size(width, 1, format, GL_UNSIGNED_SHORT)); 
    newImage_width = width;
    if (newImage == NULL) {
	return GLU_OUT_OF_MEMORY;
    }
    fill_image(&psm,width, 1, format, type, is_index(format),
	    data, newImage);
    cmpts = elements_per_group(format);

    glGetError();
    glPixelStorei(GL_UNPACK_ALIGNMENT, 2);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild1DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild1DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild1DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild1DMipmaps_cleanup;
    }
    /*
    ** If swap_bytes was set, swapping occurred in fill_image.
    */
    glPixelStorei(GL_UNPACK_SWAP_BYTES, GL_FALSE);
    if (glGetError() != GL_NO_ERROR)   {
        error = GL_TRUE;
        goto gluBuild1DMipmaps_cleanup;
    }

    for (level = 0; level <= levels; level++) {
	if (newImage_width == newwidth) {
	    /* Use newImage for this level */
	    glTexImage1D(target, level, components, newImage_width, 
		    0, format, GL_UNSIGNED_SHORT, (void *) newImage);
	} else {
	    if (otherImage == NULL) {
		memreq = image_size(newwidth, 1, format, GL_UNSIGNED_SHORT);
		otherImage = (GLushort *) malloc(memreq);
		if (otherImage == NULL) {
		    glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
		    glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
		    glPixelStorei(GL_UNPACK_SKIP_PIXELS,psm.unpack_skip_pixels);
		    glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
		    glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);
		    return GLU_OUT_OF_MEMORY;
		}
	    }
	    scale_internal(cmpts, newImage_width, 1, newImage, 
		    newwidth, 1, otherImage);
	    /* Swap newImage and otherImage */
	    imageTemp = otherImage; 
	    otherImage = newImage;
	    newImage = imageTemp;

	    newImage_width = newwidth;
	    glTexImage1D(target, level, components, newImage_width,
		    0, format, GL_UNSIGNED_SHORT, (void *) newImage);
	}
	if (newwidth > 1) newwidth /= 2;
    }

gluBuild1DMipmaps_cleanup:
    glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
    glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
    glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
    glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);

    free((GLbyte *) newImage);
    if (otherImage) {
	free((GLbyte *) otherImage);
    }
    if (error == GL_TRUE)
        return GL_OUT_OF_MEMORY;
    else
        return 0;
}

GLint gluBuild2DMipmaps(GLenum target, GLint components, GLint width, 
		     GLint height, GLenum format, 
		     GLenum type, const void *data)
{
    GLint newwidth, newheight;
    GLint level, levels;
    GLushort *newImage;
    GLint newImage_width;
    GLint newImage_height;
    GLushort *otherImage;
    GLushort *imageTemp;
    GLint memreq;
    GLint maxsize;
    GLint cmpts;
    GLboolean error = GL_FALSE;

    PixelStorageModes psm;

    if (width < 1 || height < 1) {
	return GLU_INVALID_VALUE;
    }
    if (!legalFormat(format) || !legalType(type)) {
	return GLU_INVALID_ENUM;
    }
    if (format == GL_STENCIL_INDEX) {
       return GLU_INVALID_ENUM;
    }
    if (format == GL_DEPTH_COMPONENT) {
       return GLU_INVALID_ENUM;
    }

    if (retrieveStoreModes(&psm)) {
       return GL_OUT_OF_MEMORY;
    }

    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxsize);
    if (glGetError() != GL_NO_ERROR)
    {
       return GL_OUT_OF_MEMORY;
    }

    newwidth = nearestPower(width);
    if (newwidth > maxsize) newwidth = maxsize;
    newheight = nearestPower(height);
    if (newheight > maxsize) newheight = maxsize;
    levels = computeLog(newwidth);
    level = computeLog(newheight);
    if (level > levels) levels=level;

    otherImage = NULL;
    newImage = (GLushort *) 
	malloc(image_size(width, height, format, GL_UNSIGNED_SHORT)); 
    newImage_width = width;
    newImage_height = height;
    if (newImage == NULL) {
	return GLU_OUT_OF_MEMORY;
    }
    fill_image(&psm,width, height, format, type, is_index(format),
	    data, newImage);
    cmpts = elements_per_group(format);

    glGetError();
    glPixelStorei(GL_UNPACK_ALIGNMENT, 2);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild2DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild2DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild2DMipmaps_cleanup;
    }
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild2DMipmaps_cleanup;
    }
    /*
    ** If swap_bytes was set, swapping occurred in fill_image.
    */
    glPixelStorei(GL_UNPACK_SWAP_BYTES, GL_FALSE);
    if (glGetError() != GL_NO_ERROR) {
        error = GL_TRUE;
        goto gluBuild2DMipmaps_cleanup;
    }

    for (level = 0; level <= levels; level++) {
	if (newImage_width == newwidth && newImage_height == newheight) {
	    /* Use newImage for this level */
	    glTexImage2D(target, level, components, newImage_width, 
		    newImage_height, 0, format, GL_UNSIGNED_SHORT, 
		    (void *) newImage);
	} else {
	    if (otherImage == NULL) {
		memreq = 
		    image_size(newwidth, newheight, format, GL_UNSIGNED_SHORT);
		otherImage = (GLushort *) malloc(memreq);
		if (otherImage == NULL) {
		    glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
		    glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
		    glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
		    glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
		    glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);
		    return GLU_OUT_OF_MEMORY;
		}
	    }
	    scale_internal(cmpts, newImage_width, newImage_height, newImage, 
		    newwidth, newheight, otherImage);
	    /* Swap newImage and otherImage */
	    imageTemp = otherImage; 
	    otherImage = newImage;
	    newImage = imageTemp;

	    newImage_width = newwidth;
	    newImage_height = newheight;
	    glTexImage2D(target, level, components, newImage_width, 
		    newImage_height, 0, format, GL_UNSIGNED_SHORT, 
		    (void *) newImage);
	}
	if (newwidth > 1) newwidth /= 2;
	if (newheight > 1) newheight /= 2;
    }
gluBuild2DMipmaps_cleanup:
    glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
    glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
    glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
    glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);

    free((GLbyte *) newImage);
    if (otherImage) {
	free((GLbyte *) otherImage);
    }
    if (error == GL_TRUE)
        return GL_OUT_OF_MEMORY;
    else
        return 0;
}

/*
 * Utility Routines
 */
static GLint elements_per_group(GLenum format) 
{
    /*
     * Return the number of elements per group of a specified format
     */
    switch(format) {
      case GL_RGB:
#ifdef GL_EXT_bgra
      case GL_BGR_EXT:
#endif
	return 3;
      case GL_LUMINANCE_ALPHA:
	return 2;
      case GL_RGBA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
#endif
	return 4;
      default:
	return 1;
    }
}

static GLfloat bytes_per_element(GLenum type) 
{
    /*
     * Return the number of bytes per element, based on the element type
     */
    switch(type) {
      case GL_BITMAP:
	return 1.0 / 8.0;
      case GL_UNSIGNED_SHORT:
      case GL_SHORT:
	return 2;
      case GL_UNSIGNED_BYTE:
      case GL_BYTE:
	return 1;
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
      default:
	return 4;
    }
}

#ifdef NT
static GLboolean is_index(GLenum format) 
#else
static GLint is_index(GLenum format) 
#endif
{
    return format == GL_COLOR_INDEX || format == GL_STENCIL_INDEX;
}

/*
** Compute memory required for internal packed array of data of given type
** and format.
*/
static GLint image_size(GLint width, GLint height, GLenum format, GLenum type) 
{
    int bytes_per_row;
    int components;

    assert(width > 0);
    assert(height > 0);
    components = elements_per_group(format);
    if (type == GL_BITMAP) {
	bytes_per_row = (width + 7) / 8;
    } else {
	bytes_per_row = bytes_per_element(type) * width;
    }
    return bytes_per_row * height * components;
}

/*
** Extract array from user's data applying all pixel store modes.
** The internal format used is an array of unsigned shorts.
*/
static void fill_image(const PixelStorageModes *psm,
		       GLint width, GLint height, GLenum format, 
		       GLenum type, GLboolean index_format, 
		       const void *userdata, GLushort *newimage)
{
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint groups_per_line;
    GLint group_size;
    GLint elements_per_line;
    const GLubyte *start;
    const GLubyte *iter;
    GLushort *iter2;
    GLint i, j, k;
    GLint myswap_bytes;

    myswap_bytes = psm->unpack_swap_bytes;
    components = elements_per_group(format);
    if (psm->unpack_row_length > 0) {
	groups_per_line = psm->unpack_row_length;
    } else {
	groups_per_line = width;
    }

    /* All formats except GL_BITMAP fall out trivially */
    if (type == GL_BITMAP) {
	GLint bit_offset;
	GLint current_bit;

	rowsize = (groups_per_line * components + 7) / 8;
	padding = (rowsize % psm->unpack_alignment);
	if (padding) {
	    rowsize += psm->unpack_alignment - padding;
	}
	start = (GLubyte *) userdata + psm->unpack_skip_rows * rowsize + 
		(psm->unpack_skip_pixels * components / 8);
	elements_per_line = width * components;
	iter2 = newimage;
	for (i = 0; i < height; i++) {
	    iter = start;
	    bit_offset = (psm->unpack_skip_pixels * components) % 8;
	    for (j = 0; j < elements_per_line; j++) {
		/* Retrieve bit */
		if (psm->unpack_lsb_first) {
		    current_bit = iter[0] & (1 << bit_offset);
		} else {
		    current_bit = iter[0] & (1 << (7 - bit_offset));
		}
		if (current_bit) {
		    if (index_format) {
			*iter2 = 1;
		    } else {
			*iter2 = 65535;
		    }
		} else {
		    *iter2 = 0;
		}
		bit_offset++;
		if (bit_offset == 8) {
		    bit_offset = 0;
		    iter++;
		}
		iter2++;
	    }
	    start += rowsize;
	}
    } else {
	element_size = bytes_per_element(type);
	group_size = element_size * components;
	if (element_size == 1) myswap_bytes = 0;

	rowsize = groups_per_line * group_size;
	padding = (rowsize % psm->unpack_alignment);
	if (padding) {
	    rowsize += psm->unpack_alignment - padding;
	}
	start = (GLubyte *) userdata + psm->unpack_skip_rows * rowsize + 
		psm->unpack_skip_pixels * group_size;
	elements_per_line = width * components;

	iter2 = newimage;
	for (i = 0; i < height; i++) {
	    iter = start;
	    for (j = 0; j < elements_per_line; j++) {
		Type_Widget widget;

		switch(type) {
		  case GL_UNSIGNED_BYTE:
		    if (index_format) {
			*iter2 = *iter;
		    } else {
			*iter2 = (*iter) * 257;
		    }
		    break;
		  case GL_BYTE:
		    if (index_format) {
			*iter2 = *((GLbyte *) iter);
		    } else {
			/* rough approx */
			*iter2 = (*((GLbyte *) iter)) * 516;
		    }
		    break;
		  case GL_UNSIGNED_SHORT:
		  case GL_SHORT:
		    if (myswap_bytes) {
			widget.ub[0] = iter[1];
			widget.ub[1] = iter[0];
		    } else {
			widget.ub[0] = iter[0];
			widget.ub[1] = iter[1];
		    }
		    if (type == GL_SHORT) {
			if (index_format) {
			    *iter2 = widget.s[0];
			} else {
			    /* rough approx */
			    *iter2 = widget.s[0]*2;
			}
		    } else {
			*iter2 = widget.us[0];
		    }
		    break;
		  case GL_INT:
		  case GL_UNSIGNED_INT:
		  case GL_FLOAT:
		    if (myswap_bytes) {
			widget.ub[0] = iter[3];
			widget.ub[1] = iter[2];
			widget.ub[2] = iter[1];
			widget.ub[3] = iter[0];
		    } else {
			widget.ub[0] = iter[0];
			widget.ub[1] = iter[1];
			widget.ub[2] = iter[2];
			widget.ub[3] = iter[3];
		    }
		    if (type == GL_FLOAT) {
			if (index_format) {
			    *iter2 = widget.f;
			} else {
			    *iter2 = 65535 * widget.f;
			}
		    } else if (type == GL_UNSIGNED_INT) {
			if (index_format) {
			    *iter2 = (GLushort)widget.ui;
			} else {
			    *iter2 = widget.ui >> 16;
			}
		    } else {
			if (index_format) {
			    *iter2 = (GLushort)widget.i;
			} else {
			    *iter2 = widget.i >> 15;
			}
		    }
		    break;
		}
		iter += element_size;
		iter2++;
	    }
	    start += rowsize;
	}
    }
}

/*
** Insert array into user's data applying all pixel store modes.
** The internal format is an array of unsigned shorts.
** empty_image() because it is the opposite of fill_image().
*/
static void empty_image(const PixelStorageModes *psm,
			GLint width, GLint height, GLenum format, 
		        GLenum type, GLboolean index_format, 
			const GLushort *oldimage, void *userdata)
{
    GLint components;
    GLint element_size;
    GLint rowsize;
    GLint padding;
    GLint groups_per_line;
    GLint group_size;
    GLint elements_per_line;
    GLubyte *start;
    GLubyte *iter;
    const GLushort *iter2;
    GLint i, j, k;
    GLint myswap_bytes;

    myswap_bytes = psm->pack_swap_bytes;
    components = elements_per_group(format);
    if (psm->pack_row_length > 0) {
	groups_per_line = psm->pack_row_length;
    } else {
	groups_per_line = width;
    }

    /* All formats except GL_BITMAP fall out trivially */
    if (type == GL_BITMAP) {
	GLint bit_offset;
	GLint current_bit;

	rowsize = (groups_per_line * components + 7) / 8;
	padding = (rowsize % psm->pack_alignment);
	if (padding) {
	    rowsize += psm->pack_alignment - padding;
	}
	start = (GLubyte *) userdata + psm->pack_skip_rows * rowsize + 
		(psm->pack_skip_pixels * components / 8);
	elements_per_line = width * components;
	iter2 = oldimage;
	for (i = 0; i < height; i++) {
	    iter = start;
	    bit_offset = (psm->pack_skip_pixels * components) % 8;
	    for (j = 0; j < elements_per_line; j++) {
		if (index_format) {
		    current_bit = iter2[0] & 1;
		} else {
		    if (iter2[0] > 32767) {
			current_bit = 1;
		    } else {
			current_bit = 0;
		    }
		}

		if (current_bit) {
		    if (psm->pack_lsb_first) {
			*iter |= (1 << bit_offset);
		    } else {
			*iter |= (1 << (7 - bit_offset));
		    }
		} else {
		    if (psm->pack_lsb_first) {
			*iter &= ~(1 << bit_offset);
		    } else {
			*iter &= ~(1 << (7 - bit_offset));
		    }
		}

		bit_offset++;
		if (bit_offset == 8) {
		    bit_offset = 0;
		    iter++;
		}
		iter2++;
	    }
	    start += rowsize;
	}
    } else {
	element_size = bytes_per_element(type);
	group_size = element_size * components;
	if (element_size == 1) myswap_bytes = 0;

	rowsize = groups_per_line * group_size;
	padding = (rowsize % psm->pack_alignment);
	if (padding) {
	    rowsize += psm->pack_alignment - padding;
	}
	start = (GLubyte *) userdata + psm->pack_skip_rows * rowsize + 
		psm->pack_skip_pixels * group_size;
	elements_per_line = width * components;

	iter2 = oldimage;
	for (i = 0; i < height; i++) {
	    iter = start;
	    for (j = 0; j < elements_per_line; j++) {
		Type_Widget widget;

		switch(type) {
		  case GL_UNSIGNED_BYTE:
		    if (index_format) {
			*iter = (GLubyte)*iter2;
		    } else {
			*iter = *iter2 >> 8;
		    }
		    break;
		  case GL_BYTE:
		    if (index_format) {
			*((GLbyte *) iter) = (GLbyte)*iter2;
		    } else {
			*((GLbyte *) iter) = *iter2 >> 9;
		    }
		    break;
		  case GL_UNSIGNED_SHORT:
		  case GL_SHORT:
		    if (type == GL_SHORT) {
			if (index_format) {
			    widget.s[0] = *iter2;
			} else {
			    widget.s[0] = *iter2 >> 1;
			}
		    } else {
			widget.us[0] = *iter2;
		    }
		    if (myswap_bytes) {
			iter[0] = widget.ub[1];
			iter[1] = widget.ub[0];
		    } else {
			iter[0] = widget.ub[0];
			iter[1] = widget.ub[1];
		    }
		    break;
		  case GL_INT:
		  case GL_UNSIGNED_INT:
		  case GL_FLOAT:
		    if (type == GL_FLOAT) {
			if (index_format) {
			    widget.f = *iter2;
			} else {
			    widget.f = *iter2 / (float) 65535.0;
			}
		    } else if (type == GL_UNSIGNED_INT) {
			if (index_format) {
			    widget.ui = *iter2;
			} else {
			    widget.ui = (unsigned int) *iter2 * 65537;
			}
		    } else {
			if (index_format) {
			    widget.i = *iter2;
			} else {
			    widget.i = ((unsigned int) *iter2 * 65537)/2;
			}
		    }
		    if (myswap_bytes) {
			iter[3] = widget.ub[0];
			iter[2] = widget.ub[1];
			iter[1] = widget.ub[2];
			iter[0] = widget.ub[3];
		    } else {
			iter[0] = widget.ub[0];
			iter[1] = widget.ub[1];
			iter[2] = widget.ub[2];
			iter[3] = widget.ub[3];
		    }
		    break;
		}
		iter += element_size;
		iter2++;
	    }
	    start += rowsize;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\libutil\registry.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.4 $
** $Date: 1996/03/18 10:54:22 $
*/
#include <glos.h>
#include <GL/glu.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef NT
static const GLubyte versionString[] = "1.2.2.0 Microsoft Corporation";
static const GLubyte extensionString[] = "GL_EXT_bgra";
static const GLubyte nullString[] = "";
#else
static const GLubyte versionString[] = "1.2 Irix 6.2";
static const GLubyte extensionString[] = "";
#endif

const GLubyte * APIENTRY gluGetString(GLenum name)
{
char *str;

    if (name == GLU_VERSION) {
        return versionString;
    } else if (name == GLU_EXTENSIONS) {
        str = (char *) glGetString(GL_EXTENSIONS);
        if (str != NULL)
            if (strstr( str, "GL_EXT_bgra") != NULL)
                return extensionString;
        return nullString;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\clients\glinterf.cxx ===
#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glimport.h"
#include "glrender.h"
#include "nurbscon.h"

GLUnurbs *gluNewNurbsRenderer(void)
{
    GLUnurbs *t;

    t = new GLUnurbs;
    return t;
}

void gluDeleteNurbsRenderer(GLUnurbs *r)
{
    delete r;
}

void gluBeginSurface(GLUnurbs *r)
{
    r->bgnsurface(0); 
}

void gluBeginCurve(GLUnurbs *r)
{
    r->bgncurve(0); 
}

void gluEndCurve(GLUnurbs *r)
{
    r->endcurve(); 
}

void gluEndSurface(GLUnurbs *r)
{
    r->endsurface(); 
}

void gluBeginTrim(GLUnurbs *r)
{
    r->bgntrim(); 
}

void gluEndTrim(GLUnurbs *r)
{
    r->endtrim(); 
}

void gluPwlCurve(GLUnurbs *r, GLint count, INREAL array[], 
		GLint stride, GLenum type)
{
    GLenum realType;

    switch(type) {
      case GLU_MAP1_TRIM_2:
	realType = N_P2D;
	break;
      case GLU_MAP1_TRIM_3:
	realType = N_P2DR;
	break;
      default:
	realType = type;
	break;
    }
    r->pwlcurve(count, array, sizeof(INREAL) * stride, realType);
}

void gluNurbsCurve(GLUnurbs *r, GLint nknots, INREAL knot[], GLint stride, 
		  INREAL ctlarray[], GLint order, GLenum type)
{
    GLenum realType;

    switch(type) {
      case GLU_MAP1_TRIM_2:
	realType = N_P2D;
	break;
      case GLU_MAP1_TRIM_3:
	realType = N_P2DR;
	break;
      default:
	realType = type;
	break;
    }
    r->nurbscurve(nknots, knot, sizeof(INREAL) * stride, ctlarray, order, 
	    realType);
}

void gluNurbsSurface(GLUnurbs *r, GLint sknot_count, GLfloat *sknot, 
			    GLint tknot_count, GLfloat *tknot, 
			    GLint s_stride, GLint t_stride, 
			    GLfloat *ctlarray, GLint sorder, GLint torder, 
			    GLenum type)
{
    r->nurbssurface(sknot_count, sknot, tknot_count, tknot, 
	    sizeof(INREAL) * s_stride, sizeof(INREAL) * t_stride, 
	    ctlarray, sorder, torder, type);
}

void gluLoadSamplingMatrices(GLUnurbs *r, const GLfloat modelMatrix[16],
			    const GLfloat projMatrix[16], 
			    const GLint viewport[4])
{
#ifdef NT
    r->useGLMatrices((float (*)[4])modelMatrix, (float (*)[4])projMatrix, viewport);
#else
    r->useGLMatrices(modelMatrix, projMatrix, viewport);
#endif
}

void gluNurbsProperty(GLUnurbs *r, GLenum property, GLfloat value)
{
    GLfloat nurbsValue;
    
    switch (property) {
      case GLU_AUTO_LOAD_MATRIX:
	r->setautoloadmode(value);
	return;
      case GLU_CULLING:
	if (value != 0.0) {
	    nurbsValue = N_CULLINGON;
	} else {
	    nurbsValue = N_NOCULLING;
	}
	r->setnurbsproperty(GL_MAP2_VERTEX_3, N_CULLING, nurbsValue);
	r->setnurbsproperty(GL_MAP2_VERTEX_4, N_CULLING, nurbsValue);
	r->setnurbsproperty(GL_MAP1_VERTEX_3, N_CULLING, nurbsValue);
	r->setnurbsproperty(GL_MAP1_VERTEX_4, N_CULLING, nurbsValue);
        return;

      case GLU_SAMPLING_METHOD:
	if (value == GLU_PATH_LENGTH) {
	    nurbsValue = N_PATHLENGTH;
	} else if (value == GLU_PARAMETRIC_ERROR) {
	    nurbsValue = N_PARAMETRICDISTANCE;
	} else if (value == GLU_DOMAIN_DISTANCE) {
	    nurbsValue = N_DOMAINDISTANCE;
	} else {
            r->postError(GLU_INVALID_VALUE);
            return;
        }

	r->setnurbsproperty(GL_MAP2_VERTEX_3, N_SAMPLINGMETHOD, nurbsValue);
	r->setnurbsproperty(GL_MAP2_VERTEX_4, N_SAMPLINGMETHOD, nurbsValue);
	r->setnurbsproperty(GL_MAP1_VERTEX_3, N_SAMPLINGMETHOD, nurbsValue);
	r->setnurbsproperty(GL_MAP1_VERTEX_4, N_SAMPLINGMETHOD, nurbsValue);
	return;

      case GLU_SAMPLING_TOLERANCE:
	r->setnurbsproperty(GL_MAP2_VERTEX_3, N_PIXEL_TOLERANCE, value);
	r->setnurbsproperty(GL_MAP2_VERTEX_4, N_PIXEL_TOLERANCE, value);
	r->setnurbsproperty(GL_MAP1_VERTEX_3, N_PIXEL_TOLERANCE, value);
	r->setnurbsproperty(GL_MAP1_VERTEX_4, N_PIXEL_TOLERANCE, value);
	return;

      case GLU_PARAMETRIC_TOLERANCE:
	r->setnurbsproperty(GL_MAP2_VERTEX_3, N_ERROR_TOLERANCE, value);
        r->setnurbsproperty(GL_MAP2_VERTEX_4, N_ERROR_TOLERANCE, value);
        r->setnurbsproperty(GL_MAP1_VERTEX_3, N_ERROR_TOLERANCE, value);
        r->setnurbsproperty(GL_MAP1_VERTEX_4, N_ERROR_TOLERANCE, value);
        return;

      case GLU_DISPLAY_MODE:
	if (value == GLU_FILL) {
	    nurbsValue = N_FILL;
	} else if (value == GLU_OUTLINE_POLYGON) {
	    nurbsValue = N_OUTLINE_POLY;
	} else if (value == GLU_OUTLINE_PATCH) {
	    nurbsValue = N_OUTLINE_PATCH;
	} else {
	    r->postError(GLU_INVALID_VALUE);
	    return;
	}
	r->setnurbsproperty(N_DISPLAY, nurbsValue);
	break;

      case GLU_U_STEP:
    	r->setnurbsproperty(GL_MAP1_VERTEX_3, N_S_STEPS, value);
    	r->setnurbsproperty(GL_MAP1_VERTEX_4, N_S_STEPS, value);
    	r->setnurbsproperty(GL_MAP2_VERTEX_3, N_S_STEPS, value);
    	r->setnurbsproperty(GL_MAP2_VERTEX_4, N_S_STEPS, value);
	break;

      case GLU_V_STEP:
        r->setnurbsproperty(GL_MAP1_VERTEX_3, N_T_STEPS, value);
        r->setnurbsproperty(GL_MAP1_VERTEX_4, N_T_STEPS, value);
        r->setnurbsproperty(GL_MAP2_VERTEX_3, N_T_STEPS, value);
        r->setnurbsproperty(GL_MAP2_VERTEX_4, N_T_STEPS, value);
	break;


      default:
	r->postError(GLU_INVALID_ENUM);
	return;
    }
}

void gluGetNurbsProperty(GLUnurbs *r, GLenum property, GLfloat *value)
{
    GLfloat nurbsValue;

    switch(property) {
      case GLU_AUTO_LOAD_MATRIX:
	if (r->getautoloadmode()) {
	    *value = GL_TRUE;
	} else {
	    *value = GL_FALSE;
	}
	break;
      case GLU_CULLING:
	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_CULLING, &nurbsValue);
	if (nurbsValue == N_CULLINGON) {
	    *value = GL_TRUE;
	} else {
	    *value = GL_FALSE;
	}
	break;
      case GLU_SAMPLING_METHOD:
	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_SAMPLINGMETHOD, value);
	break;
      case GLU_SAMPLING_TOLERANCE:
	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_PIXEL_TOLERANCE, value);
	break;
      case GLU_PARAMETRIC_TOLERANCE:
	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_ERROR_TOLERANCE, value);
        break;
      case GLU_U_STEP:
    	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_S_STEPS, value);
	break;
      case GLU_V_STEP:
    	r->getnurbsproperty(GL_MAP2_VERTEX_3, N_T_STEPS, value);
	break;
      case GLU_DISPLAY_MODE:
	r->getnurbsproperty(N_DISPLAY, &nurbsValue);
	if (nurbsValue == N_FILL) {
	    *value = GLU_FILL;
	} else if (nurbsValue == N_OUTLINE_POLY) {
	    *value = GLU_OUTLINE_POLYGON;
	} else {
	    *value = GLU_OUTLINE_PATCH;
	}
	break;
      default:
	r->postError(GLU_INVALID_ENUM);
	return;
    }
}

void gluNurbsCallback(GLUnurbs *r, GLenum which, void (*fn)())
{
    switch (which) {
      case GLU_ERROR:
#ifdef NT
        r->errorCallback = (GLUnurbsErrorProc) fn;
#else
	r->errorCallback = (void (*)( GLenum )) fn;
#endif
	break;
      default:
	r->postError(GLU_INVALID_ENUM);
	return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\clients\glsurfev.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glsurfeval.c++ - surface evaluator
 *
 * $Revision: 1.5 $
 */

/* Polynomial Evaluator Interface */

#include <glos.h>
#include <GL/gl.h>
#include "glimport.h"
#include "glrender.h"
#include "glsurfev.h"
#include "nurbscon.h"

/*#define USE_INTERNAL_EVAL*/ //use internal evaluator

/*whether do evaluation or not*/
/*#define NO_EVALUATION*/

 
/*for statistics*/
/*#define STATISTICS*/
#ifdef STATISTICS
static int STAT_num_of_triangles=0;
static int STAT_num_of_eval_vertices=0;
static int STAT_num_of_quad_strips=0;
#endif 


OpenGLSurfaceEvaluator::OpenGLSurfaceEvaluator() 
{ 
    int i;

    for (i=0; i<VERTEX_CACHE_SIZE; i++) {
	vertexCache[i] = new StoredVertex;
    }
    tmeshing = 0;
    which = 0;
    vcount = 0;


}

OpenGLSurfaceEvaluator::~OpenGLSurfaceEvaluator() 
{ 
   for (int ii= 0; ii< VERTEX_CACHE_SIZE; ii++) {
      delete vertexCache[ii];
      vertexCache[ii]= 0;
   }
}

/*---------------------------------------------------------------------------
 * disable - turn off a map
 *---------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::disable(long type)
{
    glDisable((GLenum) type);
}

/*---------------------------------------------------------------------------
 * enable - turn on a map
 *---------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::enable(long type)
{
    glEnable((GLenum) type);
}

/*-------------------------------------------------------------------------
 * mapgrid2f - define a lattice of points with origin and offset
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::mapgrid2f(long nu, REAL u0, REAL u1, long nv, REAL v0, REAL v1)
{
#ifdef USE_INTERNAL_EVAL
  inMapGrid2f((int) nu, (REAL) u0, (REAL) u1, (int) nv, 
	      (REAL) v0, (REAL) v1);
#else

    glMapGrid2d((GLint) nu, (GLdouble) u0, (GLdouble) u1, (GLint) nv, 
	    (GLdouble) v0, (GLdouble) v1);
#endif
}

void
OpenGLSurfaceEvaluator::polymode(long style)
{
    switch(style) {
    default:
    case N_MESHFILL:

	glPolygonMode((GLenum) GL_FRONT_AND_BACK, (GLenum) GL_FILL);
	break;
    case N_MESHLINE:
	glPolygonMode((GLenum) GL_FRONT_AND_BACK, (GLenum) GL_LINE);
	break;
    case N_MESHPOINT:
	glPolygonMode((GLenum) GL_FRONT_AND_BACK, (GLenum) GL_POINT);
	break;
    }
}

void
OpenGLSurfaceEvaluator::bgnline(void)
{
    glBegin((GLenum) GL_LINE_STRIP);
}

void
OpenGLSurfaceEvaluator::endline(void)
{
    glEnd();
}

void
OpenGLSurfaceEvaluator::range2f(long type, REAL *from, REAL *to)
{
}

void
OpenGLSurfaceEvaluator::domain2f(REAL ulo, REAL uhi, REAL vlo, REAL vhi)
{
}

void
OpenGLSurfaceEvaluator::bgnclosedline(void)
{
    glBegin((GLenum) GL_LINE_LOOP);
}

void
OpenGLSurfaceEvaluator::endclosedline(void)
{
    glEnd();
}





void
OpenGLSurfaceEvaluator::bgntmesh(void)
{

    tmeshing = 1;
    which = 0;
    vcount = 0;

    glBegin((GLenum) GL_TRIANGLES);

}

void
OpenGLSurfaceEvaluator::swaptmesh(void)
{
    which = 1 - which;

}

void
OpenGLSurfaceEvaluator::endtmesh(void)
{
    tmeshing = 0;

    glEnd();
}

void
OpenGLSurfaceEvaluator::bgntfan(void)
{
 glBegin((GLenum) GL_TRIANGLE_FAN);
}
void
OpenGLSurfaceEvaluator::endtfan(void)
{
 glEnd();
}

void
OpenGLSurfaceEvaluator::evalUStrip(int n_upper, REAL v_upper, REAL* upper_val, int n_lower, REAL v_lower, REAL* lower_val)
{
#ifdef USE_INTERNAL_EVAL
  inEvalUStrip(n_upper, v_upper, upper_val,
	n_lower, v_lower, lower_val);
#else
  int i,j,k,l;
  REAL leftMostV[2];

  /*
   *the algorithm works by scanning from left to right.
   *leftMostV: the left most of the remaining verteces (on both upper and lower).
   *           it could an element of upperVerts or lowerVerts.
   *i: upperVerts[i] is the first vertex to the right of leftMostV on upper line   
   *j: lowerVerts[j] is the first vertex to the right of leftMostV on lower line   
   */
  
  /*initialize i,j,and leftMostV
   */
  if(upper_val[0] <= lower_val[0])
    {
      i=1;
      j=0;

      leftMostV[0] = upper_val[0];
      leftMostV[1] = v_upper;
    }
  else
    {
      i=0;
      j=1;

      leftMostV[0] = lower_val[0];
      leftMostV[1] = v_lower;

    }
  
  /*the main loop.
   *the invariance is that: 
   *at the beginning of each loop, the meaning of i,j,and leftMostV are 
   *maintained
   */
  while(1)
    {
      if(i >= n_upper) /*case1: no more in upper*/
        {
          if(j<n_lower-1) /*at least two vertices in lower*/
            {
              bgntfan();
	      coord2f(leftMostV[0], leftMostV[1]);
//	      glNormal3fv(leftMostNormal);
//              glVertex3fv(leftMostXYZ);

              while(j<n_lower){
		coord2f(lower_val[j], v_lower);
//		glNormal3fv(lowerNormal[j]);
//		glVertex3fv(lowerXYZ[j]);
		j++;

              }
              endtfan();
            }
          break; /*exit the main loop*/
        }
      else if(j>= n_lower) /*case2: no more in lower*/
        {
          if(i<n_upper-1) /*at least two vertices in upper*/
            {
              bgntfan();
	      coord2f(leftMostV[0], leftMostV[1]);
//	      glNormal3fv(leftMostNormal);
//	      glVertex3fv(leftMostXYZ);
	      
              for(k=n_upper-1; k>=i; k--) /*reverse order for two-side lighting*/
		{
		  coord2f(upper_val[k], v_upper);
//		  glNormal3fv(upperNormal[k]);
//		  glVertex3fv(upperXYZ[k]);
		}

              endtfan();
            }
          break; /*exit the main loop*/
        }
      else /* case3: neither is empty, plus the leftMostV, there is at least one triangle to output*/
        {
          if(upper_val[i] <= lower_val[j])
            {
	      bgntfan();
	      coord2f(lower_val[j], v_lower);
//	      glNormal3fv(lowerNormal[j]);
//	      glVertex3fv(lowerXYZ[j]);

              /*find the last k>=i such that 
               *upperverts[k][0] <= lowerverts[j][0]
               */
              k=i;

              while(k<n_upper)
                {
                  if(upper_val[k] > lower_val[j])
                    break;
                  k++;

                }
              k--;


              for(l=k; l>=i; l--)/*the reverse is for two-side lighting*/
                {
		  coord2f(upper_val[l], v_upper);
//		  glNormal3fv(upperNormal[l]);
//		  glVertex3fv(upperXYZ[l]);

                }
	      coord2f(leftMostV[0], leftMostV[1]);
//	      glNormal3fv(leftMostNormal);
//	      glVertex3fv(leftMostXYZ);

              endtfan();

              /*update i and leftMostV for next loop
               */
              i = k+1;

	      leftMostV[0] = upper_val[k];
	      leftMostV[1] = v_upper;
//	      leftMostNormal = upperNormal[k];
//	      leftMostXYZ = upperXYZ[k];
            }
          else /*upperVerts[i][0] > lowerVerts[j][0]*/
            {
	      bgntfan();
	      coord2f(upper_val[i], v_upper);
//	      glNormal3fv(upperNormal[i]);
//	      glVertex3fv(upperXYZ[i]);
	
	      coord2f(leftMostV[0], leftMostV[1]);
//              glNormal3fv(leftMostNormal);
//	      glVertex3fv(leftMostXYZ);
	      

              /*find the last k>=j such that
               *lowerverts[k][0] < upperverts[i][0]
               */
              k=j;
              while(k< n_lower)
                {
                  if(lower_val[k] >= upper_val[i])
                    break;
		  coord2f(lower_val[k], v_lower);
//		  glNormal3fv(lowerNormal[k]);
//		  glVertex3fv(lowerXYZ[k]);

                  k++;
                }
              endtfan();

              /*update j and leftMostV for next loop
               */
              j=k;
	      leftMostV[0] = lower_val[j-1];
	      leftMostV[1] = v_lower;

//	      leftMostNormal = lowerNormal[j-1];
//	      leftMostXYZ = lowerXYZ[j-1];
            }     
        }
    }
  //clean up 
//  free(upperXYZ);
//  free(lowerXYZ);
//  free(upperNormal);
//  free(lowerNormal);
#endif

}
  

void
OpenGLSurfaceEvaluator::evalVStrip(int n_left, REAL u_left, REAL* left_val, int n_right, REAL u_right, REAL* right_val)
{
#ifdef USE_INTERNAL_EVAL
	inEvalVStrip(n_left, u_left, left_val,
	n_right, u_right, right_val);
#else
  int i,j,k,l;
  REAL botMostV[2];
  /*
   *the algorithm works by scanning from bot to top.
   *botMostV: the bot most of the remaining verteces (on both left and right).
   *           it could an element of leftVerts or rightVerts.
   *i: leftVerts[i] is the first vertex to the top of botMostV on left line   
   *j: rightVerts[j] is the first vertex to the top of botMostV on rightline
   */
  
  /*initialize i,j,and botMostV
   */
  if(left_val[0] <= right_val[0])
    {
      i=1;
      j=0;

      botMostV[0] = u_left;
      botMostV[1] = left_val[0];
    }
  else
    {
      i=0;
      j=1;

      botMostV[0] = u_right;
      botMostV[1] = right_val[0];
    }

  /*the main loop.
   *the invariance is that: 
   *at the beginning of each loop, the meaning of i,j,and botMostV are 
   *maintained
   */
  while(1)
    {
      if(i >= n_left) /*case1: no more in left*/
        {
          if(j<n_right-1) /*at least two vertices in right*/
            {
              bgntfan();
	      coord2f(botMostV[0], botMostV[1]);
              while(j<n_right){
		coord2f(u_right, right_val[j]);
//		glNormal3fv(rightNormal[j]);
//		glVertex3fv(rightXYZ[j]);
		j++;

              }
              endtfan();
            }
          break; /*exit the main loop*/
        }
      else if(j>= n_right) /*case2: no more in right*/
        {
          if(i<n_left-1) /*at least two vertices in left*/
            {
              bgntfan();
              coord2f(botMostV[0], botMostV[1]);
//	      glNormal3fv(botMostNormal);
//	      glVertex3fv(botMostXYZ);
	      
              for(k=n_left-1; k>=i; k--) /*reverse order for two-side lighting*/
		{
		  coord2f(u_left, left_val[k]);
//		  glNormal3fv(leftNormal[k]);
//		  glVertex3fv(leftXYZ[k]);
		}

              endtfan();
            }
          break; /*exit the main loop*/
        }
      else /* case3: neither is empty, plus the botMostV, there is at least one triangle to output*/
        {
          if(left_val[i] <= right_val[j])
            {
	      bgntfan();
	      coord2f(u_right, right_val[j]);
//	      glNormal3fv(rightNormal[j]);
//	      glVertex3fv(rightXYZ[j]);

              /*find the last k>=i such that 
               *leftverts[k][0] <= rightverts[j][0]
               */
              k=i;

              while(k<n_left)
                {
                  if(left_val[k] > right_val[j])
                    break;
                  k++;

                }
              k--;


              for(l=k; l>=i; l--)/*the reverse is for two-side lighting*/
                {
		  coord2f(u_left, left_val[l]);
//		  glNormal3fv(leftNormal[l]);
//		  glVertex3fv(leftXYZ[l]);

                }
	      coord2f(botMostV[0], botMostV[1]);
//	      glNormal3fv(botMostNormal);
//	      glVertex3fv(botMostXYZ);

              endtfan();

              /*update i and botMostV for next loop
               */
              i = k+1;

	      botMostV[0] = u_left;
	      botMostV[1] = left_val[k];
//	      botMostNormal = leftNormal[k];
//	      botMostXYZ = leftXYZ[k];
            }
          else /*left_val[i] > right_val[j])*/
            {
	      bgntfan();
	      coord2f(u_left, left_val[i]);
//	      glNormal3fv(leftNormal[i]);
//	      glVertex3fv(leftXYZ[i]);
	      
	      coord2f(botMostV[0], botMostV[1]);
//            glNormal3fv(botMostNormal);
//	      glVertex3fv(botMostXYZ);
	      

              /*find the last k>=j such that
               *rightverts[k][0] < leftverts[i][0]
               */
              k=j;
              while(k< n_right)
                {
                  if(right_val[k] >= left_val[i])
                    break;
		  coord2f(u_right, right_val[k]);
//		  glNormal3fv(rightNormal[k]);
//		  glVertex3fv(rightXYZ[k]);

                  k++;
                }
              endtfan();

              /*update j and botMostV for next loop
               */
              j=k;
	      botMostV[0] = u_right;
	      botMostV[1] = right_val[j-1];

//	      botMostNormal = rightNormal[j-1];
//	      botMostXYZ = rightXYZ[j-1];
            }     
        }
    }
  //clean up 
//  free(leftXYZ);
//  free(leftNormal);
//  free(rightXYZ);
//  free(rightNormal);
#endif
}
  

void
OpenGLSurfaceEvaluator::bgnqstrip(void)
{
    glBegin((GLenum) GL_QUAD_STRIP);
#ifdef STATISTICS
	STAT_num_of_quad_strips++;
#endif
}

void
OpenGLSurfaceEvaluator::endqstrip(void)
{
    glEnd();
}

/*-------------------------------------------------------------------------
 * bgnmap2f - preamble to surface definition and evaluations
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::bgnmap2f(long)
{

    glPushAttrib((GLbitfield) GL_EVAL_BIT);

}

/*-------------------------------------------------------------------------
 * endmap2f - postamble to a map
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::endmap2f(void)
{

    glPopAttrib();

#ifdef STATISTICS
    fprintf(stderr, "num_vertices=%i,num_triangles=%i,num_quads_strips=%i\n", STAT_num_of_eval_vertices,STAT_num_of_triangles,STAT_num_of_quad_strips);
#endif

}

/*-------------------------------------------------------------------------
 * map2f - pass a desription of a surface map
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::map2f(
    long _type,
    REAL _ulower,	/* u lower domain coord		*/
    REAL _uupper,	/* u upper domain coord 	*/
    long _ustride,	/* interpoint distance		*/
    long _uorder,	/* parametric order		*/
    REAL _vlower,	/* v lower domain coord		*/
    REAL _vupper, 	/* v upper domain coord		*/
    long _vstride,	/* interpoint distance		*/
    long _vorder,	/* parametric order		*/
    REAL *pts) 	/* control points		*/
{
#ifdef USE_INTERNAL_EVAL
   inMap2f((int) _type, (REAL) _ulower, (REAL) _uupper, 
	    (int) _ustride, (int) _uorder, (REAL) _vlower, 
	    (REAL) _vupper, (int) _vstride, (int) _vorder, 
	    (REAL *) pts);
#else
    glMap2f((GLenum) _type, (GLfloat) _ulower, (GLfloat) _uupper, 
	    (GLint) _ustride, (GLint) _uorder, (GLfloat) _vlower, 
	    (GLfloat) _vupper, (GLint) _vstride, (GLint) _vorder, 
	    (const GLfloat *) pts);
#endif
}


/*-------------------------------------------------------------------------
 * mapmesh2f - evaluate a mesh of points on lattice
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::mapmesh2f(long style, long umin, long umax, long vmin, long vmax)
{
#ifdef NO_EVALUATION
	return;
#endif

#ifdef USE_INTERNAL_EVAL
    inEvalMesh2((int)umin, (int)vmin, (int)umax, (int)vmax);
#else
    switch(style) {
    default:
    case N_MESHFILL:

	glEvalMesh2((GLenum) GL_FILL, (GLint) umin, (GLint) umax, 
		(GLint) vmin, (GLint) vmax);
	break;
    case N_MESHLINE:
	glEvalMesh2((GLenum) GL_LINE, (GLint) umin, (GLint) umax, 
		(GLint) vmin, (GLint) vmax);
	break;
    case N_MESHPOINT:
	glEvalMesh2((GLenum) GL_POINT, (GLint) umin, (GLint) umax, 
		(GLint) vmin, (GLint) vmax);
	break;
    }
#endif

#ifdef STATISTICS
	STAT_num_of_quad_strips += (umax-umin)*(vmax-vmin);
#endif
}

/*-------------------------------------------------------------------------
 * evalcoord2f - evaluate a point on a surface
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::evalcoord2f(long, REAL u, REAL v)
{


#ifdef NO_EVALUATION
return;
#endif


    newtmeshvert(u, v);
}

/*-------------------------------------------------------------------------
 * evalpoint2i - evaluate a grid point
 *-------------------------------------------------------------------------
 */
void
OpenGLSurfaceEvaluator::evalpoint2i(long u, long v)
{
#ifdef NO_EVALUATION
return;
#endif

    newtmeshvert(u, v);
}

void
OpenGLSurfaceEvaluator::point2i( long u, long v )
{
#ifdef USE_INTERNAL_EVAL
    inEvalPoint2( (int)u,  (int)v);
#else
    glEvalPoint2((GLint) u, (GLint) v);
#endif

#ifdef STATISTICS
  STAT_num_of_eval_vertices++;
#endif

}

void
OpenGLSurfaceEvaluator::coord2f( REAL u, REAL v )
{
#ifdef USE_INTERNAL_EVAL
    inEvalCoord2f( u, v);
#else
    glEvalCoord2f((GLfloat) u, (GLfloat) v);
#endif


#ifdef STATISTICS
  STAT_num_of_eval_vertices++;
#endif

}

void
OpenGLSurfaceEvaluator::newtmeshvert( long u, long v )
{
    if (tmeshing) {

	if (vcount == 2) {
	    vertexCache[0]->invoke(this);
	    vertexCache[1]->invoke(this);
	    point2i( u,  v);

	} else {
	    vcount++;
	}

	vertexCache[which]->saveEvalPoint(u, v);
	which = 1 - which;
    } else {
	point2i( u,  v);
    }
}

void
OpenGLSurfaceEvaluator::newtmeshvert( REAL u, REAL v )
{

    if (tmeshing) {


	if (vcount == 2) {
	    vertexCache[0]->invoke(this);
	    vertexCache[1]->invoke(this);
            coord2f(u,v);

	} else {
	    vcount++;
	}

	vertexCache[which]->saveEvalCoord(u, v);
	which = 1 - which;
    } else {

	coord2f( u,  v);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\clients\glsurfev.h ===
#ifndef __gluglsurfeval_h_
#define __gluglsurfeval_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glsurfeval.h
 *
 * $Revision: 1.2 $
 */

#ifndef NT
#pragma once
#endif

#include "basicsur.h"

class SurfaceMap;
class OpenGLSurfaceEvaluator;
class StoredVertex;

#define TYPECOORD	1
#define TYPEPOINT	2

/* Cache up to 3 vertices from tmeshes */
#define VERTEX_CACHE_SIZE	3

class StoredVertex {
public:
    		StoredVertex() { type = 0; }
		~StoredVertex(void) {}
    void	saveEvalCoord(REAL x, REAL y) 
		    {coord[0] = x; coord[1] = y; type = TYPECOORD; }
    void	saveEvalPoint(long x, long y)
		    {point[0] = x; point[1] = y; type = TYPEPOINT; }
    void	invoke(OpenGLSurfaceEvaluator *eval);

private:
    int		type;
    REAL	coord[2];
    long	point[2];
};

class OpenGLSurfaceEvaluator : public BasicSurfaceEvaluator {
public:
			OpenGLSurfaceEvaluator();
    			~OpenGLSurfaceEvaluator( void );
    void		polymode( long style );
    void		range2f( long, REAL *, REAL * );
    void		domain2f( REAL, REAL, REAL, REAL );
    void		addMap( SurfaceMap * ) { }

    void		enable( long );
    void		disable( long );
    void		bgnmap2f( long );
    void		map2f( long, REAL, REAL, long, long, 
				     REAL, REAL, long, long, REAL * );
    void		mapgrid2f( long, REAL, REAL, long, REAL, REAL );
    void		mapmesh2f( long, long, long, long, long );
    void		evalcoord2f( long, REAL, REAL );
    void		evalpoint2i( long, long );
    void		endmap2f( void );

    void	 	bgnline( void );
    void	 	endline( void );
    void	 	bgnclosedline( void );
    void	 	endclosedline( void );
    void	 	bgntmesh( void );
    void	 	swaptmesh( void );
    void	 	endtmesh( void );
    void	 	bgnqstrip( void );
    void	 	endqstrip( void );

    void                bgntfan( void );
    void                endtfan( void );
    void                evalUStrip(int n_upper, REAL v_upper, REAL* upper_val,
                                   int n_lower, REAL v_lower, REAL* lower_val);
    void                evalVStrip(int n_left, REAL u_left, REAL* left_val,
                                   int n_right, REAL u_right, REAL* right_val);

    void		coord2f( REAL, REAL );
    void		point2i( long, long );

    void		newtmeshvert( REAL, REAL );
    void		newtmeshvert( long, long );

private:
    StoredVertex	*vertexCache[VERTEX_CACHE_SIZE];
    int			tmeshing;
    int			which;
    int			vcount;
};

inline void StoredVertex::invoke(OpenGLSurfaceEvaluator *eval)
{
    switch(type) {
      case TYPECOORD:
	eval->coord2f(coord[0], coord[1]);
	break;
      case TYPEPOINT:
	eval->point2i(point[0], point[1]);
	break;
      default:
	break;
    }
}

#endif /* __gluglsurfeval_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\clients\glrender.h ===
#ifndef __gluglrenderer_h_
#define __gluglrenderer_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glrenderer.h - $Revision: 1.4 $
 */

#ifndef NT
#pragma once
#endif

#include <GL/gl.h>
#include <GL/glu.h>
#include "nurbstes.h"
#include "glsurfev.h"
#include "glcurvev.h"

class GLUnurbs : public NurbsTessellator {

public:
		GLUnurbs( void );
    void 	loadGLMatrices( void );
#ifdef NT
    void        useGLMatrices( const GLfloat modelMatrix[4][4],
                               const GLfloat projMatrix[4][4],
                               const GLint viewport[4] );
#else
    void        useGLMatrices( const GLfloat modelMatrix[16],
                               const GLfloat projMatrix[16],
                               const GLint viewport[4] );
#endif
    void 	errorHandler( int );
    void	bgnrender( void );
    void	endrender( void );
    void	setautoloadmode( INREAL value )
		    { if (value) autoloadmode = GL_TRUE; 
		      else autoloadmode = GL_FALSE; }
    GLboolean	getautoloadmode( void ) { return autoloadmode; }

#ifdef NT
    GLUnurbsErrorProc           errorCallback;
#else
    void        (*errorCallback)( GLenum );
#endif
    void	postError( GLenum which ) 
		    { if (errorCallback) (*errorCallback)( which ); }

private:
    GLboolean			autoloadmode;
    OpenGLSurfaceEvaluator	surfaceEvaluator;
    OpenGLCurveEvaluator	curveEvaluator;

    void		loadSamplingMatrix( const GLfloat vmat[4][4], 
			        const GLint viewport[4] );
    void		loadCullingMatrix( GLfloat vmat[4][4] );
    static void		grabGLMatrix( GLfloat vmat[4][4] );
    static void		transform4d( GLfloat A[4], GLfloat B[4], 
				GLfloat mat[4][4] );
    static void		multmatrix4d( GLfloat n[4][4], GLfloat left[4][4], 
				GLfloat right[4][4] );

};

#endif /* __gluglrenderer_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\arc.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arc.c++ - $Revision: 1.7 $
 * 	Derrick Burns - 1991
 */


#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "arc.h"
#include "bin.h"
#include "bezierar.h"
#include "pwlarc.h"
#include "simplema.h"

/* local preprocessor definitions */
#define	ZERO		0.00001/*0.000001*/

const int 	Arc::bezier_tag = (1<<13);
const int 	Arc::arc_tag = (1<<3);
const int 	Arc::tail_tag = (1<<6);

/*--------------------------------------------------------------------------
 * makeSide - attach a pwl arc to an arc and mark it as a border arc
 *--------------------------------------------------------------------------
 */

void
Arc::makeSide( PwlArc *pwl, arc_side side )
{
    assert( pwl != 0);
    assert( pwlArc == 0 );
    assert( pwl->npts > 0 );
    assert( pwl->pts != 0);
    pwlArc = pwl;
    clearbezier();
    setside( side );
}
 

/*--------------------------------------------------------------------------
 * numpts - count number of points on arc loop
 *--------------------------------------------------------------------------
 */

int
Arc::numpts( void )
{
    Arc_ptr jarc = this;
    int npts = 0;
    do {
	npts += jarc->pwlArc->npts;
	jarc = jarc->next;
    } while( jarc != this );
    return npts;
}

/*--------------------------------------------------------------------------
 * markverts - mark each point with id of arc
 *--------------------------------------------------------------------------
 */

void
Arc::markverts( void )
{
    Arc_ptr jarc = this;
	
    do {
	TrimVertex *p = jarc->pwlArc->pts;
	for( int i=0; i<jarc->pwlArc->npts; i++ )
	    p[i].nuid = jarc->nuid;
	jarc = jarc->next;
    } while( jarc != this );
}

/*--------------------------------------------------------------------------
 * getextrema - find axis extrema on arc loop
 *--------------------------------------------------------------------------
 */

void
Arc::getextrema( Arc_ptr extrema[4] )
{
    REAL leftpt, botpt, rightpt, toppt;

    extrema[0] = extrema[1] = extrema[2] = extrema[3] = this;

    leftpt = rightpt = this->tail()[0];
    botpt  = toppt   = this->tail()[1];

    for( Arc_ptr jarc = this->next; jarc != this; jarc = jarc->next ) {
	if ( jarc->tail()[0] <  leftpt || 
	    (jarc->tail()[0] <= leftpt && jarc->rhead()[0]<=leftpt))  {
	    leftpt = jarc->pwlArc->pts->param[0];
	    extrema[1] = jarc;
	}
	if ( jarc->tail()[0] >  rightpt || 
	    (jarc->tail()[0] >= rightpt && jarc->rhead()[0] >= rightpt)) {
	    rightpt = jarc->pwlArc->pts->param[0];
	    extrema[3] = jarc;
	}
	if ( jarc->tail()[1] <  botpt || 
            (jarc->tail()[1] <= botpt && jarc->rhead()[1] <= botpt ))  {
	    botpt = jarc->pwlArc->pts->param[1];
	    extrema[2] = jarc;
	}
	if ( jarc->tail()[1] >  toppt || 
	    (jarc->tail()[1] >= toppt && jarc->rhead()[1] >= toppt))  {
	    toppt = jarc->pwlArc->pts->param[1];
	    extrema[0] = jarc;
	}
    }
}


/*-------------------------------------------------------------------------
 * show - print to the stdout the vertices of a pwl arc
 *-------------------------------------------------------------------------
 */

void
Arc::show()
{
#ifndef NDEBUG
    dprintf( "\tPWLARC NP: %d FL: 1\n", pwlArc->npts );
    for( int i = 0; i < pwlArc->npts; i++ ) {
         dprintf( "\t\tVERTEX %f %f\n", pwlArc->pts[i].param[0],
			pwlArc->pts[i].param[1] );
    }
#endif
}

/*-------------------------------------------------------------------------
 * print - print out the vertices of all pwl arcs on a loop
 *-------------------------------------------------------------------------
 */

void
Arc::print( void )
{
    Arc_ptr jarc = this;

    if( ! this ) {
#ifndef NDEBUG
	dprintf( "\n\nEMPTY TRIM\n\n" );
#endif
	return;
    }

#ifndef NDEBUG
    dprintf( "BGNTRIM\n" );
#endif
    do {
	jarc->show( );
	jarc = jarc->next;
    } while (jarc != this);
#ifndef NDEBUG
    dprintf("ENDTRIM\n" );
#endif
}

/*-------------------------------------------------------------------------
 * isDisconnected - check if tail of arc and head of prev meet
 *-------------------------------------------------------------------------
 */

int
Arc::isDisconnected( void )
{
    if( pwlArc == 0 ) return 0;
    if( prev->pwlArc == 0 ) return 0;

    REAL *p0 = tail();
    REAL *p1 = prev->rhead();

    if( ((p0[0] - p1[0]) > ZERO) || ((p1[0] - p0[0]) > ZERO) ||
	((p0[1] - p1[1]) > ZERO) || ((p1[1] - p0[1]) > ZERO)  ) {
#ifndef NDEBUG
	dprintf( "x coord = %f %f %f\n", p0[0], p1[0], p0[0] - p1[0] );
	dprintf( "y coord = %f %f %f\n", p0[1], p1[1], p0[1] - p1[1] );
#endif
	return 1;
    } else {
        /* average two points together */
        p0[0] = p1[0] = (p1[0] + p0[0]) * 0.5;
        p0[1] = p1[1] = (p1[1] + p0[1]) * 0.5;
        return 0;
    }
}

/*-------------------------------------------------------------------------
 * neq_vert - assert that two 2D vertices are not equal
 *-------------------------------------------------------------------------
 */

inline static int
neq_vert( REAL	*v1, REAL *v2 )
{
     return ((v1[0] != v2[0]) || (v1[1] != v2[1] )) ? 1 : 0;
}

/*-------------------------------------------------------------------------
 * check - verify consistency of a loop, including
 *		1) if pwl, no two consecutive vertices are identical
 *		2) the circular link pointers are valid
 *		3) the geometric info at the head and tail are consistent
 *-------------------------------------------------------------------------
 */

int
Arc::check( void )
{
    if( this == 0 ) return 1;
    Arc_ptr jarc = this;
    do {
	assert( (jarc->pwlArc != 0) || (jarc->bezierArc != 0) );

        if (jarc->prev == 0 || jarc->next == 0) {
#ifndef NDEBUG
	    dprintf( "checkjarc:null next/prev pointer\n");
	    jarc->print( );
#endif
	    return 0;
        }

        if (jarc->next->prev != jarc) {
#ifndef NDEBUG
	    dprintf( "checkjarc: pointer linkage screwed up\n");
	    jarc->print( );
#endif
	    return 0;
        }

        if( jarc->pwlArc ) {
#ifndef NDEBUG
	    assert( jarc->pwlArc->npts > 1 );
	    assert( jarc->pwlArc->npts < 100000 );
/*
	    for( int i=0; i < jarc->pwlArc->npts-1; i++ )
		assert( neq_vert( jarc->pwlArc->pts[i].param, 
			     jarc->pwlArc->pts[i+1].param) );
*/
#endif
	    if( jarc->prev->pwlArc ) {
		if( jarc->tail()[1] != jarc->prev->rhead()[1] ) {
#ifndef NDEBUG
		    dprintf( "checkjarc: geometric linkage screwed up 1\n");
		    jarc->prev->show();
		    jarc->show();
#endif
		    return 0;
		}
		if( jarc->tail()[0] != jarc->prev->rhead()[0] ) {
		    
#ifndef NDEBUG
		    dprintf( "checkjarc: geometric linkage screwed up 2\n");
		    jarc->prev->show();
		    jarc->show();
#endif
		    return 0;
		}
	    }
	    if( jarc->next->pwlArc ) {
		if( jarc->next->tail()[0] != jarc->rhead()[0] ) {
#ifndef NDEBUG
			dprintf( "checkjarc: geometric linkage screwed up 3\n");
			jarc->show();
			jarc->next->show();
#endif
			return 0;
		}
		if( jarc->next->tail()[1] != jarc->rhead()[1] ) {
#ifndef NDEBUG
			dprintf( "checkjarc: geometric linkage screwed up 4\n");
			jarc->show();
			jarc->next->show();
#endif
			return 0;
		}
	    }
	    if( jarc->isbezier() ) {
		assert( jarc->pwlArc->npts == 2 );
    		assert( (jarc->pwlArc->pts[0].param[0] == \
	    		jarc->pwlArc->pts[1].param[0]) ||\
    	    		(jarc->pwlArc->pts[0].param[1] == \
	    		jarc->pwlArc->pts[1].param[1]) );
	    }
	}
        jarc = jarc->next;
    } while (jarc != this);
    return 1;
}


#define TOL 0.00001

inline long tooclose( REAL x, REAL y )
{
    return (abs(x-y) < TOL) ?  1 : 0;
}


/*--------------------------------------------------------------------------
 * append - append a jordan arc to a circularly linked list
 *--------------------------------------------------------------------------
 */

Arc_ptr
Arc::append( Arc_ptr jarc )
{
    if( jarc != 0 ) {
	next = jarc->next;
	prev = jarc;
   	next->prev = prev->next = this;
    } else {
        next = prev = this;
    }
    return this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\clients\glrender.cxx ===
#include <glos.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glimport.h"
#include "glrender.h"

GLUnurbs::GLUnurbs(void)
	: NurbsTessellator(curveEvaluator, surfaceEvaluator)
{
    redefineMaps();
    defineMap(GL_MAP2_NORMAL, 0, 3);
    defineMap(GL_MAP1_NORMAL, 0, 3);
    defineMap(GL_MAP2_TEXTURE_COORD_1, 0, 1);
    defineMap(GL_MAP1_TEXTURE_COORD_1, 0, 1);
    defineMap(GL_MAP2_TEXTURE_COORD_2, 0, 2);
    defineMap(GL_MAP1_TEXTURE_COORD_2, 0, 2);
    defineMap(GL_MAP2_TEXTURE_COORD_3, 0, 3);
    defineMap(GL_MAP1_TEXTURE_COORD_3, 0, 3);
    defineMap(GL_MAP2_TEXTURE_COORD_4, 1, 4);
    defineMap(GL_MAP1_TEXTURE_COORD_4, 1, 4);
    defineMap(GL_MAP2_VERTEX_4, 1, 4);
    defineMap(GL_MAP1_VERTEX_4, 1, 4);
    defineMap(GL_MAP2_VERTEX_3, 0, 3);
    defineMap(GL_MAP1_VERTEX_3, 0, 3);
    defineMap(GL_MAP2_COLOR_4, 0, 4);
    defineMap(GL_MAP1_COLOR_4, 0, 4);
    defineMap(GL_MAP2_INDEX, 0, 1);
    defineMap(GL_MAP1_INDEX, 0, 1);

    setnurbsproperty(GL_MAP1_VERTEX_3, N_SAMPLINGMETHOD, (float) N_PATHLENGTH);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_SAMPLINGMETHOD, (float) N_PATHLENGTH);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_SAMPLINGMETHOD, (float) N_PATHLENGTH);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_SAMPLINGMETHOD, (float) N_PATHLENGTH);

    setnurbsproperty(GL_MAP1_VERTEX_3, N_PIXEL_TOLERANCE, (float) 50.0);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_PIXEL_TOLERANCE, (float) 50.0);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_PIXEL_TOLERANCE, (float) 50.0);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_PIXEL_TOLERANCE, (float) 50.0);

    setnurbsproperty(GL_MAP1_VERTEX_3, N_ERROR_TOLERANCE, (float) 0.50);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_ERROR_TOLERANCE, (float) 0.50);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_ERROR_TOLERANCE, (float) 0.50);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_ERROR_TOLERANCE, (float) 0.50);

    setnurbsproperty(GL_MAP1_VERTEX_3, N_S_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_S_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_S_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_S_STEPS, (float) 100.0);

    setnurbsproperty(GL_MAP1_VERTEX_3, N_T_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_T_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_T_STEPS, (float) 100.0);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_T_STEPS, (float) 100.0);

    autoloadmode = 1;
    errorCallback = NULL;
}

void
GLUnurbs::bgnrender(void)
{
    if (autoloadmode) {
	loadGLMatrices();
    }
}

void
GLUnurbs::endrender(void)
{
}

void
GLUnurbs::errorHandler(int i)
{
    GLenum gluError;

    gluError = i + (GLU_NURBS_ERROR1 - 1);
    postError( gluError );
}

void 
GLUnurbs::loadGLMatrices(void) 
{
    GLfloat vmat[4][4];
    GLint viewport[4];

    grabGLMatrix((GLfloat (*)[4]) vmat);
    loadCullingMatrix((GLfloat (*)[4]) vmat);
    ::glGetIntegerv((GLenum) GL_VIEWPORT, (GLint *) viewport);
    loadSamplingMatrix((const GLfloat (*)[4]) vmat, (const GLint *) viewport);
}

#ifdef NT
void
GLUnurbs::useGLMatrices(
                          const GLfloat modelMatrix[4][4],
			  const GLfloat projMatrix[4][4],
			  const GLint viewport[4])
{
    GLfloat vmat[4][4];

    multmatrix4d(vmat, modelMatrix, projMatrix);
    loadCullingMatrix(vmat);
    loadSamplingMatrix(vmat, viewport);
}
#else
void
GLUnurbs::useGLMatrices(const GLfloat modelMatrix[16], 
			  const GLfloat projMatrix[16],
			  const GLint viewport[4])
{
    GLfloat vmat[4][4];

    multmatrix4d((GLfloat (*)[4]) vmat, (GLfloat (*)[4]) modelMatrix, 
	    (GLfloat (*)[4]) projMatrix);
    loadCullingMatrix((GLfloat (*)[4]) vmat);
    loadSamplingMatrix((const GLfloat (*)[4]) vmat, (const GLint *) viewport);
}
#endif

/*--------------------------------------------------------------------------
 * grabGLMatrix  
 *--------------------------------------------------------------------------
 */

void
GLUnurbs::grabGLMatrix(GLfloat vmat[4][4])
{
    GLfloat m1[4][4], m2[4][4];

    ::glGetFloatv((GLenum) GL_MODELVIEW_MATRIX, (GLfloat *) &(m1[0][0]));
    ::glGetFloatv((GLenum) GL_PROJECTION_MATRIX, (GLfloat *) &(m2[0][0]));
    multmatrix4d((GLfloat (*)[4]) vmat, 
	    (GLfloat (*)[4]) m1, (GLfloat (*)[4]) m2);
}

void
GLUnurbs::loadSamplingMatrix(const GLfloat vmat[4][4], 
			       const GLint viewport[4])
{

    /* rescale the mapping to correspond to pixels in x/y */
    REAL xsize = 0.5 * (REAL) (viewport[2]);
    REAL ysize = 0.5 * (REAL) (viewport[3]);
 
    INREAL smat[4][4];
    smat[0][0] = vmat[0][0] * xsize;
    smat[1][0] = vmat[1][0] * xsize;
    smat[2][0] = vmat[2][0] * xsize;
    smat[3][0] = vmat[3][0] * xsize;

    smat[0][1] = vmat[0][1] * ysize;
    smat[1][1] = vmat[1][1] * ysize;
    smat[2][1] = vmat[2][1] * ysize;
    smat[3][1] = vmat[3][1] * ysize;

    smat[0][2] = 0.0;
    smat[1][2] = 0.0;
    smat[2][2] = 0.0;
    smat[3][2] = 0.0;

    smat[0][3] = vmat[0][3];
    smat[1][3] = vmat[1][3];
    smat[2][3] = vmat[2][3];
    smat[3][3] = vmat[3][3];

    const long rstride = sizeof(smat[0]) / sizeof(smat[0][0]);
    const long cstride = 1;

    setnurbsproperty(GL_MAP1_VERTEX_3, N_SAMPLINGMATRIX, &smat[0][0], rstride, 
	    cstride);
    setnurbsproperty(GL_MAP1_VERTEX_4, N_SAMPLINGMATRIX, &smat[0][0], rstride, 
	    cstride);
    setnurbsproperty(GL_MAP2_VERTEX_3, N_SAMPLINGMATRIX, &smat[0][0], rstride, 
	    cstride);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_SAMPLINGMATRIX, &smat[0][0], rstride, 
	    cstride);
}

void
GLUnurbs::loadCullingMatrix(GLfloat vmat[4][4])
{
    INREAL cmat[4][4];

    cmat[0][0] = vmat[0][0];
    cmat[0][1] = vmat[0][1];
    cmat[0][2] = vmat[0][2];
    cmat[0][3] = vmat[0][3];

    cmat[1][0] = vmat[1][0];
    cmat[1][1] = vmat[1][1];
    cmat[1][2] = vmat[1][2];
    cmat[1][3] = vmat[1][3];

    cmat[2][0] = vmat[2][0];
    cmat[2][1] = vmat[2][1];
    cmat[2][2] = vmat[2][2];
    cmat[2][3] = vmat[2][3];

    cmat[3][0] = vmat[3][0];
    cmat[3][1] = vmat[3][1];
    cmat[3][2] = vmat[3][2];
    cmat[3][3] = vmat[3][3];

    const long rstride = sizeof(cmat[0]) / sizeof(cmat[0][0]);
    const long cstride = 1;

    setnurbsproperty(GL_MAP2_VERTEX_3, N_CULLINGMATRIX, &cmat[0][0], rstride, 
	    cstride);
    setnurbsproperty(GL_MAP2_VERTEX_4, N_CULLINGMATRIX, &cmat[0][0], rstride, 
	    cstride);
}

/*---------------------------------------------------------------------
 * A = B * MAT ; transform a 4d vector through a 4x4 matrix
 *---------------------------------------------------------------------
 */
void
GLUnurbs::transform4d(GLfloat A[4], GLfloat B[4], GLfloat mat[4][4])
{

    A[0] = B[0]*mat[0][0] + B[1]*mat[1][0] + B[2]*mat[2][0] + B[3]*mat[3][0];
    A[1] = B[0]*mat[0][1] + B[1]*mat[1][1] + B[2]*mat[2][1] + B[3]*mat[3][1];
    A[2] = B[0]*mat[0][2] + B[1]*mat[1][2] + B[2]*mat[2][2] + B[3]*mat[3][2];
    A[3] = B[0]*mat[0][3] + B[1]*mat[1][3] + B[2]*mat[2][3] + B[3]*mat[3][3];
}

/*---------------------------------------------------------------------
 * new = [left][right] ; multiply two matrices together
 *---------------------------------------------------------------------
 */
void
GLUnurbs::multmatrix4d (GLfloat n[4][4], GLfloat left[4][4], GLfloat right[4][4])
{
    transform4d ((GLfloat *) n[0],(GLfloat *) left[0],(GLfloat (*)[4]) right);
    transform4d ((GLfloat *) n[1],(GLfloat *) left[1],(GLfloat (*)[4]) right);
    transform4d ((GLfloat *) n[2],(GLfloat *) left[2],(GLfloat (*)[4]) right);
    transform4d ((GLfloat *) n[3],(GLfloat *) left[3],(GLfloat (*)[4]) right);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\arc.h ===
#ifndef __gluarc_h_
#define __gluarc_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arc.h - $Revision: 1.1 $
 */

#include "myassert.h"
#include "bufpool.h"
#include "mystdio.h"
#include "types.h"
#include "pwlarc.h"
#include "trimvert.h"

class Bin;
class Arc;
class BezierArc;	
typedef Arc *Arc_ptr;

enum arc_side { arc_none = 0, arc_right, arc_top, arc_left, arc_bottom };

#ifdef NT
class Arc : public PooledObj { /* an arc, in two list, the trim list and bin */
public:
#else
struct Arc : public PooledObj { /* an arc, in two list, the trim list and bin */
#endif

    static const int bezier_tag;
    static const int arc_tag;
    static const int tail_tag;

    Arc_ptr		prev;		/* trim list pointer */
    Arc_ptr		next;		/* trim list pointer */
    Arc_ptr		link;		/* bin pointers */
    BezierArc *		bezierArc;	/* associated bezier arc */
    PwlArc *		pwlArc;	/* associated pwl arc */
    long		type;		/* curve type */
    long		nuid;

    inline		Arc( Arc *, PwlArc * );
    inline		Arc( arc_side, long );

    Arc_ptr		append( Arc_ptr );
    int			check( void );
    int			isMonotone( void );
    int			isDisconnected( void );
    int			numpts( void );
    void		markverts( void );
    void		getextrema( Arc_ptr[4] );
    void		print( void );
    void		show( void );
    void		makeSide( PwlArc *, arc_side );

    inline int		isTessellated() { return pwlArc ? 1 : 0; }
    inline long 	isbezier() 	{ return type & bezier_tag; }
    inline void 	setbezier() 	{ type |= bezier_tag; }
    inline void 	clearbezier() 	{ type &= ~bezier_tag; }
    inline long		npts() 		{ return pwlArc->npts; }
    inline TrimVertex *	pts() 		{ return pwlArc->pts; }
    inline REAL * 	tail() 		{ return pwlArc->pts[0].param; }
    inline REAL * 	head() 		{ return next->pwlArc->pts[0].param; }
    inline REAL *	rhead() 	{ return pwlArc->pts[pwlArc->npts-1].param; }
    inline long		ismarked()	{ return type & arc_tag; }
    inline void		setmark()	{ type |= arc_tag; }
    inline void		clearmark()	{ type &= (~arc_tag); }
    inline void		clearside() 	{ type &= ~(0x7 << 8); }
    inline void		setside( arc_side s ) { clearside(); type |= (((long)s)<<8); }
    inline arc_side	getside() 	{ return (arc_side) ((type>>8) & 0x7); }
    inline int		getitail()	{ return type & tail_tag; }
    inline void		setitail()	{ type |= tail_tag; }
    inline void		clearitail()	{ type &= (~tail_tag); }
};

/*--------------------------------------------------------------------------
 * Arc - initialize a new Arc with the same type and uid of
 *	    a given Arc and a given pwl arc
 *--------------------------------------------------------------------------
 */

inline
Arc::Arc( Arc *j, PwlArc *p )
{
    bezierArc = NULL;
    pwlArc = p;
    type = j->type;
    nuid = j->nuid;
}

/*--------------------------------------------------------------------------
 * Arc - initialize a new Arc with the same type and uid of
 *	    a given Arc and a given pwl arc
 *--------------------------------------------------------------------------
 */

inline
Arc::Arc( arc_side side, long _nuid )
{
    bezierArc = NULL;
    pwlArc = NULL;
    type = 0;
    setside( side );
    nuid = _nuid;
}

#endif /* __gluarc_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\arcsorte.cxx ===
#ifndef __gluarcsorter_c_
#define __gluarcsorter_c_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arcsorter.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "arc.h"
#include "arcsorte.h"
#include "subdivid.h"

ArcSorter::ArcSorter(Subdivider &s) : Sorter( sizeof( Arc ** ) ), subdivider(s)
{
}

int
ArcSorter::qscmp( char *, char * )
{
    dprintf( "ArcSorter::qscmp: pure virtual called\n" );
    return 0;
}

void
ArcSorter::qsort( Arc **a, int n )
{
    Sorter::qsort( (void *) a, n );
}

void		
ArcSorter::qsexc( char *i, char *j )// i<-j, j<-i 
{
    Arc **jarc1 = (Arc **) i;
    Arc **jarc2 = (Arc **) j;
    Arc *tmp = *jarc1;
    *jarc1 = *jarc2;
    *jarc2 = tmp;
}	

void		
ArcSorter::qstexc( char *i, char *j, char *k )// i<-k, k<-j, j<-i
{
    Arc **jarc1 = (Arc **) i;
    Arc **jarc2 = (Arc **) j;
    Arc **jarc3 = (Arc **) k;
    Arc *tmp = *jarc1;
    *jarc1 = *jarc3;
    *jarc3 = *jarc2;
    *jarc2 = tmp;
}
  

ArcSdirSorter::ArcSdirSorter( Subdivider &s ) : ArcSorter(s)
{
}

int
ArcSdirSorter::qscmp( char *i, char *j )
{
    Arc *jarc1 = *(Arc **) i;
    Arc *jarc2 = *(Arc **) j;

    int v1 = (jarc1->getitail() ? 0 : (jarc1->pwlArc->npts - 1));
    int	v2 = (jarc2->getitail() ? 0 : (jarc2->pwlArc->npts - 1));

    REAL diff =  jarc1->pwlArc->pts[v1].param[1] -
	    	 jarc2->pwlArc->pts[v2].param[1];

    if( diff < 0.0)
	return -1;
    else if( diff > 0.0)
	return 1;
    else {
	if( v1 == 0 ) {
	    if( jarc2->tail()[0] < jarc1->tail()[0] ) {
	        return subdivider.ccwTurn_sl( jarc2, jarc1 ) ? 1 : -1;
	    } else {
	        return subdivider.ccwTurn_sr( jarc2, jarc1 ) ? -1 : 1;
	    }
	} else {
	    if( jarc2->head()[0] < jarc1->head()[0] ) {
	        return subdivider.ccwTurn_sl( jarc1, jarc2 ) ? -1 : 1;
	    } else {
	        return subdivider.ccwTurn_sr( jarc1, jarc2 ) ? 1 : -1;
	    }
	}
    }    
}

ArcTdirSorter::ArcTdirSorter( Subdivider &s ) : ArcSorter(s)
{
}

/*----------------------------------------------------------------------------
 * ArcTdirSorter::qscmp - 
  *		   compare two axis monotone arcs that are incident 
 *		   to the line T == compare_value. Determine which of the
 *		   two intersects that line with a LESSER S value.  If
 *		   jarc1 does, return 1.  If jarc2 does, return -1. 
 *----------------------------------------------------------------------------
 */
int
ArcTdirSorter::qscmp( char *i, char *j )
{
    Arc *jarc1 = *(Arc **) i;
    Arc *jarc2 = *(Arc **) j;

    int v1 = (jarc1->getitail() ? 0 : (jarc1->pwlArc->npts - 1));
    int	v2 = (jarc2->getitail() ? 0 : (jarc2->pwlArc->npts - 1));

    REAL diff =  jarc1->pwlArc->pts[v1].param[0] -
	         jarc2->pwlArc->pts[v2].param[0];
 
    if( diff < 0.0)
	return 1;
    else if( diff > 0.0)
	return -1;
    else {
	if( v1 == 0 ) {
	    if (jarc2->tail()[1] < jarc1->tail()[1]) {
	        return subdivider.ccwTurn_tl( jarc2, jarc1 ) ? 1 : -1;
	    } else {
	        return subdivider.ccwTurn_tr( jarc2, jarc1 ) ? -1 : 1;
	    }
	} else {
	    if( jarc2->head()[1] < jarc1->head()[1] )  {
	        return subdivider.ccwTurn_tl( jarc1, jarc2 ) ? -1 : 1;
	    } else {
	        return subdivider.ccwTurn_tr( jarc1, jarc2 ) ? 1 : -1;
	    }
	}
    }
}



#endif /* __gluarcsorter_c_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\arcsorte.h ===
#ifndef __gluarcsorter_h_
#define __gluarcsorter_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arcsorter.h - $Revision: 1.1 $
 */

#include "sorter.h"
#include "arcsorte.h"

class Arc;
class Subdivider;

class ArcSorter : private Sorter {
public:
			ArcSorter(Subdivider &);
    void		qsort( Arc **a, int n );
protected:
    virtual int		qscmp( char *, char * );
    Subdivider&		subdivider;
private:
    void		qsexc( char *i, char *j );	// i<-j, j<-i 
    void		qstexc( char *i, char *j, char *k ); // i<-k, k<-j, j<-i 
};


class ArcSdirSorter : public ArcSorter {
public:
			ArcSdirSorter( Subdivider & );
private:
    int			qscmp( char *, char * );
};


class ArcTdirSorter : public ArcSorter {
public:
			ArcTdirSorter( Subdivider & );
private:
    int			qscmp( char *, char * );
};

#endif /* __gluarcsorter_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\backend.h ===
#ifndef __glubackend_h_
#define __glubackend_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * backend.h - $Revision: 1.2 $
 */

#include "trimvert.h"
#include "gridvert.h"
#include "gridtrim.h"

class BasicCurveEvaluator;
class BasicSurfaceEvaluator;

class Backend {
private:
    BasicCurveEvaluator&	curveEvaluator;
    BasicSurfaceEvaluator&	surfaceEvaluator;
public:
  			Backend( BasicCurveEvaluator &c, BasicSurfaceEvaluator& e )
			: curveEvaluator(c), surfaceEvaluator(e) {}

    /* surface backend routines */
    void		bgnsurf( int, int, long  );
    void		patch( REAL, REAL, REAL, REAL );
    void		surfpts( long, REAL *, long, long, int, int,
          			 REAL, REAL, REAL, REAL );
    void		surfbbox( long, REAL *, REAL * );
    void		surfgrid( REAL, REAL, long, REAL, REAL, long ); 
    void		surfmesh( long, long, long, long ); 
    void		bgntmesh( char * );
    void		endtmesh( void );
    void		swaptmesh( void );
    void		tmeshvert( GridTrimVertex * );
    void		tmeshvert( TrimVertex * );
    void		tmeshvert( GridVertex * );
    void		linevert( TrimVertex * );
    void		linevert( GridVertex * );
    void		bgnoutline( void );
    void		endoutline( void );
    void		endsurf( void );
    void		triangle( TrimVertex*, TrimVertex*, TrimVertex* );

    void                bgntfan();
    void                endtfan();
    void                bgnqstrip();
    void                endqstrip();
    void                evalUStrip(int n_upper, REAL v_upper, REAL* upper_val, 
				   int n_lower, REAL v_lower, REAL* lower_val
				   );
    void                evalVStrip(int n_left, REAL u_left, REAL* left_val, 
				   int n_right, REAL v_right, REAL* right_val
				   );
    void                tmeshvertNOGE(TrimVertex *t);
    void                tmeshvertNOGE_BU(TrimVertex *t);
    void                tmeshvertNOGE_BV(TrimVertex *t);
    void                preEvaluateBU(REAL u);
    void                preEvaluateBV(REAL v);
	

    /* curve backend routines */
    void		bgncurv( void );
    void		segment( REAL, REAL );
    void		curvpts( long, REAL *, long, int, REAL, REAL );
    void		curvgrid( REAL, REAL, long );
    void		curvmesh( long, long );
    void		curvpt( REAL  );  
    void		bgnline( void );
    void		endline( void );
    void		endcurv( void );
private:
#ifndef NOWIREFRAME
    int			wireframetris;
    int			wireframequads;
    int			npts;
    REAL		mesh[3][4];
    int			meshindex;
#endif
};

#endif /* __glubackend_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\basiccrv.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * basiccrveval.c++ - $Revision: 1.1 $
 *	Derrick Burns - 1992
 */

#include "mystdio.h"
#include "types.h"
#include "basiccrv.h"

void 
BasicCurveEvaluator::domain1f( REAL, REAL )
{
#ifndef NDEBUG
    dprintf( "domain1f\n" );
#endif
}

void 
BasicCurveEvaluator::range1f( long type, REAL *, REAL * )
{
#ifndef NDEBUG
    dprintf( "range1f\n" );
#endif
}

void 
BasicCurveEvaluator::enable( long )
{
#ifndef NDEBUG
    dprintf( "enable\n" );
#endif
}

void 
BasicCurveEvaluator::disable( long )
{
#ifndef NDEBUG
    dprintf( "disable\n" );
#endif
}

void 
BasicCurveEvaluator::bgnmap1f( long )
{
#ifndef NDEBUG
    dprintf( "bgnmap1f\n" );
#endif
}

void 
BasicCurveEvaluator::map1f( long, REAL, REAL, long, long, REAL * )
{
#ifndef NDEBUG
    dprintf( "map1f\n" );
#endif
}

void 
BasicCurveEvaluator::mapgrid1f( long, REAL, REAL )
{
#ifndef NDEBUG
    dprintf( "mapgrid1f\n" );
#endif
}

void 
BasicCurveEvaluator::mapmesh1f( long, long, long )
{
#ifndef NDEBUG
    dprintf( "mapmesh1f\n" );
#endif
}

void 
BasicCurveEvaluator::evalcoord1f( long, REAL )
{
#ifndef NDEBUG
    dprintf( "evalcoord1f\n" );
#endif
}

void 
BasicCurveEvaluator::endmap1f( void )
{
#ifndef NDEBUG
    dprintf( "endmap1f\n" );
#endif
}

void 
BasicCurveEvaluator::bgnline( void )
{
#ifndef NDEBUG
    dprintf( "bgnline\n" );
#endif
}

void 
BasicCurveEvaluator::endline( void )
{
#ifndef NDEBUG
    dprintf( "endline\n" );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\basiccrv.h ===
#ifndef __glubasiccrveval_h_
#define __glubasiccrveval_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * basiccurveeval.h - $Revision: 1.1 $
 */

#include "types.h"
#include "displaym.h"
#include "cachinge.h"

class BasicCurveEvaluator : public CachingEvaluator {
public:
    virtual void	domain1f( REAL, REAL );
    virtual void	range1f( long, REAL *, REAL * );

    virtual void	enable( long );
    virtual void	disable( long );
    virtual void	bgnmap1f( long );
    virtual void	map1f( long, REAL, REAL, long, long, REAL * );
    virtual void	mapgrid1f( long, REAL, REAL );
    virtual void	mapmesh1f( long, long, long );
    virtual void	evalcoord1f( long, REAL );
    virtual void	endmap1f( void );

    virtual void	bgnline( void );
    virtual void	endline( void );
};

#endif /* __glubasiccrveval_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\arctess.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arctessellator.c++ - $Revision: 1.6 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "arctess.h"
#include "bufpool.h"
#include "simplema.h"
#include "bezierar.h"
#include "trimvert.h"
#include "trimpool.h"

#define NOELIMINATION

#define steps_function(large, small, rate) (max(1, 1+ (int) ((large-small)/rate)));

/*-----------------------------------------------------------------------------
 * ArcTessellator - construct an ArcTessellator
 *-----------------------------------------------------------------------------
 */

ArcTessellator::ArcTessellator( TrimVertexPool& t, Pool& p ) 
	: trimvertexpool(t), pwlarcpool(p)
{
}

/*-----------------------------------------------------------------------------
 * ~ArcTessellator - destroy an ArcTessellator
 *-----------------------------------------------------------------------------
 */

ArcTessellator::~ArcTessellator( void )
{
}

/*-----------------------------------------------------------------------------
 * bezier - construct a bezier arc and attach it to an Arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::bezier( Arc *arc, REAL s1, REAL s2, REAL t1, REAL t2 )
{
    assert( arc != 0 );
    assert( ! arc->isTessellated() );

#ifndef NDEBUG
    switch( arc->getside() ) {
	case arc_left:
	    assert( s1 == s2 );
	    assert( t2 < t1 );
	    break;
	case arc_right:
	    assert( s1 == s2 );
	    assert( t1 < t2 );
	    break;
	case arc_top:
	    assert( t1 == t2 );
	    assert( s2 < s1 );
	    break;
	case arc_bottom:
	    assert( t1 == t2 );
	    assert( s1 < s2 );
	    break;
	case arc_none:
	    (void) abort();
	    break;
    }
#endif
    
    TrimVertex *p = trimvertexpool.get(2);
    arc->pwlArc = new(pwlarcpool) PwlArc( 2, p );
    p[0].param[0] = s1;
    p[0].param[1] = t1;
    p[1].param[0] = s2;
    p[1].param[1] = t2;
    assert( (s1 == s2) || (t1 == t2) );
    arc->setbezier();
}


/*-----------------------------------------------------------------------------
 * pwl_left - construct a left boundary pwl arc and attach it to an arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::pwl_left( Arc *arc, REAL s, REAL t1, REAL t2, REAL rate )
{
    assert( t2 < t1 );

/*    if(rate <= 0.06) rate = 0.06;*/
/*    int nsteps = 1 + (int) ((t1 - t2) / rate ); */
    int nsteps = steps_function(t1, t2, rate);


    REAL stepsize = (t1 - t2) / (REAL) nsteps;

    TrimVertex *newvert = trimvertexpool.get( nsteps+1 );
    for( int i = nsteps; i > 0; i-- ) {
	newvert[i].param[0] = s;
	newvert[i].param[1] = t2;
	t2 += stepsize;
    }
    newvert[i].param[0] = s;
    newvert[i].param[1] = t1;

    arc->makeSide( new(pwlarcpool) PwlArc( nsteps+1, newvert ), arc_left );
}

/*-----------------------------------------------------------------------------
 * pwl_right - construct a right boundary pwl arc and attach it to an arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::pwl_right( Arc *arc, REAL s, REAL t1, REAL t2, REAL rate )
{
    assert( t1 < t2 );

/*    if(rate <= 0.06) rate = 0.06;*/

/*    int nsteps = 1 + (int) ((t2 - t1) / rate ); */
    int nsteps = steps_function(t2,t1,rate);
    REAL stepsize = (t2 - t1) / (REAL) nsteps;

    TrimVertex *newvert = trimvertexpool.get( nsteps+1 );
    for( int i = 0; i < nsteps; i++ ) {
	newvert[i].param[0] = s;
	newvert[i].param[1] = t1;
	t1 += stepsize;
    }
    newvert[i].param[0] = s;
    newvert[i].param[1] = t2;

    arc->makeSide( new(pwlarcpool) PwlArc( nsteps+1, newvert ), arc_right );
}


/*-----------------------------------------------------------------------------
 * pwl_top - construct a top boundary pwl arc and attach it to an arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::pwl_top( Arc *arc, REAL t, REAL s1, REAL s2, REAL rate )
{
    assert( s2 < s1 );

/*    if(rate <= 0.06) rate = 0.06;*/

/*    int nsteps = 1 + (int) ((s1 - s2) / rate ); */
    int nsteps = steps_function(s1,s2,rate);
    REAL stepsize = (s1 - s2) / (REAL) nsteps;

    TrimVertex *newvert = trimvertexpool.get( nsteps+1 );
    for( int i = nsteps; i > 0; i-- ) {
	newvert[i].param[0] = s2;
	newvert[i].param[1] = t;
	s2 += stepsize;
    }
    newvert[i].param[0] = s1;
    newvert[i].param[1] = t;

    arc->makeSide( new(pwlarcpool) PwlArc( nsteps+1, newvert ), arc_top );
}

/*-----------------------------------------------------------------------------
 * pwl_bottom - construct a bottom boundary pwl arc and attach it to an arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::pwl_bottom( Arc *arc, REAL t, REAL s1, REAL s2, REAL rate )
{
    assert( s1 < s2 );

/*    if(rate <= 0.06) rate = 0.06;*/

/*    int nsteps = 1 + (int) ((s2 - s1) / rate ); */
    int nsteps = steps_function(s2,s1,rate);
    REAL stepsize = (s2 - s1) / (REAL) nsteps;

    TrimVertex *newvert = trimvertexpool.get( nsteps+1 );
    for( int i = 0; i < nsteps; i++ ) {
	newvert[i].param[0] = s1;
	newvert[i].param[1] = t;
	s1 += stepsize;
    }
    newvert[i].param[0] = s2;
    newvert[i].param[1] = t;

    arc->makeSide( new(pwlarcpool) PwlArc( nsteps+1, newvert ), arc_bottom );
}

/*-----------------------------------------------------------------------------
 * pwl - construct a pwl arc and attach it to an arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::pwl( Arc *arc, REAL s1, REAL s2, REAL t1, REAL t2, REAL rate )
{

/*    if(rate <= 0.06) rate = 0.06;*/

    int snsteps = 1 + (int) (abs(s2 - s1) / rate );
    int tnsteps = 1 + (int) (abs(t2 - t1) / rate );
    int nsteps = max(1,max( snsteps, tnsteps ));

    REAL sstepsize = (s2 - s1) / (REAL) nsteps;
    REAL tstepsize = (t2 - t1) / (REAL) nsteps;
    TrimVertex *newvert = trimvertexpool.get( nsteps+1 );
    for( long i = 0; i < nsteps; i++ ) {
	newvert[i].param[0] = s1;
	newvert[i].param[1] = t1;
	s1 += sstepsize;
	t1 += tstepsize;
    }
    newvert[i].param[0] = s2;
    newvert[i].param[1] = t2;

    /* arc->makeSide( new(pwlarcpool) PwlArc( nsteps+1, newvert ), arc_bottom ); */
    arc->pwlArc = new(pwlarcpool) PwlArc( nsteps+1, newvert );

    arc->clearbezier();
    arc->clearside( );
}


/*-----------------------------------------------------------------------------
 * tessellateLinear - constuct a linear pwl arc and attach it to an Arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::tessellateLinear( Arc *arc, REAL geo_stepsize, REAL arc_stepsize, int isrational )
{
    assert( arc->pwlArc == NULL );
    REAL s1, s2, t1, t2;
    REAL stepsize = geo_stepsize * arc_stepsize;
    BezierArc *b = arc->bezierArc;

    if( isrational ) {
	s1 = b->cpts[0] / b->cpts[2];
	t1 = b->cpts[1] / b->cpts[2];
	s2 = b->cpts[b->stride+0] / b->cpts[b->stride+2];
	t2 = b->cpts[b->stride+1] / b->cpts[b->stride+2];
    } else {
	s1 = b->cpts[0];
	t1 = b->cpts[1];
	s2 = b->cpts[b->stride+0];
	t2 = b->cpts[b->stride+1];
    }
    if( s1 == s2 )
	if( t1 < t2 )
	    pwl_right( arc, s1, t1, t2, stepsize );
	else
	    pwl_left( arc, s1, t1, t2, stepsize );
    else if( t1 == t2 )
	if( s1 < s2 ) 
	    pwl_bottom( arc, t1, s1, s2, stepsize );
	else
	    pwl_top( arc, t1, s1, s2, stepsize );
    else
	pwl( arc, s1, s2, t1, t2, stepsize );
}

/*-----------------------------------------------------------------------------
 * tessellateNonlinear - constuct a nonlinear pwl arc and attach it to an Arc
 *-----------------------------------------------------------------------------
 */

void
ArcTessellator::tessellateNonlinear( Arc *arc, REAL geo_stepsize, REAL arc_stepsize, int isrational )
{
    assert( arc->pwlArc == NULL );

    REAL stepsize	= geo_stepsize * arc_stepsize;

    int	nsteps 		= 1 + (int) (1.0/stepsize);

    TrimVertex *vert	= trimvertexpool.get( nsteps+1 );
    REAL dp 		= 1.0/nsteps;
    BezierArc *bezierArc = arc->bezierArc;

    arc->pwlArc 	= new(pwlarcpool) PwlArc();
    arc->pwlArc->pts 	= vert;

    if( isrational ) {
        REAL pow_u[MAXORDER], pow_v[MAXORDER], pow_w[MAXORDER];
    	trim_power_coeffs( bezierArc, pow_u, 0 );
    	trim_power_coeffs( bezierArc, pow_v, 1 );
        trim_power_coeffs( bezierArc, pow_w, 2 );

	/* compute first point exactly */
        REAL *b = bezierArc->cpts;
	vert->param[0] = b[0]/b[2];
	vert->param[1] = b[1]/b[2];

	/* strength reduction on p = dp * step would introduce error */
	int step;
	int ocanremove = 0;
    	register long order =  bezierArc->order;
	for( step=1, ++vert; step<nsteps; step++, vert++ ) {
	    register REAL p = dp * step;
    	    register REAL u = pow_u[0];
            register REAL v = pow_v[0];
	    register REAL w = pow_w[0];
	    for( register int i = 1; i < order; i++ ) {
	        u = u * p + pow_u[i];
	        v = v * p + pow_v[i];
	        w = w * p + pow_w[i];
            }
            vert->param[0] = u/w;
    	    vert->param[1] = v/w;
#ifndef NOELIMINATION
	    REAL ds = abs(vert[0].param[0] - vert[-1].param[0]);
	    REAL dt = abs(vert[0].param[1] - vert[-1].param[1]);
	    int canremove = (ds<geo_stepsize && dt<geo_stepsize) ? 1 : 0;
	    REAL ods=0.0, odt=0.0;

	    if( ocanremove && canremove ) {
		REAL nds = ds + ods;
		REAL ndt = dt + odt;
		if( nds<geo_stepsize && ndt<geo_stepsize ) {
		    // remove previous point
		    --vert;
		    vert[0].param[0] = vert[1].param[0];
		    vert[0].param[1] = vert[1].param[1];
		    ods = nds;
		    odt = ndt;
		    ocanremove = 1;
		} else {
		    ocanremove = canremove;
		    ods = ds;
		    odt = dt;
		}
	    } else {
		ocanremove = canremove;
		ods = ds;
		odt = dt;
	    }
#endif	
	}

	/* compute last point exactly */
	b += (order - 1) * bezierArc->stride;
	vert->param[0] = b[0]/b[2];
	vert->param[1] = b[1]/b[2];

    } else {
        REAL pow_u[MAXORDER], pow_v[MAXORDER];
	trim_power_coeffs( bezierArc, pow_u, 0 );
	trim_power_coeffs( bezierArc, pow_v, 1 );

	/* compute first point exactly */
        REAL *b = bezierArc->cpts;
	vert->param[0] = b[0];
	vert->param[1] = b[1];

	/* strength reduction on p = dp * step would introduce error */
	int step;
	int ocanremove = 0;
    	register long order =  bezierArc->order;
	for( step=1, ++vert; step<nsteps; step++, vert++ ) {
	    register REAL p = dp * step;
	    register REAL u = pow_u[0];
            register REAL v = pow_v[0];
            for( register int i = 1; i < bezierArc->order; i++ ) {
	        u = u * p + pow_u[i];
	        v = v * p + pow_v[i];
            }
            vert->param[0] = u;
	    vert->param[1] = v;
#ifndef NOELIMINATION
	    REAL ds = abs(vert[0].param[0] - vert[-1].param[0]);
	    REAL dt = abs(vert[0].param[1] - vert[-1].param[1]);
	    int canremove = (ds<geo_stepsize && dt<geo_stepsize) ? 1 : 0;
	    REAL ods=0.0, odt=0.0;

	    if( ocanremove && canremove ) {
		REAL nds = ds + ods;
		REAL ndt = dt + odt;
		if( nds<geo_stepsize && ndt<geo_stepsize ) {
		    // remove previous point
		    --vert;
		    vert[0].param[0] = vert[1].param[0];
		    vert[0].param[1] = vert[1].param[1];
		    ods = nds;
		    odt = ndt;
		    ocanremove = 1;
		} else {
		    ocanremove = canremove;
		    ods = ds;
		    odt = dt;
		}
	    } else {
		ocanremove = canremove;
		ods = ds;
		odt = dt;
	    }
#endif	
	}

	/* compute last point exactly */
	b += (order - 1) * bezierArc->stride;
	vert->param[0] = b[0];
	vert->param[1] = b[1];
    }
    arc->pwlArc->npts = vert - arc->pwlArc->pts + 1;
/*
    for( TrimVertex *vt=pwlArc->pts; vt != vert-1; vt++ ) {
	if( tooclose( vt[0].param[0], vt[1].param[0] ) )
	    vt[1].param[0] = vt[0].param[0];
	if( tooclose( vt[0].param[1], vt[1].param[1] ) )
	    vt[1].param[1] = vt[0].param[1];
    }
*/
}

#ifdef NT
REAL ArcTessellator::gl_Bernstein[][MAXORDER][MAXORDER] = {
#else
const REAL ArcTessellator::gl_Bernstein[][MAXORDER][MAXORDER] = {
#endif
 {
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {-1, 1, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {1, -2, 1, 0, 0, 0, 0, 0 },
  {-2, 2, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {-1, 3, -3, 1, 0, 0, 0, 0 },
  {3, -6, 3, 0, 0, 0, 0, 0 },
  {-3, 3, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {1, -4, 6, -4, 1, 0, 0, 0 },
  {-4, 12, -12, 4, 0, 0, 0, 0 },
  {6, -12, 6, 0, 0, 0, 0, 0 },
  {-4, 4, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {-1, 5, -10, 10, -5, 1, 0, 0 },
  {5, -20, 30, -20, 5, 0, 0, 0 },
  {-10, 30, -30, 10, 0, 0, 0, 0 },
  {10, -20, 10, 0, 0, 0, 0, 0 },
  {-5, 5, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {1, -6, 15, -20, 15, -6, 1, 0 },
  {-6, 30, -60, 60, -30, 6, 0, 0 },
  {15, -60, 90, -60, 15, 0, 0, 0 },
  {-20, 60, -60, 20, 0, 0, 0, 0 },
  {15, -30, 15, 0, 0, 0, 0, 0 },
  {-6, 6, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 },
  {0, 0, 0, 0, 0, 0, 0, 0 }
 },
 {
  {-1, 7, -21, 35, -35, 21, -7, 1 },
  {7, -42, 105, -140, 105, -42, 7, 0 },
  {-21, 105, -210, 210, -105, 21, 0, 0 },
  {35, -140, 210, -140, 35, 0, 0, 0 },
  {-35, 105, -105, 35, 0, 0, 0, 0 },
  {21, -42, 21, 0, 0, 0, 0, 0 },
  {-7, 7, 0, 0, 0, 0, 0, 0 },
  {1, 0, 0, 0, 0, 0, 0, 0 }
 }};


/*-----------------------------------------------------------------------------
 * trim_power_coeffs - compute power basis coefficients from bezier coeffients
 *-----------------------------------------------------------------------------
 */
void
ArcTessellator::trim_power_coeffs( BezierArc *bez_arc, REAL *p, int coord )
{
    register int stride = bez_arc->stride;
    register int order = bez_arc->order;
    register REAL *base = bez_arc->cpts + coord;

#ifdef NT
    REAL (*mat)[MAXORDER][MAXORDER] = &gl_Bernstein[order-1];
    REAL (*lrow)[MAXORDER] = &(*mat)[order];

    REAL (*row)[MAXORDER] = &(*mat)[0];

    for( ; row != lrow; row++ ) {
        register REAL s = (REAL)0.0;
	register REAL *point = base;
        register REAL *mlast = *row + order;
        for( REAL *m = *row; m != mlast; m++, point += stride )
	    s += *(m) * (*point);
	*(p++) = s;
    }
#else
    REAL const (*mat)[MAXORDER][MAXORDER] = &gl_Bernstein[order-1];
    REAL const (*lrow)[MAXORDER] = &(*mat)[order];

    for( REAL const (*row)[MAXORDER] = &(*mat)[0]; row != lrow; row++ ) {
	register REAL s = 0.0;
	register REAL *point = base;
	register REAL const *mlast = *row + order;
	for( REAL const *m = *row; m != mlast; m++, point += stride ) 
	    s += *(m) * (*point);
	*(p++) = s;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\basicsur.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * basicsurfaceevaluator.c++ - $Revision: 1.2 $
  *	Derrick Burns - 1992
 */

#include "mystdio.h"
#include "types.h"
#include "basicsur.h"

void 
BasicSurfaceEvaluator::domain2f( REAL, REAL, REAL, REAL )
{
#ifndef NDEBUG
    dprintf( "domain2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::polymode( long )
{
#ifndef NDEBUG
    dprintf( "polymode\n" );
#endif
}

void
BasicSurfaceEvaluator::range2f( long type, REAL *from, REAL *to )
{
#ifndef NDEBUG
    dprintf( "range2f type %ld, from (%g,%g), to (%g,%g)\n", 
		type, from[0], from[1], to[0], to[1] );
#endif
}

void 
BasicSurfaceEvaluator::enable( long )
{
#ifndef NDEBUG
    dprintf( "enable\n" );
#endif
}

void 
BasicSurfaceEvaluator::disable( long )
{
#ifndef NDEBUG
    dprintf( "disable\n" );
#endif
}

void 
BasicSurfaceEvaluator::bgnmap2f( long )
{
#ifndef NDEBUG
    dprintf( "bgnmap2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::endmap2f( void )
{
#ifndef NDEBUG
    dprintf( "endmap2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::map2f( long, REAL, REAL, long, long, 
				    REAL, REAL, long, long,
			      REAL * )
{
#ifndef NDEBUG
    dprintf( "map2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::mapgrid2f( long, REAL, REAL, long, REAL, REAL )
{
#ifndef NDEBUG
    dprintf( "mapgrid2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::mapmesh2f( long, long, long, long, long )
{
#ifndef NDEBUG
    dprintf( "mapmesh2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::evalcoord2f( long, REAL, REAL )
{
#ifndef NDEBUG
    dprintf( "evalcoord2f\n" );
#endif
}

void 
BasicSurfaceEvaluator::evalpoint2i( long, long )
{
#ifndef NDEBUG
    dprintf( "evalpoint2i\n" );
#endif
}

void 
BasicSurfaceEvaluator::bgnline( void )
{
#ifndef NDEBUG
    dprintf( "bgnline\n" );
#endif
}

void 
BasicSurfaceEvaluator::endline( void )
{
#ifndef NDEBUG
    dprintf( "endline\n" );
#endif
}

void 
BasicSurfaceEvaluator::bgnclosedline( void )
{
#ifndef NDEBUG
    dprintf( "bgnclosedline\n" );
#endif
}

void 
BasicSurfaceEvaluator::endclosedline( void )
{
#ifndef NDEBUG
    dprintf( "endclosedline\n" );
#endif
}

void 
BasicSurfaceEvaluator::bgntfan( void )
{
#ifndef NDEBUG
    dprintf( "bgntfan\n" );
#endif
}

void 
BasicSurfaceEvaluator::endtfan( void )
{
}


void 
BasicSurfaceEvaluator::bgntmesh( void )
{
#ifndef NDEBUG
    dprintf( "bgntmesh\n" );
#endif
}

void 
BasicSurfaceEvaluator::swaptmesh( void )
{
#ifndef NDEBUG
    dprintf( "swaptmesh\n" );
#endif
}

void 
BasicSurfaceEvaluator::endtmesh( void )
{
#ifndef NDEBUG
    dprintf( "endtmesh\n" );
#endif
}

void 
BasicSurfaceEvaluator::bgnqstrip( void )
{
#ifndef NDEBUG
    dprintf( "bgnqstrip\n" );
#endif
}

void 
BasicSurfaceEvaluator::endqstrip( void )
{
#ifndef NDEBUG
    dprintf( "endqstrip\n" );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\arctess.h ===
#ifndef __gluarctess_h_
#define __gluarctess_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * arctess.h - $Revision: 1.1 $
 */

#include "defines.h"
#include "types.h"
#include "arc.h"

class BezierArc;
class Pool;
class TrimVertexPool;

class ArcTessellator {
public:
			ArcTessellator( TrimVertexPool&, Pool& );
			~ArcTessellator( void );
    void		bezier( Arc *, REAL, REAL, REAL, REAL );
    void		pwl( Arc *, REAL, REAL, REAL, REAL, REAL );
    void		pwl_left( Arc *, REAL, REAL, REAL, REAL );
    void		pwl_right( Arc *, REAL, REAL, REAL, REAL );
    void		pwl_top( Arc *, REAL, REAL, REAL, REAL );
    void		pwl_bottom( Arc *, REAL, REAL, REAL, REAL );
    void		tessellateLinear( Arc *, REAL, REAL, int );
    void		tessellateNonlinear( Arc *, REAL, REAL, int );

private:
//mf
#ifdef NT
    static REAL 	gl_Bernstein[][MAXORDER][MAXORDER];
#else
    static const REAL 	gl_Bernstein[][MAXORDER][MAXORDER];
#endif
    Pool&		pwlarcpool;
    TrimVertexPool&	trimvertexpool;
#ifdef NT
    static void		trim_power_coeffs( BezierArc *, REAL *, int );
#else
    static void		trim_power_coeffs( BezierArc *, REAL[MAXORDER], int );
#endif
};

#endif /* __gluarctess_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\backend.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * backend.c++ - $Revision: 1.5 $
 * 	Derrick Burns - 1991
 */

/* Bezier surface backend
	- interprets display mode (wireframe,shaded,...)
*/

#include "glimport.h"
#include "mystdio.h"
#include "backend.h"
#include "basiccrv.h"
#include "basicsur.h"
#include "nurbscon.h"

/*-------------------------------------------------------------------------
 * bgnsurf - preamble to surface definition and evaluations
 *-------------------------------------------------------------------------
 */
void
Backend::bgnsurf( int wiretris, int wirequads, long nuid )
{
#ifndef NOWIREFRAME
    wireframetris = wiretris;
    wireframequads = wirequads;
#endif
    surfaceEvaluator.bgnmap2f( nuid );
}

void
Backend::patch( REAL ulo, REAL uhi, REAL vlo, REAL vhi )
{
    surfaceEvaluator.domain2f( ulo, uhi, vlo, vhi );
}

void
Backend::surfbbox( long type, REAL *from, REAL *to )
{
    surfaceEvaluator.range2f( type, from, to );
}

/*-------------------------------------------------------------------------
 * surfpts - pass a desription of a surface map
 *-------------------------------------------------------------------------
 */
void 
Backend::surfpts(
    long type, 		/* geometry, color, texture, normal	*/
    REAL *pts, 		/* control points			*/
    long ustride,	/* distance to next point in u direction */
    long vstride,	/* distance to next point in v direction */
    int uorder,	/* u parametric order			*/
    int vorder,	/* v parametric order			*/
    REAL ulo,		/* u lower bound			*/
    REAL uhi,		/* u upper bound			*/
    REAL vlo,		/* v lower bound			*/
    REAL vhi )		/* v upper bound			*/
{
    surfaceEvaluator.map2f( type,ulo,uhi,ustride,uorder,vlo,vhi,vstride,vorder,pts );
    surfaceEvaluator.enable( type );
}

/*-------------------------------------------------------------------------
 * surfgrid - define a lattice of points with origin and offset
 *-------------------------------------------------------------------------
 */
void
Backend::surfgrid( REAL u0, REAL u1, long nu, REAL v0, REAL v1, long nv )
{
    surfaceEvaluator.mapgrid2f( nu, u0, u1, nv, v0, v1 );
}

/*-------------------------------------------------------------------------
 * surfmesh - evaluate a mesh of points on lattice
 *-------------------------------------------------------------------------
 */
void
Backend::surfmesh( long u, long v, long n, long m )
{
#ifndef NOWIREFRAME
    if( wireframequads ) {
	long v0,  v1;
	long u0f = u, u1f = u+n;
	long v0f = v, v1f = v+m;
	long parity = (u & 1);

        for( v0 = v0f, v1 = v0f++ ; v0<v1f; v0 = v1, v1++ ) {
	    surfaceEvaluator.bgnline();
	    for( long u = u0f; u<=u1f; u++ ) {
		if( parity ) {
		    surfaceEvaluator.evalpoint2i( u, v0 );
		    surfaceEvaluator.evalpoint2i( u, v1 );
		} else {
		    surfaceEvaluator.evalpoint2i( u, v1 );
		    surfaceEvaluator.evalpoint2i( u, v0 );
		}
		parity = 1 - parity;
	    }
	    surfaceEvaluator.endline();
	}
    } else {
	surfaceEvaluator.mapmesh2f( N_MESHFILL, u, u+n, v, v+m );
    }
#else
    if( wireframequads ) {

	surfaceEvaluator.mapmesh2f( N_MESHLINE, u, u+n, v, v+m );
    } else {

	surfaceEvaluator.mapmesh2f( N_MESHFILL, u, u+n, v, v+m );
    }
#endif
}

/*-------------------------------------------------------------------------
 * endsurf - postamble to surface
 *-------------------------------------------------------------------------
 */
void
Backend::endsurf( void )
{
    surfaceEvaluator.endmap2f();
}

/***************************************/
void
Backend::bgntfan( void )
{
//  surfaceEvaluator.bgntfan();

}

void
Backend::endtfan( void )
{
//   surfaceEvaluator.endtfan();
}

void
Backend::bgnqstrip( void )
{
/*
  if(wireframequads)
    surfaceEvaluator.polymode( N_MESHLINE );
  else
    surfaceEvaluator.polymode( N_MESHFILL );    
*/
   surfaceEvaluator.bgnqstrip();

}

void
Backend::endqstrip( void )
{
   surfaceEvaluator.endqstrip();
}

void
Backend::evalUStrip(int n_upper, REAL v_upper, REAL* upper_val,
                       int n_lower, REAL v_lower, REAL* lower_val
                       )
{
}

void 
Backend::evalVStrip(int n_left, REAL u_left, REAL* left_val, 
		    int n_right, REAL u_right, REAL* right_val
		    )
{
}

/***************************************/
   

/*-------------------------------------------------------------------------
 * bgntmesh - preamble to a triangle mesh
 *-------------------------------------------------------------------------
 */
void
Backend::bgntmesh( char * )		
{
#ifndef NOWIREFRAME

    meshindex = 0;	/* I think these need to be initialized to zero */
    npts = 0;

    if( !wireframetris ) {
        surfaceEvaluator.bgntmesh();
    }
#else

    if( wireframetris ) {
	surfaceEvaluator.polymode( N_MESHLINE );
        surfaceEvaluator.bgntmesh();
    } else {
	surfaceEvaluator.polymode( N_MESHFILL );
        surfaceEvaluator.bgntmesh();
    }
#endif
}

void
Backend::tmeshvert( GridTrimVertex *v )
{
    if( v->isGridVert() ) {
	tmeshvert( v->g );
    } else {
	tmeshvert( v->t );
    }
}

void
Backend::tmeshvertNOGE(TrimVertex *t)
{
#ifdef USE_OPTTT
//	surfaceEvaluator.inDoEvalCoord2NOGE( t->param[0], t->param[1], t->cache_point, t->cache_normal);    
#endif
}

//opt for a line with the same u.
void
Backend::tmeshvertNOGE_BU(TrimVertex *t)
{
#ifdef USE_OPTTT
//	surfaceEvaluator.inDoEvalCoord2NOGE_BU( t->param[0], t->param[1], t->cache_point, t->cache_normal);    
#endif
}

//opt for a line with the same v.
void
Backend::tmeshvertNOGE_BV(TrimVertex *t)
{
#ifdef USE_OPTTT
//	surfaceEvaluator.inDoEvalCoord2NOGE_BV( t->param[0], t->param[1], t->cache_point, t->cache_normal);    
#endif
}

void
Backend::preEvaluateBU(REAL u)
{
//	surfaceEvaluator.inPreEvaluateBU_intfac(u);
}

void 
Backend::preEvaluateBV(REAL v)
{
//	surfaceEvaluator.inPreEvaluateBV_intfac(v);
}


/*-------------------------------------------------------------------------
 * tmeshvert - evaluate a point on a triangle mesh
 *-------------------------------------------------------------------------
 */
void
Backend::tmeshvert( TrimVertex *t )
{

    const long nuid = t->nuid;
    const REAL u = t->param[0];
    const REAL v = t->param[1];

#ifndef NOWIREFRAME
    npts++;
    if( wireframetris ) {
	if( npts >= 3 ) {
	    surfaceEvaluator.bgnclosedline();
	    if( mesh[0][2] == 0 )
		surfaceEvaluator.evalcoord2f( mesh[0][3], mesh[0][0], mesh[0][1] );
	    else
		surfaceEvaluator.evalpoint2i( (long) mesh[0][0], (long) mesh[0][1] );
	    if( mesh[1][2] == 0 )
		surfaceEvaluator.evalcoord2f( mesh[1][3], mesh[1][0], mesh[1][1] );
	    else
		surfaceEvaluator.evalpoint2i( (long) mesh[1][0], (long) mesh[1][1] );
	    surfaceEvaluator.evalcoord2f( nuid, u, v );
	    surfaceEvaluator.endclosedline();
	}
        mesh[meshindex][0] = u;
        mesh[meshindex][1] = v;
	mesh[meshindex][2] = 0;
	mesh[meshindex][3] = nuid;
        meshindex = (meshindex+1) % 2;
    } else {
	surfaceEvaluator.evalcoord2f( nuid, u, v );
    }
#else
    surfaceEvaluator.evalcoord2f( nuid, u, v );
#endif
}

/*-------------------------------------------------------------------------
 * tmeshvert - evaluate a grid point of a triangle mesh
 *-------------------------------------------------------------------------
 */
void
Backend::tmeshvert( GridVertex *g )
{
    const long u = g->gparam[0];
    const long v = g->gparam[1];

#ifndef NOWIREFRAME
    npts++;
    if( wireframetris ) {
	if( npts >= 3 ) {
	    surfaceEvaluator.bgnclosedline();
	    if( mesh[0][2] == 0 )
		surfaceEvaluator.evalcoord2f( (long) mesh[0][3], mesh[0][0], mesh[0][1] );
	    else
		surfaceEvaluator.evalpoint2i( (long) mesh[0][0], (long) mesh[0][1] );
	    if( mesh[1][2] == 0 )
		surfaceEvaluator.evalcoord2f( (long) mesh[1][3], mesh[1][0], mesh[1][1] );
	    else
		surfaceEvaluator.evalpoint2i( (long) mesh[1][0], (long) mesh[1][1] );
	    surfaceEvaluator.evalpoint2i( u, v );
	    surfaceEvaluator.endclosedline();
	}
        mesh[meshindex][0] = u;
        mesh[meshindex][1] = v;
	mesh[meshindex][2] = 1;
        meshindex = (meshindex+1) % 2;
    } else {
        surfaceEvaluator.evalpoint2i( u, v );
    }
#else
    surfaceEvaluator.evalpoint2i( u, v );
#endif
}

/*-------------------------------------------------------------------------
 * swaptmesh - perform a swap of the triangle mesh pointers
 *-------------------------------------------------------------------------
 */
void
Backend::swaptmesh( void )
{
#ifndef NOWIREFRAME
    if( wireframetris ) {
        meshindex = 1 - meshindex;
    } else {
	surfaceEvaluator.swaptmesh();
    }
#else
    surfaceEvaluator.swaptmesh();
#endif
}

/*-------------------------------------------------------------------------
 * endtmesh - postamble to triangle mesh
 *-------------------------------------------------------------------------
 */
void
Backend::endtmesh( void )
{
#ifndef NOWIREFRAME
    if( ! wireframetris )
        surfaceEvaluator.endtmesh();
#else
    surfaceEvaluator.endtmesh();
    surfaceEvaluator.polymode( N_MESHFILL );
#endif
}


/*-------------------------------------------------------------------------
 * bgnoutline - preamble to outlined rendering
 *-------------------------------------------------------------------------
 */
void
Backend::bgnoutline( void )
{
    surfaceEvaluator.bgnline();
}

/*-------------------------------------------------------------------------
 * linevert - evaluate a point on an outlined contour
 *-------------------------------------------------------------------------
 */
void
Backend::linevert( TrimVertex *t )
{
    surfaceEvaluator.evalcoord2f( t->nuid, t->param[0], t->param[1] );
}

/*-------------------------------------------------------------------------
 * linevert - evaluate a grid point of an outlined contour
 *-------------------------------------------------------------------------
 */
void
Backend::linevert( GridVertex *g )
{
    surfaceEvaluator.evalpoint2i( g->gparam[0], g->gparam[1] );
}

/*-------------------------------------------------------------------------
 * endoutline - postamble to outlined rendering
 *-------------------------------------------------------------------------
 */
void
Backend::endoutline( void )
{
    surfaceEvaluator.endline();
}

/*-------------------------------------------------------------------------
 * triangle - output a triangle 
 *-------------------------------------------------------------------------
 */
void
Backend::triangle( TrimVertex *a, TrimVertex *b, TrimVertex *c )
{
    bgntmesh( "spittriangle" );
    tmeshvert( a );
    tmeshvert( b );
    tmeshvert( c );
    endtmesh();
}

void 
Backend::bgncurv( void )
{
    curveEvaluator.bgnmap1f( 0 );
}

void
Backend::segment( REAL ulo, REAL uhi )
{
    curveEvaluator.domain1f( ulo, uhi );
} 

void 
Backend::curvpts( 
    long type,		 	/* geometry, color, texture, normal */
    REAL *pts, 			/* control points */
    long stride, 		/* distance to next point */
    int order,			/* parametric order */
    REAL ulo,			/* lower parametric bound */
    REAL uhi )			/* upper parametric bound */

{
    curveEvaluator.map1f( type, ulo, uhi, stride, order, pts );
    curveEvaluator.enable( type );
}

void 
Backend::curvgrid( REAL u0, REAL u1, long nu )
{
    curveEvaluator.mapgrid1f( nu, u0, u1 );
}

void 
Backend::curvmesh( long from, long n )
{
    curveEvaluator.mapmesh1f( N_MESHFILL, from, from+n );
}

void 
Backend::curvpt(REAL u)
{
    curveEvaluator.evalcoord1f( 0, u );
}

void 
Backend::bgnline( void )		
{
    curveEvaluator.bgnline();
}

void 
Backend::endline( void )
{
    curveEvaluator.endline();
}

void 
Backend::endcurv( void )
{
    curveEvaluator.endmap1f();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\basicsur.h ===
#ifndef __glubasicsurfeval_h_
#define __glubasicsurfeval_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * basicsurfeval.h - $Revision: 1.3 $
 */

#include "types.h"
#include "displaym.h"
#include "cachinge.h"

class BasicSurfaceEvaluator : public CachingEvaluator {
public:
    virtual void	range2f( long, REAL *, REAL * );
    virtual void	domain2f( REAL, REAL, REAL, REAL );

    virtual void	enable( long );
    virtual void	disable( long );
    virtual void	bgnmap2f( long );
    virtual void	map2f( long, REAL, REAL, long, long, 
				     REAL, REAL, long, long, 
				     REAL *  );
    virtual void	mapgrid2f( long, REAL, REAL, long,  REAL, REAL );
    virtual void	mapmesh2f( long, long, long, long, long );
    virtual void	evalcoord2f( long, REAL, REAL );
    virtual void	evalpoint2i( long, long );
    virtual void	endmap2f( void );

    virtual void	polymode( long );
    virtual void 	bgnline( void );
    virtual void 	endline( void );
    virtual void 	bgnclosedline( void );
    virtual void 	endclosedline( void );
    virtual void 	bgntmesh( void );
    virtual void 	swaptmesh( void );
    virtual void 	endtmesh( void );
    virtual void 	bgnqstrip( void );
    virtual void 	endqstrip( void );

    virtual void 	bgntfan( void );
    virtual void 	endtfan( void );

};

#endif /* __glubasicsurfeval_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\bin.h ===
#ifndef __glubin_h_
#define __glubin_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * bin.h - $Revision: 1.2 $
 */

#include "myassert.h"
#include "arc.h"
#include "defines.h"

#ifdef NT
class Bin { /* a linked list of jordan arcs */
#else
struct Bin { /* a linked list of jordan arcs */
#endif
private:
    Arc *		head;		/* first arc on list */
    Arc *		current;	/* current arc on list */
public:
    			Bin();
			~Bin();
    inline Arc *	firstarc( void );
    inline Arc *	nextarc( void );
    inline Arc *	removearc( void );
    inline int		isnonempty( void ) { return (head ? 1 : 0); }
    inline void		addarc( Arc * );
    void 		remove_this_arc( Arc * );
    int			numarcs( void );
    void 		adopt( void );
    void		markall( void );
    void		show( char * );
    void		listBezier( void );
};

/*----------------------------------------------------------------------------
 * Bin::addarc - add an Arc * to head of linked list of Arc *s
 *----------------------------------------------------------------------------
 */

inline void
Bin::addarc( Arc *jarc )
{
   jarc->link = head;
   head = jarc;
}

/*----------------------------------------------------------------------------
 * Bin::removearc - remove first Arc * from bin
 *----------------------------------------------------------------------------
 */

inline Arc *
Bin::removearc( void )
{
    Arc * jarc = head;

    if( jarc ) head = jarc->link;
    return jarc;
}


/*----------------------------------------------------------------------------
 * BinIter::nextarc - return current arc in bin and advance pointer to next arc
 *----------------------------------------------------------------------------
 */

inline Arc *
Bin::nextarc( void )
{
    Arc * jarc = current;

#ifdef DEBUG
    assert( jarc->check() != 0 );
#endif

    if( jarc ) current = jarc->link;
    return jarc;
}

/*----------------------------------------------------------------------------
 * BinIter::firstarc - set current arc to first arc of bin advance to next arc
 *----------------------------------------------------------------------------
 */

inline Arc *
Bin::firstarc( void )
{
    current = head;
    return nextarc( );
}

#endif /* __glubin_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\bezierar.h ===
#ifndef __glubezierarc_h
#define __glubezierarc_h

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * bezierarc.h - $Revision: 1.1 $
 */

#include "myassert.h"

class Mapdesc;

#ifdef NT
class BezierArc : public PooledObj { /* a bezier arc */
public:
#else
struct BezierArc : public PooledObj { /* a bezier arc */
#endif
    REAL *		cpts;		/* control points of arc */
    int			order;		/* order of arc */
    int			stride;		/* REAL distance between points */
    long		type;		/* curve type */
    Mapdesc *		mapdesc;
};

#endif /* __glubezierarc_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\bufpool.h ===
#ifndef __glubufpool_h_
#define __glubufpool_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * bufpool.h - $Revision: 1.3 $
 */

#include "myassert.h"
#include "mystdlib.h"

#define NBLOCKS	32

class Buffer {
	friend class 	Pool;
	Buffer	*	next;		/* next buffer on free list	*/
};

class Pool {
public:
			Pool( int, int, char * );
			~Pool( void );
    inline void*	new_buffer( void );
    inline void		free_buffer( void * );
    void		clear( void );
    
private:
    void		grow( void );

protected:
    Buffer		*freelist;		/* linked list of free buffers */
    char		*blocklist[NBLOCKS];	/* blocks of malloced memory */
    int			nextblock;		/* next free block index */
    char		*curblock;		/* last malloced block */
    int			buffersize;		/* bytes per buffer */
    int			nextsize;		/* size of next block of memory	*/
    int			nextfree;		/* byte offset past next free buffer */
    int			initsize;
    enum Magic { is_allocated = 0xf3a1, is_free = 0xf1a2 };
    char		*name;			/* name of the pool */
    Magic		magic;			/* marker for valid pool */
};

/*-----------------------------------------------------------------------------
 * Pool::free_buffer - return a buffer to a pool
 *-----------------------------------------------------------------------------
 */

inline void
Pool::free_buffer( void *b )
{
    assert( (this != 0) && (magic == is_allocated) );

    /* add buffer to singly connected free list */

    ((Buffer *) b)->next = freelist;
    freelist = (Buffer *) b;
}


/*-----------------------------------------------------------------------------
 * Pool::new_buffer - allocate a buffer from a pool
 *-----------------------------------------------------------------------------
 */

inline void * 
Pool::new_buffer( void )
{
    void *buffer;

    assert( (this != 0) && (magic == is_allocated) );

    /* find free buffer */

    if( freelist ) {
    	buffer = (void *) freelist; 
    	freelist = freelist->next;
    } else {
    	if( ! nextfree )
    	    grow( );
    	nextfree -= buffersize;;
    	buffer = (void *) (curblock + nextfree);
    }
    return buffer;
}
	
class PooledObj {
public:
    inline void *	operator new( size_t, Pool & );
    inline void * 	operator new( size_t, void *);
    inline void * 	operator new( size_t s)
				{ return ::new char[s]; }
    inline void 	operator delete( void * ) { assert( 0 ); }
    inline void		deleteMe( Pool & );
};

inline void *
PooledObj::operator new( size_t, Pool& pool )
{
    return pool.new_buffer();
}

inline void
PooledObj::deleteMe( Pool& pool )
{
    pool.free_buffer( (void *) this );
}

#endif /* __glubufpool_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\bufpool.cxx ===
/**************************************************************************
 *    								  *
 *     	 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *    								  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *    								  *
 **************************************************************************/

/*
 *  bufpool.c++ - $Revision: 1.4 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "bufpool.h"


/*-----------------------------------------------------------------------------
 * Pool - allocate a new pool of buffers
 *-----------------------------------------------------------------------------
 */
Pool::Pool( int _buffersize, int initpoolsize, char *n )
{
    buffersize= (_buffersize < sizeof(Buffer)) ? sizeof(Buffer)	: _buffersize;
    initsize	= initpoolsize * buffersize;
    nextsize	= initsize;
    name	= n;
    magic	= is_allocated;
    nextblock	= 0;
    curblock	= 0;
    freelist	= 0;
    nextfree	= 0;
}

/*-----------------------------------------------------------------------------
 * ~Pool - free a pool of buffers and the pool itself
 *-----------------------------------------------------------------------------
 */

Pool::~Pool( void )
{
    assert( (this != 0) && (magic == is_allocated) );

    while( nextblock ) {
	delete blocklist[--nextblock];
        blocklist[nextblock] = 0;
    }
    magic = is_free;
}


void Pool::grow( void )
{
    assert( (this != 0) && (magic == is_allocated) );
    curblock = new char[nextsize];
    blocklist[nextblock++] = curblock;
    nextfree = nextsize;
    nextsize *= 2;
}

/*-----------------------------------------------------------------------------
 * Pool::clear - free buffers associated with pool but keep pool 
 *-----------------------------------------------------------------------------
 */

void 
Pool::clear( void )
{
    assert( (this != 0) && (magic == is_allocated) );

    while( nextblock ) {
	delete blocklist[--nextblock];
	blocklist[nextblock] = 0;
    }
    curblock	= 0;
    freelist	= 0;
    nextfree	= 0;
    if( nextsize > initsize )
        nextsize /= 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\bin.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * bin.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "bin.h"

/*----------------------------------------------------------------------------
 * Constructor and destructor
 *----------------------------------------------------------------------------
 */
Bin::Bin()
{
    head = NULL;
}

Bin::~Bin()
{
    assert( head == NULL);
}

/*----------------------------------------------------------------------------
 * remove_this_arc - remove given Arc_ptr from bin
 *----------------------------------------------------------------------------
 */

void 
Bin::remove_this_arc( Arc_ptr arc )
{
    for( Arc_ptr *j = &(head); (*j != 0) && (*j != arc); j = &((*j)->link) );

    if( *j != 0 ) {
        if( *j == current )
	    current = (*j)->link;
	*j = (*j)->link;
    }
}

/*----------------------------------------------------------------------------
 * numarcs - count number of arcs in bin
 *----------------------------------------------------------------------------
 */

int
Bin::numarcs()
{
    long count = 0;
    for( Arc_ptr jarc = firstarc(); jarc; jarc = nextarc() )
	count++;
    return count;
}

/*----------------------------------------------------------------------------
 * adopt - place an orphaned arcs into their new parents bin
 *----------------------------------------------------------------------------
 */

void 
Bin::adopt()
{
    markall();

    Arc_ptr orphan;
    while( orphan = removearc() ) {
	for( Arc_ptr parent = orphan->next; parent != orphan; parent = parent->next ) {
	    if (! parent->ismarked() ) {
		orphan->link = parent->link;
		parent->link = orphan;
		orphan->clearmark();
		break;
	    }
	}
    }
}


/*----------------------------------------------------------------------------
 * show - print out descriptions of the arcs in the bin
 *----------------------------------------------------------------------------
 */

void
Bin::show( char *name )
{
#ifndef NDEBUG
    dprintf( "%s\n", name );
    for( Arc_ptr jarc = firstarc(); jarc; jarc = nextarc() )
        jarc->show( );
#endif
}



/*----------------------------------------------------------------------------
 * markall - mark all arcs with an identifying tag
 *----------------------------------------------------------------------------
 */

void 
Bin::markall()
{
    for( Arc_ptr jarc=firstarc(); jarc; jarc=nextarc() )
	jarc->setmark();
}

/*----------------------------------------------------------------------------
 * listBezier - print out all arcs that are untessellated border arcs
 *----------------------------------------------------------------------------
 */

void 
Bin::listBezier( void )
{
    for( Arc_ptr jarc=firstarc(); jarc; jarc=nextarc() ) {
	if( jarc->isbezier( ) ) {
    	    assert( jarc->pwlArc->npts == 2 );	
	    TrimVertex  *pts = jarc->pwlArc->pts;
    	    REAL s1 = pts[0].param[0];
    	    REAL t1 = pts[0].param[1];
    	    REAL s2 = pts[1].param[0];
    	    REAL t2 = pts[1].param[1];
#ifndef NDEBUG
	   dprintf( "arc (%g,%g) (%g,%g)\n", s1, t1, s2, t2 );
#endif
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\cachinge.h ===
#ifndef __glucachingval_h_
#define __glucachingval_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * cachingeval.h - $Revision: 1.1 $
 */

class CachingEvaluator {
public:
    enum ServiceMode 	{ play, record, playAndRecord };
    virtual int		canRecord( void );
    virtual int		canPlayAndRecord( void );
    virtual int		createHandle( int handle );
    virtual void	beginOutput( ServiceMode, int handle );
    virtual void	endOutput( void ); 
    virtual void	discardRecording( int handle );
    virtual void	playRecording( int handle );
};
#endif /* __glucachingval_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\cachinge.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * cachingeval.c++ - $Revision: 1.1 $
 */

#include "cachinge.h"

int
CachingEvaluator::canRecord( void )
{
    return 0;
}

int
CachingEvaluator::canPlayAndRecord( void )
{
    return 0;
}

int
CachingEvaluator::createHandle( int )
{
    return 0;
}

void
CachingEvaluator::beginOutput( ServiceMode, int )
{
}

void
CachingEvaluator::endOutput( void )
{
} 

void
CachingEvaluator::discardRecording( int )
{
}

void
CachingEvaluator::playRecording( int )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\curve.h ===
#ifndef __glucurve_h_
#define __glucurve_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * curve.h - $Revision: 1.1 $
 */

#include "types.h"
#include "defines.h"

class Mapdesc;
class Quilt;


class Curve {
public:
friend class Curvelist;
    			Curve( Quilt *, REAL, REAL, Curve * );
    			Curve( Curve&, REAL, Curve * );
    Curve *		next;
private:
    Mapdesc *		mapdesc;
    int			stride;
    int		        order;
    int			cullval;
    int			needsSampling;
    REAL		cpts[MAXORDER*MAXCOORDS];
    REAL		spts[MAXORDER*MAXCOORDS];
    REAL		stepsize;
    REAL		minstepsize;
    REAL		range[3];

    void		clamp( void );
    void		setstepsize( REAL );
    void		getstepsize( void );
    int			cullCheck( void );
    int			needsSamplingSubdivision( void );
};
#endif /* __glucurve_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\coveandt.h ===
#ifndef __glucoveandtiler_h
#define __glucoveandtiler_h

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * coveandtiler.h - $Revision: 1.1 $
 */

#include "trimregi.h"

class Backend;
class TrimVertex;
class GridVertex;
class GridTrimVertex;

class CoveAndTiler : virtual public TrimRegion {
public:
    			CoveAndTiler( Backend& );
    			~CoveAndTiler( void );
    void 		coveAndTile( void );
private:
    Backend&		backend;
    static const int 	MAXSTRIPSIZE;
    void		tile( long, long, long );
    void		coveLowerLeft( void );
    void		coveLowerRight( void );
    void		coveUpperLeft( void );
    void		coveUpperRight( void );
    void		coveUpperLeftNoGrid( TrimVertex * );
    void		coveUpperRightNoGrid( TrimVertex * );
    void		coveLowerLeftNoGrid( TrimVertex * );
    void		coveLowerRightNoGrid( TrimVertex * );
    void		coveLL( void );
    void		coveLR( void );
    void		coveUL( void );
    void		coveUR( void );
    inline void		output( GridTrimVertex& );
    inline void		output( GridVertex& );
    inline void		output( TrimVertex* );
};

#endif /* __glucoveandtiler_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\curve.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * curve.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "mymath.h"
#include "curve.h"
#include "mapdesc.h"
#include "types.h"
#include "quilt.h"
#include "nurbscon.h"

/*--------------------------------------------------------------------------
 * Curve::Curve - copy curve from quilt and transform control points
 *--------------------------------------------------------------------------
 */

Curve::Curve( Quilt_ptr geo, REAL pta, REAL ptb, Curve *c )
{
    mapdesc = geo->mapdesc;
    next = c;
    needsSampling = mapdesc->isRangeSampling() ? 1 : 0;
    cullval = mapdesc->isCulling() ? CULL_ACCEPT : CULL_TRIVIAL_ACCEPT;
    order = geo->qspec[0].order;
    stride = MAXCOORDS;

    REAL *ps  = geo->cpts; 
    Quiltspec_ptr qs = geo->qspec;
    ps += qs->offset;
    ps += qs->index * qs->order * qs->stride;
    REAL *pend = ps + qs->order * qs->stride;

    if( needsSampling )
	mapdesc->xformSampling( ps, qs->order, qs->stride, spts, stride );
	
    if( cullval == CULL_ACCEPT )
	mapdesc->xformCulling(  ps, qs->order, qs->stride, cpts, stride );

    /* set untrimmed curve range */
    range[0] = qs->breakpoints[qs->index];
    range[1] = qs->breakpoints[qs->index+1];
    range[2] = range[1] - range[0];

    if( range[0] != pta ) {
	Curve lower( *this, pta, 0 );
	lower.next = next;
	*this = lower;
    }
    if( range[1] != ptb ) {
	Curve lower( *this, ptb, 0 );
    }
}

/*--------------------------------------------------------------------------
 * Curve::Curve - subdivide a curve along an isoparametric line
 *--------------------------------------------------------------------------
 */

Curve::Curve( Curve& upper, REAL value, Curve *c )
{
    Curve &lower = *this;

    lower.next = c;
    lower.mapdesc = upper.mapdesc;
    lower.needsSampling = upper.needsSampling;
    lower.order = upper.order;
    lower.stride = upper.stride;
    lower.cullval = upper.cullval;

    REAL d = (value - upper.range[0]) / upper.range[2];

    if( needsSampling )
        mapdesc->subdivide( upper.spts, lower.spts, d, upper.stride, upper.order );

    if( cullval == CULL_ACCEPT ) 
        mapdesc->subdivide( upper.cpts, lower.cpts, d, upper.stride, upper.order );

    lower.range[0] = upper.range[0];
    lower.range[1] = value;
    lower.range[2] = value - upper.range[0];
    upper.range[0] = value;
    upper.range[2] = upper.range[1] - value;
}


/*--------------------------------------------------------------------------
 * Curve::clamp - clamp the sampling rate to a given maximum
 *--------------------------------------------------------------------------
 */

void
Curve::clamp( void )
{
    if( stepsize < minstepsize )
        stepsize = mapdesc->clampfactor * minstepsize;
}

void
Curve::setstepsize( REAL max )
{
    stepsize = ( max >= 1.0 ) ? (range[2] / max) : range[2];
    minstepsize = stepsize;
}

void
Curve::getstepsize( void )
{
    minstepsize= 0;

    if( mapdesc->isConstantSampling() ) {
	// fixed number of samples per patch in each direction
	// maxrate is number of s samples per patch
        setstepsize( mapdesc->maxrate );
    } else if( mapdesc->isDomainSampling() ) {
	// maxrate is number of s samples per unit s length of domain
        setstepsize( mapdesc->maxrate * range[2] );
    } else {
	// upper bound on path length between sample points

	assert( order <= MAXORDER );
    
	/* points have been transformed, therefore they are homogeneous */
        REAL tmp[MAXORDER][MAXCOORDS];
	const int tstride = sizeof(tmp[0]) / sizeof(REAL);
	int val = mapdesc->project( spts, stride, &tmp[0][0], tstride,  order ); 

        if( val == 0 ) {
	    // control points cross infinity, therefore derivatives are undefined
            setstepsize( mapdesc->maxrate );
        } else {
            REAL t = mapdesc->getProperty( N_PIXEL_TOLERANCE );
	    if( mapdesc->isParametricDistanceSampling() ) {
		REAL d = mapdesc->calcPartialVelocity( &tmp[0][0], tstride, order, 2, range[2] );
		stepsize = (d > 0.0) ? ::sqrtf( 8.0 * t / d ) : range[2];
		minstepsize = ( mapdesc->maxrate > 0.0 ) ? (range[2] / mapdesc->maxrate) : 0.0;
	    } else if( mapdesc->isPathLengthSampling() ) {
		// t is upper bound on path (arc) length
		REAL d = mapdesc->calcPartialVelocity( &tmp[0][0], tstride, order, 1, range[2] );
		stepsize = ( d > 0.0 ) ? (t / d) : range[2];
		minstepsize = ( mapdesc->maxrate > 0.0 ) ? (range[2] / mapdesc->maxrate) : 0.0;
	    } else {
		// control points cross infinity, therefore partials are undefined
		setstepsize( mapdesc->maxrate );
	    }
	}
    }
}

int
Curve::needsSamplingSubdivision( void )
{
    return ( stepsize < minstepsize )  ? 1 : 0;
}

int
Curve::cullCheck( void )
{
    if( cullval == CULL_ACCEPT ) 
	cullval = mapdesc->cullCheck( cpts, order, stride );
    return cullval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\coveandt.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * coveandtiler.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "coveandt.h"
#include "gridvert.h"
#include "gridtrim.h"
#include "uarray.h"
#include "backend.h"


const int CoveAndTiler::MAXSTRIPSIZE = 1000;

CoveAndTiler::CoveAndTiler( Backend& b )
            : backend( b )
{ }

CoveAndTiler::~CoveAndTiler( void )
{ }

inline void
CoveAndTiler::output( GridVertex &gv )
{
    backend.tmeshvert( &gv );
}

inline void
CoveAndTiler::output( TrimVertex *tv )
{
    backend.tmeshvert( tv );
}

inline void
CoveAndTiler::output( GridTrimVertex& g )
{
    backend.tmeshvert( &g );
}

void 
CoveAndTiler::coveAndTile( void )
{
    long ustart = (top.ustart >= bot.ustart) ? top.ustart : bot.ustart;
    long uend   = (top.uend <= bot.uend)     ? top.uend   : bot.uend;
    if( ustart <= uend ) {
	tile( bot.vindex, ustart, uend );
	if( top.ustart >= bot.ustart )  
	    coveUpperLeft();
	else 
	    coveLowerLeft();
    
	if( top.uend <= bot.uend )  
	    coveUpperRight();
	else
	    coveLowerRight();
    } else {
	TrimVertex blv, tlv, *bl, *tl;
	GridTrimVertex bllv, tllv;
	TrimVertex *lf = left.first();
	TrimVertex *ll = left.last();
	if( lf->param[0] >= ll->param[0] ) {
	    blv.param[0] = lf->param[0];
	    blv.param[1] = ll->param[1];
	    blv.nuid = 0; // XXX
	    assert( blv.param[1] == bot.vval );
	    bl = &blv;
	    tl = lf;
	    tllv.set( lf );
	    if( ll->param[0] > uarray.uarray[top.ustart-1] ) {
		bllv.set( ll );
		assert( ll->param[0] <= uarray.uarray[bot.ustart] );
	    } else {
		bllv.set( top.ustart-1, bot.vindex );
	    }
	    coveUpperLeftNoGrid( bl );
	} else {
	    tlv.param[0] = ll->param[0];
	    tlv.param[1] = lf->param[1];
	    tlv.nuid = 0; // XXX
	    assert( tlv.param[1] == top.vval );
	    tl = &tlv;
	    bl = ll;
	    bllv.set( ll );
	    if( lf->param[0] > uarray.uarray[bot.ustart-1] ) {
		assert( lf->param[0] <= uarray.uarray[bot.ustart] );
		tllv.set( lf );
	    } else {
		tllv.set( bot.ustart-1, top.vindex );
	    }
 	    coveLowerLeftNoGrid( tl );
	}

	TrimVertex brv, trv, *br, *tr;
	GridTrimVertex brrv, trrv;
	TrimVertex *rf = right.first();
	TrimVertex *rl = right.last();

	if( rf->param[0] <= rl->param[0] ) {
	    brv.param[0] = rf->param[0];
	    brv.param[1] = rl->param[1];
	    brv.nuid = 0; // XXX
	    assert( brv.param[1] == bot.vval );
	    br = &brv;
	    tr = rf;
	    trrv.set( rf );
	    if( rl->param[0] < uarray.uarray[top.uend+1] ) {
		assert( rl->param[0] >= uarray.uarray[top.uend] );
		brrv.set( rl );
	    } else {
		brrv.set( top.uend+1, bot.vindex );
	    }
	    coveUpperRightNoGrid( br );
	} else {
	    trv.param[0] = rl->param[0];
	    trv.param[1] = rf->param[1];
	    trv.nuid = 0; // XXX
	    assert( trv.param[1] == top.vval );
	    tr = &trv;
	    br = rl;
	    brrv.set( rl );
	    if( rf->param[0] < uarray.uarray[bot.uend+1] ) {
	        assert( rf->param[0] >= uarray.uarray[bot.uend] );
		trrv.set( rf );
	    } else {
		trrv.set( bot.uend+1, top.vindex );
	    }
	    coveLowerRightNoGrid( tr );
	}

	backend.bgntmesh( "doit" );
	output(trrv);
	output(tllv);
	output( tr );
	output( tl );
	output( br );
	output( bl );
	output(brrv);
	output(bllv);
	backend.endtmesh();
    }
}

void 
CoveAndTiler::tile( long vindex, long ustart, long uend )
{
    long numsteps = uend - ustart;

    if( numsteps == 0 ) return;

    if( numsteps > MAXSTRIPSIZE ) {
	long umid = ustart + (uend - ustart) / 2;
	tile( vindex, ustart, umid );
	tile( vindex, umid, uend );
    } else {
	backend.surfmesh( ustart, vindex-1, numsteps, 1 );
    }
}

void 
CoveAndTiler::coveUpperRight( void )
{
    GridVertex tgv( top.uend, top.vindex );
    GridVertex gv( top.uend, bot.vindex );

    right.first();
    backend.bgntmesh( "coveUpperRight" );
    output( right.next() );
    output( tgv );
    backend.swaptmesh();
    output( gv );
        coveUR();
    backend.endtmesh();
}

void
CoveAndTiler::coveUpperRightNoGrid( TrimVertex* br )
{
    backend.bgntmesh( "coveUpperRight" );
    output( right.first() ); 
    output( right.next() );
    backend.swaptmesh();
    output( br );
        coveUR();
    backend.endtmesh();
}

void 
CoveAndTiler::coveUR( )
{
    GridVertex gv( top.uend, bot.vindex );
    TrimVertex *vert = right.next();
    if( vert == NULL ) return;

    assert( vert->param[0] >= uarray.uarray[gv.gparam[0]]  );

    if( gv.nextu() >= bot.uend ) {
	for( ; vert; vert = right.next() ) {
	    output( vert );
	    backend.swaptmesh();
	}
    } else while( 1 ) {
        if( vert->param[0] < uarray.uarray[gv.gparam[0]]  ) {
	    output( vert );
	    backend.swaptmesh();
	    vert = right.next();
	    if( vert == NULL ) break;
	} else {
	    backend.swaptmesh();
	    output( gv );
	    if( gv.nextu() == bot.uend ) {
		for( ; vert; vert = right.next() ) {
		    output( vert );
		    backend.swaptmesh();
    		}
		break;
	    }
	}
    }
}

void
CoveAndTiler::coveUpperLeft( void )
{
    GridVertex tgv( top.ustart, top.vindex );
    GridVertex gv( top.ustart, bot.vindex );

    left.first();
    backend.bgntmesh( "coveUpperLeft" );
    output( tgv );
    output( left.next() );
    output( gv );
    backend.swaptmesh();
        coveUL();
    backend.endtmesh();
}

void
CoveAndTiler::coveUpperLeftNoGrid( TrimVertex* bl )
{
    backend.bgntmesh( "coveUpperLeftNoGrid" );
    output( left.first() ); 
    output( left.next() );
    output( bl );
    backend.swaptmesh();
        coveUL();
    backend.endtmesh();
}

void 
CoveAndTiler::coveUL()
{
    GridVertex gv( top.ustart, bot.vindex );
    TrimVertex *vert = left.next();
    if( vert == NULL ) return;
    assert( vert->param[0] <= uarray.uarray[gv.gparam[0]]  );

    if( gv.prevu() <= bot.ustart ) {
	for( ; vert; vert = left.next() ) {
	    backend.swaptmesh();
	    output( vert );
	}
    } else while( 1 ) {
	if( vert->param[0] > uarray.uarray[gv.gparam[0]]  ) {
	    backend.swaptmesh();
	    output( vert );
	    vert = left.next();
	    if( vert == NULL ) break;
	} else {
	    output( gv );
	    backend.swaptmesh();
	    if( gv.prevu() == bot.ustart ) {
		for( ; vert; vert = left.next() ) {
		    backend.swaptmesh();
		    output( vert );
		}
		break;
	    }
	}
    }
}

void 
CoveAndTiler::coveLowerLeft( void )
{
    GridVertex bgv( bot.ustart, bot.vindex );
    GridVertex gv( bot.ustart, top.vindex );

    left.last();
    backend.bgntmesh( "coveLowerLeft" );
    output( left.prev() );
    output( bgv );
    backend.swaptmesh();
    output( gv );
        coveLL();
    backend.endtmesh();
}

void
CoveAndTiler::coveLowerLeftNoGrid( TrimVertex* tl )
{
    backend.bgntmesh( "coveLowerLeft" );
    output( left.last() ); 
    output( left.prev() );
    backend.swaptmesh();
    output( tl );
        coveLL( );
    backend.endtmesh();
}

void 
CoveAndTiler::coveLL()
{
    GridVertex gv( bot.ustart, top.vindex );
    TrimVertex *vert = left.prev();
    if( vert == NULL ) return;
    assert( vert->param[0] <= uarray.uarray[gv.gparam[0]]  );

    if( gv.prevu() <= top.ustart ) {
	for( ; vert; vert = left.prev() ) {
	    output( vert );
	    backend.swaptmesh();
	}
    } else while( 1 ) {
        if( vert->param[0] > uarray.uarray[gv.gparam[0]] ){
	    output( vert );
	    backend.swaptmesh();
	    vert = left.prev();
	    if( vert == NULL ) break;
	} else {
	    backend.swaptmesh();
	    output( gv );
	    if( gv.prevu() == top.ustart ) {
    		for( ; vert; vert = left.prev() ) {
		    output( vert );
		    backend.swaptmesh();
    		}
	        break;
	    }
	}
    }
}

void 
CoveAndTiler::coveLowerRight( void )
{
    GridVertex bgv( bot.uend, bot.vindex );
    GridVertex gv( bot.uend, top.vindex );

    right.last();
    backend.bgntmesh( "coveLowerRight" );	
    output( bgv );
    output( right.prev() );
    output( gv );
    backend.swaptmesh();
        coveLR();
    backend.endtmesh( );
}

void
CoveAndTiler::coveLowerRightNoGrid( TrimVertex* tr )
{
    backend.bgntmesh( "coveLowerRIght" );
    output( right.last() ); 
    output( right.prev() );
    output( tr );
    backend.swaptmesh();
        coveLR();
    backend.endtmesh();
}

void 
CoveAndTiler::coveLR( )
{
    GridVertex gv( bot.uend, top.vindex );
    TrimVertex *vert = right.prev();
    if( vert == NULL ) return;
    assert( vert->param[0] >= uarray.uarray[gv.gparam[0]]  );

    if( gv.nextu() >= top.uend ) {
	for( ; vert; vert = right.prev() ) {
	    backend.swaptmesh();
	    output( vert );
	}
    } else while( 1 ) {
        if( vert->param[0] < uarray.uarray[gv.gparam[0]]  ) {
	    backend.swaptmesh();
	    output( vert );
	    vert = right.prev();
	    if( vert == NULL ) break;
	} else {
	    output( gv );
	    backend.swaptmesh();
	    if( gv.nextu() == top.uend ) {
    		for( ; vert; vert = right.prev() ) {
		    backend.swaptmesh();
		    output( vert );
    		}
	        break;
	    }
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\checker.h ===
#ifndef __gluchecker_h_
#define __gluchecker_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * checker.h - $Revision: 1.1 $
 */

#include "types.h"
#include "bufpool.h"

/* local type definitions */
struct Edge : PooledObj {
			Edge( REAL *, REAL *, char * );
    REAL		v1[3];
    REAL		v2[3];
    char *		name;
    int 		count;
    Edge *		next;
};

class Hashtable {
private:
#define NENTRIES	5997
    Pool 		edgepool;
    int			slot;
    Edge *		curentry;
    Edge *		hashtable[NENTRIES];
public:
			Hashtable( void );
    void		init( void );
    void		clear( void );
    Edge *		find( REAL *, REAL * );
    void		insert( REAL *, REAL *, char * );
    long		hashval( REAL *, REAL * );
    Edge *		firstentry( void );
    Edge *		nextentry( void );
    static inline int	equal( REAL *, REAL * );
};

class Checker {
private:
    Hashtable		hashtable;
    long		graphwin;
    int			initialized;
    
    REAL		ulo, uhi, vlo, vhi;
    REAL    		us, vs, dus, dvs;
    int			npts;
    REAL		cache[3][3];
    int			index;
    char *		curname;
    REAL 		tempa[3], tempb[3];	

    inline void		add_edgei( long, long, long, long );
    void		add_edge( REAL *, REAL * );
    void		add_tri( REAL *, REAL *, REAL * );
    void		dump( Edge * );
    void		reference( Edge * );

public:
    inline void *	operator new( size_t ){ return ::malloc( sizeof( Checker ) ); }
    inline void 	operator delete( void *p ) { if( p ) ::free( p ); }
			Checker( void ) { graphwin = 0; initialized = 0; }
    void		init( void );
    void		graph( void );
    void		range( REAL, REAL, REAL, REAL );
    void		grid( REAL, REAL, REAL, REAL );
    void		add_mesh( long, long, long, long );
    void		bgntmesh( char *);
    void		swaptmesh( void );
    void		s2ftmesh( REAL * );
    void		g2ltmesh( long * );
    void		endtmesh( void );
    void		bgnoutline( char * );
    void		s2foutline( REAL * );
    void		g2loutline( long * );
    void		endoutline( void );
};

#endif /* __gluchecker_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\ccw.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * ccw.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "subdivid.h"
#include "types.h"
#include "arc.h"
#include "trimvert.h"
#include "simplema.h"

inline int 
Subdivider::bbox( TrimVertex *a, TrimVertex *b, TrimVertex *c, int p )
{
    return bbox( a->param[p], b->param[p], c->param[p], 
	         a->param[1-p], b->param[1-p], c->param[1-p] ); 
}

int
Subdivider::ccwTurn_sr( Arc_ptr j1, Arc_ptr j2 ) // dir = 1
{
    register TrimVertex *v1	= &j1->pwlArc->pts[j1->pwlArc->npts-1];
    register TrimVertex *v1last	= &j1->pwlArc->pts[0];
    register TrimVertex *v2	= &j2->pwlArc->pts[0];
    register TrimVertex *v2last	= &j2->pwlArc->pts[j2->pwlArc->npts-1];
    register TrimVertex *v1next	= v1-1;
    register TrimVertex *v2next	= v2+1;
    int sgn;

    assert( v1 != v1last );
    assert( v2 != v2last );

#ifndef NDEBUG
    dprintf( "arc_ccw_turn, p = %d\n", 0 );
#endif

    // the arcs lie on the line (0 == v1->param[0])
    if( v1->param[0] == v1next->param[0] && v2->param[0] == v2next->param[0] )
	return 0;

    if( v2next->param[0] < v2->param[0] || v1next->param[0] < v1->param[0] )
	::mylongjmp( jumpbuffer, 28 );

    if( v1->param[1] < v2->param[1] )
	return 0;
    else if( v1->param[1] > v2->param[1] )
	return 1;

    while( 1 ) {
	if( v1next->param[0] < v2next->param[0] ) {
#ifndef NDEBUG
	    dprintf( "case a\n" );
#endif
	    assert( v1->param[0] <= v1next->param[0] );
	    assert( v2->param[0] <= v1next->param[0] );
	    switch( bbox( v2, v2next, v1next, 1 ) ) {
		case -1:
		    return 0;
		case 0:
		   sgn = ccw( v1next, v2, v2next );
		   if( sgn != -1 ) {
			return sgn;
		   } else {
			dprintf( "decr\n" );
			v1 = v1next--;
			if( v1 == v1last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 1;
	    }
	} else if( v1next->param[0] > v2next->param[0] ) {
#ifndef NDEBUG
	    dprintf( "case b\n" );
#endif
	    assert( v1->param[0] <= v2next->param[0] );
	    assert( v2->param[0] <= v2next->param[0] );
	    switch( bbox( v1, v1next, v2next, 1 ) ) {
		case -1:
		    return 1;
		case 0:
		   sgn = ccw( v1next, v1, v2next );
		   if( sgn != -1 ) { 
			return sgn;
		   } else {
			dprintf( "incr\n" );
			v2 = v2next++;
			if( v2 == v2last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 0;
	    }
	} else {
#ifndef NDEBUG
	    dprintf( "case ab\n" );
#endif
	    if( v1next->param[1] < v2next->param[1] )
		return 0;
	    else if( v1next->param[1] > v2next->param[1] )
		return 1;
	    else {
		dprintf( "incr\n" );
		v2 = v2next++;
		if( v2 == v2last ) {
		    dprintf( "no good results\n" );
		    return 0; // ill-conditioned, guess answer
		}
	    }
	}
    }
}

int
Subdivider::ccwTurn_sl( Arc_ptr j1, Arc_ptr j2 ) // dir = 0
{
    register TrimVertex *v1	= &j1->pwlArc->pts[j1->pwlArc->npts-1];
    register TrimVertex *v1last	= &j1->pwlArc->pts[0];
    register TrimVertex *v2	= &j2->pwlArc->pts[0];
    register TrimVertex *v2last	= &j2->pwlArc->pts[j2->pwlArc->npts-1];
    register TrimVertex *v1next	= v1-1;
    register TrimVertex *v2next	= v2+1;
    int sgn;

    assert( v1 != v1last );
    assert( v2 != v2last );

#ifndef NDEBUG
    dprintf( "arc_ccw_turn, p = %d\n", 0 );
#endif

    // the arcs lie on the line (0 == v1->param[0])
    if( v1->param[0] == v1next->param[0] && v2->param[0] == v2next->param[0] )
	return 0;

    if( v2next->param[0] > v2->param[0] || v1next->param[0] > v1->param[0] ) 
	::mylongjmp( jumpbuffer, 28 );

    if( v1->param[1] < v2->param[1] )
	return 1;
    else if( v1->param[1] > v2->param[1] )
	return 0;

    while( 1 ) {
	if( v1next->param[0] > v2next->param[0] ) {
#ifndef NDEBUG
	    dprintf( "case c\n" );
#endif
	    assert( v1->param[0] >= v1next->param[0] );
	    assert( v2->param[0] >= v1next->param[0] );
	    switch( bbox( v2next, v2, v1next, 1 ) ) {
		case -1:
		    return 1;
		case 0:
		    sgn = ccw( v1next, v2, v2next );
		    if( sgn != -1 ) 
			return sgn;
		    else {
			v1 = v1next--;
			dprintf( "decr\n" );
			if( v1 == v1last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 0;
	    }
	} else if( v1next->param[0] < v2next->param[0] ) {
#ifndef NDEBUG
	    dprintf( "case d\n" );
#endif
	    assert( v1->param[0] >= v2next->param[0] );
	    assert( v2->param[0] >= v2next->param[0] );
	    switch( bbox( v1next, v1, v2next, 1 ) ) {
		case -1:
		    return 0;
		case 0:
		    sgn = ccw( v1next, v1, v2next );
		    if( sgn != -1 ) 
			return sgn;
		    else {
			v2 = v2next++;
			dprintf( "incr\n" );
			if( v2 == v2last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 1;
	    }
	} else {
	    dprintf( "case cd\n" );
	    if( v1next->param[1] < v2next->param[1] )
		return 1;
	    else if( v1next->param[1] > v2next->param[1] )
		return 0;
	    else {
		v2 = v2next++;
		dprintf( "incr\n" );
		if( v2 == v2last ) {
		    dprintf( "no good results\n" );
		    return 0; // ill-conditioned, guess answer
		}
	    }
	}
    }
}

int
Subdivider::ccwTurn_tr( Arc_ptr j1, Arc_ptr j2 ) // dir = 1
{
    register TrimVertex *v1	= &j1->pwlArc->pts[j1->pwlArc->npts-1];
    register TrimVertex *v1last	= &j1->pwlArc->pts[0];
    register TrimVertex *v2	= &j2->pwlArc->pts[0];
    register TrimVertex *v2last	= &j2->pwlArc->pts[j2->pwlArc->npts-1];
    register TrimVertex *v1next	= v1-1;
    register TrimVertex *v2next	= v2+1;
    int sgn;

    assert( v1 != v1last );
    assert( v2 != v2last );

#ifndef NDEBUG
    dprintf( "arc_ccw_turn, p = %d\n", 1 );
#endif

    // the arcs lie on the line (1 == v1->param[1])
    if( v1->param[1] == v1next->param[1] && v2->param[1] == v2next->param[1] )
	return 0;

    if( v2next->param[1] < v2->param[1] || v1next->param[1] < v1->param[1] )
	::mylongjmp( jumpbuffer, 28 );

    if( v1->param[0] < v2->param[0] )
	return 1;
    else if( v1->param[0] > v2->param[0] )
	return 0;

    while( 1 ) {
	if( v1next->param[1] < v2next->param[1] ) {
#ifndef NDEBUG
	    dprintf( "case a\n" );
#endif
	    assert( v1->param[1] <= v1next->param[1] );
	    assert( v2->param[1] <= v1next->param[1] );
	    switch( bbox( v2, v2next, v1next, 0 ) ) {
		case -1:
		    return 1;
		case 0:
		   sgn = ccw( v1next, v2, v2next );
		   if( sgn != -1 ) {
			return sgn;
		   } else {
			dprintf( "decr\n" );
			v1 = v1next--;
			if( v1 == v1last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 0;
	    }
	} else if( v1next->param[1] > v2next->param[1] ) {
#ifndef NDEBUG
	    dprintf( "case b\n" );
#endif
	    assert( v1->param[1] <= v2next->param[1] );
	    assert( v2->param[1] <= v2next->param[1] );
	    switch( bbox( v1, v1next, v2next, 0 ) ) {
		case -1:
		    return 0;
		case 0:
		   sgn = ccw( v1next, v1, v2next );
		   if( sgn != -1 ) { 
			return sgn;
		   } else {
			dprintf( "incr\n" );
			v2 = v2next++;
			if( v2 == v2last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 1;
	    }
	} else {
	    dprintf( "case ab\n" );
	    if( v1next->param[0] < v2next->param[0] )
		return 1;
	    else if( v1next->param[0] > v2next->param[0] )
		return 0;
	    else {
		dprintf( "incr\n" );
		v2 = v2next++;
		if( v2 == v2last ) {
		    dprintf( "no good results\n" );
		    return 0; // ill-conditioned, guess answer
		}
	    }
	}
    }
}

int
Subdivider::ccwTurn_tl( Arc_ptr j1, Arc_ptr j2 )
{
    register TrimVertex *v1	= &j1->pwlArc->pts[j1->pwlArc->npts-1];
    register TrimVertex *v1last	= &j1->pwlArc->pts[0];
    register TrimVertex *v2	= &j2->pwlArc->pts[0];
    register TrimVertex *v2last	= &j2->pwlArc->pts[j2->pwlArc->npts-1];
    register TrimVertex *v1next	= v1-1;
    register TrimVertex *v2next	= v2+1;
    int sgn;

    assert( v1 != v1last );
    assert( v2 != v2last );

#ifndef NDEBUG
    dprintf( "arc_ccw_turn, p = %d\n", 1 );
#endif

    // the arcs lie on the line (1 == v1->param[1])
    if( v1->param[1] == v1next->param[1] && v2->param[1] == v2next->param[1] )
	return 0;

    if( v2next->param[1] > v2->param[1] || v1next->param[1] > v1->param[1] ) 
	::mylongjmp( jumpbuffer, 28 );

    if( v1->param[0] < v2->param[0] )
	return 0;
    else if( v1->param[0] > v2->param[0] )
	return 1;

    while( 1 ) {
	if( v1next->param[1] > v2next->param[1] ) {
#ifndef NDEBUG
	    dprintf( "case c\n" );
#endif
	    assert( v1->param[1] >= v1next->param[1] );
	    assert( v2->param[1] >= v1next->param[1] );
	    switch( bbox( v2next, v2, v1next, 0 ) ) {
		case -1:
		    return 0;
		case 0:
		    sgn = ccw( v1next, v2, v2next );
		    if( sgn != -1 ) 
			return sgn;
		    else {
			v1 = v1next--;
			dprintf( "decr\n" );
			if( v1 == v1last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 1;
	    }
	} else if( v1next->param[1] < v2next->param[1] ) {
#ifndef NDEBUG
	    dprintf( "case d\n" );
	    assert( v1->param[1] >= v2next->param[1] );
	    assert( v2->param[1] >= v2next->param[1] );
#endif
	    switch( bbox( v1next, v1, v2next, 0 ) ) {
		case -1:
		    return 1;
		case 0:
		    sgn = ccw( v1next, v1, v2next );
		    if( sgn != -1 ) 
			return sgn;
		    else {
			v2 = v2next++;
			dprintf( "incr\n" );
			if( v2 == v2last ) {
			    dprintf( "no good results\n" );
			    return 0; // ill-conditioned, guess answer
			}
		    }
		    break;
		case 1:
		    return 0;
	    }
	} else {
	    dprintf( "case cd\n" );
	    if( v1next->param[0] < v2next->param[0] )
		return 0;
	    else if( v1next->param[0] > v2next->param[0] )
		return 1;
	    else {
		v2 = v2next++;
		dprintf( "incr\n" );
		if( v2 == v2last ) {
		    dprintf( "no good results\n" );
		    return 0; // ill-conditioned, guess answer
		}
	    }
	}
    }
}


#ifndef NDEBUG
int
Subdivider::bbox( register REAL sa, register REAL sb, register REAL sc,
      register REAL ta, register REAL tb, register REAL tc )
#else
int
Subdivider::bbox( register REAL sa, register REAL sb, register REAL sc,
      register REAL   , register REAL   , register REAL    )
#endif
{
#ifndef NDEBUG
    assert( tc >= ta );
    assert( tc <= tb );
#endif

    if( sa < sb ) {
	if( sc <= sa ) {
	    return -1;
	} else if( sb <= sc ) {
	    return 1;
	} else {
	    return 0;
	}
    } else if( sa > sb ) {
	if( sc >= sa ) {
	    return 1;
	} else if( sb >= sc ) {
	    return -1;
	} else {
	    return 0;
	}
    } else {
	if( sc > sa ) {
	    return 1;
	} else if( sb > sc ) {
	    return -1;
	} else {
	    return 0;
	}
    }
}

/*----------------------------------------------------------------------------
 * ccw - determine how three points are oriented by computing their
 *	 determinant.  
 *	 Return 1 if the vertices are ccw oriented, 
 *		0 if they are cw oriented, or 
 *		-1 if the computation is ill-conditioned.
 *----------------------------------------------------------------------------
 */
int
Subdivider::ccw( TrimVertex *a, TrimVertex *b, TrimVertex *c )
{
    REAL d = det3( a, b, c );
    if( abs(d) < 0.0001 ) return -1;
    return (d < 0.0) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\curvelis.h ===
#ifndef __glucurvelist_h_
#define __glucurvelist_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * curvelist.h - $Revision: 1.1 $
 */

#include "types.h"
#include "defines.h"

class Mapdesc;
class Quilt;
class Curve;

class Curvelist 
{
friend class Subdivider;
public:
			Curvelist( Quilt *, REAL, REAL );
    			Curvelist( Curvelist &, REAL );
			~Curvelist( void );
    int			cullCheck( void );
    void		getstepsize( void );
    int			needsSamplingSubdivision();
private:
    Curve		*curve;
    float		range[3];
    int			needsSubdivision;
    float		stepsize;
};
#endif /* __glucurvelist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\displaym.h ===
#ifndef __gludisplaymode_h_
#define __gludisplaymode_h_

#define N_MESHFILL	0
#define N_MESHLINE	1
#define N_MESHPOINT	2

#endif /* __gludisplaymode_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\curvelis.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * curvelist.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "quilt.h"
#include "curvelis.h"
#include "curve.h"
#include "nurbscon.h"
#include "types.h"

Curvelist::Curvelist( Quilt *quilts, REAL pta, REAL ptb )
{
    curve = 0;
    for( Quilt *q = quilts; q; q = q->next ) 
	curve = new Curve( q, pta, ptb, curve );
    range[0] = pta;
    range[1] = ptb;
    range[2] = ptb - pta;
}

Curvelist::Curvelist( Curvelist &upper, REAL value )
{
    Curvelist &lower = *this;
    curve = 0;
    for( Curve *c = upper.curve; c; c = c->next )
	curve = new Curve( *c, value, curve );

    lower.range[0] = upper.range[0];
    lower.range[1] = value;
    lower.range[2] = value - upper.range[0];
    upper.range[0] = value;
    upper.range[2] = upper.range[1] - value;
}

Curvelist::~Curvelist()
{
    while( curve ) {
	Curve *c = curve;
	curve = curve->next;
	delete c;
    }
}

int
Curvelist::cullCheck( void )
{
    for( Curve *c = curve; c; c = c->next )
	if( c->cullCheck() == CULL_TRIVIAL_REJECT )
	    return CULL_TRIVIAL_REJECT;
    return CULL_ACCEPT;
}

void
Curvelist::getstepsize( void )
{
    stepsize = range[2];
    for( Curve *c = curve; c; c = c->next ) {
	c->getstepsize();
	c->clamp();
	stepsize =  ((c->stepsize < stepsize) ? c->stepsize : stepsize);
	if( c->needsSamplingSubdivision() ) break;
    }
    needsSubdivision = ( c ) ? 1 : 0;
}

int
Curvelist::needsSamplingSubdivision( void )
{
    return needsSubdivision;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\defines.h ===
#ifndef __gludefines_h_
#define __gludefines_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * defines.h - $Revision: 1.1 $
 */

/* culling constants */
#define CULL_TRIVIAL_REJECT	0
#define CULL_TRIVIAL_ACCEPT	1
#define CULL_ACCEPT		2

/* maximum order of a B-Spline */ 
#define	MAXORDER 	24

/* maximum dimension of any B-spline range space  */
#define MAXCOORDS	5

#endif /* __gludefines_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\displayl.h ===
#ifndef __gludisplaylist_h_
#define __gludisplaylist_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * displaylist.h - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mysetjmp.h"
#include "mystdio.h"
#include "bufpool.h"

class NurbsTessellator;

typedef void (NurbsTessellator::*PFVS)( void * );

struct Dlnode : public PooledObj {
    			Dlnode( PFVS, void *, PFVS );
    PFVS		work;
    void *		arg;
    PFVS		cleanup;
    Dlnode *		next;
};

inline
Dlnode::Dlnode( PFVS _work, void *_arg, PFVS _cleanup ) 
{
    work = _work;
    arg = _arg;
    cleanup = _cleanup;
}

class DisplayList {
public:
			DisplayList( NurbsTessellator * );
			~DisplayList( void );
    void		play( void );
    void		append( PFVS work, void *arg, PFVS cleanup );
    void		endList( void );
private:
    Dlnode 		*nodes;
    Pool		dlnodePool;
    Dlnode		**lastNode;
    NurbsTessellator 	*nt;
};

#endif /* __gludisplaylist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\displayl.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * displaylist.c++ - $Revision: 1.4 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "nurbstes.h"
#include "displayl.h"


DisplayList::DisplayList( NurbsTessellator  *_nt ) :
	dlnodePool( sizeof( Dlnode ), 1, "dlnodepool" )
{
    lastNode = &nodes;
    nt = _nt;
}

DisplayList::~DisplayList( void ) 
{
    for( Dlnode *nextNode; nodes; nodes = nextNode ) {
	nextNode = nodes->next;
	if( nodes->cleanup != 0 ) (nt->*nodes->cleanup)( nodes->arg );
	//nodes->deleteMe(dlnodePool);
    }
}

void 
DisplayList::play( void )
{
    for( Dlnode *node = nodes; node; node = node->next ) 
	if( node->work != 0 ) (nt->*node->work)( node->arg );
}

void 
DisplayList::endList( void )
{
    *lastNode = 0;
}

void 
DisplayList::append( PFVS work, void *arg, PFVS cleanup )
{
    Dlnode *node = new(dlnodePool) Dlnode( work, arg, cleanup );
    *lastNode = node;
    lastNode = &(node->next);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\flist.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * flist.c++ - $Revision: 1.3 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "flist.h"

/*----------------------------------------------------------------------------
 * Flist::Flist - initialize a REAL number array
 *----------------------------------------------------------------------------
 */
Flist::Flist( void )
{
    npts = 0;
    pts = 0;
    start = end = 0;
}

/*----------------------------------------------------------------------------
 * Flist::~Flist - free a REAL number array
 *----------------------------------------------------------------------------
 */
Flist::~Flist( void )
{
    if( npts ) delete[] pts;
}

void
Flist::add( REAL x )
{
    pts[end++] = x;
    assert( end <= npts );
}

/*----------------------------------------------------------------------------
 * Flist::filter - remove duplicate numbers from array
 *----------------------------------------------------------------------------
 */
void Flist::filter( void )
{
    sorter.qsort( pts, end );
    start = 0;

    int j = 0;
    for( int i = 1; i < end; i++ ) { 
	if( pts[i] == pts[i-j-1] )
	    j++;
	pts[i-j] = pts[i];
    }
    end -= j;
}

/*----------------------------------------------------------------------------
 * Flist::grow - ensure that array is large enough
 *----------------------------------------------------------------------------
 */
void Flist::grow( int maxpts )
{
    if( npts < maxpts ) {
	if( npts ) delete[] pts;
	npts = 2 * maxpts; 
	pts = new REAL[npts];
	assert( pts != 0 );
    }
    start = end = 0;
}

/*----------------------------------------------------------------------------
 * Flist::taper - ignore head and tail of array
 *----------------------------------------------------------------------------
 */
void Flist::taper( REAL from, REAL to )
{
    while( pts[start] != from )
	start++;

    while( pts[end-1] != to )
	end--;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\curvesub.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * curvesub.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "subdivid.h"
#include "renderhi.h"
#include "backend.h"
#include "quilt.h"
#include "curvelis.h"
#include "curve.h"
#include "nurbscon.h"

/*--------------------------------------------------------------------------
 * drawCurves - main curve rendering entry point
 *--------------------------------------------------------------------------
 */

void
Subdivider::drawCurves( void )
{
    REAL 	from[1], to[1];
    Flist	bpts;
    qlist->getRange( from, to, bpts );

    renderhints.init( );

    backend.bgncurv();
    for( int i=bpts.start; i<bpts.end-1; i++ ) {
        REAL pta, ptb;
	pta = bpts.pts[i];
	ptb = bpts.pts[i+1];

	qlist->downloadAll( &pta, &ptb, backend );

	Curvelist curvelist( qlist, pta, ptb );
	samplingSplit( curvelist, renderhints.maxsubdivisions );
    }
    backend.endcurv();
}


/*--------------------------------------------------------------------------
 * samplingSplit - recursively subdivide patch, cull check each subpatch  
 *--------------------------------------------------------------------------
 */

void
Subdivider::samplingSplit( Curvelist& curvelist, int subdivisions )
{
    if( curvelist.cullCheck() == CULL_TRIVIAL_REJECT )  return;

    curvelist.getstepsize();

    if( curvelist.needsSamplingSubdivision() && (subdivisions > 0) ) {
	REAL mid = ( curvelist.range[0] + curvelist.range[1] ) * 0.5;
	Curvelist lowerlist( curvelist, mid );
	samplingSplit( lowerlist, subdivisions-1 ); // lower
	samplingSplit( curvelist, subdivisions-1 ); // upper
    } else {
	long nu = 1 + ((long) (curvelist.range[2] / curvelist.stepsize));
	backend.curvgrid( curvelist.range[0], curvelist.range[1], nu );
	backend.curvmesh( 0, nu );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\flistsor.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * flistsorter.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "flistsor.h"

FlistSorter::FlistSorter( void ) : Sorter( sizeof( REAL ) )
{
}

void
FlistSorter::qsort( REAL *p, int n )
{
    Sorter::qsort( (char *)p, n );
}

int
FlistSorter::qscmp( char *i, char *j )
{
    REAL f0 = *(REAL *)i;
    REAL f1 = *(REAL *)j;
    return (f0 < f1) ? -1 : 1;
}

void
FlistSorter::qsexc( char *i, char *j )
{
    REAL *f0 = (REAL *)i;
    REAL *f1 = (REAL *)j;
    REAL tmp = *f0;
    *f0 = *f1;
    *f1 = tmp;
}

void
FlistSorter::qstexc( char *i, char *j, char *k )
{
    REAL *f0 = (REAL *)i;
    REAL *f1 = (REAL *)j;
    REAL *f2 = (REAL *)k;
    REAL tmp = *f0;
    *f0 = *f2;
    *f2 = *f1;
    *f1 = tmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\glimport.h ===
#ifndef __gluimports_h_
#define __gluimports_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * glimports.h - $Revision: 1.1 $
 */

#ifdef NT
#include <glos.h>
#include "windows.h"
#else
#include "mystdlib.h"
#include "mystdio.h"
#endif

#ifdef NT
extern "C" DWORD gluMemoryAllocationFailed;
inline void * GLOS_CCALL
operator new( size_t s )
{
    void *p = (void *) LocalAlloc(LMEM_FIXED, s);

    if( p ) {
	return p;
    } else {
        gluMemoryAllocationFailed++;
#ifndef NDEBUG
        MessageBoxA(NULL, "LocalAlloc failed\n", "ERROR", MB_OK);
#endif
	return p;
    }
}

inline void GLOS_CCALL
operator delete( void *p )
{
    if (p) LocalFree(p);
}

#else

operator new( size_t s )
{
    void *p = malloc( s );

    if( p ) {
	return p;
    } else {
        dprintf( "malloc failed\n" );
	return p;
    }
}

inline void
operator delete( void *p )
{
    if( p ) free( p );
}

#endif // NT
#endif /* __gluimports_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\flist.h ===
#ifndef __gluflist_h_
#define __gluflist_h_

/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * flist.h - $Revision: 1.1 $
 */

#include "types.h"
#include "flistsor.h"

class Flist {
public:
    REAL *		pts;		/* head of array */
    int			npts;		/* number of points in array */
    int			start;		/* first important point index */
    int			end;		/* last important point index */

    			Flist( void );
    			~Flist( void );
    void		add( REAL x );
    void		filter( void );
    void		grow( int);
    void		taper( REAL , REAL );
protected:
    FlistSorter 	sorter;
};

#endif /* __gluflist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\flistsor.h ===
#ifndef __gluflistsorter_h_
#define __gluflistsorter_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * flistsorter.h - $Revision: 1.1 $
 */

#include "sorter.h"
#include "types.h"

class FlistSorter : public Sorter {
public:
			FlistSorter(void);
    void		qsort( REAL *a, int n );

protected:	
    virtual int		qscmp( char *, char * );
    virtual void	qsexc( char *i, char *j );	// i<-j, j<-i 
    virtual void	qstexc( char *i, char *j, char *k ); // i<-k, k<-j, j<-i 
};
#endif /* __gluflistsorter_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\gridvert.h ===
#ifndef __glugridvertex_h_
#define __glugridvertex_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * gridvertex.h - $Revision: 1.1 $
 */

#ifdef NT
class GridVertex { public:
#else
struct GridVertex {
#endif
    long 		gparam[2];
			GridVertex( void ) {}
			GridVertex( long u, long v ) { gparam[0] = u, gparam[1] = v; }
    void		set( long u, long v ) { gparam[0] = u, gparam[1] = v; }
    long		nextu() { return gparam[0]++; }
    long		prevu() { return gparam[0]--; }
};

#endif /* __glugridvertex_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\gridline.h ===
#ifndef __glugridline_h_
#define __glugridline_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * gridline.h - $Revision: 1.1 $
 */

#ifdef NT
class Gridline {
public:
#else
struct Gridline {
#endif
    long 		v;
    REAL		vval;
    long		vindex;
    long 		ustart;
    long 		uend;
 };
#endif /* __glugridline_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\gridtrim.h ===
#ifndef __glugridtrimvertex_h_
#define __glugridtrimvertex_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * gridtrimvertex.h - $Revision: 1.1 $
 */

#include "mystdlib.h"
#include "bufpool.h"
#include "trimvert.h"
#include "gridvert.h"

class GridTrimVertex : public PooledObj
{
private:
    TrimVertex	dummyt;
    GridVertex	dummyg;
public:
			GridTrimVertex() { g = 0; t = 0; }
    TrimVertex	*t;
    GridVertex	*g;
   
    inline void		set( long, long );
    inline void		set( REAL, REAL );
    inline void		set( TrimVertex * );
    inline void		clear( void ) { t = 0; g = 0; };
    inline int		isGridVert() { return g ? 1 : 0 ; }
    inline int		isTrimVert() { return t ? 1 : 0 ; }
    inline void		output();
};

inline void
GridTrimVertex::set( long x, long y )
{
    g = &dummyg;
    dummyg.gparam[0] = x;
    dummyg.gparam[1] = y;
}

inline void
GridTrimVertex::set( REAL x, REAL y )
{
    g = 0;
    t = &dummyt;
    dummyt.param[0] = x;
    dummyt.param[1] = y;
    dummyt.nuid = 0;
}

inline void
GridTrimVertex::set( TrimVertex *v )
{
    g = 0;
    t = v;
}

typedef GridTrimVertex *GridTrimVertex_p;
#endif /* __glugridtrimvertex_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\knot.h ===
#ifndef __gluknot_h_
#define __gluknot_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1991, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * knot.h - $Revision: 1.1 $
 */

#include "types.h"

typedef	REAL		Knot, *Knot_ptr;/* knot values */
#endif /* __gluknot_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\jarcloc.h ===
#ifndef __glujarcloc_h_
#define __glujarcloc_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * jarcloc.h - $Revision: 1.1 $
 */

#include "arc.h"

class Jarcloc {
private:
    Arc * 		arc;
    TrimVertex		*p;
    TrimVertex		*plast;
public:
    inline void		init( Arc_ptr a, long first, long last ) { arc = a; p=&a->pwlArc->pts[first]; plast = &a->pwlArc->pts[last]; }
    inline TrimVertex *	getnextpt( void );
    inline TrimVertex *	getprevpt( void );
    inline void		reverse();
};

inline void
Jarcloc::reverse()
{
    if( plast == &arc->pwlArc->pts[0] )
	plast =  &arc->pwlArc->pts[arc->pwlArc->npts - 1];
    else
	plast =  &arc->pwlArc->pts[0];
}

inline TrimVertex *
Jarcloc::getnextpt()
{
    assert( p <= plast );
    if( p == plast ) {
	arc = arc->next;
	p = &arc->pwlArc->pts[0];
	plast = &arc->pwlArc->pts[arc->pwlArc->npts - 1];
	assert( p < plast );
    }
    return p++;
}
	
inline TrimVertex *
Jarcloc::getprevpt()
{
    assert( p >= plast );
    if( p == plast ) {
	arc = arc->prev;
	p = &arc->pwlArc->pts[arc->pwlArc->npts - 1];
	plast = &arc->pwlArc->pts[0];
	assert( p > plast );
    }
    return p--;
}
#endif /* __glujarcloc_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\hull.h ===
#ifndef __gluhull_h_
#define __gluhull_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * hull.h - $Revision: 1.1 $
 */

#include "trimline.h"
#include "trimregi.h"

class GridTrimVertex;
class Gridline;
class Uarray;

class Hull : virtual public TrimRegion {
public:
    			Hull( void );
    			~Hull( void );
    void		init( void );
    GridTrimVertex *	nextlower( GridTrimVertex * );
    GridTrimVertex *	nextupper( GridTrimVertex * );
private:
    struct Side {
	Trimline 	*left;
	Gridline     	*line;
	Trimline 	*right;
	long 		index;
    };
	
    Side 		lower;
    Side		upper;
    Trimline 		fakeleft;
    Trimline		fakeright;
};


#endif /* __gluhull_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\knotvect.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * knotvector.c++ - $Revision: 1.5 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "knotvect.h"
#include "defines.h"


void Knotvector::init( long _knotcount, long _stride, long _order, INREAL *_knotlist )
{
    knotcount = _knotcount; 
    stride = _stride; 
    order = _order; 
    knotlist = new Knot[_knotcount];
    assert( knotlist != 0 );

    for( int i = 0; i != _knotcount; i++ )
        knotlist[i] = (Knot) _knotlist[i]; 
}

Knotvector::Knotvector( void )
{
    knotlist = 0;
}

Knotvector::~Knotvector( void )
{
    if( knotlist ) delete[] knotlist;
}

int Knotvector::validate( void )
{
   /* kindex is used as an array index so subtract one first, 
     * this propagates throughout the code so study carefully */
    long	kindex = knotcount-1;

    if( order < 1 || order > MAXORDER ) {
	// spline order un-supported
	return( 1 );
    }

    if( knotcount < (2 * order) ) {
	// too few knots
	return( 2 );
    }

    if( identical( knotlist[kindex-(order-1)], knotlist[order-1]) ) {
	// valid knot range is empty 
	return( 3 );
    }

    for( long i = 0; i < kindex; i++)
	if( knotlist[i] > knotlist[i+1] ) {
	    // decreasing knot sequence
	    return( 4 );
	}
	
    /* check for valid multiplicity */

    /*	kindex is currently the index of the last knot.
     *	In the next loop  it is decremented to ignore the last knot
     *	and the loop stops when kindex  is 2 so as to ignore the first
     *  knot as well.  These knots are not used in computing 
     *  knot multiplicities.
     */

    long multi = 1;
    for( ; kindex >= 1; kindex-- ) {
	if( knotlist[kindex] - knotlist[kindex-1] < TOLERANCE ) {
	    multi++; 
	    continue;
	} 
	if ( multi > order ) {
            // knot multiplicity greater than order of spline
	    return( 5 );
	} 
	multi = 1;
    }

    if ( multi > order ) {
        // knot multiplicity greater than order of spline
	return( 5 );
    } 

    return 0;
}

void Knotvector::show( char *msg )
{
#ifndef NDEBUG
    dprintf( "%s\n", msg ); 
    dprintf( "order = %ld, count = %ld\n", order, knotcount );

    for( int i=0; i<knotcount; i++ )
	dprintf( "knot[%d] = %g\n", i, knotlist[i] );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\intersec.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * intersect.c++ - $Revision: 1.5 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "subdivid.h"
#include "arc.h"
#include "bin.h"
#include "backend.h"
#include "trimpool.h"

enum i_result { INTERSECT_VERTEX, INTERSECT_EDGE };

/* local functions */
static int		arc_classify( Arc_ptr, int, REAL );
static enum i_result	pwlarc_intersect( PwlArc *, int, REAL, int, int[3] );


void
Subdivider::partition( Bin & bin, Bin & left, Bin & intersections, 
	        Bin & right, Bin & unknown, int param, REAL value )
{
    Bin	headonleft, headonright, tailonleft, tailonright;

    for( Arc_ptr jarc = bin.removearc(); jarc; jarc = bin.removearc() ) {

	REAL tdiff = jarc->tail()[param] - value;
	REAL hdiff = jarc->head()[param] - value;
    
	if( tdiff > 0.0 ) {
	    if( hdiff > 0.0 ) {
		right.addarc( jarc  );
	    } else if( hdiff == 0.0 ) {
		tailonright.addarc( jarc  );
	    } else {
	        Arc_ptr	jtemp;
		switch( arc_split(jarc, param, value, 0) ) {
		    case 2:
			tailonright.addarc( jarc  );
			headonleft.addarc( jarc->next  );
			break;
		    case 31:
			assert( jarc->head()[param] > value );
			right.addarc( jarc  );
			tailonright.addarc( jtemp = jarc->next  );
			headonleft.addarc( jtemp->next  );
		        break;
		    case 32:
			assert( jarc->head()[param] <= value );
			tailonright .addarc( jarc  );
			headonleft.addarc( jtemp = jarc->next  );
			left.addarc( jtemp->next  );
			break;
		    case 4:
			right.addarc( jarc  );
			tailonright.addarc( jtemp = jarc->next  );
			headonleft.addarc( jtemp = jtemp->next  );
			left.addarc( jtemp->next  );
		}
	    }
	} else if( tdiff == 0.0 ) {
	    if( hdiff > 0.0 ) {
		headonright.addarc( jarc  );
	    } else if( hdiff == 0.0 ) {
		unknown.addarc( jarc  );
	    } else {
		headonleft.addarc( jarc  );
	    }
	} else {
	    if( hdiff > 0.0 ) {
	        Arc_ptr	jtemp;
		switch( arc_split(jarc, param, value, 1) ) {
		    case 2:
			tailonleft.addarc( jarc  );
			headonright.addarc( jarc->next  );
			break;
		    case 31:
			assert( jarc->head()[param] < value );
			left.addarc( jarc  );
			tailonleft.addarc( jtemp = jarc->next  );
			headonright.addarc( jtemp->next  );
			break;
		    case 32:
			assert( jarc->head()[param] >= value );
			tailonleft.addarc( jarc  );
			headonright.addarc( jtemp = jarc->next  );
			right.addarc( jtemp->next  );
			break;
		    case 4:
			left.addarc( jarc  );
			tailonleft.addarc( jtemp = jarc->next  );
			headonright.addarc( jtemp = jtemp->next  );
			right.addarc( jtemp->next  );
		}
	    } else if( hdiff == 0.0 ) {
		tailonleft.addarc( jarc  );
	    } else {
		left.addarc( jarc  );
	    }
	}
    }
    if( param == 0 ) {
	classify_headonleft_s( headonleft, intersections, left, value );
	classify_tailonleft_s( tailonleft, intersections, left, value );
	classify_headonright_s( headonright, intersections, right, value );
	classify_tailonright_s( tailonright, intersections, right, value );
    } else {
	classify_headonleft_t( headonleft, intersections, left, value );
	classify_tailonleft_t( tailonleft, intersections, left, value );
	classify_headonright_t( headonright, intersections, right, value );
	classify_tailonright_t( tailonright, intersections, right, value );
    }
}

inline static void 
vert_interp( TrimVertex *n, TrimVertex *l, TrimVertex *r, int p, REAL val )
{
    assert( val > l->param[p]);
    assert( val < r->param[p]);

    n->nuid = l->nuid;

    n->param[p] = val;
    if( l->param[1-p] != r->param[1-p]  ) {
	REAL ratio = (val - l->param[p]) / (r->param[p] - l->param[p]);
	n->param[1-p] = l->param[1-p] + 
		        ratio * (r->param[1-p] - l->param[1-p]);
    } else {
	n->param[1-p] = l->param[1-p];
    }
}
	
int
Subdivider::arc_split( Arc_ptr jarc, int param, REAL value, int dir )
{
    int		maxvertex = jarc->pwlArc->npts;
    Arc_ptr	jarc1, jarc2, jarc3;
    TrimVertex* v = jarc->pwlArc->pts;

    int		loc[3];
    switch( pwlarc_intersect( jarc->pwlArc, param, value, dir, loc ) ) {

    case INTERSECT_VERTEX: {
	    jarc1 = new(arcpool) Arc( jarc, new( pwlarcpool) PwlArc( maxvertex-loc[1], &v[loc[1]] ) );
	    jarc->pwlArc->npts = loc[1] + 1;
	    jarc1->next = jarc->next;
	    jarc1->next->prev = jarc1;
	    jarc->next = jarc1;
	    jarc1->prev = jarc;
	    assert(jarc->check() != 0);
	    return 2;
	}

    case INTERSECT_EDGE: {
	    int i, j;
	    if( dir == 0 ) {
		i = loc[0];
		j = loc[2];
	    } else {
		i = loc[2];
		j = loc[0];
	    }

	    TrimVertex *newjunk = trimvertexpool.get(3);
	    v[i].nuid = jarc->nuid;
	    v[j].nuid = jarc->nuid;
	    newjunk[0] = v[j];
	    newjunk[2] = v[i];
	    vert_interp( &newjunk[1], &v[loc[0]], &v[loc[2]], param, value );

	    if( showingDegenerate() )
		backend.triangle( &newjunk[2], &newjunk[1], &newjunk[0] );

	    if (maxvertex == 2) {
		jarc1 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk+1 ) );
		jarc->pwlArc->npts = 2;
		jarc->pwlArc->pts = newjunk;
		jarc1->next = jarc->next;
		jarc1->next->prev = jarc1;
		jarc->next = jarc1;
		jarc1->prev = jarc;
		assert(jarc->check() != 0);
		return 2;
	    } else if (maxvertex - j == 2) {
		jarc1 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk ) );
		jarc2 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk+1 ) );
		jarc->pwlArc->npts = maxvertex-1;
		jarc2->next = jarc->next;
		jarc2->next->prev = jarc2;
		jarc->next = jarc1;
		jarc1->prev = jarc;
		jarc1->next = jarc2;
		jarc2->prev = jarc1;
		assert(jarc->check() != 0);
		return 31;
	    } else if (i == 1) {
		jarc1 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk+1 ) );
		jarc2 = new(arcpool) Arc( jarc, 
			new(pwlarcpool) PwlArc( maxvertex-1, &jarc->pwlArc->pts[1] ) );
		jarc->pwlArc->npts = 2;
		jarc->pwlArc->pts = newjunk;
		jarc2->next = jarc->next;
		jarc2->next->prev = jarc2;
		jarc->next = jarc1;
		jarc1->prev = jarc;
		jarc1->next = jarc2;
		jarc2->prev = jarc1;
		assert(jarc->check() != 0);
		return 32;
	    } else {
		jarc1 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk ) );
		jarc2 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( 2, newjunk+1 ) );
		jarc3 = new(arcpool) Arc( jarc, new(pwlarcpool) PwlArc( maxvertex-i, v+i ) );
		jarc->pwlArc->npts = j + 1;
		jarc3->next = jarc->next;
		jarc3->next->prev = jarc3;
		jarc->next = jarc1;
		jarc1->prev = jarc;
		jarc1->next = jarc2;
		jarc2->prev = jarc1;
		jarc2->next = jarc3;
		jarc3->prev = jarc2;
		assert(jarc->check() != 0);
		return 4;
	    }
	}
	default:
	return -1; //picked -1 since it's not used
    }
}

/*----------------------------------------------------------------------------
 * pwlarc_intersect -  find intersection of pwlArc and isoparametric line
 *----------------------------------------------------------------------------
 */

static enum i_result
pwlarc_intersect(
    PwlArc *pwlArc,
    int param,
    REAL value,
    int dir,
    int loc[3] )
{
    assert( pwlArc->npts > 0 );

    if( dir ) {
	TrimVertex *v = pwlArc->pts;
	int imin = 0; 
	int imax = pwlArc->npts - 1;
	assert( value > v[imin].param[param] );
	assert( value < v[imax].param[param] );	
	while( (imax - imin) > 1 ) {
	    int imid = (imax + imin)/2;
	    if( v[imid].param[param] > value )
		imax = imid;
	    else if( v[imid].param[param] < value )
		imin = imid;
	    else {
		loc[1] = imid;
		return INTERSECT_VERTEX;
	    }
	}
	loc[0] = imin;
	loc[2] = imax;
	return INTERSECT_EDGE;
    } else {
	TrimVertex *v = pwlArc->pts;
	int imax = 0; 
	int imin = pwlArc->npts - 1;
	assert( value > v[imin].param[param] );
	assert( value < v[imax].param[param] );	
	while( (imin - imax) > 1 ) {
	    int imid = (imax + imin)/2;
	    if( v[imid].param[param] > value )
		imax = imid;
	    else if( v[imid].param[param] < value )
		imin = imid;
	    else {
		loc[1] = imid;
		return INTERSECT_VERTEX;
	    }
	}
	loc[0] = imin;
	loc[2] = imax;
	return INTERSECT_EDGE;
    }
}

/*----------------------------------------------------------------------------
 * arc_classify - determine which side of a line a jarc lies 
 *----------------------------------------------------------------------------
 */

static int
arc_classify( Arc_ptr jarc, int param, REAL value )
{
    REAL tdiff, hdiff;
    if( param == 0 ) {
	tdiff = jarc->tail()[0] - value;
	hdiff = jarc->head()[0] - value;
    } else {
	tdiff = jarc->tail()[1] - value;
	hdiff = jarc->head()[1] - value;
    }

    if( tdiff > 0.0 ) {
	if( hdiff > 0.0 ) {
	    return 0x11;
	} else if( hdiff == 0.0 ) {
	    return 0x12;
	} else {
	    return 0x10;
	}
    } else if( tdiff == 0.0 ) {
	if( hdiff > 0.0 ) {
	    return 0x21;
	} else if( hdiff == 0.0 ) {
	    return 0x22;
	} else {
	    return 0x20;
	}
    } else {
	if( hdiff > 0.0 ) {
	    return 0x01;
	} else if( hdiff == 0.0 ) {
	    return 0x02;
	} else {
	    return 0;
	}
    }
}

void
Subdivider::classify_tailonleft_s( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail at left, head on line */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 0, val ) == 0x02 );
	j->clearitail();

	REAL diff = j->next->head()[0] - val;
	if( diff > 0.0 ) {
	    in.addarc( j );
	} else if( diff < 0.0 ) {
	    if( ccwTurn_sl( j, j->next ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else {
	    if( j->next->tail()[1] > j->next->head()[1] ) 
		in.addarc(j);
	    else
		out.addarc(j);
	}
    }
}

void
Subdivider::classify_tailonleft_t( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail at left, head on line */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 1, val ) == 0x02 );
	j->clearitail();

        REAL diff = j->next->head()[1] - val;
	if( diff > 0.0 ) {
	    in.addarc( j );
	} else if( diff < 0.0 ) {
	    if( ccwTurn_tl( j, j->next ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else {
	    if (j->next->tail()[0] > j->next->head()[0] )
		out.addarc( j );
	    else
		in.addarc( j );
	}
    }
}

void
Subdivider::classify_headonleft_s( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail on line, head at left */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 0, val ) == 0x20 );

	j->setitail();

	REAL diff = j->prev->tail()[0] - val;
	if( diff > 0.0 ) {
	    out.addarc( j );
	} else if( diff < 0.0 ) {
	    if( ccwTurn_sl( j->prev, j ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else {
	    if( j->prev->tail()[1] > j->prev->head()[1] )
		in.addarc( j );
	    else
		out.addarc( j );
	}
    }
}

void
Subdivider::classify_headonleft_t( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail on line, head at left */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 1, val ) == 0x20 );
	j->setitail();

	REAL diff = j->prev->tail()[1] - val;
	if( diff > 0.0 ) {
	    out.addarc( j );
	} else if( diff < 0.0 ) {
	    if( ccwTurn_tl( j->prev, j ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else {
	    if( j->prev->tail()[0] > j->prev->head()[0] )
		out.addarc( j );
	    else
		in.addarc( j );
	}
    }
}


void
Subdivider::classify_tailonright_s( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail at right, head on line */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 0, val ) == 0x12);
	
	j->clearitail();

        REAL diff = j->next->head()[0] - val;
	if( diff > 0.0 ) {
	    if( ccwTurn_sr( j, j->next ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else if( diff < 0.0 ) {
	    in.addarc( j );
	} else {
	    if( j->next->tail()[1] > j->next->head()[1] ) 
		out.addarc( j );
	    else
		in.addarc( j );
	}
    }
}

void
Subdivider::classify_tailonright_t( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail at right, head on line */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 1, val ) == 0x12);
	
	j->clearitail();

	REAL diff =  j->next->head()[1] - val;
	if( diff > 0.0 ) {
	    if( ccwTurn_tr( j, j->next ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else if( diff < 0.0 ) { 
	    in.addarc( j );
	} else {
	    if( j->next->tail()[0] > j->next->head()[0] ) 
		in.addarc( j );
	    else
		out.addarc( j );
	}
    }
}

void
Subdivider::classify_headonright_s( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail on line, head at right */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 0, val ) == 0x21 );
    
	j->setitail();

        REAL diff = j->prev->tail()[0] - val;
	if( diff > 0.0 ) { 
	    if( ccwTurn_sr( j->prev, j ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else if( diff < 0.0 ) {
	    out.addarc( j );
	} else {
	    if( j->prev->tail()[1] > j->prev->head()[1] )
		out.addarc( j );
	    else
		in.addarc( j );
	}
    }
}

void
Subdivider::classify_headonright_t( Bin& bin, Bin& in, Bin& out, REAL val )
{
    /* tail on line, head at right */
    Arc_ptr j;

    while( j = bin.removearc() ) {
	assert( arc_classify( j, 1, val ) == 0x21 );
    
	j->setitail();

        REAL diff = j->prev->tail()[1] - val;
	if( diff > 0.0 ) { 
	    if( ccwTurn_tr( j->prev, j ) )
		out.addarc( j );
	    else
		in.addarc( j );
	} else if( diff < 0.0 ) {
	    out.addarc( j );
	} else {
	    if( j->prev->tail()[0] > j->prev->head()[0] )
		in.addarc( j );
	    else
		out.addarc( j );
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\knotvect.h ===
#ifndef __gluknotvector_h_
#define __gluknotvector_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * knotvector.h - $Revision: 1.1 $
 */

#include "types.h"

#ifdef NT
class Knotvector { /* a knot vector */
public:
#else
struct Knotvector { /* a knot vector */
#endif
			Knotvector( void );
			~Knotvector( void );
    void		init( long, long, long, INREAL * );
    int			validate( void );
    void 		show( char * );

    long		order;		/* order of spline  */
    long		knotcount;	/* number of knots  */
    long		stride;		/* bytes between points */
    Knot *		knotlist;	/* global knot vector */
};

/* tolerance to test knot coincidence */
#define TOLERANCE 		10.0e-5

inline int 
identical( Knot x, Knot y )
{
    return ((x-y) < TOLERANCE) ? 1 : 0;
}
#endif /* __gluknotvector_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\hull.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * hull.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "hull.h"
#include "gridvert.h"
#include "gridtrim.h"
#include "gridline.h"
#include "trimline.h"
#include "uarray.h"
#include "trimregi.h"

Hull::Hull( void )
{}

Hull::~Hull( void )
{}

/*----------------------------------------------------------------------
 * Hull:init - this routine does the initialization needed before any
 *	 	calls to nextupper or nextlower can be made.
 *----------------------------------------------------------------------
 */
void
Hull::init( void )
{
    TrimVertex *lfirst = left.first();
    TrimVertex *llast = left.last();
    if( lfirst->param[0] <= llast->param[0] ) {
	fakeleft.init( left.first() );
	upper.left = &fakeleft;
	lower.left = &left;
    } else {
	fakeleft.init( left.last() );
	lower.left = &fakeleft;
 	upper.left = &left;
    }
    upper.left->last();
    lower.left->first();

    if( top.ustart <= top.uend ) {
	upper.line = &top;
	upper.index = top.ustart;
    } else
	upper.line = 0;

    if( bot.ustart <= bot.uend ) {
	lower.line = &bot;
	lower.index = bot.ustart;
    } else
	lower.line = 0;

    TrimVertex *rfirst = right.first();
    TrimVertex *rlast = right.last();
    if( rfirst->param[0] <= rlast->param[0] ) {
	fakeright.init( right.last() );
	lower.right = &fakeright;
	upper.right = &right;
    } else {
	fakeright.init( right.first() );
	upper.right = &fakeright;
	lower.right = &right;
    }
    upper.right->first();
    lower.right->last();
}

/*----------------------------------------------------------------------
 * nextupper - find next vertex on upper hull of trim region.
 *		 - if vertex is on trim curve, set vtop point to 
 *		   that vertex.  if vertex is on grid, set vtop to
 *		   point to temporary area and stuff coordinants into
 *		   temporary vertex.  Also, place grid coords in temporary
 *		   grid vertex.
 *----------------------------------------------------------------------
 */
GridTrimVertex *
Hull::nextupper( GridTrimVertex *gv )
{
    if( upper.left ) {
	gv->set( upper.left->prev() );
	if( gv->isTrimVert() ) return gv;
	upper.left = 0;
    } 

    if( upper.line ) {
	assert( upper.index <= upper.line->uend );
	gv->set( uarray.uarray[upper.index], upper.line->vval );
	gv->set( upper.index, upper.line->vindex );
	if( upper.index++ == upper.line->uend ) upper.line = 0;
	return gv; 
    } 

    if( upper.right ) {
	gv->set( upper.right->next() );
	if( gv->isTrimVert() ) return gv;
	upper.right = 0;
    } 

    return 0; 
}

GridTrimVertex *
Hull::nextlower( register GridTrimVertex *gv )
{
    if( lower.left ) {
	gv->set( lower.left->next() );
	if( gv->isTrimVert() ) return gv;
	lower.left = 0;
    } 

    if( lower.line ) {
	gv->set( uarray.uarray[lower.index], lower.line->vval );
	gv->set( lower.index, lower.line->vindex );
	if( lower.index++ == lower.line->uend ) lower.line = 0;
	return gv;
    } 

    if( lower.right ) {
	gv->set( lower.right->prev() );
	if( gv->isTrimVert() ) return gv;
	lower.right = 0;
    } 

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mapdesc.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mapdesc.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "mystring.h"
#include "mymath.h"
#include "backend.h"
#include "nurbscon.h"
#include "mapdesc.h"

Mapdesc::Mapdesc( long _type, int _israt, int _ncoords, Backend& b ) 
    : backend( b )
{
    type 		= _type;
    isrational 		= _israt;
    ncoords 		= _ncoords;
    hcoords		= _ncoords + (_israt ? 0 : 1 );
    inhcoords		= _ncoords - (_israt ? 1 : 0 );
    mask 		= ((1<<(inhcoords*2))-1);
    next		= 0;

    assert( hcoords <= MAXCOORDS );
    assert( inhcoords >= 1 );

    pixel_tolerance 	= 1.0;
    error_tolerance	= 1.0;
    bbox_subdividing	= N_NOBBOXSUBDIVISION;
    culling_method 	= N_NOCULLING;		
    sampling_method 	= N_NOSAMPLING;
    clampfactor 	= N_NOCLAMPING;
    minsavings 		= N_NOSAVINGSSUBDIVISION;
    s_steps  		= 0.0;
    t_steps 		= 0.0;
    maxrate 		= ( s_steps < 0.0 ) ? 0.0 : s_steps;
    maxsrate 		= ( s_steps < 0.0 ) ? 0.0 : s_steps;
    maxtrate 		= ( t_steps < 0.0 ) ? 0.0 : t_steps;
    identify( bmat );
    identify( cmat );
    identify( smat );
    for( int i = 0; i != inhcoords; i++ )
	bboxsize[i] = 1.0;
}

void
Mapdesc::setBboxsize( INREAL *mat )
{
    for( int i = 0; i != inhcoords; i++ )
	bboxsize[i] = (REAL) mat[i];
}

void
Mapdesc::identify( REAL dest[MAXCOORDS][MAXCOORDS] )
{
    memset( dest, 0, sizeof( dest ) );
    for( int i=0; i != hcoords; i++ )
	dest[i][i] = 1.0;
}

void
Mapdesc::surfbbox( REAL bb[2][MAXCOORDS] )
{
    backend.surfbbox( type, bb[0], bb[1] );
}

void 
Mapdesc::copy( REAL dest[MAXCOORDS][MAXCOORDS], long n, INREAL *src,
	long rstride, long cstride )
{
    assert( n >= 0 );
    for( int i=0; i != n; i++ )
        for( int j=0; j != n; j++ )
	    dest[i][j] = src[i*rstride + j*cstride];
}

/*--------------------------------------------------------------------------
 * copyPt - copy a homogeneous point
 *--------------------------------------------------------------------------
 */
void
Mapdesc::copyPt( REAL *d, REAL *s )
{
    assert( hcoords > 0 );
    switch( hcoords  ) {
	case 4: 
	    d[3] = s[3];
	    d[2] = s[2];
	    d[1] = s[1];
	    d[0] = s[0];
	    break;
	case 3: 
	    d[2] = s[2];
	    d[1] = s[1];
	    d[0] = s[0];
	    break;
	case 2: 
	    d[1] = s[1];
	    d[0] = s[0];
	    break;
	case 1: 
	    d[0] = s[0];
	    break;
	case 5: 
	    d[4] = s[4];
	    d[3] = s[3];
	    d[2] = s[2];
	    d[1] = s[1];
	    d[0] = s[0];
	    break;
	default:
	    memcpy( d, s, hcoords * sizeof( REAL ) );
	    break;
    }
}

/*--------------------------------------------------------------------------
 * sumPt - compute affine combination of two homogeneous points
 *--------------------------------------------------------------------------
 */
void
Mapdesc::sumPt( REAL *dst, REAL *src1, REAL *src2, register REAL alpha, register REAL beta )
{
    assert( hcoords > 0 );
    switch( hcoords  ) {
	case 4: 
	    dst[3] = src1[3] * alpha + src2[3] * beta;
	    dst[2] = src1[2] * alpha + src2[2] * beta;
	    dst[1] = src1[1] * alpha + src2[1] * beta;
	    dst[0] = src1[0] * alpha + src2[0] * beta;
	    break;
	case 3: 
	    dst[2] = src1[2] * alpha + src2[2] * beta;
	    dst[1] = src1[1] * alpha + src2[1] * beta;
	    dst[0] = src1[0] * alpha + src2[0] * beta;
	    break;
	case 2: 
	    dst[1] = src1[1] * alpha + src2[1] * beta;
	    dst[0] = src1[0] * alpha + src2[0] * beta;
	    break;
	case 1: 
	    dst[0] = src1[0] * alpha + src2[0] * beta;
	    break;
	case 5: 
	    dst[4] = src1[4] * alpha + src2[4] * beta;
	    dst[3] = src1[3] * alpha + src2[3] * beta;
	    dst[2] = src1[2] * alpha + src2[2] * beta;
	    dst[1] = src1[1] * alpha + src2[1] * beta;
	    dst[0] = src1[0] * alpha + src2[0] * beta;
	    break;
	default: {
		for( int i = 0; i != hcoords; i++ )
		    dst[i] = src1[i] * alpha + src2[i] * beta;
            }
	    break;
    }
}

/*--------------------------------------------------------------------------
 * clipbits - compute bit-vector indicating point/window position
 *		       of a (transformed) homogeneous point
 *--------------------------------------------------------------------------
 */
unsigned int
Mapdesc::clipbits( REAL *p )
{
    assert( inhcoords >= 0 );
    assert( inhcoords <= 3 );

    register int nc = inhcoords;
    register REAL pw = p[nc];
    register REAL nw = -pw;
    register unsigned int bits = 0;

    if( pw == 0.0 ) return mask;

    if( pw > 0.0 ) {
	switch( nc ) {
	case 3:
	    if( p[2] <= pw ) bits |= (1<<5);
	    if( p[2] >= nw ) bits |= (1<<4);
	    if( p[1] <= pw ) bits |= (1<<3);
	    if( p[1] >= nw ) bits |= (1<<2);
	    if( p[0] <= pw ) bits |= (1<<1);
	    if( p[0] >= nw ) bits |= (1<<0);
            return bits;
	case 2:
	    if( p[1] <= pw ) bits |= (1<<3);
	    if( p[1] >= nw ) bits |= (1<<2);
	    if( p[0] <= pw ) bits |= (1<<1);
	    if( p[0] >= nw ) bits |= (1<<0);
            return bits;
	case 1:
	    if( p[0] <= pw ) bits |= (1<<1);
	    if( p[0] >= nw ) bits |= (1<<0);
            return bits;
	default: {
		int bit = 1;
		for( int i=0; i<nc; i++ ) {
		    if( p[i] >= nw ) bits |= bit; 
		    bit <<= 1;
		    if( p[i] <= pw ) bits |= bit; 
		    bit <<= 1;
		}
#ifdef NT
                return 0;
#else
		abort();
#endif
		break;
	    }
	}
    } else { 
	switch( nc ) {
	case 3:
	    if( p[2] <= nw ) bits |= (1<<5);
	    if( p[2] >= pw ) bits |= (1<<4);
	    if( p[1] <= nw ) bits |= (1<<3);
	    if( p[1] >= pw ) bits |= (1<<2);
	    if( p[0] <= nw ) bits |= (1<<1);
	    if( p[0] >= pw ) bits |= (1<<0);
            return bits;
	case 2:
	    if( p[1] <= nw ) bits |= (1<<3);
	    if( p[1] >= pw ) bits |= (1<<2);
	    if( p[0] <= nw ) bits |= (1<<1);
	    if( p[0] >= pw ) bits |= (1<<0);
            return bits;
	case 1:
	    if( p[0] <= nw ) bits |= (1<<1);
	    if( p[0] >= pw ) bits |= (1<<0);
            return bits;
	default: {
		int bit = 1; 
		for( int i=0; i<nc; i++ ) {
		    if( p[i] >= pw ) bits |= bit; 
		    bit <<= 1;
		    if( p[i] <= nw ) bits |= bit; 
		    bit <<= 1;
		}
#ifdef NT
                return 0;
#else
		abort();
#endif
		break;
	    }
	}
    }
    return bits;
}

/*--------------------------------------------------------------------------
 * xformRational - transform a homogeneous point
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformRational( Maxmatrix mat, REAL *d, REAL *s )
{
    assert( hcoords >= 0 );

    if( hcoords == 3 ) {
	REAL x = s[0];
	REAL y = s[1];
	REAL z = s[2];
	d[0] = x*mat[0][0]+y*mat[1][0]+z*mat[2][0];
	d[1] = x*mat[0][1]+y*mat[1][1]+z*mat[2][1];
	d[2] = x*mat[0][2]+y*mat[1][2]+z*mat[2][2];
    } else if( hcoords == 4 ) {
	REAL x = s[0];
	REAL y = s[1];
	REAL z = s[2];
	REAL w = s[3];
	d[0] = x*mat[0][0]+y*mat[1][0]+z*mat[2][0]+w*mat[3][0];
	d[1] = x*mat[0][1]+y*mat[1][1]+z*mat[2][1]+w*mat[3][1];
	d[2] = x*mat[0][2]+y*mat[1][2]+z*mat[2][2]+w*mat[3][2];
	d[3] = x*mat[0][3]+y*mat[1][3]+z*mat[2][3]+w*mat[3][3];
    } else {
	for( int i=0; i != hcoords; i++ ) {
	    d[i] = 0;
	    for( int j = 0; j != hcoords; j++ )
		d[i] += s[j] * mat[j][i];
	}
    }
}

/*--------------------------------------------------------------------------
 * xformNonrational - transform a inhomogeneous point to a homogeneous point
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformNonrational( Maxmatrix mat, REAL *d, REAL *s )
{
    if( inhcoords == 2 ) {
	REAL x = s[0];
	REAL y = s[1];
	d[0] = x*mat[0][0]+y*mat[1][0]+mat[2][0];
	d[1] = x*mat[0][1]+y*mat[1][1]+mat[2][1];
	d[2] = x*mat[0][2]+y*mat[1][2]+mat[2][2];
    } else if( inhcoords == 3 ) {
	REAL x = s[0];
	REAL y = s[1];
	REAL z = s[2];
	d[0] = x*mat[0][0]+y*mat[1][0]+z*mat[2][0]+mat[3][0];
	d[1] = x*mat[0][1]+y*mat[1][1]+z*mat[2][1]+mat[3][1];
	d[2] = x*mat[0][2]+y*mat[1][2]+z*mat[2][2]+mat[3][2];
	d[3] = x*mat[0][3]+y*mat[1][3]+z*mat[2][3]+mat[3][3];
    } else {
        assert( inhcoords >= 0 );
	for( int i=0; i != hcoords; i++ ) {
	    d[i] = mat[inhcoords][i];
	    for( int j = 0; j < inhcoords; j++ )
		d[i] += s[j] * mat[j][i];
	}
    }
}

/*--------------------------------------------------------------------------
 * xformAndCullCheck - transform a set of points that may be EITHER 
 *	homogeneous or inhomogeneous depending on the map description and
 *	check if they are either completely inside, completely outside, 
 *	or intersecting the viewing frustrum.
 *--------------------------------------------------------------------------
 */
int
Mapdesc::xformAndCullCheck( 
    REAL *pts, int uorder, int ustride, int vorder, int vstride )
{
    assert( uorder > 0 );
    assert( vorder > 0 );

    unsigned int inbits = mask;
    unsigned int outbits = 0;

    REAL *p = pts;
    for( REAL *pend = p + uorder * ustride; p != pend; p += ustride ) {
        REAL *q = p;
        for( REAL *qend = q + vorder * vstride; q != qend; q += vstride ) {
    	    REAL cpts[MAXCOORDS];
	    xformCulling( cpts, q );
	    unsigned int bits = clipbits( cpts );
	    outbits |= bits;
	    inbits &= bits;
	    if( ( outbits == mask ) && ( inbits != mask ) ) return CULL_ACCEPT;
	} 
    }

    if( outbits != mask ) {
	return CULL_TRIVIAL_REJECT;
    } else if( inbits == mask ) {
	return CULL_TRIVIAL_ACCEPT;
    } else {
	return CULL_ACCEPT;
    }
}

/*--------------------------------------------------------------------------
 * cullCheck - check if a set of homogeneous transformed points are 
 *	either completely inside, completely outside, 
 *	or intersecting the viewing frustrum.
 *--------------------------------------------------------------------------
 */
int
Mapdesc::cullCheck( REAL *pts, int uorder, int ustride, int vorder, int vstride )
{
    unsigned int inbits = mask;
    unsigned int outbits  = 0;

    REAL *p = pts;
    for( REAL *pend = p + uorder * ustride; p != pend; p += ustride ) {
        REAL *q = p;
        for( REAL *qend = q + vorder * vstride; q != qend; q += vstride ) {
	    unsigned int bits = clipbits( q );
	    outbits |= bits;
	    inbits &= bits;
	    if( ( outbits == mask ) && ( inbits != mask ) ) return CULL_ACCEPT;
	} 
    }

    if( outbits != mask ) {
	return CULL_TRIVIAL_REJECT;
    } else if( inbits == mask ) {
	return CULL_TRIVIAL_ACCEPT;
    } else {
	return CULL_ACCEPT;
    }
}

/*--------------------------------------------------------------------------
 * cullCheck - check if a set of homogeneous transformed points are 
 *	either completely inside, completely outside, 
 *	or intersecting the viewing frustrum.
 *--------------------------------------------------------------------------
 */
int
Mapdesc::cullCheck( REAL *pts, int order, int stride )
{
    unsigned int inbits = mask;
    unsigned int outbits  = 0;

    REAL *p = pts;
    for( REAL *pend = p + order * stride; p != pend; p += stride ) {
	unsigned int bits = clipbits( p );
	outbits |= bits;
	inbits &= bits;
	if( ( outbits == mask ) && ( inbits != mask ) ) return CULL_ACCEPT;
    }

    if( outbits != mask ) {
	return CULL_TRIVIAL_REJECT;
    } else if( inbits == mask ) {
	return CULL_TRIVIAL_ACCEPT;
    } else {
	return CULL_ACCEPT;
    }
}

/*--------------------------------------------------------------------------
 * xformSampling - transform a set of points that may be EITHER 
 *	homogeneous or inhomogeneous depending on the map description 
 *	into sampling space 
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformSampling( REAL *pts, int order, int stride, REAL *sp, int outstride )
{
    xformMat( smat, pts, order, stride, sp, outstride );
}

void
Mapdesc::xformBounding( REAL *pts, int order, int stride, REAL *sp, int outstride )
{
    xformMat( bmat, pts, order, stride, sp, outstride );
}

/*--------------------------------------------------------------------------
 * xformCulling - transform a set of points that may be EITHER 
 *	homogeneous or inhomogeneous depending on the map description 
 *	into culling space 
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformCulling( REAL *pts, int order, int stride, REAL *cp, int outstride )
{
    xformMat( cmat, pts, order, stride, cp, outstride );
}

/*--------------------------------------------------------------------------
 * xformCulling - transform a set of points that may be EITHER 
 *	homogeneous or inhomogeneous depending on the map description 
 *	into culling space 
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformCulling( REAL *pts, 
    int uorder, int ustride,
    int vorder, int vstride, 
    REAL *cp, int outustride, int outvstride )
{
    xformMat( cmat, pts, uorder, ustride, vorder, vstride, cp, outustride, outvstride );
}

/*--------------------------------------------------------------------------
 * xformSampling - transform a set of points that may be EITHER 
 *	homogeneous or inhomogeneous depending on the map description 
 *	into sampling space 
 *--------------------------------------------------------------------------
 */
void
Mapdesc::xformSampling( REAL *pts, 
    int uorder, int ustride, 
    int vorder, int vstride, 
    REAL *sp, int outustride, int outvstride )
{
    xformMat( smat, pts, uorder, ustride, vorder, vstride, sp, outustride, outvstride );
}

void
Mapdesc::xformBounding( REAL *pts, 
    int uorder, int ustride, 
    int vorder, int vstride, 
    REAL *sp, int outustride, int outvstride )
{
    xformMat( bmat, pts, uorder, ustride, vorder, vstride, sp, outustride, outvstride );
}

void
Mapdesc::xformMat( 
    Maxmatrix	mat, 
    REAL *	pts, 
    int 	order, 
    int 	stride,
    REAL *	cp, 
    int 	outstride )
{
    if( isrational ) {
	REAL *pend = pts + order * stride;
	for( REAL *p = pts ; p != pend; p += stride ) {
	    xformRational( mat, cp, p );
	    cp += outstride;
	}       
    } else {
	REAL *pend = pts + order * stride;
	for( REAL *p = pts ; p != pend; p += stride ) {
	    xformNonrational( mat, cp, p );
	    cp += outstride;
	}	
    }
}

void
Mapdesc::xformMat( Maxmatrix mat, REAL *pts, 
    int uorder, int ustride, 
    int vorder, int vstride, 
    REAL *cp, int outustride, int outvstride )
{
    if( isrational ) {
	REAL *pend = pts + uorder * ustride;
	for( REAL *p = pts ; p != pend; p += ustride ) {
	    REAL *cpts2 = cp;
	    REAL *qend = p + vorder * vstride;
	    for( REAL *q = p; q != qend; q += vstride ) {
		xformRational( mat, cpts2, q );
		cpts2 += outvstride;
	    } 
	    cp += outustride;
	}
    } else {
	REAL *pend = pts + uorder * ustride;
	for( REAL *p = pts ; p != pend; p += ustride ) {
	    REAL *cpts2 = cp;
	    REAL *qend = p + vorder * vstride;
	    for( REAL *q = p; q != qend; q += vstride ) {
		xformNonrational( mat, cpts2, q );
		cpts2 += outvstride;
	    } 
	    cp += outustride;
	}
    }
}

/*--------------------------------------------------------------------------
 * subdivide - subdivide a curve along an isoparametric line
 *--------------------------------------------------------------------------
 */

void
Mapdesc::subdivide( REAL *src, REAL *dst, REAL v, int stride, int order )
{
    REAL mv = 1.0 - v;

    for( REAL *send=src+stride*order; src!=send; send-=stride, dst+=stride ) {
	copyPt( dst, src );
	REAL *qpnt = src + stride;
	for( REAL *qp=src; qpnt!=send; qp=qpnt, qpnt+=stride )
	    sumPt( qp, qp, qpnt, mv, v );
    }
}

/*--------------------------------------------------------------------------
 * subdivide - subdivide a patch along an isoparametric line
 *--------------------------------------------------------------------------
 */

void
Mapdesc::subdivide( REAL *src, REAL *dst, REAL v, 
    int so, int ss, int to, int ts  )
{
    REAL mv = 1.0 - v;

    for( REAL *slast = src+ss*so; src != slast; src += ss, dst += ss ) {
	REAL *sp = src;
	REAL *dp = dst;
        for( REAL *send = src+ts*to; sp != send; send -= ts, dp += ts ) {
	    copyPt( dp, sp );
	    REAL *qp = sp;
	    for( REAL *qpnt = sp+ts; qpnt != send; qp = qpnt, qpnt += ts )
	        sumPt( qp, qp, qpnt, mv, v );
	}
    }
}


#define sign(x)	((x > 0) ? 1 : ((x < 0.0) ? -1 : 0))

/*--------------------------------------------------------------------------
 * project - project a set of homogeneous coordinates into inhomogeneous ones
 *--------------------------------------------------------------------------
 */
int
Mapdesc::project( REAL *src, int rstride, int cstride, 
	          REAL *dest, int trstride, int tcstride,
		  int nrows, int ncols )
{
    int s = sign( src[inhcoords] );
    REAL *rlast = src + nrows * rstride;
    REAL *trptr = dest;
    for( REAL *rptr=src; rptr != rlast; rptr+=rstride, trptr+=trstride ) {
	REAL *clast = rptr + ncols * cstride;
	REAL *tcptr = trptr;
	for( REAL *cptr = rptr; cptr != clast; cptr+=cstride, tcptr+=tcstride ) {
	    REAL *coordlast = cptr + inhcoords;
	    if( sign( *coordlast ) != s ) return 0;
	    REAL *tcoord = tcptr;
	    for( REAL *coord = cptr; coord != coordlast; coord++, tcoord++ ) {
		*tcoord = *coord / *coordlast;
	    }
	}
    }
    return 1;
}

/*--------------------------------------------------------------------------
 * project - project a set of homogeneous coordinates into inhomogeneous ones
 *--------------------------------------------------------------------------
 */
int
Mapdesc::project( REAL *src, int stride, REAL *dest, int tstride, int ncols )
{
    int s = sign( src[inhcoords] );

    REAL *clast = src + ncols * stride;
    for( REAL *cptr = src, *tcptr = dest; cptr != clast; cptr+=stride, tcptr+=tstride ) {
	REAL *coordlast = cptr + inhcoords;
	if( sign( *coordlast ) != s ) return 0;
	for( REAL *coord = cptr, *tcoord = tcptr; coord != coordlast; coord++, tcoord++ ) 
	    *tcoord = *coord / *coordlast;
    }

    return 1;
}

int
Mapdesc::bboxTooBig( 
    REAL *p, 
    int	 rstride,
    int	 cstride,
    int	 nrows,
    int	 ncols,
    REAL bb[2][MAXCOORDS] )
{
    REAL bbpts[MAXORDER][MAXORDER][MAXCOORDS];
    const int trstride = sizeof(bbpts[0]) / sizeof(REAL);
    const int tcstride = sizeof(bbpts[0][0]) / sizeof(REAL); 

    // points have been transformed, therefore they are homogeneous
    // project points
    int val = project( p, rstride, cstride, 
	     &bbpts[0][0][0], trstride, tcstride, nrows, ncols );
    if( val == 0 ) return -1;

    // compute bounding box
    bbox( bb, &bbpts[0][0][0], trstride, tcstride, nrows, ncols );

    // find out if bounding box can't fit in unit cube
    if( bbox_subdividing == N_BBOXROUND ) {
	for( int k=0; k != inhcoords; k++ )
	    if( ceilf(bb[1][k]) - floorf(bb[0][k]) > bboxsize[k] ) return 1;
    } else {
	for( int k=0; k != inhcoords; k++ )
	    if( bb[1][k] - bb[0][k] > bboxsize[k] ) return 1;
    }
    return 0;  
}

void
Mapdesc::bbox( 
    REAL bb[2][MAXCOORDS], 
    REAL *p, 
    int	 rstride,
    int	 cstride,
    int	 nrows,
    int	 ncols )
{
    for( int k=0; k != inhcoords; k++ )
	 bb[0][k] = bb[1][k] = p[k];

    for( int i=0; i != nrows; i++ ) 
	for( int j=0; j != ncols; j++ ) 
	    for( k=0; k != inhcoords; k++ ) {
		REAL x = p[i*rstride + j*cstride + k];
		if(  x < bb[0][k] ) bb[0][k] = x;
		else if( x > bb[1][k] ) bb[1][k] = x;
	    }
}

/*--------------------------------------------------------------------------
 * calcVelocityRational - calculate upper bound on first partial derivative 
 *	of a homogeneous set of points and bounds on each row of points.
 *--------------------------------------------------------------------------
 */
REAL
Mapdesc::calcVelocityRational( REAL *p, int stride, int ncols )
{
    REAL tmp[MAXORDER][MAXCOORDS];

    assert( ncols <= MAXORDER );

    const int tstride = sizeof(tmp[0]) / sizeof(REAL); 

    if( project( p, stride, &tmp[0][0], tstride, ncols ) ) {
	return calcPartialVelocity( &tmp[0][0], tstride, ncols, 1, 1.0 );
    } else { /* XXX */
	return calcPartialVelocity( &tmp[0][0], tstride, ncols, 1, 1.0 );
    }
}

/*--------------------------------------------------------------------------
 * calcVelocityNonrational - calculate upper bound on  first partial 
 *	derivative of a inhomogeneous set of points.
 *--------------------------------------------------------------------------
 */
REAL
Mapdesc::calcVelocityNonrational( REAL *pts, int stride, int ncols )
{
    return calcPartialVelocity( pts, stride, ncols, 1, 1.0 );
}

int
Mapdesc::isProperty( long property )
{
    switch ( property ) {
	case N_PIXEL_TOLERANCE:
	case N_ERROR_TOLERANCE:
	case N_CULLING:
	case N_BBOX_SUBDIVIDING:
	case N_S_STEPS:
	case N_T_STEPS:
        case N_SAMPLINGMETHOD:
        case N_CLAMPFACTOR:
        case N_MINSAVINGS:
	    return 1;
	default:
	    return 0;
    }
}

REAL
Mapdesc::getProperty( long property )
{
    switch ( property ) {
	case N_PIXEL_TOLERANCE:
	    return pixel_tolerance;
	case N_ERROR_TOLERANCE:
	    return error_tolerance;
	case N_CULLING:
	    return culling_method;
	case N_BBOX_SUBDIVIDING:
	    return bbox_subdividing;
	case N_S_STEPS:
	    return s_steps;
	case N_T_STEPS:
	    return t_steps;
        case N_SAMPLINGMETHOD:
	    return sampling_method;
        case N_CLAMPFACTOR:
	    return clampfactor;
        case N_MINSAVINGS:
	    return minsavings;
	default:
#ifdef NT
            return( (REAL) 0.0 );
#else
	    abort();
	    return -1; //not necessary, needed to shut up compiler
#endif
    }
}

void
Mapdesc::setProperty( long property, REAL value )
{

    switch ( property ) {
	case N_PIXEL_TOLERANCE:
	    pixel_tolerance = value;
	    break;
	case N_ERROR_TOLERANCE:
	    error_tolerance = value;
	    break;
	case N_CULLING:
	    culling_method = value;
	    break;
	case N_BBOX_SUBDIVIDING:
	    if( value <= 0.0 ) value = N_NOBBOXSUBDIVISION;
	    bbox_subdividing = value;
	    break;
	case N_S_STEPS:
	    if( value < 0.0 ) value = 0.0;
	    s_steps = value;
	    maxrate = ( value < 0.0 ) ? 0.0 : value;
	    maxsrate = ( value < 0.0 ) ? 0.0 : value;
	    break;
	case N_T_STEPS:
	    if( value < 0.0 ) value = 0.0;
	    t_steps = value;
	    maxtrate = ( value < 0.0 ) ? 0.0 : value;
	    break;
	case N_SAMPLINGMETHOD:
	    sampling_method = value;
	    break;
	case N_CLAMPFACTOR:
	    if( value <= 0.0 ) value = N_NOCLAMPING;
	    clampfactor = value;
	    break;
	case N_MINSAVINGS:
	    if( value <= 0.0 ) value = N_NOSAVINGSSUBDIVISION;
	    minsavings = value;
	    break;
	default:
#ifndef NT
	    abort();
#endif
	    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\maplist.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * maplist.c++ - $Revision: 1.3 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "mymath.h"
#include "nurbscon.h"
#include "maplist.h"
#include "mapdesc.h"
#include "backend.h"
 
Maplist::Maplist( Backend& b )
    : mapdescPool( sizeof( Mapdesc ), 10, "mapdesc pool" ),
      backend( b )
{
    maps = 0; lastmap = &maps;
}

void 
Maplist::initialize( void )
{
    freeMaps();
    define( N_P2D, 0, 2 );
    define( N_P2DR, 1, 3 );
}

void 
Maplist::add( long type, int israt, int ncoords )
{
    *lastmap = new(mapdescPool) Mapdesc( type, israt, ncoords, backend );
    lastmap = &((*lastmap)->next);
}

void 
Maplist::define( long type, int israt, int ncoords )
{
    Mapdesc *m = locate( type );
    assert( m == NULL || ( m->isrational == israt && m->ncoords == ncoords ) );
    add( type, israt, ncoords );
}

void 
Maplist::remove( Mapdesc *m )
{
    for( Mapdesc **curmap = &maps; *curmap; curmap = &((*curmap)->next) ) {
	if( *curmap == m ) {
	    *curmap = m->next;
	    m->deleteMe( mapdescPool );
	    return;
	}
    }
#ifndef NT
    abort();
#endif
}

void
Maplist::freeMaps( void )
{
    mapdescPool.clear();
    maps = 0;
    lastmap = &maps;
}

Mapdesc * 
Maplist::find( long type )
{
    Mapdesc *val = locate( type );
    assert( val != 0 );
    return val;
}

Mapdesc * 
Maplist::locate( long type )
{
    for( Mapdesc *m = maps; m; m = m->next )
	if( m->getType() == type ) break;
    return m;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mapdesc.h ===
#ifndef __glumapdesc_h_
#define __glumapdesc_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mapdesc.h - $Revision: 1.1 $
 */

#include "mystdio.h"
#include "types.h"
#include "defines.h"
#include "bufpool.h"
#include "nurbscon.h"

typedef REAL Maxmatrix[MAXCOORDS][MAXCOORDS];

class Backend;

class Mapdesc : public PooledObj {
    friend class Maplist;
			
public:
    			Mapdesc( long, int, int, Backend & );
    int			isProperty( long );
    REAL		getProperty( long );
    void		setProperty( long, REAL );
    int			isConstantSampling( void );
    int			isDomainSampling( void );
    int			isRangeSampling( void );
    int			isSampling( void );
    int			isParametricDistanceSampling( void );
    int			isSurfaceAreaSampling( void );
    int			isPathLengthSampling( void );
    int			isCulling( void );
    int			isBboxSubdividing( void );
    long		getType( void );

    /* curve routines */
    void		subdivide( REAL *, REAL *, REAL, int, int );
    int 		cullCheck( REAL *, int, int );
    void		xformBounding( REAL *, int, int, REAL *, int );
    void		xformCulling( REAL *, int, int, REAL *, int );
    void		xformSampling( REAL *, int, int, REAL *, int );
    void		xformMat( Maxmatrix, REAL *, int, int, REAL *, int );
    REAL		calcPartialVelocity ( REAL *, int, int, int, REAL );
    int			project( REAL *, int, REAL *, int, int );
    REAL		calcVelocityRational( REAL *, int, int );
    REAL		calcVelocityNonrational( REAL *, int, int );

    /* surface routines */
    void		subdivide( REAL *, REAL *, REAL, int, int, int, int );
    int 		cullCheck( REAL *, int, int, int, int );
    void		xformBounding( REAL *, int, int, int, int, REAL *, int, int );
    void		xformCulling( REAL *, int, int, int, int, REAL *, int, int );
    void		xformSampling( REAL *, int, int, int, int, REAL *, int, int );
    void		xformMat( Maxmatrix, REAL *, int, int, int, int, REAL *, int, int );
    REAL		calcPartialVelocity ( REAL *, REAL *, int, int, int, int, int, int, REAL, REAL, int );
    int 		project( REAL *, int, int, REAL *, int, int, int, int);
    void		surfbbox( REAL bb[2][MAXCOORDS] );

    int			bboxTooBig( REAL *, int, int, int, int, REAL [2][MAXCOORDS] );
    int 		xformAndCullCheck( REAL *, int, int, int, int );

    void		identify( REAL[MAXCOORDS][MAXCOORDS] );
    void		setBboxsize( INREAL *);
    inline void 	setBmat( INREAL*, long, long );
    inline void 	setCmat( INREAL*, long, long );
    inline void 	setSmat( INREAL*, long, long );
    inline int		isRational( void );
    inline int		getNcoords( void );

    REAL 		pixel_tolerance;    /* pathlength sampling tolerance */
    REAL		error_tolerance;    /* parametric error sampling tolerance*/
    REAL 		clampfactor;
    REAL 		minsavings;
    REAL		maxrate;
    REAL		maxsrate;
    REAL		maxtrate;
    REAL		bboxsize[MAXCOORDS];

private:
    long 		type;
    int 		isrational;
    int 		ncoords;
    int 		hcoords;
    int 		inhcoords;
#ifdef NT
    unsigned int mask;
#else
    int			mask;
#endif
    Maxmatrix 		bmat;
    Maxmatrix 		cmat;
    Maxmatrix 		smat;
    REAL 		s_steps;		/* max samples in s direction */
    REAL 		t_steps;		/* max samples in t direction */
    REAL 		sampling_method;	
    REAL 		culling_method;		/* check for culling */
    REAL		bbox_subdividing;
    Mapdesc *		next;
    Backend &		backend;

    void		bbox( REAL [2][MAXCOORDS], REAL *, int, int, int, int );
    REAL		maxDifference( int, REAL *, int );
    static void 	copy( Maxmatrix, long, INREAL *, long, long );

    /* individual control point routines */
    static void		transform4d( float[4], float[4], float[4][4] );
    static void		multmatrix4d ( float[4][4], float[4][4], float[4][4] );
    void		copyPt( REAL *, REAL * );
    void		sumPt( REAL *, REAL *, REAL *, REAL, REAL );
    void		xformSampling( REAL *, REAL * );
    void		xformCulling( REAL *, REAL * );
    void		xformRational( Maxmatrix, REAL *, REAL * );
    void		xformNonrational( Maxmatrix, REAL *, REAL * );
    unsigned int	clipbits( REAL * );
};

inline void
Mapdesc::setBmat( INREAL *mat, long rstride, long cstride )
{
    copy( bmat, hcoords, mat, rstride, cstride );
}

inline void
Mapdesc::setCmat( INREAL *mat, long rstride, long cstride )
{
    copy( cmat, hcoords, mat, rstride, cstride );
}

inline void
Mapdesc::setSmat( INREAL *mat, long rstride, long cstride )
{
    copy( smat, hcoords, mat, rstride, cstride );
}

inline long
Mapdesc::getType( void )
{
    return type;
}

inline void
Mapdesc::xformCulling( REAL *d, REAL *s )
{
    if( isrational )
        xformRational( cmat, d, s );
    else
	xformNonrational( cmat, d, s );
}

inline void
Mapdesc::xformSampling( REAL *d, REAL *s )
{
    if( isrational )
        xformRational( smat, d, s );
    else
	xformNonrational( smat, d, s );
}

inline int 
Mapdesc::isRational( void )
{
    return isrational ? 1 : 0;
}

inline int		
Mapdesc::getNcoords( void ) 
{
    return ncoords; 
}

inline int			
Mapdesc::isConstantSampling( void ) 
{
    return ((sampling_method == N_FIXEDRATE) ? 1 : 0); 
}

inline int			
Mapdesc::isDomainSampling( void ) 
{ 
    return ((sampling_method == N_DOMAINDISTANCE) ? 1 : 0); 
}

inline int			
Mapdesc::isParametricDistanceSampling( void ) 
{
    return ((sampling_method == N_PARAMETRICDISTANCE) ? 1 : 0);
}

inline int			
Mapdesc::isSurfaceAreaSampling( void ) 
{
    return ((sampling_method == N_SURFACEAREA) ? 1 : 0);
}

inline int			
Mapdesc::isPathLengthSampling( void ) 
{
    return ((sampling_method == N_PATHLENGTH) ? 1 : 0);
}

inline int			
Mapdesc::isRangeSampling( void ) 
{
    return ( isParametricDistanceSampling() || isPathLengthSampling() ||
	    isSurfaceAreaSampling() );
}

inline int
Mapdesc::isSampling( void )
{
    return isRangeSampling() || isConstantSampling() || isDomainSampling();
}

inline int			
Mapdesc::isCulling( void ) 
{
    return ((culling_method != N_NOCULLING) ? 1 : 0);
}

inline int			
Mapdesc::isBboxSubdividing( void ) 
{
    return ((bbox_subdividing != N_NOBBOXSUBDIVISION) ? 1 : 0);
}
#endif /* __glumapdesc_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\maplist.h ===
#ifndef __glumaplist_h_
#define __glumaplist_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * maplist.h - $Revision: 1.4 $
 */

#include "types.h"
#include "defines.h"
#include "bufpool.h"

class Backend;
class Mapdesc;

class Maplist {
public:
			Maplist( Backend & );
    void 		define( long, int, int );
    inline void 	undefine( long );
    inline int		isMap( long );

    void 		initialize( void );
    Mapdesc * 		find( long );
    Mapdesc * 		locate( long );

private:
    Pool		mapdescPool;
    Mapdesc *		maps;
    Mapdesc **		lastmap;
    Backend &		backend;

    void 		add( long, int, int );
    void 		remove( Mapdesc * );
    void		freeMaps( void );
};

inline int
Maplist::isMap( long type )
{
    return (locate( type ) ? 1 : 0);
}

inline void 
Maplist::undefine( long type )
{
    Mapdesc *m = locate( type );
    assert( m != 0 );
    remove( m );
}
#endif /* __glumaplist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mesher.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mesher.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "mesher.h"
#include "gridvert.h"
#include "gridtrim.h"
#include "jarcloc.h"
#include "gridline.h"
#include "trimline.h"
#include "uarray.h"
#include "backend.h"


const float Mesher::ZERO = 0.0;

Mesher::Mesher( Backend& b ) 
	: backend( b ), 
	p( sizeof( GridTrimVertex ), 100, "GridTrimVertexPool" )
{
    stacksize = 0;
    vdata = 0;
    lastedge = 0; //needed to prevent purify UMR 
}

Mesher::~Mesher( void )
{
    if( vdata ) delete[] vdata;
}

void 
Mesher::init( unsigned int npts )
{
    p.clear();
    if( stacksize < npts ) {
	stacksize = 2 * npts;
	if( vdata ) delete[] vdata;		
	vdata = new GridTrimVertex_p[stacksize];
    } 
}

inline void
Mesher::push( GridTrimVertex *gt )
{
    assert( itop+1 != stacksize );
    vdata[++itop] = gt;
}

inline void
Mesher::pop( long )
{
}

inline void
Mesher::openMesh()
{
    backend.bgntmesh( "addedge" );
}

inline void
Mesher::closeMesh()
{
    backend.endtmesh();
}

inline void
Mesher::swapMesh()
{
    backend.swaptmesh();
}

inline void
Mesher::clearStack()
{
    itop = -1;
    last[0] = 0;
}

void
Mesher::finishLower( GridTrimVertex *gtlower )
{
    for( push(gtlower); 
	 nextlower( gtlower=new(p) GridTrimVertex ); 
	 push(gtlower) ) 
	    addLower();
    addLast();
}

void
Mesher::finishUpper( GridTrimVertex *gtupper )
{
    for( push(gtupper); 
	 nextupper( gtupper=new(p) GridTrimVertex ); 
	 push(gtupper) ) 
	    addUpper();
    addLast();
}

void
Mesher::mesh( void )
{
    GridTrimVertex *gtlower, *gtupper;

    Hull::init( );
    nextupper( gtupper = new(p) GridTrimVertex );
    nextlower( gtlower = new(p) GridTrimVertex );

    clearStack();
    openMesh();
    push(gtupper);

    nextupper( gtupper = new(p) GridTrimVertex );
    nextlower( gtlower );

    assert( gtupper->t && gtlower->t );
    
    if( gtupper->t->param[0] < gtlower->t->param[0] ) {
	push(gtupper);
	lastedge = 1;
	if( nextupper( gtupper=new(p) GridTrimVertex ) == 0 ) {
	    finishLower(gtlower);
	    return;
	}
    } else if( gtupper->t->param[0] > gtlower->t->param[0] ) {
	push(gtlower);
	lastedge = 0;
	if( nextlower( gtlower=new(p) GridTrimVertex ) == 0 ) {
	    finishUpper(gtupper);
	    return;
	}
    } else {
	if( lastedge == 0 ) {
	    push(gtupper);
	    lastedge = 1;
	    if( nextupper(gtupper=new(p) GridTrimVertex) == 0 ) {
		finishLower(gtlower);
		return;
	    }
	} else {
	    push(gtlower);
	    lastedge = 0;
	    if( nextlower( gtlower=new(p) GridTrimVertex ) == 0 ) {
		finishUpper(gtupper);
		return;
	    }
	}
    }

    while ( 1 ) {
	if( gtupper->t->param[0] < gtlower->t->param[0] ) {
            push(gtupper);
	    addUpper();
	    if( nextupper( gtupper=new(p) GridTrimVertex ) == 0 ) {
		finishLower(gtlower);
		return;
	    }
	} else if( gtupper->t->param[0] > gtlower->t->param[0] ) {
    	    push(gtlower);
	    addLower();
	    if( nextlower( gtlower=new(p) GridTrimVertex ) == 0 ) {
		finishUpper(gtupper);
		return;
	    }
	} else {
	    if( lastedge == 0 ) {
		push(gtupper);
		addUpper();
		if( nextupper( gtupper=new(p) GridTrimVertex ) == 0 ) {
		    finishLower(gtlower);
		    return;
		}
	    } else {
		push(gtlower);
		addLower();
		if( nextlower( gtlower=new(p) GridTrimVertex ) == 0 ) {
		    finishUpper(gtupper);
		    return;
		}
	    }
	}
    }
}

inline int
Mesher::isCcw( int ilast )
{
    REAL area = det3( vdata[ilast]->t, vdata[itop-1]->t, vdata[itop-2]->t );
    return (area < ZERO) ? 0 : 1;
}

inline int
Mesher::isCw( int ilast  )
{
    REAL area = det3( vdata[ilast]->t, vdata[itop-1]->t, vdata[itop-2]->t );
    return (area > -ZERO) ? 0 : 1;
}

inline int
Mesher::equal( int x, int y )
{
    return( last[0] == vdata[x] && last[1] == vdata[y] );
}

inline void
Mesher::copy( int x, int y )
{
    last[0] = vdata[x]; last[1] = vdata[y];
}
 
inline void
Mesher::move( int x, int y ) 
{
    vdata[x] = vdata[y];
}

inline void
Mesher::output( int x )
{
    backend.tmeshvert( vdata[x] );
}

/*---------------------------------------------------------------------------
 * addedge - addedge an edge to the triangulation
 *
 *	This code has been re-written to generate large triangle meshes
 *	from a monotone polygon.  Although smaller triangle meshes
 *	could be generated faster and with less code, larger meshes
 *	actually give better SYSTEM performance.  This is because
 *	vertices are processed in the backend slower than they are
 *	generated by this code and any decrease in the number of vertices
 *	results in a decrease in the time spent in the backend.
 *---------------------------------------------------------------------------
 */

void
Mesher::addLast( )
{
    register int ilast = itop;

    if( lastedge == 0 ) {
	if( equal( 0, 1 ) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i = 2; i < ilast; i++ ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, ilast-1 );
	} else if( equal( ilast-2, ilast-1) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i = ilast-3; i >= 0; i-- ) {
		output( i );
		swapMesh();
	    }
	    copy( 0, ilast );
	} else {
	    closeMesh();	openMesh();
	    output( ilast );
	    output( 0 );
	    for( register int i = 1; i < ilast; i++ ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, ilast-1 );
	}
    } else {
	if( equal( 1, 0) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i = 2; i < ilast; i++ ) {
		output( i );
		swapMesh();
	    }
	    copy( ilast-1, ilast );
	} else if( equal( ilast-1, ilast-2) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i = ilast-3; i >= 0; i-- ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, 0 );
	} else {
	    closeMesh();	openMesh();
	    output( 0 );
	    output( ilast );
	    for( register int i = 1; i < ilast; i++ ) {
		output( i );
		swapMesh();
	    }
	    copy( ilast-1, ilast );
	}
    }
    closeMesh();
    //for( register long k=0; k<=ilast; k++ ) pop( k );
}

void
Mesher::addUpper( )
{
    register int ilast = itop;

    if( lastedge == 0 ) {
	if( equal( 0, 1 ) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i = 2; i < ilast; i++ ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, ilast-1 );
	} else if( equal( ilast-2, ilast-1) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i = ilast-3; i >= 0; i-- ) {
		output( i );
		swapMesh();
	    }
	    copy( 0, ilast );
	} else {
	    closeMesh();	openMesh();
	    output( ilast );
	    output( 0 );
	    for( register int i = 1; i < ilast; i++ ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, ilast-1 );
	}
	lastedge = 1;
        //for( register long k=0; k<ilast-1; k++ ) pop( k );
	move( 0, ilast-1 );
	move( 1, ilast );
	itop = 1;
    } else {
	if( ! isCcw( ilast ) ) return;
	do {
	    itop--;
	} while( (itop > 1) && isCcw( ilast ) );

	if( equal( ilast-1, ilast-2 ) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i=ilast-3; i>=itop-1; i-- ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, itop-1 );
	} else if( equal( itop, itop-1 ) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i = itop+1; i < ilast; i++ ) {
		output( i );
		swapMesh();
	    }
	    copy( ilast-1, ilast );
	} else {
	    closeMesh();	openMesh();
	    output( ilast );
	    output( ilast-1 );
	    for( register int i=ilast-2; i>=itop-1; i-- ) {
		swapMesh();
		output( i );
	    } 
	    copy( ilast, itop-1 );
	}
        //for( register int k=itop; k<ilast; k++ ) pop( k );
	move( itop, ilast );
    }
}

void
Mesher::addLower()
{
    register int ilast = itop;

    if( lastedge == 1 ) {
	if( equal( 1, 0) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i = 2; i < ilast; i++ ) {
		output( i );
		swapMesh();
	    }
	    copy( ilast-1, ilast );
	} else if( equal( ilast-1, ilast-2) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i = ilast-3; i >= 0; i-- ) {
		swapMesh();
		output( i );
	    }
	    copy( ilast, 0 );
	} else {
	    closeMesh();	openMesh();
	    output( 0 );
	    output( ilast );
	    for( register int i = 1; i < ilast; i++ ) {
		output( i );
		swapMesh();
	    }
	    copy( ilast-1, ilast );
	}

	lastedge = 0;
        //for( register long k=0; k<ilast-1; k++ ) pop( k );
	move( 0, ilast-1 );
	move( 1, ilast );
	itop = 1;
    } else {
	if( ! isCw( ilast ) ) return;
	do {
	    itop--;
	} while( (itop > 1) && isCw( ilast ) );

	if( equal( ilast-2, ilast-1) ) {
	    swapMesh();
	    output( ilast );
	    for( register int i=ilast-3; i>=itop-1; i--) {
		output( i );
		swapMesh( );
	    }
	    copy( itop-1, ilast );
	} else if( equal( itop-1, itop) ) {
	    output( ilast );
	    swapMesh();
	    for( register int i=itop+1; i<ilast; i++ ) {
		swapMesh( );
		output( i );
	    }
	    copy( ilast, ilast-1 );
	} else {
	    closeMesh();	openMesh();
	    output( ilast-1 );
	    output( ilast );
	    for( register int i=ilast-2; i>=itop-1; i-- ) {
		output( i );
		swapMesh( );
	    }
	    copy( itop-1, ilast );
	}
        //for( register int k=itop; k<ilast; k++ ) pop( k );
	move( itop, ilast );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mesher.h ===
#ifndef __glumesher_h_
#define __glumesher_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mesher.h - $Revision: 1.1 $
 */

#include "hull.h"

class TrimRegion;
class Backend;
class Pool;
class GridTrimVertex;


class Mesher : public Hull {
public:
     			Mesher( Backend & );
			~Mesher( void );
    void		init( unsigned int );
    void		mesh( void );

private:
    static const float	ZERO;
    Backend&		backend;

    Pool		p;
    unsigned int	stacksize;
    GridTrimVertex **	vdata;
    GridTrimVertex *	last[2];
    int			itop;
    int			lastedge;

    inline void		openMesh( void );
    inline void		swapMesh( void );
    inline void		closeMesh( void );
    inline int		isCcw( int );
    inline int		isCw( int );
    inline void		clearStack( void );
    inline void		push( GridTrimVertex * );
    inline void		pop( long );
    inline void		move( int, int );
    inline int 		equal( int, int );
    inline void 	copy( int, int );
    inline void 	output( int );
    void		addUpper( void );
    void		addLower( void );
    void		addLast( void );
    void		finishUpper( GridTrimVertex * );
    void		finishLower( GridTrimVertex * );
};
#endif /* __glumesher_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\monotoni.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * monotonizer.c++ - $Revision: 1.5 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "arc.h"
#include "arctess.h"
#include "bezierar.h"
#include "bin.h"
#include "mapdesc.h"
#include "nurbscon.h"
#include "subdivid.h"

/*-----------------------------------------------------------------------------
 * Subdivider::decompose - break all curves into monotone arcs
 *-----------------------------------------------------------------------------
 */
int
Subdivider::decompose( Bin& bin, REAL geo_stepsize )
{
    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	if( ! jarc->isTessellated() ) {
	    /* points have not been transformed, therefore they may be either
	       homogeneous or inhomogeneous */
	    tessellate( jarc, geo_stepsize );
	    if( jarc->isDisconnected() || jarc->next->isDisconnected() ) 
		return 1;
	}
    }

    for( jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	monotonize( jarc, bin );
    }

#ifndef NDEBUG
    for( jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	assert( isMonotone( jarc ) != 0 );
    }
#endif

    return 0;
}

void
Subdivider::tessellate( Arc_ptr jarc, REAL geo_stepsize )
{
    BezierArc *b = jarc->bezierArc;
    Mapdesc *mapdesc = b->mapdesc;

    if( mapdesc->isRational() ) {
	REAL max = mapdesc->calcVelocityRational( b->cpts, b->stride, b->order );
	REAL arc_stepsize = (max > 1.0) ? (1.0/max) : 1.0; 
	if( jarc->bezierArc->order != 2 )
	    arctessellator.tessellateNonlinear( jarc, geo_stepsize, arc_stepsize, 1 );
	else {
	    arctessellator.tessellateLinear( jarc, geo_stepsize, arc_stepsize, 1 );
	}
    } else { 
	REAL max = mapdesc->calcVelocityNonrational( b->cpts, b->stride, b->order );
	REAL arc_stepsize = (max > 1.0) ? (1.0/max) : 1.0; 
	if( jarc->bezierArc->order != 2 )
	    arctessellator.tessellateNonlinear( jarc, geo_stepsize, arc_stepsize, 0 );
	else {
	    arctessellator.tessellateLinear( jarc, geo_stepsize, arc_stepsize, 0 );
	}
    }
}

/*-------------------------------------------------------------------------
 * Subdivider::monotonize - break up a jordan arc into s,t-monotone
 *	components.  This code will remove degenerate segments, including
 *	arcs of only a single point.
 *-------------------------------------------------------------------------
 */
void
Subdivider::monotonize( Arc_ptr jarc, Bin& bin )
{
    TrimVertex  *firstvert = jarc->pwlArc->pts;
    TrimVertex  *lastvert = firstvert + (jarc->pwlArc->npts - 1);
    long	uid = jarc->nuid;
    arc_side	side = jarc->getside();
    dir		sdir = none;
    dir		tdir = none;
    int 	degenerate = 1;

    int		nudegenerate;
    int		change;

    for( TrimVertex *vert = firstvert; vert != lastvert; vert++ ) {

        nudegenerate = 1;
        change = 0;

	/* check change relative to s axis, clear degenerate bit if needed */
        REAL sdiff = vert[1].param[0] - vert[0].param[0]; 
        if( sdiff == 0 ) {
	    if( sdir != same ) {
	        sdir = same;
		change = 1;
	    }
        } else if( sdiff < 0.0 ) {
	    if( sdir != down ) {
	        sdir = down;
		change = 1;
	    }
	    nudegenerate = 0;
        } else {
	    if( sdir != up ) {
	        sdir = up;
		change = 1;
	    }
	    nudegenerate = 0;
        }
    
	/* check change relative to t axis, clear degenerate bit if needed */
        REAL tdiff = vert[1].param[1] - vert[0].param[1]; 
        if( tdiff == 0 ) { 
	    if( tdir != same ) {
	        tdir = same;
	 	change = 1;
	    }
        } else if( tdiff < 0.0 ) {
	    if( tdir != down ) {
	        tdir = down;
		change = 1;
	    }
	    nudegenerate = 0;
        } else {
	    if( tdir != up ) {
	        tdir = up;
		change = 1;
	    }
	    nudegenerate = 0;
        }
    
	if( change ) {
	    if( ! degenerate ) {
	        /* make last segment into separate pwl curve */
	        jarc->pwlArc->npts = vert - firstvert + 1;
#ifdef NT
                // This works under NT.

                Arc_ptr prevjarc;

                prevjarc = jarc;
                jarc     = new(arcpool) Arc( side, uid );

                jarc->append( prevjarc );

#else
                // However this doesn't.
	        jarc = new(arcpool) Arc( side, uid )->append( jarc );
#endif
	        jarc->pwlArc = new(pwlarcpool) PwlArc();
		bin.addarc( jarc );
	    }
	    firstvert = jarc->pwlArc->pts = vert;
	    degenerate = nudegenerate;
	} 
    }
    jarc->pwlArc->npts = vert - firstvert + 1;

    if( degenerate ) {
	/* remove jarc from circularly linked list */
	jarc->prev->next = jarc->next;
	jarc->next->prev = jarc->prev;

        assert( jarc->prev->check(  ) != 0 );
        assert( jarc->next->check(  ) != 0 );

	/* remove jarc from bin */
	bin.remove_this_arc( jarc  );

	jarc->pwlArc->deleteMe( pwlarcpool ); jarc->pwlArc = 0;
	jarc->deleteMe( arcpool );
    } 
}

/*-------------------------------------------------------------------------
 * Subdivider::isMonotone - return true if arc is monotone AND non-degenerate
 *-------------------------------------------------------------------------
 */
int
Subdivider::isMonotone( Arc_ptr jarc )
{
    TrimVertex  *firstvert = jarc->pwlArc->pts;
    TrimVertex  *lastvert = firstvert + (jarc->pwlArc->npts - 1);

    if( firstvert == lastvert ) return 1;

    TrimVertex	*vert = firstvert;
    enum dir	sdir;
    enum dir	tdir;

    REAL diff = vert[1].param[0] - vert[0].param[0]; 
    if( diff == 0.0 ) 
        sdir = same;
    else if( diff < 0.0 )
        sdir = down;
    else
        sdir = up;

    diff = vert[1].param[1] - vert[0].param[1]; 
    if( diff == 0.0 ) 
        tdir = same;
    else if( diff < 0.0 )
        tdir = down;
    else
        tdir = up;

    if( (sdir == same) && (tdir == same) ) return 0;
    
    for( ++vert ; vert != lastvert; vert++ ) {
        diff = vert[1].param[0] - vert[0].param[0]; 
        if( diff == 0.0 ) {
	    if( sdir != same ) return 0;
        } else if( diff < 0.0 ) {
	    if( sdir != down ) return 0;
        } else {
	    if( sdir != up ) return 0;
        }

        diff = vert[1].param[1] - vert[0].param[1]; 
        if( diff == 0.0 ) {
	    if( tdir != same ) return 0;
        } else if( diff < 0.0 ) {
	    if( tdir != down ) return 0;
        } else {
	    if( tdir != up ) return 0;
        }
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\monotoni.h ===
#ifndef __glumonotonizer_h_
#define __glumonotonizer_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * monotonizer.h - $Revision: 1.1 $
 */

#include "mysetjmp.h"
#include "types.h"

class Arc;
class ArcTessellator;
class Pool;
class Bin;
class PwlArcPool;
class Mapdesc;

class Monotonizer {
    ArcTessellator&	arctessellator;
    Pool&		arcpool;
    Pool&		pwlarcpool;
    jmp_buf&		nurbsJmpBuf;

    enum dir 		{ down, same, up, none };
    void		tessellate( Arc *, REAL );
    void		monotonize( Arc *, Bin & );
    int			isMonotone( Arc * );
public:
    			Monotonizer( ArcTessellator& at, Pool& ap, Pool& p, jmp_buf& j ) 
				: arctessellator(at), arcpool(ap), pwlarcpool(p), nurbsJmpBuf(j) {}
    int			decompose( Bin &, REAL );
};
#endif /* __glumonotonizer_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mapdescv.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mapdescv.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "mystring.h"
#include "mymath.h"
#include "nurbscon.h"
#include "mapdesc.h"

/*--------------------------------------------------------------------------
 * calcPartialVelocity - calculate maximum magnitude of a given partial
 * derivative
 *--------------------------------------------------------------------------
 */
REAL
Mapdesc::calcPartialVelocity (
    REAL *p,
    int	 stride,
    int	 ncols,
    int  partial,
    REAL range )
{
    REAL tmp[MAXORDER][MAXCOORDS];
    REAL mag[MAXORDER];

    assert( ncols <= MAXORDER );

    int j, k, t;
    // copy inhomogeneous control points into temporary array
    for( j=0; j != ncols; j++ ) 
	for( k=0; k != inhcoords; k++ )
	    tmp[j][k] = p[j*stride + k];

    for( t=0; t != partial; t++ ) 
	for( j=0; j != ncols-t-1; j++ ) 
	    for( k=0; k != inhcoords; k++ ) 
		tmp[j][k] = tmp[j+1][k] - tmp[j][k];

    // compute magnitude and store in mag array
    for( j=0; j != ncols-partial; j++ ) {
	mag[j] = 0.0;
	for( k=0; k != inhcoords; k++ )
	    mag[j] += tmp[j][k] * tmp[j][k];
    }

    // compute scale factor
    REAL fac = 1;
    REAL invt = 1.0 / range;
    for( t = ncols-1; t != ncols-1-partial; t-- ) 
	fac *= t * invt;

    // compute max magnitude of all entries in array
    REAL max = 0.0;
    for( j=0; j != ncols-partial; j++ )
	if( mag[j] > max ) max = mag[j];
    max = fac * ::sqrtf( (float) max );

    return max;
}

/*--------------------------------------------------------------------------
 * calcPartialVelocity - calculate maximum magnitude of a given partial
 * derivative
 *--------------------------------------------------------------------------
 */
REAL
Mapdesc::calcPartialVelocity (
    REAL *dist,
    REAL *p,
    int	 rstride,
    int	 cstride,
    int	 nrows,
    int	 ncols,
    int  spartial,
    int  tpartial,
    REAL srange, 
    REAL trange,
    int  side )
{
    REAL tmp[MAXORDER][MAXORDER][MAXCOORDS];
    REAL mag[MAXORDER][MAXORDER];

    assert( nrows <= MAXORDER );
    assert( ncols <= MAXORDER );

    REAL *tp = &tmp[0][0][0];
    REAL *mp = &mag[0][0];
    const int istride = sizeof( tmp[0]) / sizeof( tmp[0][0][0] );
    const int jstride = sizeof( tmp[0][0]) / sizeof( tmp[0][0][0] );
    const int kstride = sizeof( tmp[0][0][0]) / sizeof( tmp[0][0][0] );
    const int mistride = sizeof( mag[0]) / sizeof( mag[0][0] );
    const int mjstride = sizeof( mag[0][0]) / sizeof( mag[0][0] );
    const int idist = nrows * istride;
    const int jdist = ncols * jstride;
    const int kdist = inhcoords * kstride;
    const int id = idist - spartial * istride;
    const int jd = jdist - tpartial * jstride;

    {
	// copy control points
	REAL *ti = tp;
	REAL *qi = p;
	REAL *til = tp + idist;
	for( ; ti != til; ) {
	    REAL *tj = ti;
	    REAL *qj = qi;
	    REAL *tjl = ti + jdist;
	    for( ; tj != tjl;  ) {
		for( int k=0; k != inhcoords; k++ ) {
		    tj[k] = qj[k];
		}
		tj += jstride;
		qj += cstride;
	    }
	    ti += istride;
	    qi += rstride; 
	}
    }

    {
        // compute (s)-partial derivative control points
	REAL *til = tp + idist - istride;
	const REAL *till = til - ( spartial * istride );
	for( ; til != till; til -= istride )
	    for( REAL *ti = tp; ti != til; ti += istride )
		for( REAL *tj = ti, *tjl = tj + jdist; tj != tjl; tj += jstride )
		    for( int k=0; k != inhcoords; k++ )
			tj[k] = tj[k+istride] - tj[k];
    }

    {
        // compute (s,t)-partial derivative control points
	REAL *tjl = tp + jdist - jstride;
	const REAL *tjll = tjl - ( tpartial * jstride );
	for( ; tjl != tjll; tjl -= jstride )
	    for( REAL *tj = tp; tj != tjl; tj += jstride )
		for( REAL *ti = tj, *til = ti + id; ti != til; ti += istride )
		    for( int k=0; k != inhcoords; k++ ) 
			ti[k] = ti[k+jstride] - ti[k];

    }

    REAL max = 0.0;
    {
	// compute magnitude and store in mag array
	memset( (void *) mp, 0, sizeof( mag ) );
	for( REAL *ti = tp, *mi = mp, *til = tp + id; ti != til; ti += istride, mi += mistride )
	    for( REAL *tj = ti, *mj = mi, *tjl = ti + jd; tj != tjl; tj += jstride, mj += mjstride ) {
		for( int k=0; k != inhcoords; k++ )
		   *mj += tj[k] * tj[k];
		if( *mj > max ) max = *mj;
	    }

    }

    int i, j;

    // compute scale factor
    REAL fac = 1.0;
    {
	REAL invs = 1.0 / srange;
	REAL invt = 1.0 / trange;
	for( int s = nrows-1, slast = s-spartial; s != slast; s-- ) 
	    fac *= s * invs;
	for( int t = ncols-1, tlast = t-tpartial; t != tlast; t-- ) 
	    fac *= t * invt;
    }

    if( side == 0 ) {
	// compute max magnitude of first and last column
	dist[0] = 0.0;
	dist[1] = 0.0;
	for( i=0; i != nrows-spartial; i++ ) {
	    j = 0;
	    if( mag[i][j] > dist[0] ) dist[0] = mag[i][j];
    
	    j = ncols-tpartial-1;
	    if( mag[i][j] > dist[1] ) dist[1] = mag[i][j];
	}
	dist[0] = fac * ::sqrtf( dist[0] );
	dist[1] = fac * ::sqrtf( dist[1] );
    } else if( side == 1 ) {
	// compute max magnitude of first and last row
	dist[0] = 0.0;
	dist[1] = 0.0;
	for( j=0; j != ncols-tpartial; j++ ) {
	    i = 0;
	    if( mag[i][j] > dist[0] ) dist[0] = mag[i][j];
    
	    i = nrows-spartial-1;
	    if( mag[i][j] > dist[1] ) dist[1] = mag[i][j];
	}
	dist[0] = fac * ::sqrtf( dist[0] );
	dist[1] = fac * ::sqrtf( dist[1] );
    }

    max = fac * ::sqrtf( (float) max );

    return max;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\myassert.h ===
#ifndef __glumyassert_h_
#define __glumyassert_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * myassert.h - $Revision: 1.1 $
 */

#ifdef STANDALONE
#define assert(EX) ((void)0)
#endif

#ifdef LIBRARYBUILD
#include <assert.h>
#endif

#ifdef GLBUILD
#define assert(EX) ((void)0)
#endif

#endif /* __glumyassert_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mycode.cxx ===
#include "mymath.h"

#ifdef NEEDCEILF

float ceilf( float x )
{
   if( x < 0 ) {
	float nx = -x;
	int ix = (int) nx;
	return (float) -ix;
   } else {
	int ix = (int) x;
	if( x == (float) ix ) return x;
	return (float) (ix+1);
   }
}

float floorf( float x )
{
   if( x < 0 ) {
	float nx = -x;
	int ix = (int) nx;
	if( nx == (float) ix ) return x;
	return (float) -(ix+1);
   } else {
	int ix = (int) x;
	return (float) ix;
   }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mybstrin.h ===
#ifndef __glumybstring_h_
#define __glumybstring_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mybstring.h - $Revision: 1.1 $
 */

#ifdef STANDALONE
extern "C" void	bcopy(const void *, void *, int);
extern "C" void	bzero(void *, int);
#else
#include <bstring.h>
#endif

#endif /* __glumybstring_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mymath.h ===
#ifndef __glumymath_h_
#define __glumymath_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mymath.h - $Revision: 1.1 $
 */

#ifdef GLBUILD
#define sqrtf		gl_fsqrt
#endif

#if GLBUILD | STANDALONE
#define M_SQRT2		1.41421356237309504880
#define ceilf		myceilf
#define floorf		myfloorf	
#define sqrtf		sqrt
extern "C" double	sqrt(double);
extern "C" float	ceilf(float);
extern "C" float	floorf(float);
#define NEEDCEILF
#endif

#ifdef LIBRARYBUILD
#include <math.h>
#endif

#endif /* __glumymath_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mystdio.h ===
#ifndef __glumystdio_h_
#define __glumystdio_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mystdio.h - $Revision: 1.4 $
 */

#ifdef STANDALONE
inline void dprintf( char *, ... ) { }
#endif

#ifdef LIBRARYBUILD
#ifndef NDEBUG
#include <stdio.h>
#define dprintf printf
#else
inline void dprintf( char *, ... ) { }
#endif
#endif

#ifdef GLBUILD
inline void dprintf( char *, ... ) { }
#endif

#ifndef NULL
#define NULL		0
#endif

#endif /* __glumystdio_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mystdlib.h ===
#ifndef __glumystdlib_h_
#define __glumystdlib_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mystdlib.h - $Revision: 1.1 $
 */

#ifdef STANDALONE
#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

extern "C" void 	abort( void );
extern "C" void *	malloc( size_t );
extern "C" void 	free( void * );
#endif

#ifdef LIBRARYBUILD
#include <stdlib.h>
#endif

#ifdef GLBUILD
#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

extern "C" void 	abort( void );
extern "C" void *	malloc( size_t );
extern "C" void 	free( void * );
#endif

#endif /* __glumystdlib_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mysetjmp.h ===
#ifndef __glumysetjmp_h_
#define __glumysetjmp_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mysetjmp.h - $Revision: 1.3 $
 */

#ifdef STANDALONE
struct JumpBuffer;
#ifdef NT
extern "C" JumpBuffer * GLOS_CCALL newJumpbuffer( void );
extern "C" void GLOS_CCALL deleteJumpbuffer(JumpBuffer *);
extern "C" void GLOS_CCALL mylongjmp( JumpBuffer *, int );
extern "C" int GLOS_CCALL mysetjmp( JumpBuffer * );
#else
extern "C" JumpBuffer *newJumpbuffer( void );
extern "C" void deleteJumpbuffer(JumpBuffer *);
extern "C" void mylongjmp( JumpBuffer *, int );
extern "C" int mysetjmp( JumpBuffer * );
#endif // NT
#endif

extern "C" DWORD gluMemoryAllocationFailed;

#ifdef GLBUILD
#define setjmp		gl_setjmp
#define longjmp 	gl_longjmp
#endif

#if LIBRARYBUILD | GLBUILD | defined(NT)
#include <setjmp.h>
#ifndef NT
#include <stdlib.h>
#endif

struct JumpBuffer {
    jmp_buf	buf;
};

#ifdef NT
inline JumpBuffer * GLOS_CCALL
#else
inline JumpBuffer *
#endif
newJumpbuffer( void )
{
#ifdef NT
    JumpBuffer *tmp;
    tmp = (JumpBuffer *) LocalAlloc(LMEM_FIXED, sizeof(JumpBuffer));
    if (tmp == NULL) gluMemoryAllocationFailed++;
    return tmp;
#else
    return (JumpBuffer *) malloc( sizeof( JumpBuffer ) );
#endif
}

#ifdef NT
inline void GLOS_CCALL
#else
inline void
#endif
deleteJumpbuffer(JumpBuffer *jb)
{
#ifdef NT
   LocalFree( (HLOCAL) jb);
#else
   free( (void *) jb);
#endif
}

#ifdef NT
inline void GLOS_CCALL
#else
inline void
#endif
mylongjmp( JumpBuffer *j, int code ) 
{
    ::longjmp( j->buf, code );
}

#ifdef NT
inline int GLOS_CCALL
#else
inline int
#endif
mysetjmp( JumpBuffer *j )
{
    return ::setjmp( j->buf );
}
#endif

#endif /* __glumysetjmp_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\mystring.h ===
#ifndef __glumystring_h_
#define __glumystring_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * mystring.h - $Revision: 1.1 $
 */

#ifdef STANDALONE

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifdef NT
extern "C" void *	GLOS_CCALL memcpy(void *, const void *, size_t);
extern "C" void *	GLOS_CCALL memset(void *, int, size_t);
#else
extern "C" void *	memcpy(void *, const void *, size_t);
extern "C" void *	memset(void *, int, size_t);
#endif
#endif

#ifdef GLBUILD
#define memcpy(a,b,c)	bcopy(b,a,c)
#define memset(a,b,c)	bzero(a,c)
extern "C" void		bcopy(const void *, void *, int);
extern "C" void		bzero(void *, int);
#endif

#ifdef LIBRARYBUILD
#include <string.h>
#endif

#endif /* __glumystring_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\patch.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by ederal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * patch.c++ - $Revision: 1.4 $
 * 	Derrick Burns - 1992
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "mymath.h"
#include "mystring.h"
#include "patch.h"
#include "mapdesc.h"
#include "quilt.h"
#include "nurbscon.h"
#include "simplema.h" //for abs function in ::singleStep();


/*--------------------------------------------------------------------------
 * Patch - copy patch from quilt and transform control points
 *--------------------------------------------------------------------------
 */

Patch::Patch( Quilt_ptr geo, REAL *pta, REAL *ptb, Patch *n )
{
/* pspec[i].range is uninit here */
    mapdesc = geo->mapdesc;
    cullval = mapdesc->isCulling() ? CULL_ACCEPT : CULL_TRIVIAL_ACCEPT;
    notInBbox = mapdesc->isBboxSubdividing() ? 1 : 0;
    needsSampling = mapdesc->isRangeSampling() ? 1 : 0;
    pspec[0].order = geo->qspec[0].order;
    pspec[1].order = geo->qspec[1].order;
    pspec[0].stride = pspec[1].order * MAXCOORDS;
    pspec[1].stride = MAXCOORDS;

    /* transform control points to sampling and culling spaces */
    REAL *ps  = geo->cpts;
    geo->select( pta, ptb );
    ps += geo->qspec[0].offset;
    ps += geo->qspec[1].offset;
    ps += geo->qspec[0].index * geo->qspec[0].order * geo->qspec[0].stride;
    ps += geo->qspec[1].index * geo->qspec[1].order * geo->qspec[1].stride;

    if( needsSampling ) {
	mapdesc->xformSampling( ps, geo->qspec[0].order, geo->qspec[0].stride, 
				geo->qspec[1].order, geo->qspec[1].stride,
			        spts, pspec[0].stride, pspec[1].stride );
    }

    if( cullval == CULL_ACCEPT  ) {
	mapdesc->xformCulling( ps, geo->qspec[0].order, geo->qspec[0].stride, 
			       geo->qspec[1].order, geo->qspec[1].stride,
			       cpts, pspec[0].stride, pspec[1].stride ); 
    }
    
    if( notInBbox ) {
	mapdesc->xformBounding( ps, geo->qspec[0].order, geo->qspec[0].stride, 
			       geo->qspec[1].order, geo->qspec[1].stride,
			       bpts, pspec[0].stride, pspec[1].stride ); 
    }
    
    /* set scale range */
    pspec[0].range[0] = geo->qspec[0].breakpoints[geo->qspec[0].index];
    pspec[0].range[1] = geo->qspec[0].breakpoints[geo->qspec[0].index+1];
    pspec[0].range[2] = pspec[0].range[1] - pspec[0].range[0];

    pspec[1].range[0] = geo->qspec[1].breakpoints[geo->qspec[1].index];
    pspec[1].range[1] = geo->qspec[1].breakpoints[geo->qspec[1].index+1];
    pspec[1].range[2] = pspec[1].range[1] - pspec[1].range[0];

    // may need to subdivide to match range of sub-patch
    if( pspec[0].range[0] != pta[0] ) {
	assert( pspec[0].range[0] < pta[0] );
	Patch lower( *this, 0, pta[0], 0 );
	*this = lower;
    }

    if( pspec[0].range[1] != ptb[0] ) {
	assert( pspec[0].range[1] > ptb[0] );
	Patch upper( *this, 0, ptb[0], 0 );
    }

    if( pspec[1].range[0] != pta[1] ) {
	assert( pspec[1].range[0] < pta[1] );
	Patch lower( *this, 1, pta[1], 0 );
	*this = lower;
    }

    if( pspec[1].range[1] != ptb[1] ) {
	assert( pspec[1].range[1] > ptb[1] );
	Patch upper( *this, 1, ptb[1], 0 );
    }
    checkBboxConstraint();
    next = n;
}

/*--------------------------------------------------------------------------
 * Patch - subdivide a patch along an isoparametric line
 *--------------------------------------------------------------------------
 */

Patch::Patch( Patch& upper, int param, REAL value, Patch *n )
{
    Patch& lower = *this;

    lower.cullval = upper.cullval;
    lower.mapdesc = upper.mapdesc;
    lower.notInBbox = upper.notInBbox;
    lower.needsSampling = upper.needsSampling;
    lower.pspec[0].order = upper.pspec[0].order;
    lower.pspec[1].order = upper.pspec[1].order;
    lower.pspec[0].stride = upper.pspec[0].stride;
    lower.pspec[1].stride = upper.pspec[1].stride;
    lower.next = n;

    /* reset scale range */
    switch( param ) {
	case 0: {
    	    REAL d = (value-upper.pspec[0].range[0]) / upper.pspec[0].range[2];
	    if( needsSampling )
                mapdesc->subdivide( upper.spts, lower.spts, d, pspec[1].order,
                        pspec[1].stride, pspec[0].order, pspec[0].stride );

    	    if( cullval == CULL_ACCEPT ) 
	        mapdesc->subdivide( upper.cpts, lower.cpts, d, pspec[1].order,
                        pspec[1].stride, pspec[0].order, pspec[0].stride );

    	    if( notInBbox ) 
	        mapdesc->subdivide( upper.bpts, lower.bpts, d, pspec[1].order,
                        pspec[1].stride, pspec[0].order, pspec[0].stride );
	    
            lower.pspec[0].range[0] = upper.pspec[0].range[0];
            lower.pspec[0].range[1] = value;
    	    lower.pspec[0].range[2] = value - upper.pspec[0].range[0];
            upper.pspec[0].range[0] = value;
    	    upper.pspec[0].range[2] = upper.pspec[0].range[1] - value;

            lower.pspec[1].range[0] = upper.pspec[1].range[0];
            lower.pspec[1].range[1] = upper.pspec[1].range[1];
    	    lower.pspec[1].range[2] = upper.pspec[1].range[2];
	    break;
	}
	case 1: {
    	    REAL d = (value-upper.pspec[1].range[0]) / upper.pspec[1].range[2];
	    if( needsSampling )
	        mapdesc->subdivide( upper.spts, lower.spts, d, pspec[0].order,
                        pspec[0].stride, pspec[1].order, pspec[1].stride );
    	    if( cullval == CULL_ACCEPT ) 
	        mapdesc->subdivide( upper.cpts, lower.cpts, d, pspec[0].order,
                        pspec[0].stride, pspec[1].order, pspec[1].stride );
    	    if( notInBbox ) 
	        mapdesc->subdivide( upper.bpts, lower.bpts, d, pspec[0].order,
                        pspec[0].stride, pspec[1].order, pspec[1].stride );
            lower.pspec[0].range[0] = upper.pspec[0].range[0];
            lower.pspec[0].range[1] = upper.pspec[0].range[1];
    	    lower.pspec[0].range[2] = upper.pspec[0].range[2];

            lower.pspec[1].range[0] = upper.pspec[1].range[0];
            lower.pspec[1].range[1] = value;
    	    lower.pspec[1].range[2] = value - upper.pspec[1].range[0];
            upper.pspec[1].range[0] = value;
    	    upper.pspec[1].range[2] = upper.pspec[1].range[1] - value;
	    break;
	}
    }

    // inherit bounding box
    if( mapdesc->isBboxSubdividing() && ! notInBbox )
	memcpy( lower.bb, upper.bb, sizeof( bb ) );
	    
    lower.checkBboxConstraint();
    upper.checkBboxConstraint();
}

/*--------------------------------------------------------------------------
 * clamp - clamp the sampling rate to a given maximum
 *--------------------------------------------------------------------------
 */

void
Patch::clamp( void )
{
    if( mapdesc->clampfactor != N_NOCLAMPING ) {
	pspec[0].clamp( mapdesc->clampfactor );
	pspec[1].clamp( mapdesc->clampfactor );
    }
}

void 
Patchspec::clamp( REAL clampfactor )
{
    if( sidestep[0] < minstepsize )
        sidestep[0] = clampfactor * minstepsize;
    if( sidestep[1] < minstepsize )
        sidestep[1] = clampfactor * minstepsize;
    if( stepsize < minstepsize )
        stepsize = clampfactor * minstepsize;
}

void 
Patch::checkBboxConstraint( void )
{
    if( notInBbox && 
	mapdesc->bboxTooBig( bpts, pspec[0].stride, pspec[1].stride,
				   pspec[0].order, pspec[1].order, bb ) != 1 ) {
	notInBbox = 0;
    }
}

void
Patch::bbox( void )
{
    if( mapdesc->isBboxSubdividing() )
	mapdesc->surfbbox( bb );
}

/*--------------------------------------------------------------------------
 * getstepsize - compute the sampling density across the patch
 * 		and determine if patch needs to be subdivided
 *--------------------------------------------------------------------------
 */

void
Patch::getstepsize( void )
{
    pspec[0].minstepsize = pspec[1].minstepsize = 0;
    pspec[0].needsSubdivision = pspec[1].needsSubdivision = 0;

    if( mapdesc->isConstantSampling() ) {
	// fixed number of samples per patch in each direction
	// maxsrate is number of s samples per patch
	// maxtrate is number of t samples per patch
        pspec[0].getstepsize( mapdesc->maxsrate );
        pspec[1].getstepsize( mapdesc->maxtrate );

    } else if( mapdesc->isDomainSampling() ) {
	// maxsrate is number of s samples per unit s length of domain
	// maxtrate is number of t samples per unit t length of domain
        pspec[0].getstepsize( mapdesc->maxsrate * pspec[0].range[2] );
        pspec[1].getstepsize( mapdesc->maxtrate * pspec[1].range[2] );

    } else if( ! needsSampling ) {
	pspec[0].singleStep();
	pspec[1].singleStep();
    } else {
	// upper bound on path length between sample points
        REAL tmp[MAXORDER][MAXORDER][MAXCOORDS];
	const int trstride = sizeof(tmp[0]) / sizeof(REAL);
	const int tcstride = sizeof(tmp[0][0]) / sizeof(REAL); 

	assert( pspec[0].order <= MAXORDER );
    
	/* points have been transformed, therefore they are homogeneous */

	int val = mapdesc->project( spts, pspec[0].stride, pspec[1].stride, 
		 &tmp[0][0][0], trstride, tcstride, 
		 pspec[0].order, pspec[1].order ); 
        if( val == 0 ) {
	    // control points cross infinity, therefore partials are undefined
            pspec[0].getstepsize( mapdesc->maxsrate );
            pspec[1].getstepsize( mapdesc->maxtrate );
        } else {
            REAL t1 = mapdesc->getProperty( N_PIXEL_TOLERANCE );
	    REAL t2 = mapdesc->getProperty( N_ERROR_TOLERANCE );
	    pspec[0].minstepsize = ( mapdesc->maxsrate > 0.0 ) ? 
			(pspec[0].range[2] / mapdesc->maxsrate) : 0.0;
	    pspec[1].minstepsize = ( mapdesc->maxtrate > 0.0 ) ? 
			(pspec[1].range[2] / mapdesc->maxtrate) : 0.0;
	    if( mapdesc->isParametricDistanceSampling() ) {
		// t2 is upper bound on the distance between surface and tessellant 
		REAL ssv[2], ttv[2];
		REAL ss = mapdesc->calcPartialVelocity( ssv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 2, 0, pspec[0].range[2], pspec[1].range[2], 0 );
		REAL st = mapdesc->calcPartialVelocity(   0, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 1, 1, pspec[0].range[2], pspec[1].range[2], -1 );
		REAL tt = mapdesc->calcPartialVelocity( ttv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 0, 2, pspec[0].range[2], pspec[1].range[2], 1 );
    
		if( ss != 0.0 && tt != 0.0 ) {
		    /* printf( "ssv[0] %g ssv[1] %g ttv[0] %g ttv[1] %g\n", 
			ssv[0], ssv[1], ttv[0], ttv[1] ); */
		    REAL ttq = ::sqrtf( (float) ss );
		    REAL ssq = ::sqrtf( (float) tt );
		    REAL ds = ::sqrtf( 4 * t2 * ttq / ( ss * ttq + st * ssq ) );
		    REAL dt = ::sqrtf( 4 * t2 * ssq / ( tt * ssq + st * ttq ) );
		    pspec[0].stepsize = ( ds < pspec[0].range[2] ) ? ds : pspec[0].range[2];
		    REAL scutoff = 2.0 * t2 / ( pspec[0].range[2] * pspec[0].range[2]);
		    pspec[0].sidestep[0] = (ssv[0] > scutoff) ? ::sqrtf( 2.0 * t2 / ssv[0] ) : pspec[0].range[2];
		    pspec[0].sidestep[1] = (ssv[1] > scutoff) ? ::sqrtf( 2.0 * t2 / ssv[1] ) : pspec[0].range[2];
    
		    pspec[1].stepsize = ( dt < pspec[1].range[2] ) ? dt : pspec[1].range[2];
		    REAL tcutoff = 2.0 * t2 / ( pspec[1].range[2] * pspec[1].range[2]);
		    pspec[1].sidestep[0] = (ttv[0] > tcutoff) ? ::sqrtf( 2.0 * t2 / ttv[0] ) : pspec[1].range[2];
		    pspec[1].sidestep[1] = (ttv[1] > tcutoff) ? ::sqrtf( 2.0 * t2 / ttv[1] ) : pspec[1].range[2];
		} else if( ss != 0.0 ) {
		    REAL x = pspec[1].range[2] * st;
		    REAL ds = ( ::sqrtf( x * x + 8.0 * t2 * ss ) - x ) / ss;
		    pspec[0].stepsize = ( ds < pspec[0].range[2] ) ? ds : pspec[0].range[2];
		    REAL scutoff = 2.0 * t2 / ( pspec[0].range[2] * pspec[0].range[2]);
		    pspec[0].sidestep[0] = (ssv[0] > scutoff) ? ::sqrtf( 2.0 * t2 / ssv[0] ) : pspec[0].range[2];
		    pspec[0].sidestep[1] = (ssv[1] > scutoff) ? ::sqrtf( 2.0 * t2 / ssv[1] ) : pspec[0].range[2];
		    pspec[1].singleStep();
		} else if( tt != 0.0 ) {
		    REAL x = pspec[0].range[2] * st;
		    REAL dt = ( ::sqrtf( x * x + 8.0 * t2 * tt ) - x )  / tt;
		    pspec[0].singleStep();
		    REAL tcutoff = 2.0 * t2 / ( pspec[1].range[2] * pspec[1].range[2]);
		    pspec[1].stepsize = ( dt < pspec[1].range[2] ) ? dt : pspec[1].range[2];
		    pspec[1].sidestep[0] = (ttv[0] > tcutoff) ? ::sqrtf( 2.0 * t2 / ttv[0] ) : pspec[1].range[2];
		    pspec[1].sidestep[1] = (ttv[1] > tcutoff) ? ::sqrtf( 2.0 * t2 / ttv[1] ) : pspec[1].range[2];
		} else {
		    if( 4.0 * t2  > st * pspec[0].range[2] * pspec[1].range[2] ) {
			pspec[0].singleStep();
			pspec[1].singleStep();
		    } else {
			REAL area = 4.0 * t2 / st;
			REAL ds = ::sqrtf( area * pspec[0].range[2] / pspec[1].range[2] );
			REAL dt = ::sqrtf( area * pspec[1].range[2] / pspec[0].range[2] );
			pspec[0].stepsize = ( ds < pspec[0].range[2] ) ? ds : pspec[0].range[2];
			pspec[0].sidestep[0] = pspec[0].range[2];
			pspec[0].sidestep[1] = pspec[0].range[2];
	
			pspec[1].stepsize = ( dt < pspec[1].range[2] ) ? dt : pspec[1].range[2];
			pspec[1].sidestep[0] = pspec[1].range[2];
			pspec[1].sidestep[1] = pspec[1].range[2];
		    }
		}
	    } else if( mapdesc->isPathLengthSampling() ) {
		// t1 is upper bound on path length
		REAL msv[2], mtv[2];
		REAL ms = mapdesc->calcPartialVelocity( msv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 1, 0, pspec[0].range[2], pspec[1].range[2], 0 );
		REAL mt = mapdesc->calcPartialVelocity( mtv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 0, 1, pspec[0].range[2], pspec[1].range[2], 1 );
		if( ms != 0.0 ) {
		    if( mt != 0.0 ) {
/*		    REAL d = t1 / ( ms * ms + mt * mt );*/
/*		    REAL ds = mt * d;*/
		    REAL ds = t1 / (2.0*ms);
/*		    REAL dt = ms * d;*/
		    REAL dt = t1 / (2.0*mt); 
			pspec[0].stepsize = ( ds < pspec[0].range[2] ) ? ds : pspec[0].range[2];
			pspec[0].sidestep[0] = ( msv[0] * pspec[0].range[2] > t1 ) ? (t1 / msv[0]) : pspec[0].range[2];
			pspec[0].sidestep[1] = ( msv[1] * pspec[0].range[2] > t1 ) ? (t1 / msv[1]) : pspec[0].range[2];
	
			pspec[1].stepsize = ( dt < pspec[1].range[2] ) ? dt : pspec[1].range[2];
			pspec[1].sidestep[0] = ( mtv[0] * pspec[1].range[2] > t1 ) ? (t1 / mtv[0]) : pspec[1].range[2];
			pspec[1].sidestep[1] = ( mtv[1] * pspec[1].range[2] > t1 ) ? (t1 / mtv[1]) : pspec[1].range[2];
		    } else {
			pspec[0].stepsize = ( t1 < ms * pspec[0].range[2] ) ? (t1 / ms) : pspec[0].range[2];
			pspec[0].sidestep[0] = ( msv[0] * pspec[0].range[2] > t1 ) ? (t1 / msv[0]) : pspec[0].range[2];
			pspec[0].sidestep[1] = ( msv[1] * pspec[0].range[2] > t1 ) ? (t1 / msv[1]) : pspec[0].range[2];
	
			pspec[1].singleStep();
		    }
		} else {
		    if( mt != 0.0 ) {
			pspec[0].singleStep();

			pspec[1].stepsize = ( t1 < mt * pspec[1].range[2] ) ? (t1 / mt) : pspec[1].range[2];
			pspec[1].sidestep[0] = ( mtv[0] * pspec[1].range[2] > t1 ) ? (t1 / mtv[0]) : pspec[1].range[2];
			pspec[1].sidestep[1] = ( mtv[1] * pspec[1].range[2] > t1 ) ? (t1 / mtv[1]) : pspec[1].range[2];
		    } else {
			pspec[0].singleStep();
			pspec[1].singleStep();
		    }
		}
	    } else if( mapdesc->isSurfaceAreaSampling() ) {
		// t is the square root of area
/*
		REAL msv[2], mtv[2];
		REAL ms = mapdesc->calcPartialVelocity( msv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 1, 0, pspec[0].range[2], pspec[1].range[2], 0 );
		REAL mt = mapdesc->calcPartialVelocity( mtv, &tmp[0][0][0], trstride, tcstride, pspec[0].order, pspec[1].order, 0, 1, pspec[0].range[2], pspec[1].range[2], 1 );
		if( ms != 0.0 &&  mt != 0.0 ) {
			REAL d = 1.0 / (ms * mt);
			t *= M_SQRT2;
			REAL ds = t * ::sqrtf( d * pspec[0].range[2] / pspec[1].range[2] );
			REAL dt = t * ::sqrtf( d * pspec[1].range[2] / pspec[0].range[2] );
			pspec[0].stepsize = ( ds < pspec[0].range[2] ) ? ds : pspec[0].range[2];
			pspec[0].sidestep[0] = ( msv[0] * pspec[0].range[2] > t ) ? (t / msv[0]) : pspec[0].range[2];
			pspec[0].sidestep[1] = ( msv[1] * pspec[0].range[2] > t ) ? (t / msv[1]) : pspec[0].range[2];
	
			pspec[1].stepsize = ( dt < pspec[1].range[2] ) ? dt : pspec[1].range[2];
			pspec[1].sidestep[0] = ( mtv[0] * pspec[1].range[2] > t ) ? (t / mtv[0]) : pspec[1].range[2];
			pspec[1].sidestep[1] = ( mtv[1] * pspec[1].range[2] > t ) ? (t / mtv[1]) : pspec[1].range[2];
		} else {
		    pspec[0].singleStep();
		    pspec[1].singleStep();
		}
*/
	    } else {
		pspec[0].singleStep();
		pspec[1].singleStep();
	    }
	}
    }

    dprintf( "sidesteps %g %g %g %g, stepsize %g %g\n",
	pspec[0].sidestep[0], pspec[0].sidestep[1],
	pspec[1].sidestep[0], pspec[1].sidestep[1],
	pspec[0].stepsize, pspec[1].stepsize );

    if( mapdesc->minsavings != N_NOSAVINGSSUBDIVISION ) {
	REAL savings = 1./(pspec[0].stepsize * pspec[1].stepsize) ;
	savings-= (2./( pspec[0].sidestep[0] + pspec[0].sidestep[1] )) * 
		  (2./( pspec[1].sidestep[0] + pspec[1].sidestep[1] ));
    
	savings *= pspec[0].range[2] * pspec[1].range[2];
	if( savings > mapdesc->minsavings ) {
	    pspec[0].needsSubdivision = pspec[1].needsSubdivision = 1;
	}
    }

    if( pspec[0].stepsize < pspec[0].minstepsize )  pspec[0].needsSubdivision =  1;
    if( pspec[1].stepsize < pspec[1].minstepsize )  pspec[1].needsSubdivision =  1;
    needsSampling = (needsSampling ? needsSamplingSubdivision() : 0);
}

void
Patchspec::singleStep()
{
    stepsize =  sidestep[0] =  sidestep[1] = abs(range[2]);
}

void 
Patchspec::getstepsize( REAL max ) // max is number of samples for entire patch
{
    stepsize = ( max >= 1.0 ) ? range[2] / max : range[2];
    if (stepsize < 0.0) {
       stepsize = -stepsize;
    }
    sidestep[0]	=  sidestep[1] = minstepsize = stepsize;
}

int
Patch::needsSamplingSubdivision( void )
{
    return (pspec[0].needsSubdivision || pspec[1].needsSubdivision) ? 1 : 0;
}

int
Patch::needsNonSamplingSubdivision( void )
{
    return notInBbox;
}

int
Patch::needsSubdivision( int param )
{
    return pspec[param].needsSubdivision;
}

int
Patch::cullCheck( void )
{
    if( cullval == CULL_ACCEPT ) 
	cullval = mapdesc->cullCheck( cpts, pspec[0].order,  pspec[0].stride,
					    pspec[1].order,  pspec[1].stride );
    return cullval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\nurbsint.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * nurbsinterfac.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "nurbscon.h"
#include "nurbstes.h"
#include "bufpool.h"
#include "quilt.h"
#include "displayl.h"
#include "knotvect.h"
#include "mapdesc.h"

#define THREAD( work, arg, cleanup ) \
	if( dl ) {\
	    arg->save = 1;\
	    dl->append( (PFVS)&NurbsTessellator::work, (void *) arg, (PFVS)&NurbsTessellator::cleanup );\
 	} else {\
	    arg->save = 0;\
	    work( arg );\
	}

#define THREAD2( work ) \
	if( dl ) {\
	    dl->append( (PFVS)&NurbsTessellator::work, 0, 0 );\
 	} else {\
	    work( );\
	}

NurbsTessellator::NurbsTessellator( BasicCurveEvaluator &c, BasicSurfaceEvaluator& e) 
	: subdivider( renderhints, backend ),
	  backend( c, e ),
	  maplist( backend ),
	  o_pwlcurvePool( sizeof( O_pwlcurve ), 32, "o_pwlcurvePool" ),
	  o_nurbscurvePool( sizeof( O_nurbscurve ), 32, "o_nurbscurvePool"),
	  o_curvePool( sizeof( O_curve ), 32,  "o_curvePool" ),
	  o_trimPool( sizeof( O_trim ), 32,  "o_trimPool" ),
	  o_surfacePool( sizeof( O_surface ), 1, "o_surfacePool" ),
	  o_nurbssurfacePool( sizeof( O_nurbssurface ), 4, "o_nurbssurfacePool" ),
	  propertyPool( sizeof( Property ), 32, "propertyPool" ),
          quiltPool( sizeof( Quilt  ), 32, "quiltPool" )
{
    dl		= 0;
    inSurface	= 0;
    inCurve	= 0;
    inTrim	= 0;
    playBack	= 0;
    jumpbuffer  = newJumpbuffer();
    subdivider.setJumpbuffer( jumpbuffer );
}

NurbsTessellator::~NurbsTessellator( void ) 
{
    if( inTrim ) {
	do_nurbserror( 12 );
	endtrim();
    }

    if( inSurface ) {
        *nextNurbssurface = 0;
        do_freeall();
    }

    if (jumpbuffer) {
        deleteJumpbuffer(jumpbuffer);
	jumpbuffer= 0;
    }	
}

/*-----------------------------------------------------------------------------
 * bgnsurface - allocate and initialize an o_surface structure
 *
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::bgnsurface( long nuid )
{
    O_surface *o_surface = new(o_surfacePool) O_surface;
    o_surface->nuid = nuid;
    THREAD( do_bgnsurface, o_surface, do_freebgnsurface );
}

/*-----------------------------------------------------------------------------
 * bgncurve - allocate an initialize an o_curve structure
 * 
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::bgncurve( long nuid )
{
    O_curve *o_curve = new(o_curvePool) O_curve;
    o_curve->nuid = nuid;
    THREAD( do_bgncurve, o_curve, do_freebgncurve );
}
/*-----------------------------------------------------------------------------
 * endcurve -
 * 
 * Client:
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::endcurve( void )
{
    THREAD2( do_endcurve );
}

/*-----------------------------------------------------------------------------
 * endsurface - user level end of surface call
 *
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::endsurface( void )
{
    THREAD2( do_endsurface );
}


/*-----------------------------------------------------------------------------
 * bgntrim - allocate and initialize a new trim loop structure (o_trim )
 *
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::bgntrim( void )
{
    O_trim *o_trim = new(o_trimPool) O_trim;
    THREAD( do_bgntrim, o_trim, do_freebgntrim );
}

/*-----------------------------------------------------------------------------
 * endtrim -
 *
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::endtrim( void )
{
    THREAD2( do_endtrim );
}


/*-----------------------------------------------------------------------------
 * pwlcurve -
 *
 *      count        - number of points on curve
 *      array        - array of points on curve
 *      byte_stride  - distance between points in bytes
 *      type         - valid data flag
 *
 * Client: Gl user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::pwlcurve( long count, INREAL array[], long byte_stride, long type )
{
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	isDataValid = 0;
	return;
    }

    if ( (type != N_P2D) && (type != N_P2DR) ) {
	do_nurbserror( 22 );
	isDataValid = 0;
	return;
    }
    if( count < 0 ) {
	do_nurbserror( 33 );
	isDataValid = 0;
	return;
    }
    if( byte_stride < 0 ) {
	do_nurbserror( 34 );
	isDataValid = 0;
	return;
    }

#ifdef NOTDEF
    if( mapdesc->isRational() ) {
	INREAL *p = array;
	INREAL x = p[0]; INREAL y = p[1]; INREAL w = p[2];
	p = (INREAL *) (((char *) p) + byte_stride);
	for( long i = 1; i != count; i++ ) {
	    if( p[0] == x && p[1] == y && p[2] == w ) break;
	    x = p[0]; y = p[1]; w = p[2];
	    p = (INREAL *) (((char *) p) + byte_stride);
	}
	if( i != count ) {
	    do_nurbserror( 37 );
	    dprintf( "point %d (%f,%f)\n", i, x, y );
	    isDataValid = 0;
	    return;
	}
    } else {
	INREAL *p = array;
	INREAL x = p[0]; INREAL y = p[1];
	p = (INREAL *) (((char *) p) + byte_stride);
	for( long i = 1; i != count; i++ ) {
	    if( p[0] == x && p[1] == y ) break;
	    x = p[0]; y = p[1];
	    p = (INREAL *) (((char *) p) + byte_stride);
	}
	if( i != count ) {
	    do_nurbserror( 37 );
	    dprintf( "point %d (%f,%f)\n", i, x, y );
	    isDataValid = 0;
	    return;
	}
    }
#endif

    O_pwlcurve	*o_pwlcurve = new(o_pwlcurvePool) O_pwlcurve( type, count, array, byte_stride, extTrimVertexPool.get((int)count) );
    THREAD( do_pwlcurve, o_pwlcurve, do_freepwlcurve );
}


/*-----------------------------------------------------------------------------
 * nurbscurve -
 *
 * Client: GL user
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::nurbscurve(
    long nknots, 		/* number of p knots */
    INREAL knot[], 		/* nondecreasing knot values in p */
    long byte_stride,		/* distance in bytes between control points */
    INREAL ctlarray[], 		/* pointer to first control point */
    long order,			/* order of spline */
    long type )			/* description of range space */
{

    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	isDataValid = 0;
	return;
    }

    if( ctlarray == 0 ) {
	do_nurbserror( 36 );
	isDataValid = 0;
	return;
    }

    if( byte_stride < 0 ) {
	do_nurbserror( 34 );
	isDataValid = 0;
	return;
    }

    Knotvector knots;

    knots.init( nknots, byte_stride, order, knot );
    if( do_check_knots( &knots, "curve" ) ) return;
    
    O_nurbscurve *o_nurbscurve = new(o_nurbscurvePool) O_nurbscurve(type);
    o_nurbscurve->bezier_curves = new(quiltPool) Quilt(mapdesc);
    o_nurbscurve->bezier_curves->toBezier( knots,ctlarray, mapdesc->getNcoords() );
 
    THREAD( do_nurbscurve, o_nurbscurve, do_freenurbscurve );
}


/*-----------------------------------------------------------------------------
 * nurbssurface -
 *
 * Client: User routine
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::nurbssurface(
    long sknot_count,		/* number of s knots */
    INREAL sknot[],		/* nondecreasing knot values in s */
    long tknot_count, 		/* number of t knots */
    INREAL tknot[],		/* nondecreasing knot values in t */
    long s_byte_stride,		/* s step size in memory bytes */
    long t_byte_stride,		/* t step size in memory bytes */
    INREAL ctlarray[],		/* pointer to first control point */
    long sorder,		/* order of the spline in s parameter */
    long torder,		/* order of the spline in t parameter */
    long type)			/* description of range space */
{ 
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	isDataValid = 0;
	return;
    }

    if( s_byte_stride < 0 ) {
	do_nurbserror( 34 );
	isDataValid = 0;
	return;
    }

    if( t_byte_stride < 0 ) {
	do_nurbserror( 34 );
	isDataValid = 0;
	return;
    }

    Knotvector sknotvector, tknotvector;

    sknotvector.init( sknot_count, s_byte_stride, sorder, sknot );
    if( do_check_knots( &sknotvector, "surface" ) ) return;

    tknotvector.init( tknot_count, t_byte_stride, torder, tknot );
    if( do_check_knots( &tknotvector, "surface" ) ) return;

    O_nurbssurface *o_nurbssurface = new(o_nurbssurfacePool) O_nurbssurface(type);
    o_nurbssurface->bezier_patches = new(quiltPool) Quilt(mapdesc);

    o_nurbssurface->bezier_patches->toBezier( sknotvector, tknotvector,
	ctlarray, mapdesc->getNcoords() ); 
    THREAD( do_nurbssurface, o_nurbssurface, do_freenurbssurface );
}


/*-----------------------------------------------------------------------------
 * setnurbsproperty -
 * 
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::setnurbsproperty( long tag, INREAL value )
{
    if( ! renderhints.isProperty( tag ) ) {
	do_nurbserror( 26 );
    } else {
	Property *prop = new(propertyPool) Property( tag, value );
	THREAD( do_setnurbsproperty, prop, do_freenurbsproperty );
    }
}

/*-----------------------------------------------------------------------------
 * setnurbsproperty -
 * 
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::setnurbsproperty( long type, long tag, INREAL value )
{
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	return;
    }

    if( ! mapdesc->isProperty( tag ) ) {
	do_nurbserror( 26 );
	return;
    }

    Property *prop = new(propertyPool) Property( type, tag, value );
    THREAD( do_setnurbsproperty2, prop, do_freenurbsproperty );
}


/*-----------------------------------------------------------------------------
 * getnurbsproperty - 
 * 
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::getnurbsproperty( long tag, INREAL *value )
{
    if( renderhints.isProperty( tag ) ) {
	*value = renderhints.getProperty( tag );
    } else {
	do_nurbserror( 26 );
    }
}

/*-----------------------------------------------------------------------------
 * getnurbsproperty - 
 * 
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::getnurbsproperty( long type, long tag, INREAL *value )
{
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) 
	do_nurbserror( 35 );

    if( mapdesc->isProperty( tag  ) ) {
	*value = mapdesc->getProperty( tag );
    } else {
	do_nurbserror( 26 );
    }
}

/*--------------------------------------------------------------------------
 * setnurbsproperty - accept a user supplied matrix as culling or sampling mat
 *--------------------------------------------------------------------------
 */

void 
NurbsTessellator::setnurbsproperty( long type, long purpose, INREAL *mat )
{
    // XXX - cannot be put in display list
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	isDataValid = 0;
    } else if( purpose == N_BBOXSIZE ) {
	mapdesc->setBboxsize( mat );
    } else {
#ifndef NDEBUG
        dprintf( "ERRORRORRORR!!!\n");
#endif
    }
}

/*--------------------------------------------------------------------------
 * setnurbsproperty - accept a user supplied matrix as culling or sampling mat
 *--------------------------------------------------------------------------
 */

void 
NurbsTessellator::setnurbsproperty( long type, long purpose, INREAL *mat, 
    long rstride, long cstride )
{
    // XXX - cannot be put in display list
    Mapdesc *mapdesc = maplist.locate( type );

    if( mapdesc == 0 ) {
	do_nurbserror( 35 );
	isDataValid = 0;
    } else if( purpose == N_CULLINGMATRIX ) {
	mapdesc->setCmat( mat, rstride, cstride );
    } else if( purpose == N_SAMPLINGMATRIX ) {
	mapdesc->setSmat( mat, rstride, cstride );
    } else if( purpose == N_BBOXMATRIX ) {
	mapdesc->setBmat( mat, rstride, cstride );
    } else {
#ifndef NDEBUG
        dprintf( "ERRORRORRORR!!!\n");
#endif
    }
}

void	
NurbsTessellator::redefineMaps( void )
{
    maplist.initialize();
}

void 	
NurbsTessellator::defineMap( long type, long rational, long ncoords )
{
    maplist.define( type, (int) rational, (int) ncoords );
}

void 
NurbsTessellator::discardRecording( void *_dl )
{
    delete (DisplayList *) _dl;
}

void * 
NurbsTessellator::beginRecording( void )
{
    dl = new DisplayList( this );
    return (void *) dl;
}

void 
NurbsTessellator::endRecording( void )
{
    dl->endList();
    dl = 0;
}

void 
NurbsTessellator::playRecording( void *_dl )
{
    playBack = 1;
    bgnrender();
    ((DisplayList *)_dl)->play();
    endrender();
    playBack = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\nurbstes.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * nurbstess.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mysetjmp.h"
#include "mystdio.h"
#include "nurbscon.h"
#include "nurbstes.h"
#include "bufpool.h"
#include "quilt.h"
#include "knotvect.h"
#include "mapdesc.h"
#include "maplist.h"

void
NurbsTessellator::resetObjects( void )
{
    subdivider.clear();
}

void
NurbsTessellator::makeobj( int )
{
#ifndef NDEBUG
   dprintf( "makeobj\n" );
#endif
}

void
NurbsTessellator::closeobj( void )
{
#ifndef NDEBUG
   dprintf( "closeobj\n" );
#endif
}

void
NurbsTessellator::bgnrender( void )
{
#ifndef NDEBUG
   dprintf( "bgnrender\n" );
#endif
}

void
NurbsTessellator::endrender( void )
{
#ifndef NDEBUG
    dprintf( "endrender\n" );
#endif
}

/*-----------------------------------------------------------------------------
 * do_freebgnsurface - free o_surface structure 
 *
 * Client: do_freeall(), bgnsurface()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_freebgnsurface( O_surface *o_surface )
{
    o_surface->deleteMe( o_surfacePool );
}


/*-----------------------------------------------------------------------------
 * do_bgnsurface - begin the display of a surface
 *
 * Client: bgnsurface()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_bgnsurface( O_surface *o_surface )
{
    if( inSurface ) {
	do_nurbserror( 27 );
	endsurface();
    }
    inSurface = 1;

    if( ! playBack ) bgnrender();

    isTrimModified = 0;
    isSurfaceModified = 0;
    isDataValid = 1;
    numTrims = 0;
    currentSurface = o_surface;
    nextTrim = &( currentSurface->o_trim );
    nextNurbssurface = &( currentSurface->o_nurbssurface );
}

/*-----------------------------------------------------------------------------
 * do_bgncurve - begin the display of a curve 
 * 
 * Client: bgncurve()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_bgncurve( O_curve *o_curve )
{
    if ( inCurve ) {
	do_nurbserror( 6 );
	endcurve();
    }

    inCurve = 1;
    currentCurve = o_curve;
    currentCurve->curvetype = ct_none;

    if( inTrim ) {
        if( *nextCurve != o_curve ) {
	    isCurveModified = 1;
	    *nextCurve = o_curve;
	}
    } else {
        if( ! playBack ) bgnrender();
        isDataValid = 1;
    }
    nextCurve = &(o_curve->next);
    nextPwlcurve = &(o_curve->curve.o_pwlcurve);
    nextNurbscurve = &(o_curve->curve.o_nurbscurve);
}

/*-----------------------------------------------------------------------------
 * do_endcurve -
 * 
 * Client: endcurve()
 *-----------------------------------------------------------------------------
 */
    
void
NurbsTessellator::do_endcurve( void )
{
    if( ! inCurve ) {
	do_nurbserror( 7 );
	return;
    }
    inCurve = 0;

    *nextCurve = 0;
    if (currentCurve->curvetype == ct_nurbscurve)
	*nextNurbscurve = 0;
    else
	*nextPwlcurve = 0;

    if ( ! inTrim ) {
        if( ! isDataValid ) {
            do_freecurveall( currentCurve ); 
	    return;
        }

	int errval;
	errval = ::mysetjmp( jumpbuffer );
	if( errval == 0 ) {
	    if( currentCurve->curvetype == ct_nurbscurve ) {
		subdivider.beginQuilts();
		for( O_nurbscurve *n = currentCurve->curve.o_nurbscurve; n != 0; n = n->next ) 
		    subdivider.addQuilt( n->bezier_curves );
		subdivider.endQuilts();
		subdivider.drawCurves(); 
		if( ! playBack ) endrender();
	    } else {
		/* XXX */
	        if( ! playBack ) endrender();
	        /*do_draw_pwlcurve( currentCurve->curve.o_pwlcurve ) */;
	        do_nurbserror( 9 );
	    }
	} else {
	    if( ! playBack ) endrender();
	    do_nurbserror( errval );
	}
	do_freecurveall( currentCurve );
	resetObjects();
    }
}

/*-----------------------------------------------------------------------------
 * do_endsurface - mark end of surface, display surface, free immediate data 
 *
 * Client:
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_endsurface( void )
{
    if( inTrim ) {
	do_nurbserror( 12 );
	endtrim();
    }

    if( ! inSurface ) {
	do_nurbserror( 13 );
	return;
    }
    inSurface = 0;

    *nextNurbssurface = 0;

    if( ! isDataValid ) {
        do_freeall( ); 
	return;
    }

    if( *nextTrim != 0 ) {
	isTrimModified = 1;
        *nextTrim = 0;
    }

    int errval;

    errval = ::mysetjmp( jumpbuffer );
    if( errval == 0 ) {
        if( numTrims > 0 ) {

	    subdivider.beginTrims();
	    for( O_trim	*trim = currentSurface->o_trim; trim; trim = trim->next ) {
		subdivider.beginLoop();
		for( O_curve *curve = trim->o_curve; curve; curve = curve->next ) {  
		    curve->used = 0;
		    assert( curve->curvetype != ct_none );
		    if (curve->curvetype == ct_pwlcurve) {
			O_pwlcurve *c = curve->curve.o_pwlcurve; 
			subdivider.addArc( c->npts, c->pts, curve->nuid );
		    } else {
			Quilt	   *quilt = curve->curve.o_nurbscurve->bezier_curves;
			Quiltspec  *qspec = quilt->qspec;
			REAL       *cpts  = quilt->cpts + qspec->offset;
			REAL       *cptsend = cpts + (qspec->width * qspec->order * qspec->stride);
			for( ; cpts != cptsend; cpts += qspec->order*qspec->stride ) 
			     subdivider.addArc( cpts, quilt, curve->nuid );
		    }
		}
		subdivider.endLoop();
	    }
	    subdivider.endTrims();
	}

	subdivider.beginQuilts();
	for( O_nurbssurface *n = currentSurface->o_nurbssurface; n; n = n->next ) 
	    subdivider.addQuilt( n->bezier_patches );
	subdivider.endQuilts();
        subdivider.drawSurfaces( currentSurface->nuid ); 
	if( ! playBack ) endrender();
    } else {
	if( ! playBack ) endrender();
	do_nurbserror( errval );
    }

    do_freeall( );
    resetObjects();
}

/*-----------------------------------------------------------------------------
 * do_freeall - free all data allocated in immediate mode
 *
 * Client:
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_freeall( void )
{
    for( O_trim *o_trim = currentSurface->o_trim; o_trim; ) {
	O_trim *next_o_trim = o_trim->next;
        for( O_curve *curve = o_trim->o_curve; curve; ) {
	    O_curve *next_o_curve = curve->next;
	    do_freecurveall( curve );
	    curve = next_o_curve;
	}
	if( o_trim->save == 0 ) do_freebgntrim( o_trim );
	o_trim = next_o_trim;
    }

    O_nurbssurface *nurbss, *next_nurbss;
    for( nurbss= currentSurface->o_nurbssurface; nurbss; nurbss = next_nurbss) {
	next_nurbss = nurbss->next;
	if( nurbss->save == 0 )
	    do_freenurbssurface( nurbss );
	else
	    nurbss->used = 0;
    }

    if( currentSurface->save == 0 ) do_freebgnsurface( currentSurface );
}

void
NurbsTessellator::do_freecurveall( O_curve *curve )
{
    assert( curve->curvetype != ct_none );

    if( curve->curvetype == ct_nurbscurve ) {
	O_nurbscurve *ncurve, *next_ncurve;
	for( ncurve=curve->curve.o_nurbscurve; ncurve; ncurve=next_ncurve ) {
	    next_ncurve = ncurve->next;
	    if( ncurve->save == 0 )
		do_freenurbscurve( ncurve );
	    else
		ncurve->used = 0;
	}
    } else {
	O_pwlcurve *pcurve, *next_pcurve;
	for( pcurve=curve->curve.o_pwlcurve; pcurve; pcurve=next_pcurve ) {
	    next_pcurve = pcurve->next;
	    if( pcurve->save == 0 )
		do_freepwlcurve( pcurve );
	    else
		pcurve->used = 0;
	}
    }
    if( curve->save == 0 )
        do_freebgncurve( curve );
}


/*-----------------------------------------------------------------------------
 * do_freebgntrim - free the space allocated for a trim loop
 *
 * Client:
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_freebgntrim( O_trim *o_trim )
{ 
    o_trim->deleteMe( o_trimPool );
}


/*-----------------------------------------------------------------------------
 * do_bgntrim - link in a trim loop to the current trimmed surface description
 *
 * Client: bgntrim()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_bgntrim( O_trim *o_trim )
{

    if( ! inSurface ) {
	do_nurbserror( 15 );
	bgnsurface( 0 );
	inSurface = 2;
    }

    if( inTrim ) {
	do_nurbserror( 16 );
	endtrim();
    }
    inTrim = 1;

    if( *nextTrim != o_trim ) {
	isTrimModified = 1;	
        *nextTrim = o_trim;
    }

    currentTrim = o_trim;
    nextTrim = &(o_trim->next);
    nextCurve = &(o_trim->o_curve);
}


/*-----------------------------------------------------------------------------
 * do_endtrim - mark the end of the current trim loop 
 *
 * Client: endtrim()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_endtrim( void )
{
    if( ! inTrim ) {
	do_nurbserror( 17 );
	return;
    }
    inTrim = 0;

    if( currentTrim->o_curve == 0 ) {
	do_nurbserror( 18 );
	isDataValid = 0;
    }

    numTrims++;
   
    if( *nextCurve != 0 ) {
	isTrimModified = 1;
        *nextCurve = 0;	
    }
}

/*-----------------------------------------------------------------------------
 * do_freepwlcurve -
 * 
 * Client:
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_freepwlcurve( O_pwlcurve *o_pwlcurve )
{
    o_pwlcurve->deleteMe( o_pwlcurvePool );
}

void
NurbsTessellator::do_freebgncurve( O_curve *o_curve )
{
    o_curve->deleteMe( o_curvePool );
}

/*-----------------------------------------------------------------------------
 * do_pwlcurve - link in pwl trim loop to the current surface description
 * 
 * Client: pwlcurve()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_pwlcurve( O_pwlcurve *o_pwlcurve )
{
    if( ! inTrim ) {
	do_nurbserror( 19 );
	if( o_pwlcurve->save == 0 )
	    do_freepwlcurve(o_pwlcurve );
	return;
    }

    if( ! inCurve ) {
	bgncurve( 0 );
	inCurve = 2;
    }

    if( o_pwlcurve->used ) {
	do_nurbserror( 20 );
	isDataValid = 0;
	return;
    } else
        o_pwlcurve->used = 1;

    if( currentCurve->curvetype == ct_none ) {
        currentCurve->curvetype = ct_pwlcurve;
    } else if( currentCurve->curvetype != ct_pwlcurve ) {
	do_nurbserror( 21 );
	isDataValid = 0;
	return;
    }
	
    if( *nextPwlcurve != o_pwlcurve ) {
	isCurveModified = 1;
        *nextPwlcurve = o_pwlcurve;
    }
    nextPwlcurve = &(o_pwlcurve->next);

    if( o_pwlcurve->owner != currentCurve ) {
	isCurveModified = 1;
	o_pwlcurve->owner = currentCurve;
    }

    if( (inCurve == 2) ) 
	endcurve();
}


/*-----------------------------------------------------------------------------
 * do_freenurbscurve -
 * 
 * Client:
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_freenurbscurve( O_nurbscurve *o_nurbscurve )
{
    o_nurbscurve->bezier_curves->deleteMe( quiltPool );
    o_nurbscurve->deleteMe( o_nurbscurvePool );
}


/*-----------------------------------------------------------------------------
 * do_nurbscurve -
 * 
 * Client: nurbscurve() 
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_nurbscurve( O_nurbscurve *o_nurbscurve )
{
    if ( ! inCurve ) {
	bgncurve( 0 );
	inCurve = 2;
    }

    if( o_nurbscurve->used ) {
	/* error - curve was already called in current surface */
	do_nurbserror( 23 );
	isDataValid = 0;
	return;
    } else
        o_nurbscurve->used = 1;

    if( currentCurve->curvetype == ct_none ) {
        currentCurve->curvetype = ct_nurbscurve;
    } else if( currentCurve->curvetype != ct_nurbscurve ) {
	do_nurbserror( 24 );
	isDataValid = 0;
	return;
    }
	
    if( *nextNurbscurve != o_nurbscurve ) {
	isCurveModified = 1;
	*nextNurbscurve = o_nurbscurve;
    }

    nextNurbscurve = &(o_nurbscurve->next);

    if( o_nurbscurve->owner != currentCurve ) {
	isCurveModified = 1;
	o_nurbscurve->owner = currentCurve;
    }

    if( o_nurbscurve->owner == 0 )
	isCurveModified = 1;
    
    if( inCurve == 2 )
        endcurve();
}


/*-----------------------------------------------------------------------------
 * do_freenurbssurface -
 *
 * Client:
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::do_freenurbssurface( O_nurbssurface *o_nurbssurface )
{
    o_nurbssurface->bezier_patches->deleteMe( quiltPool );
    o_nurbssurface->deleteMe( o_nurbssurfacePool );
}

/*-----------------------------------------------------------------------------
 * do_nurbssurface -
 * 
 * Client: nurbssurface()
 *-----------------------------------------------------------------------------
 */
void
NurbsTessellator::do_nurbssurface( O_nurbssurface *o_nurbssurface )
{
    if( ! inSurface ) {
	bgnsurface( 0 );
	inSurface = 2;
    }

    if( o_nurbssurface->used ) {
	/* error - surface was already called in current block */
	do_nurbserror( 25 );
	isDataValid = 0;
	return;
    } else
        o_nurbssurface->used = 1;

    if( *nextNurbssurface != o_nurbssurface ) {
	isSurfaceModified = 1;
        *nextNurbssurface  = o_nurbssurface;
    }

    if( o_nurbssurface->owner != currentSurface ) {
	isSurfaceModified = 1;
	o_nurbssurface->owner = currentSurface;
    }
    nextNurbssurface = &(o_nurbssurface->next);

    if( inSurface == 2  )
	endsurface();
}


/*-----------------------------------------------------------------------------
 * do_freenurbsproperty
 * 
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::do_freenurbsproperty( Property *prop )
{
    prop->deleteMe( propertyPool );
}

    
/*-----------------------------------------------------------------------------
 * do_setnurbsproperty -
 * 
 *-----------------------------------------------------------------------------
 */

void
NurbsTessellator::do_setnurbsproperty( Property *prop )
{
    renderhints.setProperty( prop->tag, prop->value );
    if( prop->save == 0 )
	do_freenurbsproperty( prop );
}

void
NurbsTessellator::do_setnurbsproperty2( Property *prop )
{
    Mapdesc *mapdesc = maplist.find( prop->type );

    mapdesc->setProperty( prop->tag, prop->value );
    if( prop->save == 0 )
	do_freenurbsproperty( prop );
}

void
NurbsTessellator::errorHandler( int )
{
}

void
NurbsTessellator::do_nurbserror( int msg )
{
    errorHandler( msg );
}

int 
NurbsTessellator::do_check_knots( Knotvector *knots, char *msg )
{
    int status = knots->validate();
    if( status ) {
	do_nurbserror( status );
        if( renderhints.errorchecking != N_NOMSG ) knots->show( msg );
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\nurbscon.h ===
#ifndef __glunurbsconsts_h_
#define __glunurbsconsts_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * nurbsconsts.h - $Revision: 1.1 $
 */

/* NURBS Properties - one set per map, 
   each takes a single INREAL arg */
#define N_SAMPLING_TOLERANCE  	1
#define N_S_RATE		6
#define N_T_RATE		7
#define N_CLAMPFACTOR		13
#define 	N_NOCLAMPING		0.0
#define N_MINSAVINGS		14
#define 	N_NOSAVINGSSUBDIVISION	0.0

/* NURBS Properties - one set per map, 
   each takes an enumerated value */
#define N_CULLING		2
#define 	N_NOCULLING		0.0
#define 	N_CULLINGON		1.0
#define N_SAMPLINGMETHOD	10
#define 	N_NOSAMPLING		0.0
#define 	N_FIXEDRATE		3.0
#define 	N_DOMAINDISTANCE	2.0
#define 	N_PARAMETRICDISTANCE	5.0
#define 	N_PATHLENGTH		6.0
#define 	N_SURFACEAREA		7.0
#define N_BBOX_SUBDIVIDING	17
#define 	N_NOBBOXSUBDIVISION	0.0
#define 	N_BBOXTIGHT		1.0
#define 	N_BBOXROUND		2.0

/* NURBS Rendering Properties - one set per renderer
   each takes an enumerated value */
#define N_DISPLAY		3
#define 	N_FILL			1.0 	
#define 	N_OUTLINE_POLY		2.0
#define 	N_OUTLINE_TRI		3.0
#define 	N_OUTLINE_QUAD	 	4.0
#define 	N_OUTLINE_PATCH		5.0
#define 	N_OUTLINE_PARAM		6.0
#define 	N_OUTLINE_PARAM_S	7.0
#define 	N_OUTLINE_PARAM_ST 	8.0
#define 	N_OUTLINE_SUBDIV 	9.0
#define 	N_OUTLINE_SUBDIV_S 	10.0
#define 	N_OUTLINE_SUBDIV_ST 	11.0
#define 	N_ISOLINE_S		12.0
#define N_ERRORCHECKING		4
#define 	N_NOMSG			0.0
#define 	N_MSG			1.0

/* GL 4.0 propeties not defined above */
#ifndef N_PIXEL_TOLERANCE
#define N_PIXEL_TOLERANCE	N_SAMPLING_TOLERANCE
#define N_ERROR_TOLERANCE	20
#define N_SUBDIVISIONS		5
#define N_TILES			8
#define N_TMP1			9
#define N_TMP2			N_SAMPLINGMETHOD
#define N_TMP3			11
#define N_TMP4			12
#define N_TMP5			N_CLAMPFACTOR
#define N_TMP6			N_MINSAVINGS
#define N_S_STEPS		N_S_RATE
#define N_T_STEPS		N_T_RATE
#endif

/* NURBS Rendering Properties - one set per map,
   each takes an INREAL matrix argument */
#define N_CULLINGMATRIX		1
#define N_SAMPLINGMATRIX	2
#define N_BBOXMATRIX		3


/* NURBS Rendering Properties - one set per map,
   each takes an INREAL vector argument */
#define	N_BBOXSIZE		4

/* type argument for trimming curves */
#ifndef N_P2D
#define N_P2D 	 		0x8	
#define N_P2DR 	 		0xd
#endif	

#endif /* __glunurbsconsts_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\nurbstes.h ===
#ifndef __glunurbstess_h_
#define __glunurbstess_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * nurbstess.h - $Revision: 1.2 $
 */

#include "mysetjmp.h"
#include "subdivid.h"
#include "renderhi.h"
#include "backend.h"
#include "maplist.h"
#include "reader.h"
#include "nurbscon.h"

class Knotvector;
class Quilt;
class DisplayList;
class BasicCurveEvaluator;
class BasicSurfaceEvaluator;

class NurbsTessellator {
public:
    			NurbsTessellator( BasicCurveEvaluator &c,
                                          BasicSurfaceEvaluator &e );
    			~NurbsTessellator( void );

    void     		getnurbsproperty( long, INREAL * );
    void     		getnurbsproperty( long, long, INREAL * );
    void     		setnurbsproperty( long, INREAL );
    void     		setnurbsproperty( long, long, INREAL );
    void		setnurbsproperty( long, long, INREAL * );
    void		setnurbsproperty( long, long, INREAL *, long, long );

    // called before a tessellation begins/ends
    virtual void	bgnrender( void );
    virtual void	endrender( void );

    // called to make a display list of the output vertices
    virtual void	makeobj( int n );
    virtual void	closeobj( void );

    // called when a error occurs
    virtual void	errorHandler( int );

    void     		bgnsurface( long );
    void     		endsurface( void );
    void     		bgntrim( void );
    void     		endtrim( void );
    void     		bgncurve( long );
    void     		endcurve( void );
    void     		pwlcurve( long, INREAL[], long, long );
    void     		nurbscurve( long, INREAL[], long, INREAL[], long, long );
    void     		nurbssurface( long, INREAL[], long, INREAL[], long, long,
			    INREAL[], long, long, long );

    void 		defineMap( long, long, long );
    void		redefineMaps( void );

    // recording of input description
    void 		discardRecording( void * );
    void * 		beginRecording( void );
    void 		endRecording( void );
    void 		playRecording( void * );

protected:
    Renderhints		renderhints;
    Maplist		maplist;
    Backend		backend;

private:

    void		resetObjects( void );
    int			do_check_knots( Knotvector *, char * );
    void		do_nurbserror( int );
    void		do_bgncurve( O_curve * );
    void		do_endcurve( void );
    void		do_freeall( void );
    void		do_freecurveall( O_curve * );
    void		do_freebgntrim( O_trim * );
    void		do_freebgncurve( O_curve * );
    void		do_freepwlcurve( O_pwlcurve * );
    void		do_freenurbscurve( O_nurbscurve * );
    void		do_freenurbssurface( O_nurbssurface * );
    void 		do_freebgnsurface( O_surface * );
    void		do_bgnsurface( O_surface * );
    void		do_endsurface( void );
    void		do_bgntrim( O_trim * );
    void		do_endtrim( void );
    void		do_pwlcurve( O_pwlcurve * );
    void		do_nurbscurve( O_nurbscurve * );
    void		do_nurbssurface( O_nurbssurface * );
    void		do_freenurbsproperty( Property * );
    void		do_setnurbsproperty( Property * );
    void		do_setnurbsproperty2( Property * );

    Subdivider		subdivider;
    JumpBuffer* 	jumpbuffer;
    Pool		o_pwlcurvePool;
    Pool		o_nurbscurvePool;
    Pool		o_curvePool;
    Pool		o_trimPool;
    Pool		o_surfacePool;
    Pool		o_nurbssurfacePool;
    Pool		propertyPool;
    Pool		quiltPool;
    TrimVertexPool	extTrimVertexPool;

    int			inSurface;		/* bgnsurface seen */
    int			inCurve;		/* bgncurve seen */
    int			inTrim;			/* bgntrim seen */
    int			isCurveModified;	/* curve changed */
    int			isTrimModified;		/* trim curves changed */
    int			isSurfaceModified;	/* surface changed */
    int			isDataValid;		/* all data is good */
    int			numTrims;		/* valid trim regions */
    int			playBack;

    O_trim**		nextTrim;		/* place to link o_trim */
    O_curve**		nextCurve;		/* place to link o_curve */
    O_nurbscurve**	nextNurbscurve;		/* place to link o_nurbscurve */
    O_pwlcurve**	nextPwlcurve;		/* place to link o_pwlcurve */
    O_nurbssurface**	nextNurbssurface;	/* place to link o_nurbssurface */

    O_surface*		currentSurface;
    O_trim*		currentTrim;
    O_curve*		currentCurve;

    DisplayList		*dl;

};

#endif /* __glunurbstess_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\patch.h ===
#ifndef __glupatch_h_
#define __glupatch_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * patch.h - $Revision: 1.1 $
 */

#include "types.h"
#include "defines.h"

class Quilt;
class Mapdesc;


struct Pspec {
    REAL		range[3];
    REAL		sidestep[2];
    REAL		stepsize;
    REAL		minstepsize;
    int			needsSubdivision;
};

struct Patchspec : public Pspec {
    int			order;
    int			stride;
    void 		clamp( REAL );
    void 		getstepsize( REAL );
    void		singleStep( void );
};

class Patch {
public:
friend class Subdivider;
friend class Quilt;
friend class Patchlist;
    			Patch( Quilt *, REAL*, REAL *, Patch * );
    			Patch( Patch &, int, REAL, Patch * );
    void		bbox( void );
    void		clamp( void );
    void		getstepsize( void );
    int			cullCheck( void );
    int			needsSubdivision( int );
    int			needsSamplingSubdivision( void );
    int			needsNonSamplingSubdivision( void );

private:

    Mapdesc*		mapdesc;
    Patch*		next;
    int			cullval;
    int			notInBbox;
    int			needsSampling;
    REAL		cpts[MAXORDER*MAXORDER*MAXCOORDS]; //culling pts 
    REAL		spts[MAXORDER*MAXORDER*MAXCOORDS]; //sampling pts 
    REAL		bpts[MAXORDER*MAXORDER*MAXCOORDS]; //bbox pts
    Patchspec		pspec[2];
    void 		checkBboxConstraint( void );
    REAL 		bb[2][MAXCOORDS];
};
#endif /* __glupatch_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\patchlis.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * patchlist.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "quilt.h"
#include "patchlis.h"
#include "patch.h"
#include "nurbscon.h"

Patchlist::Patchlist( Quilt *quilts, REAL *pta, REAL *ptb )
{
    patch = 0;
    for( Quilt *q = quilts; q; q = q->next ) 
	patch = new Patch( q, pta, ptb, patch );
    pspec[0].range[0] = pta[0];
    pspec[0].range[1] = ptb[0];
    pspec[0].range[2] = ptb[0] - pta[0];
 
    pspec[1].range[0] = pta[1];
    pspec[1].range[1] = ptb[1];
    pspec[1].range[2] = ptb[1] - pta[1];
}

Patchlist::Patchlist( Patchlist &upper, int param,  REAL value)
{
    Patchlist &lower = *this;
    patch = 0;
    for( Patch *p = upper.patch; p; p = p->next )
	patch = new Patch( *p, param, value, patch );

    if( param == 0 ) {
	lower.pspec[0].range[0] = upper.pspec[0].range[0];
	lower.pspec[0].range[1] = value;
	lower.pspec[0].range[2] = value - upper.pspec[0].range[0];
	upper.pspec[0].range[0] = value;
	upper.pspec[0].range[2] = upper.pspec[0].range[1] - value;
	lower.pspec[1] = upper.pspec[1];
    } else {
	lower.pspec[0] = upper.pspec[0];
	lower.pspec[1].range[0] = upper.pspec[1].range[0];
	lower.pspec[1].range[1] = value;
	lower.pspec[1].range[2] = value - upper.pspec[1].range[0];
	upper.pspec[1].range[0] = value;
	upper.pspec[1].range[2] = upper.pspec[1].range[1] - value;
    }
}

Patchlist::~Patchlist()
{
    while( patch ) {
	Patch *p = patch;
	patch = patch->next;
	delete p;
    }
}

int
Patchlist::cullCheck( void )
{
    for( Patch *p = patch; p; p = p->next )
	if( p->cullCheck() == CULL_TRIVIAL_REJECT )
	    return CULL_TRIVIAL_REJECT;
    return CULL_ACCEPT;
}

void
Patchlist::getstepsize( void )
{
    pspec[0].stepsize    = pspec[0].range[2];
    pspec[0].sidestep[0] = pspec[0].range[2];
    pspec[0].sidestep[1] = pspec[0].range[2];

    pspec[1].stepsize    = pspec[1].range[2];
    pspec[1].sidestep[0] = pspec[1].range[2];
    pspec[1].sidestep[1] = pspec[1].range[2];

    for( Patch *p = patch; p; p = p->next ) {
	p->getstepsize();
	p->clamp();
	pspec[0].stepsize    =  ((p->pspec[0].stepsize < pspec[0].stepsize) ? p->pspec[0].stepsize : pspec[0].stepsize);
	pspec[0].sidestep[0] =  ((p->pspec[0].sidestep[0] < pspec[0].sidestep[0]) ? p->pspec[0].sidestep[0] : pspec[0].sidestep[0]);
	pspec[0].sidestep[1] =  ((p->pspec[0].sidestep[1] < pspec[0].sidestep[1]) ? p->pspec[0].sidestep[1] : pspec[0].sidestep[1]);
	pspec[1].stepsize    =  ((p->pspec[1].stepsize < pspec[1].stepsize) ? p->pspec[1].stepsize : pspec[1].stepsize);
	pspec[1].sidestep[0] =  ((p->pspec[1].sidestep[0] < pspec[1].sidestep[0]) ? p->pspec[1].sidestep[0] : pspec[1].sidestep[0]);
	pspec[1].sidestep[1] =  ((p->pspec[1].sidestep[1] < pspec[1].sidestep[1]) ? p->pspec[1].sidestep[1] : pspec[1].sidestep[1]);
    }
}

void
Patchlist::bbox( void )
{
    for( Patch *p = patch; p; p = p->next )
	p->bbox();
}

int
Patchlist::needsNonSamplingSubdivision( void )
{
    notInBbox = 0;
    for( Patch *p = patch; p; p = p->next )
	notInBbox |= p->needsNonSamplingSubdivision();
    return notInBbox;
}

int
Patchlist::needsSamplingSubdivision( void )
{
    pspec[0].needsSubdivision = 0;
    pspec[1].needsSubdivision = 0;

    for( Patch *p = patch; p; p = p->next ) {
	pspec[0].needsSubdivision |= p->pspec[0].needsSubdivision;
	pspec[1].needsSubdivision |= p->pspec[0].needsSubdivision;
    }
    return (pspec[0].needsSubdivision || pspec[1].needsSubdivision) ? 1 : 0;
}

int
Patchlist::needsSubdivision( int param )
{
    return pspec[param].needsSubdivision;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\pwlarc.h ===
#ifndef __glupwlarc_h_
#define __glupwlarc_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * pwlarc.h - $Revision: 1.1 $
 */

#include "myassert.h"
#include "nurbscon.h"

class TrimVertex;

struct PwlArc : public PooledObj { /* a piecewise-linear arc */
    TrimVertex *	pts;		/* sample points */
    int			npts;		/* number of sample points */
    long		type;		/* curve type */
    inline		PwlArc( void );
    inline		PwlArc( int, TrimVertex * );
    inline		PwlArc( int, TrimVertex *, long );
};

inline
PwlArc::PwlArc( void )
{
    type = N_P2D;
    pts = 0;
    npts = -1;
}

inline
PwlArc::PwlArc( int _npts, TrimVertex *_pts )
{
    pts = _pts;
    npts = _npts;
    type = N_P2D;
}

inline
PwlArc::PwlArc( int _npts, TrimVertex *_pts, long _type )
{
    pts = _pts;
    npts = _npts;
    type = _type;
}

#endif /* __glupwlarc_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\patchlis.h ===
#ifndef __glupatchlist_h_
#define __glupatchlist_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * patchlist.h - $Revision: 1.1 $
 */

#include "types.h"
#include "defines.h"
#include "patch.h"

class Quilt;

class Patchlist {
friend class Subdivider;
public:
    			Patchlist( Quilt *, REAL *, REAL * );
    			Patchlist( Patchlist &, int ,  REAL );
    			~Patchlist();	
    void		bbox();
    int			cullCheck( void );
    void		getstepsize( void );
    int			needsNonSamplingSubdivision( void );
    int			needsSamplingSubdivision( void );
    int			needsSubdivision( int );
    REAL		getStepsize( int );
private:
    Patch		*patch;
    int			notInBbox;
    int			needsSampling;
    Pspec		pspec[2];
};

inline REAL
Patchlist::getStepsize( int param )
{
    return pspec[param].stepsize;
}

#endif /* __glupatchlist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\quilt.h ===
#ifndef __gluquilt_h_
#define __gluquilt_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * quilt.h - $Revision: 1.1 $
 */

#include "defines.h"
#include "bufpool.h"
#include "types.h"

class Backend;
class Mapdesc;
class Flist;
class Knotvector;

/* constants for memory allocation of NURBS to Bezier conversion */ 
#define	MAXDIM 		2

struct Quiltspec { /* a specification for a dimension of a quilt */
    int			stride;		/* words between points */
    int			width;		/* number of segments */
    int			offset;		/* words to first point */
    int			order;		/* order */
    int			index;		/* current segment number */
    int			bdry[2];	/* boundary edge flag */
    REAL  		step_size;
    Knot *		breakpoints;
};

typedef Quiltspec *Quiltspec_ptr;
    
#ifdef NT
class Quilt : public PooledObj { public: /* an array of bezier patches */
#else
struct Quilt : PooledObj { /* an array of bezier patches */
#endif
    			Quilt( Mapdesc * );
    Mapdesc *		mapdesc;	/* map descriptor */
    REAL *		cpts;		/* control points */
    Quiltspec		qspec[MAXDIM];	/* the dimensional data */
    Quiltspec_ptr	eqspec;		/* qspec trailer */
    Quilt		*next;		/* next quilt in linked list */
			
    void		deleteMe( Pool& );
    void		toBezier( Knotvector &, INREAL *, long  );
    void		toBezier( Knotvector &, Knotvector &, INREAL *, long  );
    void		select( REAL *, REAL * );
    int			getDimension( void ) { return eqspec - qspec; }
    void 		download( Backend & );
    void		downloadAll( REAL *, REAL *, Backend & );
    int 		isCulled( void );
    void		getRange( REAL *, REAL *, Flist&, Flist & );
    void		getRange( REAL *, REAL *, int, Flist & );
    void		getRange( REAL *, REAL *, Flist&  );
    void		findRates( Flist& slist, Flist& tlist, REAL[2] );
    void		findSampleRates( Flist& slist, Flist& tlist );
    void		show();
};

typedef Quilt *Quilt_ptr;

#endif /* __gluquilt_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\quilt.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * quilt.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "quilt.h"
#include "backend.h"
#include "mapdesc.h"
#include "flist.h"
#include "knotvect.h"
#include "patchlis.h"
#include "math.h"     //fabs()
#define _abs_defined
#include "simplema.h" //min()

/* local preprocessor definitions */
#define DEF_PATCH_STEPSIZE	.2
#define fsizeof(x)		(sizeof(x)/sizeof(REAL))


Quilt::Quilt( Mapdesc *_mapdesc )
{
    mapdesc = _mapdesc;
}

void
Quilt::deleteMe( Pool& p )
{
    for( Quiltspec *q=qspec; q != eqspec; q++ ) {
#if 1
	if( q->breakpoints) delete[] q->breakpoints;  q->breakpoints = 0;
#else
	if( q->breakpoints) {
	   delete[] q->breakpoints;
	   q->breakpoints = 0;
printf("in here\n");
        }
#endif
    }
    if( cpts ) delete[] cpts;
    cpts = 0;
    PooledObj::deleteMe( p );
}

void
Quilt::show( void )
{
#ifndef NDEBUG
    int nc = mapdesc->getNcoords();
    REAL *ps  = cpts;
    ps += qspec[0].offset;
    ps += qspec[1].offset;
    for( int i=0; i!= qspec[0].order * qspec[0].width; i++ ) {
	for( int j = 0; j!= qspec[1].order * qspec[1].width; j++ ) {
	    for( int k=0; k < nc; k++ )
		dprintf(  "%g ", ps[i*qspec[0].stride + j*qspec[1].stride + k] );
	    dprintf(  "\n" );
	}
	dprintf(  "\n" );
    }
    dprintf( "\n" );
#endif
}

/*--------------------------------------------------------------------------
 * Quilt::select - find which map in each quilt contains the points
 *			pta and ptb with pta[i] < ptb[i]
 *--------------------------------------------------------------------------
 */

void
Quilt::select( REAL *pta, REAL *ptb )
{
    int dim = eqspec - qspec;
    for( int i=0; i<dim; i++) {
	for( int j=qspec[i].width-1; j>=0; j-- )
	    if( (qspec[i].breakpoints[j] <= pta[i]   ) &&
	    	(ptb[i] <= qspec[i].breakpoints[j+1] ) )
		 break;
	assert( j != -1 );
	qspec[i].index = j;
    }
}

void
Quilt::download( Backend &backend )
{
    if( getDimension() == 2 ) {
	REAL *ps  = cpts;
	ps += qspec[0].offset;
	ps += qspec[1].offset;
	ps += qspec[0].index * qspec[0].order * qspec[0].stride;
	ps += qspec[1].index * qspec[1].order * qspec[1].stride;
	backend.surfpts( mapdesc->getType(), ps,
		  qspec[0].stride,
		  qspec[1].stride,
		  qspec[0].order,
		  qspec[1].order,
		  qspec[0].breakpoints[qspec[0].index],
		  qspec[0].breakpoints[qspec[0].index+1],
		  qspec[1].breakpoints[qspec[1].index],
		  qspec[1].breakpoints[qspec[1].index+1] );
    } else {
	REAL *ps  = cpts;
	ps += qspec[0].offset;
	ps += qspec[0].index * qspec[0].order * qspec[0].stride;
	backend.curvpts( mapdesc->getType(), ps,
		      qspec[0].stride,
		      qspec[0].order,
		      qspec[0].breakpoints[qspec[0].index],
		      qspec[0].breakpoints[qspec[0].index+1] );
    }
}

/*--------------------------------------------------------------------------
 * Quilt::downloadAll - download each map that contains the current patch
 *--------------------------------------------------------------------------
 */

void
Quilt::downloadAll( REAL *pta, REAL *ptb, Backend &backend )
{
    for( Quilt *m = this; m; m=m->next ) {
	m->select( pta, ptb );
	m->download( backend );
    }
}

/*--------------------------------------------------------------------------
  * Quilt::isCulled - determine if an entire quilt is trivially rejected.
 *--------------------------------------------------------------------------
 */

int
Quilt::isCulled( void )
{
    if( mapdesc->isCulling() )
	return mapdesc->xformAndCullCheck( cpts + qspec[0].offset + qspec[1].offset,
			qspec[0].order * qspec[0].width, qspec[0].stride,
			qspec[1].order * qspec[1].width, qspec[1].stride );
    else
	return CULL_ACCEPT;
}

/*---------------------------------------------------------------------------
 * Quilt::getRange - retrieve the valid paramater range of a set of quilts
 *---------------------------------------------------------------------------
 */
void
Quilt::getRange( REAL *from, REAL *to, Flist& slist, Flist &tlist )
{
    getRange( from, to, 0, slist );
    getRange( from, to, 1, tlist );
}

/*---------------------------------------------------------------------------
 * Quilt::getRange - retrieve the valid paramater range of a set of quilts
 *---------------------------------------------------------------------------
 */
void
Quilt::getRange( REAL *from, REAL *to, int i, Flist &list )
{
    Quilt *maps = this;
    from[i] = maps->qspec[i].breakpoints[0];
    to[i]   = maps->qspec[i].breakpoints[maps->qspec[i].width];
    int maxpts = 0;
    for( Quilt_ptr m=maps; m; m=m->next ) {
	if( m->qspec[i].breakpoints[0] > from[i] )
	    from[i] = m->qspec[i].breakpoints[0];
	if( m->qspec[i].breakpoints[m->qspec[i].width] < to[i] )
	    to[i] = m->qspec[i].breakpoints[m->qspec[i].width];
	maxpts += m->qspec[i].width + 1;
    }

    list.grow( maxpts );

    for( m=maps; m; m=m->next )
	for( int j=0; j<=m->qspec[i].width; j++ ) {
	    list.add( m->qspec[i].breakpoints[j] );
	}

    list.filter( );
    list.taper( from[i], to[i] );
}

void
Quilt::getRange( REAL *from, REAL *to, Flist& slist )
{
    getRange( from, to, 0, slist );
}

void
Quilt::findRates( Flist& slist, Flist& tlist, REAL rate[2] )
{
    findSampleRates( slist, tlist );
    rate[0] = qspec[0].step_size;
    rate[1] = qspec[1].step_size;

    for( Quilt *q = next; q; q = q->next ) {
	q->findSampleRates( slist, tlist );
	if( q->qspec[0].step_size < rate[0] )
	    rate[0] = q->qspec[0].step_size;
	if( q->qspec[1].step_size < rate[1] )
	    rate[1] = q->qspec[1].step_size;
    }
}

void
Quilt::findSampleRates( Flist& slist, Flist& tlist )
{
    qspec[0].step_size = DEF_PATCH_STEPSIZE *
	    (qspec[0].breakpoints[qspec[0].width] - qspec[0].breakpoints[0]);
    qspec[1].step_size = DEF_PATCH_STEPSIZE *
	    (qspec[1].breakpoints[qspec[1].width] - qspec[1].breakpoints[0]);

    for( int i = slist.start; i < slist.end-1; i++ ) {
	for( int j = tlist.start; j < tlist.end-1; j++ ) {

	    REAL pta[2], ptb[2];
	    pta[0] = slist.pts[i];
	    ptb[0] = slist.pts[i+1];
	    pta[1] = tlist.pts[j];
	    ptb[1] = tlist.pts[j+1];
	    Patchlist patchlist( this, pta, ptb );
	    patchlist.getstepsize();
	
	    {
	    float edge_len_s = min(fabs(ptb[0]-pta[0]),1.0);
	    float edge_len_t = min(fabs(ptb[1]-pta[1]),1.0);

	    if( patchlist.getStepsize(0)/edge_len_s < qspec[0].step_size )
	       qspec[0].step_size = patchlist.getStepsize(0)/edge_len_s;
	    if( patchlist.getStepsize(1)/edge_len_t < qspec[1].step_size )
	      qspec[1].step_size = patchlist.getStepsize(1)/edge_len_t;
	    }
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\renderhi.h ===
#ifndef __glurenderhints_h_
#define __glurenderhints_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * renderhints.h - $Revision: 1.1 $
 */

#include "types.h"

class Renderhints {
public:
    			Renderhints( void );
    void		init( void );
    int			isProperty( long );
    REAL 		getProperty( long );
    void		setProperty( long, REAL );

    REAL 		display_method;		/* display mode */
    REAL 		errorchecking;		/* activate error checking */
    REAL 		subdivisions;		/* maximum number of subdivisions per patch */
    REAL 		tmp1;			/* unused */

    int			displaydomain;
    int			maxsubdivisions;
    int			wiretris;
    int			wirequads;
};

#endif /* __glurenderhints_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\renderhi.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * renderhints.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "mystdio.h"
#include "renderhi.h"
#include "defines.h"
#include "nurbscon.h"


/*--------------------------------------------------------------------------
 * Renderhints::Renderhints - set all window specific options
 *--------------------------------------------------------------------------
 */
Renderhints::Renderhints()
{
    display_method 	= N_FILL;
    errorchecking 	= N_MSG;
    subdivisions 	= 6.0;
    tmp1 		= 0.0;
}

void
Renderhints::init( void )
{
    maxsubdivisions = (int) subdivisions;
    if( maxsubdivisions < 0 ) maxsubdivisions = 0;


    if( display_method == N_FILL ) {
	wiretris = 0;
	wirequads = 0;
    } else if( display_method == N_OUTLINE_TRI ) {
	wiretris = 1;
	wirequads = 0;
    } else if( display_method == N_OUTLINE_QUAD ) {
	wiretris = 0;
	wirequads = 1;
    } else {
	wiretris = 1;
	wirequads = 1;
    }
}

int
Renderhints::isProperty( long property )
{
    switch ( property ) {
	case N_DISPLAY:
	case N_ERRORCHECKING:
	case N_SUBDIVISIONS:
        case N_TMP1:
	    return 1;
	default:
	    return 0;
    }
}

REAL 
Renderhints::getProperty( long property )
{
    switch ( property ) {
	case N_DISPLAY:
	    return display_method;
	case N_ERRORCHECKING:
	    return errorchecking;
	case N_SUBDIVISIONS:
	    return subdivisions;
        case N_TMP1:
	    return tmp1;
	default:
#ifdef NT
        return ((REAL) 0);
#else
	    abort();
	    return -1;  //not necessary, needed to shut up compiler
#endif
    }
}

void 
Renderhints::setProperty( long property, REAL value )
{
    switch ( property ) {
	case N_DISPLAY:
	    display_method = value;
	    break;
	case N_ERRORCHECKING:
	    errorchecking = value;
	    break;
	case N_SUBDIVISIONS:
	    subdivisions = value;
	    break;
	case N_TMP1: /* unused */
	    tmp1 = value;
	    break;
	default:
#ifndef NT
	    abort();
#endif
	    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\reader.h ===
#ifndef __glureader_h_
#define __glureader_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * reader.h - $Revision: 1.1 $
 */

#include "bufpool.h"
#include "types.h"

enum Curvetype { ct_nurbscurve, ct_pwlcurve, ct_none };
    
struct Property;
struct O_surface;
struct O_nurbssurface;
struct O_trim;
struct O_pwlcurve;
struct O_nurbscurve;
struct O_curve;
class  Quilt;
class TrimVertex;


struct O_curve : public PooledObj {
    union {
        O_nurbscurve	*o_nurbscurve;
        O_pwlcurve	*o_pwlcurve;
    } curve;
    Curvetype		curvetype;	/* arc type: pwl or nurbs	*/
    O_curve *		next;		/* next arc in loop		*/
    O_surface *		owner;		/* owning surface		*/
    int			used;		/* curve called in cur surf	*/
    int			save;		/* 1 if in display list		*/
    long		nuid;
    			O_curve() { next = 0; used = 0; owner = 0; 
				    curve.o_pwlcurve = 0; }
    };

struct O_nurbscurve : public PooledObj {
    Quilt		*bezier_curves;	/* array of bezier curves	*/
    long		type;		/* range descriptor		*/
    REAL		tesselation;	/* tesselation tolerance 	*/
    int			method;		/* tesselation method 		*/
    O_nurbscurve *	next;		/* next curve in list		*/
    int			used;		/* curve called in cur surf	*/
    int			save;		/* 1 if in display list		*/
    O_curve *		owner;		/* owning curve 		*/
			O_nurbscurve( long _type ) 
			   { type = _type; owner = 0; next = 0; used = 0; }
    };
 
#ifdef NT
struct O_pwlcurve : public PooledObj {
#else
class O_pwlcurve : public PooledObj {
#endif
public:
    TrimVertex		*pts;		/* array of trim vertices	*/
    int			npts;		/* number of trim vertices	*/
    O_pwlcurve *	next;		/* next curve in list		*/
    int			used;		/* curve called in cur surf	*/
    int			save;		/* 1 if in display list		*/
    O_curve *		owner;		/* owning curve 		*/
			O_pwlcurve( long, long, INREAL *, long, TrimVertex * );
    };

struct O_trim : public PooledObj {
    O_curve		*o_curve;	/* closed trim loop	 	*/
    O_trim *		next;		/* next loop along trim 	*/
    int			save;		/* 1 if in display list		*/
			O_trim() { next = 0; o_curve = 0; }
    };

struct O_nurbssurface : public PooledObj {
    Quilt *		bezier_patches;/* array of bezier patches	*/
    long		type;		/* range descriptor		*/
    O_surface *		owner;		/* owning surface		*/
    O_nurbssurface *	next;		/* next surface in chain	*/
    int			save;		/* 1 if in display list		*/
    int			used;		/* 1 if prev called in block	*/
			O_nurbssurface( long _type ) 
			   { type = _type; owner = 0; next = 0; used = 0; }
    };

struct O_surface : public PooledObj {
    O_nurbssurface *	o_nurbssurface;	/* linked list of surfaces	*/
    O_trim *		o_trim;		/* list of trim loops		*/
    int			save;		/* 1 if in display list		*/
    long		nuid;
			O_surface() { o_trim = 0; o_nurbssurface = 0; }
    };

struct Property : public PooledObj {
    long		type;
    long		tag;
    REAL		value;
    int			save;		/* 1 if in display list		*/
			Property( long _type, long _tag, INREAL _value )
			{ type = _type; tag = _tag; value = (REAL) _value; }
			Property( long _tag, INREAL _value )
			{ type = 0; tag = _tag; value = (REAL) _value; }
    };

class NurbsTessellator;
#endif /* __glureader_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\reader.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 *  reader.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "nurbscon.h"
#include "reader.h"
#include "trimvert.h"

O_pwlcurve::O_pwlcurve( long _type, long count, INREAL *array, long byte_stride, TrimVertex *trimpts )
{
    next = 0;
    used = 0;
    owner = 0;
    pts = trimpts;
    npts = (int) count;

    /* copy user data into internal trimming data structures */
    switch( _type ) {
        case N_P2D: {
	    TrimVertex *v = pts;
    	    for( TrimVertex *lastv = v + count; v != lastv; v++ ) {
	        v->param[0] = (REAL) array[0];
	        v->param[1] = (REAL) array[1];
		array = (INREAL *) (((char *) array) + byte_stride);
	    }
	    break;
	}
        case N_P2DR: {
	    TrimVertex *v = pts;
    	    for( TrimVertex *lastv = v + count; v != lastv; v++ ) {
	        v->param[0] = (REAL) array[0] / (REAL) array[2];
	        v->param[1] = (REAL) array[1] / (REAL) array[2];
		array = (INREAL *) (((char *) array) + byte_stride);
	    }
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\simplema.h ===
#ifndef __glusimplemath_h_
#define __glusimplemath_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * simplemath.h - $Revision: 1.4 $
 */

/* simple inline routines */

inline int
max( int x, int y ) { return ( x < y ) ? y : x; }

inline REAL
min( REAL x, REAL y ) { return ( x > y ) ? y : x; }

#ifndef _abs_defined
inline REAL
abs( REAL x ) { return ( x < 0.0 ) ? -x : x; }
#endif

#endif /* __glusimplemath_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\sorter.h ===
#ifndef __glusorter_h_
#define __glusorter_h_

class Sorter {
public:
			Sorter( int es );
    void		qsort( void *a, int n );

protected:	
    virtual int		qscmp( char *, char * );
    virtual void	qsexc( char *i, char *j );	// i<-j, j<-i 
    virtual void	qstexc( char *i, char *j, char *k ); // i<-k, k<-j, j<-i 

private:
    void		qs1( char *, char * );
    int 		es;
};
#endif /* __glusorter_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\slicer.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * slicer.c++ - $Revision: 1.4 $
 * 	Derrick Burns - 1991
 */
#include "glimport.h"
#include "mystdio.h"
#include "myassert.h"
#include "bufpool.h"
#include "slicer.h"
#include "backend.h"
#include "arc.h"
#include "gridtrim.h"
#include "trimvert.h"
#include "varray.h"

Slicer::Slicer( Backend &b ) 
	: CoveAndTiler( b ), Mesher( b ), backend( b )
{
}

Slicer::~Slicer()
{
}

void
Slicer::setisolines( int x )
{
    isolines = x;
}

void
Slicer::setstriptessellation( REAL x, REAL y )
{
    assert(x > 0 && y > 0);
    du = x;
    dv = y;
    setDu( du );
}

void
Slicer::slice( Arc_ptr loop )
{
    loop->markverts();

    Arc_ptr extrema[4];
    loop->getextrema( extrema );

    unsigned int npts = loop->numpts();
    TrimRegion::init( npts, extrema[0] );

    Mesher::init( npts );

    long ulines = uarray.init( du, extrema[1], extrema[3] );

    Varray varray;
    long vlines = varray.init( dv, extrema[0], extrema[2] );

    long botv = 0;
    long topv;
    TrimRegion::init( varray.varray[botv] );
    getGridExtent( &extrema[0]->pwlArc->pts[0], &extrema[0]->pwlArc->pts[0] );

    for( long quad=0; quad<varray.numquads; quad++ ) {
	backend.surfgrid( uarray.uarray[0], 
		       uarray.uarray[ulines-1], 
	 	       ulines-1, 
		       varray.vval[quad], 
		       varray.vval[quad+1], 
		       varray.voffset[quad+1] - varray.voffset[quad] );

	for( long i=varray.voffset[quad]+1; i <= varray.voffset[quad+1]; i++ ) {
    	    topv = botv++;
    	    advance( topv - varray.voffset[quad], 
		     botv - varray.voffset[quad], 
		     varray.varray[botv] );
	    if( i == vlines )
		getPts( extrema[2] );
	    else
		getPts( backend );
	    getGridExtent();
            if( isolines ) {
	        outline();
	    } else {
		if( canTile() ) 
		    coveAndTile();
		else
		    mesh();
	    }
        }
   }
}


void
Slicer::outline( void )
{
    GridTrimVertex upper, lower;
    Hull::init( );

    backend.bgnoutline();
    while( (nextupper( &upper )) ) {
	if( upper.isGridVert() )
	    backend.linevert( upper.g );
	else
	    backend.linevert( upper.t );
    }
    backend.endoutline();

    backend.bgnoutline();
    while( (nextlower( &lower )) ) {
	if( lower.isGridVert() )
	    backend.linevert( lower.g );
	else
	    backend.linevert( lower.t );
    }
    backend.endoutline();
}


void
Slicer::outline( Arc_ptr jarc )
{
    jarc->markverts();

    if( jarc->pwlArc->npts >= 2 ) {
	backend.bgnoutline();
	for( int j = jarc->pwlArc->npts-1; j >= 0; j--  )
	    backend.linevert( &(jarc->pwlArc->pts[j]) );
	backend.endoutline();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\sorter.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * sorter.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "sorter.h"
#include "mystdio.h"

Sorter::Sorter( int _es )
{
    es = _es;
}

void
Sorter::qsort( void *a, int n )
{
    qs1( (char *)a, ((char *)a)+n*es);
}

int
Sorter::qscmp( char *, char * )
{
    dprintf( "Sorter::qscmp: pure virtual called\n" );
    return 0;
}


void
Sorter::qsexc( char *, char * )
{
    dprintf( "Sorter::qsexc: pure virtual called\n" );
}


void
Sorter::qstexc( char *, char *, char * )
{
    dprintf( "Sorter::qstexc: pure virtual called\n" );
}

void
Sorter::qs1( char *a,  char *l )
{
    char *i, *j;
    char	*lp, *hp;
    int	c;
    unsigned int n;

start:
#ifdef NT
    if((int)(n=l-a) <= es)
#else
    if((n=l-a) <= es)
#endif
	    return;
    n = es * (n / (2*es));
    hp = lp = a+n;
    i = a;
    j = l-es;
    while(1) {
	if(i < lp) {
	    if((c = qscmp(i, lp)) == 0) {
		qsexc(i, lp -= es);
		continue;
	    }
	    if(c < 0) {
		i += es;
		continue;
	    }
	}

loop:
	if(j > hp) {
	    if((c = qscmp(hp, j)) == 0) {
		qsexc(hp += es, j);
		goto loop;
	    }
	    if(c > 0) {
		if(i == lp) {
		    qstexc(i, hp += es, j);
		    i = lp += es;
		    goto loop;
		}
		qsexc(i, j);
		j -= es;
		i += es;
		continue;
	    }
	    j -= es;
	    goto loop;
	}

	if(i == lp) {
	    if(lp-a >= l-hp) {
		qs1(hp+es, l);
		l = lp;
	    } else {
		qs1(a, lp);
		a = hp+es;
	    }
	    goto start;
	}

	qstexc(j, lp -= es, i);
	j = hp -= es;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\splitarc.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * splitarcs.c++ - $Revision: 1.5 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mysetjmp.h"
#include "mystdio.h"
#include "subdivid.h"
#include "arcsorte.h"
#include "arc.h"
#include "bin.h"

/* local preprocessor definitions */
#define MAXARCS	10

/*----------------------------------------------------------------------------
 * Subdivider::split - split trim regions in source bin by line (param == value). 
 *----------------------------------------------------------------------------
 */

void
Subdivider::split( Bin& bin, Bin& left, Bin& right, int param, REAL value )
{
    Bin	intersections, unknown; 

    partition( bin, left, intersections, right, unknown, param, value );

    int	count = intersections.numarcs();
    if( count % 2 ) {
#ifndef NDEBUG
	left.show( "left" );
	intersections.show( "intersections" );
	right.show( "right" );
#endif
	::mylongjmp( jumpbuffer, 29 );
    }

    Arc_ptr arclist[MAXARCS], *list;
    if( count >= MAXARCS ) {
	list = new Arc_ptr[count];
    } else {
	list = arclist;
    }

    Arc_ptr jarc;
    for( Arc_ptr *last = list; jarc=intersections.removearc(); last++ )
	*last = jarc;

    if( param == 0 ) { /* sort into increasing t order */
	ArcSdirSorter sorter(*this);
	sorter.qsort( list, count );
	
        //::qsort ((void *)list, count, sizeof(Arc_ptr), (cmpfunc)compare_s);
	for( Arc_ptr *lptr=list; lptr<last; lptr+=2 )
	    check_s ( lptr[0], lptr[1] );
	for( lptr=list; lptr<last; lptr+=2 )
	    join_s ( left, right, lptr[0], lptr[1] );
	for( lptr=list; lptr != last; lptr++ ) {
	    if( ((*lptr)->head()[0] <= value) && ((*lptr)->tail()[0] <= value) )
		left.addarc( *lptr  );
	    else
		right.addarc( *lptr  );
	}
    } else { /* sort into decreasing s order */
	ArcTdirSorter sorter(*this);
	sorter.qsort( list, count );
        //::qsort ((void *)list, count, sizeof(Arc_ptr), (cmpfunc)compare_t);
	for( Arc_ptr *lptr=list; lptr<last; lptr+=2 )
	    check_t ( lptr[0], lptr[1] );
	for( lptr=list; lptr<last; lptr+=2 )
	    join_t ( left, right, lptr[0], lptr[1] );
	for( lptr=list; lptr != last; lptr++ ) {
	    if( ((*lptr)->head()[1] <= value) && ((*lptr)->tail()[1] <= value) )
		left.addarc( *lptr  );
	    else
		right.addarc( *lptr  );
	}
    }

    if( list != arclist ) delete[] list;
    unknown.adopt(); 
}


void
Subdivider::check_s( Arc_ptr jarc1, Arc_ptr jarc2 )
{
    assert( jarc1->check( ) != 0 );
    assert( jarc2->check( ) != 0 );
    assert( jarc1->next->check( ) != 0 );
    assert( jarc2->next->check( ) != 0 );
    assert( jarc1 != jarc2 );

    /* XXX - if these assertions fail, it is due to user error or
	     undersampling */
    if( ! ( jarc1->tail()[0] < (jarc1)->head()[0] ) ) {
#ifndef NDEBUG
	dprintf( "s difference %f\n",  (jarc1)->tail()[0] - (jarc1)->head()[0] );
#endif
	::mylongjmp( jumpbuffer, 28 );
    }

    if( ! ( jarc2->tail()[0] > (jarc2)->head()[0] ) ) { 
#ifndef NDEBUG
	dprintf( "s difference %f\n",  (jarc2)->tail()[0] - (jarc2)->head()[0] );
#endif
	::mylongjmp( jumpbuffer, 28 );
    }
}

inline void
Subdivider::link( Arc_ptr jarc1, Arc_ptr jarc2, Arc_ptr up, Arc_ptr down )
{
    up->nuid = down->nuid = 0;		// XXX

    up->next = jarc2;
    down->next = jarc1;
    up->prev = jarc1->prev;
    down->prev = jarc2->prev;

    down->next->prev = down;
    up->next->prev = up;
    down->prev->next = down;
    up->prev->next = up;
}

inline void 
Subdivider::simple_link( Arc_ptr jarc1, Arc_ptr jarc2 )
{
    Arc_ptr tmp = jarc2->prev;
    jarc2->prev = jarc1->prev;
    jarc1->prev = tmp;
    jarc2->prev->next = jarc2;
    jarc1->prev->next = jarc1;
}


/*----------------------------------------------------------------------------
 * join - add a pair of oppositely directed jordan arcs between two arcs
 *----------------------------------------------------------------------------
 */

void
Subdivider::join_s( Bin& left, Bin& right, Arc_ptr jarc1, Arc_ptr jarc2 )
{
    assert( jarc1->check( ) != 0);
    assert( jarc2->check( ) != 0);
    assert( jarc1 != jarc2 );

    if( ! jarc1->getitail() )
	jarc1 = jarc1->next;

    if( ! jarc2->getitail() )
	jarc2 = jarc2->next;

    REAL s = jarc1->tail()[0];
    REAL t1 = jarc1->tail()[1];
    REAL t2 = jarc2->tail()[1];

    if( t1 == t2 ) {
	simple_link( jarc1, jarc2 );
    } else {
	Arc_ptr newright = new(arcpool) Arc( arc_right, 0 ); 
	Arc_ptr newleft = new(arcpool) Arc( arc_left, 0 );
	assert( t1 < t2 );
	if( isBezierArcType() ) {
	    arctessellator.bezier( newright, s, s, t1, t2 );
	    arctessellator.bezier( newleft, s, s, t2, t1 );
	} else {
	    arctessellator.pwl_right( newright, s, t1, t2, stepsizes[0] );
	    arctessellator.pwl_left( newleft, s, t2, t1, stepsizes[2] );
	}
	link( jarc1, jarc2, newright, newleft );
	left.addarc( newright  );
	right.addarc( newleft  );
    }

    assert( jarc1->check( ) != 0 );
    assert( jarc2->check( ) != 0 );
    assert( jarc1->next->check( ) != 0);
    assert( jarc2->next->check( ) != 0);
}

void
Subdivider::check_t( Arc_ptr jarc1, Arc_ptr jarc2 )
{
    assert( jarc1->check( ) != 0 );
    assert( jarc2->check( ) != 0 );
    assert( jarc1->next->check( ) != 0 );
    assert( jarc2->next->check( ) != 0 );
    assert( jarc1 != jarc2 );

    /* XXX - if these assertions fail, it is due to user error or
	     undersampling */
    if( ! ( jarc1->tail()[1] < (jarc1)->head()[1] ) ) {
#ifndef NDEBUG
	dprintf( "t difference %f\n",  jarc1->tail()[1] - (jarc1)->head()[1] );
#endif
	::mylongjmp( jumpbuffer, 28 );
    }

    if( ! ( jarc2->tail()[1] > (jarc2)->head()[1] ) ) { 
#ifndef NDEBUG
	dprintf( "t difference %f\n",  jarc2->tail()[1] - (jarc2)->head()[1] );
#endif
	::mylongjmp( jumpbuffer, 28 );
    }
}

/*----------------------------------------------------------------------------
 * join_t - add a pair of oppositely directed jordan arcs between two arcs
 *----------------------------------------------------------------------------
 */

void
Subdivider::join_t( Bin& bottom, Bin& top, Arc_ptr jarc1, Arc_ptr jarc2 )
{
    assert( jarc1->check( ) != 0 );
    assert( jarc2->check( ) != 0 );
    assert( jarc1->next->check( ) != 0 );
    assert( jarc2->next->check( ) != 0 );
    assert( jarc1 != jarc2 );

    if( ! jarc1->getitail() )
	jarc1 = jarc1->next;

    if( ! jarc2->getitail() )
	jarc2 = jarc2->next;

    REAL s1 = jarc1->tail()[0];
    REAL s2 = jarc2->tail()[0];
    REAL t  = jarc1->tail()[1];

    if( s1 == s2 ) {
	simple_link( jarc1, jarc2 );
    } else {
	Arc_ptr newtop = new(arcpool) Arc( arc_top, 0 );
	Arc_ptr newbot = new(arcpool) Arc( arc_bottom, 0 );
	assert( s1 > s2 );
	if( isBezierArcType() ) {
	    arctessellator.bezier( newtop, s1, s2, t, t );
	    arctessellator.bezier( newbot, s2, s1, t, t );
	} else {
	    arctessellator.pwl_top( newtop, t, s1, s2, stepsizes[1] );
	    arctessellator.pwl_bottom( newbot, t, s2, s1, stepsizes[3] );
	}
	link( jarc1, jarc2, newtop, newbot );
	bottom.addarc( newtop  );
	top.addarc( newbot  );
    }

    assert( jarc1->check( ) != 0 );
    assert( jarc2->check( ) != 0 );
    assert( jarc1->next->check( ) != 0 );
    assert( jarc2->next->check( ) != 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\subdivid.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * subdivider.c++ - $Revision: 1.3 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "subdivid.h"
#include "arc.h"
#include "bezierar.h"
#include "bin.h"
#include "renderhi.h"
#include "backend.h"
#include "mapdesc.h"
#include "quilt.h"
#include "patchlis.h"
#include "patch.h"
#include "nurbscon.h"
#include "trimpool.h"
#include "simplema.h"

/*---------------------------------------------------------------------------
 * Subdivider - construct a subdivider
 *---------------------------------------------------------------------------
 */

Subdivider::Subdivider( Renderhints& r, Backend& b ) 
	: arcpool( sizeof( Arc), 1, "arcpool" ),
 	  bezierarcpool( sizeof( BezierArc ), 1, "Bezarcpool" ),
	  pwlarcpool( sizeof( PwlArc ), 1, "Pwlarcpool" ),
	  renderhints( r ),
	  arctessellator( trimvertexpool, pwlarcpool ), 
	  backend( b ),
	  slicer( b )
{
}

void
Subdivider::setJumpbuffer( JumpBuffer *j )
{
    jumpbuffer = j;
}

/*---------------------------------------------------------------------------
 * clear - reset all state after possible error condition
 *---------------------------------------------------------------------------
 */

void		
Subdivider::clear( void )
{
    trimvertexpool.clear();     
    arcpool.clear();
    pwlarcpool.clear();
    bezierarcpool.clear();
}

/*---------------------------------------------------------------------------
 * ~Subdivider - destroy a subdivider
 *---------------------------------------------------------------------------
 */

Subdivider::~Subdivider( void )
{
}

/*---------------------------------------------------------------------------
 * addArc - add a bezier arc to a trim loop and to a bin
 *---------------------------------------------------------------------------
 */
void
Subdivider::addArc( REAL *cpts, Quilt *quilt, long _nuid )
{
    BezierArc *bezierArc = new(bezierarcpool) BezierArc;
    Arc *jarc  		= new(arcpool) Arc( arc_none, _nuid );
    jarc->pwlArc	= 0;
    jarc->bezierArc	= bezierArc;
    bezierArc->order	= quilt->qspec->order;
    bezierArc->stride	= quilt->qspec->stride;
    bezierArc->mapdesc	= quilt->mapdesc;
    bezierArc->cpts	= cpts;
    initialbin.addarc( jarc );
    pjarc		= jarc->append( pjarc );
}

/*---------------------------------------------------------------------------
 * addArc - add a pwl arc to a trim loop and to a bin
 *---------------------------------------------------------------------------
 */

void
Subdivider::addArc( int npts, TrimVertex *pts, long _nuid ) 
{
    Arc *jarc 		= new(arcpool) Arc( arc_none, _nuid );
    jarc->pwlArc	= new(pwlarcpool) PwlArc( npts, pts );        
    initialbin.addarc( jarc  );
    pjarc		= jarc->append( pjarc );
}

void
Subdivider::beginQuilts( void )
{
    qlist = 0;
}

void
Subdivider::addQuilt( Quilt *quilt )
{
    quilt->next = qlist;
    qlist = quilt;
}

/*---------------------------------------------------------------------------
 * drawSurfaces - main entry point for surface tessellation
 *---------------------------------------------------------------------------
 */

void
Subdivider::drawSurfaces( long nuid )
{
    renderhints.init( );

    if (qlist == NULL) return;
    for( Quilt *q = qlist; q; q = q->next ) {
	if( q->isCulled( ) == CULL_TRIVIAL_REJECT ) {
	    freejarcs( initialbin );
	    return;
	}
    }

    REAL from[2], to[2];
    qlist->getRange( from, to, spbrkpts, tpbrkpts );

    if( ! initialbin.isnonempty() ) {
	makeBorderTrim( from, to );
    } else {
	REAL rate[2];
	qlist->findRates( spbrkpts, tpbrkpts, rate );

    	if( decompose( initialbin, min(rate[0], rate[1]) ) ) 
	    mylongjmp( jumpbuffer, 31 );
    }

    backend.bgnsurf( renderhints.wiretris, renderhints.wirequads, nuid );
    subdivideInS( initialbin );
    backend.endsurf();
}

void
Subdivider::subdivideInS( Bin& source )
{
    if( renderhints.display_method == N_OUTLINE_PARAM ) {
	outline( source );
	freejarcs( source );
    } else {
	setArcTypeBezier();
	setNonDegenerate();
	splitInS( source, spbrkpts.start, spbrkpts.end );
    }
}


/*---------------------------------------------------------------------------
 * splitInS - split a patch and a bin by an isoparametric line
 *---------------------------------------------------------------------------
 */

void
Subdivider::splitInS( Bin& source, int start, int end )
{
    if( source.isnonempty() ) {
        if( start != end ) {
	    int	i = start + (end - start) / 2;
	    Bin left, right;
	    split( source, left, right, 0, spbrkpts.pts[i] );
	    splitInS( left, start, i );
	    splitInS( right, i+1, end );
        } else {
	    if( start == spbrkpts.start || start == spbrkpts.end ) {
		freejarcs( source );
	    } else if( renderhints.display_method == N_OUTLINE_PARAM_S ) {
		outline( source );
		freejarcs( source );
	    } else {
		setArcTypeBezier();
		setNonDegenerate();
		s_index = start;
		splitInT( source, tpbrkpts.start, tpbrkpts.end );
	    }
        }
    } 
}

/*---------------------------------------------------------------------------
 * splitInT - split a patch and a bin by an isoparametric line
 *---------------------------------------------------------------------------
 */

void
Subdivider::splitInT( Bin& source, int start, int end )
{
    if( source.isnonempty() ) {
        if( start != end ) {
	    int	i = start + (end - start) / 2;
	    Bin left, right;
	    split( source, left, right, 1, tpbrkpts.pts[i] );
	    splitInT( left, start, i );
	    splitInT( right, i+1, end );
        } else {
	    if( start == tpbrkpts.start || start == tpbrkpts.end ) {
		freejarcs( source );
	    } else if( renderhints.display_method == N_OUTLINE_PARAM_ST ) {
		outline( source );
		freejarcs( source );
	    } else {
		t_index = start;
		setArcTypeBezier();
		setDegenerate();

		REAL pta[2], ptb[2];
		pta[0] = spbrkpts.pts[s_index-1];
		pta[1] = tpbrkpts.pts[t_index-1];

		ptb[0] = spbrkpts.pts[s_index];
		ptb[1] = tpbrkpts.pts[t_index];
		qlist->downloadAll( pta, ptb, backend );
	    
		Patchlist patchlist( qlist, pta, ptb );
		samplingSplit( source, patchlist, renderhints.maxsubdivisions, 0 );
		setNonDegenerate();
		setArcTypeBezier();
	    }
        }
    } 
}

/*--------------------------------------------------------------------------
 * samplingSplit - recursively subdivide patch, cull check each subpatch  
 *--------------------------------------------------------------------------
 */

void
Subdivider::samplingSplit( 
    Bin& source, 
    Patchlist& patchlist, 
    int subdivisions, 
    int param )
{
    if( ! source.isnonempty() ) return;

    if( patchlist.cullCheck() == CULL_TRIVIAL_REJECT ) {
	freejarcs( source );
	return;
    }

    patchlist.getstepsize();

    if( renderhints.display_method == N_OUTLINE_PATCH ) {
        tessellation( source, patchlist );
	outline( source );
	freejarcs( source );
	return;
    } 

    //patchlist.clamp();

    tessellation( source, patchlist );

    if( patchlist.needsSamplingSubdivision() && (subdivisions > 0) ) {
	if( ! patchlist.needsSubdivision( 0 ) )
	    param = 1;
	else if( ! patchlist.needsSubdivision( 1 ) )
	    param = 0;
	else
	    param = 1 - param;

	Bin left, right;
	REAL mid = ( patchlist.pspec[param].range[0] +
		     patchlist.pspec[param].range[1] ) * 0.5;
	split( source, left, right, param, mid );
	Patchlist subpatchlist( patchlist, param, mid );
	samplingSplit( left, subpatchlist, subdivisions-1, param );
	samplingSplit( right, patchlist, subdivisions-1, param );
    } else {
	setArcTypePwl();
	setDegenerate();
	nonSamplingSplit( source, patchlist, subdivisions, param );
	setDegenerate();
	setArcTypeBezier();
    }
}

void
Subdivider::nonSamplingSplit( 
    Bin& source, 
    Patchlist& patchlist, 
    int subdivisions, 
    int param )
{
    if( patchlist.needsNonSamplingSubdivision() && (subdivisions > 0) ) {
	param = 1 - param;

	Bin left, right;
	REAL mid = ( patchlist.pspec[param].range[0] +
		     patchlist.pspec[param].range[1] ) * 0.5;
	split( source, left, right, param, mid );
	Patchlist subpatchlist( patchlist, param, mid );
	if( left.isnonempty() )
	    if( subpatchlist.cullCheck() == CULL_TRIVIAL_REJECT ) 
		freejarcs( left );
	    else
	        nonSamplingSplit( left, subpatchlist, subdivisions-1, param );
	if( right.isnonempty() ) 
	    if( patchlist.cullCheck() == CULL_TRIVIAL_REJECT ) 
		freejarcs( right );
	    else
	        nonSamplingSplit( right, patchlist, subdivisions-1, param );

    } else {
	// make bbox calls
	patchlist.bbox();
	backend.patch( patchlist.pspec[0].range[0], patchlist.pspec[0].range[1],
		       patchlist.pspec[1].range[0], patchlist.pspec[1].range[1] );
    
	if( renderhints.display_method == N_OUTLINE_SUBDIV ) {
	    outline( source );
	    freejarcs( source );
	} else {
	    setArcTypePwl();
	    setDegenerate();
	    findIrregularS( source );
	    monosplitInS( source, smbrkpts.start, smbrkpts.end );
	}
    }
}

/*--------------------------------------------------------------------------
 * tessellation - set tessellation of interior and boundary of patch
 *--------------------------------------------------------------------------
 */

void
Subdivider::tessellation( Bin& bin, Patchlist &patchlist )
{
    // tessellate unsampled trim curves
    tessellate( bin, patchlist.pspec[1].sidestep[1], patchlist.pspec[0].sidestep[1],
	 patchlist.pspec[1].sidestep[0], patchlist.pspec[0].sidestep[0] );

    // set interior sampling rates
    slicer.setstriptessellation( patchlist.pspec[0].stepsize, patchlist.pspec[1].stepsize );

    // set boundary sampling rates
    stepsizes[0] = patchlist.pspec[1].stepsize;
    stepsizes[1] = patchlist.pspec[0].stepsize;
    stepsizes[2] = patchlist.pspec[1].stepsize;
    stepsizes[3] = patchlist.pspec[0].stepsize;
}

/*---------------------------------------------------------------------------
 * monosplitInS - split a patch and a bin by an isoparametric line
 *---------------------------------------------------------------------------
 */

void
Subdivider::monosplitInS( Bin& source, int start, int end )
{
    if( source.isnonempty() ) {
        if( start != end ) {
	    int	i = start + (end - start) / 2;
	    Bin left, right;
	    split( source, left, right, 0, smbrkpts.pts[i] );
	    monosplitInS( left, start, i );
	    monosplitInS( right, i+1, end );
        } else {
	    if( renderhints.display_method == N_OUTLINE_SUBDIV_S ) {
		outline( source );
		freejarcs( source );
	    } else {
		setArcTypePwl();
		setDegenerate();
		findIrregularT( source );
		monosplitInT( source, tmbrkpts.start, tmbrkpts.end );
	    }
        }
    } 
}

/*---------------------------------------------------------------------------
 * monosplitInT - split a patch and a bin by an isoparametric line
 *---------------------------------------------------------------------------
 */

void
Subdivider::monosplitInT( Bin& source, int start, int end )
{
    if( source.isnonempty() ) {
        if( start != end ) {
	    int	i = start + (end - start) / 2;
	    Bin left, right;
	    split( source, left, right, 1, tmbrkpts.pts[i] );
	    monosplitInT( left, start, i );
	    monosplitInT( right, i+1, end );
        } else {
	    if( renderhints.display_method == N_OUTLINE_SUBDIV_ST ) {
		outline( source );
		freejarcs( source );
	    } else {
		render( source );
		freejarcs( source );
	    }
        }
    } 
}


/*----------------------------------------------------------------------------
 * findIrregularS - determine points of non-monotonicity is s direction
 *----------------------------------------------------------------------------
 */

void
Subdivider::findIrregularS( Bin& bin )
{
    assert( bin.firstarc()->check() != 0 );

    smbrkpts.grow( bin.numarcs() );

    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	REAL *a = jarc->prev->tail();
	REAL *b = jarc->tail();
	REAL *c = jarc->head();

	if( b[1] == a[1] && b[1] == c[1] ) continue;

	if( b[1] <= a[1] && b[1] <= c[1] ) {
	    if( ! ccwTurn_tr( jarc->prev, jarc ) )
                smbrkpts.add( b[0] );
	} else if( b[1] >= a[1] && b[1] >= c[1] ) {
	    if( ! ccwTurn_tl( jarc->prev, jarc ) )
                smbrkpts.add( b[0] );
        }
    }

    smbrkpts.filter();
} 

/*----------------------------------------------------------------------------
 * findIrregularT - determine points of non-monotonicity in t direction
 *		     where one arc is parallel to the s axis.
 *----------------------------------------------------------------------------
 */

void
Subdivider::findIrregularT( Bin& bin )
{
    assert( bin.firstarc()->check() != 0 );

    tmbrkpts.grow( bin.numarcs() );

    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	REAL *a = jarc->prev->tail();
	REAL *b = jarc->tail();
	REAL *c = jarc->head();

	if( b[0] == a[0] && b[0] == c[0] ) continue;

	if( b[0] <= a[0] && b[0] <= c[0] ) {
	    if( a[1] != b[1] && b[1] != c[1] ) continue; 
	    if( ! ccwTurn_sr( jarc->prev, jarc ) )
                tmbrkpts.add( b[1] );
	} else if ( b[0] >= a[0] && b[0] >= c[0] ) {
	    if( a[1] != b[1] && b[1] != c[1] ) continue; 
	    if( ! ccwTurn_sl( jarc->prev, jarc ) )
                tmbrkpts.add( b[1] );
	}
    }
    tmbrkpts.filter( );
}

/*-----------------------------------------------------------------------------
 * makeBorderTrim - if no user input trimming data then create 
 * a trimming curve around the boundaries of the Quilt.  The curve consists of
 * four Jordan arcs, one for each side of the Quilt, connected, of course,
 * head to tail. 
 *-----------------------------------------------------------------------------
 */

void
Subdivider::makeBorderTrim( const REAL *from, const REAL *to )
{ 
    REAL smin = from[0];
    REAL smax = to[0];
    REAL tmin = from[1];
    REAL tmax = to[1];

    pjarc = 0;

    Arc_ptr jarc = new(arcpool) Arc( arc_bottom, 0 );
    arctessellator.bezier( jarc, smin, smax, tmin, tmin );
    initialbin.addarc( jarc  );
    pjarc = jarc->append( pjarc );

    jarc = new(arcpool) Arc( arc_right, 0 );
    arctessellator.bezier( jarc, smax, smax, tmin, tmax );
    initialbin.addarc( jarc  );
    pjarc = jarc->append( pjarc );

    jarc = new(arcpool) Arc( arc_top, 0 );
    arctessellator.bezier( jarc, smax, smin, tmax, tmax );
    initialbin.addarc( jarc  );
    pjarc = jarc->append( pjarc );

    jarc = new(arcpool) Arc( arc_left, 0 );
    arctessellator.bezier( jarc, smin, smin, tmax, tmin );
    initialbin.addarc( jarc  );
    jarc->append( pjarc );

    assert( jarc->check() != 0 );
}

/*----------------------------------------------------------------------------
 * render - renders all monotone regions in a bin and frees the bin
 *----------------------------------------------------------------------------
 */

void
Subdivider::render( Bin& bin )
{
    bin.markall();

#ifdef N_ISOLINE_S
    slicer.setisolines( ( renderhints.display_method == N_ISOLINE_S ) ? 1 : 0 );
#else
    slicer.setisolines( 0 );
#endif

    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	if( jarc->ismarked() ) {
	    assert( jarc->check( ) != 0 );
	    Arc_ptr jarchead = jarc;
	    do {
		jarc->clearmark();
		jarc = jarc->next;
	    } while (jarc != jarchead);
	    slicer.slice( jarc );
	}
    }
}

/*---------------------------------------------------------------------------
 * outline - render the trimmed patch by outlining the boundary 
 *---------------------------------------------------------------------------
 */

void
Subdivider::outline( Bin& bin )
{
    bin.markall();
    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	if( jarc->ismarked() ) {
	    assert( jarc->check( ) != 0 );
	    Arc_ptr jarchead = jarc;
	    do {
		slicer.outline( jarc );
		jarc->clearmark();
		jarc = jarc->prev;
	    } while (jarc != jarchead);
	}
    }
}

/*---------------------------------------------------------------------------
 * freejarcs - free all arcs in a bin
 *---------------------------------------------------------------------------
 */

void
Subdivider::freejarcs( Bin& bin )
{
    bin.adopt();	/* XXX - should not be necessary */

    Arc_ptr jarc;
    while( jarc = bin.removearc() ) {
	if( jarc->pwlArc ) jarc->pwlArc->deleteMe( pwlarcpool ); jarc->pwlArc = 0;
	if( jarc->bezierArc) jarc->bezierArc->deleteMe( bezierarcpool ); jarc->bezierArc = 0;
	jarc->deleteMe( arcpool );
    }
}

/*----------------------------------------------------------------------------
 * tessellate - tessellate all Bezier arcs in a bin
 * 		   1) only accepts linear Bezier arcs as input 
 * 		   2) the Bezier arcs are stored in the pwlArc structure
 * 		   3) only vertical or horizontal lines work
 * 		-- should 
 * 		   1) represent Bezier arcs in BezierArc structure
 * 		      (this requires a multitude of changes to the code)
 * 		   2) accept high degree Bezier arcs (hard)
 * 		   3) map the curve onto the surface to determine tessellation
 * 		   4) work for curves of arbitrary geometry
 *----------------------------------------------------------------------------
 */


void
Subdivider::tessellate( Bin& bin, REAL rrate, REAL trate, REAL lrate, REAL brate )
{
    for( Arc_ptr jarc=bin.firstarc(); jarc; jarc=bin.nextarc() ) {
	if( jarc->isbezier( ) ) {
    	    assert( jarc->pwlArc->npts == 2 );	
	    TrimVertex  *pts = jarc->pwlArc->pts;
    	    REAL s1 = pts[0].param[0];
    	    REAL t1 = pts[0].param[1];
    	    REAL s2 = pts[1].param[0];
    	    REAL t2 = pts[1].param[1];
	    
    	    jarc->pwlArc->deleteMe( pwlarcpool ); jarc->pwlArc = 0;
	    
	    switch( jarc->getside() ) {
		case arc_left:
		    assert( s1 == s2 );
		    arctessellator.pwl_left( jarc, s1, t1, t2, lrate );
		    break;
		case arc_right:
		    assert( s1 == s2 );
		    arctessellator.pwl_right( jarc, s1, t1, t2, rrate );
		    break;
		case arc_top:
		    assert( t1 == t2 );
		    arctessellator.pwl_top( jarc, t1, s1, s2, trate );
		    break;
		case arc_bottom:
		    assert( t1 == t2 );
		    arctessellator.pwl_bottom( jarc, t1, s1, s2, brate );
		    break;
		case arc_none:
#ifndef NT
		    (void) abort();
#endif
		    break;
	    }
	    assert( ! jarc->isbezier() );
    	    assert( jarc->check() != 0 );
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\slicer.h ===
#ifndef __gluslicer_h_
#define __gluslicer_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * slicer.h - $Revision: 1.3 $
 */

#include "trimregi.h"
#include "mesher.h"
#include "coveandt.h"

class Backend;
class Arc;
class TrimVertex;

class Slicer : public CoveAndTiler, public Mesher {
public:
    			Slicer( Backend & );
			~Slicer( void );
    void		slice( Arc * );
    void		outline( Arc * );
    void		setstriptessellation( REAL, REAL );
    void		setisolines( int );
private:
    Backend&		backend;
    REAL		oneOverDu;
    REAL		du, dv;
    int			isolines;

    void		outline( void );
    void		initGridlines( void );
    void		advanceGridlines( long );
};
#endif /* __gluslicer_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\subdivid.h ===
#ifndef __glusubdivider_h_
#define __glusubdivider_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * subdivider.h - $Revision: 1.1 $
 */

#include "mysetjmp.h"
#include "bin.h"
#include "flist.h"
#include "slicer.h"
#include "arctess.h"
#include "trimvert.h"
#include "trimpool.h"

class Arc;
class Pool;
class Renderhints;
class Backend;
class Quilt;
class Patchlist;
class Curvelist;
#ifdef NT
struct JumpBuffer;
#else
class JumpBuffer;
#endif

class Subdivider {
public:
			Subdivider( Renderhints&, Backend& );
			~Subdivider( void );
    void		clear( void );

    void		beginTrims( void ) {}
    void		beginLoop( void );
    void		addArc( REAL *, Quilt *, long );
    void		addArc( int, TrimVertex *, long );
    void		endLoop( void ) {}
    void		endTrims( void ) {}

    void		beginQuilts( void );
    void		addQuilt( Quilt * );
    void		endQuilts( void ) {}

    void		drawCurves( void );
    void		drawSurfaces( long );

    int			ccwTurn_sl( Arc *, Arc * );
    int			ccwTurn_sr( Arc *, Arc * );
    int			ccwTurn_tl( Arc *, Arc * );
    int			ccwTurn_tr( Arc *, Arc * );

    void		setJumpbuffer( JumpBuffer * );

private:
    void		classify_headonleft_s( Bin &, Bin &, Bin &, REAL );
    void		classify_tailonleft_s( Bin &, Bin &, Bin &, REAL );
    void		classify_headonright_s( Bin &, Bin &, Bin &, REAL );
    void		classify_tailonright_s( Bin &, Bin &, Bin &, REAL );
    void		classify_headonleft_t( Bin &, Bin &, Bin &, REAL );
    void		classify_tailonleft_t( Bin &, Bin &, Bin &, REAL );
    void		classify_headonright_t( Bin &, Bin &, Bin &, REAL );
    void		classify_tailonright_t( Bin &, Bin &, Bin &, REAL );

    enum dir 		{ down, same, up, none };
    void		tessellate( Arc *, REAL );
    void		monotonize( Arc *, Bin & );
    int			isMonotone( Arc * );
    int			decompose( Bin &, REAL );


    Slicer		slicer;
    ArcTessellator	arctessellator;
    Pool		arcpool;
    Pool		bezierarcpool;
    Pool		pwlarcpool;
    TrimVertexPool	trimvertexpool;

    JumpBuffer*		jumpbuffer;
    Renderhints&	renderhints;
    Backend&		backend;

    Bin			initialbin;
    Arc *		pjarc;
    int 		s_index;
    int			t_index;
    Quilt *		qlist;
    Flist		spbrkpts;
    Flist		tpbrkpts;
    Flist		smbrkpts;
    Flist		tmbrkpts;
    REAL	 	stepsizes[4];
    int			showDegenerate;
    int			isArcTypeBezier;

    void		samplingSplit( Curvelist&, int );

    void		subdivideInS( Bin&  );
    void		splitInS( Bin&, int, int );
    void		splitInT( Bin&, int, int );
    void		samplingSplit( Bin&, Patchlist&, int, int );
    void		nonSamplingSplit( Bin&, Patchlist&, int, int );
    void		tessellation( Bin&, Patchlist& );
    void		monosplitInS( Bin&, int, int );
    void		monosplitInT( Bin&, int, int );

    void		outline( Bin & );
    void		freejarcs( Bin & );
    void		render( Bin & );
    void		split( Bin &, Bin &, Bin &, int, REAL );
    void		tessellate( Bin &, REAL, REAL, REAL, REAL );

    inline void		setDegenerate( void ) { showDegenerate = 1; }
    inline void		setNonDegenerate( void ) { showDegenerate = 0; }
    inline int		showingDegenerate( void ) { return showDegenerate; }
    inline void		setArcTypeBezier( void ) { isArcTypeBezier = 1; }
    inline void		setArcTypePwl( void ) { isArcTypeBezier = 0; }
    inline int		isBezierArcType( void ) { return isArcTypeBezier; }

    void		makeBorderTrim( const REAL *, const REAL * );
    void		split( Bin &, int, const REAL *, int, int );
    void		partition( Bin &, Bin &, Bin &, Bin &, Bin &, int, REAL );
    void		findIrregularS( Bin & );
    void		findIrregularT( Bin & );


    inline int		bbox( TrimVertex *, TrimVertex *, TrimVertex *, int );
    static int		bbox( REAL, REAL, REAL, REAL, REAL, REAL );
    static int		ccw( TrimVertex *, TrimVertex *, TrimVertex * );
    void		join_s( Bin &, Bin &, Arc *, Arc * );
    void		join_t( Bin &, Bin &, Arc *, Arc * );
    int			arc_split( Arc *, int, REAL, int );
    void		check_s( Arc *, Arc * );
    void		check_t( Arc *, Arc * );
    inline void		link( Arc *, Arc *, Arc *, Arc * );
    inline void		simple_link( Arc *, Arc * );
};

inline void
Subdivider::beginLoop( void ) 
{
    pjarc = 0;
}


#endif /* __glusubdivider_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\tobezier.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/* 
 * tobezier.c++ - $Revision: 1.6 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "mystring.h"
#include "quilt.h"
#include "knotvect.h"

/* local type definitions */
struct Breakpt {		/* breakpoints	*/
    Knot		value;		/* value	*/
    int			multi;		/* multiplicity	*/
    int			def;		/* deficit */
};

struct Knotspec {		/* knotvector format */
    long		order;		/* order of spline  */
    Knot_ptr		inkbegin;	/* input knot sequence */
    Knot_ptr		inkend;		/* location after last knot */
    Knot_ptr		outkbegin;	/* in-process knot subsequence */
    Knot_ptr		outkend;	/* location after last knot */
    Knot_ptr		kleft;		/* */
    Knot_ptr		kright;		/* */
    Knot_ptr		kfirst;		/* */
    Knot_ptr		klast;		/* */
    Knot_ptr		sbegin;		/* conversion factor values */
    Breakpt *		bbegin;		/* in-process breakpoints */
    Breakpt *		bend;		/* last breakpoint */
    int			ncoords;	/* coordinates per control point */
    int			prestride;	/* stride between input points */
    int			poststride;	/* stride between output points	*/
    int 		preoffset;	/* scaled point offset	*/
    int 		postoffset;	/* scaled point offset	*/
    int 		prewidth;	/* width of dimension	*/
    int 		postwidth;	/* width of dimension	*/
    int 		istransformed;	/* was dimension transformed */
    Knotspec *		next;   	/* next knotspec */
    Knotspec *		kspectotrans;   /* knotspec in transformation direction */

			Knotspec( void );
			~Knotspec( void );
    void		factors( void );
    void		insert( REAL * );
    void		preselect();
    void		select( void );
    void		copy( INREAL *, REAL * );
    void		breakpoints( void );
    void		knots( void );
    void		transform( REAL * );
    void		showpts( REAL * );
    
    void		pt_io_copy( REAL *, INREAL * );
    void		pt_oo_copy( REAL *, REAL * );
    void		pt_oo_sum( REAL*, REAL*, REAL*, Knot, Knot );
};

struct Splinespec {		/* a non-uniform tensor element */
			Splinespec( int );
                        ~Splinespec(void);
    Knotspec		*kspec;	/* format of each param. dir. */
    int			dim;		/* domain dimension */
    REAL *		outcpts;	/* Bezier control points */

    void		kspecinit( Knotvector & );
    void		kspecinit( Knotvector &, Knotvector & );
    void		select( void );
    void		layout( long );
    void		setupquilt( Quilt_ptr );
    void		copy( INREAL * );
    void		transform( void );
};

/*-----------------------------------------------------------------------------
 * Quilt::toBezier - convert from NURBS to rational Bezier 
 *-----------------------------------------------------------------------------
 */

void
Quilt::toBezier( 
    Knotvector& knotvector,	/* a knot vector */
    INREAL *ctlpts,		/* input contol points */
    long ncoords )		/* number of coordinates per control point */
{
    Splinespec spline( 1 );
    spline.kspecinit( knotvector );
    spline.select();
    spline.layout( ncoords );
    spline.setupquilt( this );
    spline.copy( ctlpts );
    spline.transform();
}

void
Quilt::toBezier( 
    Knotvector& sknotvector,	/* a knot vector */
    Knotvector& tknotvector,	/* a knot vector */
    INREAL *ctlpts,		/* input contol points */
    long ncoords )		/* number of coordinates per control point */
{
    Splinespec spline( 2 );
    spline.kspecinit( sknotvector, tknotvector );
    spline.select();
    spline.layout( ncoords );
    spline.setupquilt( this );
    spline.copy( ctlpts );
    spline.transform();
}
Splinespec::Splinespec( int dimen )
{
    dim = dimen;
}

Splinespec::~Splinespec( void )
{
    /* Note: do NOT delete 'outcpts' here since its address (not contents)
     * is copied in 'cpts' in this file in function Splinespec::setupquilt().
     * This block of memory will eventually be deleted in file quilt.c++ in
     * function Quilt::deleteMe() through 'cpts' so do NOT delete it here!
     */	
    Knotspec *ktrav= kspec;         //start at beginning of list 
    while (ktrav != 0) {            //any items to delete? 
       Knotspec *deleteThis= ktrav; //remember to delete this 
       ktrav= ktrav->next;          //go to next item if any
       delete deleteThis;           //delete it
    }	
} /* ~Splinespec() */

/*-----------------------------------------------------------------------------
 * Splinespec::kspecinit - initialize Splinespec structure
 *
 * Client: Quilt::toBezier
 *-----------------------------------------------------------------------------
 */

void
Splinespec::kspecinit( Knotvector& knotvector )
{
    kspec = new Knotspec;
    kspec->inkbegin = knotvector.knotlist;
    kspec->inkend = knotvector.knotlist + knotvector.knotcount;
    kspec->prestride = (int) knotvector.stride; 
    kspec->order = knotvector.order;
    kspec->next = NULL;
}

void
Splinespec::kspecinit( Knotvector& sknotvector, Knotvector& tknotvector )
{
    kspec = new Knotspec;
    Knotspec *tkspec = new Knotspec;

    kspec->inkbegin = sknotvector.knotlist;
    kspec->inkend = sknotvector.knotlist + sknotvector.knotcount;
    kspec->prestride = (int) sknotvector.stride; 
    kspec->order = sknotvector.order;
    kspec->next = tkspec;

    tkspec->inkbegin = tknotvector.knotlist;
    tkspec->inkend = tknotvector.knotlist + tknotvector.knotcount;
    tkspec->prestride = (int) tknotvector.stride; 
    tkspec->order = tknotvector.order;
    tkspec->next = NULL;
}


/*-----------------------------------------------------------------------------
 * Splinespec::select - select the subsegments to copy
 *
 * Client: gl_quilt_to_bezier	
 *-----------------------------------------------------------------------------
 */

void
Splinespec::select( )
{
    for( Knotspec *knotspec = kspec; knotspec; knotspec = knotspec->next ) {
	knotspec->preselect();
	knotspec->select();
    }
}

/*-----------------------------------------------------------------------------
 * Splinespec::layout - 
 *
 * Client: gl_quilt_to_bezier	
 *-----------------------------------------------------------------------------
 */

void
Splinespec::layout( long ncoords )
{

    long stride = ncoords;
    for( Knotspec *knotspec = kspec; knotspec; knotspec=knotspec->next ) {
	knotspec->poststride = (int) stride;
	stride *= (long)((knotspec->bend-knotspec->bbegin)*knotspec->order + knotspec->postoffset);
        knotspec->preoffset  *= knotspec->prestride;
	knotspec->prewidth  *= knotspec->poststride;
	knotspec->postwidth *= knotspec->poststride;
	knotspec->postoffset *= knotspec->poststride;
        knotspec->ncoords = (int) ncoords;
    }
    outcpts = new REAL[stride];
    assert( outcpts != 0 );  
}

/*-----------------------------------------------------------------------------
 * Splinespec::copy - copy the control points of current subobject
 *
 * Client: gl_quilt_to_bezier
 *-----------------------------------------------------------------------------
 */

void
Splinespec::copy( INREAL *incpts )
{
    kspec->copy( incpts, outcpts );
}

/*-----------------------------------------------------------------------------
 * Splinespec::setupquilt - assign all quilt variables from knotspec 
 *
 * Client: gl_quilt_to_bezier
 *-----------------------------------------------------------------------------
 */

void
Splinespec::setupquilt( Quilt_ptr quilt )
{
    Quiltspec_ptr qspec = quilt->qspec;
    quilt->eqspec = qspec + dim;
    for( Knotspec *knotspec = kspec; knotspec; knotspec=knotspec->next, qspec++ ) {
	qspec->stride	= knotspec->poststride;
	qspec->width	= knotspec->bend - knotspec->bbegin;
	qspec->order	= (int) knotspec->order;
	qspec->offset	= knotspec->postoffset;
	qspec->index	= 0;
	qspec->bdry[0]	= (knotspec->kleft == knotspec->kfirst) ? 1 : 0;
	qspec->bdry[1]	= (knotspec->kright == knotspec->klast) ? 1 : 0;
	qspec->breakpoints = new Knot[qspec->width+1];
	Knot_ptr k =  qspec->breakpoints;
	for( Breakpt *bk = knotspec->bbegin; bk <= knotspec->bend; bk++ )
	    *(k++) = bk->value;
    }
    quilt->cpts = outcpts;
    quilt->next = 0;
}

/*-----------------------------------------------------------------------------
 * Splinespec::transform - convert a spline to Bezier format
 *
 * Client: gl_quilt_to_bezier
 *-----------------------------------------------------------------------------
 */

void
Splinespec::transform( void )
{
    for( Knotspec *knotspec = kspec; knotspec; knotspec=knotspec->next )
        knotspec->istransformed = 0;

    for( knotspec = kspec; knotspec; knotspec=knotspec->next ) {
	for( Knotspec *kspec2 = kspec; kspec2; kspec2=kspec2->next )
	    kspec2->kspectotrans = knotspec;
	kspec->transform( outcpts );
	knotspec->istransformed = 1;
    }
}


/*-----------------------------------------------------------------------------
 * Knotspec::Knotspec -  constuct a knot spec 
 *-----------------------------------------------------------------------------
 */

Knotspec::Knotspec( void )
{
    bbegin = 0;
    sbegin = 0;
    outkbegin = 0;
}

/*-----------------------------------------------------------------------------
 * Knotspec::copy -  copy the control points along minor direction 
 *
 * Client: Splinespec::copy
 *-----------------------------------------------------------------------------
 */

void
Knotspec::copy( INREAL *inpt, REAL *outpt )
{
    inpt = (INREAL *) (((char *) inpt) + preoffset);

    if( next ) {
        for( REAL *lpt=outpt+prewidth; outpt != lpt; outpt += poststride ) {
	    next->copy( inpt, outpt );
	    inpt = (INREAL *) (((char *) inpt) + prestride);
	}
   } else {
        for( REAL *lpt=outpt+prewidth; outpt != lpt; outpt += poststride ) {
	    pt_io_copy( outpt, inpt );
	    inpt = (INREAL *) (((char *) inpt) + prestride);
	}
     }
}

/*-----------------------------------------------------------------------------
 * Knotspec::showpts - print out points before transformation
 *
 * Client: Knotspec::select
 *-----------------------------------------------------------------------------
 */
void
Knotspec::showpts( REAL *outpt )
{
    if( next ) {
        for( REAL *lpt=outpt+prewidth; outpt != lpt; outpt += poststride )
	    next->showpts( outpt );
    } else {
        for( REAL *lpt=outpt+prewidth; outpt != lpt; outpt += poststride )
	    dprintf(  "show %g %g %g\n", outpt[0], outpt[1], outpt[2] );
    }
}

/*-----------------------------------------------------------------------------
 * Knotspec::factors - precompute scale factors 	
 *	   - overwrites knot vector, actual new knot vector is NOT produced
 *
 * Client: Knotspec::select
 *-----------------------------------------------------------------------------
 */

void
Knotspec::factors( void )
{
    Knot *mid = (outkend - 1) - order + bend->multi;
    Knot_ptr fptr = sbegin;

    for( Breakpt *bpt = bend; bpt >= bbegin; bpt-- ) {
    	mid -= bpt->multi;		// last knot less than knot to insert
	int def = bpt->def - 1;		// number of knots to insert
	if( def <= 0 ) continue;
	Knot kv = bpt->value;		// knot to insert

	Knot *kf = (mid-def) + (order-1);
	for( Knot *kl = kf + def; kl != kf; kl-- ) {
	    Knot *kh, *kt;
	    for( kt=kl, kh=mid; kt != kf; kh--, kt-- ) 
		*(fptr++) = (kv - *kh) / (*kt - *kh);
	    *kl = kv;
	}
    }
}

/*-----------------------------------------------------------------------------
 * Knotspec::insert - convert subobject in direction of kspec into Bezier
 *
 * Client: Knotspec::transform
 *-----------------------------------------------------------------------------
 */

void
Knotspec::insert( REAL *p )
{
    Knot_ptr fptr = sbegin;
    REAL *srcpt = p + prewidth - poststride;
    REAL *dstpt = p + postwidth + postoffset - poststride;
    Breakpt *bpt = bend;

   for( REAL *pend = srcpt - poststride*bpt->def; srcpt != pend; pend +=poststride ) {
	REAL *p1 = srcpt;
	for( REAL *p2 = srcpt-poststride; p2 != pend; p1 = p2, p2 -= poststride ) {
	    pt_oo_sum( p1, p1, p2, *fptr, 1.0-*fptr );
	    fptr++;
	}
    }

    for( --bpt; bpt >= bbegin; bpt-- ) {

	for( int multi = bpt->multi; multi > 0; multi-- ) {
	    pt_oo_copy( dstpt, srcpt );
	    dstpt -= poststride;
	    srcpt -= poststride;	
	}
    
	for( REAL *pend = srcpt - poststride*bpt->def; srcpt != pend; pend +=poststride, dstpt-=poststride ) {
	    pt_oo_copy( dstpt, srcpt );
	    REAL *p1 = srcpt;

	    for( REAL *p2 = srcpt-poststride; p2 != pend; p1=p2, p2 -= poststride ) {
		pt_oo_sum( p1, p1, p2, *fptr, 1.0-*fptr );
		fptr++;
	    }
	}
    }
}

/*-----------------------------------------------------------------------------
 * Knotspec::preselect - initialize kspec for processing
 *
 * Client: Splinespec::select
 *-----------------------------------------------------------------------------
 */

void
Knotspec::preselect( void )
{
    Knot kval; 

    /* position klast after last knot of "last" breakpoint */
    for( klast = inkend - order, kval = *klast; klast != inkend; klast++ ) 
	if( ! identical( *klast, kval ) ) break;

    /* position kfirst after last knot of "first" breakpoint */
    for( kfirst = inkbegin+order-1, kval= *kfirst;  kfirst != inkend; kfirst++ )
	if( ! identical( *kfirst, kval ) ) break;

    /* compute multiplicity of first breakpoint */
    for( Knot_ptr k  = kfirst - 1; k >= inkbegin; k-- ) 
	if( ! identical( kval, *k ) ) break;    
    k++;

    /* allocate space for breakpoints -
       use worst case estimate on number of breakpoints */

    bbegin = new Breakpt[(klast - kfirst)+1];
    /* record multiplicity and value of first breakpoint */
    bbegin->multi = kfirst - k;
    bbegin->value = kval;
    bend = bbegin;

    kleft = kright = kfirst;
}


/*-----------------------------------------------------------------------------
 * Knotspec::select - Knotspec::select segments and precompute scale factors
 *
 * Client: Splinespec::select
 *-----------------------------------------------------------------------------
 */

void
Knotspec::select( void )
{
    breakpoints();
    knots();
    factors();
    
    preoffset	= kleft - (inkbegin + order);
    postwidth	= (int)((bend - bbegin) * order);
    prewidth 	= (int)((outkend - outkbegin) - order);
    postoffset  = (bbegin->def > 1) ? (bbegin->def-1) : 0;
}
 
/*-----------------------------------------------------------------------------
 * Knotspec::breakpoints - compute breakpoints for knotspec
 *
 * Client: Knotspec::select
 *-----------------------------------------------------------------------------
 */

void
Knotspec::breakpoints( void )
{
    Breakpt *ubpt	= bbegin;
    Breakpt *ubend	= bend;
    long    nfactors  	= 0;

    ubpt->value	= ubend->value;
    ubpt->multi	= ubend->multi;

    kleft = kright;

    for( ; kright != klast; kright++ ) {
        if ( identical(*kright,ubpt->value) ) {
	    (ubpt->multi)++;
	} else {
    	    ubpt->def = (int) (order - ubpt->multi);
    	    nfactors += (ubpt->def * (ubpt->def - 1)) / 2;
	    (++ubpt)->value = *kright;
	    ubpt->multi = 1;
	}
    }
    ubpt->def = (int) (order - ubpt->multi);
    nfactors += (ubpt->def * (ubpt->def - 1)) / 2;

    bend = ubpt;

    if( nfactors ) {	    
        sbegin = new Knot[nfactors];
    } else {
	sbegin = NULL;
    }
}


/*-----------------------------------------------------------------------------
 * Knotspec::knots - copy relevant subsequence of knots into temporary area
 *
 * Client: Knotspec::select
 *-----------------------------------------------------------------------------
 */

void
Knotspec::knots( void )
{
    Knot_ptr inkpt = kleft - order;
    Knot_ptr inkend = kright  + bend->def;

    /* allocate space for knots and factors */
    outkbegin = new Knot[inkend-inkpt];
    for( Knot_ptr outkpt = outkbegin; inkpt != inkend; inkpt++, outkpt++ ) 
	*outkpt = *inkpt;

    outkend = outkpt;
}


/*-----------------------------------------------------------------------------
 * Knotspec::transform -	convert a spline along a given direction 
 *
 * Client: Splienspec::transform
 *-----------------------------------------------------------------------------
 */

void
Knotspec::transform( REAL *p )
{
   if( next ) {
	if( this == kspectotrans ) {
	    next->transform( p );
	} else {
	    if( istransformed ) {
		p += postoffset;
		for( REAL *pend = p + postwidth; p != pend; p += poststride )
		    next->transform( p );
	    } else {
		REAL *pend = p + prewidth;
		for( ; p != pend; p += poststride )
		    next->transform( p );
	    }
	}
   } else {
	if( this == kspectotrans ) {
	    insert( p );
	} else {
	    if( istransformed ) {
		p += postoffset;
		for( REAL *pend = p + postwidth; p != pend; p += poststride )
		    kspectotrans->insert( p );
	    } else {
		REAL *pend = p + prewidth;
		for( ; p != pend; p += poststride )
		    kspectotrans->insert( p );
	    }
	}
   }
}

/*-----------------------------------------------------------------------------
 * Knotspec::~Knotspec - free space alocated for knotspec
 *-----------------------------------------------------------------------------
 */

Knotspec::~Knotspec( void )
{
    if( bbegin ) delete[] bbegin;
    if( sbegin ) delete[] sbegin;
    if( outkbegin ) delete[] outkbegin;
}


/*-----------------------------------------------------------------------------
 * pt_io_copy - make internal copy of input cntrl pt. of x coords
 *-----------------------------------------------------------------------------
 */

void
Knotspec::pt_io_copy( REAL *topt, INREAL *frompt )
{
    switch( ncoords ) {
    case 4:
        topt[3] = (REAL) frompt[3];
    case 3:
        topt[2] = (REAL) frompt[2];
    case 2:
        topt[1] = (REAL) frompt[1];
    case 1:
        topt[0] = (REAL) frompt[0];
	break;
    default: {
	    for( int i = 0; i < ncoords; i++ )
		*topt++ = (REAL) *frompt++;
	}
    }
}

/*-----------------------------------------------------------------------------
 * pt_oo_copy - make internal copy of internal cntrl pt. of x coords
 *-----------------------------------------------------------------------------
 */

void
Knotspec::pt_oo_copy( REAL *topt, REAL *frompt )
{
    switch( ncoords ) {
    case 4:
        topt[3] = frompt[3];
    case 3:
        topt[2] = frompt[2];
    case 2:
        topt[1] = frompt[1];
    case 1:
        topt[0] = frompt[0];
	break;
    default:
	memcpy( topt, frompt, ncoords * sizeof( REAL ) );
    }
}

/*-----------------------------------------------------------------------------
 * pt_oo_sum - compute affine combination of internal cntrl pts
 *-----------------------------------------------------------------------------
 */

void
Knotspec::pt_oo_sum( REAL *x, REAL *y, REAL *z, Knot a, Knot b )
{
    switch( ncoords ) {
    case 4:
        x[3] = a * y[3]  +  b * z[3];
    case 3:
        x[2] = a * y[2]  +  b * z[2];
    case 2:
        x[1] = a * y[1]  +  b * z[1];
    case 1:
        x[0] = a * y[0]  +  b * z[0];
	break;
    default: {
          for( int i = 0; i < ncoords; i++ )
              *x++ = a * *y++   +   b * *z++;
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\trimline.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimline.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "trimline.h"
#include "backend.h"

Trimline::Trimline()
{
    size = 0; pts = 0; numverts = 0;
    tinterp = &t; binterp = &b; 
}

Trimline::~Trimline()
{
    if( pts ) delete[] pts; 
}

void 
Trimline::init( TrimVertex *v )
{
    reset();
    grow(1);
    append(v);
}

inline void
Trimline::grow( long npts )
{
    if( size < npts ) {
	size = 2 * npts;
	if( pts ) delete[] pts; 
        pts = new TrimVertex_p[size];
    }
}

inline void
Trimline::append( TrimVertex *v )
{
    assert( numverts != size ); 
    pts[numverts++] = v;
}

void
Trimline::init( long npts, Arc_ptr jarc, long last )
{
    jarcl.init( jarc, 0, last );
    grow( npts + 2 );
}

inline void
Trimline::swap()
{
    TrimVertex *tmp=tinterp; 
    tinterp=binterp; 
    binterp=tmp;
}

void
Trimline::getNextPt()
{
    *binterp = *jarcl.getnextpt();    
}

void 
Trimline::getPrevPt()
{
    *binterp = *jarcl.getprevpt();
}

/*----------------------------------------------------------------------
 * getNextPts - make arrays of pointers to trim points on left and right
 *		hulls of trim strip.
 *----------------------------------------------------------------------
 */
void
Trimline::getNextPts( REAL vval, Backend& backend )
{
    reset(); swap(); append( tinterp );
    assert( tinterp->param[1] >= vval );

    register TrimVertex *p;
    for( p=jarcl.getnextpt() ; p->param[1] >= vval; p=jarcl.getnextpt() ) {
	append( p ); 
    }

    /* compute and copy pointer to final point on left hull */
    if( interpvert( last(), p, binterp, vval ) ) {
	binterp->nuid = p->nuid;
	backend.triangle( p, binterp, last() );
        append( binterp );
    }
    jarcl.reverse();
    (void) jarcl.getprevpt(); 	/* reset jarcl to proper position */
    jarcl.reverse();
}

void 
Trimline::getPrevPts( REAL vval, Backend& backend )
{
    reset(); swap(); append( tinterp );
    assert( tinterp->param[1] >= vval );

    register TrimVertex *q;
    for( q=jarcl.getprevpt(); q->param[1] >= vval; q=jarcl.getprevpt() ) {
	append( q );
    }

    /* compute and copy pointer to final point on right hull */
    if( interpvert( q, last(), binterp, vval ) ) {
	binterp->nuid = q->nuid;
	backend.triangle( last(), binterp, q );
        append( binterp );
    }
    jarcl.reverse();
    (void) jarcl.getnextpt();  /* reset jarcl to proper position */
    jarcl.reverse();
}

void
Trimline::getNextPts( Arc_ptr botarc )
{
    reset(); swap(); append( tinterp );

    PwlArc *lastpwl = botarc->prev->pwlArc;
    TrimVertex *lastpt1 = &lastpwl->pts[lastpwl->npts-1];
    TrimVertex *lastpt2 = botarc->pwlArc->pts;

    register TrimVertex *p = jarcl.getnextpt();
    for( append( p ); p != lastpt2; append( p ) ) {
	assert( p != lastpt1 );
	p = jarcl.getnextpt();
    }
}

void
Trimline::getPrevPts( Arc_ptr botarc )
{
    reset();  swap(); append( tinterp );

    PwlArc *lastpwl = botarc->prev->pwlArc;
    TrimVertex *lastpt1 = &lastpwl->pts[lastpwl->npts-1];
    TrimVertex *lastpt2 = botarc->pwlArc->pts;

    register TrimVertex *q =  jarcl.getprevpt();
    for( append( q ); q != lastpt1; append( q ) ) {
	assert( q != lastpt2 );
	q = jarcl.getprevpt();
    }
}


long
Trimline::interpvert( TrimVertex *a, TrimVertex *b, TrimVertex *c, REAL vval )
{
    REAL denom = a->param[1] - b->param[1];

    if(denom != 0) {
	if( vval == a->param[1] ) {
	    c->param[0] = a->param[0]; 
	    c->param[1] = a->param[1];
	    c->nuid = a->nuid;
	    return 0;
	} else if( vval == b->param[1] ) {
	    c->param[0] = b->param[0]; 
	    c->param[1] = b->param[1];
	    c->nuid = b->nuid;
	    return 0;
	} else {
	    REAL r = (a->param[1] - vval)/denom;
	    c->param[0] =  a->param[0] - r * (a->param[0] - b->param[0]);
	    c->param[1] = vval;
	    return 1;
	}
    } else {
        c->param[0] = a->param[0]; 
        c->param[1] = a->param[1];
	c->nuid = a->nuid;
	return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\trimpool.h ===
#ifndef __glutrimvertpool_h_
#define __glutrimvertpool_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimvertexpool.h - $Revision: 1.1 $
 */

#include "bufpool.h"

class TrimVertex;

#define INIT_VERTLISTSIZE  200

class TrimVertexPool {
public:
    			TrimVertexPool( void );
    			~TrimVertexPool( void );
    void		clear( void );
    TrimVertex *	get( int );
private:
    Pool		pool;
    TrimVertex **	vlist;
    int			nextvlistslot;
    int			vlistsize;
};
#endif /* __glutrimvertpool_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\trimregi.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimregion.c++ - $Revision: 1.2 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "trimregi.h"
#include "backend.h"

TrimRegion::TrimRegion( void )
{
}

void
TrimRegion::setDu( REAL du )
{
    oneOverDu = 1.0/du;
}

void
TrimRegion::init( long npts, Arc_ptr extrema )
{
    left.init( npts, extrema, extrema->pwlArc->npts - 1 ); 
    left.getNextPt();

    right.init( npts, extrema, 0 ); 
    right.getPrevPt();
}

void
TrimRegion::getPts( Arc_ptr extrema )
{
    left.getNextPts( extrema );
    right.getPrevPts( extrema );
}

void
TrimRegion::getPts( Backend &backend )
{
    left.getNextPts( bot.vval, backend );
    right.getPrevPts( bot.vval, backend );
}

void 
TrimRegion::getGridExtent( void )
{
    getGridExtent( left.last(), right.last() );
}

void
TrimRegion::getGridExtent( TrimVertex *l, TrimVertex *r )
{
    bot.ustart = (long) ((l->param[0] - uarray.uarray[0])*oneOverDu);
    if( l->param[0] >= uarray.uarray[bot.ustart] ) bot.ustart++;
//  if( l->param[0] > uarray.uarray[bot.ustart] ) bot.ustart++;
    assert( l->param[0] <= uarray.uarray[bot.ustart] );
    assert( l->param[0] >= uarray.uarray[bot.ustart-1] );

    bot.uend = (long) ((r->param[0] - uarray.uarray[0])*oneOverDu);
    if( uarray.uarray[bot.uend] >= r->param[0] ) bot.uend--;
//  if( uarray.uarray[bot.uend] > r->param[0] ) bot.uend--;
    assert( r->param[0] >= uarray.uarray[bot.uend] );
    assert( r->param[0] <= uarray.uarray[bot.uend+1] );
}

int
TrimRegion::canTile( void )
{
    TrimVertex *lf = left.first();
    TrimVertex *ll = left.last();
    TrimVertex *l = ( ll->param[0] > lf->param[0] ) ? ll : lf; 

    TrimVertex *rf = right.first();
    TrimVertex *rl = right.last();
    TrimVertex *r = ( rl->param[0] < rf->param[0] ) ? rl : rf;
    return (l->param[0] <= r->param[0]) ? 1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\trimregi.h ===
#ifndef __glutrimregion_h_
#define __glutrimregion_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimregion.h - $Revision: 1.2 $
 */

#include "trimline.h"
#include "gridline.h"
#include "uarray.h"

class Arc;
class Backend;

class TrimRegion {
public:
			TrimRegion();
    Trimline		left;
    Trimline		right;
    Gridline		top;
    Gridline		bot;
    Uarray		uarray;

    void		init( REAL );
    void		advance( REAL, REAL, REAL );
    void		setDu( REAL );
    void		init( long, Arc * );
    void		getPts( Arc * );
    void		getPts( Backend & );
    void		getGridExtent( TrimVertex *, TrimVertex * );
    void		getGridExtent( void );
    int			canTile( void );
private:
    REAL		oneOverDu;
};

inline void
TrimRegion::init( REAL vval ) 
{
    bot.vval = vval;
}

inline void
TrimRegion::advance( REAL topVindex, REAL botVindex, REAL botVval )
{
    top.vindex	= (long) topVindex;
    bot.vindex	= (long) botVindex;
    top.vval	= bot.vval;
    bot.vval	= botVval;
    top.ustart	= bot.ustart;
    top.uend	= bot.uend;
}
#endif /* __glutrimregion_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\trimvert.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimvertexpool.c++ - $Revision: 1.1 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "mystring.h"
#include "trimvert.h"
#include "trimpool.h"
#include "bufpool.h"

/*----------------------------------------------------------------------------
 * TrimVertexPool::TrimVertexPool 
 *----------------------------------------------------------------------------
 */
TrimVertexPool::TrimVertexPool( void )
	: pool( sizeof(TrimVertex)*3, 32, "Threevertspool" )
{
    // initialize array of pointers to vertex lists
    nextvlistslot = 0;
    vlistsize = INIT_VERTLISTSIZE;
    vlist = new TrimVertex_p[vlistsize];
}

/*----------------------------------------------------------------------------
 * TrimVertexPool::~TrimVertexPool 
 *----------------------------------------------------------------------------
 */
TrimVertexPool::~TrimVertexPool( void )
{
    // free all arrays of TrimVertices vertices
    while( nextvlistslot ) {
	delete vlist[--nextvlistslot];
    }

    // reallocate space for array of pointers to vertex lists
    if( vlist ) delete[] vlist;
}

/*----------------------------------------------------------------------------
 * TrimVertexPool::clear 
 *----------------------------------------------------------------------------
 */
void
TrimVertexPool::clear( void )
{
    // reinitialize pool of 3 vertex arrays    
    pool.clear();

    // free all arrays of TrimVertices vertices
    while( nextvlistslot ) {
	delete vlist[--nextvlistslot];
	vlist[nextvlistslot] = 0;
    }

    // reallocate space for array of pointers to vertex lists
    if( vlist ) delete[] vlist;
    vlist = new TrimVertex_p[vlistsize];
}


/*----------------------------------------------------------------------------
 * TrimVertexPool::get - allocate a vertex list
 *----------------------------------------------------------------------------
 */
TrimVertex *
TrimVertexPool::get( int n )
{
    TrimVertex	*v;
    if( n == 3 ) {
	v = (TrimVertex *) pool.new_buffer();
    } else {
        if( nextvlistslot == vlistsize ) {
	    vlistsize *= 2;
	    TrimVertex_p *nvlist = new TrimVertex_p[vlistsize];
	    memcpy( nvlist, vlist, nextvlistslot * sizeof(TrimVertex_p) );
	    if( vlist ) delete[] vlist;
	    vlist = nvlist;
        }
        v = vlist[nextvlistslot++] = new TrimVertex[n];
    }
    return v;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\trimvert.h ===
#ifndef __glutrimvertex_h_
#define __glutrimvertex_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimvertex.h - $Revision: 1.2 $
 */

#include "types.h"

/*#define USE_OPTTT*/

#ifdef NT
class TrimVertex { public: /* a vertex on a trim curve */
#else
struct TrimVertex { /* a vertex on a trim curve */
#endif
    REAL		param[2];	/* parametric space coords */
#ifdef USE_OPTTT
    REAL                cache_point[4]; //only when USE_OPTTT is on in slicer.c++
    REAL                cache_normal[3];
#endif
    long		nuid;
};

typedef TrimVertex *TrimVertex_p;

inline REAL  
det3( TrimVertex *a, TrimVertex *b, TrimVertex *c ) 
{         
    return a->param[0] * (b->param[1]-c->param[1]) + 
	   b->param[0] * (c->param[1]-a->param[1]) + 
	   c->param[0] * (a->param[1]-b->param[1]);
}

#endif /* __glutrimvertex_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\trimline.h ===
#ifndef __glutrimline_h_
#define __glutrimline_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * trimline.h - $Revision: 1.1 $
 */

class Arc;
class Backend;

#include "trimvert.h"
#include "jarcloc.h"


class Trimline {
private:
    TrimVertex**	pts; 	
    long 		numverts;
    long		i;
    long		size;
    Jarcloc		jarcl;
    TrimVertex		t, b;
    TrimVertex 		*tinterp, *binterp;
    void		reset( void ) { numverts = 0; }
    inline void		grow( long );
    inline void		swap( void );
    inline void		append( TrimVertex * );
    static long		interpvert( TrimVertex *, TrimVertex *, TrimVertex *, REAL );



public:
			Trimline();
			~Trimline();
    void		init( TrimVertex * );
    void		init( long, Arc *, long );
    void		getNextPt( void );
    void		getPrevPt( void );
    void		getNextPts( REAL, Backend & );
    void		getPrevPts( REAL, Backend & );
    void		getNextPts( Arc * );
    void		getPrevPts( Arc * );
    inline TrimVertex *	next( void );
    inline TrimVertex *	prev( void ); 
    inline TrimVertex *	first( void );
    inline TrimVertex *	last( void );
};

inline TrimVertex *
Trimline::next( void ) 
{
    if( i < numverts) return pts[i++]; else return 0; 
} 

inline TrimVertex *
Trimline::prev( void ) 
{
    if( i >= 0 ) return pts[i--]; else return 0; 
} 

inline TrimVertex *
Trimline::first( void ) 
{
    i = 0; return pts[i]; 
}

inline TrimVertex *
Trimline::last( void ) 
{
    i = numverts; return pts[--i]; 
}  
#endif /* __glutrimline_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\types.h ===
#ifndef __glutypes_h_
#define __glutypes_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * types.h - $Revision: 1.1 $
 */

//typedef double		INREAL;
#define INREAL          float
typedef float		REAL;
typedef void 		(*Pfvv)( void );
typedef void 		(*Pfvf)( float * );
typedef int		(*cmpfunc)(const void *, const void *);
typedef	REAL		Knot, *Knot_ptr;/* knot values */

#endif /* __glutypes_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\uarray.h ===
#ifndef __gluuarray_h_
#define __gluuarray_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * uarray.h - $Revision: 1.1 $
 */

#include "types.h"

class Arc;

class Uarray {
private:
    long		size;
    long		ulines;
public:
			Uarray();
			~Uarray();
    long		init( REAL, Arc *, Arc * );
    REAL *		uarray;
};

#endif /* __gluuarray_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\uarray.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * uarray.c++ - $Revision: 1.4 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "uarray.h"
#include "arc.h"

Uarray::Uarray( void )
{
    uarray = 0;
    size = 0;
}

Uarray::~Uarray( void )
{
    if( uarray ) delete[] uarray;		
}

long
Uarray::init( REAL delta, Arc_ptr lo, Arc_ptr hi )
{
    ulines = (long) ((hi->tail()[0] - lo->tail()[0])/delta) + 3;
    if( size < ulines ) {
	size = ulines * 2;
	if( uarray ) delete[] uarray;		
	uarray = new REAL[size];
	assert( uarray != 0);
    }
    uarray[0] = lo->tail()[0] - delta/2.0;
    for( long i = 1 ; i != ulines; i++ )
	uarray[i] = uarray[0] + i*delta;
    return ulines;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\nt\errinit.c ===
/******************************Module*Header*******************************\
* Module Name: errinit.c
*
* Initialize the NURBS error string tables.
*
* Created: 18-Feb-1994 00:06:53
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include "glstring.h"

static UINT auiNurbsErrors[] = {
    STR_NURB_00,    // " "
    STR_NURB_01,    // "spline order un-supported"
    STR_NURB_02,    // "too few knots"
    STR_NURB_03,    // "valid knot range is empty"
    STR_NURB_04,    // "decreasing knot sequence knot"
    STR_NURB_05,    // "knot multiplicity greater than order of spline"
    STR_NURB_06,    // "endcurve() must follow bgncurve()"
    STR_NURB_07,    // "bgncurve() must precede endcurve()"
    STR_NURB_08,    // "missing or extra geometric data"
    STR_NURB_09,    // "can't draw pwlcurves"
    STR_NURB_10,    // "missing or extra domain data"
    STR_NURB_11,    // "missing or extra domain data"
    STR_NURB_12,    // "endtrim() must precede endsurface()"
    STR_NURB_13,    // "bgnsurface() must precede endsurface()"
    STR_NURB_14,    // "curve of improper type passed as trim curve"
    STR_NURB_15,    // "bgnsurface() must precede bgntrim()"
    STR_NURB_16,    // "endtrim() must follow bgntrim()"
    STR_NURB_17,    // "bgntrim() must precede endtrim()"
    STR_NURB_18,    // "invalid or missing trim curve"
    STR_NURB_19,    // "bgntrim() must precede pwlcurve()"
    STR_NURB_20,    // "pwlcurve referenced twice"
    STR_NURB_21,    // "pwlcurve and nurbscurve mixed"
    STR_NURB_22,    // "improper usage of trim data type"
    STR_NURB_23,    // "nurbscurve referenced twice"
    STR_NURB_24,    // "nurbscurve and pwlcurve mixed"
    STR_NURB_25,    // "nurbssurface referenced twice"
    STR_NURB_26,    // "invalid property"
    STR_NURB_27,    // "endsurface() must follow bgnsurface()"
    STR_NURB_28,    // "intersecting or misoriented trim curves"
    STR_NURB_29,    // "intersecting trim curves"
    STR_NURB_30,    // "UNUSED"
    STR_NURB_31,    // "unconnected trim curves"
    STR_NURB_32,    // "unknown knot error"
    STR_NURB_33,    // "negative vertex count encountered"
    STR_NURB_34,    // "negative byte-stride encounteed"
    STR_NURB_35,    // "unknown type descriptor"
    STR_NURB_36,    // "null control point reference"
    STR_NURB_37     // "duplicate point on pwlcurve"
};

#define NERRORS ( sizeof(auiNurbsErrors)/sizeof(auiNurbsErrors[0]) )

char *__glNurbsErrors[NERRORS];
WCHAR *__glNurbsErrorsW[NERRORS];

VOID vInitNurbStrings(HINSTANCE hMod, BOOL bAnsi)
{
    int i;

    if (bAnsi)
    {
        for (i = 0; i < NERRORS; i++)
            __glNurbsErrors[i] = pszGetResourceStringA(hMod, auiNurbsErrors[i]);
    }
    else
    {
        for (i = 0; i < NERRORS; i++)
            __glNurbsErrorsW[i] = pwszGetResourceStringW(hMod, auiNurbsErrors[i]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\varray.cxx ===
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * varray.c++ - $Revision: 1.6 $
 * 	Derrick Burns - 1991
 */

#include "glimport.h"
#include "myassert.h"
#include "mystdio.h"
#include "varray.h"
#include "arc.h"
#include "math.h"         // fabs()

#define TINY 0.0001
inline long sgn( REAL x ) 
{
    return (x < -TINY) ? -1 :  ((x > TINY) ? 1 : 0 );
}


Varray::Varray( void )
{
    varray = 0;
    size = 0;
}

Varray::~Varray( void )
{
    if( varray ) delete[] varray; 
}

inline void
Varray::update( Arc_ptr arc, long dir[2], REAL val )
{
    register long ds = sgn(arc->tail()[0] - arc->prev->tail()[0]);
    register long dt = sgn(arc->tail()[1] - arc->prev->tail()[1]);

    if( dir[0] != ds || dir[1] != dt ) {
	dir[0] = ds;
	dir[1] = dt;
	append( val );
    }
}

void
Varray::grow( long guess )
{
    if( size < guess ) {
	size = guess * 2;
	if( varray ) delete[] varray; 
	varray = new REAL[size];
	assert( varray != 0 );
    }
}

long
Varray::init( REAL delta, Arc_ptr toparc, Arc_ptr botarc )
{
    Arc_ptr left = toparc->next;
    Arc_ptr right = toparc;
    long ldir[2], rdir[2];
    
    ldir[0] = sgn( left->tail()[0] - left->prev->tail()[0] );
    ldir[1] = sgn( left->tail()[1] - left->prev->tail()[1] );
    rdir[0] = sgn( right->tail()[0] - right->prev->tail()[0] );
    rdir[1] = sgn( right->tail()[1] - right->prev->tail()[1] );

    vval[0] = toparc->tail()[1];
    numquads = 0;

    while( 1 ) {
	switch( sgn( left->tail()[1] - right->prev->tail()[1] ) ) {
	case 1:
	    left = left->next;
	    update( left, ldir, left->prev->tail()[1] );
	    break;
	case -1: 
	    right = right->prev;
	    update( right, rdir, right->tail()[1] );
	    break;
	case 0:
	    if( fabs(left->tail()[1] - botarc->tail()[1]) < TINY) goto end;
            if( fabs(left->tail()[0]-right->prev->tail()[0]) < TINY &&
                fabs(left->tail()[1]-right->prev->tail()[1]) < TINY) goto end;
	    left = left->next;
	    break;
 	}
    }

end:
    append( botarc->tail()[1] );

    grow( ((long) ((vval[0] - vval[numquads])/delta)) + numquads + 2 );

    long index = 0;
    for( long i=0; i<numquads; i++ ) {
	voffset[i] = index;
        varray[index++] = vval[i];
	REAL dist = vval[i] - vval[i+1];
	if( dist > delta ) {
	    long steps = ((long) (dist/delta)) +1;
	    float deltav = - dist / (REAL) steps;
	    for( long j=1; j<steps; j++ ) 
		varray[index++] = vval[i] + j * deltav; 
	}
    }
    voffset[i] = index;
    varray[index] = vval[i];
    return index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\core\varray.h ===
#ifndef __gluvarray_h_
#define __gluvarray_h_
/**************************************************************************
 *									  *
 * 		 Copyright (C) 1992, Silicon Graphics, Inc.		  *
 *									  *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *									  *
 **************************************************************************/

/*
 * varray.h - $Revision: 1.1 $
 */

#include "types.h"

class Arc;

class Varray {
public:
			Varray();
			~Varray();
    long		init( REAL, Arc *, Arc * );
    REAL *		varray;
    REAL		vval[1000];
    long		voffset[1000];
    long 		numquads;

private:
    long		size;
    inline void		update( Arc *, long[2], REAL );
    void		grow( long );
    inline void		append( REAL );
};

inline void
Varray::append( REAL v ) 
{
    if( v != vval[numquads] )
        vval[++numquads] = v; 
}


#endif /* __gluvarray_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\glu\nurbs\nt\glue.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include <windows.h>
#include <windef.h>
#include <setjmp.h>

// void *malloc( size_t );

struct JumpBuffer *__glnewJumpBuffer( void )
{
    return (struct JumpBuffer *) LocalAlloc(LMEM_FIXED, sizeof(jmp_buf));
}

extern char *__glNurbsErrors [];
extern WCHAR *__glNurbsErrorsW [];

const char *__glNURBSErrorString( int errno )
{
    return __glNurbsErrors[errno];
}

const WCHAR *__glNURBSErrorStringW( int errno )
{
    return __glNurbsErrorsW[errno];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\batchinf.h ===
#ifndef __BATCHINF_H__
#define __BATCHINF_H__

#define GLMSG_ALIGN(x)           ((ULONG)((((ULONG_PTR)(x))+7)&-8))

#define GLMSG_ALIGNPTR(x)        ((((ULONG_PTR)(x))+7)&-8)

#define GLMSGBATCHSTATS_CLEAR     0     // Clear values
#define GLMSGBATCHSTATS_GETSTATS  1     // Return values

typedef struct {

    ULONG ServerTrips;          // Number of times the server was called
    ULONG ClientCalls;          // Total number of client calls
    ULONG ServerCalls;          // Total number of server calls

} GLMSGBATCHSTATS;

/*
 *  GLMSGBATCHINFO is the first structure in the shared section
 *
 */

typedef struct _GLMSGBATCHINFO {

    ULONG MaximumOffset;        // Threshold for flushing.
    ULONG FirstOffset;          // Where to put the first message
    ULONG NextOffset;           // Where to place the next message
    ULONG ReturnValue;          // Value returned from the server

#ifdef DOGLMSGBATCHSTATS

    GLMSGBATCHSTATS BatchStats;

#endif /* DOGLMSGBATCHSTATS */

} GLMSGBATCHINFO;

#if DBG

#ifdef DODBGPRINTSTRUCT

#define PRINT_GLMSGBATCHINFO(Text, pMsgBatchInfo)                           \
{                                                                           \
    DbgPrint("%s (%d): %s:\n", __FILE__, __LINE__, Text);                   \
    if (NULL == pMsgBatchInfo)                                              \
    {                                                                       \
        DbgPrint("Cannot print pMsgBatchInfo == NULL\n");                   \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        DbgPrint("pMsgBatchInfo:    0x%08lX\n",                             \
            pMsgBatchInfo                  );                               \
        DbgPrint("MaximumOffset.....0x%08lX\n",                             \
            pMsgBatchInfo->MaximumOffset   );                               \
        DbgPrint("FirstOffset       0x%08lX\n",                             \
            pMsgBatchInfo->FirstOffset     );                               \
        DbgPrint("NextOffset........0x%08lX\n",                             \
            pMsgBatchInfo->NextOffset      );                               \
        DbgPrint("\n");                                                     \
    }                                                                       \
}

#else  /* DOPRINT */

#define PRINT_GLMSGBATCHINFO(Text, pMsgBatchInfo)

#endif /* DOPRINT */

#else /* DBG */

#define PRINT_GLMSGBATCHINFO(Text, pMsgBatchInfo)

#endif /* DBG */


#endif /* __BATCHINF_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\alloc.h ===
//+---------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// alloc.h
//
// Global allocation macros and routines.
//
// History:
//  Mon Jun 02 16:53:42 1997	-by-	Drew Bliss [drewb]
//   Created
//
//----------------------------------------------------------------------------

#ifndef __ALLOC_H__
#define __ALLOC_H__

#include <types.h>

//
// Usage notes:
//
// ALLOC is a direct replacement for malloc().
// ALLOCZ allocates zero-filled memory.
// REALLOC is a direct replacement for realloc().
// FREE is a direct replacement for free().
//
// On debug builds these macros evaluate to calls to a memory-tracking
// allocator.  On free builds they make direct heap calls.
// All of the rest of the allocation routines are built on top of the
// above macros and so inherit their tracking capabilities.
//
// The basic allocation routines also provide a mechanism to randomly
// cause allocations to fail via manipulation of the glRandomMallocFail
// variable.
//

#if DBG

extern long glRandomMallocFail;

void * FASTCALL dbgAlloc(UINT nbytes, DWORD flags);
void * FASTCALL dbgRealloc(void *mem, UINT nbytes);
void   FASTCALL dbgFree(void *mem);
int    FASTCALL dbgMemSize(void *mem);

#define ALLOC(nbytes)           dbgAlloc((nbytes), 0)
#define ALLOCZ(nbytes)          dbgAlloc((nbytes), HEAP_ZERO_MEMORY)
#define REALLOC(mem, nbytes)    dbgRealloc((mem), (nbytes))
#define FREE(mem)               dbgFree((mem))

#else // DBG

#define ALLOC(nbytes)           HeapAlloc(GetProcessHeap(), 0, (nbytes))
#define ALLOCZ(nbytes)          HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, \
                                          (nbytes))
#define REALLOC(mem, nbytes)    HeapReAlloc(GetProcessHeap(), 0, (mem), \
                                            (nbytes))
#define FREE(mem)               HeapFree(GetProcessHeap(), 0, (mem))

#endif // DBG

//
// 32-byte aligned memory allocator.
//
void * FASTCALL AllocAlign32(UINT nbytes);
void   FASTCALL FreeAlign32(void *mem);

//
// Short-lived memory allocator.  This allocator should be used
// for relatively small allocations (<= 4K) that are only live for
// a function or two.
//
BOOL   FASTCALL InitTempAlloc(void);
void * FASTCALL gcTempAlloc(__GLcontext *gc, UINT nbytes);
void   FASTCALL gcTempFree(__GLcontext *gc, void *mem);

//
// Allocator wrappers which automatically set the gc error on failure.
// The wrappers don't currently do anything extra on frees but
// having matching free calls allows for per-gc tracking if necessary.
//

// Internal worker function.
void * FASTCALL gcAlloc(__GLcontext *gc, UINT nbytes, DWORD flags);

#define GCALLOC(gc, nbytes)  gcAlloc((gc), (nbytes), 0)
#define GCALLOCZ(gc, nbytes) gcAlloc((gc), (nbytes), HEAP_ZERO_MEMORY)
                                              
void * FASTCALL GCREALLOC(__GLcontext *gc, void *mem, UINT nbytes);
#define         GCFREE(gc, mem) FREE(mem)
                       
void * FASTCALL GCALLOCALIGN32(__GLcontext *gc, UINT nbytes);
#define         GCFREEALIGN32(gc, mem) FreeAlign32(mem)

#endif // #ifndef __ALLOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\compsize.h ===
/******************************Module*Header*******************************\
* Module Name: compsize.h
*
* Function prototypes and macros to compute size of input buffer.
*
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef __COMPSIZE_H__
#define __COMPSIZE_H__


#ifndef _CLIENTSIDE_
GLint __glCallLists_size(GLint n, GLenum type);
GLint __glCltMap1_size(GLenum target);
GLint __glCltMap2_size(GLenum target);
GLint __glGetMap_size(GLenum target, GLenum query);
GLint __glGetPixelMap_size(GLenum map);
GLint __glGet_size(GLenum pname);

#define __glGetMapdv_size(target,query)                         \
        (__glGetMap_size(target,query)*sizeof(GLdouble))
#define __glGetMapfv_size(target,query)                         \
        (__glGetMap_size(target,query)*sizeof(GLfloat))
#define __glGetMapiv_size(target,query)                         \
        (__glGetMap_size(target,query)*sizeof(GLint))
#define __glGetPixelMapfv_size(map)                             \
        (__glGetPixelMap_size(map)*sizeof(GLfloat))
#define __glGetPixelMapuiv_size(map)                            \
        (__glGetPixelMap_size(map)*sizeof(GLuint))
#define __glGetPixelMapusv_size(map)                            \
        (__glGetPixelMap_size(map)*sizeof(GLushort))
#endif

// FOG_ASSERT
#if !(((GL_FOG_INDEX  +1) == GL_FOG_DENSITY) &&  \
      ((GL_FOG_DENSITY+1) == GL_FOG_START  ) &&  \
      ((GL_FOG_START  +1) == GL_FOG_END    ) &&  \
      ((GL_FOG_END    +1) == GL_FOG_MODE   ) &&  \
      ((GL_FOG_MODE   +1) == GL_FOG_COLOR  )     \
     )
#error "bad fog index ordering"
#endif

// LIGHT_SOURCE_ASSERT
#if !(((GL_AMBIENT             +1) == GL_DIFFUSE              ) && \
      ((GL_DIFFUSE             +1) == GL_SPECULAR             ) && \
      ((GL_SPECULAR            +1) == GL_POSITION             ) && \
      ((GL_POSITION            +1) == GL_SPOT_DIRECTION       ) && \
      ((GL_SPOT_DIRECTION      +1) == GL_SPOT_EXPONENT        ) && \
      ((GL_SPOT_EXPONENT       +1) == GL_SPOT_CUTOFF          ) && \
      ((GL_SPOT_CUTOFF         +1) == GL_CONSTANT_ATTENUATION ) && \
      ((GL_CONSTANT_ATTENUATION+1) == GL_LINEAR_ATTENUATION   ) && \
      ((GL_LINEAR_ATTENUATION  +1) == GL_QUADRATIC_ATTENUATION)    \
     )
#error "bad light source index ordering"
#endif

// LIGHT_MODEL_ASSERT
#if !(((GL_LIGHT_MODEL_LOCAL_VIEWER+1) == GL_LIGHT_MODEL_TWO_SIDE) && \
      ((GL_LIGHT_MODEL_TWO_SIDE    +1) == GL_LIGHT_MODEL_AMBIENT )    \
     )
#error "bad light model index ordering"
#endif

// TEX_GEN_ASSERT
#if !(((GL_TEXTURE_GEN_MODE+1) == GL_OBJECT_PLANE) && \
      ((GL_OBJECT_PLANE+1)     ==  GL_EYE_PLANE)      \
     )
#error "bad tex gen index ordering"
#endif

// TEX_PARAMETER_ASSERT
#if !(((GL_TEXTURE_MAG_FILTER  +1) == GL_TEXTURE_MIN_FILTER   ) && \
      ((GL_TEXTURE_MIN_FILTER  +1) == GL_TEXTURE_WRAP_S       ) && \
      ((GL_TEXTURE_WRAP_S      +1) == GL_TEXTURE_WRAP_T       )    \
     )
#error "bad tex parameter index ordering"
#endif

// PIXEL_MAP_ASSERT
#if !(((GL_PIXEL_MAP_I_TO_I+1) == GL_PIXEL_MAP_S_TO_S) &&               \
      ((GL_PIXEL_MAP_S_TO_S+1) == GL_PIXEL_MAP_I_TO_R) &&               \
      ((GL_PIXEL_MAP_I_TO_R+1) == GL_PIXEL_MAP_I_TO_G) &&               \
      ((GL_PIXEL_MAP_I_TO_G+1) == GL_PIXEL_MAP_I_TO_B) &&               \
      ((GL_PIXEL_MAP_I_TO_B+1) == GL_PIXEL_MAP_I_TO_A) &&               \
      ((GL_PIXEL_MAP_I_TO_A+1) == GL_PIXEL_MAP_R_TO_R) &&               \
      ((GL_PIXEL_MAP_R_TO_R+1) == GL_PIXEL_MAP_G_TO_G) &&               \
      ((GL_PIXEL_MAP_G_TO_G+1) == GL_PIXEL_MAP_B_TO_B) &&               \
      ((GL_PIXEL_MAP_B_TO_B+1) == GL_PIXEL_MAP_A_TO_A) &&               \
      ((GL_PIXEL_MAP_I_TO_I_SIZE+1) == GL_PIXEL_MAP_S_TO_S_SIZE) &&     \
      ((GL_PIXEL_MAP_S_TO_S_SIZE+1) == GL_PIXEL_MAP_I_TO_R_SIZE) &&     \
      ((GL_PIXEL_MAP_I_TO_R_SIZE+1) == GL_PIXEL_MAP_I_TO_G_SIZE) &&     \
      ((GL_PIXEL_MAP_I_TO_G_SIZE+1) == GL_PIXEL_MAP_I_TO_B_SIZE) &&     \
      ((GL_PIXEL_MAP_I_TO_B_SIZE+1) == GL_PIXEL_MAP_I_TO_A_SIZE) &&     \
      ((GL_PIXEL_MAP_I_TO_A_SIZE+1) == GL_PIXEL_MAP_R_TO_R_SIZE) &&     \
      ((GL_PIXEL_MAP_R_TO_R_SIZE+1) == GL_PIXEL_MAP_G_TO_G_SIZE) &&     \
      ((GL_PIXEL_MAP_G_TO_G_SIZE+1) == GL_PIXEL_MAP_B_TO_B_SIZE) &&     \
      ((GL_PIXEL_MAP_B_TO_B_SIZE+1) == GL_PIXEL_MAP_A_TO_A_SIZE)        \
     )
#error "bad pixel map index ordering"
#endif

// MAP1_ASSERT
#if !(((GL_MAP1_COLOR_4        +1) == GL_MAP1_INDEX          ) &&\
      ((GL_MAP1_INDEX          +1) == GL_MAP1_NORMAL         ) &&\
      ((GL_MAP1_NORMAL         +1) == GL_MAP1_TEXTURE_COORD_1) &&\
      ((GL_MAP1_TEXTURE_COORD_1+1) == GL_MAP1_TEXTURE_COORD_2) &&\
      ((GL_MAP1_TEXTURE_COORD_2+1) == GL_MAP1_TEXTURE_COORD_3) &&\
      ((GL_MAP1_TEXTURE_COORD_3+1) == GL_MAP1_TEXTURE_COORD_4) &&\
      ((GL_MAP1_TEXTURE_COORD_4+1) == GL_MAP1_VERTEX_3       ) &&\
      ((GL_MAP1_VERTEX_3       +1) == GL_MAP1_VERTEX_4       )   \
     )
#error "bad map1 index ordering"
#endif

// MAP2_ASSERT
#if !(((GL_MAP2_COLOR_4        +1) == GL_MAP2_INDEX          ) &&\
      ((GL_MAP2_INDEX          +1) == GL_MAP2_NORMAL         ) &&\
      ((GL_MAP2_NORMAL         +1) == GL_MAP2_TEXTURE_COORD_1) &&\
      ((GL_MAP2_TEXTURE_COORD_1+1) == GL_MAP2_TEXTURE_COORD_2) &&\
      ((GL_MAP2_TEXTURE_COORD_2+1) == GL_MAP2_TEXTURE_COORD_3) &&\
      ((GL_MAP2_TEXTURE_COORD_3+1) == GL_MAP2_TEXTURE_COORD_4) &&\
      ((GL_MAP2_TEXTURE_COORD_4+1) == GL_MAP2_VERTEX_3       ) &&\
      ((GL_MAP2_VERTEX_3       +1) == GL_MAP2_VERTEX_4       )   \
     )
#error "bad map2 index ordering"
#endif

// TYPE_ASSERT
#if !(((GL_BYTE          +1) == GL_UNSIGNED_BYTE ) &&  \
      ((GL_UNSIGNED_BYTE +1) == GL_SHORT         ) &&  \
      ((GL_SHORT         +1) == GL_UNSIGNED_SHORT) &&  \
      ((GL_UNSIGNED_SHORT+1) == GL_INT           ) &&  \
      ((GL_INT           +1) == GL_UNSIGNED_INT  ) &&  \
      ((GL_UNSIGNED_INT  +1) == GL_FLOAT         ) &&  \
      ((GL_FLOAT         +1) == GL_2_BYTES       ) &&  \
      ((GL_2_BYTES       +1) == GL_3_BYTES       ) &&  \
      ((GL_3_BYTES       +1) == GL_4_BYTES       ) &&  \
      ((GL_4_BYTES       +1) == GL_DOUBLE        )     \
     )
#error "bad GL type index ordering"
#endif

// ARRAY_TYPE_ASSERT
#if !(((GL_VERTEX_ARRAY        +1) == GL_NORMAL_ARRAY        ) &&  \
      ((GL_NORMAL_ARRAY        +1) == GL_COLOR_ARRAY         ) &&  \
      ((GL_COLOR_ARRAY         +1) == GL_INDEX_ARRAY         ) &&  \
      ((GL_INDEX_ARRAY         +1) == GL_TEXTURE_COORD_ARRAY ) &&  \
      ((GL_TEXTURE_COORD_ARRAY +1) == GL_EDGE_FLAG_ARRAY     )     \
     )
#error "bad GL array type ordering"
#endif

// INTERLEAVED_FORMAT_ASSERT
#if !(((GL_V2F             +1) == GL_V3F             ) && \
      ((GL_V3F             +1) == GL_C4UB_V2F        ) && \
      ((GL_C4UB_V2F        +1) == GL_C4UB_V3F        ) && \
      ((GL_C4UB_V3F        +1) == GL_C3F_V3F         ) && \
      ((GL_C3F_V3F         +1) == GL_N3F_V3F         ) && \
      ((GL_N3F_V3F         +1) == GL_C4F_N3F_V3F     ) && \
      ((GL_C4F_N3F_V3F     +1) == GL_T2F_V3F         ) && \
      ((GL_T2F_V3F         +1) == GL_T4F_V4F         ) && \
      ((GL_T4F_V4F         +1) == GL_T2F_C4UB_V3F    ) && \
      ((GL_T2F_C4UB_V3F    +1) == GL_T2F_C3F_V3F     ) && \
      ((GL_T2F_C3F_V3F     +1) == GL_T2F_N3F_V3F     ) && \
      ((GL_T2F_N3F_V3F     +1) == GL_T2F_C4F_N3F_V3F ) && \
      ((GL_T2F_C4F_N3F_V3F +1) == GL_T4F_C4F_N3F_V4F )    \
     )
#error "bad GL interleaved array format ordering"
#endif

#ifndef _CLIENTSIDE_
#define GLSETERROR(e)        {DBGLEVEL1(LEVEL_INFO,"GLSETERROR(%ld)\n",e);}
#else
#define GLSETERROR(e)        __glSetError(e)
#endif

#endif /* !__COMPSIZE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* OpenGL debugging macros.
*
* Created: 23-Oct-1993 18:33:23
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#ifndef __DEBUG_H__
#define __DEBUG_H__

//
// LEVEL_ALLOC is the highest level of debug output.  For alloc,free, etc.
// LEVEL_ENTRY is for function entry.
// LEVEL_INFO is for general debug information.
// LEVEL_ERROR is for debug error information.
//
#define LEVEL_ERROR 1L
#define LEVEL_INFO  2L
#define LEVEL_ENTRY 8L
#define LEVEL_ALLOC 10L

#if DBG

extern long glDebugLevel;
extern ULONG glDebugFlags;

#define GLDEBUG_DISABLEMCD      0x00000001  // disable MCD driver
#define GLDEBUG_DISABLEPRIM     0x00000002  // disable MCD primitives
#define GLDEBUG_DISABLEDCI      0x00000004  // disable DCI buffer access

// These debug macros are useful for assertions.  They are not controlled
// by the warning level.

#define WARNING(str)             DbgPrint("%s(%d): " str,__FILE__,__LINE__)
#define WARNING1(str,a)          DbgPrint("%s(%d): " str,__FILE__,__LINE__,a)
#define WARNING2(str,a,b)        DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b)
#define WARNING3(str,a,b,c)      DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b,c)
#define WARNING4(str,a,b,c,d)    DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b,c,d)
#define RIP(str)                 {WARNING(str); DebugBreak();}
#define RIP1(str,a)              {WARNING1(str,a); DebugBreak();}
#define RIP2(str,a,b)            {WARNING2(str,a,b); DebugBreak();}
#define ASSERTOPENGL(expr,str)            if(!(expr)) RIP(str)
#define ASSERTOPENGL1(expr,str,a)         if(!(expr)) RIP1(str,a)
#define ASSERTOPENGL2(expr,str,a,b)       if(!(expr)) RIP2(str,a,b)

//
// Use DBGPRINT for general purpose debug message that are NOT
// controlled by the warning level.
//

#define DBGPRINT(str)            DbgPrint("OPENGL32: " str)
#define DBGPRINT1(str,a)         DbgPrint("OPENGL32: " str,a)
#define DBGPRINT2(str,a,b)       DbgPrint("OPENGL32: " str,a,b)
#define DBGPRINT3(str,a,b,c)     DbgPrint("OPENGL32: " str,a,b,c)
#define DBGPRINT4(str,a,b,c,d)   DbgPrint("OPENGL32: " str,a,b,c,d)
#define DBGPRINT5(str,a,b,c,d,e) DbgPrint("OPENGL32: " str,a,b,c,d,e)

//
// Use DBGLEVEL for general purpose debug messages gated by an
// arbitrary warning level.
//
#define DBGLEVEL(n,str)            if (glDebugLevel >= (n)) DBGPRINT(str)
#define DBGLEVEL1(n,str,a)         if (glDebugLevel >= (n)) DBGPRINT1(str,a)
#define DBGLEVEL2(n,str,a,b)       if (glDebugLevel >= (n)) DBGPRINT2(str,a,b)    
#define DBGLEVEL3(n,str,a,b,c)     if (glDebugLevel >= (n)) DBGPRINT3(str,a,b,c)  
#define DBGLEVEL4(n,str,a,b,c,d)   if (glDebugLevel >= (n)) DBGPRINT4(str,a,b,c,d)
#define DBGLEVEL5(n,str,a,b,c,d,e) if (glDebugLevel >= (n)) DBGPRINT5(str,a,b,c,d,e)

//
// Use DBGERROR for error info.  Debug string must not have arguments.
//
#define DBGERROR(s)     if (glDebugLevel >= LEVEL_ERROR) DbgPrint("%s(%d): %s", __FILE__, __LINE__, s)

//
// Use DBGINFO for general debug info.  Debug string must not have
// arguments.
//
#define DBGINFO(s)      if (glDebugLevel >= LEVEL_INFO)  DBGPRINT(s)

//
// Use DBGENTRY for function entry.  Debug string must not have
// arguments.
//
#define DBGENTRY(s)     if (glDebugLevel >= LEVEL_ENTRY) DBGPRINT(s)

//
// DBGBEGIN/DBGEND for more complex debugging output (for
// example, those requiring formatting arguments--%ld, %s, etc.).
//
// Note: DBGBEGIN/END blocks must be bracketed by #if DBG/#endif.  To
// enforce this, we will not define these macros in the DBG == 0 case.
// Therefore, without the #if DBG bracketing use of this macro, a
// compiler (or linker) error will be generated.  This is by design.
//
#define DBGBEGIN(n)     if (glDebugLevel >= (n)) {
#define DBGEND          }

#else

#define WARNING(str)
#define WARNING1(str,a)
#define WARNING2(str,a,b)
#define WARNING3(str,a,b,c)
#define WARNING4(str,a,b,c,d)
#define RIP(str)
#define RIP1(str,a)
#define RIP2(str,a,b)
#define ASSERTOPENGL(expr,str)
#define ASSERTOPENGL1(expr,str,a)
#define ASSERTOPENGL2(expr,str,a,b)
#define DBGPRINT(str)
#define DBGPRINT1(str,a)
#define DBGPRINT2(str,a,b)
#define DBGPRINT3(str,a,b,c)
#define DBGPRINT4(str,a,b,c,d)
#define DBGPRINT5(str,a,b,c,d,e)
#define DBGLEVEL(n,str)
#define DBGLEVEL1(n,str,a)
#define DBGLEVEL2(n,str,a,b)
#define DBGLEVEL3(n,str,a,b,c)
#define DBGLEVEL4(n,str,a,b,c,d)
#define DBGLEVEL5(n,str,a,b,c,d,e)
#define DBGERROR(s)
#define DBGINFO(s)
#define DBGENTRY(s)

#endif /* DBG */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\dispindx.h ===
/******************************Module*Header*******************************\
* Module Name: dispindx.h
*
* OpenGL API function table indices.  Same as glapi.inc.
*
* Created: 1/15/1996
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1996 Microsoft Corporation
\**************************************************************************/

#ifndef __DISPINDX_H__
#define __DISPINDX_H__

// OpenGL function index in the dispatch table.
// NOTE: Extension indices are based on 336 non-extension indices

#define INDEX_glNewList                 0
#define INDEX_glEndList                 1
#define INDEX_glCallList                2
#define INDEX_glCallLists               3
#define INDEX_glDeleteLists             4
#define INDEX_glGenLists                5
#define INDEX_glListBase                6
#define INDEX_glBegin                   7
#define INDEX_glBitmap                  8
#define INDEX_glColor3b                 9
#define INDEX_glColor3bv                10
#define INDEX_glColor3d                 11
#define INDEX_glColor3dv                12
#define INDEX_glColor3f                 13
#define INDEX_glColor3fv                14
#define INDEX_glColor3i                 15
#define INDEX_glColor3iv                16
#define INDEX_glColor3s                 17
#define INDEX_glColor3sv                18
#define INDEX_glColor3ub                19
#define INDEX_glColor3ubv               20
#define INDEX_glColor3ui                21
#define INDEX_glColor3uiv               22
#define INDEX_glColor3us                23
#define INDEX_glColor3usv               24
#define INDEX_glColor4b                 25
#define INDEX_glColor4bv                26
#define INDEX_glColor4d                 27
#define INDEX_glColor4dv                28
#define INDEX_glColor4f                 29
#define INDEX_glColor4fv                30
#define INDEX_glColor4i                 31
#define INDEX_glColor4iv                32
#define INDEX_glColor4s                 33
#define INDEX_glColor4sv                34
#define INDEX_glColor4ub                35
#define INDEX_glColor4ubv               36
#define INDEX_glColor4ui                37
#define INDEX_glColor4uiv               38
#define INDEX_glColor4us                39
#define INDEX_glColor4usv               40
#define INDEX_glEdgeFlag                41
#define INDEX_glEdgeFlagv               42
#define INDEX_glEnd                     43
#define INDEX_glIndexd                  44
#define INDEX_glIndexdv                 45
#define INDEX_glIndexf                  46
#define INDEX_glIndexfv                 47
#define INDEX_glIndexi                  48
#define INDEX_glIndexiv                 49
#define INDEX_glIndexs                  50
#define INDEX_glIndexsv                 51
#define INDEX_glNormal3b                52
#define INDEX_glNormal3bv               53
#define INDEX_glNormal3d                54
#define INDEX_glNormal3dv               55
#define INDEX_glNormal3f                56
#define INDEX_glNormal3fv               57
#define INDEX_glNormal3i                58
#define INDEX_glNormal3iv               59
#define INDEX_glNormal3s                60
#define INDEX_glNormal3sv               61
#define INDEX_glRasterPos2d             62
#define INDEX_glRasterPos2dv            63
#define INDEX_glRasterPos2f             64
#define INDEX_glRasterPos2fv            65
#define INDEX_glRasterPos2i             66
#define INDEX_glRasterPos2iv            67
#define INDEX_glRasterPos2s             68
#define INDEX_glRasterPos2sv            69
#define INDEX_glRasterPos3d             70
#define INDEX_glRasterPos3dv            71
#define INDEX_glRasterPos3f             72
#define INDEX_glRasterPos3fv            73
#define INDEX_glRasterPos3i             74
#define INDEX_glRasterPos3iv            75
#define INDEX_glRasterPos3s             76
#define INDEX_glRasterPos3sv            77
#define INDEX_glRasterPos4d             78
#define INDEX_glRasterPos4dv            79
#define INDEX_glRasterPos4f             80
#define INDEX_glRasterPos4fv            81
#define INDEX_glRasterPos4i             82
#define INDEX_glRasterPos4iv            83
#define INDEX_glRasterPos4s             84
#define INDEX_glRasterPos4sv            85
#define INDEX_glRectd                   86
#define INDEX_glRectdv                  87
#define INDEX_glRectf                   88
#define INDEX_glRectfv                  89
#define INDEX_glRecti                   90
#define INDEX_glRectiv                  91
#define INDEX_glRects                   92
#define INDEX_glRectsv                  93
#define INDEX_glTexCoord1d              94
#define INDEX_glTexCoord1dv             95
#define INDEX_glTexCoord1f              96
#define INDEX_glTexCoord1fv             97
#define INDEX_glTexCoord1i              98
#define INDEX_glTexCoord1iv             99
#define INDEX_glTexCoord1s              100
#define INDEX_glTexCoord1sv             101
#define INDEX_glTexCoord2d              102
#define INDEX_glTexCoord2dv             103
#define INDEX_glTexCoord2f              104
#define INDEX_glTexCoord2fv             105
#define INDEX_glTexCoord2i              106
#define INDEX_glTexCoord2iv             107
#define INDEX_glTexCoord2s              108
#define INDEX_glTexCoord2sv             109
#define INDEX_glTexCoord3d              110
#define INDEX_glTexCoord3dv             111
#define INDEX_glTexCoord3f              112
#define INDEX_glTexCoord3fv             113
#define INDEX_glTexCoord3i              114
#define INDEX_glTexCoord3iv             115
#define INDEX_glTexCoord3s              116
#define INDEX_glTexCoord3sv             117
#define INDEX_glTexCoord4d              118
#define INDEX_glTexCoord4dv             119
#define INDEX_glTexCoord4f              120
#define INDEX_glTexCoord4fv             121
#define INDEX_glTexCoord4i              122
#define INDEX_glTexCoord4iv             123
#define INDEX_glTexCoord4s              124
#define INDEX_glTexCoord4sv             125
#define INDEX_glVertex2d                126
#define INDEX_glVertex2dv               127
#define INDEX_glVertex2f                128
#define INDEX_glVertex2fv               129
#define INDEX_glVertex2i                130
#define INDEX_glVertex2iv               131
#define INDEX_glVertex2s                132
#define INDEX_glVertex2sv               133
#define INDEX_glVertex3d                134
#define INDEX_glVertex3dv               135
#define INDEX_glVertex3f                136
#define INDEX_glVertex3fv               137
#define INDEX_glVertex3i                138
#define INDEX_glVertex3iv               139
#define INDEX_glVertex3s                140
#define INDEX_glVertex3sv               141
#define INDEX_glVertex4d                142
#define INDEX_glVertex4dv               143
#define INDEX_glVertex4f                144
#define INDEX_glVertex4fv               145
#define INDEX_glVertex4i                146
#define INDEX_glVertex4iv               147
#define INDEX_glVertex4s                148
#define INDEX_glVertex4sv               149
#define INDEX_glClipPlane               150
#define INDEX_glColorMaterial           151
#define INDEX_glCullFace                152
#define INDEX_glFogf                    153
#define INDEX_glFogfv                   154
#define INDEX_glFogi                    155
#define INDEX_glFogiv                   156
#define INDEX_glFrontFace               157
#define INDEX_glHint                    158
#define INDEX_glLightf                  159
#define INDEX_glLightfv                 160
#define INDEX_glLighti                  161
#define INDEX_glLightiv                 162
#define INDEX_glLightModelf             163
#define INDEX_glLightModelfv            164
#define INDEX_glLightModeli             165
#define INDEX_glLightModeliv            166
#define INDEX_glLineStipple             167
#define INDEX_glLineWidth               168
#define INDEX_glMaterialf               169
#define INDEX_glMaterialfv              170
#define INDEX_glMateriali               171
#define INDEX_glMaterialiv              172
#define INDEX_glPointSize               173
#define INDEX_glPolygonMode             174
#define INDEX_glPolygonStipple          175
#define INDEX_glScissor                 176
#define INDEX_glShadeModel              177
#define INDEX_glTexParameterf           178
#define INDEX_glTexParameterfv          179
#define INDEX_glTexParameteri           180
#define INDEX_glTexParameteriv          181
#define INDEX_glTexImage1D              182
#define INDEX_glTexImage2D              183
#define INDEX_glTexEnvf                 184
#define INDEX_glTexEnvfv                185
#define INDEX_glTexEnvi                 186
#define INDEX_glTexEnviv                187
#define INDEX_glTexGend                 188
#define INDEX_glTexGendv                189
#define INDEX_glTexGenf                 190
#define INDEX_glTexGenfv                191
#define INDEX_glTexGeni                 192
#define INDEX_glTexGeniv                193
#define INDEX_glFeedbackBuffer          194
#define INDEX_glSelectBuffer            195
#define INDEX_glRenderMode              196
#define INDEX_glInitNames               197
#define INDEX_glLoadName                198
#define INDEX_glPassThrough             199
#define INDEX_glPopName                 200
#define INDEX_glPushName                201
#define INDEX_glDrawBuffer              202
#define INDEX_glClear                   203
#define INDEX_glClearAccum              204
#define INDEX_glClearIndex              205
#define INDEX_glClearColor              206
#define INDEX_glClearStencil            207
#define INDEX_glClearDepth              208
#define INDEX_glStencilMask             209
#define INDEX_glColorMask               210
#define INDEX_glDepthMask               211
#define INDEX_glIndexMask               212
#define INDEX_glAccum                   213
#define INDEX_glDisable                 214
#define INDEX_glEnable                  215
#define INDEX_glFinish                  216
#define INDEX_glFlush                   217
#define INDEX_glPopAttrib               218
#define INDEX_glPushAttrib              219
#define INDEX_glMap1d                   220
#define INDEX_glMap1f                   221
#define INDEX_glMap2d                   222
#define INDEX_glMap2f                   223
#define INDEX_glMapGrid1d               224
#define INDEX_glMapGrid1f               225
#define INDEX_glMapGrid2d               226
#define INDEX_glMapGrid2f               227
#define INDEX_glEvalCoord1d             228
#define INDEX_glEvalCoord1dv            229
#define INDEX_glEvalCoord1f             230
#define INDEX_glEvalCoord1fv            231
#define INDEX_glEvalCoord2d             232
#define INDEX_glEvalCoord2dv            233
#define INDEX_glEvalCoord2f             234
#define INDEX_glEvalCoord2fv            235
#define INDEX_glEvalMesh1               236
#define INDEX_glEvalPoint1              237
#define INDEX_glEvalMesh2               238
#define INDEX_glEvalPoint2              239
#define INDEX_glAlphaFunc               240
#define INDEX_glBlendFunc               241
#define INDEX_glLogicOp                 242
#define INDEX_glStencilFunc             243
#define INDEX_glStencilOp               244
#define INDEX_glDepthFunc               245
#define INDEX_glPixelZoom               246
#define INDEX_glPixelTransferf          247
#define INDEX_glPixelTransferi          248
#define INDEX_glPixelStoref             249
#define INDEX_glPixelStorei             250
#define INDEX_glPixelMapfv              251
#define INDEX_glPixelMapuiv             252
#define INDEX_glPixelMapusv             253
#define INDEX_glReadBuffer              254
#define INDEX_glCopyPixels              255
#define INDEX_glReadPixels              256
#define INDEX_glDrawPixels              257
#define INDEX_glGetBooleanv             258
#define INDEX_glGetClipPlane            259
#define INDEX_glGetDoublev              260
#define INDEX_glGetError                261
#define INDEX_glGetFloatv               262
#define INDEX_glGetIntegerv             263
#define INDEX_glGetLightfv              264
#define INDEX_glGetLightiv              265
#define INDEX_glGetMapdv                266
#define INDEX_glGetMapfv                267
#define INDEX_glGetMapiv                268
#define INDEX_glGetMaterialfv           269
#define INDEX_glGetMaterialiv           270
#define INDEX_glGetPixelMapfv           271
#define INDEX_glGetPixelMapuiv          272
#define INDEX_glGetPixelMapusv          273
#define INDEX_glGetPolygonStipple       274
#define INDEX_glGetString               275
#define INDEX_glGetTexEnvfv             276
#define INDEX_glGetTexEnviv             277
#define INDEX_glGetTexGendv             278
#define INDEX_glGetTexGenfv             279
#define INDEX_glGetTexGeniv             280
#define INDEX_glGetTexImage             281
#define INDEX_glGetTexParameterfv       282
#define INDEX_glGetTexParameteriv       283
#define INDEX_glGetTexLevelParameterfv  284
#define INDEX_glGetTexLevelParameteriv  285
#define INDEX_glIsEnabled               286
#define INDEX_glIsList                  287
#define INDEX_glDepthRange              288
#define INDEX_glFrustum                 289
#define INDEX_glLoadIdentity            290
#define INDEX_glLoadMatrixf             291
#define INDEX_glLoadMatrixd             292
#define INDEX_glMatrixMode              293
#define INDEX_glMultMatrixf             294
#define INDEX_glMultMatrixd             295
#define INDEX_glOrtho                   296
#define INDEX_glPopMatrix               297
#define INDEX_glPushMatrix              298
#define INDEX_glRotated                 299
#define INDEX_glRotatef                 300
#define INDEX_glScaled                  301
#define INDEX_glScalef                  302
#define INDEX_glTranslated              303
#define INDEX_glTranslatef              304
#define INDEX_glViewport                305
#define INDEX_glArrayElement            306
#define INDEX_glBindTexture             307
#define INDEX_glColorPointer            308
#define INDEX_glDisableClientState      309
#define INDEX_glDrawArrays              310
#define INDEX_glDrawElements            311
#define INDEX_glEdgeFlagPointer         312
#define INDEX_glEnableClientState       313
#define INDEX_glIndexPointer            314
#define INDEX_glIndexub                 315
#define INDEX_glIndexubv                316
#define INDEX_glInterleavedArrays       317
#define INDEX_glNormalPointer           318
#define INDEX_glPolygonOffset           319
#define INDEX_glTexCoordPointer         320
#define INDEX_glVertexPointer           321
#define INDEX_glAreTexturesResident     322
#define INDEX_glCopyTexImage1D          323
#define INDEX_glCopyTexImage2D          324
#define INDEX_glCopyTexSubImage1D       325
#define INDEX_glCopyTexSubImage2D       326
#define INDEX_glDeleteTextures          327
#define INDEX_glGenTextures             328
#define INDEX_glGetPointerv             329
#define INDEX_glIsTexture               330
#define INDEX_glPrioritizeTextures      331
#define INDEX_glTexSubImage1D           332
#define INDEX_glTexSubImage2D           333
#define INDEX_glPopClientAttrib         334
#define INDEX_glPushClientAttrib        335
#define INDEX_glLastFunc                335

#if !(INDEX_glLastFunc == INDEX_glPushClientAttrib)
#error "bad last function index\n"
#endif

#define INDEX_glDrawRangeElementsWIN        (INDEX_glLastFunc+1)
#define INDEX_glColorTableEXT               (INDEX_glLastFunc+2)
#define INDEX_glColorSubTableEXT            (INDEX_glLastFunc+3)
#define INDEX_glGetColorTableEXT            (INDEX_glLastFunc+4)
#define INDEX_glGetColorTableParameterivEXT (INDEX_glLastFunc+5)
#define INDEX_glGetColorTableParameterfvEXT (INDEX_glLastFunc+6)
#define INDEX_glCurrentTextureIndexWIN      (INDEX_glLastFunc+7)
#define INDEX_glMultiTexCoord1dWIN          (INDEX_glLastFunc+8)
#define INDEX_glMultiTexCoord1dvWIN         (INDEX_glLastFunc+9)
#define INDEX_glMultiTexCoord1fWIN          (INDEX_glLastFunc+10)
#define INDEX_glMultiTexCoord1fvWIN         (INDEX_glLastFunc+11)
#define INDEX_glMultiTexCoord1iWIN          (INDEX_glLastFunc+12)
#define INDEX_glMultiTexCoord1ivWIN         (INDEX_glLastFunc+13)
#define INDEX_glMultiTexCoord1sWIN          (INDEX_glLastFunc+14)
#define INDEX_glMultiTexCoord1svWIN         (INDEX_glLastFunc+15)
#define INDEX_glMultiTexCoord2dWIN          (INDEX_glLastFunc+16)
#define INDEX_glMultiTexCoord2dvWIN         (INDEX_glLastFunc+17)
#define INDEX_glMultiTexCoord2fWIN          (INDEX_glLastFunc+18)
#define INDEX_glMultiTexCoord2fvWIN         (INDEX_glLastFunc+19)
#define INDEX_glMultiTexCoord2iWIN          (INDEX_glLastFunc+20)
#define INDEX_glMultiTexCoord2ivWIN         (INDEX_glLastFunc+21)
#define INDEX_glMultiTexCoord2sWIN          (INDEX_glLastFunc+22)
#define INDEX_glMultiTexCoord2svWIN         (INDEX_glLastFunc+23)
#define INDEX_glMultiTexCoord3dWIN          (INDEX_glLastFunc+24)
#define INDEX_glMultiTexCoord3dvWIN         (INDEX_glLastFunc+25)
#define INDEX_glMultiTexCoord3fWIN          (INDEX_glLastFunc+26)
#define INDEX_glMultiTexCoord3fvWIN         (INDEX_glLastFunc+27)
#define INDEX_glMultiTexCoord3iWIN          (INDEX_glLastFunc+28)
#define INDEX_glMultiTexCoord3ivWIN         (INDEX_glLastFunc+29)
#define INDEX_glMultiTexCoord3sWIN          (INDEX_glLastFunc+30)
#define INDEX_glMultiTexCoord3svWIN         (INDEX_glLastFunc+31)
#define INDEX_glMultiTexCoord4dWIN          (INDEX_glLastFunc+32)
#define INDEX_glMultiTexCoord4dvWIN         (INDEX_glLastFunc+33)
#define INDEX_glMultiTexCoord4fWIN          (INDEX_glLastFunc+34)
#define INDEX_glMultiTexCoord4fvWIN         (INDEX_glLastFunc+35)
#define INDEX_glMultiTexCoord4iWIN          (INDEX_glLastFunc+36)
#define INDEX_glMultiTexCoord4ivWIN         (INDEX_glLastFunc+37)
#define INDEX_glMultiTexCoord4sWIN          (INDEX_glLastFunc+38)
#define INDEX_glMultiTexCoord4svWIN         (INDEX_glLastFunc+39)
#define INDEX_glBindNthTextureWIN           (INDEX_glLastFunc+40)
#define INDEX_glNthTexCombineFuncWIN        (INDEX_glLastFunc+41)

// OpenGL function index in the dispatch table cache in the TEB.
// These indices are used to access the FP cache in the TEB.  These
// cached functions have less overhead because we can avoid dereferencing
// the dispatch table pointer stored in the TEB (save one level of
// indirection).
//
// NOTE: If you modify these indices, you also need to modify the
// GLDISPATCHTABLE_FAST structure definiton.

#define FASTINDEX_glCallList            0
#define FASTINDEX_glCallLists           1
#define FASTINDEX_glBegin               2
#define FASTINDEX_glColor3b             3
#define FASTINDEX_glColor3bv            4
#define FASTINDEX_glColor3d             5
#define FASTINDEX_glColor3dv            6
#define FASTINDEX_glColor3f             7
#define FASTINDEX_glColor3fv            8
#define FASTINDEX_glColor3i             9
#define FASTINDEX_glColor3iv            10
#define FASTINDEX_glColor3s             11
#define FASTINDEX_glColor3sv            12
#define FASTINDEX_glColor3ub            13
#define FASTINDEX_glColor3ubv           14
#define FASTINDEX_glColor3ui            15
#define FASTINDEX_glColor3uiv           16
#define FASTINDEX_glColor3us            17
#define FASTINDEX_glColor3usv           18
#define FASTINDEX_glColor4b             19
#define FASTINDEX_glColor4bv            20
#define FASTINDEX_glColor4d             21
#define FASTINDEX_glColor4dv            22
#define FASTINDEX_glColor4f             23
#define FASTINDEX_glColor4fv            24
#define FASTINDEX_glColor4i             25
#define FASTINDEX_glColor4iv            26
#define FASTINDEX_glColor4s             27
#define FASTINDEX_glColor4sv            28
#define FASTINDEX_glColor4ub            29
#define FASTINDEX_glColor4ubv           30
#define FASTINDEX_glColor4ui            31
#define FASTINDEX_glColor4uiv           32
#define FASTINDEX_glColor4us            33
#define FASTINDEX_glColor4usv           34
#define FASTINDEX_glEdgeFlag            35
#define FASTINDEX_glEdgeFlagv           36
#define FASTINDEX_glEnd                 37
#define FASTINDEX_glIndexd              38
#define FASTINDEX_glIndexdv             39
#define FASTINDEX_glIndexf              40
#define FASTINDEX_glIndexfv             41
#define FASTINDEX_glIndexi              42
#define FASTINDEX_glIndexiv             43
#define FASTINDEX_glIndexs              44
#define FASTINDEX_glIndexsv             45
#define FASTINDEX_glNormal3b            46
#define FASTINDEX_glNormal3bv           47
#define FASTINDEX_glNormal3d            48
#define FASTINDEX_glNormal3dv           49
#define FASTINDEX_glNormal3f            50
#define FASTINDEX_glNormal3fv           51
#define FASTINDEX_glNormal3i            52
#define FASTINDEX_glNormal3iv           53
#define FASTINDEX_glNormal3s            54
#define FASTINDEX_glNormal3sv           55
#define FASTINDEX_glTexCoord1d          56
#define FASTINDEX_glTexCoord1dv         57
#define FASTINDEX_glTexCoord1f          58
#define FASTINDEX_glTexCoord1fv         59
#define FASTINDEX_glTexCoord1i          60
#define FASTINDEX_glTexCoord1iv         61
#define FASTINDEX_glTexCoord1s          62
#define FASTINDEX_glTexCoord1sv         63
#define FASTINDEX_glTexCoord2d          64
#define FASTINDEX_glTexCoord2dv         65
#define FASTINDEX_glTexCoord2f          66
#define FASTINDEX_glTexCoord2fv         67
#define FASTINDEX_glTexCoord2i          68
#define FASTINDEX_glTexCoord2iv         69
#define FASTINDEX_glTexCoord2s          70
#define FASTINDEX_glTexCoord2sv         71
#define FASTINDEX_glTexCoord3d          72
#define FASTINDEX_glTexCoord3dv         73
#define FASTINDEX_glTexCoord3f          74
#define FASTINDEX_glTexCoord3fv         75
#define FASTINDEX_glTexCoord3i          76
#define FASTINDEX_glTexCoord3iv         77
#define FASTINDEX_glTexCoord3s          78
#define FASTINDEX_glTexCoord3sv         79
#define FASTINDEX_glTexCoord4d          80
#define FASTINDEX_glTexCoord4dv         81
#define FASTINDEX_glTexCoord4f          82
#define FASTINDEX_glTexCoord4fv         83
#define FASTINDEX_glTexCoord4i          84
#define FASTINDEX_glTexCoord4iv         85
#define FASTINDEX_glTexCoord4s          86
#define FASTINDEX_glTexCoord4sv         87
#define FASTINDEX_glVertex2d            88
#define FASTINDEX_glVertex2dv           89
#define FASTINDEX_glVertex2f            90
#define FASTINDEX_glVertex2fv           91
#define FASTINDEX_glVertex2i            92
#define FASTINDEX_glVertex2iv           93
#define FASTINDEX_glVertex2s            94
#define FASTINDEX_glVertex2sv           95
#define FASTINDEX_glVertex3d            96
#define FASTINDEX_glVertex3dv           97
#define FASTINDEX_glVertex3f            98
#define FASTINDEX_glVertex3fv           99
#define FASTINDEX_glVertex3i            100
#define FASTINDEX_glVertex3iv           101
#define FASTINDEX_glVertex3s            102
#define FASTINDEX_glVertex3sv           103
#define FASTINDEX_glVertex4d            104
#define FASTINDEX_glVertex4dv           105
#define FASTINDEX_glVertex4f            106
#define FASTINDEX_glVertex4fv           107
#define FASTINDEX_glVertex4i            108
#define FASTINDEX_glVertex4iv           109
#define FASTINDEX_glVertex4s            110
#define FASTINDEX_glVertex4sv           111
#define FASTINDEX_glMaterialf           112
#define FASTINDEX_glMaterialfv          113
#define FASTINDEX_glMateriali           114
#define FASTINDEX_glMaterialiv          115
#define FASTINDEX_glDisable             116
#define FASTINDEX_glEnable              117
#define FASTINDEX_glPopAttrib           118
#define FASTINDEX_glPushAttrib          119
#define FASTINDEX_glEvalCoord1d         120
#define FASTINDEX_glEvalCoord1dv        121
#define FASTINDEX_glEvalCoord1f         122
#define FASTINDEX_glEvalCoord1fv        123
#define FASTINDEX_glEvalCoord2d         124
#define FASTINDEX_glEvalCoord2dv        125
#define FASTINDEX_glEvalCoord2f         126
#define FASTINDEX_glEvalCoord2fv        127
#define FASTINDEX_glEvalPoint1          128
#define FASTINDEX_glEvalPoint2          129
#define FASTINDEX_glLoadIdentity        130
#define FASTINDEX_glLoadMatrixf         131
#define FASTINDEX_glLoadMatrixd         132
#define FASTINDEX_glMatrixMode          133
#define FASTINDEX_glMultMatrixf         134
#define FASTINDEX_glMultMatrixd         135
#define FASTINDEX_glPopMatrix           136
#define FASTINDEX_glPushMatrix          137
#define FASTINDEX_glRotated             138
#define FASTINDEX_glRotatef             139
#define FASTINDEX_glScaled              140
#define FASTINDEX_glScalef              141
#define FASTINDEX_glTranslated          142
#define FASTINDEX_glTranslatef          143
#define FASTINDEX_glArrayElement        144
#define FASTINDEX_glBindTexture         145
#define FASTINDEX_glColorPointer        146
#define FASTINDEX_glDisableClientState  147
#define FASTINDEX_glDrawArrays          148
#define FASTINDEX_glDrawElements        149
#define FASTINDEX_glEdgeFlagPointer     150
#define FASTINDEX_glEnableClientState   151
#define FASTINDEX_glIndexPointer        152
#define FASTINDEX_glIndexub             153
#define FASTINDEX_glIndexubv            154
#define FASTINDEX_glInterleavedArrays   155
#define FASTINDEX_glNormalPointer       156
#define FASTINDEX_glPolygonOffset       157
#define FASTINDEX_glTexCoordPointer     158
#define FASTINDEX_glVertexPointer       159
#define FASTINDEX_glGetPointerv         160
#define FASTINDEX_glPopClientAttrib     161
#define FASTINDEX_glPushClientAttrib    162
#define FASTINDEX_glDrawRangeElementsWIN 163
#define FASTINDEX_glColorTableEXT       164
#define FASTINDEX_glColorSubTableEXT    165
#define FASTINDEX_glCurrentTextureIndexWIN 166
#define FASTINDEX_glBindNthTextureWIN   167
#define FASTINDEX_glNthTexCombineFuncWIN 168
#define FASTINDEX_glMultiTexCoord1fWIN  169
#define FASTINDEX_glMultiTexCoord1fvWIN 170
#define FASTINDEX_glMultiTexCoord1iWIN  171
#define FASTINDEX_glMultiTexCoord1ivWIN 172
#define FASTINDEX_glMultiTexCoord2fWIN  173
#define FASTINDEX_glMultiTexCoord2fvWIN 174
#define FASTINDEX_glMultiTexCoord2iWIN  175
#define FASTINDEX_glMultiTexCoord2ivWIN 176

#endif /* !__DISPINDX_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glapi.inc ===
;---------------------------Module-Header------------------------------;
; Module Name: glapi.inc
;
; OpenGL API function table indices.
;
; Created: 11/16/1993
; Author: Hock San Lee [hockl]
;
; Copyright (c) 1993 Microsoft Corporation
;----------------------------------------------------------------------;

; OpenGL function index in the dispatch table.
; NOTE: Extension indices are based on 336 non-extension indices

INDEX_glNewList                 equ     0
INDEX_glEndList                 equ     1
INDEX_glCallList                equ     2
INDEX_glCallLists               equ     3
INDEX_glDeleteLists             equ     4
INDEX_glGenLists                equ     5
INDEX_glListBase                equ     6
INDEX_glBegin                   equ     7
INDEX_glBitmap                  equ     8
INDEX_glColor3b                 equ     9
INDEX_glColor3bv                equ     10
INDEX_glColor3d                 equ     11
INDEX_glColor3dv                equ     12
INDEX_glColor3f                 equ     13
INDEX_glColor3fv                equ     14
INDEX_glColor3i                 equ     15
INDEX_glColor3iv                equ     16
INDEX_glColor3s                 equ     17
INDEX_glColor3sv                equ     18
INDEX_glColor3ub                equ     19
INDEX_glColor3ubv               equ     20
INDEX_glColor3ui                equ     21
INDEX_glColor3uiv               equ     22
INDEX_glColor3us                equ     23
INDEX_glColor3usv               equ     24
INDEX_glColor4b                 equ     25
INDEX_glColor4bv                equ     26
INDEX_glColor4d                 equ     27
INDEX_glColor4dv                equ     28
INDEX_glColor4f                 equ     29
INDEX_glColor4fv                equ     30
INDEX_glColor4i                 equ     31
INDEX_glColor4iv                equ     32
INDEX_glColor4s                 equ     33
INDEX_glColor4sv                equ     34
INDEX_glColor4ub                equ     35
INDEX_glColor4ubv               equ     36
INDEX_glColor4ui                equ     37
INDEX_glColor4uiv               equ     38
INDEX_glColor4us                equ     39
INDEX_glColor4usv               equ     40
INDEX_glEdgeFlag                equ     41
INDEX_glEdgeFlagv               equ     42
INDEX_glEnd                     equ     43
INDEX_glIndexd                  equ     44
INDEX_glIndexdv                 equ     45
INDEX_glIndexf                  equ     46
INDEX_glIndexfv                 equ     47
INDEX_glIndexi                  equ     48
INDEX_glIndexiv                 equ     49
INDEX_glIndexs                  equ     50
INDEX_glIndexsv                 equ     51
INDEX_glNormal3b                equ     52
INDEX_glNormal3bv               equ     53
INDEX_glNormal3d                equ     54
INDEX_glNormal3dv               equ     55
INDEX_glNormal3f                equ     56
INDEX_glNormal3fv               equ     57
INDEX_glNormal3i                equ     58
INDEX_glNormal3iv               equ     59
INDEX_glNormal3s                equ     60
INDEX_glNormal3sv               equ     61
INDEX_glRasterPos2d             equ     62
INDEX_glRasterPos2dv            equ     63
INDEX_glRasterPos2f             equ     64
INDEX_glRasterPos2fv            equ     65
INDEX_glRasterPos2i             equ     66
INDEX_glRasterPos2iv            equ     67
INDEX_glRasterPos2s             equ     68
INDEX_glRasterPos2sv            equ     69
INDEX_glRasterPos3d             equ     70
INDEX_glRasterPos3dv            equ     71
INDEX_glRasterPos3f             equ     72
INDEX_glRasterPos3fv            equ     73
INDEX_glRasterPos3i             equ     74
INDEX_glRasterPos3iv            equ     75
INDEX_glRasterPos3s             equ     76
INDEX_glRasterPos3sv            equ     77
INDEX_glRasterPos4d             equ     78
INDEX_glRasterPos4dv            equ     79
INDEX_glRasterPos4f             equ     80
INDEX_glRasterPos4fv            equ     81
INDEX_glRasterPos4i             equ     82
INDEX_glRasterPos4iv            equ     83
INDEX_glRasterPos4s             equ     84
INDEX_glRasterPos4sv            equ     85
INDEX_glRectd                   equ     86
INDEX_glRectdv                  equ     87
INDEX_glRectf                   equ     88
INDEX_glRectfv                  equ     89
INDEX_glRecti                   equ     90
INDEX_glRectiv                  equ     91
INDEX_glRects                   equ     92
INDEX_glRectsv                  equ     93
INDEX_glTexCoord1d              equ     94
INDEX_glTexCoord1dv             equ     95
INDEX_glTexCoord1f              equ     96
INDEX_glTexCoord1fv             equ     97
INDEX_glTexCoord1i              equ     98
INDEX_glTexCoord1iv             equ     99
INDEX_glTexCoord1s              equ     100
INDEX_glTexCoord1sv             equ     101
INDEX_glTexCoord2d              equ     102
INDEX_glTexCoord2dv             equ     103
INDEX_glTexCoord2f              equ     104
INDEX_glTexCoord2fv             equ     105
INDEX_glTexCoord2i              equ     106
INDEX_glTexCoord2iv             equ     107
INDEX_glTexCoord2s              equ     108
INDEX_glTexCoord2sv             equ     109
INDEX_glTexCoord3d              equ     110
INDEX_glTexCoord3dv             equ     111
INDEX_glTexCoord3f              equ     112
INDEX_glTexCoord3fv             equ     113
INDEX_glTexCoord3i              equ     114
INDEX_glTexCoord3iv             equ     115
INDEX_glTexCoord3s              equ     116
INDEX_glTexCoord3sv             equ     117
INDEX_glTexCoord4d              equ     118
INDEX_glTexCoord4dv             equ     119
INDEX_glTexCoord4f              equ     120
INDEX_glTexCoord4fv             equ     121
INDEX_glTexCoord4i              equ     122
INDEX_glTexCoord4iv             equ     123
INDEX_glTexCoord4s              equ     124
INDEX_glTexCoord4sv             equ     125
INDEX_glVertex2d                equ     126
INDEX_glVertex2dv               equ     127
INDEX_glVertex2f                equ     128
INDEX_glVertex2fv               equ     129
INDEX_glVertex2i                equ     130
INDEX_glVertex2iv               equ     131
INDEX_glVertex2s                equ     132
INDEX_glVertex2sv               equ     133
INDEX_glVertex3d                equ     134
INDEX_glVertex3dv               equ     135
INDEX_glVertex3f                equ     136
INDEX_glVertex3fv               equ     137
INDEX_glVertex3i                equ     138
INDEX_glVertex3iv               equ     139
INDEX_glVertex3s                equ     140
INDEX_glVertex3sv               equ     141
INDEX_glVertex4d                equ     142
INDEX_glVertex4dv               equ     143
INDEX_glVertex4f                equ     144
INDEX_glVertex4fv               equ     145
INDEX_glVertex4i                equ     146
INDEX_glVertex4iv               equ     147
INDEX_glVertex4s                equ     148
INDEX_glVertex4sv               equ     149
INDEX_glClipPlane               equ     150
INDEX_glColorMaterial           equ     151
INDEX_glCullFace                equ     152
INDEX_glFogf                    equ     153
INDEX_glFogfv                   equ     154
INDEX_glFogi                    equ     155
INDEX_glFogiv                   equ     156
INDEX_glFrontFace               equ     157
INDEX_glHint                    equ     158
INDEX_glLightf                  equ     159
INDEX_glLightfv                 equ     160
INDEX_glLighti                  equ     161
INDEX_glLightiv                 equ     162
INDEX_glLightModelf             equ     163
INDEX_glLightModelfv            equ     164
INDEX_glLightModeli             equ     165
INDEX_glLightModeliv            equ     166
INDEX_glLineStipple             equ     167
INDEX_glLineWidth               equ     168
INDEX_glMaterialf               equ     169
INDEX_glMaterialfv              equ     170
INDEX_glMateriali               equ     171
INDEX_glMaterialiv              equ     172
INDEX_glPointSize               equ     173
INDEX_glPolygonMode             equ     174
INDEX_glPolygonStipple          equ     175
INDEX_glScissor                 equ     176
INDEX_glShadeModel              equ     177
INDEX_glTexParameterf           equ     178
INDEX_glTexParameterfv          equ     179
INDEX_glTexParameteri           equ     180
INDEX_glTexParameteriv          equ     181
INDEX_glTexImage1D              equ     182
INDEX_glTexImage2D              equ     183
INDEX_glTexEnvf                 equ     184
INDEX_glTexEnvfv                equ     185
INDEX_glTexEnvi                 equ     186
INDEX_glTexEnviv                equ     187
INDEX_glTexGend                 equ     188
INDEX_glTexGendv                equ     189
INDEX_glTexGenf                 equ     190
INDEX_glTexGenfv                equ     191
INDEX_glTexGeni                 equ     192
INDEX_glTexGeniv                equ     193
INDEX_glFeedbackBuffer          equ     194
INDEX_glSelectBuffer            equ     195
INDEX_glRenderMode              equ     196
INDEX_glInitNames               equ     197
INDEX_glLoadName                equ     198
INDEX_glPassThrough             equ     199
INDEX_glPopName                 equ     200
INDEX_glPushName                equ     201
INDEX_glDrawBuffer              equ     202
INDEX_glClear                   equ     203
INDEX_glClearAccum              equ     204
INDEX_glClearIndex              equ     205
INDEX_glClearColor              equ     206
INDEX_glClearStencil            equ     207
INDEX_glClearDepth              equ     208
INDEX_glStencilMask             equ     209
INDEX_glColorMask               equ     210
INDEX_glDepthMask               equ     211
INDEX_glIndexMask               equ     212
INDEX_glAccum                   equ     213
INDEX_glDisable                 equ     214
INDEX_glEnable                  equ     215
INDEX_glFinish                  equ     216
INDEX_glFlush                   equ     217
INDEX_glPopAttrib               equ     218
INDEX_glPushAttrib              equ     219
INDEX_glMap1d                   equ     220
INDEX_glMap1f                   equ     221
INDEX_glMap2d                   equ     222
INDEX_glMap2f                   equ     223
INDEX_glMapGrid1d               equ     224
INDEX_glMapGrid1f               equ     225
INDEX_glMapGrid2d               equ     226
INDEX_glMapGrid2f               equ     227
INDEX_glEvalCoord1d             equ     228
INDEX_glEvalCoord1dv            equ     229
INDEX_glEvalCoord1f             equ     230
INDEX_glEvalCoord1fv            equ     231
INDEX_glEvalCoord2d             equ     232
INDEX_glEvalCoord2dv            equ     233
INDEX_glEvalCoord2f             equ     234
INDEX_glEvalCoord2fv            equ     235
INDEX_glEvalMesh1               equ     236
INDEX_glEvalPoint1              equ     237
INDEX_glEvalMesh2               equ     238
INDEX_glEvalPoint2              equ     239
INDEX_glAlphaFunc               equ     240
INDEX_glBlendFunc               equ     241
INDEX_glLogicOp                 equ     242
INDEX_glStencilFunc             equ     243
INDEX_glStencilOp               equ     244
INDEX_glDepthFunc               equ     245
INDEX_glPixelZoom               equ     246
INDEX_glPixelTransferf          equ     247
INDEX_glPixelTransferi          equ     248
INDEX_glPixelStoref             equ     249
INDEX_glPixelStorei             equ     250
INDEX_glPixelMapfv              equ     251
INDEX_glPixelMapuiv             equ     252
INDEX_glPixelMapusv             equ     253
INDEX_glReadBuffer              equ     254
INDEX_glCopyPixels              equ     255
INDEX_glReadPixels              equ     256
INDEX_glDrawPixels              equ     257
INDEX_glGetBooleanv             equ     258
INDEX_glGetClipPlane            equ     259
INDEX_glGetDoublev              equ     260
INDEX_glGetError                equ     261
INDEX_glGetFloatv               equ     262
INDEX_glGetIntegerv             equ     263
INDEX_glGetLightfv              equ     264
INDEX_glGetLightiv              equ     265
INDEX_glGetMapdv                equ     266
INDEX_glGetMapfv                equ     267
INDEX_glGetMapiv                equ     268
INDEX_glGetMaterialfv           equ     269
INDEX_glGetMaterialiv           equ     270
INDEX_glGetPixelMapfv           equ     271
INDEX_glGetPixelMapuiv          equ     272
INDEX_glGetPixelMapusv          equ     273
INDEX_glGetPolygonStipple       equ     274
INDEX_glGetString               equ     275
INDEX_glGetTexEnvfv             equ     276
INDEX_glGetTexEnviv             equ     277
INDEX_glGetTexGendv             equ     278
INDEX_glGetTexGenfv             equ     279
INDEX_glGetTexGeniv             equ     280
INDEX_glGetTexImage             equ     281
INDEX_glGetTexParameterfv       equ     282
INDEX_glGetTexParameteriv       equ     283
INDEX_glGetTexLevelParameterfv  equ     284
INDEX_glGetTexLevelParameteriv  equ     285
INDEX_glIsEnabled               equ     286
INDEX_glIsList                  equ     287
INDEX_glDepthRange              equ     288
INDEX_glFrustum                 equ     289
INDEX_glLoadIdentity            equ     290
INDEX_glLoadMatrixf             equ     291
INDEX_glLoadMatrixd             equ     292
INDEX_glMatrixMode              equ     293
INDEX_glMultMatrixf             equ     294
INDEX_glMultMatrixd             equ     295
INDEX_glOrtho                   equ     296
INDEX_glPopMatrix               equ     297
INDEX_glPushMatrix              equ     298
INDEX_glRotated                 equ     299
INDEX_glRotatef                 equ     300
INDEX_glScaled                  equ     301
INDEX_glScalef                  equ     302
INDEX_glTranslated              equ     303
INDEX_glTranslatef              equ     304
INDEX_glViewport                equ     305
INDEX_glArrayElement            equ     306
INDEX_glBindTexture             equ     307
INDEX_glColorPointer            equ     308
INDEX_glDisableClientState      equ     309
INDEX_glDrawArrays              equ     310
INDEX_glDrawElements            equ     311
INDEX_glEdgeFlagPointer         equ     312
INDEX_glEnableClientState       equ     313
INDEX_glIndexPointer            equ     314
INDEX_glIndexub                 equ     315
INDEX_glIndexubv                equ     316
INDEX_glInterleavedArrays       equ     317
INDEX_glNormalPointer           equ     318
INDEX_glPolygonOffset           equ     319
INDEX_glTexCoordPointer         equ     320
INDEX_glVertexPointer           equ     321
INDEX_glAreTexturesResident     equ     322
INDEX_glCopyTexImage1D          equ     323
INDEX_glCopyTexImage2D          equ     324
INDEX_glCopyTexSubImage1D       equ     325
INDEX_glCopyTexSubImage2D       equ     326
INDEX_glDeleteTextures          equ     327
INDEX_glGenTextures             equ     328
INDEX_glGetPointerv             equ     329
INDEX_glIsTexture               equ     330
INDEX_glPrioritizeTextures      equ     331
INDEX_glTexSubImage1D           equ     332
INDEX_glTexSubImage2D           equ     333
INDEX_glPopClientAttrib         equ     334
INDEX_glPushClientAttrib        equ     335
INDEX_glLastFunc                equ     335

INDEX_glDrawRangeElementsWIN    equ     (INDEX_glLastFunc+1)
INDEX_glColorTableEXT           equ     (INDEX_glLastFunc+2)
INDEX_glColorSubTableEXT        equ     (INDEX_glLastFunc+3)
INDEX_glGetColorTableEXT        equ     (INDEX_glLastFunc+4)
INDEX_glGetColorTableParameterivEXT equ (INDEX_glLastFunc+5)
INDEX_glGetColorTableParameterfvEXT equ (INDEX_glLastFunc+6)
INDEX_glCurrentTextureIndexWIN	equ     (INDEX_glLastFunc+7)
INDEX_glMultiTexCoord1dWIN	equ     (INDEX_glLastFunc+8)
INDEX_glMultiTexCoord1dvWIN	equ     (INDEX_glLastFunc+9)
INDEX_glMultiTexCoord1fWIN	equ     (INDEX_glLastFunc+10)
INDEX_glMultiTexCoord1fvWIN	equ     (INDEX_glLastFunc+11)
INDEX_glMultiTexCoord1iWIN	equ     (INDEX_glLastFunc+12)
INDEX_glMultiTexCoord1ivWIN	equ     (INDEX_glLastFunc+13)
INDEX_glMultiTexCoord1sWIN	equ     (INDEX_glLastFunc+14)
INDEX_glMultiTexCoord1svWIN	equ     (INDEX_glLastFunc+15)
INDEX_glMultiTexCoord2dWIN	equ     (INDEX_glLastFunc+16)
INDEX_glMultiTexCoord2dvWIN	equ     (INDEX_glLastFunc+17)
INDEX_glMultiTexCoord2fWIN	equ     (INDEX_glLastFunc+18)
INDEX_glMultiTexCoord2fvWIN	equ     (INDEX_glLastFunc+19)
INDEX_glMultiTexCoord2iWIN	equ     (INDEX_glLastFunc+20)
INDEX_glMultiTexCoord2ivWIN	equ     (INDEX_glLastFunc+21)
INDEX_glMultiTexCoord2sWIN	equ     (INDEX_glLastFunc+22)
INDEX_glMultiTexCoord2svWIN	equ     (INDEX_glLastFunc+23)
INDEX_glMultiTexCoord3dWIN	equ     (INDEX_glLastFunc+24)
INDEX_glMultiTexCoord3dvWIN	equ     (INDEX_glLastFunc+25)
INDEX_glMultiTexCoord3fWIN	equ     (INDEX_glLastFunc+26)
INDEX_glMultiTexCoord3fvWIN	equ     (INDEX_glLastFunc+27)
INDEX_glMultiTexCoord3iWIN	equ     (INDEX_glLastFunc+28)
INDEX_glMultiTexCoord3ivWIN	equ     (INDEX_glLastFunc+29)
INDEX_glMultiTexCoord3sWIN	equ     (INDEX_glLastFunc+30)
INDEX_glMultiTexCoord3svWIN	equ     (INDEX_glLastFunc+31)
INDEX_glMultiTexCoord4dWIN	equ     (INDEX_glLastFunc+32)
INDEX_glMultiTexCoord4dvWIN	equ     (INDEX_glLastFunc+33)
INDEX_glMultiTexCoord4fWIN	equ     (INDEX_glLastFunc+34)
INDEX_glMultiTexCoord4fvWIN	equ     (INDEX_glLastFunc+35)
INDEX_glMultiTexCoord4iWIN	equ     (INDEX_glLastFunc+36)
INDEX_glMultiTexCoord4ivWIN	equ     (INDEX_glLastFunc+37)
INDEX_glMultiTexCoord4sWIN	equ     (INDEX_glLastFunc+38)
INDEX_glMultiTexCoord4svWIN	equ     (INDEX_glLastFunc+39)
INDEX_glBindNthTextureWIN	equ     (INDEX_glLastFunc+40)
INDEX_glNthTexCombineFuncWIN	equ     (INDEX_glLastFunc+41)

; OpenGL function index in the dispatch table cache in the TEB.

FASTINDEX_glCallList            equ     0
FASTINDEX_glCallLists           equ     1
FASTINDEX_glBegin               equ     2
FASTINDEX_glColor3b             equ     3
FASTINDEX_glColor3bv            equ     4
FASTINDEX_glColor3d             equ     5
FASTINDEX_glColor3dv            equ     6
FASTINDEX_glColor3f             equ     7
FASTINDEX_glColor3fv            equ     8
FASTINDEX_glColor3i             equ     9
FASTINDEX_glColor3iv            equ     10
FASTINDEX_glColor3s             equ     11
FASTINDEX_glColor3sv            equ     12
FASTINDEX_glColor3ub            equ     13
FASTINDEX_glColor3ubv           equ     14
FASTINDEX_glColor3ui            equ     15
FASTINDEX_glColor3uiv           equ     16
FASTINDEX_glColor3us            equ     17
FASTINDEX_glColor3usv           equ     18
FASTINDEX_glColor4b             equ     19
FASTINDEX_glColor4bv            equ     20
FASTINDEX_glColor4d             equ     21
FASTINDEX_glColor4dv            equ     22
FASTINDEX_glColor4f             equ     23
FASTINDEX_glColor4fv            equ     24
FASTINDEX_glColor4i             equ     25
FASTINDEX_glColor4iv            equ     26
FASTINDEX_glColor4s             equ     27
FASTINDEX_glColor4sv            equ     28
FASTINDEX_glColor4ub            equ     29
FASTINDEX_glColor4ubv           equ     30
FASTINDEX_glColor4ui            equ     31
FASTINDEX_glColor4uiv           equ     32
FASTINDEX_glColor4us            equ     33
FASTINDEX_glColor4usv           equ     34
FASTINDEX_glEdgeFlag            equ     35
FASTINDEX_glEdgeFlagv           equ     36
FASTINDEX_glEnd                 equ     37
FASTINDEX_glIndexd              equ     38
FASTINDEX_glIndexdv             equ     39
FASTINDEX_glIndexf              equ     40
FASTINDEX_glIndexfv             equ     41
FASTINDEX_glIndexi              equ     42
FASTINDEX_glIndexiv             equ     43
FASTINDEX_glIndexs              equ     44
FASTINDEX_glIndexsv             equ     45
FASTINDEX_glNormal3b            equ     46
FASTINDEX_glNormal3bv           equ     47
FASTINDEX_glNormal3d            equ     48
FASTINDEX_glNormal3dv           equ     49
FASTINDEX_glNormal3f            equ     50
FASTINDEX_glNormal3fv           equ     51
FASTINDEX_glNormal3i            equ     52
FASTINDEX_glNormal3iv           equ     53
FASTINDEX_glNormal3s            equ     54
FASTINDEX_glNormal3sv           equ     55
FASTINDEX_glTexCoord1d          equ     56
FASTINDEX_glTexCoord1dv         equ     57
FASTINDEX_glTexCoord1f          equ     58
FASTINDEX_glTexCoord1fv         equ     59
FASTINDEX_glTexCoord1i          equ     60
FASTINDEX_glTexCoord1iv         equ     61
FASTINDEX_glTexCoord1s          equ     62
FASTINDEX_glTexCoord1sv         equ     63
FASTINDEX_glTexCoord2d          equ     64
FASTINDEX_glTexCoord2dv         equ     65
FASTINDEX_glTexCoord2f          equ     66
FASTINDEX_glTexCoord2fv         equ     67
FASTINDEX_glTexCoord2i          equ     68
FASTINDEX_glTexCoord2iv         equ     69
FASTINDEX_glTexCoord2s          equ     70
FASTINDEX_glTexCoord2sv         equ     71
FASTINDEX_glTexCoord3d          equ     72
FASTINDEX_glTexCoord3dv         equ     73
FASTINDEX_glTexCoord3f          equ     74
FASTINDEX_glTexCoord3fv         equ     75
FASTINDEX_glTexCoord3i          equ     76
FASTINDEX_glTexCoord3iv         equ     77
FASTINDEX_glTexCoord3s          equ     78
FASTINDEX_glTexCoord3sv         equ     79
FASTINDEX_glTexCoord4d          equ     80
FASTINDEX_glTexCoord4dv         equ     81
FASTINDEX_glTexCoord4f          equ     82
FASTINDEX_glTexCoord4fv         equ     83
FASTINDEX_glTexCoord4i          equ     84
FASTINDEX_glTexCoord4iv         equ     85
FASTINDEX_glTexCoord4s          equ     86
FASTINDEX_glTexCoord4sv         equ     87
FASTINDEX_glVertex2d            equ     88
FASTINDEX_glVertex2dv           equ     89
FASTINDEX_glVertex2f            equ     90
FASTINDEX_glVertex2fv           equ     91
FASTINDEX_glVertex2i            equ     92
FASTINDEX_glVertex2iv           equ     93
FASTINDEX_glVertex2s            equ     94
FASTINDEX_glVertex2sv           equ     95
FASTINDEX_glVertex3d            equ     96
FASTINDEX_glVertex3dv           equ     97
FASTINDEX_glVertex3f            equ     98
FASTINDEX_glVertex3fv           equ     99
FASTINDEX_glVertex3i            equ     100
FASTINDEX_glVertex3iv           equ     101
FASTINDEX_glVertex3s            equ     102
FASTINDEX_glVertex3sv           equ     103
FASTINDEX_glVertex4d            equ     104
FASTINDEX_glVertex4dv           equ     105
FASTINDEX_glVertex4f            equ     106
FASTINDEX_glVertex4fv           equ     107
FASTINDEX_glVertex4i            equ     108
FASTINDEX_glVertex4iv           equ     109
FASTINDEX_glVertex4s            equ     110
FASTINDEX_glVertex4sv           equ     111
FASTINDEX_glMaterialf           equ     112
FASTINDEX_glMaterialfv          equ     113
FASTINDEX_glMateriali           equ     114
FASTINDEX_glMaterialiv          equ     115
FASTINDEX_glDisable             equ     116
FASTINDEX_glEnable              equ     117
FASTINDEX_glPopAttrib           equ     118
FASTINDEX_glPushAttrib          equ     119
FASTINDEX_glEvalCoord1d         equ     120
FASTINDEX_glEvalCoord1dv        equ     121
FASTINDEX_glEvalCoord1f         equ     122
FASTINDEX_glEvalCoord1fv        equ     123
FASTINDEX_glEvalCoord2d         equ     124
FASTINDEX_glEvalCoord2dv        equ     125
FASTINDEX_glEvalCoord2f         equ     126
FASTINDEX_glEvalCoord2fv        equ     127
FASTINDEX_glEvalPoint1          equ     128
FASTINDEX_glEvalPoint2          equ     129
FASTINDEX_glLoadIdentity        equ     130
FASTINDEX_glLoadMatrixf         equ     131
FASTINDEX_glLoadMatrixd         equ     132
FASTINDEX_glMatrixMode          equ     133
FASTINDEX_glMultMatrixf         equ     134
FASTINDEX_glMultMatrixd         equ     135
FASTINDEX_glPopMatrix           equ     136
FASTINDEX_glPushMatrix          equ     137
FASTINDEX_glRotated             equ     138
FASTINDEX_glRotatef             equ     139
FASTINDEX_glScaled              equ     140
FASTINDEX_glScalef              equ     141
FASTINDEX_glTranslated          equ     142
FASTINDEX_glTranslatef          equ     143
FASTINDEX_glArrayElement        equ     144
FASTINDEX_glBindTexture         equ     145
FASTINDEX_glColorPointer        equ     146
FASTINDEX_glDisableClientState  equ     147
FASTINDEX_glDrawArrays          equ     148
FASTINDEX_glDrawElements        equ     149
FASTINDEX_glEdgeFlagPointer     equ     150
FASTINDEX_glEnableClientState   equ     151
FASTINDEX_glIndexPointer        equ     152
FASTINDEX_glIndexub             equ     153
FASTINDEX_glIndexubv            equ     154
FASTINDEX_glInterleavedArrays   equ     155
FASTINDEX_glNormalPointer       equ     156
FASTINDEX_glPolygonOffset       equ     157
FASTINDEX_glTexCoordPointer     equ     158
FASTINDEX_glVertexPointer       equ     159
FASTINDEX_glGetPointerv         equ     160
FASTINDEX_glPopClientAttrib     equ     161
FASTINDEX_glPushClientAttrib    equ     162
FASTINDEX_glDrawRangeElementsWIN equ    163
FASTINDEX_glColorTableEXT       equ     164
FASTINDEX_glColorSubTableEXT    equ     165
FASTINDEX_glCurrentTextureIndexWIN equ  166
FASTINDEX_glBindNthTextureWIN	equ     167
FASTINDEX_glNthTexCombineFuncWIN equ    168
FASTINDEX_glMultiTexCoord1fWIN	equ     169
FASTINDEX_glMultiTexCoord1fvWIN	equ     170
FASTINDEX_glMultiTexCoord1iWIN	equ     171
FASTINDEX_glMultiTexCoord1ivWIN	equ     172
FASTINDEX_glMultiTexCoord2fWIN	equ     173
FASTINDEX_glMultiTexCoord2fvWIN	equ     174
FASTINDEX_glMultiTexCoord2iWIN	equ     175
FASTINDEX_glMultiTexCoord2ivWIN	equ     176
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\exttable.h ===
/******************************Module*Header*******************************\
* Module Name: exttable.h
*
* Dispatch table for extension functions
*
* Created: 11/27/95
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-96 Microsoft Corporation
\**************************************************************************/

#ifndef __EXTTABLE_H__
#define __EXTTABLE_H__

typedef struct _GLEXTDISPATCHTABLE
{
    void (APIENTRY *glDrawRangeElementsWIN)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
    void (APIENTRY *glColorTableEXT)       ( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data);
    void (APIENTRY *glColorSubTableEXT)    ( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
    void (APIENTRY *glGetColorTableEXT)    ( GLenum target, GLenum format, GLenum type, GLvoid *data);
    void (APIENTRY *glGetColorTableParameterivEXT) ( GLenum target, GLenum pname, GLint *params);
    void (APIENTRY *glGetColorTableParameterfvEXT) ( GLenum target, GLenum pname, GLfloat *params);
#ifdef GL_WIN_multiple_textures
    void (APIENTRY *glCurrentTextureIndexWIN)
        (GLuint index);
    void (APIENTRY *glMultiTexCoord1dWIN)
        (GLbitfield mask, GLdouble s);
    void (APIENTRY *glMultiTexCoord1dvWIN)
        (GLbitfield mask, const GLdouble *v);
    void (APIENTRY *glMultiTexCoord1fWIN)
        (GLbitfield mask, GLfloat s);
    void (APIENTRY *glMultiTexCoord1fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord1iWIN)
        (GLbitfield mask, GLint s);
    void (APIENTRY *glMultiTexCoord1ivWIN)
        (GLbitfield mask, const GLint *v);
    void (APIENTRY *glMultiTexCoord1sWIN)
        (GLbitfield mask, GLshort s);
    void (APIENTRY *glMultiTexCoord1svWIN)
        (GLbitfield mask, const GLshort *v);
    void (APIENTRY *glMultiTexCoord2dWIN)
        (GLbitfield mask, GLdouble s, GLdouble t);
    void (APIENTRY *glMultiTexCoord2dvWIN)
        (GLbitfield mask, const GLdouble *v);
    void (APIENTRY *glMultiTexCoord2fWIN)
        (GLbitfield mask, GLfloat s, GLfloat t);
    void (APIENTRY *glMultiTexCoord2fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord2iWIN)
        (GLbitfield mask, GLint s, GLint t);
    void (APIENTRY *glMultiTexCoord2ivWIN)
        (GLbitfield mask, const GLint *v);
    void (APIENTRY *glMultiTexCoord2sWIN)
        (GLbitfield mask, GLshort s, GLshort t);
    void (APIENTRY *glMultiTexCoord2svWIN)
        (GLbitfield mask, const GLshort *v);
    void (APIENTRY *glMultiTexCoord3dWIN)
        (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r);
    void (APIENTRY *glMultiTexCoord3dvWIN)
        (GLbitfield mask, const GLdouble *v);
    void (APIENTRY *glMultiTexCoord3fWIN)
        (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r);
    void (APIENTRY *glMultiTexCoord3fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord3iWIN)
        (GLbitfield mask, GLint s, GLint t, GLint r);
    void (APIENTRY *glMultiTexCoord3ivWIN)
        (GLbitfield mask, const GLint *v);
    void (APIENTRY *glMultiTexCoord3sWIN)
        (GLbitfield mask, GLshort s, GLshort t, GLshort r);
    void (APIENTRY *glMultiTexCoord3svWIN)
        (GLbitfield mask, const GLshort *v);
    void (APIENTRY *glMultiTexCoord4dWIN)
        (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
    void (APIENTRY *glMultiTexCoord4dvWIN)
        (GLbitfield mask, const GLdouble *v);
    void (APIENTRY *glMultiTexCoord4fWIN)
        (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
    void (APIENTRY *glMultiTexCoord4fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord4iWIN)
        (GLbitfield mask, GLint s, GLint t, GLint r, GLint q);
    void (APIENTRY *glMultiTexCoord4ivWIN)
        (GLbitfield mask, const GLint *v);
    void (APIENTRY *glMultiTexCoord4sWIN)
        (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q);
    void (APIENTRY *glMultiTexCoord4svWIN)
        (GLbitfield mask, const GLshort *v);
    void (APIENTRY *glBindNthTextureWIN)
        (GLuint index, GLenum target, GLuint texture);
    void (APIENTRY *glNthTexCombineFuncWIN)
        (GLuint index,
         GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
         GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures
} GLEXTDISPATCHTABLE, *PGLEXTDISPATCHTABLE;

typedef struct _GLEXTPROCTABLE
{
    int                cEntries;        // Number of function entries in table
    GLEXTDISPATCHTABLE glDispatchTable; // OpenGL function dispatch table
} GLEXTPROCTABLE, *PGLEXTPROCTABLE;

#endif // __EXTTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glapi.h ===
/******************************Module*Header*******************************\
* Module Name: glapi.h
*
* OpenGL API function table indices and cached fast dispatch table
*
* Created: 12/27/1993
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef __GLAPI_H__
#define __GLAPI_H__

// Opengl dispatch table indices
#include "dispindx.h"

// OpenGL fast function dispatch table in the TEB's glDispatchTable field.
// These cached functions have less overhead because we can avoid
// dereferencing the dispatch table pointer stored in the TEB (save one
// level of indirection).
//
// NOTE: If you modify the table, you also need to modify the above fast
// indices.

typedef struct _GLDISPATCHTABLE_FAST {
    void      (APIENTRY *glCallList               )( GLuint list );
    void      (APIENTRY *glCallLists              )( GLsizei n, GLenum type, const GLvoid *lists );
    void      (APIENTRY *glBegin                  )( GLenum mode );
    void      (APIENTRY *glColor3b                )( GLbyte red, GLbyte green, GLbyte blue );
    void      (APIENTRY *glColor3bv               )( const GLbyte *v );
    void      (APIENTRY *glColor3d                )( GLdouble red, GLdouble green, GLdouble blue );
    void      (APIENTRY *glColor3dv               )( const GLdouble *v );
    void      (APIENTRY *glColor3f                )( GLfloat red, GLfloat green, GLfloat blue );
    void      (APIENTRY *glColor3fv               )( const GLfloat *v );
    void      (APIENTRY *glColor3i                )( GLint red, GLint green, GLint blue );
    void      (APIENTRY *glColor3iv               )( const GLint *v );
    void      (APIENTRY *glColor3s                )( GLshort red, GLshort green, GLshort blue );
    void      (APIENTRY *glColor3sv               )( const GLshort *v );
    void      (APIENTRY *glColor3ub               )( GLubyte red, GLubyte green, GLubyte blue );
    void      (APIENTRY *glColor3ubv              )( const GLubyte *v );
    void      (APIENTRY *glColor3ui               )( GLuint red, GLuint green, GLuint blue );
    void      (APIENTRY *glColor3uiv              )( const GLuint *v );
    void      (APIENTRY *glColor3us               )( GLushort red, GLushort green, GLushort blue );
    void      (APIENTRY *glColor3usv              )( const GLushort *v );
    void      (APIENTRY *glColor4b                )( GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha );
    void      (APIENTRY *glColor4bv               )( const GLbyte *v );
    void      (APIENTRY *glColor4d                )( GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha );
    void      (APIENTRY *glColor4dv               )( const GLdouble *v );
    void      (APIENTRY *glColor4f                )( GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha );
    void      (APIENTRY *glColor4fv               )( const GLfloat *v );
    void      (APIENTRY *glColor4i                )( GLint red, GLint green, GLint blue, GLint alpha );
    void      (APIENTRY *glColor4iv               )( const GLint *v );
    void      (APIENTRY *glColor4s                )( GLshort red, GLshort green, GLshort blue, GLshort alpha );
    void      (APIENTRY *glColor4sv               )( const GLshort *v );
    void      (APIENTRY *glColor4ub               )( GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha );
    void      (APIENTRY *glColor4ubv              )( const GLubyte *v );
    void      (APIENTRY *glColor4ui               )( GLuint red, GLuint green, GLuint blue, GLuint alpha );
    void      (APIENTRY *glColor4uiv              )( const GLuint *v );
    void      (APIENTRY *glColor4us               )( GLushort red, GLushort green, GLushort blue, GLushort alpha );
    void      (APIENTRY *glColor4usv              )( const GLushort *v );
    void      (APIENTRY *glEdgeFlag               )( GLboolean flag );
    void      (APIENTRY *glEdgeFlagv              )( const GLboolean *flag );
    void      (APIENTRY *glEnd                    )( void );
    void      (APIENTRY *glIndexd                 )( GLdouble c );
    void      (APIENTRY *glIndexdv                )( const GLdouble *c );
    void      (APIENTRY *glIndexf                 )( GLfloat c );
    void      (APIENTRY *glIndexfv                )( const GLfloat *c );
    void      (APIENTRY *glIndexi                 )( GLint c );
    void      (APIENTRY *glIndexiv                )( const GLint *c );
    void      (APIENTRY *glIndexs                 )( GLshort c );
    void      (APIENTRY *glIndexsv                )( const GLshort *c );
    void      (APIENTRY *glNormal3b               )( GLbyte nx, GLbyte ny, GLbyte nz );
    void      (APIENTRY *glNormal3bv              )( const GLbyte *v );
    void      (APIENTRY *glNormal3d               )( GLdouble nx, GLdouble ny, GLdouble nz );
    void      (APIENTRY *glNormal3dv              )( const GLdouble *v );
    void      (APIENTRY *glNormal3f               )( GLfloat nx, GLfloat ny, GLfloat nz );
    void      (APIENTRY *glNormal3fv              )( const GLfloat *v );
    void      (APIENTRY *glNormal3i               )( GLint nx, GLint ny, GLint nz );
    void      (APIENTRY *glNormal3iv              )( const GLint *v );
    void      (APIENTRY *glNormal3s               )( GLshort nx, GLshort ny, GLshort nz );
    void      (APIENTRY *glNormal3sv              )( const GLshort *v );
    void      (APIENTRY *glTexCoord1d             )( GLdouble s );
    void      (APIENTRY *glTexCoord1dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord1f             )( GLfloat s );
    void      (APIENTRY *glTexCoord1fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord1i             )( GLint s );
    void      (APIENTRY *glTexCoord1iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord1s             )( GLshort s );
    void      (APIENTRY *glTexCoord1sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord2d             )( GLdouble s, GLdouble t );
    void      (APIENTRY *glTexCoord2dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord2f             )( GLfloat s, GLfloat t );
    void      (APIENTRY *glTexCoord2fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord2i             )( GLint s, GLint t );
    void      (APIENTRY *glTexCoord2iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord2s             )( GLshort s, GLshort t );
    void      (APIENTRY *glTexCoord2sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord3d             )( GLdouble s, GLdouble t, GLdouble r );
    void      (APIENTRY *glTexCoord3dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord3f             )( GLfloat s, GLfloat t, GLfloat r );
    void      (APIENTRY *glTexCoord3fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord3i             )( GLint s, GLint t, GLint r );
    void      (APIENTRY *glTexCoord3iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord3s             )( GLshort s, GLshort t, GLshort r );
    void      (APIENTRY *glTexCoord3sv            )( const GLshort *v );
    void      (APIENTRY *glTexCoord4d             )( GLdouble s, GLdouble t, GLdouble r, GLdouble q );
    void      (APIENTRY *glTexCoord4dv            )( const GLdouble *v );
    void      (APIENTRY *glTexCoord4f             )( GLfloat s, GLfloat t, GLfloat r, GLfloat q );
    void      (APIENTRY *glTexCoord4fv            )( const GLfloat *v );
    void      (APIENTRY *glTexCoord4i             )( GLint s, GLint t, GLint r, GLint q );
    void      (APIENTRY *glTexCoord4iv            )( const GLint *v );
    void      (APIENTRY *glTexCoord4s             )( GLshort s, GLshort t, GLshort r, GLshort q );
    void      (APIENTRY *glTexCoord4sv            )( const GLshort *v );
    void      (APIENTRY *glVertex2d               )( GLdouble x, GLdouble y );
    void      (APIENTRY *glVertex2dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex2f               )( GLfloat x, GLfloat y );
    void      (APIENTRY *glVertex2fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex2i               )( GLint x, GLint y );
    void      (APIENTRY *glVertex2iv              )( const GLint *v );
    void      (APIENTRY *glVertex2s               )( GLshort x, GLshort y );
    void      (APIENTRY *glVertex2sv              )( const GLshort *v );
    void      (APIENTRY *glVertex3d               )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glVertex3dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex3f               )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glVertex3fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex3i               )( GLint x, GLint y, GLint z );
    void      (APIENTRY *glVertex3iv              )( const GLint *v );
    void      (APIENTRY *glVertex3s               )( GLshort x, GLshort y, GLshort z );
    void      (APIENTRY *glVertex3sv              )( const GLshort *v );
    void      (APIENTRY *glVertex4d               )( GLdouble x, GLdouble y, GLdouble z, GLdouble w );
    void      (APIENTRY *glVertex4dv              )( const GLdouble *v );
    void      (APIENTRY *glVertex4f               )( GLfloat x, GLfloat y, GLfloat z, GLfloat w );
    void      (APIENTRY *glVertex4fv              )( const GLfloat *v );
    void      (APIENTRY *glVertex4i               )( GLint x, GLint y, GLint z, GLint w );
    void      (APIENTRY *glVertex4iv              )( const GLint *v );
    void      (APIENTRY *glVertex4s               )( GLshort x, GLshort y, GLshort z, GLshort w );
    void      (APIENTRY *glVertex4sv              )( const GLshort *v );
    void      (APIENTRY *glMaterialf              )( GLenum face, GLenum pname, GLfloat param );
    void      (APIENTRY *glMaterialfv             )( GLenum face, GLenum pname, const GLfloat *params );
    void      (APIENTRY *glMateriali              )( GLenum face, GLenum pname, GLint param );
    void      (APIENTRY *glMaterialiv             )( GLenum face, GLenum pname, const GLint *params );
    void      (APIENTRY *glDisable                )( GLenum cap );
    void      (APIENTRY *glEnable                 )( GLenum cap );
    void      (APIENTRY *glPopAttrib              )( void );
    void      (APIENTRY *glPushAttrib             )( GLbitfield mask );
    void      (APIENTRY *glEvalCoord1d            )( GLdouble u );
    void      (APIENTRY *glEvalCoord1dv           )( const GLdouble *u );
    void      (APIENTRY *glEvalCoord1f            )( GLfloat u );
    void      (APIENTRY *glEvalCoord1fv           )( const GLfloat *u );
    void      (APIENTRY *glEvalCoord2d            )( GLdouble u, GLdouble v );
    void      (APIENTRY *glEvalCoord2dv           )( const GLdouble *u );
    void      (APIENTRY *glEvalCoord2f            )( GLfloat u, GLfloat v );
    void      (APIENTRY *glEvalCoord2fv           )( const GLfloat *u );
    void      (APIENTRY *glEvalPoint1             )( GLint i );
    void      (APIENTRY *glEvalPoint2             )( GLint i, GLint j );
    void      (APIENTRY *glLoadIdentity           )( void );
    void      (APIENTRY *glLoadMatrixf            )( const GLfloat *m );
    void      (APIENTRY *glLoadMatrixd            )( const GLdouble *m );
    void      (APIENTRY *glMatrixMode             )( GLenum mode );
    void      (APIENTRY *glMultMatrixf            )( const GLfloat *m );
    void      (APIENTRY *glMultMatrixd            )( const GLdouble *m );
    void      (APIENTRY *glPopMatrix              )( void );
    void      (APIENTRY *glPushMatrix             )( void );
    void      (APIENTRY *glRotated                )( GLdouble angle, GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glRotatef                )( GLfloat angle, GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glScaled                 )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glScalef                 )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glTranslated             )( GLdouble x, GLdouble y, GLdouble z );
    void      (APIENTRY *glTranslatef             )( GLfloat x, GLfloat y, GLfloat z );
    void      (APIENTRY *glArrayElement           )(GLint i);
    void      (APIENTRY *glBindTexture            )(GLenum target, GLuint texture);
    void      (APIENTRY *glColorPointer           )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glDisableClientState     )(GLenum array);
    void      (APIENTRY *glDrawArrays             )(GLenum mode, GLint first, GLsizei count);
    void      (APIENTRY *glDrawElements           )(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
    void      (APIENTRY *glEdgeFlagPointer        )(GLsizei stride, const GLvoid* *pointer);
    void      (APIENTRY *glEnableClientState      )(GLenum array);
    void      (APIENTRY *glIndexPointer           )(GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glIndexub                )(GLubyte c);
    void      (APIENTRY *glIndexubv               )(const GLubyte *c);
    void      (APIENTRY *glInterleavedArrays      )(GLenum format, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glNormalPointer          )(GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glPolygonOffset          )(GLfloat factor, GLfloat units);
    void      (APIENTRY *glTexCoordPointer        )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glVertexPointer          )(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
    void      (APIENTRY *glGetPointerv            )(GLenum pname, GLvoid* *params);
    void      (APIENTRY *glPopClientAttrib        )(void);
    void      (APIENTRY *glPushClientAttrib       )(GLbitfield mask);
    void (APIENTRY *glDrawRangeElementsWIN)
        (GLenum mode, GLuint start, GLuint end, GLsizei count,
         GLenum type, const GLvoid *indices);
    void (APIENTRY *glColorTableEXT)
        (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
         GLenum type, const GLvoid *data);
    void (APIENTRY *glColorSubTableEXT)
        (GLenum target, GLsizei start, GLsizei count, GLenum format,
         GLenum type, const GLvoid *data);
#ifdef GL_WIN_multiple_textures
    void (APIENTRY *glCurrentTextureIndexWIN)
        (GLuint index);
    void (APIENTRY *glBindNthTextureWIN)
        (GLenum index, GLenum target, GLuint texture);
    void (APIENTRY *glNthTexCombineFuncWIN)
        (GLenum index,
         GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
         GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
    void (APIENTRY *glMultiTexCoord1fWIN)
        (GLbitfield mask, GLfloat s);
    void (APIENTRY *glMultiTexCoord1fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord1iWIN)
        (GLbitfield mask, GLint s);
    void (APIENTRY *glMultiTexCoord1ivWIN)
        (GLbitfield mask, const GLint *v);
    void (APIENTRY *glMultiTexCoord2fWIN)
        (GLbitfield mask, GLfloat s, GLfloat t);
    void (APIENTRY *glMultiTexCoord2fvWIN)
        (GLbitfield mask, const GLfloat *v);
    void (APIENTRY *glMultiTexCoord2iWIN)
        (GLbitfield mask, GLint s, GLint t);
    void (APIENTRY *glMultiTexCoord2ivWIN)
        (GLbitfield mask, const GLint *v);
#endif // GL_WIN_multiple_textures
} GLDISPATCHTABLE_FAST, *PGLDISPATCHTABLE_FAST;

#endif /* !__GLAPI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glgdimsg.h ===
/*
 *  Copyright 1991, 1992, Silicon Graphics, Inc.
 *  All Rights Reserved.
 *
 *  This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
 *  the contents of this file may not be disclosed to third parties, copied or
 *  duplicated in any form, in whole or in part, without the prior written
 *  permission of Silicon Graphics, Inc.
 *
 *  RESTRICTED RIGHTS LEGEND:
 *  Use, duplication or disclosure by the Government is subject to restrictions
 *  as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
 *  and Computer Software clause at DFARS 252.227-7013, and/or in similar or
 *  successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
 *  rights reserved under the Copyright Laws of the United States.
 */

#ifndef __GLGDIMSG_H__
#define __GLGDIMSG_H__

// These are new GDI messages used by the sub batching code.

#ifdef DOGLMSGBATCHSTATS

typedef struct _MSG_GLMSGBATCHSTATS
{
    CSR_QLPC_API_MSG msg;
    LONG Action;
    GLMSGBATCHSTATS BatchStats;

} MSG_GLMSGBATCHSTATS, *PMSG_GLMSGBATCHSTATS;

#endif /* DOGLMSGBATCHSTATS */

#endif /* __GLGDIMSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glgenwin.h ===
/******************************Module*Header*******************************\
* Module Name: glgenwin.h
*
* Client side replacement for WNDOBJ.  Tracks window state (size, location,
* clip region, etc.).
*
* Created: 12-Jan-1995 00:31:42
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#ifndef _GLGENWIN_H_
#define _GLGENWIN_H_

// Tracks lock/unlock calls on windows if defined.  This is always
// on for checked builds.
#define TRACK_WINCRIT

#if DBG && !defined(TRACK_WINCRIT)
#define TRACK_WINCRIT
#endif

// Not defined in NT 3.51!
typedef ULONG FLONG;

/*
 * GLGENscan structure
 *
 * Represents a single scan of a region.  Consists of a top, a bottom
 * and an even number of walls.
 *
 * Part of the GLGENscanData structure.
 */
typedef struct GLGENscanRec GLGENscan;
typedef struct GLGENscanRec
{
// Accelerator points to next GLGENscan in the array (we could compute).

    GLGENscan *pNext;

    ULONG     cWalls;
    LONG      top;
    LONG      bottom;
#ifdef _IA64_
	LONG      pad;
#endif
    LONG      alWalls[1];   // array of walls

} GLGENscan;

/*
 * GLGENscanData structure
 *
 * Scan line oriented version of the visible region info in the RGNDATA
 * structure.
 */
typedef struct GLGENscanDataRec
{
    ULONG     cScans;
    GLGENscan aScans[1];    // array of scans

} GLGENscanData;

/*
 * GLGENlayerInfo structure
 *
 * Information about an overlay/underlay.
 */
typedef struct GLGENlayerInfo
{
    LONG     cPalEntries;
    COLORREF pPalEntries[1];
} GLGENlayerInfo;

/*
 * GLGENlayers structure
 *
 *
 */
typedef struct GLGENlayers
{
    GLGENlayerInfo *overlayInfo[15];
    GLGENlayerInfo *underlayInfo[15];
} GLGENlayers;

/*
 * Identifying information for a window
 */

#define GLWID_ERROR          0
#define GLWID_HWND           1
#define GLWID_HDC            2
#define GLWID_DDRAW          3

typedef struct IDirectDrawSurface *LPDIRECTDRAWSURFACE;

typedef struct _GLWINDOWID
{
    int iType;
    HWND hwnd;
    HDC hdc;
    LPDIRECTDRAWSURFACE pdds;
} GLWINDOWID;

#define CLC_TRIVIAL     0
#define CLC_RECT        1
#define CLC_COMPLEX     2

/*
 * GLGENwindows structure
 *
 * Substitute for the NT DDI's WNDOBJ service.  This structure is used to
 * track the current state of a window (size, location, clipping).  A
 * semaphore protected linked list of these is kept globally per-process.
 */
typedef struct GLGENwindowRec GLGENwindow;
typedef struct GLGENwindowRec
{
    struct __GLGENbuffersRec *buffers; // Buffer information
    int         clipComplexity; // Clipping area complexity
    RECTL       rclBounds;      // Clip area bounds
    RECTL       rclClient;      // Window client rect
    GLGENwindow *pNext;         // linked list
    GLWINDOWID  gwid;           // Identifying information
    int         ipfd;           // pixel format assigned to this window
    int         ipfdDevMax;     // max. device pixel format
    WNDPROC     pfnOldWndProc;  // original WndProc function
    ULONG       ulPaletteUniq;  // uniq palette id
    ULONG       ulFlags;

// These fields are used for direct screen access

    LPDIRECTDRAWCLIPPER pddClip;// DirectDraw clipper assocated with window
    UINT        cjrgndat;       // size of RGNDATA struct
    RGNDATA     *prgndat;       // pointer to RGNDATA struct

// Scan version of RGNDATA.

    UINT        cjscandat;      // size of GLGENscanData struct
    GLGENscanData *pscandat;    // pointer to GLGENscanData struct

// Installable client drivers ONLY.

    PVOID       pvDriver;       // pointer to GLDRIVER for window

// Layer palettes for MCD drivers ONLY.

    GLGENlayers *plyr;          // pointer to GLGENlayers for window
                                // non-NULL only if overlays for MCD are
                                // actively in use

    // DirectDraw surface vtbl pointer for doing DDraw surface validation
    void *pvSurfaceVtbl;
    
    // DirectDraw surface locked if DIRECTSCREEN is set
    LPDIRECTDRAWSURFACE pddsDirectScreen;
    void *pvDirectScreen;
    void *pvDirectScreenLock;

    // MCD server-side handle for this window
    ULONG_PTR dwMcdWindow;

    //
    // Reference counting and serialization.
    //
    
    // Count of things holding a pointer to this window.
    LONG lUsers;
    
    // All accesses to this window's data must occur under this lock.
    CRITICAL_SECTION sem;

    // Context that is currently holding this window's lock.
    struct __GLGENcontextRec *gengc;
    
    // Thread that is currently holding this window's lock and
    // recursion count on this window's lock.  This information may
    // be in the critical section but to be cross-platform we
    // maintain it ourselves.
    DWORD owningThread;
    DWORD lockRecursion;
} GLGENwindow;

/*
 * GLGENwindow::ulFlags
 *
 *  GLGENWIN_DIRECTSCREEN       Direct screen access locks are held
 *  GLGENWIN_OTHERPROCESS       The window handle is from another process
 *  GLGENWIN_DRIVERSET          pvDriver has been set
 */
#define GLGENWIN_DIRECTSCREEN   0x00000001
#define GLGENWIN_OTHERPROCESS   0x00000002
#define GLGENWIN_DRIVERSET      0x00000004

/*
 * Global header node for the linked list of GLGENwindow structures.
 * The semaphore in the header node is used as the list access semaphore.
 */
extern GLGENwindow gwndHeader;

/*
 * GLGENwindow list management functions.
 */

// Retrieves the GLGENwindow that corresponds to the specified HWND.
// NULL if failure.
// Increments lUsers
extern GLGENwindow * APIENTRY pwndGetFromHWND(HWND hwnd);

// Retrieves the GLGENwindow that corresponds to the specified HDC.
// NULL if failure.
// Increments lUsers
extern GLGENwindow * APIENTRY pwndGetFromMemDC(HDC hdc);

// Retrieves the GLGENwindow that corresponds to the specified DDraw surface.
// NULL if failure.
// Increments lUsers
GLGENwindow *pwndGetFromDdraw(LPDIRECTDRAWSURFACE pdds);

// General retrieval
// NULL if failure.
// Increments lUsers
extern GLGENwindow * APIENTRY pwndGetFromID(GLWINDOWID *pgwid);

// Allocates a new GLGENwindow structure and puts it into the linked list.
// NULL if failure.
// Starts lUsers at 1
extern GLGENwindow * APIENTRY pwndNew(GLGENwindow *pwndInit);

// Creates a GLGENwindow for the given information
extern GLGENwindow * APIENTRY CreatePwnd(GLWINDOWID *pgwid, int ipfd,
                                         int ipfdDevMax, DWORD dwObjectType,
                                         RECTL *prcl, BOOL *pbNew);

// Cleans up resources for a GLGENwindow
// NULL if success; pointer to GLGENwindow structure if failure.
extern GLGENwindow * APIENTRY pwndFree(GLGENwindow *pwnd,
                                       BOOL bExitProcess);

// Removes an active GLGENwindow from the window list and
// waits for a safe time to clean it up, then pwndFrees it
extern void APIENTRY pwndCleanup(GLGENwindow *pwnd);

// Decrements lUsers
#if DBG
extern void APIENTRY pwndRelease(GLGENwindow *pwnd);
#else
#define pwndRelease(pwnd) \
    InterlockedDecrement(&(pwnd)->lUsers)
#endif

// Unlocks pwnd->sem and does pwndRelease
extern void APIENTRY pwndUnlock(GLGENwindow *pwnd,
                                struct __GLGENcontextRec *gengc);

// Removes and deletes all GLGENwindow structures from the linked list.
// Must *ONLY* be called from process detach (GLUnInitializeProcess).
extern VOID APIENTRY vCleanupWnd(VOID);

// Retrieves layer information for the specified layer of the pwnd.
// Allocates if necessary.
extern GLGENlayerInfo * APIENTRY plyriGet(GLGENwindow *pwnd, HDC hdc, int iLayer);

void APIENTRY WindowIdFromHdc(HDC hdc, GLWINDOWID *pgwid);

//
// Begin/end direct screen access
//
extern BOOL BeginDirectScreenAccess(struct __GLGENcontextRec *gengc,
                                    GLGENwindow *pwnd,
                                    PIXELFORMATDESCRIPTOR *ppfd);
extern VOID EndDirectScreenAccess(GLGENwindow *pwnd);

//
// Debugging support for tracking lock/unlock on a window.
//

#if DBG || defined(TRACK_WINCRIT)
// Don't use ASSERTOPENGL so this can be used on free builds.
#define ASSERT_WINCRIT(pwnd) \
    if ((pwnd)->owningThread != GetCurrentThreadId()) \
    { \
        DbgPrint("Window 0x%08lX owned by 0x%X, not 0x%X\n", \
                 (pwnd), (pwnd)->owningThread, GetCurrentThreadId()); \
        DebugBreak(); \
    }
#define ASSERT_NOT_WINCRIT(pwnd) \
    if ((pwnd)->owningThread == GetCurrentThreadId()) \
    { \
        DbgPrint("Window 0x%08lX already owned by 0x%X\n", \
                 (pwnd), (pwnd)->owningThread); \
        DebugBreak(); \
    }
// Asserts that the current thread can recursively take the given
// wincrit.  For this to be true it must be unowned or owned by
// the same thread.
#define ASSERT_COMPATIBLE_WINCRIT(pwnd) \
    if ((pwnd)->owningThread != 0 && \
        (pwnd)->owningThread != GetCurrentThreadId()) \
    { \
        DbgPrint("Window 0x%08lX owned by 0x%X, not 0x%X\n", \
                 (pwnd), (pwnd)->owningThread, GetCurrentThreadId()); \
        DebugBreak(); \
    }
#else
#define ASSERT_WINCRIT(pwnd)
#define ASSERT_NOT_WINCRIT(pwnd)
#define ASSERT_COMPATIBLE_WINCRIT(pwnd)
#endif

// Use both GC and non-GC forms so it's possible to write macros
// for both cases if we want to in the future.

void ENTER_WINCRIT_GC(GLGENwindow *pwnd, struct __GLGENcontextRec *gengc);
void LEAVE_WINCRIT_GC(GLGENwindow *pwnd, struct __GLGENcontextRec *gengc);

#define ENTER_WINCRIT(pwnd) ENTER_WINCRIT_GC(pwnd, NULL)
#define LEAVE_WINCRIT(pwnd) LEAVE_WINCRIT_GC(pwnd, NULL)

#endif //_GLGENWIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glclt.h ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#ifndef __GLCLT_H__
#define __GLCLT_H__

/* Client Side Prototypes */

/* gl Entry points */

void      APIENTRY glcltNewList                ( IN GLuint list, IN GLenum mode );
void      APIENTRY glcltEndList                ( void );
void      APIENTRY glcltCallList               ( IN GLuint list );
void      APIENTRY glcltCallLists              ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists );
void      APIENTRY glcltDeleteLists            ( IN GLuint list, IN GLsizei range );
GLuint    APIENTRY glcltGenLists               ( IN GLsizei range );
void      APIENTRY glcltListBase               ( IN GLuint base );
void      APIENTRY glcltBegin                  ( IN GLenum mode );
void      APIENTRY glcltBitmap                 ( IN GLsizei width, IN GLsizei height, IN GLfloat xorig, IN GLfloat yorig, IN GLfloat xmove, IN GLfloat ymove, IN const GLubyte bitmap[] );
void      APIENTRY glcltColor3b_InRGBA         ( IN GLbyte red, IN GLbyte green, IN GLbyte blue );
void      APIENTRY glcltColor3bv_InRGBA        ( IN const GLbyte v[3] );
void      APIENTRY glcltColor3d_InRGBA         ( IN GLdouble red, IN GLdouble green, IN GLdouble blue );
void      APIENTRY glcltColor3dv_InRGBA        ( IN const GLdouble v[3] );
void      APIENTRY glcltColor3f_InRGBA         ( IN GLfloat red, IN GLfloat green, IN GLfloat blue );
void      APIENTRY glcltColor3fv_InRGBA        ( IN const GLfloat v[3] );
void      APIENTRY glcltColor3i_InRGBA         ( IN GLint red, IN GLint green, IN GLint blue );
void      APIENTRY glcltColor3iv_InRGBA        ( IN const GLint v[3] );
void      APIENTRY glcltColor3s_InRGBA         ( IN GLshort red, IN GLshort green, IN GLshort blue );
void      APIENTRY glcltColor3sv_InRGBA        ( IN const GLshort v[3] );
void      APIENTRY glcltColor3ub_InRGBA        ( IN GLubyte red, IN GLubyte green, IN GLubyte blue );
void      APIENTRY glcltColor3ubv_InRGBA       ( IN const GLubyte v[3] );
void      APIENTRY glcltColor3ui_InRGBA        ( IN GLuint red, IN GLuint green, IN GLuint blue );
void      APIENTRY glcltColor3uiv_InRGBA       ( IN const GLuint v[3] );
void      APIENTRY glcltColor3us_InRGBA        ( IN GLushort red, IN GLushort green, IN GLushort blue );
void      APIENTRY glcltColor3usv_InRGBA       ( IN const GLushort v[3] );
void      APIENTRY glcltColor4b_InRGBA         ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha );
void      APIENTRY glcltColor4bv_InRGBA        ( IN const GLbyte v[4] );
void      APIENTRY glcltColor4d_InRGBA         ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha );
void      APIENTRY glcltColor4dv_InRGBA        ( IN const GLdouble v[4] );
void      APIENTRY glcltColor4f_InRGBA         ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha );
void      APIENTRY glcltColor4fv_InRGBA        ( IN const GLfloat v[4] );
void      APIENTRY glcltColor4i_InRGBA         ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha );
void      APIENTRY glcltColor4iv_InRGBA        ( IN const GLint v[4] );
void      APIENTRY glcltColor4s_InRGBA         ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha );
void      APIENTRY glcltColor4sv_InRGBA        ( IN const GLshort v[4] );
void      APIENTRY glcltColor4ub_InRGBA        ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha );
void      APIENTRY glcltColor4ubv_InRGBA       ( IN const GLubyte v[4] );
void      APIENTRY glcltColor4ui_InRGBA        ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha );
void      APIENTRY glcltColor4uiv_InRGBA       ( IN const GLuint v[4] );
void      APIENTRY glcltColor4us_InRGBA        ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha );
void      APIENTRY glcltColor4usv_InRGBA       ( IN const GLushort v[4] );
void      APIENTRY glcltColor3b_InCI           ( IN GLbyte red, IN GLbyte green, IN GLbyte blue );
void      APIENTRY glcltColor3bv_InCI          ( IN const GLbyte v[3] );
void      APIENTRY glcltColor3d_InCI           ( IN GLdouble red, IN GLdouble green, IN GLdouble blue );
void      APIENTRY glcltColor3dv_InCI          ( IN const GLdouble v[3] );
void      APIENTRY glcltColor3f_InCI           ( IN GLfloat red, IN GLfloat green, IN GLfloat blue );
void      APIENTRY glcltColor3fv_InCI          ( IN const GLfloat v[3] );
void      APIENTRY glcltColor3i_InCI           ( IN GLint red, IN GLint green, IN GLint blue );
void      APIENTRY glcltColor3iv_InCI          ( IN const GLint v[3] );
void      APIENTRY glcltColor3s_InCI           ( IN GLshort red, IN GLshort green, IN GLshort blue );
void      APIENTRY glcltColor3sv_InCI          ( IN const GLshort v[3] );
void      APIENTRY glcltColor3ub_InCI          ( IN GLubyte red, IN GLubyte green, IN GLubyte blue );
void      APIENTRY glcltColor3ubv_InCI         ( IN const GLubyte v[3] );
void      APIENTRY glcltColor3ui_InCI          ( IN GLuint red, IN GLuint green, IN GLuint blue );
void      APIENTRY glcltColor3uiv_InCI         ( IN const GLuint v[3] );
void      APIENTRY glcltColor3us_InCI          ( IN GLushort red, IN GLushort green, IN GLushort blue );
void      APIENTRY glcltColor3usv_InCI         ( IN const GLushort v[3] );
void      APIENTRY glcltColor4b_InCI           ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha );
void      APIENTRY glcltColor4bv_InCI          ( IN const GLbyte v[4] );
void      APIENTRY glcltColor4d_InCI           ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha );
void      APIENTRY glcltColor4dv_InCI          ( IN const GLdouble v[4] );
void      APIENTRY glcltColor4f_InCI           ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha );
void      APIENTRY glcltColor4fv_InCI          ( IN const GLfloat v[4] );
void      APIENTRY glcltColor4i_InCI           ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha );
void      APIENTRY glcltColor4iv_InCI          ( IN const GLint v[4] );
void      APIENTRY glcltColor4s_InCI           ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha );
void      APIENTRY glcltColor4sv_InCI          ( IN const GLshort v[4] );
void      APIENTRY glcltColor4ub_InCI          ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha );
void      APIENTRY glcltColor4ubv_InCI         ( IN const GLubyte v[4] );
void      APIENTRY glcltColor4ui_InCI          ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha );
void      APIENTRY glcltColor4uiv_InCI         ( IN const GLuint v[4] );
void      APIENTRY glcltColor4us_InCI          ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha );
void      APIENTRY glcltColor4usv_InCI         ( IN const GLushort v[4] );
void      APIENTRY glcltEdgeFlag               ( IN GLboolean flag );
void      APIENTRY glcltEdgeFlagv              ( IN const GLboolean flag[1] );
void      APIENTRY glcltEnd                    ( void );
void      APIENTRY glcltIndexd_InCI            ( IN GLdouble c );
void      APIENTRY glcltIndexdv_InCI           ( IN const GLdouble c[1] );
void      APIENTRY glcltIndexf_InCI            ( IN GLfloat c );
void      APIENTRY glcltIndexfv_InCI           ( IN const GLfloat c[1] );
void      APIENTRY glcltIndexi_InCI            ( IN GLint c );
void      APIENTRY glcltIndexiv_InCI           ( IN const GLint c[1] );
void      APIENTRY glcltIndexs_InCI            ( IN GLshort c );
void      APIENTRY glcltIndexsv_InCI           ( IN const GLshort c[1] );
void      APIENTRY glcltIndexd_InRGBA          ( IN GLdouble c );
void      APIENTRY glcltIndexdv_InRGBA         ( IN const GLdouble c[1] );
void      APIENTRY glcltIndexf_InRGBA          ( IN GLfloat c );
void      APIENTRY glcltIndexfv_InRGBA         ( IN const GLfloat c[1] );
void      APIENTRY glcltIndexi_InRGBA          ( IN GLint c );
void      APIENTRY glcltIndexiv_InRGBA         ( IN const GLint c[1] );
void      APIENTRY glcltIndexs_InRGBA          ( IN GLshort c );
void      APIENTRY glcltIndexsv_InRGBA         ( IN const GLshort c[1] );
void      APIENTRY glcltNormal3b               ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz );
void      APIENTRY glcltNormal3bv              ( IN const GLbyte v[3] );
void      APIENTRY glcltNormal3d               ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz );
void      APIENTRY glcltNormal3dv              ( IN const GLdouble v[3] );
void      APIENTRY glcltNormal3f               ( IN GLfloat nx, IN GLfloat ny, IN GLfloat nz );
void      APIENTRY glcltNormal3fv              ( IN const GLfloat v[3] );
void      APIENTRY glcltNormal3i               ( IN GLint nx, IN GLint ny, IN GLint nz );
void      APIENTRY glcltNormal3iv              ( IN const GLint v[3] );
void      APIENTRY glcltNormal3s               ( IN GLshort nx, IN GLshort ny, IN GLshort nz );
void      APIENTRY glcltNormal3sv              ( IN const GLshort v[3] );
void      APIENTRY glcltRasterPos2d            ( IN GLdouble x, IN GLdouble y );
void      APIENTRY glcltRasterPos2dv           ( IN const GLdouble v[2] );
void      APIENTRY glcltRasterPos2f            ( IN GLfloat x, IN GLfloat y );
void      APIENTRY glcltRasterPos2fv           ( IN const GLfloat v[2] );
void      APIENTRY glcltRasterPos2i            ( IN GLint x, IN GLint y );
void      APIENTRY glcltRasterPos2iv           ( IN const GLint v[2] );
void      APIENTRY glcltRasterPos2s            ( IN GLshort x, IN GLshort y );
void      APIENTRY glcltRasterPos2sv           ( IN const GLshort v[2] );
void      APIENTRY glcltRasterPos3d            ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY glcltRasterPos3dv           ( IN const GLdouble v[3] );
void      APIENTRY glcltRasterPos3f            ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY glcltRasterPos3fv           ( IN const GLfloat v[3] );
void      APIENTRY glcltRasterPos3i            ( IN GLint x, IN GLint y, IN GLint z );
void      APIENTRY glcltRasterPos3iv           ( IN const GLint v[3] );
void      APIENTRY glcltRasterPos3s            ( IN GLshort x, IN GLshort y, IN GLshort z );
void      APIENTRY glcltRasterPos3sv           ( IN const GLshort v[3] );
void      APIENTRY glcltRasterPos4d            ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w );
void      APIENTRY glcltRasterPos4dv           ( IN const GLdouble v[4] );
void      APIENTRY glcltRasterPos4f            ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w );
void      APIENTRY glcltRasterPos4fv           ( IN const GLfloat v[4] );
void      APIENTRY glcltRasterPos4i            ( IN GLint x, IN GLint y, IN GLint z, IN GLint w );
void      APIENTRY glcltRasterPos4iv           ( IN const GLint v[4] );
void      APIENTRY glcltRasterPos4s            ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w );
void      APIENTRY glcltRasterPos4sv           ( IN const GLshort v[4] );
void      APIENTRY glcltRectd                  ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 );
void      APIENTRY glcltRectdv                 ( IN const GLdouble v1[2], IN const GLdouble v2[2] );
void      APIENTRY glcltRectf                  ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 );
void      APIENTRY glcltRectfv                 ( IN const GLfloat v1[2], IN const GLfloat v2[2] );
void      APIENTRY glcltRecti                  ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 );
void      APIENTRY glcltRectiv                 ( IN const GLint v1[2], IN const GLint v2[2] );
void      APIENTRY glcltRects                  ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 );
void      APIENTRY glcltRectsv                 ( IN const GLshort v1[2], IN const GLshort v2[2] );
void      APIENTRY glcltTexCoord1d             ( IN GLdouble s );
void      APIENTRY glcltTexCoord1dv            ( IN const GLdouble v[1] );
void      APIENTRY glcltTexCoord1f             ( IN GLfloat s );
void      APIENTRY glcltTexCoord1fv            ( IN const GLfloat v[1] );
void      APIENTRY glcltTexCoord1i             ( IN GLint s );
void      APIENTRY glcltTexCoord1iv            ( IN const GLint v[1] );
void      APIENTRY glcltTexCoord1s             ( IN GLshort s );
void      APIENTRY glcltTexCoord1sv            ( IN const GLshort v[1] );
void      APIENTRY glcltTexCoord2d             ( IN GLdouble s, IN GLdouble t );
void      APIENTRY glcltTexCoord2dv            ( IN const GLdouble v[2] );
void      APIENTRY glcltTexCoord2f             ( IN GLfloat s, IN GLfloat t );
void      APIENTRY glcltTexCoord2fv            ( IN const GLfloat v[2] );
void      APIENTRY glcltTexCoord2i             ( IN GLint s, IN GLint t );
void      APIENTRY glcltTexCoord2iv            ( IN const GLint v[2] );
void      APIENTRY glcltTexCoord2s             ( IN GLshort s, IN GLshort t );
void      APIENTRY glcltTexCoord2sv            ( IN const GLshort v[2] );
void      APIENTRY glcltTexCoord3d             ( IN GLdouble s, IN GLdouble t, IN GLdouble r );
void      APIENTRY glcltTexCoord3dv            ( IN const GLdouble v[3] );
void      APIENTRY glcltTexCoord3f             ( IN GLfloat s, IN GLfloat t, IN GLfloat r );
void      APIENTRY glcltTexCoord3fv            ( IN const GLfloat v[3] );
void      APIENTRY glcltTexCoord3i             ( IN GLint s, IN GLint t, IN GLint r );
void      APIENTRY glcltTexCoord3iv            ( IN const GLint v[3] );
void      APIENTRY glcltTexCoord3s             ( IN GLshort s, IN GLshort t, IN GLshort r );
void      APIENTRY glcltTexCoord3sv            ( IN const GLshort v[3] );
void      APIENTRY glcltTexCoord4d             ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q );
void      APIENTRY glcltTexCoord4dv            ( IN const GLdouble v[4] );
void      APIENTRY glcltTexCoord4f             ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q );
void      APIENTRY glcltTexCoord4fv            ( IN const GLfloat v[4] );
void      APIENTRY glcltTexCoord4i             ( IN GLint s, IN GLint t, IN GLint r, IN GLint q );
void      APIENTRY glcltTexCoord4iv            ( IN const GLint v[4] );
void      APIENTRY glcltTexCoord4s             ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q );
void      APIENTRY glcltTexCoord4sv            ( IN const GLshort v[4] );
void      APIENTRY glcltVertex2d               ( IN GLdouble x, IN GLdouble y );
void      APIENTRY glcltVertex2dv              ( IN const GLdouble v[2] );
void      APIENTRY glcltVertex2f               ( IN GLfloat x, IN GLfloat y );
void      APIENTRY glcltVertex2fv              ( IN const GLfloat v[2] );
void      APIENTRY glcltVertex2i               ( IN GLint x, IN GLint y );
void      APIENTRY glcltVertex2iv              ( IN const GLint v[2] );
void      APIENTRY glcltVertex2s               ( IN GLshort x, IN GLshort y );
void      APIENTRY glcltVertex2sv              ( IN const GLshort v[2] );
void      APIENTRY glcltVertex3d               ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY glcltVertex3dv              ( IN const GLdouble v[3] );
void      APIENTRY glcltVertex3f               ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY glcltVertex3fv              ( IN const GLfloat v[3] );
void      APIENTRY glcltVertex3i               ( IN GLint x, IN GLint y, IN GLint z );
void      APIENTRY glcltVertex3iv              ( IN const GLint v[3] );
void      APIENTRY glcltVertex3s               ( IN GLshort x, IN GLshort y, IN GLshort z );
void      APIENTRY glcltVertex3sv              ( IN const GLshort v[3] );
void      APIENTRY glcltVertex4d               ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w );
void      APIENTRY glcltVertex4dv              ( IN const GLdouble v[4] );
void      APIENTRY glcltVertex4f               ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w );
void      APIENTRY glcltVertex4fv              ( IN const GLfloat v[4] );
void      APIENTRY glcltVertex4i               ( IN GLint x, IN GLint y, IN GLint z, IN GLint w );
void      APIENTRY glcltVertex4iv              ( IN const GLint v[4] );
void      APIENTRY glcltVertex4s               ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w );
void      APIENTRY glcltVertex4sv              ( IN const GLshort v[4] );
void      APIENTRY glcltClipPlane              ( IN GLenum plane, IN const GLdouble equation[4] );
void      APIENTRY glcltColorMaterial          ( IN GLenum face, IN GLenum mode );
void      APIENTRY glcltCullFace               ( IN GLenum mode );
void      APIENTRY glcltFogf                   ( IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltFogfv                  ( IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltFogi                   ( IN GLenum pname, IN GLint param );
void      APIENTRY glcltFogiv                  ( IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltFrontFace              ( IN GLenum mode );
void      APIENTRY glcltHint                   ( IN GLenum target, IN GLenum mode );
void      APIENTRY glcltLightf                 ( IN GLenum light, IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltLightfv                ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltLighti                 ( IN GLenum light, IN GLenum pname, IN GLint param );
void      APIENTRY glcltLightiv                ( IN GLenum light, IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltLightModelf            ( IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltLightModelfv           ( IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltLightModeli            ( IN GLenum pname, IN GLint param );
void      APIENTRY glcltLightModeliv           ( IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltLineStipple            ( IN GLint factor, IN GLushort pattern );
void      APIENTRY glcltLineWidth              ( IN GLfloat width );
void      APIENTRY glcltMaterialf              ( IN GLenum face, IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltMaterialfv             ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltMateriali              ( IN GLenum face, IN GLenum pname, IN GLint param );
void      APIENTRY glcltMaterialiv             ( IN GLenum face, IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltPointSize              ( IN GLfloat size );
void      APIENTRY glcltPolygonMode            ( IN GLenum face, IN GLenum mode );
void      APIENTRY glcltPolygonStipple         ( IN const GLubyte mask[] );
void      APIENTRY glcltScissor                ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height );
void      APIENTRY glcltShadeModel             ( IN GLenum mode );
void      APIENTRY glcltTexParameterf          ( IN GLenum target, IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltTexParameterfv         ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltTexParameteri          ( IN GLenum target, IN GLenum pname, IN GLint param );
void      APIENTRY glcltTexParameteriv         ( IN GLenum target, IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltTexImage1D             ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY glcltTexImage2D             ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLsizei height, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY glcltTexEnvf                ( IN GLenum target, IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltTexEnvfv               ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltTexEnvi                ( IN GLenum target, IN GLenum pname, IN GLint param );
void      APIENTRY glcltTexEnviv               ( IN GLenum target, IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltTexGend                ( IN GLenum coord, IN GLenum pname, IN GLdouble param );
void      APIENTRY glcltTexGendv               ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] );
void      APIENTRY glcltTexGenf                ( IN GLenum coord, IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltTexGenfv               ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY glcltTexGeni                ( IN GLenum coord, IN GLenum pname, IN GLint param );
void      APIENTRY glcltTexGeniv               ( IN GLenum coord, IN GLenum pname, IN const GLint params[] );
void      APIENTRY glcltFeedbackBuffer         ( IN GLsizei size, IN GLenum type, OUT GLfloat buffer[] );
void      APIENTRY glcltSelectBuffer           ( IN GLsizei size, OUT GLuint buffer[] );
GLint     APIENTRY glcltRenderMode             ( IN GLenum mode );
void      APIENTRY glcltInitNames              ( void );
void      APIENTRY glcltLoadName               ( IN GLuint name );
void      APIENTRY glcltPassThrough            ( IN GLfloat token );
void      APIENTRY glcltPopName                ( void );
void      APIENTRY glcltPushName               ( IN GLuint name );
void      APIENTRY glcltDrawBuffer             ( IN GLenum mode );
void      APIENTRY glcltClear                  ( IN GLbitfield mask );
void      APIENTRY glcltClearAccum             ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha );
void      APIENTRY glcltClearIndex             ( IN GLfloat c );
void      APIENTRY glcltClearColor             ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha );
void      APIENTRY glcltClearStencil           ( IN GLint s );
void      APIENTRY glcltClearDepth             ( IN GLclampd depth );
void      APIENTRY glcltStencilMask            ( IN GLuint mask );
void      APIENTRY glcltColorMask              ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha );
void      APIENTRY glcltDepthMask              ( IN GLboolean flag );
void      APIENTRY glcltIndexMask              ( IN GLuint mask );
void      APIENTRY glcltAccum                  ( IN GLenum op, IN GLfloat value );
void      APIENTRY glcltDisable                ( IN GLenum cap );
void      APIENTRY glcltEnable                 ( IN GLenum cap );
void      APIENTRY glcltFinish                 ( void );
void      APIENTRY glcltFlush                  ( void );
void      APIENTRY glcltPopAttrib              ( void );
void      APIENTRY glcltPushAttrib             ( IN GLbitfield mask );
void      APIENTRY glcltMap1d                  ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] );
void      APIENTRY glcltMap1f                  ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] );
void      APIENTRY glcltMap2d                  ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] );
void      APIENTRY glcltMap2f                  ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] );
void      APIENTRY glcltMapGrid1d              ( IN GLint un, IN GLdouble u1, IN GLdouble u2 );
void      APIENTRY glcltMapGrid1f              ( IN GLint un, IN GLfloat u1, IN GLfloat u2 );
void      APIENTRY glcltMapGrid2d              ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 );
void      APIENTRY glcltMapGrid2f              ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 );
void      APIENTRY glcltEvalCoord1d            ( IN GLdouble u );
void      APIENTRY glcltEvalCoord1dv           ( IN const GLdouble u[1] );
void      APIENTRY glcltEvalCoord1f            ( IN GLfloat u );
void      APIENTRY glcltEvalCoord1fv           ( IN const GLfloat u[1] );
void      APIENTRY glcltEvalCoord2d            ( IN GLdouble u, IN GLdouble v );
void      APIENTRY glcltEvalCoord2dv           ( IN const GLdouble u[2] );
void      APIENTRY glcltEvalCoord2f            ( IN GLfloat u, IN GLfloat v );
void      APIENTRY glcltEvalCoord2fv           ( IN const GLfloat u[2] );
void      APIENTRY glcltEvalMesh1              ( IN GLenum mode, IN GLint i1, IN GLint i2 );
void      APIENTRY glcltEvalPoint1             ( IN GLint i );
void      APIENTRY glcltEvalMesh2              ( IN GLenum mode, IN GLint i1, IN GLint i2, IN GLint j1, IN GLint j2 );
void      APIENTRY glcltEvalPoint2             ( IN GLint i, IN GLint j );
void      APIENTRY glcltAlphaFunc              ( IN GLenum func, IN GLclampf ref );
void      APIENTRY glcltBlendFunc              ( IN GLenum sfactor, IN GLenum dfactor );
void      APIENTRY glcltLogicOp                ( IN GLenum opcode );
void      APIENTRY glcltStencilFunc            ( IN GLenum func, IN GLint ref, IN GLuint mask );
void      APIENTRY glcltStencilOp              ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass );
void      APIENTRY glcltDepthFunc              ( IN GLenum func );
void      APIENTRY glcltPixelZoom              ( IN GLfloat xfactor, IN GLfloat yfactor );
void      APIENTRY glcltPixelTransferf         ( IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltPixelTransferi         ( IN GLenum pname, IN GLint param );
void      APIENTRY glcltPixelStoref            ( IN GLenum pname, IN GLfloat param );
void      APIENTRY glcltPixelStorei            ( IN GLenum pname, IN GLint param );
void      APIENTRY glcltPixelMapfv             ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] );
void      APIENTRY glcltPixelMapuiv            ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] );
void      APIENTRY glcltPixelMapusv            ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] );
void      APIENTRY glcltReadBuffer             ( IN GLenum mode );
void      APIENTRY glcltCopyPixels             ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type );
void      APIENTRY glcltReadPixels             ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, OUT GLvoid *pixels );
void      APIENTRY glcltDrawPixels             ( IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY glcltGetBooleanv            ( IN GLenum pname, OUT GLboolean params[] );
void      APIENTRY glcltGetClipPlane           ( IN GLenum plane, OUT GLdouble equation[4] );
void      APIENTRY glcltGetDoublev             ( IN GLenum pname, OUT GLdouble params[] );
GLenum    APIENTRY glcltGetError               ( void );
void      APIENTRY glcltGetFloatv              ( IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetIntegerv            ( IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetLightfv             ( IN GLenum light, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetLightiv             ( IN GLenum light, IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetMapdv               ( IN GLenum target, IN GLenum query, OUT GLdouble v[] );
void      APIENTRY glcltGetMapfv               ( IN GLenum target, IN GLenum query, OUT GLfloat v[] );
void      APIENTRY glcltGetMapiv               ( IN GLenum target, IN GLenum query, OUT GLint v[] );
void      APIENTRY glcltGetMaterialfv          ( IN GLenum face, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetMaterialiv          ( IN GLenum face, IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetPixelMapfv          ( IN GLenum map, OUT GLfloat values[] );
void      APIENTRY glcltGetPixelMapuiv         ( IN GLenum map, OUT GLuint values[] );
void      APIENTRY glcltGetPixelMapusv         ( IN GLenum map, OUT GLushort values[] );
void      APIENTRY glcltGetPolygonStipple      ( OUT GLubyte mask[] );
const GLubyte * APIENTRY glcltGetString        ( IN GLenum name );
void      APIENTRY glcltGetTexEnvfv            ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetTexEnviv            ( IN GLenum target, IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetTexGendv            ( IN GLenum coord, IN GLenum pname, OUT GLdouble params[] );
void      APIENTRY glcltGetTexGenfv            ( IN GLenum coord, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetTexGeniv            ( IN GLenum coord, IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetTexImage            ( IN GLenum target, IN GLint level, IN GLenum format, IN GLenum type, OUT GLvoid *pixels );
void      APIENTRY glcltGetTexParameterfv      ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetTexParameteriv      ( IN GLenum target, IN GLenum pname, OUT GLint params[] );
void      APIENTRY glcltGetTexLevelParameterfv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY glcltGetTexLevelParameteriv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLint params[] );
GLboolean APIENTRY glcltIsEnabled              ( IN GLenum cap );
GLboolean APIENTRY glcltIsList                 ( IN GLuint list );
void      APIENTRY glcltDepthRange             ( IN GLclampd zNear, IN GLclampd zFar );
void      APIENTRY glcltFrustum                ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar );
void      APIENTRY glcltLoadIdentity           ( void );
void      APIENTRY glcltLoadMatrixf            ( IN const GLfloat m[16] );
void      APIENTRY glcltLoadMatrixd            ( IN const GLdouble m[16] );
void      APIENTRY glcltMatrixMode             ( IN GLenum mode );
void      APIENTRY glcltMultMatrixf            ( IN const GLfloat m[16] );
void      APIENTRY glcltMultMatrixd            ( IN const GLdouble m[16] );
void      APIENTRY glcltOrtho                  ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar );
void      APIENTRY glcltPopMatrix              ( void );
void      APIENTRY glcltPushMatrix             ( void );
void      APIENTRY glcltRotated                ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY glcltRotatef                ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY glcltScaled                 ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY glcltScalef                 ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY glcltTranslated             ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY glcltTranslatef             ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY glcltViewport               ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height );
void      APIENTRY glcltAddSwapHintRectWIN     ( IN GLint x, IN GLint y, IN GLint width, IN GLint height );
void      APIENTRY glsimVertexPointerEXT       ( IN GLint size, IN GLenum type, IN GLsizei stride, IN GLsizei count, IN const GLvoid* pointer);
void      APIENTRY glsimColorPointerEXT        ( IN GLint size, IN GLenum type, IN GLsizei stride, IN GLsizei count, IN const GLvoid* pointer);
void      APIENTRY glsimTexCoordPointerEXT     ( IN GLint size, IN GLenum type, IN GLsizei stride, IN GLsizei count, IN const GLvoid* pointer);
void      APIENTRY glsimNormalPointerEXT       ( IN GLenum type, IN GLsizei stride, IN GLsizei count, IN const GLvoid* pointer);
void      APIENTRY glsimIndexPointerEXT        ( IN GLenum type, IN GLsizei stride, IN GLsizei count, IN const GLvoid* pointer);
void      APIENTRY glsimEdgeFlagPointerEXT     ( IN GLsizei stride, IN GLsizei count, IN const GLboolean* pointer);
void      APIENTRY glsimArrayElementEXT        ( IN GLint i );
void      APIENTRY glsimArrayElementArrayEXT      ( IN GLenum mode, IN GLsizei count, IN const GLvoid* pi);
void      APIENTRY glsimDrawArraysEXT          ( IN GLenum mode, IN GLint first, IN GLsizei count);
void      APIENTRY glsimGetPointervEXT         ( IN GLenum pname, OUT void** params);
void      APIENTRY glcltArrayElement           (GLint i);
void      APIENTRY glcltColorPointer           (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltDisableClientState     (GLenum array);
void      APIENTRY glcltDrawArrays             (GLenum mode, GLint first, GLsizei count);
void      APIENTRY glcltDrawElements           (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
void      APIENTRY glcltDrawRangeElementsWIN   (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
void      APIENTRY glcltEdgeFlagPointer        (GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltEnableClientState      (GLenum array);
void      APIENTRY glcltIndexub_InRGBA         (GLubyte c);
void      APIENTRY glcltIndexubv_InRGBA        (const GLubyte *c);
void      APIENTRY glcltIndexub_InCI           (GLubyte c);
void      APIENTRY glcltIndexubv_InCI          (const GLubyte *c);
void      APIENTRY glcltIndexPointer           (GLenum type, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltInterleavedArrays      (GLenum format, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltNormalPointer          (GLenum type, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltPolygonOffset          (GLfloat factor, GLfloat units);
void      APIENTRY glcltTexCoordPointer        (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltVertexPointer          (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
void      APIENTRY glcltGetPointerv            (GLenum pname, GLvoid* *params);
void      APIENTRY glcltPopClientAttrib        (void);
void      APIENTRY glcltPushClientAttrib       (IN GLbitfield mask);
GLboolean APIENTRY glcltAreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences);
void APIENTRY glcltBindTexture(GLenum target, GLuint texture);
void APIENTRY glcltCopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border);
void APIENTRY glcltCopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border);
void APIENTRY glcltCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width);
void APIENTRY glcltCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height);
void APIENTRY glcltDeleteTextures(GLsizei n, const GLuint *textures);
void APIENTRY glcltGenTextures(GLsizei n, GLuint *textures);
GLboolean APIENTRY glcltIsTexture(GLuint texture);
void APIENTRY glcltPrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities);
void APIENTRY glcltTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels);
void APIENTRY glcltTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels);

void APIENTRY glcltColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data);
void APIENTRY glcltColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
void APIENTRY glcltGetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data);
void APIENTRY glcltGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params);
void APIENTRY glcltGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params);

#ifdef GL_WIN_multiple_textures
void APIENTRY glcltCurrentTextureIndexWIN
    (GLuint index);
void APIENTRY glcltMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s);
void APIENTRY glcltMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glcltMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s);
void APIENTRY glcltMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glcltMultiTexCoord1iWIN
    (GLbitfield mask, GLint s);
void APIENTRY glcltMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glcltMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s);
void APIENTRY glcltMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glcltMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t);
void APIENTRY glcltMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glcltMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t);
void APIENTRY glcltMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glcltMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t);
void APIENTRY glcltMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glcltMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t);
void APIENTRY glcltMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glcltMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r);
void APIENTRY glcltMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glcltMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r);
void APIENTRY glcltMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glcltMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r);
void APIENTRY glcltMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glcltMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r);
void APIENTRY glcltMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glcltMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
void APIENTRY glcltMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glcltMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
void APIENTRY glcltMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glcltMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q);
void APIENTRY glcltMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glcltMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q);
void APIENTRY glcltMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glcltBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture);
void APIENTRY glcltNthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures

#endif /* __GLCLT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glmf.h ===
#if !defined(__gls_h_)
#define __gls_h_

/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define GLS_LINKAGE APIENTRY

#include <windef.h>
#include <wingdi.h>
#include <GL/gl.h>
#include <stddef.h>
#include <stdio.h>

#if defined(__cplusplus)
    extern "C" {
#endif /* defined(__cplusplus) */

typedef __int64 GLlong;
typedef unsigned __int64 GLulong;

typedef GLuint GLSenum;
typedef GLuint GLSopcode;

typedef struct {
    GLuint mask;
    GLuint value;
} GLScommandAlignment;

typedef void (GLS_LINKAGE *GLScaptureFunc)(GLSopcode inOpcode);
typedef size_t (GLS_LINKAGE *GLSreadFunc)(size_t inCount, GLubyte *outBuf);
typedef size_t (GLS_LINKAGE *GLSwriteFunc)(size_t inCount, const GLubyte *inBuf);

#if defined(__cplusplus)
    typedef void (GLS_LINKAGE *GLSfunc)(...);
#else /* !defined(__cplusplus) */
    typedef void (GLS_LINKAGE *GLSfunc)();
#endif /* defined(__cplusplus) */

#define glsCSTR(p) ((const GLubyte*)(p))
#define glsSTR(p)  ((GLubyte*)(p))

/*************************************************************/

/* CaptureFlags */
/*      GLS_NONE */
#define GLS_CAPTURE_EXECUTE_BIT                   0x00000001
#define GLS_CAPTURE_WRITE_BIT                     0x00000002

/* CommandAttrib */
/*      GLS_NONE */
#define GLS_COMMAND_GEN_BIT                       0x00000001
#define GLS_COMMAND_GET_BIT                       0x00000002
#define GLS_COMMAND_REPLY_BIT                     0x00000004

/* ImageFlags */
/*      GLS_NONE */
#define GLS_IMAGE_NULL_BIT                        0x00000001

/* StreamAttrib */
/*      GLS_NONE */
#define GLS_STREAM_CONTEXT_BIT                    0x00000001
#define GLS_STREAM_NAMED_BIT                      0x00000002
#define GLS_STREAM_READABLE_BIT                   0x00000004
#define GLS_STREAM_SEEKABLE_BIT                   0x00000008
#define GLS_STREAM_WRITABLE_BIT                   0x00000010

/* WriteFlags */
/*      GLS_NONE */
#define GLS_WRITE_APPEND_BIT                      0x00000001

/* Fundamental */
#define GLS_NONE                                  0x0000

/* AbortMode */
/*      GLS_NONE */
#define GLS_ALL                                   0x0010
#define GLS_LAST                                  0x0011

/* API */
#define GLS_API_GLS                               0x0020
#define GLS_API_GL                                0x0021

/* BlockType */
#define GLS_FRAME                                 0x0030
#define GLS_HEADER                                0x0031
#define GLS_INIT                                  0x0032
#define GLS_STATIC                                0x0033

/* CaptureFuncTarget */
#define GLS_CAPTURE_ENTRY_FUNC                    0x0040
#define GLS_CAPTURE_EXIT_FUNC                     0x0041

/* CaptureStreamType */
#define GLS_CONTEXT                               0x0050
#define GLS_BINARY_LSB_FIRST                      0x0051
#define GLS_BINARY_MSB_FIRST                      0x0052
#define GLS_TEXT                                  0x0053

/* ChannelTarget */
#define GLS_DEFAULT_READ_CHANNEL                  0x0060
#define GLS_DEFAULT_WRITE_CHANNEL                 0x0061

/* Consti */
#define GLS_API_COUNT                             0x0070
#define GLS_MAX_CALL_NESTING                      0x0071
#define GLS_MAX_CAPTURE_NESTING                   0x0072
#define GLS_VERSION_MAJOR                         0x0073
#define GLS_VERSION_MINOR                         0x0074

/* Constiv */
#define GLS_ALL_APIS                              0x0080

/* Constubz */
#define GLS_EXTENSIONS                            0x0090
#define GLS_PLATFORM                              0x0091
#define GLS_RELEASE                               0x0092
#define GLS_VENDOR                                0x0093

/* ContextFunc */
/*      GLS_CAPTURE_ENTRY_FUNC */
/*      GLS_CAPTURE_EXIT_FUNC */
#define GLS_READ_FUNC                             0x00A1
#define GLS_UNREAD_FUNC                           0x00A2
#define GLS_WRITE_FUNC                            0x00A3

/* ContextListl */
#define GLS_OUT_ARG_LIST                          0x00B0

/* ContextListubz */
#define GLS_CONTEXT_STREAM_LIST                   0x00C0
#define GLS_READ_PREFIX_LIST                      0x00C1

/* ContextPointer */
/*      GLS_DEFAULT_READ_CHANNEL */
/*      GLS_DEFAULT_WRITE_CHANNEL */
#define GLS_DATA_POINTER                          0x00E0

/* Contexti */
#define GLS_ABORT_MODE                            0x00E0
#define GLS_BLOCK_TYPE                            0x00E1
#define GLS_CALL_NESTING                          0x00E2
#define GLS_CAPTURE_NESTING                       0x00E3
#define GLS_CONTEXT_STREAM_COUNT                  0x00E4
#define GLS_CURRENT_GLRC                          0x00E5
#define GLS_OUT_ARG_COUNT                         0x00E6
#define GLS_PIXEL_SETUP_GEN                       0x00E7
#define GLS_READ_PREFIX_COUNT                     0x00E8
#define GLS_STREAM_VERSION_MAJOR                  0x00E9
#define GLS_STREAM_VERSION_MINOR                  0x00EA

/* Contextubz */
#define GLS_WRITE_PREFIX                          0x0100

/* CopyStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* DisplayFormat */
#define GLS_IIII                                  0x0110
#define GLS_RGBA                                  0x0111
#define GLS_RRRA                                  0x0112

/* DisplayMap */
#define GLS_DISPLAY_MAP_I_TO_R                    0x0120
#define GLS_DISPLAY_MAP_I_TO_G                    0x0121
#define GLS_DISPLAY_MAP_I_TO_B                    0x0122
#define GLS_DISPLAY_MAP_I_TO_A                    0x0123

/* ErrorCode */
/*      GLS_NONE */
#define GLS_CALL_OVERFLOW                         0x0130
#define GLS_DECODE_ERROR                          0x0131
#define GLS_ENCODE_ERROR                          0x0132
#define GLS_INVALID_ENUM                          0x0133
#define GLS_INVALID_OPERATION                     0x0134
#define GLS_INVALID_STREAM                        0x0135
#define GLS_INVALID_STRING                        0x0136
#define GLS_INVALID_VALUE                         0x0137
#define GLS_NOT_FOUND                             0x0138
#define GLS_OUT_OF_MEMORY                         0x0139
#define GLS_STREAM_CLOSE_ERROR                    0x013A
#define GLS_STREAM_DELETE_ERROR                   0x013B
#define GLS_STREAM_OPEN_ERROR                     0x013C
#define GLS_STREAM_READ_ERROR                     0x013D
#define GLS_STREAM_WRITE_ERROR                    0x013E
#define GLS_UNSUPPORTED_COMMAND                   0x013F
#define GLS_UNSUPPORTED_EXTENSION                 0x0140

/* ExternStreamType */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */

/* FlushType */
/*      GLS_ALL */
/*      GLS_LAST */

/* GetStreamType */
/*      GLS_NONE */
/*      GLS_CONTEXT */
/*      GLS_BINARY_LSB_FIRST */
/*      GLS_BINARY_MSB_FIRST */
/*      GLS_TEXT */
#define GLS_UNKNOWN                               0x0150

/* GLRCi */
#define GLS_LAYER                                 0x0160
#define GLS_READ_LAYER                            0x0161
#define GLS_SHARE_GLRC                            0x0162

/* Headerf */
#define GLS_ASPECT                                0x0170
#define GLS_BORDER_WIDTH                          0x0171
#define GLS_CONTRAST_RATIO                        0x0172
#define GLS_HEIGHT_MM                             0x0173

/* Headerfv */
#define GLS_BORDER_COLOR                          0x0180
#define GLS_GAMMA                                 0x0181
#define GLS_ORIGIN                                0x0182
#define GLS_PAGE_COLOR                            0x0183
#define GLS_PAGE_SIZE                             0x0184
#define GLS_RED_POINT                             0x0185
#define GLS_GREEN_POINT                           0x0186
#define GLS_BLUE_POINT                            0x0187
#define GLS_WHITE_POINT                           0x0188

/* Headeri */
#define GLS_FRAME_COUNT                           0x01A0
#define GLS_GLRC_COUNT                            0x01A1
#define GLS_HEIGHT_PIXELS                         0x01A2
#define GLS_LAYER_COUNT                           0x01A3
#define GLS_TILEABLE                              0x01A4

/* Headeriv */
#define GLS_CREATE_TIME                           0x01B0
#define GLS_MODIFY_TIME                           0x01B1

/* Headerubz */
/*      GLS_EXTENSIONS */
#define GLS_AUTHOR                                0x01C0
#define GLS_DESCRIPTION                           0x01C1
#define GLS_NOTES                                 0x01C2
#define GLS_TITLE                                 0x01C3
#define GLS_TOOLS                                 0x01C4
#define GLS_VERSION                               0x01C5

/* Layerf */
#define GLS_INVISIBLE_ASPECT                      0x01D0

/* Layeri */
#define GLS_DISPLAY_FORMAT                        0x01E0
#define GLS_DOUBLEBUFFER                          0x01E1
#define GLS_INVISIBLE                             0x01E2
#define GLS_INVISIBLE_HEIGHT_PIXELS               0x01E3
#define GLS_LEVEL                                 0x01E4
#define GLS_STEREO                                0x01E5
#define GLS_TRANSPARENT                           0x01E6
#define GLS_INDEX_BITS                            0x01E7
#define GLS_RED_BITS                              0x01E8
#define GLS_GREEN_BITS                            0x01E9
#define GLS_BLUE_BITS                             0x01EA
#define GLS_ALPHA_BITS                            0x01EB
#define GLS_DEPTH_BITS                            0x01EC
#define GLS_STENCIL_BITS                          0x01ED
#define GLS_ACCUM_RED_BITS                        0x01EE
#define GLS_ACCUM_GREEN_BITS                      0x01EF
#define GLS_ACCUM_BLUE_BITS                       0x01F0
#define GLS_ACCUM_ALPHA_BITS                      0x01F1
#define GLS_AUX_BUFFERS                           0x01F2
/*      GLS_SAMPLE_BUFFERS_SGIS */
/*      GLS_SAMPLES_SGIS */

/* ListOp */
#define GLS_APPEND                                0x0200
#define GLS_PREPEND                               0x0201

/* GL_SGIS_multisample */
#define GLS_SAMPLE_BUFFERS_SGIS                   0x0400
#define GLS_SAMPLES_SGIS                          0x0401

/* GLS opcodes */
#define GLS_OP_glsBeginGLS                        16
#define GLS_OP_glsBlock                           17
#define GLS_OP_glsCallStream                      18
#define GLS_OP_glsEndGLS                          19
#define GLS_OP_glsError                           20
#define GLS_OP_glsGLRC                            21
#define GLS_OP_glsGLRCLayer                       22
#define GLS_OP_glsHeaderGLRCi                     23
#define GLS_OP_glsHeaderLayerf                    24
#define GLS_OP_glsHeaderLayeri                    25
#define GLS_OP_glsHeaderf                         26
#define GLS_OP_glsHeaderfv                        27
#define GLS_OP_glsHeaderi                         28
#define GLS_OP_glsHeaderiv                        29
#define GLS_OP_glsHeaderubz                       30
#define GLS_OP_glsRequireExtension                31
#define GLS_OP_glsUnsupportedCommand              32
#define GLS_OP_glsAppRef                          33
#define GLS_OP_glsBeginObj                        34
#define GLS_OP_glsCharubz                         35
#define GLS_OP_glsComment                         36
#define GLS_OP_glsDisplayMapfv                    37
#define GLS_OP_glsEndObj                          38
#define GLS_OP_glsNumb                            39
#define GLS_OP_glsNumbv                           40
#define GLS_OP_glsNumd                            41
#define GLS_OP_glsNumdv                           42
#define GLS_OP_glsNumf                            43
#define GLS_OP_glsNumfv                           44
#define GLS_OP_glsNumi                            45
#define GLS_OP_glsNumiv                           46
#define GLS_OP_glsNuml                            47
#define GLS_OP_glsNumlv                           48
#define GLS_OP_glsNums                            49
#define GLS_OP_glsNumsv                           50
#define GLS_OP_glsNumub                           51
#define GLS_OP_glsNumubv                          52
#define GLS_OP_glsNumui                           53
#define GLS_OP_glsNumuiv                          54
#define GLS_OP_glsNumul                           55
#define GLS_OP_glsNumulv                          56
#define GLS_OP_glsNumus                           57
#define GLS_OP_glsNumusv                          58
#define GLS_OP_glsPad                             59
#define GLS_OP_glsSwapBuffers                     60

/* GL opcodes */
#define GLS_OP_glAccum                            277
#define GLS_OP_glAlphaFunc                        304
#define GLS_OP_glAreTexturesResidentEXT           65502
#define GLS_OP_glArrayElementEXT                  65493
#define GLS_OP_glBegin                            71
#define GLS_OP_glBindTextureEXT                   65503
#define GLS_OP_glBitmap                           72
#define GLS_OP_glBlendColorEXT                    65520
#define GLS_OP_glBlendEquationEXT                 65521
#define GLS_OP_glBlendFunc                        305
#define GLS_OP_glCallList                         66
#define GLS_OP_glCallLists                        67
#define GLS_OP_glClear                            267
#define GLS_OP_glClearAccum                       268
#define GLS_OP_glClearColor                       270
#define GLS_OP_glClearDepth                       272
#define GLS_OP_glClearIndex                       269
#define GLS_OP_glClearStencil                     271
#define GLS_OP_glClipPlane                        214
#define GLS_OP_glColor3b                          73
#define GLS_OP_glColor3bv                         74
#define GLS_OP_glColor3d                          75
#define GLS_OP_glColor3dv                         76
#define GLS_OP_glColor3f                          77
#define GLS_OP_glColor3fv                         78
#define GLS_OP_glColor3i                          79
#define GLS_OP_glColor3iv                         80
#define GLS_OP_glColor3s                          81
#define GLS_OP_glColor3sv                         82
#define GLS_OP_glColor3ub                         83
#define GLS_OP_glColor3ubv                        84
#define GLS_OP_glColor3ui                         85
#define GLS_OP_glColor3uiv                        86
#define GLS_OP_glColor3us                         87
#define GLS_OP_glColor3usv                        88
#define GLS_OP_glColor4b                          89
#define GLS_OP_glColor4bv                         90
#define GLS_OP_glColor4d                          91
#define GLS_OP_glColor4dv                         92
#define GLS_OP_glColor4f                          93
#define GLS_OP_glColor4fv                         94
#define GLS_OP_glColor4i                          95
#define GLS_OP_glColor4iv                         96
#define GLS_OP_glColor4s                          97
#define GLS_OP_glColor4sv                         98
#define GLS_OP_glColor4ub                         99
#define GLS_OP_glColor4ubv                        100
#define GLS_OP_glColor4ui                         101
#define GLS_OP_glColor4uiv                        102
#define GLS_OP_glColor4us                         103
#define GLS_OP_glColor4usv                        104
#define GLS_OP_glColorMask                        274
#define GLS_OP_glColorMaterial                    215
#define GLS_OP_glColorPointerEXT                  65494
#define GLS_OP_glColorSubTableEXT                 65424
#define GLS_OP_glDrawRangeElementsWIN             65425
#define GLS_OP_glColorTableParameterfvSGI         65477
#define GLS_OP_glColorTableParameterivSGI         65478
#define GLS_OP_glColorTableEXT                    65476
#define GLS_OP_glConvolutionFilter1DEXT           65528
#define GLS_OP_glConvolutionFilter2DEXT           65529
#define GLS_OP_glConvolutionParameterfEXT         65530
#define GLS_OP_glConvolutionParameterfvEXT        65531
#define GLS_OP_glConvolutionParameteriEXT         65532
#define GLS_OP_glConvolutionParameterivEXT        65533
#define GLS_OP_glCopyColorTableSGI                65479
#define GLS_OP_glCopyConvolutionFilter1DEXT       65534
#define GLS_OP_glCopyConvolutionFilter2DEXT       65535
#define GLS_OP_glCopyPixels                       319
#define GLS_OP_glCopyTexImage1DEXT                65487
#define GLS_OP_glCopyTexImage2DEXT                65456
#define GLS_OP_glCopyTexSubImage1DEXT             65457
#define GLS_OP_glCopyTexSubImage2DEXT             65458
#define GLS_OP_glCopyTexSubImage3DEXT             65459
#define GLS_OP_glCullFace                         216
#define GLS_OP_glDeleteLists                      68
#define GLS_OP_glDeleteTexturesEXT                65472
#define GLS_OP_glDepthFunc                        309
#define GLS_OP_glDepthMask                        275
#define GLS_OP_glDepthRange                       352
#define GLS_OP_glDetailTexFuncSGIS                65489
#define GLS_OP_glDisable                          278
#define GLS_OP_glDrawArraysEXT                    65495
#define GLS_OP_glDrawBuffer                       266
#define GLS_OP_glDrawPixels                       321
#define GLS_OP_glEdgeFlag                         105
#define GLS_OP_glEdgeFlagPointerEXT               65496
#define GLS_OP_glEdgeFlagv                        106
#define GLS_OP_glEnable                           279
#define GLS_OP_glEnd                              107
#define GLS_OP_glEndList                          65
#define GLS_OP_glEvalCoord1d                      292
#define GLS_OP_glEvalCoord1dv                     293
#define GLS_OP_glEvalCoord1f                      294
#define GLS_OP_glEvalCoord1fv                     295
#define GLS_OP_glEvalCoord2d                      296
#define GLS_OP_glEvalCoord2dv                     297
#define GLS_OP_glEvalCoord2f                      298
#define GLS_OP_glEvalCoord2fv                     299
#define GLS_OP_glEvalMesh1                        300
#define GLS_OP_glEvalMesh2                        302
#define GLS_OP_glEvalPoint1                       301
#define GLS_OP_glEvalPoint2                       303
#define GLS_OP_glFeedbackBuffer                   258
#define GLS_OP_glFinish                           280
#define GLS_OP_glFlush                            281
#define GLS_OP_glFogf                             217
#define GLS_OP_glFogfv                            218
#define GLS_OP_glFogi                             219
#define GLS_OP_glFogiv                            220
#define GLS_OP_glFrontFace                        221
#define GLS_OP_glFrustum                          353
#define GLS_OP_glGenLists                         69
#define GLS_OP_glGenTexturesEXT                   65473
#define GLS_OP_glGetBooleanv                      322
#define GLS_OP_glGetClipPlane                     323
#define GLS_OP_glGetColorTableParameterfvEXT      65481
#define GLS_OP_glGetColorTableParameterivEXT      65482
#define GLS_OP_glGetColorTableEXT                 65480
#define GLS_OP_glGetConvolutionFilterEXT          65504
#define GLS_OP_glGetConvolutionParameterfvEXT     65505
#define GLS_OP_glGetConvolutionParameterivEXT     65506
#define GLS_OP_glGetDetailTexFuncSGIS             65490
#define GLS_OP_glGetDoublev                       324
#define GLS_OP_glGetError                         325
#define GLS_OP_glGetFloatv                        326
#define GLS_OP_glGetHistogramEXT                  65509
#define GLS_OP_glGetHistogramParameterfvEXT       65510
#define GLS_OP_glGetHistogramParameterivEXT       65511
#define GLS_OP_glGetIntegerv                      327
#define GLS_OP_glGetLightfv                       328
#define GLS_OP_glGetLightiv                       329
#define GLS_OP_glGetMapdv                         330
#define GLS_OP_glGetMapfv                         331
#define GLS_OP_glGetMapiv                         332
#define GLS_OP_glGetMaterialfv                    333
#define GLS_OP_glGetMaterialiv                    334
#define GLS_OP_glGetMinmaxEXT                     65512
#define GLS_OP_glGetMinmaxParameterfvEXT          65513
#define GLS_OP_glGetMinmaxParameterivEXT          65514
#define GLS_OP_glGetPixelMapfv                    335
#define GLS_OP_glGetPixelMapuiv                   336
#define GLS_OP_glGetPixelMapusv                   337
#define GLS_OP_glGetPointervEXT                   65497
#define GLS_OP_glGetPolygonStipple                338
#define GLS_OP_glGetSeparableFilterEXT            65507
#define GLS_OP_glGetSharpenTexFuncSGIS            65492
#define GLS_OP_glGetString                        339
#define GLS_OP_glGetTexColorTableParameterfvSGI   65483
#define GLS_OP_glGetTexColorTableParameterivSGI   65484
#define GLS_OP_glGetTexEnvfv                      340
#define GLS_OP_glGetTexEnviv                      341
#define GLS_OP_glGetTexGendv                      342
#define GLS_OP_glGetTexGenfv                      343
#define GLS_OP_glGetTexGeniv                      344
#define GLS_OP_glGetTexImage                      345
#define GLS_OP_glGetTexLevelParameterfv           348
#define GLS_OP_glGetTexLevelParameteriv           349
#define GLS_OP_glGetTexParameterfv                346
#define GLS_OP_glGetTexParameteriv                347
#define GLS_OP_glHint                             222
#define GLS_OP_glHistogramEXT                     65515
#define GLS_OP_glIndexMask                        276
#define GLS_OP_glIndexPointerEXT                  65498
#define GLS_OP_glIndexd                           108
#define GLS_OP_glIndexdv                          109
#define GLS_OP_glIndexf                           110
#define GLS_OP_glIndexfv                          111
#define GLS_OP_glIndexi                           112
#define GLS_OP_glIndexiv                          113
#define GLS_OP_glIndexs                           114
#define GLS_OP_glIndexsv                          115
#define GLS_OP_glInitNames                        261
#define GLS_OP_glIsEnabled                        350
#define GLS_OP_glIsList                           351
#define GLS_OP_glIsTextureEXT                     65474
#define GLS_OP_glLightModelf                      227
#define GLS_OP_glLightModelfv                     228
#define GLS_OP_glLightModeli                      229
#define GLS_OP_glLightModeliv                     230
#define GLS_OP_glLightf                           223
#define GLS_OP_glLightfv                          224
#define GLS_OP_glLighti                           225
#define GLS_OP_glLightiv                          226
#define GLS_OP_glLineStipple                      231
#define GLS_OP_glLineWidth                        232
#define GLS_OP_glListBase                         70
#define GLS_OP_glLoadIdentity                     354
#define GLS_OP_glLoadMatrixd                      356
#define GLS_OP_glLoadMatrixf                      355
#define GLS_OP_glLoadName                         262
#define GLS_OP_glLogicOp                          306
#define GLS_OP_glMap1d                            284
#define GLS_OP_glMap1f                            285
#define GLS_OP_glMap2d                            286
#define GLS_OP_glMap2f                            287
#define GLS_OP_glMapGrid1d                        288
#define GLS_OP_glMapGrid1f                        289
#define GLS_OP_glMapGrid2d                        290
#define GLS_OP_glMapGrid2f                        291
#define GLS_OP_glMaterialf                        233
#define GLS_OP_glMaterialfv                       234
#define GLS_OP_glMateriali                        235
#define GLS_OP_glMaterialiv                       236
#define GLS_OP_glMatrixMode                       357
#define GLS_OP_glMinmaxEXT                        65516
#define GLS_OP_glMultMatrixd                      359
#define GLS_OP_glMultMatrixf                      358
#define GLS_OP_glNewList                          64
#define GLS_OP_glNormal3b                         116
#define GLS_OP_glNormal3bv                        117
#define GLS_OP_glNormal3d                         118
#define GLS_OP_glNormal3dv                        119
#define GLS_OP_glNormal3f                         120
#define GLS_OP_glNormal3fv                        121
#define GLS_OP_glNormal3i                         122
#define GLS_OP_glNormal3iv                        123
#define GLS_OP_glNormal3s                         124
#define GLS_OP_glNormal3sv                        125
#define GLS_OP_glNormalPointerEXT                 65499
#define GLS_OP_glOrtho                            360
#define GLS_OP_glPassThrough                      263
#define GLS_OP_glPixelMapfv                       315
#define GLS_OP_glPixelMapuiv                      316
#define GLS_OP_glPixelMapusv                      317
#define GLS_OP_glPixelStoref                      313
#define GLS_OP_glPixelStorei                      314
#define GLS_OP_glPixelTexGenSGIX                  65462
#define GLS_OP_glPixelTransferf                   311
#define GLS_OP_glPixelTransferi                   312
#define GLS_OP_glPixelZoom                        310
#define GLS_OP_glPointSize                        237
#define GLS_OP_glPolygonMode                      238
#define GLS_OP_glPolygonOffsetEXT                 65522
#define GLS_OP_glPolygonStipple                   239
#define GLS_OP_glPopAttrib                        282
#define GLS_OP_glPopMatrix                        361
#define GLS_OP_glPopName                          264
#define GLS_OP_glPrioritizeTexturesEXT            65475
#define GLS_OP_glPushAttrib                       283
#define GLS_OP_glPushMatrix                       362
#define GLS_OP_glPushName                         265
#define GLS_OP_glRasterPos2d                      126
#define GLS_OP_glRasterPos2dv                     127
#define GLS_OP_glRasterPos2f                      128
#define GLS_OP_glRasterPos2fv                     129
#define GLS_OP_glRasterPos2i                      130
#define GLS_OP_glRasterPos2iv                     131
#define GLS_OP_glRasterPos2s                      132
#define GLS_OP_glRasterPos2sv                     133
#define GLS_OP_glRasterPos3d                      134
#define GLS_OP_glRasterPos3dv                     135
#define GLS_OP_glRasterPos3f                      136
#define GLS_OP_glRasterPos3fv                     137
#define GLS_OP_glRasterPos3i                      138
#define GLS_OP_glRasterPos3iv                     139
#define GLS_OP_glRasterPos3s                      140
#define GLS_OP_glRasterPos3sv                     141
#define GLS_OP_glRasterPos4d                      142
#define GLS_OP_glRasterPos4dv                     143
#define GLS_OP_glRasterPos4f                      144
#define GLS_OP_glRasterPos4fv                     145
#define GLS_OP_glRasterPos4i                      146
#define GLS_OP_glRasterPos4iv                     147
#define GLS_OP_glRasterPos4s                      148
#define GLS_OP_glRasterPos4sv                     149
#define GLS_OP_glReadBuffer                       318
#define GLS_OP_glReadPixels                       320
#define GLS_OP_glRectd                            150
#define GLS_OP_glRectdv                           151
#define GLS_OP_glRectf                            152
#define GLS_OP_glRectfv                           153
#define GLS_OP_glRecti                            154
#define GLS_OP_glRectiv                           155
#define GLS_OP_glRects                            156
#define GLS_OP_glRectsv                           157
#define GLS_OP_glRenderMode                       260
#define GLS_OP_glResetHistogramEXT                65517
#define GLS_OP_glResetMinmaxEXT                   65518
#define GLS_OP_glRotated                          363
#define GLS_OP_glRotatef                          364
#define GLS_OP_glSampleMaskSGIS                   65525
#define GLS_OP_glSamplePatternSGIS                65526
#define GLS_OP_glScaled                           365
#define GLS_OP_glScalef                           366
#define GLS_OP_glScissor                          240
#define GLS_OP_glSelectBuffer                     259
#define GLS_OP_glSeparableFilter2DEXT             65508
#define GLS_OP_glShadeModel                       241
#define GLS_OP_glSharpenTexFuncSGIS               65491
#define GLS_OP_glStencilFunc                      307
#define GLS_OP_glStencilMask                      273
#define GLS_OP_glStencilOp                        308
#define GLS_OP_glTagSampleBufferSGIX              65527
#define GLS_OP_glTexColorTableParameterfvSGI      65485
#define GLS_OP_glTexColorTableParameterivSGI      65486
#define GLS_OP_glTexCoord1d                       158
#define GLS_OP_glTexCoord1dv                      159
#define GLS_OP_glTexCoord1f                       160
#define GLS_OP_glTexCoord1fv                      161
#define GLS_OP_glTexCoord1i                       162
#define GLS_OP_glTexCoord1iv                      163
#define GLS_OP_glTexCoord1s                       164
#define GLS_OP_glTexCoord1sv                      165
#define GLS_OP_glTexCoord2d                       166
#define GLS_OP_glTexCoord2dv                      167
#define GLS_OP_glTexCoord2f                       168
#define GLS_OP_glTexCoord2fv                      169
#define GLS_OP_glTexCoord2i                       170
#define GLS_OP_glTexCoord2iv                      171
#define GLS_OP_glTexCoord2s                       172
#define GLS_OP_glTexCoord2sv                      173
#define GLS_OP_glTexCoord3d                       174
#define GLS_OP_glTexCoord3dv                      175
#define GLS_OP_glTexCoord3f                       176
#define GLS_OP_glTexCoord3fv                      177
#define GLS_OP_glTexCoord3i                       178
#define GLS_OP_glTexCoord3iv                      179
#define GLS_OP_glTexCoord3s                       180
#define GLS_OP_glTexCoord3sv                      181
#define GLS_OP_glTexCoord4d                       182
#define GLS_OP_glTexCoord4dv                      183
#define GLS_OP_glTexCoord4f                       184
#define GLS_OP_glTexCoord4fv                      185
#define GLS_OP_glTexCoord4i                       186
#define GLS_OP_glTexCoord4iv                      187
#define GLS_OP_glTexCoord4s                       188
#define GLS_OP_glTexCoord4sv                      189
#define GLS_OP_glTexCoordPointerEXT               65500
#define GLS_OP_glTexEnvf                          248
#define GLS_OP_glTexEnvfv                         249
#define GLS_OP_glTexEnvi                          250
#define GLS_OP_glTexEnviv                         251
#define GLS_OP_glTexGend                          252
#define GLS_OP_glTexGendv                         253
#define GLS_OP_glTexGenf                          254
#define GLS_OP_glTexGenfv                         255
#define GLS_OP_glTexGeni                          256
#define GLS_OP_glTexGeniv                         257
#define GLS_OP_glTexImage1D                       246
#define GLS_OP_glTexImage2D                       247
#define GLS_OP_glTexImage3DEXT                    65519
#define GLS_OP_glTexImage4DSGIS                   65460
#define GLS_OP_glTexParameterf                    242
#define GLS_OP_glTexParameterfv                   243
#define GLS_OP_glTexParameteri                    244
#define GLS_OP_glTexParameteriv                   245
#define GLS_OP_glTexSubImage1DEXT                 65523
#define GLS_OP_glTexSubImage2DEXT                 65524
#define GLS_OP_glTexSubImage3DEXT                 65488
#define GLS_OP_glTexSubImage4DSGIS                65461
#define GLS_OP_glTranslated                       367
#define GLS_OP_glTranslatef                       368
#define GLS_OP_glVertex2d                         190
#define GLS_OP_glVertex2dv                        191
#define GLS_OP_glVertex2f                         192
#define GLS_OP_glVertex2fv                        193
#define GLS_OP_glVertex2i                         194
#define GLS_OP_glVertex2iv                        195
#define GLS_OP_glVertex2s                         196
#define GLS_OP_glVertex2sv                        197
#define GLS_OP_glVertex3d                         198
#define GLS_OP_glVertex3dv                        199
#define GLS_OP_glVertex3f                         200
#define GLS_OP_glVertex3fv                        201
#define GLS_OP_glVertex3i                         202
#define GLS_OP_glVertex3iv                        203
#define GLS_OP_glVertex3s                         204
#define GLS_OP_glVertex3sv                        205
#define GLS_OP_glVertex4d                         206
#define GLS_OP_glVertex4dv                        207
#define GLS_OP_glVertex4f                         208
#define GLS_OP_glVertex4fv                        209
#define GLS_OP_glVertex4i                         210
#define GLS_OP_glVertex4iv                        211
#define GLS_OP_glVertex4s                         212
#define GLS_OP_glVertex4sv                        213
#define GLS_OP_glVertexPointerEXT                 65501
#define GLS_OP_glViewport                         369

#define GLS_OP_glArrayElement                     370
#define GLS_OP_glBindTexture                      371
#define GLS_OP_glColorPointer                     372
#define GLS_OP_glDisableClientState               373
#define GLS_OP_glDrawArrays                       374
#define GLS_OP_glDrawElements                     375
#define GLS_OP_glEdgeFlagPointer                  376
#define GLS_OP_glEnableClientState                377
#define GLS_OP_glIndexPointer                     378
#define GLS_OP_glIndexub                          379
#define GLS_OP_glIndexubv                         380
#define GLS_OP_glInterleavedArrays                381
#define GLS_OP_glNormalPointer                    382
#define GLS_OP_glPolygonOffset                    383
#define GLS_OP_glTexCoordPointer                  384
#define GLS_OP_glVertexPointer                    385
#define GLS_OP_glAreTexturesResident              386
#define GLS_OP_glCopyTexImage1D                   387
#define GLS_OP_glCopyTexImage2D                   388
#define GLS_OP_glCopyTexSubImage1D                389
#define GLS_OP_glCopyTexSubImage2D                390
#define GLS_OP_glDeleteTextures                   391
#define GLS_OP_glGenTextures                      392
#define GLS_OP_glGetPointerv                      393
#define GLS_OP_glIsTexture                        394
#define GLS_OP_glPrioritizeTextures               395
#define GLS_OP_glTexSubImage1D                    396
#define GLS_OP_glTexSubImage2D                    397
#define GLS_OP_glPushClientAttrib                 398
#define GLS_OP_glPopClientAttrib                  399

/*************************************************************/

/* GLS global commands */
extern GLSenum GLS_LINKAGE glsBinary (GLboolean inSwapped);
extern GLSenum GLS_LINKAGE glsCommandAPI (GLSopcode inOpcode);
extern const GLubyte* GLS_LINKAGE glsCommandString (GLSopcode inOpcode);
extern void GLS_LINKAGE glsContext (GLuint inContext);
extern void GLS_LINKAGE glsDeleteContext (GLuint inContext);
extern const GLubyte* GLS_LINKAGE glsEnumString (GLSenum inAPI, GLSenum inEnum);
extern GLuint GLS_LINKAGE glsGenContext (void);
extern GLuint* GLS_LINKAGE glsGetAllContexts (void);
extern GLScommandAlignment* GLS_LINKAGE glsGetCommandAlignment (GLSopcode inOpcode, GLSenum inExternStreamType, GLScommandAlignment *outAlignment);
extern GLbitfield GLS_LINKAGE glsGetCommandAttrib (GLSopcode inOpcode);
extern GLint GLS_LINKAGE glsGetConsti (GLSenum inAttrib);
extern const GLint* GLS_LINKAGE glsGetConstiv (GLSenum inAttrib);
extern const GLubyte* GLS_LINKAGE glsGetConstubz (GLSenum inAttrib);
extern GLuint GLS_LINKAGE glsGetCurrentContext (void);
extern GLint* GLS_LINKAGE glsGetCurrentTime (GLint *outTime);
extern GLSenum GLS_LINKAGE glsGetError (GLboolean inClear);
extern GLint GLS_LINKAGE glsGetOpcodeCount (GLSenum inAPI);
extern const GLSopcode* GLS_LINKAGE glsGetOpcodes (GLSenum inAPI);
extern GLboolean GLS_LINKAGE glsIsContext (GLuint inContext);
extern GLboolean GLS_LINKAGE glsIsExtensionSupported (const GLubyte *inExtension);
extern GLboolean GLS_LINKAGE glsIsUTF8String (const GLubyte *inString);
extern GLlong GLS_LINKAGE glsLong (GLint inHigh, GLuint inLow);
extern GLint GLS_LINKAGE glsLongHigh (GLlong inVal);
extern GLuint GLS_LINKAGE glsLongLow (GLlong inVal);
extern GLSfunc GLS_LINKAGE glsNullCommandFunc (GLSopcode inOpcode);
extern void GLS_LINKAGE glsPixelSetup (void);
extern GLulong GLS_LINKAGE glsULong (GLuint inHigh, GLuint inLow);
extern GLuint GLS_LINKAGE glsULongHigh (GLulong inVal);
extern GLuint GLS_LINKAGE glsULongLow (GLulong inVal);
extern GLint GLS_LINKAGE glsUCS4toUTF8 (GLuint inUCS4, GLubyte *outUTF8);
extern GLubyte* GLS_LINKAGE glsUCStoUTF8z (size_t inUCSbytes, const GLvoid *inUCSz, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS1toUTF8z (const GLubyte *inUCS1z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS2toUTF8z (const GLushort *inUCS2z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLubyte* GLS_LINKAGE glsUCS4toUTF8z (const GLuint *inUCS4z, size_t inUTF8max, GLubyte *outUTF8z);
extern GLint GLS_LINKAGE glsUTF8toUCS4 (const GLubyte *inUTF8, GLuint *outUCS4);
extern GLboolean GLS_LINKAGE glsUTF8toUCSz (size_t inUCSbytes, const GLubyte *inUTF8z, size_t inUCSmax, GLvoid *outUCSz);
extern GLboolean GLS_LINKAGE glsUTF8toUCS1z (const GLubyte *inUTF8z, size_t inUCS1max, GLubyte *outUCS1z);
extern GLboolean GLS_LINKAGE glsUTF8toUCS2z (const GLubyte *inUTF8z, size_t inUCS2max, GLushort *outUCS2z);
extern GLboolean GLS_LINKAGE glsUTF8toUCS4z (const GLubyte *inUTF8z, size_t inUCS4max, GLuint *outUCS4z);

/* GLS immediate commands */
extern void GLS_LINKAGE glsAbortCall (GLSenum inMode);
extern GLboolean GLS_LINKAGE glsBeginCapture (const GLubyte *inStreamName, GLSenum inCaptureStreamType, GLbitfield inWriteFlags);
extern void GLS_LINKAGE glsCallArray (GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray);
extern void GLS_LINKAGE glsCaptureFlags (GLSopcode inOpcode, GLbitfield inFlags);
extern void GLS_LINKAGE glsCaptureFunc (GLSenum inTarget, GLScaptureFunc inFunc);
extern void GLS_LINKAGE glsChannel (GLSenum inTarget, FILE *inChannel);
extern void GLS_LINKAGE glsCommandFunc (GLSopcode inOpcode, GLSfunc inFunc);
extern GLSenum GLS_LINKAGE glsCopyStream (const GLubyte *inSource, const GLubyte *inDest, GLSenum inDestType, GLbitfield inWriteFlags);
extern void GLS_LINKAGE glsDataPointer (GLvoid *inPointer);
extern void GLS_LINKAGE glsDeleteReadPrefix (GLuint inIndex);
extern void GLS_LINKAGE glsDeleteStream (const GLubyte *inName);
extern void GLS_LINKAGE glsEndCapture (void);
extern void GLS_LINKAGE glsFlush (GLSenum inFlushType);
extern GLbitfield GLS_LINKAGE glsGetCaptureFlags (GLSopcode inOpcode);
extern GLSfunc GLS_LINKAGE glsGetCommandFunc (GLSopcode inOpcode);
extern GLSfunc GLS_LINKAGE glsGetContextFunc (GLSenum inAttrib);
extern GLlong GLS_LINKAGE glsGetContextListl (GLSenum inAttrib, GLuint inIndex);
extern const GLubyte* GLS_LINKAGE glsGetContextListubz (GLSenum inAttrib, GLuint inIndex);
extern GLvoid* GLS_LINKAGE glsGetContextPointer (GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetContexti (GLSenum inAttrib);
extern const GLubyte* GLS_LINKAGE glsGetContextubz (GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetGLRCi (GLuint inGLRC, GLSenum inAttrib);
extern GLfloat GLS_LINKAGE glsGetHeaderf (GLSenum inAttrib);
extern GLfloat* GLS_LINKAGE glsGetHeaderfv (GLSenum inAttrib, GLfloat *outVec);
extern GLint GLS_LINKAGE glsGetHeaderi (GLSenum inAttrib);
extern GLint* GLS_LINKAGE glsGetHeaderiv (GLSenum inAttrib, GLint *outVec);
extern const GLubyte* GLS_LINKAGE glsGetHeaderubz (GLSenum inAttrib);
extern GLfloat GLS_LINKAGE glsGetLayerf (GLuint inLayer, GLSenum inAttrib);
extern GLint GLS_LINKAGE glsGetLayeri (GLuint inLayer, GLSenum inAttrib);
extern GLbitfield GLS_LINKAGE glsGetStreamAttrib (const GLubyte *inName);
extern GLuint GLS_LINKAGE glsGetStreamCRC32 (const GLubyte *inName);
extern const GLubyte* GLS_LINKAGE glsGetStreamReadName (const GLubyte *inName);
extern size_t GLS_LINKAGE glsGetStreamSize (const GLubyte *inName);
extern GLSenum GLS_LINKAGE glsGetStreamType (const GLubyte *inName);
extern GLboolean GLS_LINKAGE glsIsContextStream (const GLubyte *inName);
extern void GLS_LINKAGE glsPixelSetupGen (GLboolean inEnabled);
extern void GLS_LINKAGE glsReadFunc (GLSreadFunc inFunc);
extern void GLS_LINKAGE glsReadPrefix (GLSenum inListOp, const GLubyte *inPrefix);
extern void GLS_LINKAGE glsUnreadFunc (GLSwriteFunc inFunc);
extern void GLS_LINKAGE glsWriteFunc (GLSwriteFunc inFunc);
extern void GLS_LINKAGE glsWritePrefix (const GLubyte *inPrefix);

/* GLS encodable commands */
extern void GLS_LINKAGE glsBeginGLS (GLint inVersionMajor, GLint inVersionMinor);
extern void GLS_LINKAGE glsBlock (GLSenum inBlockType);
extern GLSenum GLS_LINKAGE glsCallStream (const GLubyte *inName);
extern void GLS_LINKAGE glsEndGLS (void);
extern void GLS_LINKAGE glsError (GLSopcode inOpcode, GLSenum inError);
extern void GLS_LINKAGE glsGLRC (GLuint inGLRC);
extern void GLS_LINKAGE glsGLRCLayer (GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void GLS_LINKAGE glsHeaderGLRCi (GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderLayerf (GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void GLS_LINKAGE glsHeaderLayeri (GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderf (GLSenum inAttrib, GLfloat inVal);
extern void GLS_LINKAGE glsHeaderfv (GLSenum inAttrib, const GLfloat *inVec);
extern void GLS_LINKAGE glsHeaderi (GLSenum inAttrib, GLint inVal);
extern void GLS_LINKAGE glsHeaderiv (GLSenum inAttrib, const GLint *inVec);
extern void GLS_LINKAGE glsHeaderubz (GLSenum inAttrib, const GLubyte *inString);
extern void GLS_LINKAGE glsRequireExtension (const GLubyte *inExtension);
extern void GLS_LINKAGE glsUnsupportedCommand (void);

/* GLS encodable-nop commands */
extern void GLS_LINKAGE glsAppRef (GLulong inAddress, GLuint inCount);
extern void GLS_LINKAGE glsBeginObj (const GLubyte *inTag);
extern void GLS_LINKAGE glsCharubz (const GLubyte *inTag, const GLubyte *inString);
extern void GLS_LINKAGE glsComment (const GLubyte *inComment);
extern void GLS_LINKAGE glsDisplayMapfv (GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void GLS_LINKAGE glsEndObj (void);
extern void GLS_LINKAGE glsNumb (const GLubyte *inTag, GLbyte inVal);
extern void GLS_LINKAGE glsNumbv (const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void GLS_LINKAGE glsNumd (const GLubyte *inTag, GLdouble inVal);
extern void GLS_LINKAGE glsNumdv (const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void GLS_LINKAGE glsNumf (const GLubyte *inTag, GLfloat inVal);
extern void GLS_LINKAGE glsNumfv (const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void GLS_LINKAGE glsNumi (const GLubyte *inTag, GLint inVal);
extern void GLS_LINKAGE glsNumiv (const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void GLS_LINKAGE glsNuml (const GLubyte *inTag, GLlong inVal);
extern void GLS_LINKAGE glsNumlv (const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void GLS_LINKAGE glsNums (const GLubyte *inTag, GLshort inVal);
extern void GLS_LINKAGE glsNumsv (const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void GLS_LINKAGE glsNumub (const GLubyte *inTag, GLubyte inVal);
extern void GLS_LINKAGE glsNumubv (const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void GLS_LINKAGE glsNumui (const GLubyte *inTag, GLuint inVal);
extern void GLS_LINKAGE glsNumuiv (const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void GLS_LINKAGE glsNumul (const GLubyte *inTag, GLulong inVal);
extern void GLS_LINKAGE glsNumulv (const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void GLS_LINKAGE glsNumus (const GLubyte *inTag, GLushort inVal);
extern void GLS_LINKAGE glsNumusv (const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void GLS_LINKAGE glsPad (void);
extern void GLS_LINKAGE glsSwapBuffers (GLuint inLayer);

#if defined(__cplusplus)
    }
#endif /* defined(__cplusplus) */

#endif /* defined(__gls_h_) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glsbcltu.h ===
/*
 *  Copyright 1991, 1992, Silicon Graphics, Inc.
 *  All Rights Reserved.
 *
 *  This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
 *  the contents of this file may not be disclosed to third parties, copied or
 *  duplicated in any form, in whole or in part, without the prior written
 *  permission of Silicon Graphics, Inc.
 *
 *  RESTRICTED RIGHTS LEGEND:
 *  Use, duplication or disclosure by the Government is subject to restrictions
 *  as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
 *  and Computer Software clause at DFARS 252.227-7013, and/or in similar or
 *  successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
 *  rights reserved under the Copyright Laws of the United States.
 */

#ifndef __GLSBCLTU_H__
#define __GLSBCLTU_H__

#ifndef _CLIENTSIDE_
BOOL APIENTRY glsbCreateAndDuplicateSection ( DWORD SectionSize );
BOOL APIENTRY glsbMsgStats ( LONG Action, GLMSGBATCHSTATS *BatchStats );
void APIENTRY glsbCloseAndDestroySection( void );
#endif
BOOL APIENTRY glsbAttention ( void );
ULONG APIENTRY glsbAttentionAlt(ULONG Offset);
VOID APIENTRY glsbResetBuffers(BOOL);

#endif /* __GLSBCLTU_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glp.h ===
/******************************Module*Header*******************************\
* Module Name: glp.h
*
* GL system routines shared between the front and back end
*
* Created: 12-Nov-1993 17:36:00
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef _glp_
#define _glp_

// Calls into the back end
typedef struct GLGENwindowRec GLGENwindow;

// Fake object type for DirectDraw.  BITMAP is used because it
// shouldn't come up in the places we use GetObjectType.
#define OBJ_DDRAW OBJ_BITMAP

// Surface flags

// HDC available
#define GLSURF_HDC                      0x00000001
// DirectDraw surfaces available
#define GLSURF_DIRECTDRAW               0x00000002
// Metafile-based
#define GLSURF_METAFILE                 0x00000004
// Direct memory access possible
#define GLSURF_DIRECT_ACCESS            0x00000008
// Screen surface, only set for HDC surfaces
#define GLSURF_SCREEN                   0x00000010
// Direct DC surface
#define GLSURF_DIRECTDC                 0x00000020
// Surface is in video memory
#define GLSURF_VIDEO_MEMORY             0x00000040

// Special surface types

// Memory DC
#define GLSURF_IS_MEMDC(dwFlags) \
    (((dwFlags) & (GLSURF_HDC | GLSURF_DIRECTDC | GLSURF_METAFILE)) == \
     GLSURF_HDC)
// Non-memory, non-info DC
#define GLSURF_IS_DIRECTDC(dwFlags) \
    (((dwFlags) & (GLSURF_HDC | GLSURF_DIRECTDC | GLSURF_METAFILE)) == \
     (GLSURF_HDC | GLSURF_DIRECTDC))
// Direct DC for the screen
#define GLSURF_IS_SCREENDC(dwFlags) \
    (((dwFlags) & (GLSURF_HDC | GLSURF_DIRECTDC | GLSURF_METAFILE | \
                   GLSURF_SCREEN)) == \
     (GLSURF_HDC | GLSURF_DIRECTDC | GLSURF_SCREEN))

typedef struct IDirectDrawSurface *LPDIRECTDRAWSURFACE;

typedef struct _GLDDSURF
{
    LPDIRECTDRAWSURFACE pdds;
    DDSURFACEDESC ddsd;
    DWORD dwBitDepth;
} GLDDSURF;

typedef struct _GLDDSURFACES
{
    GLDDSURF gddsFront;
    GLDDSURF gddsZ;
} GLDDSURFACES;

typedef struct _GLSURF
{
    DWORD dwFlags;
    int iLayer;
    int ipfd;
    
    PIXELFORMATDESCRIPTOR pfd;

    // Needed for ExtEscape calls for hardware even for surfaces, like
    // DirectDraw surfaces, which don't need a DC for access
    HDC hdc;
    
    // Source-specific fields
    union
    {
        HWND hwnd;
        GLDDSURFACES dd;
    };
} GLSURF;

DWORD APIENTRY DdbdToCount(DWORD ddbd);
// The documentation says that depths returned in DDPIXELFORMATs are
// DDBD_ constants, but they seem to be real numbers.  Hide the conversion
// necessary in case it needs to change.
#define DdPixDepthToCount(ddpd) (ddpd)
BYTE APIENTRY DdPixelDepth(DDSURFACEDESC *pddsd);

void  APIENTRY MaskToBitsAndShift(DWORD dwMask, BYTE *pbBits, BYTE *pbShift);
BOOL  APIENTRY InitDeviceSurface(HDC hdc, int ipfd, int iLayer,
                                 DWORD dwObjectType, BOOL bUpdatePfd,
                                 GLSURF *pgsurf);

BOOL  APIENTRY IsDirectDrawDevice(HDC hdc);

BOOL  APIENTRY glsrvAttention(PVOID, PVOID, PVOID, HANDLE);
PVOID APIENTRY glsrvCreateContext(struct _GLWINDOWID *, GLSURF *);
BOOL  APIENTRY glsrvMakeCurrent(struct _GLWINDOWID *, PVOID, GLGENwindow *);
VOID  APIENTRY glsrvLoseCurrent(PVOID);
BOOL  APIENTRY glsrvDeleteContext(PVOID);
BOOL  APIENTRY glsrvSwapBuffers(HDC, GLGENwindow *);
VOID  APIENTRY glsrvThreadExit(void);
VOID  APIENTRY glsrvCleanupWindow(PVOID, GLGENwindow *);
ULONG APIENTRY glsrvShareLists(PVOID, PVOID);
BOOL  APIENTRY glsrvCopyContext(PVOID, PVOID, UINT);
BOOL  APIENTRY glsrvBindDirectDrawTexture(struct __GLcontextRec *, int,
                                          LPDIRECTDRAWSURFACE *,
                                          DDSURFACEDESC *, ULONG);
void  APIENTRY glsrvUnbindDirectDrawTexture(struct __GLcontextRec *);

BOOL APIENTRY __wglGetBitfieldColorFormat(HDC hdc, UINT cColorBits,
                                          PIXELFORMATDESCRIPTOR *ppfd,
                                          BOOL bDescribeSurf);

BOOL APIENTRY wglIsDirectDevice(HDC hdc);

// Cleans up any orphaned window information
VOID  APIENTRY wglValidateWindows(void);

// GL metafile support function
DWORD APIENTRY wglObjectType(HDC hdc);

// Find pixel format counts
VOID APIENTRY wglNumHardwareFormats(HDC hdc, DWORD dwType,
                                    int *piMcd, int *piIcd);

// Calls from the back end to the front end
int  WINAPI __DrvDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                                     LPPIXELFORMATDESCRIPTOR ppfd);
BOOL WINAPI __DrvSetPixelFormat(HDC hdc, int ipfd, PVOID *pwnd);
BOOL WINAPI __DrvSwapBuffers(HDC hdc, BOOL bFinish);

extern CRITICAL_SECTION gcsPixelFormat;

extern CRITICAL_SECTION gcsPaletteWatcher;
extern DWORD tidPaletteWatcherThread;
extern ULONG ulPaletteWatcherCount;
extern HWND hwndPaletteWatcher;

extern DWORD dwPlatformId;
#define NT_PLATFORM     ( dwPlatformId == VER_PLATFORM_WIN32_NT )
#define WIN95_PLATFORM  ( dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )

extern LONG lThreadsAttached;

typedef HRESULT (WINAPI *PFN_GETSURFACEFROMDC)(HDC, LPDIRECTDRAWSURFACE *,
                                               HDC *);
extern PFN_GETSURFACEFROMDC pfnGetSurfaceFromDC;

#ifdef GL_METAFILE
// OpenGL metafile support routines in GDI, dynamically linked
// so the DLL can be run on platforms without metafile support
extern BOOL (APIENTRY *pfnGdiAddGlsRecord)(HDC hdc, DWORD cb, BYTE *pb,
                                           LPRECTL prclBounds);
extern BOOL (APIENTRY *pfnGdiAddGlsBounds)(HDC hdc, LPRECTL prclBounds);
extern BOOL (APIENTRY *pfnGdiIsMetaPrintDC)(HDC hdc);

#if DBG
// Use NULL-checking thunks in debug mode to check erroneous DLL usage
BOOL APIENTRY GlGdiAddGlsRecord(HDC hdc, DWORD cb, BYTE *pb,
                                LPRECTL prclBounds);
BOOL APIENTRY GlGdiAddGlsBounds(HDC hdc, LPRECTL prclBounds);
BOOL APIENTRY GlGdiIsMetaPrintDC(HDC hdc);
#else
// Call directly through points in retail builds
#define GlGdiAddGlsRecord(hdc, cb, pb, prcl) \
    pfnGdiAddGlsRecord(hdc, cb, pb, prcl)
#define GlGdiAddGlsBounds(hdc, prcl) \
    pfnGdiAddGlsBounds(hdc, prcl)
#define GlGdiIsMetaPrintDC(hdc) \
    pfnGdiIsMetaPrintDC(hdc)
#endif
#endif

#include <alloc.h>
#include <debug.h>

#endif // _glp_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glos.h ===
#ifndef __GLOS_H__
#define __GLOS_H__

#ifdef NT

#ifdef GLU32

/*
 *  Turn off a bunch of stuff so the we can compile the glu cleanly.
 *
 *  NOGDI       ; No gdi prototypes. (was having problems with 'Arc'
 *              ; being defined as a class and as a function
 *  NOMINMAX    ; The glu code defines its own inline min, max functions
 */

#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NOCOMM
#define NOKANJI

#include <windows.h>

/* Disable long to float conversion warning */
#pragma warning (disable:4244)

#else

#include <windows.h>

#endif  /* GLU32 */


#define GLOS_ALTCALL    WINAPI      /* Alternate calling convention     */
#define GLOS_CCALL      WINAPIV     /* C calling convention             */
#define GLOS_CALLBACK   CALLBACK

#endif  /* NT */

#ifdef UNIX

/*
 * ALTCALL and CCALL are used in the x86 world
 * to specify calling conventions.
 */

#define GLOS_ALTCALL
#define GLOS_CCALL
#define GLOS_CALLBACK

#endif  /* UNIX */

#endif  /* !__GLOS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glsbmsg.h ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#ifndef __GLSBMSG_H__
#define __GLSBMSG_H__

/*
 * Sub batching Messages
 */
typedef struct
{
    ULONG ProcOffset;
    GLint xs;
    GLint ys;
    GLint xe;
    GLint ye;

} GLMSG_ADDSWAPHINTRECTWIN;

typedef struct
{
    ULONG ProcOffset;
    GLuint list;
    GLenum mode;

} GLMSG_NEWLIST;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_ENDLIST;

typedef struct
{
    ULONG ProcOffset;
    GLuint list;

} GLMSG_CALLLIST;

typedef struct
{
    ULONG ProcOffset;
    GLsizei n;
    GLenum type;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG listsOff;

} GLMSG_CALLLISTS;

typedef struct
{
    ULONG ProcOffset;
    GLuint list;
    GLsizei range;

} GLMSG_DELETELISTS;

typedef struct
{
    ULONG ProcOffset;
    GLsizei range;

} GLMSG_GENLISTS;

typedef struct
{
    ULONG ProcOffset;
    GLuint base;

} GLMSG_LISTBASE;

typedef struct
{
    ULONG ProcOffset;
    PVOID pa0;
    PVOID paLast;
    ULONG pad[512];

} GLMSG_DRAWPOLYARRAY_LARGE;	// this must be the largest message!

typedef struct
{
    ULONG ProcOffset;
    PVOID pa0;
    PVOID paLast;

} GLMSG_DRAWPOLYARRAY;

typedef struct
{
    ULONG ProcOffset;
    GLbyte red;
    GLbyte green;
    GLbyte blue;

} GLMSG_COLOR3B;

typedef struct
{
    ULONG ProcOffset;
    GLbyte v[3];

} GLMSG_COLOR3BV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble red;
    GLdouble green;
    GLdouble blue;

} GLMSG_COLOR3D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[3];

} GLMSG_COLOR3DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat red;
    GLfloat green;
    GLfloat blue;

} GLMSG_COLOR3F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[3];

} GLMSG_COLOR3FV;

typedef struct
{
    ULONG ProcOffset;
    GLint red;
    GLint green;
    GLint blue;

} GLMSG_COLOR3I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[3];

} GLMSG_COLOR3IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort red;
    GLshort green;
    GLshort blue;

} GLMSG_COLOR3S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[3];

} GLMSG_COLOR3SV;

typedef struct
{
    ULONG ProcOffset;
    GLubyte red;
    GLubyte green;
    GLubyte blue;

} GLMSG_COLOR3UB;

typedef struct
{
    ULONG ProcOffset;
    GLubyte v[3];

} GLMSG_COLOR3UBV;

typedef struct
{
    ULONG ProcOffset;
    GLuint red;
    GLuint green;
    GLuint blue;

} GLMSG_COLOR3UI;

typedef struct
{
    ULONG ProcOffset;
    GLuint v[3];

} GLMSG_COLOR3UIV;

typedef struct
{
    ULONG ProcOffset;
    GLushort red;
    GLushort green;
    GLushort blue;

} GLMSG_COLOR3US;

typedef struct
{
    ULONG ProcOffset;
    GLushort v[3];

} GLMSG_COLOR3USV;

typedef struct
{
    ULONG ProcOffset;
    GLbyte red;
    GLbyte green;
    GLbyte blue;
    GLbyte alpha;

} GLMSG_COLOR4B;

typedef struct
{
    ULONG ProcOffset;
    GLbyte v[4];

} GLMSG_COLOR4BV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble red;
    GLdouble green;
    GLdouble blue;
    GLdouble alpha;

} GLMSG_COLOR4D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[4];

} GLMSG_COLOR4DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;

} GLMSG_COLOR4F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[4];

} GLMSG_COLOR4FV;

typedef struct
{
    ULONG ProcOffset;
    GLint red;
    GLint green;
    GLint blue;
    GLint alpha;

} GLMSG_COLOR4I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[4];

} GLMSG_COLOR4IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort red;
    GLshort green;
    GLshort blue;
    GLshort alpha;

} GLMSG_COLOR4S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[4];

} GLMSG_COLOR4SV;

typedef struct
{
    ULONG ProcOffset;
    GLubyte red;
    GLubyte green;
    GLubyte blue;
    GLubyte alpha;

} GLMSG_COLOR4UB;

typedef struct
{
    ULONG ProcOffset;
    GLubyte v[4];

} GLMSG_COLOR4UBV;

typedef struct
{
    ULONG ProcOffset;
    GLuint red;
    GLuint green;
    GLuint blue;
    GLuint alpha;

} GLMSG_COLOR4UI;

typedef struct
{
    ULONG ProcOffset;
    GLuint v[4];

} GLMSG_COLOR4UIV;

typedef struct
{
    ULONG ProcOffset;
    GLushort red;
    GLushort green;
    GLushort blue;
    GLushort alpha;

} GLMSG_COLOR4US;

typedef struct
{
    ULONG ProcOffset;
    GLushort v[4];

} GLMSG_COLOR4USV;

typedef struct
{
    ULONG ProcOffset;
    GLboolean flag;

} GLMSG_EDGEFLAG;

typedef struct
{
    ULONG ProcOffset;
    GLboolean flag[1];

} GLMSG_EDGEFLAGV;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_END;

typedef struct
{
    ULONG ProcOffset;
    GLdouble c;

} GLMSG_INDEXD;

typedef struct
{
    ULONG ProcOffset;
    GLdouble c[1];

} GLMSG_INDEXDV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat c;

} GLMSG_INDEXF;

typedef struct
{
    ULONG ProcOffset;
    GLfloat c[1];

} GLMSG_INDEXFV;

typedef struct
{
    ULONG ProcOffset;
    GLint c;

} GLMSG_INDEXI;

typedef struct
{
    ULONG ProcOffset;
    GLint c[1];

} GLMSG_INDEXIV;

typedef struct
{
    ULONG ProcOffset;
    GLshort c;

} GLMSG_INDEXS;

typedef struct
{
    ULONG ProcOffset;
    GLshort c[1];

} GLMSG_INDEXSV;

typedef struct
{
    ULONG ProcOffset;
    GLbyte nx;
    GLbyte ny;
    GLbyte nz;

} GLMSG_NORMAL3B;

typedef struct
{
    ULONG ProcOffset;
    GLbyte v[3];

} GLMSG_NORMAL3BV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble nx;
    GLdouble ny;
    GLdouble nz;

} GLMSG_NORMAL3D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[3];

} GLMSG_NORMAL3DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;

} GLMSG_NORMAL3F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[3];

} GLMSG_NORMAL3FV;

typedef struct
{
    ULONG ProcOffset;
    GLint nx;
    GLint ny;
    GLint nz;

} GLMSG_NORMAL3I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[3];

} GLMSG_NORMAL3IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort nx;
    GLshort ny;
    GLshort nz;

} GLMSG_NORMAL3S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[3];

} GLMSG_NORMAL3SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;

} GLMSG_RASTERPOS2D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[2];

} GLMSG_RASTERPOS2DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;

} GLMSG_RASTERPOS2F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[2];

} GLMSG_RASTERPOS2FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;

} GLMSG_RASTERPOS2I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[2];

} GLMSG_RASTERPOS2IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;

} GLMSG_RASTERPOS2S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[2];

} GLMSG_RASTERPOS2SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;

} GLMSG_RASTERPOS3D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[3];

} GLMSG_RASTERPOS3DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;

} GLMSG_RASTERPOS3F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[3];

} GLMSG_RASTERPOS3FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLint z;

} GLMSG_RASTERPOS3I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[3];

} GLMSG_RASTERPOS3IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;
    GLshort z;

} GLMSG_RASTERPOS3S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[3];

} GLMSG_RASTERPOS3SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;
    GLdouble w;

} GLMSG_RASTERPOS4D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[4];

} GLMSG_RASTERPOS4DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;

} GLMSG_RASTERPOS4F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[4];

} GLMSG_RASTERPOS4FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLint z;
    GLint w;

} GLMSG_RASTERPOS4I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[4];

} GLMSG_RASTERPOS4IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;

} GLMSG_RASTERPOS4S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[4];

} GLMSG_RASTERPOS4SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x1;
    GLdouble y1;
    GLdouble x2;
    GLdouble y2;

} GLMSG_RECTD;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v1[2];
    GLdouble v2[2];

} GLMSG_RECTDV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x1;
    GLfloat y1;
    GLfloat x2;
    GLfloat y2;

} GLMSG_RECTF;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v1[2];
    GLfloat v2[2];

} GLMSG_RECTFV;

typedef struct
{
    ULONG ProcOffset;
    GLint x1;
    GLint y1;
    GLint x2;
    GLint y2;

} GLMSG_RECTI;

typedef struct
{
    ULONG ProcOffset;
    GLint v1[2];
    GLint v2[2];

} GLMSG_RECTIV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x1;
    GLshort y1;
    GLshort x2;
    GLshort y2;

} GLMSG_RECTS;

typedef struct
{
    ULONG ProcOffset;
    GLshort v1[2];
    GLshort v2[2];

} GLMSG_RECTSV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble s;

} GLMSG_TEXCOORD1D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[1];

} GLMSG_TEXCOORD1DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat s;

} GLMSG_TEXCOORD1F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[1];

} GLMSG_TEXCOORD1FV;

typedef struct
{
    ULONG ProcOffset;
    GLint s;

} GLMSG_TEXCOORD1I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[1];

} GLMSG_TEXCOORD1IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort s;

} GLMSG_TEXCOORD1S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[1];

} GLMSG_TEXCOORD1SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble s;
    GLdouble t;

} GLMSG_TEXCOORD2D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[2];

} GLMSG_TEXCOORD2DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat s;
    GLfloat t;

} GLMSG_TEXCOORD2F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[2];

} GLMSG_TEXCOORD2FV;

typedef struct
{
    ULONG ProcOffset;
    GLint s;
    GLint t;

} GLMSG_TEXCOORD2I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[2];

} GLMSG_TEXCOORD2IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort s;
    GLshort t;

} GLMSG_TEXCOORD2S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[2];

} GLMSG_TEXCOORD2SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble s;
    GLdouble t;
    GLdouble r;

} GLMSG_TEXCOORD3D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[3];

} GLMSG_TEXCOORD3DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat s;
    GLfloat t;
    GLfloat r;

} GLMSG_TEXCOORD3F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[3];

} GLMSG_TEXCOORD3FV;

typedef struct
{
    ULONG ProcOffset;
    GLint s;
    GLint t;
    GLint r;

} GLMSG_TEXCOORD3I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[3];

} GLMSG_TEXCOORD3IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort s;
    GLshort t;
    GLshort r;

} GLMSG_TEXCOORD3S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[3];

} GLMSG_TEXCOORD3SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble s;
    GLdouble t;
    GLdouble r;
    GLdouble q;

} GLMSG_TEXCOORD4D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[4];

} GLMSG_TEXCOORD4DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat q;

} GLMSG_TEXCOORD4F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[4];

} GLMSG_TEXCOORD4FV;

typedef struct
{
    ULONG ProcOffset;
    GLint s;
    GLint t;
    GLint r;
    GLint q;

} GLMSG_TEXCOORD4I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[4];

} GLMSG_TEXCOORD4IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort s;
    GLshort t;
    GLshort r;
    GLshort q;

} GLMSG_TEXCOORD4S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[4];

} GLMSG_TEXCOORD4SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;

} GLMSG_VERTEX2D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[2];

} GLMSG_VERTEX2DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;

} GLMSG_VERTEX2F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[2];

} GLMSG_VERTEX2FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;

} GLMSG_VERTEX2I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[2];

} GLMSG_VERTEX2IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;

} GLMSG_VERTEX2S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[2];

} GLMSG_VERTEX2SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;

} GLMSG_VERTEX3D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[3];

} GLMSG_VERTEX3DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;

} GLMSG_VERTEX3F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[3];

} GLMSG_VERTEX3FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLint z;

} GLMSG_VERTEX3I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[3];

} GLMSG_VERTEX3IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;
    GLshort z;

} GLMSG_VERTEX3S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[3];

} GLMSG_VERTEX3SV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;
    GLdouble w;

} GLMSG_VERTEX4D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble v[4];

} GLMSG_VERTEX4DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;

} GLMSG_VERTEX4F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat v[4];

} GLMSG_VERTEX4FV;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLint z;
    GLint w;

} GLMSG_VERTEX4I;

typedef struct
{
    ULONG ProcOffset;
    GLint v[4];

} GLMSG_VERTEX4IV;

typedef struct
{
    ULONG ProcOffset;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;

} GLMSG_VERTEX4S;

typedef struct
{
    ULONG ProcOffset;
    GLshort v[4];

} GLMSG_VERTEX4SV;

typedef struct
{
    ULONG ProcOffset;
    GLenum plane;
    GLdouble equation[4];

} GLMSG_CLIPPLANE;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum mode;

} GLMSG_COLORMATERIAL;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_CULLFACE;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_FRONTFACE;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum mode;

} GLMSG_HINT;

typedef struct
{
    ULONG ProcOffset;
    GLint factor;
    GLushort pattern;

} GLMSG_LINESTIPPLE;

typedef struct
{
    ULONG ProcOffset;
    GLfloat width;

} GLMSG_LINEWIDTH;

typedef struct
{
    ULONG ProcOffset;
    GLfloat size;

} GLMSG_POINTSIZE;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum mode;

} GLMSG_POLYGONMODE;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;

} GLMSG_SCISSOR;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_SHADEMODEL;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_INITNAMES;

typedef struct
{
    ULONG ProcOffset;
    GLuint name;

} GLMSG_LOADNAME;

typedef struct
{
    ULONG ProcOffset;
    GLfloat token;

} GLMSG_PASSTHROUGH;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_POPNAME;

typedef struct
{
    ULONG ProcOffset;
    GLuint name;

} GLMSG_PUSHNAME;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_DRAWBUFFER;

typedef struct
{
    ULONG ProcOffset;
    GLbitfield mask;

} GLMSG_CLEAR;

typedef struct
{
    ULONG ProcOffset;
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;

} GLMSG_CLEARACCUM;

typedef struct
{
    ULONG ProcOffset;
    GLfloat c;

} GLMSG_CLEARINDEX;

typedef struct
{
    ULONG ProcOffset;
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;

} GLMSG_CLEARCOLOR;

typedef struct
{
    ULONG ProcOffset;
    GLint s;

} GLMSG_CLEARSTENCIL;

typedef struct
{
    ULONG ProcOffset;
    GLclampd depth;

} GLMSG_CLEARDEPTH;

typedef struct
{
    ULONG ProcOffset;
    GLuint mask;

} GLMSG_STENCILMASK;

typedef struct
{
    ULONG ProcOffset;
    GLboolean red;
    GLboolean green;
    GLboolean blue;
    GLboolean alpha;

} GLMSG_COLORMASK;

typedef struct
{
    ULONG ProcOffset;
    GLboolean flag;

} GLMSG_DEPTHMASK;

typedef struct
{
    ULONG ProcOffset;
    GLuint mask;

} GLMSG_INDEXMASK;

typedef struct
{
    ULONG ProcOffset;
    GLenum op;
    GLfloat value;

} GLMSG_ACCUM;

typedef struct
{
    ULONG ProcOffset;
    GLenum cap;

} GLMSG_DISABLE;

typedef struct
{
    ULONG ProcOffset;
    GLenum cap;

} GLMSG_ENABLE;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_FINISH;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_FLUSH;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_POPATTRIB;

typedef struct
{
    ULONG ProcOffset;
    GLbitfield mask;

} GLMSG_PUSHATTRIB;

typedef struct
{
    ULONG ProcOffset;
    GLint un;
    GLdouble u1;
    GLdouble u2;

} GLMSG_MAPGRID1D;

typedef struct
{
    ULONG ProcOffset;
    GLint un;
    GLfloat u1;
    GLfloat u2;

} GLMSG_MAPGRID1F;

typedef struct
{
    ULONG ProcOffset;
    GLint un;
    GLdouble u1;
    GLdouble u2;
    GLint vn;
    GLdouble v1;
    GLdouble v2;

} GLMSG_MAPGRID2D;

typedef struct
{
    ULONG ProcOffset;
    GLint un;
    GLfloat u1;
    GLfloat u2;
    GLint vn;
    GLfloat v1;
    GLfloat v2;

} GLMSG_MAPGRID2F;

typedef struct
{
    ULONG ProcOffset;
    GLdouble u;

} GLMSG_EVALCOORD1D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble u[1];

} GLMSG_EVALCOORD1DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat u;

} GLMSG_EVALCOORD1F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat u[1];

} GLMSG_EVALCOORD1FV;

typedef struct
{
    ULONG ProcOffset;
    GLdouble u;
    GLdouble v;

} GLMSG_EVALCOORD2D;

typedef struct
{
    ULONG ProcOffset;
    GLdouble u[2];

} GLMSG_EVALCOORD2DV;

typedef struct
{
    ULONG ProcOffset;
    GLfloat u;
    GLfloat v;

} GLMSG_EVALCOORD2F;

typedef struct
{
    ULONG ProcOffset;
    GLfloat u[2];

} GLMSG_EVALCOORD2FV;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;
    GLint i1;
    GLint i2;

} GLMSG_EVALMESH1;

typedef struct
{
    ULONG ProcOffset;
    GLint i;

} GLMSG_EVALPOINT1;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;
    GLint i1;
    GLint i2;
    GLint j1;
    GLint j2;

} GLMSG_EVALMESH2;

typedef struct
{
    ULONG ProcOffset;
    GLint i;
    GLint j;

} GLMSG_EVALPOINT2;

typedef struct
{
    ULONG ProcOffset;
    GLenum func;
    GLclampf ref;

} GLMSG_ALPHAFUNC;

typedef struct
{
    ULONG ProcOffset;
    GLenum sfactor;
    GLenum dfactor;

} GLMSG_BLENDFUNC;

typedef struct
{
    ULONG ProcOffset;
    GLenum opcode;

} GLMSG_LOGICOP;

typedef struct
{
    ULONG ProcOffset;
    GLenum func;
    GLint ref;
    GLuint mask;

} GLMSG_STENCILFUNC;

typedef struct
{
    ULONG ProcOffset;
    GLenum fail;
    GLenum zfail;
    GLenum zpass;

} GLMSG_STENCILOP;

typedef struct
{
    ULONG ProcOffset;
    GLenum func;

} GLMSG_DEPTHFUNC;

typedef struct
{
    ULONG ProcOffset;
    GLfloat xfactor;
    GLfloat yfactor;

} GLMSG_PIXELZOOM;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLfloat param;

} GLMSG_PIXELTRANSFERF;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLint param;

} GLMSG_PIXELTRANSFERI;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLfloat param;

} GLMSG_PIXELSTOREF;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLint param;

} GLMSG_PIXELSTOREI;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    GLint mapsize;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_PIXELMAPFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    GLint mapsize;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_PIXELMAPUIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    GLint mapsize;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_PIXELMAPUSV;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_READBUFFER;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum type;

} GLMSG_COPYPIXELS;

typedef struct
{
    ULONG ProcOffset;
    GLenum plane;
#ifdef _CLIENTSIDE_
    GLdouble *equation;
#else
    GLdouble equation[4];
#endif

} GLMSG_GETCLIPPLANE;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_GETERROR;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum query;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR vOff;

} GLMSG_GETMAPDV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum query;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR vOff;

} GLMSG_GETMAPFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum query;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR vOff;

} GLMSG_GETMAPIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_GETPIXELMAPFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_GETPIXELMAPUIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum map;
    ULONG MsgSize;
    ULONG DataSize;
    ULONG_PTR valuesOff;

} GLMSG_GETPIXELMAPUSV;

typedef struct
{
    ULONG ProcOffset;
    GLenum cap;

} GLMSG_ISENABLED;

typedef struct
{
    ULONG ProcOffset;
    GLuint list;

} GLMSG_ISLIST;

typedef struct
{
    ULONG ProcOffset;
    GLclampd zNear;
    GLclampd zFar;

} GLMSG_DEPTHRANGE;

typedef struct
{
    ULONG ProcOffset;
    GLdouble left;
    GLdouble right;
    GLdouble bottom;
    GLdouble top;
    GLdouble zNear;
    GLdouble zFar;

} GLMSG_FRUSTUM;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_LOADIDENTITY;

typedef struct
{
    ULONG ProcOffset;
    GLfloat m[16];

} GLMSG_LOADMATRIXF;

typedef struct
{
    ULONG ProcOffset;
    GLdouble m[16];

} GLMSG_LOADMATRIXD;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_MATRIXMODE;

typedef struct
{
    ULONG ProcOffset;
    GLfloat m[16];

} GLMSG_MULTMATRIXF;

typedef struct
{
    ULONG ProcOffset;
    GLdouble m[16];

} GLMSG_MULTMATRIXD;

typedef struct
{
    ULONG ProcOffset;
    GLdouble left;
    GLdouble right;
    GLdouble bottom;
    GLdouble top;
    GLdouble zNear;
    GLdouble zFar;

} GLMSG_ORTHO;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_POPMATRIX;

typedef struct
{
    ULONG ProcOffset;

} GLMSG_PUSHMATRIX;

typedef struct
{
    ULONG ProcOffset;
    GLdouble angle;
    GLdouble x;
    GLdouble y;
    GLdouble z;

} GLMSG_ROTATED;

typedef struct
{
    ULONG ProcOffset;
    GLfloat angle;
    GLfloat x;
    GLfloat y;
    GLfloat z;

} GLMSG_ROTATEF;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;

} GLMSG_SCALED;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;

} GLMSG_SCALEF;

typedef struct
{
    ULONG ProcOffset;
    GLdouble x;
    GLdouble y;
    GLdouble z;

} GLMSG_TRANSLATED;

typedef struct
{
    ULONG ProcOffset;
    GLfloat x;
    GLfloat y;
    GLfloat z;

} GLMSG_TRANSLATEF;

typedef struct
{
    ULONG ProcOffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;

} GLMSG_VIEWPORT;

#endif /* !__GLSBMSG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glsize.h ===
#ifndef __GLSIZE_H__
#define __GLSIZE_H__

#define RANGE(n, a, b)  \
	(((unsigned)(n) >= (unsigned)(a)) && ((unsigned)(n) <= (unsigned)(b)))

#define __GLTYPESIZE(n)          __glTypeSize[(n)-GL_BYTE]
extern GLint __glTypeSize[];
// #define RANGE_GLTYPESIZE(n)   RANGE(n,GL_BYTE,GL_DOUBLE)

#endif  /* !__GLSIZE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glscreen.h ===
/******************************Module*Header*******************************\
* Module Name: glscreen.h
*
* OpenGL direct screen access support
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#ifndef _GLSCREEN_H_
#define _GLSCREEN_H_

#include <ddraw.h>

//
// Structure that contains all the info we need to access the framebuffer
//
typedef struct _SCREENINFO_ {
    LPDIRECTDRAW pdd;
    GLDDSURF gdds;
} SCREENINFO;

//
// Global pointer to SCREENINFO structure that is non-NULL if and only if
// direct access to the framebuffer is available.
//
extern SCREENINFO *gpScreenInfo;

//
// Direct access macros:
//
//  GLDIRECTSCREEN  TRUE if direct access is enabled
//  GLSCREENINFO    Pointer to global SCREENINFO.
//
#define GLDIRECTSCREEN  ( gpScreenInfo != NULL )
#define GLSCREENINFO    ( gpScreenInfo )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glsbmsgh.h ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * Message for handcoded OpenGL functions going through the subbatch
 */

#ifndef __GLSBMSGH_H__
#define __GLSBMSGH_H__

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLfloat params[4];

} GLMSG_FOGFV, GLMSG_FOGF;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLint params[4];

} GLMSG_FOGIV, GLMSG_FOGI;

typedef struct
{
    ULONG ProcOffset;
    GLenum light;
    GLenum pname;
    GLfloat params[4];

} GLMSG_LIGHTFV, GLMSG_LIGHTF;

typedef struct
{
    ULONG ProcOffset;
    GLenum light;
    GLenum pname;
    GLint params[4];

} GLMSG_LIGHTIV, GLMSG_LIGHTI;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLfloat params[4];

} GLMSG_LIGHTMODELFV, GLMSG_LIGHTMODELF;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
    GLint params[4];

} GLMSG_LIGHTMODELIV, GLMSG_LIGHTMODELI;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum pname;
    GLfloat params[4];

} GLMSG_MATERIALFV, GLMSG_MATERIALF;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum pname;
    GLint params[4];

} GLMSG_MATERIALIV, GLMSG_MATERIALI;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLfloat params[4];

} GLMSG_TEXPARAMETERFV, GLMSG_TEXPARAMETERF;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLint params[4];

} GLMSG_TEXPARAMETERIV, GLMSG_TEXPARAMETERI;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLfloat params[4];

} GLMSG_TEXENVFV, GLMSG_TEXENVF;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLint params[4];

} GLMSG_TEXENVIV, GLMSG_TEXENVI;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
    GLdouble params[4];

} GLMSG_TEXGENDV, GLMSG_TEXGEND;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
    GLfloat params[4];

} GLMSG_TEXGENFV, GLMSG_TEXGENF;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
    GLint params[4];

} GLMSG_TEXGENIV, GLMSG_TEXGENI;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLboolean *params;
#else
    GLboolean params[16];
#endif

} GLMSG_GETBOOLEANV;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLdouble *params;
#else
    GLdouble params[16];
#endif

} GLMSG_GETDOUBLEV;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[16];
#endif

} GLMSG_GETFLOATV;

typedef struct
{
    ULONG ProcOffset;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[16];
#endif

} GLMSG_GETINTEGERV;

typedef struct
{
    ULONG ProcOffset;
    GLenum light;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[4];
#endif

} GLMSG_GETLIGHTFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum light;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[4];
#endif

} GLMSG_GETLIGHTIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[4];
#endif

} GLMSG_GETMATERIALFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum face;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[4];
#endif

} GLMSG_GETMATERIALIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[4];
#endif

} GLMSG_GETTEXENVFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[4];
#endif

} GLMSG_GETTEXENVIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLdouble *params;
#else
    GLdouble params[4];
#endif

} GLMSG_GETTEXGENDV;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[4];
#endif

} GLMSG_GETTEXGENFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum coord;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[4];
#endif

} GLMSG_GETTEXGENIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[4];
#endif

} GLMSG_GETTEXPARAMETERFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[4];
#endif

} GLMSG_GETTEXPARAMETERIV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLfloat *params;
#else
    GLfloat params[1];
#endif

} GLMSG_GETTEXLEVELPARAMETERFV;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLenum pname;
#ifdef _CLIENTSIDE_
    GLint *params;
#else
    GLint params[1];
#endif

} GLMSG_GETTEXLEVELPARAMETERIV;

typedef struct
{
    ULONG_PTR ProcOffset;
    GLsizei size;
    GLenum type;
    ULONG_PTR bufferOff;

} GLMSG_FEEDBACKBUFFER;

typedef struct
{
    ULONG ProcOffset;
    GLsizei size;
    ULONG_PTR bufferOff;

} GLMSG_SELECTBUFFER;

typedef struct
{
    ULONG ProcOffset;
    GLenum mode;

} GLMSG_RENDERMODE;

typedef struct
{
    // This only used so that the code compiles.
    // GetString is included in the proctables.
    // However, GetString() is currently implemented
    // on the client side.

    ULONG ProcOffset;

} GLMSG_GETSTRING;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLdouble u1;
    GLdouble u2;
    GLint stride;
    GLint order;
#ifndef _CLIENTSIDE_
    ULONG MsgSize;
    ULONG DataSize;
#endif
    ULONG pointsOff;

} GLMSG_MAP1D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint stride;
    GLint order;
#ifndef _CLIENTSIDE_
    ULONG MsgSize;
    ULONG DataSize;
#endif
    ULONG pointsOff;

} GLMSG_MAP1F;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLdouble u1;
    GLdouble u2;
    GLint ustride;
    GLint uorder;
    GLdouble v1;
    GLdouble v2;
    GLint vstride;
    GLint vorder;
#ifndef _CLIENTSIDE_
    ULONG MsgSize;
    ULONG DataSize;
#endif
    ULONG pointsOff;

} GLMSG_MAP2D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint ustride;
    GLint uorder;
    GLfloat v1;
    GLfloat v2;
    GLint vstride;
    GLint vorder;
#ifndef _CLIENTSIDE_
    ULONG MsgSize;
    ULONG DataSize;
#endif
    ULONG pointsOff;

} GLMSG_MAP2F;

typedef struct
{
    ULONG ProcOffset    ;
    GLint x             ;
    GLint y             ;
    GLsizei width       ;
    GLsizei height      ;
    GLenum format       ;
    GLenum type         ;
    ULONG_PTR pixelsOff ;

} GLMSG_READPIXELS;

typedef struct
{
    ULONG  ProcOffset   ;
    GLenum target       ;
    GLint  level        ;
    GLenum format       ;
    GLenum type         ;
    ULONG_PTR pixelsOff ;

} GLMSG_GETTEXIMAGE;

typedef struct
{
    ULONG   ProcOffset  ;
    GLsizei width       ;
    GLsizei height      ;
    GLenum  format      ;
    GLenum  type        ;
    ULONG_PTR pixelsOff ;
    GLboolean _IsDlist  ;

} GLMSG_DRAWPIXELS;

typedef struct
{
    ULONG   ProcOffset  ;
    GLsizei width       ;
    GLsizei height      ;
    GLfloat xorig       ;
    GLfloat yorig       ;
    GLfloat xmove       ;
    GLfloat ymove       ;
    ULONG_PTR bitmapOff ;
    GLboolean _IsDlist  ;

} GLMSG_BITMAP;

typedef struct
{
    ULONG ProcOffset    ;
    ULONG_PTR maskOff       ;
    GLboolean _IsDlist  ;

} GLMSG_POLYGONSTIPPLE, GLMSG_GETPOLYGONSTIPPLE;

typedef struct
{
    ULONG   ProcOffset  ;
    GLenum  target      ;
    GLint   level       ;
    GLint   components  ;
    GLsizei width       ;
    GLint   border      ;
    GLenum  format      ;
    GLenum  type        ;
    ULONG_PTR pixelsOff ;
    GLboolean _IsDlist  ;

} GLMSG_TEXIMAGE1D;

typedef struct
{
    ULONG   ProcOffset  ;
    GLenum  target      ;
    GLint   level       ;
    GLint   components  ;
    GLsizei width       ;
    GLsizei height      ;
    GLint   border      ;
    GLenum  format      ;
    GLenum  type        ;
    ULONG_PTR pixelsOff ;
    GLboolean _IsDlist  ;

} GLMSG_TEXIMAGE2D;

typedef struct
{
    ULONG ProcOffset;
    GLsizei n;
    const GLuint *textures;
    GLboolean *residences;
} GLMSG_ARETEXTURESRESIDENT;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLuint texture;
} GLMSG_BINDTEXTURE;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
} GLMSG_COPYTEXIMAGE1D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
} GLMSG_COPYTEXIMAGE2D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
} GLMSG_COPYTEXSUBIMAGE1D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} GLMSG_COPYTEXSUBIMAGE2D;

typedef struct
{
    ULONG ProcOffset;
    GLsizei n;
    const GLuint *textures;
} GLMSG_DELETETEXTURES;

typedef struct
{
    ULONG ProcOffset;
    GLsizei n;
    GLuint *textures;
} GLMSG_GENTEXTURES;

typedef struct
{
    ULONG ProcOffset;
    GLuint texture;
} GLMSG_ISTEXTURE;

typedef struct
{
    ULONG ProcOffset;
    GLsizei n;
    const GLuint *textures;
    const GLclampf *priorities;
} GLMSG_PRIORITIZETEXTURES;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    ULONG_PTR pixelsOff;
    GLboolean _IsDlist  ;
} GLMSG_TEXSUBIMAGE1D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    ULONG_PTR pixelsOff;
    GLboolean _IsDlist  ;
} GLMSG_TEXSUBIMAGE2D;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum internalFormat;
    GLsizei width;
    GLenum format;
    GLenum type;
    const GLvoid *data;
    GLboolean _IsDlist;
} GLMSG_COLORTABLEEXT;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLuint start;
    GLsizei count;
    GLenum format;
    GLenum type;
    const GLvoid *data;
    GLboolean _IsDlist;
} GLMSG_COLORSUBTABLEEXT;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid *data;
} GLMSG_GETCOLORTABLEEXT;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLint *params;
} GLMSG_GETCOLORTABLEPARAMETERIVEXT;

typedef struct
{
    ULONG ProcOffset;
    GLenum target;
    GLenum pname;
    GLfloat *params;
} GLMSG_GETCOLORTABLEPARAMETERFVEXT;

typedef struct
{
    ULONG ProcOffset;
    GLfloat factor;
    GLfloat units;
} GLMSG_POLYGONOFFSET;

#ifdef GL_WIN_multiple_textures
typedef struct
{
    ULONG ProcOffset;
    GLuint index;
} GLMSG_CURRENTTEXTUREINDEXWIN;

typedef struct
{
    ULONG ProcOffset;
    GLuint index;
    GLenum target;
    GLuint texture;
} GLMSG_BINDNTHTEXTUREWIN;

typedef struct
{
    ULONG ProcOffset;
    GLuint index;
    GLenum leftColorFactor;
    GLenum colorOp;
    GLenum rightColorFactor;
    GLenum leftAlphaFactor;
    GLenum alphaOp;
    GLenum rightAlphaFactor;
} GLMSG_NTHTEXCOMBINEFUNCWIN;
#endif // GL_WIN_multiple_textures

#endif /* !__GLSBMSGH_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\lcfuncs.h ===
#ifndef __lcfuncs_h__
#define __lcfuncs_h__

/* Client Side Prototypes */

/* gl Entry points */

void      APIENTRY __gllc_NewList                ( IN GLuint list, IN GLenum mode );
void      APIENTRY __gllc_EndList                ( void );
void      APIENTRY __gllc_CallList               ( IN GLuint list );
void      APIENTRY __gllc_CallLists              ( IN GLsizei n, IN GLenum type, IN const GLvoid *lists );
void      APIENTRY __gllc_DeleteLists            ( IN GLuint list, IN GLsizei range );
GLuint    APIENTRY __gllc_GenLists               ( IN GLsizei range );
void      APIENTRY __gllc_ListBase               ( IN GLuint base );
void      APIENTRY __gllc_Begin                  ( IN GLenum mode );
void      APIENTRY __gllc_Bitmap                 ( IN GLsizei width, IN GLsizei height, IN GLfloat xorig, IN GLfloat yorig, IN GLfloat xmove, IN GLfloat ymove, IN const GLubyte bitmap[] );
void      APIENTRY __gllc_Color3b                ( IN GLbyte red, IN GLbyte green, IN GLbyte blue );
void      APIENTRY __gllc_Color3bv               ( IN const GLbyte v[3] );
void      APIENTRY __gllc_Color3d                ( IN GLdouble red, IN GLdouble green, IN GLdouble blue );
void      APIENTRY __gllc_Color3dv               ( IN const GLdouble v[3] );
void      APIENTRY __gllc_Color3f                ( IN GLfloat red, IN GLfloat green, IN GLfloat blue );
void      APIENTRY __gllc_Color3fv               ( IN const GLfloat v[3] );
void      APIENTRY __gllc_Color3i                ( IN GLint red, IN GLint green, IN GLint blue );
void      APIENTRY __gllc_Color3iv               ( IN const GLint v[3] );
void      APIENTRY __gllc_Color3s                ( IN GLshort red, IN GLshort green, IN GLshort blue );
void      APIENTRY __gllc_Color3sv               ( IN const GLshort v[3] );
void      APIENTRY __gllc_Color3ub               ( IN GLubyte red, IN GLubyte green, IN GLubyte blue );
void      APIENTRY __gllc_Color3ubv              ( IN const GLubyte v[3] );
void      APIENTRY __gllc_Color3ui               ( IN GLuint red, IN GLuint green, IN GLuint blue );
void      APIENTRY __gllc_Color3uiv              ( IN const GLuint v[3] );
void      APIENTRY __gllc_Color3us               ( IN GLushort red, IN GLushort green, IN GLushort blue );
void      APIENTRY __gllc_Color3usv              ( IN const GLushort v[3] );
void      APIENTRY __gllc_Color4b                ( IN GLbyte red, IN GLbyte green, IN GLbyte blue, IN GLbyte alpha );
void      APIENTRY __gllc_Color4bv               ( IN const GLbyte v[4] );
void      APIENTRY __gllc_Color4d                ( IN GLdouble red, IN GLdouble green, IN GLdouble blue, IN GLdouble alpha );
void      APIENTRY __gllc_Color4dv               ( IN const GLdouble v[4] );
void      APIENTRY __gllc_Color4f                ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha );
void      APIENTRY __gllc_Color4fv               ( IN const GLfloat v[4] );
void      APIENTRY __gllc_Color4i                ( IN GLint red, IN GLint green, IN GLint blue, IN GLint alpha );
void      APIENTRY __gllc_Color4iv               ( IN const GLint v[4] );
void      APIENTRY __gllc_Color4s                ( IN GLshort red, IN GLshort green, IN GLshort blue, IN GLshort alpha );
void      APIENTRY __gllc_Color4sv               ( IN const GLshort v[4] );
void      APIENTRY __gllc_Color4ub               ( IN GLubyte red, IN GLubyte green, IN GLubyte blue, IN GLubyte alpha );
void      APIENTRY __gllc_Color4ubv              ( IN const GLubyte v[4] );
void      APIENTRY __gllc_Color4ui               ( IN GLuint red, IN GLuint green, IN GLuint blue, IN GLuint alpha );
void      APIENTRY __gllc_Color4uiv              ( IN const GLuint v[4] );
void      APIENTRY __gllc_Color4us               ( IN GLushort red, IN GLushort green, IN GLushort blue, IN GLushort alpha );
void      APIENTRY __gllc_Color4usv              ( IN const GLushort v[4] );
void      APIENTRY __gllc_EdgeFlag               ( IN GLboolean flag );
void      APIENTRY __gllc_EdgeFlagv              ( IN const GLboolean flag[1] );
void      APIENTRY __gllc_End                    ( void );
void      APIENTRY __gllc_Indexd                 ( IN GLdouble c );
void      APIENTRY __gllc_Indexdv                ( IN const GLdouble c[1] );
void      APIENTRY __gllc_Indexf                 ( IN GLfloat c );
void      APIENTRY __gllc_Indexfv                ( IN const GLfloat c[1] );
void      APIENTRY __gllc_Indexi                 ( IN GLint c );
void      APIENTRY __gllc_Indexiv                ( IN const GLint c[1] );
void      APIENTRY __gllc_Indexs                 ( IN GLshort c );
void      APIENTRY __gllc_Indexsv                ( IN const GLshort c[1] );
void      APIENTRY __gllc_Normal3b               ( IN GLbyte nx, IN GLbyte ny, IN GLbyte nz );
void      APIENTRY __gllc_Normal3bv              ( IN const GLbyte v[3] );
void      APIENTRY __gllc_Normal3d               ( IN GLdouble nx, IN GLdouble ny, IN GLdouble nz );
void      APIENTRY __gllc_Normal3dv              ( IN const GLdouble v[3] );
void      APIENTRY __gllc_Normal3f               ( IN GLfloat nx, IN GLfloat ny, IN GLfloat nz );
void      APIENTRY __gllc_Normal3fv              ( IN const GLfloat v[3] );
void      APIENTRY __gllc_Normal3i               ( IN GLint nx, IN GLint ny, IN GLint nz );
void      APIENTRY __gllc_Normal3iv              ( IN const GLint v[3] );
void      APIENTRY __gllc_Normal3s               ( IN GLshort nx, IN GLshort ny, IN GLshort nz );
void      APIENTRY __gllc_Normal3sv              ( IN const GLshort v[3] );
void      APIENTRY __gllc_RasterPos2d            ( IN GLdouble x, IN GLdouble y );
void      APIENTRY __gllc_RasterPos2dv           ( IN const GLdouble v[2] );
void      APIENTRY __gllc_RasterPos2f            ( IN GLfloat x, IN GLfloat y );
void      APIENTRY __gllc_RasterPos2fv           ( IN const GLfloat v[2] );
void      APIENTRY __gllc_RasterPos2i            ( IN GLint x, IN GLint y );
void      APIENTRY __gllc_RasterPos2iv           ( IN const GLint v[2] );
void      APIENTRY __gllc_RasterPos2s            ( IN GLshort x, IN GLshort y );
void      APIENTRY __gllc_RasterPos2sv           ( IN const GLshort v[2] );
void      APIENTRY __gllc_RasterPos3d            ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY __gllc_RasterPos3dv           ( IN const GLdouble v[3] );
void      APIENTRY __gllc_RasterPos3f            ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY __gllc_RasterPos3fv           ( IN const GLfloat v[3] );
void      APIENTRY __gllc_RasterPos3i            ( IN GLint x, IN GLint y, IN GLint z );
void      APIENTRY __gllc_RasterPos3iv           ( IN const GLint v[3] );
void      APIENTRY __gllc_RasterPos3s            ( IN GLshort x, IN GLshort y, IN GLshort z );
void      APIENTRY __gllc_RasterPos3sv           ( IN const GLshort v[3] );
void      APIENTRY __gllc_RasterPos4d            ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w );
void      APIENTRY __gllc_RasterPos4dv           ( IN const GLdouble v[4] );
void      APIENTRY __gllc_RasterPos4f            ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w );
void      APIENTRY __gllc_RasterPos4fv           ( IN const GLfloat v[4] );
void      APIENTRY __gllc_RasterPos4i            ( IN GLint x, IN GLint y, IN GLint z, IN GLint w );
void      APIENTRY __gllc_RasterPos4iv           ( IN const GLint v[4] );
void      APIENTRY __gllc_RasterPos4s            ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w );
void      APIENTRY __gllc_RasterPos4sv           ( IN const GLshort v[4] );
void      APIENTRY __gllc_Rectd                  ( IN GLdouble x1, IN GLdouble y1, IN GLdouble x2, IN GLdouble y2 );
void      APIENTRY __gllc_Rectdv                 ( IN const GLdouble v1[2], IN const GLdouble v2[2] );
void      APIENTRY __gllc_Rectf                  ( IN GLfloat x1, IN GLfloat y1, IN GLfloat x2, IN GLfloat y2 );
void      APIENTRY __gllc_Rectfv                 ( IN const GLfloat v1[2], IN const GLfloat v2[2] );
void      APIENTRY __gllc_Recti                  ( IN GLint x1, IN GLint y1, IN GLint x2, IN GLint y2 );
void      APIENTRY __gllc_Rectiv                 ( IN const GLint v1[2], IN const GLint v2[2] );
void      APIENTRY __gllc_Rects                  ( IN GLshort x1, IN GLshort y1, IN GLshort x2, IN GLshort y2 );
void      APIENTRY __gllc_Rectsv                 ( IN const GLshort v1[2], IN const GLshort v2[2] );
void      APIENTRY __gllc_TexCoord1d             ( IN GLdouble s );
void      APIENTRY __gllc_TexCoord1dv            ( IN const GLdouble v[1] );
void      APIENTRY __gllc_TexCoord1f             ( IN GLfloat s );
void      APIENTRY __gllc_TexCoord1fv            ( IN const GLfloat v[1] );
void      APIENTRY __gllc_TexCoord1i             ( IN GLint s );
void      APIENTRY __gllc_TexCoord1iv            ( IN const GLint v[1] );
void      APIENTRY __gllc_TexCoord1s             ( IN GLshort s );
void      APIENTRY __gllc_TexCoord1sv            ( IN const GLshort v[1] );
void      APIENTRY __gllc_TexCoord2d             ( IN GLdouble s, IN GLdouble t );
void      APIENTRY __gllc_TexCoord2dv            ( IN const GLdouble v[2] );
void      APIENTRY __gllc_TexCoord2f             ( IN GLfloat s, IN GLfloat t );
void      APIENTRY __gllc_TexCoord2fv            ( IN const GLfloat v[2] );
void      APIENTRY __gllc_TexCoord2i             ( IN GLint s, IN GLint t );
void      APIENTRY __gllc_TexCoord2iv            ( IN const GLint v[2] );
void      APIENTRY __gllc_TexCoord2s             ( IN GLshort s, IN GLshort t );
void      APIENTRY __gllc_TexCoord2sv            ( IN const GLshort v[2] );
void      APIENTRY __gllc_TexCoord3d             ( IN GLdouble s, IN GLdouble t, IN GLdouble r );
void      APIENTRY __gllc_TexCoord3dv            ( IN const GLdouble v[3] );
void      APIENTRY __gllc_TexCoord3f             ( IN GLfloat s, IN GLfloat t, IN GLfloat r );
void      APIENTRY __gllc_TexCoord3fv            ( IN const GLfloat v[3] );
void      APIENTRY __gllc_TexCoord3i             ( IN GLint s, IN GLint t, IN GLint r );
void      APIENTRY __gllc_TexCoord3iv            ( IN const GLint v[3] );
void      APIENTRY __gllc_TexCoord3s             ( IN GLshort s, IN GLshort t, IN GLshort r );
void      APIENTRY __gllc_TexCoord3sv            ( IN const GLshort v[3] );
void      APIENTRY __gllc_TexCoord4d             ( IN GLdouble s, IN GLdouble t, IN GLdouble r, IN GLdouble q );
void      APIENTRY __gllc_TexCoord4dv            ( IN const GLdouble v[4] );
void      APIENTRY __gllc_TexCoord4f             ( IN GLfloat s, IN GLfloat t, IN GLfloat r, IN GLfloat q );
void      APIENTRY __gllc_TexCoord4fv            ( IN const GLfloat v[4] );
void      APIENTRY __gllc_TexCoord4i             ( IN GLint s, IN GLint t, IN GLint r, IN GLint q );
void      APIENTRY __gllc_TexCoord4iv            ( IN const GLint v[4] );
void      APIENTRY __gllc_TexCoord4s             ( IN GLshort s, IN GLshort t, IN GLshort r, IN GLshort q );
void      APIENTRY __gllc_TexCoord4sv            ( IN const GLshort v[4] );
void      APIENTRY __gllc_Vertex2d               ( IN GLdouble x, IN GLdouble y );
void      APIENTRY __gllc_Vertex2dv              ( IN const GLdouble v[2] );
void      APIENTRY __gllc_Vertex2f               ( IN GLfloat x, IN GLfloat y );
void      APIENTRY __gllc_Vertex2fv              ( IN const GLfloat v[2] );
void      APIENTRY __gllc_Vertex2i               ( IN GLint x, IN GLint y );
void      APIENTRY __gllc_Vertex2iv              ( IN const GLint v[2] );
void      APIENTRY __gllc_Vertex2s               ( IN GLshort x, IN GLshort y );
void      APIENTRY __gllc_Vertex2sv              ( IN const GLshort v[2] );
void      APIENTRY __gllc_Vertex3d               ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY __gllc_Vertex3dv              ( IN const GLdouble v[3] );
void      APIENTRY __gllc_Vertex3f               ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY __gllc_Vertex3fv              ( IN const GLfloat v[3] );
void      APIENTRY __gllc_Vertex3i               ( IN GLint x, IN GLint y, IN GLint z );
void      APIENTRY __gllc_Vertex3iv              ( IN const GLint v[3] );
void      APIENTRY __gllc_Vertex3s               ( IN GLshort x, IN GLshort y, IN GLshort z );
void      APIENTRY __gllc_Vertex3sv              ( IN const GLshort v[3] );
void      APIENTRY __gllc_Vertex4d               ( IN GLdouble x, IN GLdouble y, IN GLdouble z, IN GLdouble w );
void      APIENTRY __gllc_Vertex4dv              ( IN const GLdouble v[4] );
void      APIENTRY __gllc_Vertex4f               ( IN GLfloat x, IN GLfloat y, IN GLfloat z, IN GLfloat w );
void      APIENTRY __gllc_Vertex4fv              ( IN const GLfloat v[4] );
void      APIENTRY __gllc_Vertex4i               ( IN GLint x, IN GLint y, IN GLint z, IN GLint w );
void      APIENTRY __gllc_Vertex4iv              ( IN const GLint v[4] );
void      APIENTRY __gllc_Vertex4s               ( IN GLshort x, IN GLshort y, IN GLshort z, IN GLshort w );
void      APIENTRY __gllc_Vertex4sv              ( IN const GLshort v[4] );
void      APIENTRY __gllc_ClipPlane              ( IN GLenum plane, IN const GLdouble equation[4] );
void      APIENTRY __gllc_ColorMaterial          ( IN GLenum face, IN GLenum mode );
void      APIENTRY __gllc_CullFace               ( IN GLenum mode );
void      APIENTRY __gllc_Fogf                   ( IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_Fogfv                  ( IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_Fogi                   ( IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_Fogiv                  ( IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_FrontFace              ( IN GLenum mode );
void      APIENTRY __gllc_Hint                   ( IN GLenum target, IN GLenum mode );
void      APIENTRY __gllc_Lightf                 ( IN GLenum light, IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_Lightfv                ( IN GLenum light, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_Lighti                 ( IN GLenum light, IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_Lightiv                ( IN GLenum light, IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_LightModelf            ( IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_LightModelfv           ( IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_LightModeli            ( IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_LightModeliv           ( IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_LineStipple            ( IN GLint factor, IN GLushort pattern );
void      APIENTRY __gllc_LineWidth              ( IN GLfloat width );
void      APIENTRY __gllc_Materialf              ( IN GLenum face, IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_Materialfv             ( IN GLenum face, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_Materiali              ( IN GLenum face, IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_Materialiv             ( IN GLenum face, IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_PointSize              ( IN GLfloat size );
void      APIENTRY __gllc_PolygonMode            ( IN GLenum face, IN GLenum mode );
void      APIENTRY __gllc_PolygonStipple         ( IN const GLubyte mask[] );
void      APIENTRY __gllc_Scissor                ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height );
void      APIENTRY __gllc_ShadeModel             ( IN GLenum mode );
void      APIENTRY __gllc_TexParameterf          ( IN GLenum target, IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_TexParameterfv         ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_TexParameteri          ( IN GLenum target, IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_TexParameteriv         ( IN GLenum target, IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_TexImage1D             ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY __gllc_TexImage2D             ( IN GLenum target, IN GLint level, IN GLint components, IN GLsizei width, IN GLsizei height, IN GLint border, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY __gllc_TexEnvf                ( IN GLenum target, IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_TexEnvfv               ( IN GLenum target, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_TexEnvi                ( IN GLenum target, IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_TexEnviv               ( IN GLenum target, IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_TexGend                ( IN GLenum coord, IN GLenum pname, IN GLdouble param );
void      APIENTRY __gllc_TexGendv               ( IN GLenum coord, IN GLenum pname, IN const GLdouble params[] );
void      APIENTRY __gllc_TexGenf                ( IN GLenum coord, IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_TexGenfv               ( IN GLenum coord, IN GLenum pname, IN const GLfloat params[] );
void      APIENTRY __gllc_TexGeni                ( IN GLenum coord, IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_TexGeniv               ( IN GLenum coord, IN GLenum pname, IN const GLint params[] );
void      APIENTRY __gllc_FeedbackBuffer         ( IN GLsizei size, IN GLenum type, OUT GLfloat buffer[] );
void      APIENTRY __gllc_SelectBuffer           ( IN GLsizei size, OUT GLuint buffer[] );
GLint     APIENTRY __gllc_RenderMode             ( IN GLenum mode );
void      APIENTRY __gllc_InitNames              ( void );
void      APIENTRY __gllc_LoadName               ( IN GLuint name );
void      APIENTRY __gllc_PassThrough            ( IN GLfloat token );
void      APIENTRY __gllc_PopName                ( void );
void      APIENTRY __gllc_PushName               ( IN GLuint name );
void      APIENTRY __gllc_DrawBuffer             ( IN GLenum mode );
void      APIENTRY __gllc_Clear                  ( IN GLbitfield mask );
void      APIENTRY __gllc_ClearAccum             ( IN GLfloat red, IN GLfloat green, IN GLfloat blue, IN GLfloat alpha );
void      APIENTRY __gllc_ClearIndex             ( IN GLfloat c );
void      APIENTRY __gllc_ClearColor             ( IN GLclampf red, IN GLclampf green, IN GLclampf blue, IN GLclampf alpha );
void      APIENTRY __gllc_ClearStencil           ( IN GLint s );
void      APIENTRY __gllc_ClearDepth             ( IN GLclampd depth );
void      APIENTRY __gllc_StencilMask            ( IN GLuint mask );
void      APIENTRY __gllc_ColorMask              ( IN GLboolean red, IN GLboolean green, IN GLboolean blue, IN GLboolean alpha );
void      APIENTRY __gllc_DepthMask              ( IN GLboolean flag );
void      APIENTRY __gllc_IndexMask              ( IN GLuint mask );
void      APIENTRY __gllc_Accum                  ( IN GLenum op, IN GLfloat value );
void      APIENTRY __gllc_Disable                ( IN GLenum cap );
void      APIENTRY __gllc_Enable                 ( IN GLenum cap );
void      APIENTRY __gllc_Finish                 ( void );
void      APIENTRY __gllc_Flush                  ( void );
void      APIENTRY __gllc_PopAttrib              ( void );
void      APIENTRY __gllc_PushAttrib             ( IN GLbitfield mask );
void      APIENTRY __gllc_Map1d                  ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint stride, IN GLint order, IN const GLdouble points[] );
void      APIENTRY __gllc_Map1f                  ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint stride, IN GLint order, IN const GLfloat points[] );
void      APIENTRY __gllc_Map2d                  ( IN GLenum target, IN GLdouble u1, IN GLdouble u2, IN GLint ustride, IN GLint uorder, IN GLdouble v1, IN GLdouble v2, IN GLint vstride, IN GLint vorder, IN const GLdouble points[] );
void      APIENTRY __gllc_Map2f                  ( IN GLenum target, IN GLfloat u1, IN GLfloat u2, IN GLint ustride, IN GLint uorder, IN GLfloat v1, IN GLfloat v2, IN GLint vstride, IN GLint vorder, IN const GLfloat points[] );
void      APIENTRY __gllc_MapGrid1d              ( IN GLint un, IN GLdouble u1, IN GLdouble u2 );
void      APIENTRY __gllc_MapGrid1f              ( IN GLint un, IN GLfloat u1, IN GLfloat u2 );
void      APIENTRY __gllc_MapGrid2d              ( IN GLint un, IN GLdouble u1, IN GLdouble u2, IN GLint vn, IN GLdouble v1, IN GLdouble v2 );
void      APIENTRY __gllc_MapGrid2f              ( IN GLint un, IN GLfloat u1, IN GLfloat u2, IN GLint vn, IN GLfloat v1, IN GLfloat v2 );
void      APIENTRY __gllc_EvalCoord1d            ( IN GLdouble u );
void      APIENTRY __gllc_EvalCoord1dv           ( IN const GLdouble u[1] );
void      APIENTRY __gllc_EvalCoord1f            ( IN GLfloat u );
void      APIENTRY __gllc_EvalCoord1fv           ( IN const GLfloat u[1] );
void      APIENTRY __gllc_EvalCoord2d            ( IN GLdouble u, IN GLdouble v );
void      APIENTRY __gllc_EvalCoord2dv           ( IN const GLdouble u[2] );
void      APIENTRY __gllc_EvalCoord2f            ( IN GLfloat u, IN GLfloat v );
void      APIENTRY __gllc_EvalCoord2fv           ( IN const GLfloat u[2] );
void      APIENTRY __gllc_EvalMesh1              ( IN GLenum mode, IN GLint i1, IN GLint i2 );
void      APIENTRY __gllc_EvalPoint1             ( IN GLint i );
void      APIENTRY __gllc_EvalMesh2              ( IN GLenum mode, IN GLint i1, IN GLint i2, IN GLint j1, IN GLint j2 );
void      APIENTRY __gllc_EvalPoint2             ( IN GLint i, IN GLint j );
void      APIENTRY __gllc_AlphaFunc              ( IN GLenum func, IN GLclampf ref );
void      APIENTRY __gllc_BlendFunc              ( IN GLenum sfactor, IN GLenum dfactor );
void      APIENTRY __gllc_LogicOp                ( IN GLenum opcode );
void      APIENTRY __gllc_StencilFunc            ( IN GLenum func, IN GLint ref, IN GLuint mask );
void      APIENTRY __gllc_StencilOp              ( IN GLenum fail, IN GLenum zfail, IN GLenum zpass );
void      APIENTRY __gllc_DepthFunc              ( IN GLenum func );
void      APIENTRY __gllc_PixelZoom              ( IN GLfloat xfactor, IN GLfloat yfactor );
void      APIENTRY __gllc_PixelTransferf         ( IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_PixelTransferi         ( IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_PixelStoref            ( IN GLenum pname, IN GLfloat param );
void      APIENTRY __gllc_PixelStorei            ( IN GLenum pname, IN GLint param );
void      APIENTRY __gllc_PixelMapfv             ( IN GLenum map, IN GLint mapsize, IN const GLfloat values[] );
void      APIENTRY __gllc_PixelMapuiv            ( IN GLenum map, IN GLint mapsize, IN const GLuint values[] );
void      APIENTRY __gllc_PixelMapusv            ( IN GLenum map, IN GLint mapsize, IN const GLushort values[] );
void      APIENTRY __gllc_ReadBuffer             ( IN GLenum mode );
void      APIENTRY __gllc_CopyPixels             ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum type );
void      APIENTRY __gllc_ReadPixels             ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, OUT GLvoid *pixels );
void      APIENTRY __gllc_DrawPixels             ( IN GLsizei width, IN GLsizei height, IN GLenum format, IN GLenum type, IN const GLvoid *pixels );
void      APIENTRY __gllc_GetBooleanv            ( IN GLenum pname, OUT GLboolean params[] );
void      APIENTRY __gllc_GetClipPlane           ( IN GLenum plane, OUT GLdouble equation[4] );
void      APIENTRY __gllc_GetDoublev             ( IN GLenum pname, OUT GLdouble params[] );
GLenum    APIENTRY __gllc_GetError               ( void );
void      APIENTRY __gllc_GetFloatv              ( IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetIntegerv            ( IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetLightfv             ( IN GLenum light, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetLightiv             ( IN GLenum light, IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetMapdv               ( IN GLenum target, IN GLenum query, OUT GLdouble v[] );
void      APIENTRY __gllc_GetMapfv               ( IN GLenum target, IN GLenum query, OUT GLfloat v[] );
void      APIENTRY __gllc_GetMapiv               ( IN GLenum target, IN GLenum query, OUT GLint v[] );
void      APIENTRY __gllc_GetMaterialfv          ( IN GLenum face, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetMaterialiv          ( IN GLenum face, IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetPixelMapfv          ( IN GLenum map, OUT GLfloat values[] );
void      APIENTRY __gllc_GetPixelMapuiv         ( IN GLenum map, OUT GLuint values[] );
void      APIENTRY __gllc_GetPixelMapusv         ( IN GLenum map, OUT GLushort values[] );
void      APIENTRY __gllc_GetPolygonStipple      ( OUT GLubyte mask[] );
const GLubyte * APIENTRY __gllc_GetString        ( IN GLenum name );
void      APIENTRY __gllc_GetTexEnvfv            ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetTexEnviv            ( IN GLenum target, IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetTexGendv            ( IN GLenum coord, IN GLenum pname, OUT GLdouble params[] );
void      APIENTRY __gllc_GetTexGenfv            ( IN GLenum coord, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetTexGeniv            ( IN GLenum coord, IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetTexImage            ( IN GLenum target, IN GLint level, IN GLenum format, IN GLenum type, OUT GLvoid *pixels );
void      APIENTRY __gllc_GetTexParameterfv      ( IN GLenum target, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetTexParameteriv      ( IN GLenum target, IN GLenum pname, OUT GLint params[] );
void      APIENTRY __gllc_GetTexLevelParameterfv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLfloat params[] );
void      APIENTRY __gllc_GetTexLevelParameteriv ( IN GLenum target, IN GLint level, IN GLenum pname, OUT GLint params[] );
GLboolean APIENTRY __gllc_IsEnabled              ( IN GLenum cap );
GLboolean APIENTRY __gllc_IsList                 ( IN GLuint list );
void      APIENTRY __gllc_DepthRange             ( IN GLclampd zNear, IN GLclampd zFar );
void      APIENTRY __gllc_Frustum                ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar );
void      APIENTRY __gllc_LoadIdentity           ( void );
void      APIENTRY __gllc_LoadMatrixf            ( IN const GLfloat m[16] );
void      APIENTRY __gllc_LoadMatrixd            ( IN const GLdouble m[16] );
void      APIENTRY __gllc_MatrixMode             ( IN GLenum mode );
void      APIENTRY __gllc_MultMatrixf            ( IN const GLfloat m[16] );
void      APIENTRY __gllc_MultMatrixd            ( IN const GLdouble m[16] );
void      APIENTRY __gllc_Ortho                  ( IN GLdouble left, IN GLdouble right, IN GLdouble bottom, IN GLdouble top, IN GLdouble zNear, IN GLdouble zFar );
void      APIENTRY __gllc_PopMatrix              ( void );
void      APIENTRY __gllc_PushMatrix             ( void );
void      APIENTRY __gllc_Rotated                ( IN GLdouble angle, IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY __gllc_Rotatef                ( IN GLfloat angle, IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY __gllc_Scaled                 ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY __gllc_Scalef                 ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY __gllc_Translated             ( IN GLdouble x, IN GLdouble y, IN GLdouble z );
void      APIENTRY __gllc_Translatef             ( IN GLfloat x, IN GLfloat y, IN GLfloat z );
void      APIENTRY __gllc_Viewport               ( IN GLint x, IN GLint y, IN GLsizei width, IN GLsizei height );
void      APIENTRY __gllc_AddSwapHintRectWIN     ( IN GLint x, IN GLint y, IN GLint width, IN GLint height );
void      APIENTRY __gllc_Indexub                ( IN GLubyte c );
void      APIENTRY __gllc_Indexubv               ( IN const GLubyte c[1] );
GLboolean APIENTRY __gllc_AreTexturesResident(GLsizei n, const GLuint *textures,
                                            GLboolean *residences);
void APIENTRY __gllc_BindTexture(GLenum target, GLuint texture);
void APIENTRY __gllc_CopyTexImage1D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLint border);
void APIENTRY __gllc_CopyTexImage2D(GLenum target, GLint level,
                                  GLenum internalformat, GLint x, GLint y,
                                  GLsizei width, GLsizei height, GLint border);
void APIENTRY __gllc_CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                     GLint x, GLint y, GLsizei width);
void APIENTRY __gllc_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                     GLint yoffset, GLint x, GLint y,
                                     GLsizei width, GLsizei height);
void APIENTRY __gllc_DeleteTextures(GLsizei n, const GLuint *textures);
void APIENTRY __gllc_GenTextures(GLsizei n, GLuint *textures);
GLboolean APIENTRY __gllc_IsTexture(GLuint texture);
void APIENTRY __gllc_PrioritizeTextures(GLsizei n, const GLuint *textures,
                                      const GLclampf *priorities);
void APIENTRY __gllc_TexSubImage1D(GLenum target, GLint level, GLint xoffset,
                                 GLsizei width, GLenum format, GLenum type,
                                 const GLvoid *pixels);
void APIENTRY __gllc_TexSubImage2D(GLenum target, GLint level, GLint xoffset,
                                 GLint yoffset, GLsizei width, GLsizei height,
                                 GLenum format, GLenum type,
                                 const GLvoid *pixels);

void APIENTRY __gllc_PolygonOffset (GLfloat factor, GLfloat units);

void APIENTRY __gllc_ColorTableEXT (GLenum target,
                                    GLenum internalFormat,
                                    GLsizei width,
                                    GLenum format,
                                    GLenum type,
                                    const GLvoid *data);
void APIENTRY __gllc_ColorSubTableEXT (GLenum target,
                                       GLsizei start,
                                       GLsizei count,
                                       GLenum format,
                                       GLenum type,
                                       const GLvoid *data);
void APIENTRY __gllc_ArrayElement(GLint i);
void APIENTRY __gllc_DrawArrays(GLenum mode, GLint first, GLsizei count);
void APIENTRY __gllc_DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
void APIENTRY __gllc_DrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

#ifdef GL_WIN_multiple_textures
void APIENTRY __gllc_CurrentTextureIndexWIN
    (GLuint index);
void APIENTRY __gllc_MultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s);
void APIENTRY __gllc_MultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY __gllc_MultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s);
void APIENTRY __gllc_MultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY __gllc_MultiTexCoord1iWIN
    (GLbitfield mask, GLint s);
void APIENTRY __gllc_MultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY __gllc_MultiTexCoord1sWIN
    (GLbitfield mask, GLshort s);
void APIENTRY __gllc_MultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY __gllc_MultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t);
void APIENTRY __gllc_MultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY __gllc_MultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t);
void APIENTRY __gllc_MultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY __gllc_MultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t);
void APIENTRY __gllc_MultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY __gllc_MultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t);
void APIENTRY __gllc_MultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY __gllc_MultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r);
void APIENTRY __gllc_MultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY __gllc_MultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r);
void APIENTRY __gllc_MultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY __gllc_MultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r);
void APIENTRY __gllc_MultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY __gllc_MultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r);
void APIENTRY __gllc_MultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY __gllc_MultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
void APIENTRY __gllc_MultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY __gllc_MultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
void APIENTRY __gllc_MultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY __gllc_MultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q);
void APIENTRY __gllc_MultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY __gllc_MultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q);
void APIENTRY __gllc_MultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY __gllc_BindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture);
void APIENTRY __gllc_NthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures

#endif /* __lcfuncs_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glteb.h ===
/******************************Module*Header*******************************\
* Module Name: glteb.h
*
* TEB related structures.
*
* Created: 12/27/1993
* Author: Hock San Lee [hockl]
*
* Copyright (c) 1993-96 Microsoft Corporation
\**************************************************************************/

#ifndef __GLTEB_H__
#define __GLTEB_H__

#include <gldrv.h> // Dispatch table sizes

#include "oleauto.h"
#include "exttable.h"

// OpenGL reserves a few entries in the NT TEB and allocates TLS storage to
// keep thread local states.
//
// In Win95, the NT TEB storage is not available in the TEB and is made
// part of its TLS storage.
//
// For code simplicity, a special NT_CURRENT_TEB macro is used to access
// fields that are defined in NT TEB.  Another macro CURRENT_GLTEBINFO is
// used to access the other fields.  This convention should be followed.

// Shared section size

#define SHARED_SECTION_SIZE     8192

// Number of entries in the extended dispatch table
#define GL_EXT_PROC_TABLE_SIZE      (sizeof(GLEXTDISPATCHTABLE)/sizeof(PROC))

// Offset of entries for extension functions.  This offset must
// be greater than all possible non-extension entries
#define GL_EXT_PROC_TABLE_OFFSET    OPENGL_VERSION_110_ENTRIES

typedef struct _GLTEBINFO {
    // glCltDispatchTable must be the first field for the assembly code to work.
    // We pad the table with an extra entry if necessary to make glMsgBatchInfo
    // start at a qword boundary.
    PVOID glCltDispatchTable[(OPENGL_VERSION_110_ENTRIES+GL_EXT_PROC_TABLE_SIZE+1)/2*2];

    // This field must be qword aligned!
    BYTE glMsgBatchInfo[SHARED_SECTION_SIZE];

#ifdef _WIN95_
    // These fields must match the NT TEB definitions!

    PVOID glDispatchTable[233]; // fast dispatch table
    ULONG glReserved1[29];      // POLYARRAY structure
    PVOID glReserved2;          // pointer to POLYMATERIAL structure
    PVOID glSectionInfo;        // generic server GC
    PVOID glSection;            // Not used
    PVOID glTable;              // Used only for NT x86
    PVOID glCurrentRC;          // generic client RC
    PVOID glContext;            // reserved by OpenGL ICD drivers
#endif // _WIN95_
} GLTEBINFO, *PGLTEBINFO;

extern DWORD dwTlsOffset;

#if !defined(_WIN95_)
#if defined(_WIN64)
#define TeglDispatchTable       0x9f0
#define TeglReserved1           0x1138
#define TeglReserved2           0x1220
#define TeglSectionInfo         0x1228
#define TeglSection             0x1230
#define TeglTable               0x1238
#define TeglCurrentRC           0x1240
#define TeglContext             0x1248
#else
#define TeglDispatchTable       0x7c4
#define TeglReserved1           0xb68
#define TeglPaTeb               0xbb0
#define TeglReserved2           0xbdc
#define TeglSectionInfo         0xbe0
#define TeglSection             0xbe4
#define TeglTable               0xbe8
#define TeglCurrentRC           0xbec
#define TeglContext             0xbf0
#endif
#endif

#if defined(_WIN95_) || !defined(_X86_)

// Use NT_CURRENT_TEB to access the fields defined in NT TEB only!
// Do not use it to access other fields such as glCltDispatchTable and
// glMsgBatchInfo.
// Use CURRENT_GLTEBINFO to access the fields *not* defined in NT TEB only!
// E.g. glCltDispatchTable and glMsgBatchInfo.

#ifdef _WIN95_
#define NT_CURRENT_TEB() \
    (*(PGLTEBINFO *)((PBYTE)NtCurrentTeb()+dwTlsOffset))
#else
#define NT_CURRENT_TEB() \
    (NtCurrentTeb())
#endif

#define CURRENT_GLTEBINFO() \
    (*(PGLTEBINFO *)((PBYTE)NtCurrentTeb()+dwTlsOffset))
#define SET_CURRENT_GLTEBINFO(pglti) \
    (*(PGLTEBINFO *)((PBYTE)NtCurrentTeb()+dwTlsOffset) = (pglti))

// Cached POLYARRAY structure.
#define GLTEB_CLTPOLYARRAY() \
    ((struct _POLYARRAY *)(NT_CURRENT_TEB()->glReserved1))

// Pointer to POLYMATERIAL structure.
#define GLTEB_CLTPOLYMATERIAL() \
    ((POLYMATERIAL *)(NT_CURRENT_TEB()->glReserved2))

#define GLTEB_SET_CLTPOLYMATERIAL(pm) \
    (NT_CURRENT_TEB()->glReserved2 = (PVOID)(pm))

// Table containing OpenGL function pointers for faster dispatch.  Use this
// table where possible.
#define GLTEB_CLTDISPATCHTABLE_FAST()                                   \
    ((PGLDISPATCHTABLE_FAST)(NT_CURRENT_TEB()->glDispatchTable))

// Client side RC structure.
#ifdef _WIN95_
#define GLTEB_CLTCURRENTRC()                                            \
    (NT_CURRENT_TEB() ? (PLRC)NT_CURRENT_TEB()->glCurrentRC : (PLRC)0)
#else
#define GLTEB_CLTCURRENTRC()                                            \
    ((PLRC)NT_CURRENT_TEB()->glCurrentRC)
#endif

#define GLTEB_SET_CLTCURRENTRC(RC)                                      \
    (NT_CURRENT_TEB()->glCurrentRC = (PVOID)(RC))

// Client driver private data.
#define GLTEB_CLTDRIVERSLOT()                                           \
    (NT_CURRENT_TEB()->glContext)

#define GLTEB_SET_CLTDRIVERSLOT(pv)                                     \
    (NT_CURRENT_TEB()->glContext = (pv))

#define GLTEB_SRVCONTEXT()                                              \
    ((struct __GLcontextRec *)(NT_CURRENT_TEB()->glSectionInfo))

#define GLTEB_SET_SRVCONTEXT(Context)                                   \
    (NT_CURRENT_TEB()->glSectionInfo = (PVOID)(Context))

#else // _WIN95_ || !_X86_

#pragma warning(disable:4035) // Function doesn't return a value

#define NT_CURRENT_TEB() \
    (NtCurrentTeb())
__inline PGLTEBINFO CURRENT_GLTEBINFO(void)
{
    __asm mov eax, [dwTlsOffset]
    __asm mov eax, fs:[eax]
}
__inline void SET_CURRENT_GLTEBINFO(PGLTEBINFO pglti)
{
    __asm mov eax, pglti
    __asm mov edx, [dwTlsOffset]
    __asm mov fs:[edx], eax
}

// Cached POLYARRAY structure.
// Returns cached linear pointer into TEB
__inline struct _POLYARRAY *GLTEB_CLTPOLYARRAY(void)
{
    __asm mov eax, fs:[TeglPaTeb]
}

// Pointer to POLYMATERIAL structure.
__inline struct _POLYMATERIAL *GLTEB_CLTPOLYMATERIAL(void)
{
    __asm mov eax, fs:[TeglReserved2]
}
__inline void GLTEB_SET_CLTPOLYMATERIAL(struct _POLYMATERIAL *pm)
{
    __asm mov eax, pm
    __asm mov fs:[TeglReserved2], eax
}

// Table containing OpenGL function pointers for faster dispatch.  Use this
// table where possible.
// Returns cached linear pointer into TEB
__inline struct _GLDISPATCHTABLE_FAST *GLTEB_CLTDISPATCHTABLE_FAST(void)
{
    __asm mov eax, fs:[TeglTable]
}

// Client side RC structure.
__inline struct _LRC *GLTEB_CLTCURRENTRC(void)
{
    __asm mov eax, fs:[TeglCurrentRC]
}
__inline void GLTEB_SET_CLTCURRENTRC(struct _LRC *RC)
{
    __asm mov eax, RC
    __asm mov fs:[TeglCurrentRC], eax
}

// Client driver private data.
__inline PVOID GLTEB_CLTDRIVERSLOT(void)
{
    __asm mov eax, fs:[TeglContext]
}
__inline void GLTEB_SET_CLTDRIVERSLOT(PVOID pv)
{
    __asm mov eax, pv
    __asm mov fs:[TeglContext], eax
}

__inline struct __GLcontextRec *GLTEB_SRVCONTEXT(void)
{
    __asm mov eax, fs:[TeglSectionInfo]
}
__inline void GLTEB_SET_SRVCONTEXT(struct __GLcontextRec *Context)
{
    __asm mov eax, Context
    __asm mov fs:[TeglSectionInfo], eax
}

#pragma warning(default:4035) // Reset to default

#endif // _WIN95_ || !_X86_

// Table containing all OpenGL API function pointers.
#define GLTEB_CLTDISPATCHTABLE()                                        \
    ((PGLDISPATCHTABLE)(CURRENT_GLTEBINFO()->glCltDispatchTable))

// Table containing all generic implementation's extension function pointers.
#define GLTEB_EXTDISPATCHTABLE()                                        \
    ((PGLEXTDISPATCHTABLE)(CURRENT_GLTEBINFO()->glCltDispatchTable+GL_EXT_PROC_TABLE_OFFSET))

// Command buffer for batching.
#define GLTEB_SHAREDMEMORYSECTION()                                     \
    ((GLMSGBATCHINFO *) (CURRENT_GLTEBINFO()->glMsgBatchInfo))

// OpenGL function return value subbatch storage

#define GLTEB_RETURNVALUE()                                             \
    GLTEB_SHAREDMEMORYSECTION()->ReturnValue

// Initialize both glCltDispatchTable and glDispatchTable with the new
// function pointers.
// glCltDispatchTable contains all OpenGL API function pointers followed
// by the generic implementation's extension function pointers.
// glDispatchTable contains a subset of OpenGL function pointers for "fast"
// dispatch.
extern void vInitTebCache(PVOID);
extern void SetCltProcTable(struct _GLCLTPROCTABLE *pgcpt,
                            struct _GLEXTPROCTABLE *pgept,
                            BOOL fForce);
extern void GetCltProcTable(struct _GLCLTPROCTABLE *pgcpt,
                            struct _GLEXTPROCTABLE *pgept,
                            BOOL fForce);

#endif /* __GLTEB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\glsrvspt.h ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

/* Server Side Sub Batching Procedure Table */


#ifndef __GLSRVSPT_H__
#define __GLSRVSPT_H__

// NOTE:
//   When adding a new server side function, you need to modify the following
//   files:
//
//   opengl\inc\glsrvspt.h
//   opengl\server\inc\dispatch.h
//   opengl\server\inc\imfuncs.h
//   opengl\server\generic\dispatch.c
//   opengl\server\wgl\driver.c
//   opengl\server\wgl\glsrvgs.c
//   opengl\server\wgl\glsrvspt.c
//   opengl\server\wgl\glsrvsb.h

typedef struct _GLSRVSBPROCTABLE {

/* First entry is Null and marks the last message */

    VOID (APIENTRY *NullEntry)( VOID );

/* gl Entry points */

    VOID * (FASTCALL *glsrvDrawPolyArray          )( __GLcontext *, IN GLMSG_DRAWPOLYARRAY          *pMsg );
    VOID * (FASTCALL *glsrvBitmap                 )( __GLcontext *, IN GLMSG_BITMAP                 *pMsg );
    VOID * (FASTCALL *glsrvColor4fv               )( __GLcontext *, IN GLMSG_COLOR4FV               *pMsg );
    VOID * (FASTCALL *glsrvEdgeFlag               )( __GLcontext *, IN GLMSG_EDGEFLAG               *pMsg );
    VOID * (FASTCALL *glsrvIndexf                 )( __GLcontext *, IN GLMSG_INDEXF                 *pMsg );
    VOID * (FASTCALL *glsrvNormal3fv              )( __GLcontext *, IN GLMSG_NORMAL3FV              *pMsg );
    VOID * (FASTCALL *glsrvRasterPos4fv           )( __GLcontext *, IN GLMSG_RASTERPOS4FV           *pMsg );
    VOID * (FASTCALL *glsrvTexCoord4fv            )( __GLcontext *, IN GLMSG_TEXCOORD4FV            *pMsg );
    VOID * (FASTCALL *glsrvClipPlane              )( __GLcontext *, IN GLMSG_CLIPPLANE              *pMsg );
    VOID * (FASTCALL *glsrvColorMaterial          )( __GLcontext *, IN GLMSG_COLORMATERIAL          *pMsg );
    VOID * (FASTCALL *glsrvCullFace               )( __GLcontext *, IN GLMSG_CULLFACE               *pMsg );
    VOID * (FASTCALL *glsrvAddSwapHintRectWIN     )( __GLcontext *, IN GLMSG_ADDSWAPHINTRECTWIN     *pMsg );
    VOID * (FASTCALL *glsrvFogfv                  )( __GLcontext *, IN GLMSG_FOGFV                  *pMsg );
    VOID * (FASTCALL *glsrvFrontFace              )( __GLcontext *, IN GLMSG_FRONTFACE              *pMsg );
    VOID * (FASTCALL *glsrvHint                   )( __GLcontext *, IN GLMSG_HINT                   *pMsg );
    VOID * (FASTCALL *glsrvLightfv                )( __GLcontext *, IN GLMSG_LIGHTFV                *pMsg );
    VOID * (FASTCALL *glsrvLightModelfv           )( __GLcontext *, IN GLMSG_LIGHTMODELFV           *pMsg );
    VOID * (FASTCALL *glsrvLineStipple            )( __GLcontext *, IN GLMSG_LINESTIPPLE            *pMsg );
    VOID * (FASTCALL *glsrvLineWidth              )( __GLcontext *, IN GLMSG_LINEWIDTH              *pMsg );
    VOID * (FASTCALL *glsrvMaterialfv             )( __GLcontext *, IN GLMSG_MATERIALFV             *pMsg );
    VOID * (FASTCALL *glsrvPointSize              )( __GLcontext *, IN GLMSG_POINTSIZE              *pMsg );
    VOID * (FASTCALL *glsrvPolygonMode            )( __GLcontext *, IN GLMSG_POLYGONMODE            *pMsg );
    VOID * (FASTCALL *glsrvPolygonStipple         )( __GLcontext *, IN GLMSG_POLYGONSTIPPLE         *pMsg );
    VOID * (FASTCALL *glsrvScissor                )( __GLcontext *, IN GLMSG_SCISSOR                *pMsg );
    VOID * (FASTCALL *glsrvShadeModel             )( __GLcontext *, IN GLMSG_SHADEMODEL             *pMsg );
    VOID * (FASTCALL *glsrvTexParameterfv         )( __GLcontext *, IN GLMSG_TEXPARAMETERFV         *pMsg );
    VOID * (FASTCALL *glsrvTexParameteriv         )( __GLcontext *, IN GLMSG_TEXPARAMETERIV         *pMsg );
    VOID * (FASTCALL *glsrvTexImage1D             )( __GLcontext *, IN GLMSG_TEXIMAGE1D             *pMsg );
    VOID * (FASTCALL *glsrvTexImage2D             )( __GLcontext *, IN GLMSG_TEXIMAGE2D             *pMsg );
    VOID * (FASTCALL *glsrvTexEnvfv               )( __GLcontext *, IN GLMSG_TEXENVFV               *pMsg );
    VOID * (FASTCALL *glsrvTexEnviv               )( __GLcontext *, IN GLMSG_TEXENVIV               *pMsg );
    VOID * (FASTCALL *glsrvTexGenfv               )( __GLcontext *, IN GLMSG_TEXGENFV               *pMsg );
    VOID * (FASTCALL *glsrvFeedbackBuffer         )( __GLcontext *, IN GLMSG_FEEDBACKBUFFER         *pMsg );
    VOID * (FASTCALL *glsrvSelectBuffer           )( __GLcontext *, IN GLMSG_SELECTBUFFER           *pMsg );
    VOID * (FASTCALL *glsrvRenderMode             )( __GLcontext *, IN GLMSG_RENDERMODE             *pMsg );
    VOID * (FASTCALL *glsrvInitNames              )( __GLcontext *, IN GLMSG_INITNAMES              *pMsg );
    VOID * (FASTCALL *glsrvLoadName               )( __GLcontext *, IN GLMSG_LOADNAME               *pMsg );
    VOID * (FASTCALL *glsrvPassThrough            )( __GLcontext *, IN GLMSG_PASSTHROUGH            *pMsg );
    VOID * (FASTCALL *glsrvPopName                )( __GLcontext *, IN GLMSG_POPNAME                *pMsg );
    VOID * (FASTCALL *glsrvPushName               )( __GLcontext *, IN GLMSG_PUSHNAME               *pMsg );
    VOID * (FASTCALL *glsrvDrawBuffer             )( __GLcontext *, IN GLMSG_DRAWBUFFER             *pMsg );
    VOID * (FASTCALL *glsrvClear                  )( __GLcontext *, IN GLMSG_CLEAR                  *pMsg );
    VOID * (FASTCALL *glsrvClearAccum             )( __GLcontext *, IN GLMSG_CLEARACCUM             *pMsg );
    VOID * (FASTCALL *glsrvClearIndex             )( __GLcontext *, IN GLMSG_CLEARINDEX             *pMsg );
    VOID * (FASTCALL *glsrvClearColor             )( __GLcontext *, IN GLMSG_CLEARCOLOR             *pMsg );
    VOID * (FASTCALL *glsrvClearStencil           )( __GLcontext *, IN GLMSG_CLEARSTENCIL           *pMsg );
    VOID * (FASTCALL *glsrvClearDepth             )( __GLcontext *, IN GLMSG_CLEARDEPTH             *pMsg );
    VOID * (FASTCALL *glsrvStencilMask            )( __GLcontext *, IN GLMSG_STENCILMASK            *pMsg );
    VOID * (FASTCALL *glsrvColorMask              )( __GLcontext *, IN GLMSG_COLORMASK              *pMsg );
    VOID * (FASTCALL *glsrvDepthMask              )( __GLcontext *, IN GLMSG_DEPTHMASK              *pMsg );
    VOID * (FASTCALL *glsrvIndexMask              )( __GLcontext *, IN GLMSG_INDEXMASK              *pMsg );
    VOID * (FASTCALL *glsrvAccum                  )( __GLcontext *, IN GLMSG_ACCUM                  *pMsg );
    VOID * (FASTCALL *glsrvDisable                )( __GLcontext *, IN GLMSG_DISABLE                *pMsg );
    VOID * (FASTCALL *glsrvEnable                 )( __GLcontext *, IN GLMSG_ENABLE                 *pMsg );
    VOID * (FASTCALL *glsrvPopAttrib              )( __GLcontext *, IN GLMSG_POPATTRIB              *pMsg );
    VOID * (FASTCALL *glsrvPushAttrib             )( __GLcontext *, IN GLMSG_PUSHATTRIB             *pMsg );
    VOID * (FASTCALL *glsrvAlphaFunc              )( __GLcontext *, IN GLMSG_ALPHAFUNC              *pMsg );
    VOID * (FASTCALL *glsrvBlendFunc              )( __GLcontext *, IN GLMSG_BLENDFUNC              *pMsg );
    VOID * (FASTCALL *glsrvLogicOp                )( __GLcontext *, IN GLMSG_LOGICOP                *pMsg );
    VOID * (FASTCALL *glsrvStencilFunc            )( __GLcontext *, IN GLMSG_STENCILFUNC            *pMsg );
    VOID * (FASTCALL *glsrvStencilOp              )( __GLcontext *, IN GLMSG_STENCILOP              *pMsg );
    VOID * (FASTCALL *glsrvDepthFunc              )( __GLcontext *, IN GLMSG_DEPTHFUNC              *pMsg );
    VOID * (FASTCALL *glsrvPixelZoom              )( __GLcontext *, IN GLMSG_PIXELZOOM              *pMsg );
    VOID * (FASTCALL *glsrvPixelTransferf         )( __GLcontext *, IN GLMSG_PIXELTRANSFERF         *pMsg );
    VOID * (FASTCALL *glsrvPixelTransferi         )( __GLcontext *, IN GLMSG_PIXELTRANSFERI         *pMsg );
    VOID * (FASTCALL *glsrvPixelStoref            )( __GLcontext *, IN GLMSG_PIXELSTOREF            *pMsg );
    VOID * (FASTCALL *glsrvPixelStorei            )( __GLcontext *, IN GLMSG_PIXELSTOREI            *pMsg );
    VOID * (FASTCALL *glsrvPixelMapfv             )( __GLcontext *, IN GLMSG_PIXELMAPFV             *pMsg );
    VOID * (FASTCALL *glsrvPixelMapuiv            )( __GLcontext *, IN GLMSG_PIXELMAPUIV            *pMsg );
    VOID * (FASTCALL *glsrvPixelMapusv            )( __GLcontext *, IN GLMSG_PIXELMAPUSV            *pMsg );
    VOID * (FASTCALL *glsrvReadBuffer             )( __GLcontext *, IN GLMSG_READBUFFER             *pMsg );
    VOID * (FASTCALL *glsrvCopyPixels             )( __GLcontext *, IN GLMSG_COPYPIXELS             *pMsg );
    VOID * (FASTCALL *glsrvReadPixels             )( __GLcontext *, IN GLMSG_READPIXELS             *pMsg );
    VOID * (FASTCALL *glsrvDrawPixels             )( __GLcontext *, IN GLMSG_DRAWPIXELS             *pMsg );
    VOID * (FASTCALL *glsrvGetBooleanv            )( __GLcontext *, IN GLMSG_GETBOOLEANV            *pMsg );
    VOID * (FASTCALL *glsrvGetClipPlane           )( __GLcontext *, IN GLMSG_GETCLIPPLANE           *pMsg );
    VOID * (FASTCALL *glsrvGetDoublev             )( __GLcontext *, IN GLMSG_GETDOUBLEV             *pMsg );
    VOID * (FASTCALL *glsrvGetError               )( __GLcontext *, IN GLMSG_GETERROR               *pMsg );
    VOID * (FASTCALL *glsrvGetFloatv              )( __GLcontext *, IN GLMSG_GETFLOATV              *pMsg );
    VOID * (FASTCALL *glsrvGetIntegerv            )( __GLcontext *, IN GLMSG_GETINTEGERV            *pMsg );
    VOID * (FASTCALL *glsrvGetLightfv             )( __GLcontext *, IN GLMSG_GETLIGHTFV             *pMsg );
    VOID * (FASTCALL *glsrvGetLightiv             )( __GLcontext *, IN GLMSG_GETLIGHTIV             *pMsg );
    VOID * (FASTCALL *glsrvGetMapdv               )( __GLcontext *, IN GLMSG_GETMAPDV               *pMsg );
    VOID * (FASTCALL *glsrvGetMapfv               )( __GLcontext *, IN GLMSG_GETMAPFV               *pMsg );
    VOID * (FASTCALL *glsrvGetMapiv               )( __GLcontext *, IN GLMSG_GETMAPIV               *pMsg );
    VOID * (FASTCALL *glsrvGetMaterialfv          )( __GLcontext *, IN GLMSG_GETMATERIALFV          *pMsg );
    VOID * (FASTCALL *glsrvGetMaterialiv          )( __GLcontext *, IN GLMSG_GETMATERIALIV          *pMsg );
    VOID * (FASTCALL *glsrvGetPixelMapfv          )( __GLcontext *, IN GLMSG_GETPIXELMAPFV          *pMsg );
    VOID * (FASTCALL *glsrvGetPixelMapuiv         )( __GLcontext *, IN GLMSG_GETPIXELMAPUIV         *pMsg );
    VOID * (FASTCALL *glsrvGetPixelMapusv         )( __GLcontext *, IN GLMSG_GETPIXELMAPUSV         *pMsg );
    VOID * (FASTCALL *glsrvGetPolygonStipple      )( __GLcontext *, IN GLMSG_GETPOLYGONSTIPPLE      *pMsg );
    VOID * (FASTCALL *glsrvGetTexEnvfv            )( __GLcontext *, IN GLMSG_GETTEXENVFV            *pMsg );
    VOID * (FASTCALL *glsrvGetTexEnviv            )( __GLcontext *, IN GLMSG_GETTEXENVIV            *pMsg );
    VOID * (FASTCALL *glsrvGetTexGendv            )( __GLcontext *, IN GLMSG_GETTEXGENDV            *pMsg );
    VOID * (FASTCALL *glsrvGetTexGenfv            )( __GLcontext *, IN GLMSG_GETTEXGENFV            *pMsg );
    VOID * (FASTCALL *glsrvGetTexGeniv            )( __GLcontext *, IN GLMSG_GETTEXGENIV            *pMsg );
    VOID * (FASTCALL *glsrvGetTexImage            )( __GLcontext *, IN GLMSG_GETTEXIMAGE            *pMsg );
    VOID * (FASTCALL *glsrvGetTexParameterfv      )( __GLcontext *, IN GLMSG_GETTEXPARAMETERFV      *pMsg );
    VOID * (FASTCALL *glsrvGetTexParameteriv      )( __GLcontext *, IN GLMSG_GETTEXPARAMETERIV      *pMsg );
    VOID * (FASTCALL *glsrvGetTexLevelParameterfv )( __GLcontext *, IN GLMSG_GETTEXLEVELPARAMETERFV *pMsg );
    VOID * (FASTCALL *glsrvGetTexLevelParameteriv )( __GLcontext *, IN GLMSG_GETTEXLEVELPARAMETERIV *pMsg );
    VOID * (FASTCALL *glsrvIsEnabled              )( __GLcontext *, IN GLMSG_ISENABLED              *pMsg );
    VOID * (FASTCALL *glsrvDepthRange             )( __GLcontext *, IN GLMSG_DEPTHRANGE             *pMsg );
    VOID * (FASTCALL *glsrvFrustum                )( __GLcontext *, IN GLMSG_FRUSTUM                *pMsg );
    VOID * (FASTCALL *glsrvLoadIdentity           )( __GLcontext *, IN GLMSG_LOADIDENTITY           *pMsg );
    VOID * (FASTCALL *glsrvLoadMatrixf            )( __GLcontext *, IN GLMSG_LOADMATRIXF            *pMsg );
    VOID * (FASTCALL *glsrvMatrixMode             )( __GLcontext *, IN GLMSG_MATRIXMODE             *pMsg );
    VOID * (FASTCALL *glsrvMultMatrixf            )( __GLcontext *, IN GLMSG_MULTMATRIXF            *pMsg );
    VOID * (FASTCALL *glsrvOrtho                  )( __GLcontext *, IN GLMSG_ORTHO                  *pMsg );
    VOID * (FASTCALL *glsrvPopMatrix              )( __GLcontext *, IN GLMSG_POPMATRIX              *pMsg );
    VOID * (FASTCALL *glsrvPushMatrix             )( __GLcontext *, IN GLMSG_PUSHMATRIX             *pMsg );
    VOID * (FASTCALL *glsrvRotatef                )( __GLcontext *, IN GLMSG_ROTATEF                *pMsg );
    VOID * (FASTCALL *glsrvScalef                 )( __GLcontext *, IN GLMSG_SCALEF                 *pMsg );
    VOID * (FASTCALL *glsrvTranslatef             )( __GLcontext *, IN GLMSG_TRANSLATEF             *pMsg );
    VOID * (FASTCALL *glsrvViewport               )( __GLcontext *, IN GLMSG_VIEWPORT               *pMsg );
    VOID * (FASTCALL *glsrvAreTexturesResident    )( __GLcontext *, IN GLMSG_ARETEXTURESRESIDENT    *pMsg);
    VOID * (FASTCALL *glsrvBindTexture            )( __GLcontext *, IN GLMSG_BINDTEXTURE            *pMsg);
    VOID * (FASTCALL *glsrvCopyTexImage1D         )( __GLcontext *, IN GLMSG_COPYTEXIMAGE1D         *pMsg);
    VOID * (FASTCALL *glsrvCopyTexImage2D         )( __GLcontext *, IN GLMSG_COPYTEXIMAGE2D         *pMsg);
    VOID * (FASTCALL *glsrvCopyTexSubImage1D      )( __GLcontext *, IN GLMSG_COPYTEXSUBIMAGE1D      *pMsg);
    VOID * (FASTCALL *glsrvCopyTexSubImage2D      )( __GLcontext *, IN GLMSG_COPYTEXSUBIMAGE2D      *pMsg);
    VOID * (FASTCALL *glsrvDeleteTextures         )( __GLcontext *, IN GLMSG_DELETETEXTURES         *pMsg);
    VOID * (FASTCALL *glsrvGenTextures            )( __GLcontext *, IN GLMSG_GENTEXTURES            *pMsg);
    VOID * (FASTCALL *glsrvIsTexture              )( __GLcontext *, IN GLMSG_ISTEXTURE              *pMsg);
    VOID * (FASTCALL *glsrvPrioritizeTextures     )( __GLcontext *, IN GLMSG_PRIORITIZETEXTURES     *pMsg);
    VOID * (FASTCALL *glsrvTexSubImage1D          )( __GLcontext *, IN GLMSG_TEXSUBIMAGE1D          *pMsg);
    VOID * (FASTCALL *glsrvTexSubImage2D          )( __GLcontext *, IN GLMSG_TEXSUBIMAGE2D          *pMsg);
    VOID * (FASTCALL *glsrvColorTableEXT          )( __GLcontext *, IN GLMSG_COLORTABLEEXT          *pMsg);
    VOID * (FASTCALL *glsrvColorSubTableEXT       )( __GLcontext *, IN GLMSG_COLORSUBTABLEEXT       *pMsg);
    VOID * (FASTCALL *glsrvGetColorTableEXT       )( __GLcontext *, IN GLMSG_GETCOLORTABLEEXT       *pMsg);
    VOID * (FASTCALL *glsrvGetColorTableParameterivEXT)( __GLcontext *, IN GLMSG_GETCOLORTABLEPARAMETERIVEXT *pMsg);
    VOID * (FASTCALL *glsrvGetColorTableParameterfvEXT)( __GLcontext *, IN GLMSG_GETCOLORTABLEPARAMETERFVEXT *pMsg);
    VOID * (FASTCALL *glsrvPolygonOffset          )( __GLcontext *, IN GLMSG_POLYGONOFFSET          *pMsg);
#ifdef GL_WIN_multiple_textures
    VOID *(FASTCALL *glsrvCurrentTextureIndexWIN)( __GLcontext *, IN GLMSG_CURRENTTEXTUREINDEXWIN *pMsg);
    VOID *(FASTCALL *glsrvBindNthTextureWIN)( __GLcontext *, IN GLMSG_BINDNTHTEXTUREWIN *pMsg);
    VOID *(FASTCALL *glsrvNthTexCombineFuncWIN)( __GLcontext *, IN GLMSG_NTHTEXCOMBINEFUNCWIN *pMsg);
#endif // GL_WIN_multiple_textures
} GLSRVSBPROCTABLE, *PGLSRVSBPROCTABLE;

#endif /* !__GLSRVSPT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\parray.h ===
#ifndef __PARRAY_H__
#define __PARRAY_H__

#include "phong.h"

// Number of polydata entries in the context.  Must be at least 32.
// It includes room for the polyarray entry and others.
// It's currently based on POLYDATA_BUFFER_SIZE+1 vertices of size 128
// fitting in 64K, which yields 511
#define POLYDATA_BUFFER_SIZE     511
// DrawElements expects at least this many vertices in the vertex buffer.
// It is the sum of the following (currently sum is 278):
//    Number of vertex entries in a batch
//    Number of entries used for index map
//    An extra vertex entry to prevent calling PolyArrayFlushPartialPrimitive
//        in the Vertex routines.
//    An entry for POLYARRAY
//    4 spare entries to be safe
// It is given by
//    VA_DRAWELEM_MAP_SIZE +
//    (VA_DRAWELEM_INDEX_SIZE + sizeof(POLYDATA) - 1) / sizeof(POLYDATA) +
//    1 + 1 + 4
#define MINIMUM_POLYDATA_BUFFER_SIZE    300

// Minimun number of polydata entries required before processing a primitive.
// Must be at least 16.
#define MIN_POLYDATA_BATCH_SIZE  68

#if !((MIN_POLYDATA_BATCH_SIZE <= MINIMUM_POLYDATA_BUFFER_SIZE) && \
      (MINIMUM_POLYDATA_BUFFER_SIZE <= POLYDATA_BUFFER_SIZE)       \
     )
#error "bad sizes\n"
#endif

// Maximun number of vertices handled by the polygon decomposer.
// It allocates stack space based on this constant.  It must be at least 6.
#define __GL_MAX_POLYGON_CLIP_SIZE   256

// The POLYMATERIAL structure contains an index to the next available
// __GLmatChange structure, an array of pointers to __GLmatChange arrays,
// and a pointer to an array of PDMATERIAL structures each containing
// pointers to the front and back material changes for each POLYDATA
// elements in vertex buffer.
//
// The __GLmatChange structures are used to record material changes to
// vertices in the vertex buffer.  Since there can be up to two material
// changes per vertex, we need up to (POLYDATA_BUFFER_SIZE * 2) material
// changes per rendering thread.
//
// The PDMATERIAL array is part of the POLYMATERIAL structure and follows
// the aMat field immediately.  Its elements correspond to the POLYDATA
// elements in the vertex buffer.
//
// To reduce memory requirement, the POLYMATERIAL structure keeps an array
// of pointers to __GLmatChange arrays.  Each __GLmatChange array of up to
// 4K size is allocated as needed.
//
// An iMat index is used to keep track of the next free __GLmatChange
// entry.  When the poly array buffer is flushed in glsbAttention, iMat
// is reset to 0.
//
// The POLYMATERIAL structure and its __GLmatChange arrays are part of
// a thread local storage and are freed when the thread exits.

#define POLYMATERIAL_ARRAY_SIZE       (4096 / sizeof(__GLmatChange))

// This structure is shared with MCD as MCDMATERIALCHANGE.
typedef struct __GLmatChangeRec {
    GLuint dirtyBits;
    __GLcolor ambient;
    __GLcolor diffuse;
    __GLcolor specular;
    __GLcolor emissive;
    __GLfloat shininess;
    __GLfloat cmapa, cmapd, cmaps;
} __GLmatChange;

// Pointers to front and back material change structures.  They are
// valid only when the POLYDATA_MATERIAL_FRONT or POLYDATA_MATERIAL_BACK
// flag of the corresponding POLYDATA in the vertex buffer is set.
//
// This structure is shared with MCD as MCDMATERIALCHANGES.
typedef struct {
    __GLmatChange *front;	// pointer to the front material changes
    __GLmatChange *back;	// pointer to the back material changes
} PDMATERIAL;

typedef struct _POLYMATERIAL {
    GLuint iMat;  // next available material structure for this command batch
    PDMATERIAL *pdMaterial0;	// pointer to the PDMATERIAL array
    GLuint aMatSize;		// number of aMat entries
    __GLmatChange *aMat[1];	// array of array of __GLmatChange structures
} POLYMATERIAL;

#ifdef GL_WIN_phong_shading

#define __GL_PHONG_FRONT_FIRST_VALID    0x00000001
#define __GL_PHONG_BACK_FIRST_VALID     0x00000002
#define __GL_PHONG_FRONT_TRAIL_VALID    0x00000004
#define __GL_PHONG_BACK_TRAIL_VALID     0x00000008


#define __GL_PHONG_FRONT_FIRST  0
#define __GL_PHONG_BACK_FIRST   1
#define __GL_PHONG_FRONT_TRAIL  2
#define __GL_PHONG_BACK_TRAIL   3


typedef struct __GLphongMaterialDataRec
{
    GLuint flags;
  __GLmatChange matChange[4];
} __GLphongMaterialData;

#endif //GL_WIN_phong_shading

/*
** Vertex structure.  Each vertex contains enough state to properly
** render the active primitive.  It is used by the front-end geometry
** and back-end rasterization pipelines.
**
** NOTE: Same as __GLvertex structure!
** NOTE: This structure is used by RasterPos and evaluator too!
**
** To minimize storage requirement, some front-end storage (e.g. obj and normal)
** is shared with back-end storage.
*/
typedef struct _POLYDATA {
    /*
    ** Keep this data structure aligned: have all vectors start on
    ** 4-word boundary, and sizeof this struct should be kept at
    ** a multiple of 4 words. Also helps to bunch together most
    ** frequently used items, helps cache.
    */

    /*
    ** Bits are set in this indicating which fields of the vertex are
    ** valid.  This field is shared with the back-end has field!
    */
    GLuint flags;

    /*
    ** Moved up here to keep GLcoords aligned.
    */
    __GLcolor *color;

    /*
    ** Clipping code mask.  One bit is set for each clipping plane that
    ** the vertex is out on.
    */
    GLuint clipCode;

    /*
    ** Fog value for the vertex.  This is only filled when doing cheap
    ** fogging.
    */
    __GLfloat fog;

    /*
    ** Coordinates straight from client. These fields may not be
    ** set depending on the active modes.  The normal and texture
    ** coordinate are used by lighting and texturing.  These cells
    ** may be overwritten by the eyeNormal and the generated texture
    ** coordinate, depending on the active modes.
    */
    /*
    ** Projected eye coodinate.  This field is filled in when the users
    ** eye coordinate has been multiplied by the projection matrix.
    */
    union
    {
        __GLcoord obj;
        __GLcoord clip;
    };

    /*
    ** Window coordinate. This field is filled in when the eye coordinate
    ** is converted to a drawing surface relative "window" coordinate.
    ** NOTE: the window.w coordinate contains 1/clip.w.
    */
    __GLcoord window;

    __GLcoord texture;
    __GLcoord normal;
    /*
    ** Colors.  colors[0] is the "front" color, colors[1] is the "back" color.
    ** The color pointer points to which color is current for this
    ** vertex.  Verticies can have more than one color when two sided
    ** lighting is enabled. (note color pointer moved up top).
    */
    __GLcolor colors[2];

    /*
    ** Eye coordinate. This field is filled in when the object coordinate
    ** has been multiplied by the model-view matrix.  If no eye coordinate
    ** was needed then this field contains undefined values.
    */
    union {
        __GLcoord eye;
        struct {
            __GLfloat eyeX;
            __GLfloat eyeZ;
            __GLfloat eyeY;
            union {
                __GLfloat eyeW;
                __GLcolor *lastColor;
            };
        };
    };

    /*
    ** On Win64 the POLYARRAY structure is larger than the POLYDATA
    ** structure since the later contains several pointers which are
    ** 8 bytes on the 64-bit system. Therefore, this structure must
    ** be padded to be the same size as the POLYARRAY structure.
    **
    ** N.B. Since the structure must be the same size as the __GLvertex
    **      structure, then that structure must also be padded.
    **
    */

#if defined(_WIN64)

    PVOID Filler[7];

#endif

} POLYDATA;

// This structure is used by RasterPos and evaluator too!
// This structure is also in the TEB!
typedef struct _POLYARRAY {
    // Flags for this batch.  Keep it first!
    GLuint flags;

    // Pointer to the next vertex in this batch.
    POLYDATA *pdNextVertex;

    // Pointer to the last vertex modifying the current color, RGBA or CI
    // depending on color mode, in this batch.
    POLYDATA *pdCurColor;

    // Pointer to the last vertex modifying normal coordinates in this batch.
    POLYDATA *pdCurNormal;

    // Pointer to the last vertex modifying texture coordinates in this batch.
    POLYDATA *pdCurTexture;

    // Pointer to the last vertex modifying edge flag in this batch.
    POLYDATA *pdCurEdgeFlag;

    // Pointer to the first vertex of this batch.
    // (pd0-1) points to this batch's POLYARRAY structure.
    POLYDATA *pd0;

    // Pointer to the flush vertex of this batch.
    POLYDATA *pdFlush;

    // Pointer to the vertex buffer entry in the gc for the next batch.
    POLYDATA *pdBufferNext;

    // Pointer to the first vertex buffer entry in the gc.
    POLYDATA *pdBuffer0;

    // Pointer to the last vertex buffer entry in the gc.
    POLYDATA *pdBufferMax;

    // In RGBA mode, otherColor.r is the last modified color index value in
    // this batch.  In CI mode, otherColor is the last modified RGBA color in
    // this batch.  Keep this field aligned!
    __GLcolor    otherColor;

    // Primitive type.
    GLenum primType;

    // Or result of all vertex clipCode's in this batch.
    GLuint  orClipCodes;

    // Pointer to the next message offset in the batching command buffer.
    // We use this offset to determine if 2 POLYARRAY's can be linked in
    // a DrawPolyArray command.
    ULONG        nextMsgOffset;

    // Linear pointer to this thread's TEB POLYARRAY, kept here
    // so the current POLYARRAY pointer can be retrieved from the
    // TEB with a single instruction
    struct _POLYARRAY *paTeb;

    // This is used to form a linked list of POLYARRAY data to be
    // processed in the DrawPolyArray command.
    struct _POLYARRAY *paNext;

    // Number of vertices in this primitive.
    GLint   nIndices;

    // Index map array defining vertex drawing order.  If NULL, the
    // vertex order starts from pd0 through (pdNextVertex-1).
    GLubyte *aIndices;

    // Fast pointer access to the shared command message buffer.
    PVOID   pMsgBatchInfo;

    // MCD Driver-private texture handle, or key
    DWORD textureKey;

    // And result of all vertex clipCode's in this batch.
    GLuint  andClipCodes;

    // Currently unused but space is reserved in the TEB for it
#ifdef GL_WIN_phong_shading
    // anankan: Using it to store a ptr to the Phong data store.
    __GLphongMaterialData *phong;
#else
    ULONG ulUnused[1];
#endif //GL_WIN_phong_shading
    POLYDATA *pdLastEvalColor;
    POLYDATA *pdLastEvalNormal;
    POLYDATA *pdLastEvalTexture;
} POLYARRAY;


// Special values for POLYARRAY members

// Initial value for aIndices
#define PA_aIndices_INITIAL_VALUE       ((GLubyte *) -1)
// Reset value for nextMsgOffset
#define PA_nextMsgOffset_RESET_VALUE    ((ULONG) -1)

/*
** Edge tag.  When POLYDATA_EDGEFLAG_BOUNDARY is set, this vertex and the next
** form a boundary edge on the primitive (polygon, tstrip, tfan, qstrip).
*/
#define POLYDATA_EDGEFLAG_BOUNDARY    	0x00000001 // must be 1, same as
						   // __GL_HAS_EDGEFLAG_BOUNDARY
#define POLYDATA_EDGEFLAG_VALID       	0x00000002
#define POLYDATA_COLOR_VALID        	0x00000004
#define POLYDATA_NORMAL_VALID       	0x00000008
#define POLYDATA_TEXTURE_VALID       	0x00000010
#define POLYDATA_VERTEX2           	0x00000020 // same as POLYARRAY_
#define POLYDATA_VERTEX3           	0x00000040 // same as POLYARRAY_
#define POLYDATA_VERTEX4           	0x00000080 // same as POLYARRAY_

/* flags for evaluators */
#define POLYDATA_EVALCOORD          	0x00000100 // same as POLYARRAY_
#define POLYDATA_EVAL_TEXCOORD         	0x00000200 // same as POLYARRAY_
#define POLYDATA_EVAL_NORMAL          	0x00000400 // same as POLYARRAY_
#define POLYDATA_EVAL_COLOR          	0x00000800 // same as POLYARRAY_

#define POLYDATA_DLIST_COLOR_4	    	0x00002000 // client side dlist flag
#define POLYDATA_FOG_VALID	        0x00004000 // same as __GL_HAS_FOG
                                    //  0x00008000 // reserved
#define POLYDATA_DLIST_TEXTURE1       	0x00100000 // client side dlist flag
#define POLYDATA_DLIST_TEXTURE2       	0x00200000 // client side dlist flag
#define POLYDATA_DLIST_TEXTURE3       	0x00400000 // client side dlist flag
#define POLYDATA_DLIST_TEXTURE4       	0x00800000 // client side dlist flag
#define POLYDATA_MATERIAL_FRONT    		0x10000000 // same as POLYARRAY_
#define POLYDATA_MATERIAL_BACK    		0x20000000 // same as POLYARRAY_
//
// This flag is valid when POLYARRAY_HAS_CULLED_VERTEX is set only.
// We have to process vertex when this flag set
//
#ifdef GL_EXT_cull_vertex
#define POLYDATA_VERTEX_USED            0x01000000
#endif //GL_EXT_cull_vertex

#define POLYARRAY_IN_BEGIN          	0x00000001
#define POLYARRAY_EYE_PROCESSED     	0x00000002
#define POLYARRAY_OTHER_COLOR          	0x00000004
#define POLYARRAY_PARTIAL_BEGIN        	0x00000008
#define POLYARRAY_PARTIAL_END          	0x00000010
#define POLYARRAY_VERTEX2           	0x00000020 // same as POLYDATA_
#define POLYARRAY_VERTEX3           	0x00000040 // same as POLYDATA_
#define POLYARRAY_VERTEX4           	0x00000080 // same as POLYDATA_

/* Recycling these flags for evaluators */
#define POLYARRAY_EVALCOORD 	   	    0x00000100 // same as POLYDATA_
#define POLYARRAY_EVAL_TEXCOORD	   	    0x00000200 // same as POLYDATA_
#define POLYARRAY_EVAL_NORMAL          	0x00000400 // same as POLYDATA_
#define POLYARRAY_EVAL_COLOR          	0x00000800 // same as POLYDATA_
#define POLYARRAY_REMOVE_PRIMITIVE  	0x00001000

//
// This flag is set when one of vertices has been culled by dot product
// between normal at the vertex and eye direction
//
#ifdef GL_EXT_cull_vertex
#define POLYARRAY_HAS_CULLED_VERTEX     0x02000000
#endif //GL_EXT_cull_vertex

#ifdef GL_WIN_phong_shading
#define POLYARRAY_PHONG_DATA_VALID      0x00002000
#endif //GL_WIN_phong_shading

#define POLYARRAY_RESET_STIPPLE	    	0x00004000
#define POLYARRAY_RENDER_PRIMITIVE  	0x00008000
#define POLYARRAY_SAME_POLYDATA_TYPE 	0x00010000
#define POLYARRAY_RASTERPOS          	0x00020000
#define POLYARRAY_SAME_COLOR_DATA	0x00040000
#define POLYARRAY_TEXTURE1          	0x00100000 // same as POLYDATA_DLIST_
#define POLYARRAY_TEXTURE2          	0x00200000 // same as POLYDATA_DLIST_
#define POLYARRAY_TEXTURE3          	0x00400000 // same as POLYDATA_DLIST_
#define POLYARRAY_TEXTURE4          	0x00800000 // same as POLYDATA_DLIST_
#define POLYARRAY_MATERIAL_FRONT    	0x10000000 // same as POLYDATA_
#define POLYARRAY_MATERIAL_BACK			0x20000000 // same as POLYDATA_
#define POLYARRAY_CLAMP_COLOR        	0x80000000 // must be 0x80000000

/************************************************************************/

GLuint FASTCALL PAClipCheckFrustum(__GLcontext *gc, POLYARRAY *pa,
                                   POLYDATA *pdLast);
GLuint FASTCALL PAClipCheckFrustum2D(__GLcontext *gc, POLYARRAY *pa,
                                     POLYDATA *pdLast);
GLuint FASTCALL PAClipCheckAll(__GLcontext *gc, POLYARRAY *pa,
                               POLYDATA *pdLast);

typedef void (FASTCALL *PFN_POLYARRAYCALCCOLORSKIP)
    (__GLcontext *, POLYARRAY *, GLint);
typedef void (FASTCALL *PFN_POLYARRAYCALCCOLOR)
    (__GLcontext *, GLint, POLYARRAY *, POLYDATA *, POLYDATA *);
typedef void (FASTCALL *PFN_POLYARRAYAPPLYCHEAPFOG)
    (__GLcontext *gc, POLYARRAY *pa);

void FASTCALL PolyArrayFillIndex0(__GLcontext *gc, POLYARRAY *pa, GLint face);
void FASTCALL PolyArrayFillColor0(__GLcontext *gc, POLYARRAY *pa, GLint face);

#ifdef GL_WIN_phong_shading
void FASTCALL PolyArrayPhongPropagateColorNormal(__GLcontext *gc,
                                                 POLYARRAY *pa);
#endif //GL_WIN_phong_shading

void FASTCALL PolyArrayCalcRGBColor(__GLcontext *gc, GLint face,
	POLYARRAY *pa, POLYDATA *pd1, POLYDATA *pd2);
void FASTCALL PolyArrayFastCalcRGBColor(__GLcontext *gc, GLint face,
	POLYARRAY *pa, POLYDATA *pd1, POLYDATA *pd2);
void FASTCALL PolyArrayZippyCalcRGBColor(__GLcontext *gc, GLint face,
	POLYARRAY *pa, POLYDATA *pd1, POLYDATA *pd2);
void FASTCALL PolyArrayCalcCIColor(__GLcontext *gc, GLint face,
	POLYARRAY *pa, POLYDATA *pd1, POLYDATA *pd2);
void FASTCALL PolyArrayFastCalcCIColor(__GLcontext *gc, GLint face,
	POLYARRAY *pa, POLYDATA *pd1, POLYDATA *pd2);
void FASTCALL PolyArrayCheapFogRGBColor(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayCheapFogCIColor(__GLcontext *gc, POLYARRAY *pa);
void FASTCALL PolyArrayFlushPartialPrimitive(void);
__GLmatChange * FASTCALL PAMatAlloc(void);
void FASTCALL FreePolyMaterial(void);
GLboolean FASTCALL PolyArrayAllocBuffer(__GLcontext *gc, GLuint nVertices);
GLvoid    FASTCALL PolyArrayFreeBuffer(__GLcontext *gc);
GLvoid    FASTCALL PolyArrayResetBuffer(__GLcontext *gc);
GLvoid    FASTCALL PolyArrayRestoreColorPointer(POLYARRAY *pa);

#endif /* __PARRAY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\mcd\client\debug.c ===
#include <windows.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

ULONG
DbgPrint(
    PCH DebugMessage,
    ...
    )
{
    va_list ap;
    char buffer[256];

    va_start(ap, DebugMessage);

    vsprintf(buffer, DebugMessage, ap);

    OutputDebugStringA(buffer);

    va_end(ap);

    return(0);
}

VOID NTAPI
DbgBreakPoint(VOID)
{
    DebugBreak();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\inc\subbatch.h ===
/******************************Module*Header*******************************\
* Module Name: subbatch.h
*
* OpenGL batching macros.
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef __SUBBATCH_H__
#define __SUBBATCH_H__

#ifdef DOGLMSGBATCHSTATS
#define STATS_INC_CLIENTCALLS()     (pMsgBatchInfo->BatchStats.ClientCalls++)
#else
#define STATS_INC_CLIENTCALLS()
#endif

// Put a message into shared area.  If it does not fit, flush what is
// currently in the buffer and then put the message at start of the buffer
//
// NOTE: glsbAttentionAlt() updates pMsgBatchInfo->NextOffset on return.
//       If you modify this macro, you have to fix the glsbAttentionAlt()
//       function!

#define GLCLIENT_BEGIN(ProcName,MsgStruct)                                  \
{                                                                           \
    GLMSGBATCHINFO *pMsgBatchInfo;                                          \
    GLMSG_##MsgStruct *pMsg;                                                \
    ULONG CurrentOffset;                                                    \
                                                                            \
    /* Get shared memory window from the TEB */                             \
    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();                            \
    STATS_INC_CLIENTCALLS();                                                \
                                                                            \
    /* Get and update the offset of the next message */                     \
    CurrentOffset = pMsgBatchInfo->NextOffset;                              \
    pMsgBatchInfo->NextOffset += GLMSG_ALIGN(sizeof(GLMSG_##MsgStruct));    \
                                                                            \
    /* Flush message if shared memory window is full */                     \
    if (pMsgBatchInfo->NextOffset > pMsgBatchInfo->MaximumOffset)           \
        CurrentOffset = glsbAttentionAlt(CurrentOffset);                    \
                                                                            \
    /* Add message to the batch */                                          \
    pMsg = (GLMSG_##MsgStruct *)(((BYTE *)pMsgBatchInfo) + CurrentOffset);  \
    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrv##ProcName);

#define GLCLIENT_END        }

// Large Messages have a variable amount of data associated with them.
// Unlike the non-clientside version, however, we will not attempt to
// copy the message into the buffer.  Instead, we will pass the pointer
// and flush.  Unlike CSR, we will not have to copy data in/out of a
// shared memory section to do this.

#define GLCLIENT_BEGIN_LARGE(bSet,ProcName,MsgStruct,pData,Size,OffData)    \
{                                                                           \
    GLMSGBATCHINFO *pMsgBatchInfo;                                          \
    GLMSG_##MsgStruct *pMsg;                                                \
    ULONG CurrentOffset;                                                    \
                                                                            \
    /* Get shared memory window from the TEB */                             \
    pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();                            \
    STATS_INC_CLIENTCALLS();                                                \
                                                                            \
    /* Get and update the offset of the next message */                     \
    CurrentOffset = pMsgBatchInfo->NextOffset;                              \
    pMsgBatchInfo->NextOffset += GLMSG_ALIGN(sizeof(GLMSG_##MsgStruct));    \
                                                                            \
    /* Flush message if shared memory window is full */                     \
    if (pMsgBatchInfo->NextOffset > pMsgBatchInfo->MaximumOffset)           \
        CurrentOffset = glsbAttentionAlt(CurrentOffset);                    \
                                                                            \
    /* Set up message header */                                             \
    pMsg = (GLMSG_##MsgStruct *)(((BYTE *)pMsgBatchInfo) + CurrentOffset);  \
    pMsg->ProcOffset = offsetof(GLSRVSBPROCTABLE, glsrv##ProcName);         \
    pMsg->##OffData = (ULONG_PTR) pData;                                        \
                                                                            \
    DBGLEVEL2(LEVEL_INFO, "GLCLIENT_BEGIN_LARGE %s pdata 0x%x\n",           \
        #ProcName, pData);

#define GLCLIENT_END_LARGE_SET                                              \
    glsbAttention();                                                        \
}

#define GLCLIENT_END_LARGE_GET                                              \
    glsbAttention();                                                        \
}

#define GLCLIENT_BEGIN_LARGE_SET(ProcName,MsgStruct,pData,Size,OffData)     \
        GLCLIENT_BEGIN_LARGE(TRUE,ProcName,MsgStruct,pData,Size,OffData)

#define GLCLIENT_BEGIN_LARGE_GET(ProcName,MsgStruct,pData,Size,OffData)     \
        GLCLIENT_BEGIN_LARGE(FALSE,ProcName,MsgStruct,pData,Size,OffData)

#define GLMSG_MEMCPY(dest,src,size)     memcpy(dest,src,size)

#endif /* !__SUBBATCH_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\mcd\client\debug.h ===
/******************************Module*Header*******************************\
* Module Name: debug.h
*
* MCD debugging macros.
*
* Created: 23-Jan-1996 14:40:34
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#ifndef __DEBUG_H__
#define __DEBUG_H__

void  DbgBreakPoint();
ULONG DbgPrint(PCH Format, ...);

#if DBG

#define MCDDEBUG_DISABLE_ALLOCBUF   0x00000001
#define MCDDEBUG_DISABLE_GETBUF     0x00000002
#define MCDDEBUG_DISABLE_PROCBATCH  0x00000004
#define MCDDEBUG_DISABLE_CLEAR      0x00000008

// These debug macros are useful for assertions.

#define WARNING(str)             DbgPrint("%s(%d): " str,__FILE__,__LINE__)
#define WARNING1(str,a)          DbgPrint("%s(%d): " str,__FILE__,__LINE__,a)
#define WARNING2(str,a,b)        DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b)
#define WARNING3(str,a,b,c)      DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b,c)
#define WARNING4(str,a,b,c,d)    DbgPrint("%s(%d): " str,__FILE__,__LINE__,a,b,c,d)
#define RIP(str)                 {WARNING(str); DbgBreakPoint();}
#define RIP1(str,a)              {WARNING1(str,a); DbgBreakPoint();}
#define RIP2(str,a,b)            {WARNING2(str,a,b); DbgBreakPoint();}
#define ASSERTOPENGL(expr,str)            if(!(expr)) RIP(str)
#define ASSERTOPENGL1(expr,str,a)         if(!(expr)) RIP1(str,a)
#define ASSERTOPENGL2(expr,str,a,b)       if(!(expr)) RIP2(str,a,b)

//
// Use DBGPRINT for general purpose debug message.
//

#define DBGPRINT(str)            DbgPrint("MCD: " str)
#define DBGPRINT1(str,a)         DbgPrint("MCD: " str,a)
#define DBGPRINT2(str,a,b)       DbgPrint("MCD: " str,a,b)
#define DBGPRINT3(str,a,b,c)     DbgPrint("MCD: " str,a,b,c)
#define DBGPRINT4(str,a,b,c,d)   DbgPrint("MCD: " str,a,b,c,d)
#define DBGPRINT5(str,a,b,c,d,e) DbgPrint("MCD: " str,a,b,c,d,e)

#else

#define WARNING(str)
#define WARNING1(str,a)
#define WARNING2(str,a,b)
#define WARNING3(str,a,b,c)
#define WARNING4(str,a,b,c,d)
#define RIP(str)
#define RIP1(str,a)
#define RIP2(str,a,b)
#define ASSERTOPENGL(expr,str)
#define ASSERTOPENGL1(expr,str,a)
#define ASSERTOPENGL2(expr,str,a,b)
#define DBGPRINT(str)
#define DBGPRINT1(str,a)
#define DBGPRINT2(str,a,b)
#define DBGPRINT3(str,a,b,c)
#define DBGPRINT4(str,a,b,c,d)
#define DBGPRINT5(str,a,b,c,d,e)

#endif

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\mcd\client\dllinit.c ===
/******************************Module*Header*******************************\
* Module Name: dllinit.c
*
* MCD library initialization routine(s).
*
* Created: 02-Apr-1996 21:25:47
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stddef.h>
#include <windows.h>
#include <wtypes.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <mcdesc.h>
#include "mcdrv.h"
#include <mcd2hack.h>
#include "mcd.h"
#include "mcdint.h"
#include "debug.h"

//
// Global flags read from the registry.
//

ULONG McdFlags = 0;
ULONG McdPrivateFlags = MCDPRIVATE_MCD_ENABLED;
#if DBG
ULONG McdDebugFlags = 0;
#endif

long GetMcdRegValue(HKEY hkMcd, REGSAM samAccess, LPSTR lpstrValueName,
                    long lDefaultData);
void GetMcdFlags(void);

#ifdef MCD95
//
// Local driver semaphore.
//

CRITICAL_SECTION gsemMcd;

extern MCDENGESCFILTERFUNC pMCDEngEscFilter;
#endif

/******************************Public*Routine******************************\
* McdDllInitialize
*
* This is the entry point for MCD32.DLL, which is called each time
* a process or thread that is linked to it is created or terminated.
*
\**************************************************************************/

BOOL McdDllInitialize(HMODULE hModule, ULONG Reason, PVOID Reserved)
{
    //
    // Suppress compiler warnings.
    //

    hModule;
    Reserved;

    //
    // Do appropriate attach/detach processing.
    //

    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:

#ifdef MCD95
        //
        // Initialize local driver semaphore.
        //

        __try 
        {
            InitializeCriticalSection(&gsemMcd);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;
        }

#endif

        //
        // On process attach, read setup information from registry.
        //

        GetMcdFlags();

#ifdef WINNT
        //
        // Quick hack to work around multimon problems.
        // If there's more than one monitor, completely disable
        // MCD.
        //

        if (GetSystemMetrics(SM_CMONITORS) > 1)
        {
            McdPrivateFlags &= ~MCDPRIVATE_MCD_ENABLED;
        }
#endif
        break;

    case DLL_PROCESS_DETACH:

#ifdef MCD95
        //
        // MCD is now closed!
        //

        pMCDEngEscFilter = (MCDENGESCFILTERFUNC) NULL;

        //
        // Delete local driver sempahore.
        //

        DeleteCriticalSection((LPCRITICAL_SECTION) &gsemMcd);
#endif

        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        //
        // Nothing to do yet for thread attach/detach.
        //

        break;

    default:
        break;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* MCDGetMcdCritSect__priv
*
* MCD95 ONLY
*
* Return pointer to local MCD semaphore.  Used to synchronize MCD32.DLL and
* MCDSRV32.DLL.
*
* Returns:
*   Pointer to semaphore.  Returns NULL on non-MCD95 builds.
*
* History:
*  18-Mar-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LPCRITICAL_SECTION APIENTRY MCDGetMcdCritSect__priv()
{
#ifdef MCD95
    return &gsemMcd;
#else
    return (LPCRITICAL_SECTION) NULL;
#endif
}

/******************************Public*Routine******************************\
* GetMcdRegValue
*
* Get the data for the specified value.  If the value cannot be found in
* the specified registry key or is of a type other than REG_DWORD, then
* the value is created (or recreated) with the supplied default data.
*
* History:
*  02-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

long GetMcdRegValue(HKEY hkMcd, REGSAM samAccess, LPSTR lpstrValueName,
                    long lDefaultData)
{
    DWORD dwDataType;
    DWORD cjSize;
    long  lData;

    //
    // For specified value, attempt to fetch the data.
    //

    cjSize = sizeof(long);
    if ( (RegQueryValueExA(hkMcd,
                           lpstrValueName,
                           (LPDWORD) NULL,
                           &dwDataType,
                           (LPBYTE) &lData,
                           &cjSize) != ERROR_SUCCESS)
         || (dwDataType != REG_DWORD) )
    {
        //
        // Since we couldn't get the data, create the value using the
        // specified default data.
        //

        if (samAccess & KEY_WRITE)
        {
            cjSize = sizeof(long);
            if ( (RegSetValueExA(hkMcd,
                                 lpstrValueName,
                                 0, // Reserved
                                 REG_DWORD,
                                 (BYTE *) &lDefaultData,
                                 cjSize) != ERROR_SUCCESS) )
            {
                DBGPRINT1("GetMcdRegValue: RegSetValueExA(%s) failed",
                          lpstrValueName);
            }
        }

        //
        // Whether or not the value was created in the registry key, return
        // the default data.
        //

        lData = lDefaultData;
    }

    return lData;
}


/******************************Public*Routine******************************\
* GetMcdFlags
*
* Fetch the MCD flags from the registry.
* If the registry entries do not exist, create them.
*
* History:
*  02-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

#define STR_MCDKEY      (PCSTR)"Software\\Microsoft\\Windows\\CurrentVersion\\MCD"
#define STR_ENABLE      (LPSTR)"Enable"
#define STR_SWAPSYNC    (LPSTR)"SwapSync"
#define STR_8BPP        (LPSTR)"Palettized Formats"
#define STR_IOPRIORITY  (LPSTR)"IO Priority"
#define STR_GENSTENCIL  (LPSTR)"Use Generic Stencil"
#define STR_EMULATEICD  (LPSTR)"Enumerate as ICD"
#define STR_DEBUG       (LPSTR)"Debug"

void GetMcdFlags()
{
    HKEY hkMcd;
    DWORD dwAction;
    REGSAM samAccess;
    ULONG ulDefMcdFlags;
    ULONG ulDefMcdFlagsPriv;
    long lTmp;

    //
    // Default values for McdFlags and McdPrivateFlags.
    // If you want to change the defaults, change them here!
    //

    ulDefMcdFlags = MCDCONTEXT_SWAPSYNC;
    ulDefMcdFlagsPriv = MCDPRIVATE_MCD_ENABLED |
                        MCDPRIVATE_PALETTEFORMATS |
                        MCDPRIVATE_USEGENERICSTENCIL;

    //
    // Set initial values.
    //

    McdFlags = 0;
#if DBG
    McdDebugFlags = 0;
#endif

    //
    // First try for read/write access.  Create the key
    // if necessary.
    //

    if ( RegCreateKeyExA(HKEY_LOCAL_MACHINE,
                         STR_MCDKEY,
                         0, // Reserved
                         (LPSTR) NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_READ | KEY_WRITE,
                         (LPSECURITY_ATTRIBUTES) NULL,
                         &hkMcd,
                         &dwAction) == ERROR_SUCCESS )
    {
        samAccess = KEY_READ | KEY_WRITE;
    }

    //
    // Next try read-only access.  Do not try to create
    // key.  Write permission is required to create and
    // we do not have that permission.
    //

    else if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                            STR_MCDKEY,
                            0, // Reserved
                            KEY_READ,
                            &hkMcd) == ERROR_SUCCESS )
    {
        samAccess = KEY_READ;
    }

    //
    // Finally, the key does not exist and we do not have
    // write access.  Fall back on the defaults and return.
    //

    else
    {
        McdFlags = ulDefMcdFlags;
        McdPrivateFlags = ulDefMcdFlagsPriv;

        return;
    }

    //
    // "Enable" value.  Default is 1 (enabled).
    //

    lTmp = (ulDefMcdFlagsPriv & MCDPRIVATE_MCD_ENABLED) ? 1:0;
    if (GetMcdRegValue(hkMcd, samAccess, STR_ENABLE, lTmp))
        McdPrivateFlags |= MCDPRIVATE_MCD_ENABLED;
    else
        McdPrivateFlags &= (~MCDPRIVATE_MCD_ENABLED);

    //
    // "SwapSync" value.  Default is 1 (enabled).
    //

    lTmp = (ulDefMcdFlags & MCDCONTEXT_SWAPSYNC) ? 1:0;
    lTmp = GetMcdRegValue(hkMcd, samAccess, STR_SWAPSYNC, lTmp);
    if (lTmp != 0)
    {
        McdFlags |= MCDCONTEXT_SWAPSYNC;
    }

    //
    // "Palettized Formats" value.  Default is 1 (enabled).
    //

    lTmp = (ulDefMcdFlagsPriv & MCDPRIVATE_PALETTEFORMATS) ? 1:0;
    lTmp = GetMcdRegValue(hkMcd, samAccess, STR_8BPP, lTmp);
    if (lTmp != 0)
    {
        McdPrivateFlags |= MCDPRIVATE_PALETTEFORMATS;
    }

    //
    // "IO Priority" value.  Default is 0 (disabled).
    //

    lTmp = (ulDefMcdFlags & MCDCONTEXT_IO_PRIORITY) ? 1:0;
    lTmp = GetMcdRegValue(hkMcd, samAccess, STR_IOPRIORITY, lTmp);
    if (lTmp != 0)
    {
        McdFlags |= MCDCONTEXT_IO_PRIORITY;
    }

    //
    // "Use Generic Stencil" value.  Default is 1 (enabled).
    //

    lTmp = (ulDefMcdFlagsPriv & MCDPRIVATE_USEGENERICSTENCIL) ? 1:0;
    lTmp = GetMcdRegValue(hkMcd, samAccess, STR_GENSTENCIL, lTmp);
    if (lTmp != 0)
    {
        McdPrivateFlags |= MCDPRIVATE_USEGENERICSTENCIL;
    }

    //
    // "Enumerate as ICD" value.  Default is 0 (disabled).
    //

    lTmp = (ulDefMcdFlagsPriv & MCDPRIVATE_EMULATEICD) ? 1:0;
    lTmp = GetMcdRegValue(hkMcd, samAccess, STR_EMULATEICD, lTmp);
    if (lTmp != 0)
    {
        McdPrivateFlags |= MCDPRIVATE_EMULATEICD;
    }

#if DBG
    //
    // "Debug" value.
    //
    // Unlike the other settings, we do not create the Debug value if
    // it does not exist.
    //

    {
        DWORD dwDataType;
        DWORD cjSize;

        cjSize = sizeof(long);
        if ( (RegQueryValueExA(hkMcd,
                               STR_DEBUG,
                               (LPDWORD) NULL,
                               &dwDataType,
                               (LPBYTE) &lTmp,
                               &cjSize) == ERROR_SUCCESS)
             && (dwDataType == REG_DWORD) )
        {
            McdDebugFlags = lTmp;
        }
    }
#endif

    //
    // We're done, so close the registry key.
    //

    RegCloseKey(hkMcd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\mcd\inc\mcd2hack.h ===
/******************************Module*Header*******************************\
* Module Name: mcdrv.h
*
* Server-side data structure for MCD driver interface.  These structures and
* values are used by the MCD driver to process calls made to the driver.
*
* Copyright (c) 1996-1997 Microsoft Corporation
*
* This is a private copy of mcdrv.h with all the 1.0 stuff
* stripped out.  It allows OpenGL to build for MCD 2.0 even though the
* public header file doesn't include the necessary information.
* Some things changed from 1.0 on and these cannot be redefined in
* a safe manner so they are not present here, causing some weirdness in
* the code but much less than ifdefing everything.
*
\**************************************************************************/

#ifndef _MCD2HACK_H
#define _MCD2HACK_H

#define MCD_MAX_LIGHTS              8

// MCDTEXTURE create flags
#define MCDTEXTURE_DIRECTDRAW_SURFACES          0x00000001


//
// Different matrix forms, for optimizing transforms.
// Types go from most general to least general.
//

// No information about matrix type
#define MCDMATRIX_GENERAL       0

// W row is 0 0 0 1
#define MCDMATRIX_W0001         1

// 2D matrix terms only
#define MCDMATRIX_2D            2

// 2D non-rotational matrix
#define MCDMATRIX_2DNR          3

// Identity
#define MCDMATRIX_IDENTITY      4

//
// A 4x4 matrix augmented with additional information about its layout.
//
// matrixType is one of the above matrix types.
// nonScaling is TRUE if the diagonal terms are one.
//

typedef struct _MCDMATRIX {
    MCDFLOAT matrix[4][4];
    ULONG matrixType;
    ULONG reserved[5];
    BOOL nonScaling;    
} MCDMATRIX;    


//
// Texture generation information for a single coordinate.
//

typedef struct _MCDTEXTURECOORDGENERATION {
    ULONG mode;
    MCDCOORD eyePlane;          // Given by program
    MCDCOORD eyePlaneInv;       // eyePlane transformed by modelview inverse
    MCDCOORD objectPlane;
} MCDTEXTURECOORDGENERATION;


//
// Light source description.
//

typedef struct _MCDLIGHT {
    MCDCOLOR ambient;           // Scaled
    MCDCOLOR diffuse;           // Scaled
    MCDCOLOR specular;          // Scaled
    MCDCOORD position;          // Given by program
    MCDCOORD positionEye;       // position transformed by modelview
    MCDCOORD direction;         // Given by program
    MCDCOORD directionInv;      // direction transformed by modelview inverse,
                                // normalized
    MCDFLOAT spotLightExponent;
    MCDFLOAT spotLightCutOffAngle;
    MCDFLOAT constantAttenuation;
    MCDFLOAT linearAttenuation;
    MCDFLOAT quadraticAttenuation;
} MCDLIGHT;


//
// Material description.
//

typedef struct _MCDMATERIAL {
    MCDCOLOR ambient;                   // Unscaled
    MCDCOLOR diffuse;                   // Unscaled
    MCDCOLOR specular;                  // Unscaled
    MCDCOLOR emissive;                  // Scaled
    MCDFLOAT specularExponent; 
    MCDFLOAT ambientColorIndex;
    MCDFLOAT diffuseColorIndex;
    MCDFLOAT specularColorIndex;
} MCDMATERIAL;


#define MCD_TEXTURE_TRANSFORM_STATE     20
#define MCD_TEXTURE_GENERATION_STATE    21
#define MCD_MATERIAL_STATE              22
#define MCD_LIGHT_SOURCE_STATE          23
#define MCD_COLOR_MATERIAL_STATE        24


// Texture transform state.
typedef struct _MCDTEXTURETRANSFORMSTATE {
    MCDMATRIX transform;
} MCDTEXTURETRANSFORMSTATE;

// Texture generation state.
typedef struct _MCDTEXTUREGENERATIONSTATE {
    MCDTEXTURECOORDGENERATION s, t, r, q;
} MCDTEXTUREGENERATIONSTATE;

// Material state.
typedef struct _MCDMATERIALSTATE {
    MCDMATERIAL materials[2];
} MCDMATERIALSTATE;
    
// Light source state.
typedef struct _MCDLIGHTSOURCESTATE {
    ULONG enables;
    ULONG changed;
    // Followed by one MCDLIGHT structure per set bit
    // in changed, starting from bit 0.  changed may be zero
    // if only the enables changed.
} MCDLIGHTSOURCESTATE;

// ColorMaterial state.
typedef struct _MCDCOLORMATERIALSTATE {
    ULONG face;
    ULONG mode;
} MCDCOLORMATERIALSTATE;
        

typedef struct _MCDRECTBUF {
    ULONG bufFlags;
    LONG  bufOffset;        // offset relative to beginning of framebuffer
    LONG  bufStride;
    RECTL bufPos;
} MCDRECTBUF;

typedef struct _MCDRECTBUFFERS {
    MCDRECTBUF mcdFrontBuf;
    MCDRECTBUF mcdBackBuf;
    MCDRECTBUF mcdDepthBuf;
} MCDRECTBUFFERS;


#define MCDSURFACE_DIRECT           0x00000002

// User-defined clip plane bits starting position
#define MCD_CLIP_USER0          0x00000040

#define MCDVERTEX_EDGEFLAG_VALID        0x00000002
#define MCDVERTEX_COLOR_VALID           0x00000004
#define MCDVERTEX_NORMAL_VALID          0x00000008
#define MCDVERTEX_TEXTURE_VALID         0x00000010
#define MCDVERTEX_VERTEX2               0x00000020 // same as MCDCOMMAND
#define MCDVERTEX_VERTEX3               0x00000040 // same as MCDCOMMAND
#define MCDVERTEX_VERTEX4               0x00000080 // same as MCDCOMMAND
#define MCDVERTEX_MATERIAL_FRONT    	0x10000000 // same as MCDCOMMAND
#define MCDVERTEX_MATERIAL_BACK    	0x20000000 // same as MCDCOMMAND

#define MCDCOMMAND_PRIMITIVE_CONTINUED  0x00000008
#define MCDCOMMAND_PRIMITIVE_INCOMPLETE 0x00000010
#define MCDCOMMAND_VERTEX2           	0x00000020 // same as MCDVERTEX
#define MCDCOMMAND_VERTEX3           	0x00000040 // same as MCDVERTEX
#define MCDCOMMAND_VERTEX4           	0x00000080 // same as MCDVERTEX
#define MCDCOMMAND_TEXTURE1          	0x00100000
#define MCDCOMMAND_TEXTURE2          	0x00200000
#define MCDCOMMAND_TEXTURE3          	0x00400000
#define MCDCOMMAND_TEXTURE4          	0x00800000
#define MCDCOMMAND_MATERIAL_FRONT    	0x10000000 // same as MCDVERTEX
#define MCDCOMMAND_MATERIAL_BACK    	0x20000000 // same as MCDVERTEX


//
// Primitive type bits for indicating what kinds of primitives are in
// a command batch:
//

#define MCDPRIM_POINTS_BIT              0x00000001
#define MCDPRIM_LINES_BIT               0x00000002
#define MCDPRIM_LINE_LOOP_BIT           0x00000004
#define MCDPRIM_LINE_STRIP_BIT          0x00000008
#define MCDPRIM_TRIANGLES_BIT           0x00000010
#define MCDPRIM_TRIANGLE_STRIP_BIT      0x00000020
#define MCDPRIM_TRIANGLE_FAN_BIT        0x00000040
#define MCDPRIM_QUADS_BIT               0x00000080
#define MCDPRIM_QUAD_STRIP_BIT          0x00000100
#define MCDPRIM_POLYGON_BIT             0x00000200


//
// Current transform information for MCD 2.0.
// The first matrix is the model-view matrix.
// The second matrix is the MV matrix composed with the current projection
// matrix.
//
// flags indicates whether the mvp matrix has changed since the last
// time it was presented to the driver.
//

#define MCDTRANSFORM_CHANGED    0x00000001

typedef struct _MCDTRANSFORM {
    MCDMATRIX matrix;
    MCDMATRIX mvp;
    ULONG flags;
} MCDTRANSFORM;


//
// Bit values for changes to materials.
//

#define MCDMATERIAL_AMBIENT		0x00000001
#define MCDMATERIAL_DIFFUSE		0x00000002
#define MCDMATERIAL_SPECULAR		0x00000004
#define MCDMATERIAL_EMISSIVE		0x00000008
#define MCDMATERIAL_SPECULAREXPONENT    0x00000010
#define MCDMATERIAL_COLORINDEXES	0x00000020
#define MCDMATERIAL_ALL		        0x0000003f

//
// Material change description.
//

typedef struct _MCDMATERIALCHANGE {
    ULONG dirtyBits;
    MCDCOLOR ambient;
    MCDCOLOR diffuse;
    MCDCOLOR specular;
    MCDCOLOR emissive;
    MCDFLOAT specularExponent; 
    MCDFLOAT ambientColorIndex;
    MCDFLOAT diffuseColorIndex;
    MCDFLOAT specularColorIndex;
} MCDMATERIALCHANGE;

//
// Material changes for both faces.
//

typedef struct _MCDMATERIALCHANGES {
    MCDMATERIALCHANGE *front, *back;
} MCDMATERIALCHANGES;


typedef int      (*MCDRVGETTEXTUREFORMATSFUNC)(MCDSURFACE *pMcdSurface,
                                               int nFmts,
                                               struct _DDSURFACEDESC *pddsd);
typedef ULONG_PTR (*MCDRVSWAPMULTIPLEFUNC)(SURFOBJ *pso,
                                          UINT cBuffers,
                                          MCDWINDOW **pMcdWindows,
                                          UINT *puiFlags);
typedef ULONG_PTR (*MCDRVPROCESSFUNC)(MCDSURFACE *pMCDSurface, MCDRC *pRc,
                                     MCDMEM *pMCDExecMem,
                                     UCHAR *pStart, UCHAR *pEnd,
                                     ULONG cmdFlagsAll, ULONG primFlags,
                                     MCDTRANSFORM *pMCDTransform,
                                     MCDMATERIALCHANGES *pMCDMatChanges);

#define MCDDRIVER_V11_SIZE      (MCDDRIVER_V10_SIZE+2*sizeof(void *))
#define MCDDRIVER_V20_SIZE      (MCDDRIVER_V11_SIZE+1*sizeof(void *))

#endif // _MCD2HACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\mcd\inc\mcdint.h ===
/******************************Module*Header*******************************\
* Module Name: mcdint.h
*
* Internal client/server-side data structure for MCD driver interface.
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

// Private flags for initialization (registry)

#define MCDPRIVATE_MCD_ENABLED          0x0001
#define MCDPRIVATE_PALETTEFORMATS       0x0002
#define MCDPRIVATE_USEGENERICSTENCIL    0x0004
#define MCDPRIVATE_EMULATEICD           0x0008

#ifdef MCD95
// Cross-process named mutex.

#define MCDMUTEXNAME    TEXT("MCDSRV32 Interprocess Synchronization Object")
#endif

// Internal command codes

#define MCD_DESCRIBEPIXELFORMAT     0x10001
#define MCD_DRIVERINFO              0x10002
#define MCD_ALLOC                   0x10003
#define MCD_FREE                    0x10004
#define MCD_STATE                   0x10005
#define MCD_VIEWPORT                0x10006
#define MCD_QUERYMEMSTATUS          0x10007
#define MCD_READSPAN                0x10008
#define MCD_WRITESPAN               0x10009
#define MCD_CLEAR                   0x1000a
#define MCD_SWAP                    0x1000b
#define MCD_SCISSOR                 0x1000c
#define MCD_DELETERC                0x1000d
#define MCD_GETBUFFERS              0x1000e
#define MCD_ALLOCBUFFERS            0x1000f
#define MCD_LOCK                    0x10010
#define MCD_UNLOCK                  0x10011
#define MCD_BINDCONTEXT		    0x10012
#define MCD_SYNC		    0x10013
#define MCD_CREATE_TEXTURE          0x10014
#define MCD_DELETE_TEXTURE          0x10015
#define MCD_UPDATE_SUB_TEXTURE      0x10016
#define MCD_UPDATE_TEXTURE_PALETTE  0x10017
#define MCD_UPDATE_TEXTURE_PRIORITY 0x10018
#define MCD_UPDATE_TEXTURE_STATE    0x10019
#define MCD_TEXTURE_STATUS          0x1001a
#define MCD_GET_TEXTURE_KEY         0x1001b
#define MCD_DESCRIBELAYERPLANE      0x1001c
#define MCD_SETLAYERPALETTE         0x1001d
#define MCD_DRAW_PIXELS             0x1001e
#define MCD_READ_PIXELS             0x1001f
#define MCD_COPY_PIXELS             0x10020
#define MCD_PIXEL_MAP               0x10021
#define MCD_DESTROY_WINDOW          0x10022
#define MCD_GET_TEXTURE_FORMATS     0x10023
#define MCD_SWAP_MULTIPLE           0x10024
#define MCD_PROCESS                 0x10025

// Internal command structures for calling through client-server layer

typedef struct _MCDCREATECONTEXT {
    // Must be first element for MCDESC compatibility.
    MCDESC_CREATE_CONTEXT escCreate;
    int ipfd;
    int iLayer;
    ULONG mcdFlags;
    MCDRCINFOPRIV *pRcInfo;
} MCDCREATECONTEXT;

typedef struct _MCDCMDI {
    ULONG command;
} MCDCMDI;

typedef struct _MCDDRIVERINFOCMDI {
    ULONG command;
} MCDDRIVERINFOCMDI;

typedef struct _MCDPIXELFORMATCMDI {
    ULONG command;
    LONG iPixelFormat;
} MCDPIXELFORMATCMDI;

typedef struct _MCDALLOCCMDI {
    ULONG command;
    ULONG sourceProcessID;
    ULONG numBytes;
    ULONG flags;
} MCDALLOCCMDI;

typedef struct _MCDFREECMDI {
    ULONG command;
    HANDLE hMCDMem;
} MCDFREECMDI;

typedef struct _MCDSTATECMDI {
    ULONG command;
    ULONG numStates;
    MCDSTATE *pNextState;
    MCDSTATE *pMaxState;
} MCDSTATECMDI;

typedef struct _MCDVIEWPORTCMDI {
    ULONG command;
    MCDVIEWPORT MCDViewport;
} MCDVIEWPORTCMDI;

typedef struct _MCDMEMSTATUSCMDI {
    ULONG command;
    MCDHANDLE hMCDMem;
} MCDMEMSTATUSCMDI;

typedef struct _MCDSPANCMDI {
    ULONG command;
    HANDLE hMem;
    MCDSPAN MCDSpan;
} MCDSPANCMDI;

typedef struct _MCDCLEARCMDI {
    ULONG command;
    ULONG buffers;
} MCDCLEARCMDI;

typedef struct _MCDSCISSORCMDI {
    ULONG command;
    RECTL rect;
    BOOL bEnabled;
} MCDSCISSORCMDI;

typedef struct _MCDSWAPCMDI {
    ULONG command;
    ULONG flags;
} MCDSWAPCMDI;

typedef struct _MCDDELETERCCMDI {
    ULONG command;
} MCDDELETERCCMDI;

typedef struct _MCDGETBUFFERSCMDI {
    ULONG command;
    BOOL getRect;
} MCDGETBUFFERSCMDI;

typedef struct _MCDALLOCBUFFERSCMDI {
    ULONG command;
    RECTL WndRect;
} MCDALLOCBUFFERSCMDI;

typedef struct _MCDLOCKCMDI {
    ULONG command;
} MCDLOCKCMDI;

typedef struct _MCDBINDCONTEXTCMDI {
    ULONG command;
    HWND hWnd;
} MCDBINDCONTEXTCMDI;

typedef struct _MCDSYNCCMDI {
    ULONG command;
} MCDSYNCCMDI;

typedef struct _MCDCREATETEXCMDI {
    ULONG command;
    MCDTEXTUREDATA *pTexData;
    ULONG flags;
    VOID *pSurface;
} MCDCREATETEXCMDI;

typedef struct _MCDDELETETEXCMDI {
    ULONG command;
    MCDHANDLE hTex;
} MCDDELETETEXCMDI;

typedef struct _MCDUPDATESUBTEXCMDI {
    ULONG command;
    MCDHANDLE hTex;
    MCDTEXTUREDATA *pTexData;
    ULONG lod;
    RECTL rect;
} MCDUPDATESUBTEXCMDI;

typedef struct _MCDUPDATETEXPALETTECMDI {
    ULONG command;
    MCDHANDLE hTex;
    MCDTEXTUREDATA *pTexData;
    ULONG start;
    ULONG numEntries;
} MCDUPDATETEXPALETTECMDI;
    
typedef struct _MCDUPDATETEXPRIORITYCMDI {
    ULONG command;
    MCDHANDLE hTex;
    MCDTEXTUREDATA *pTexData;
} MCDUPDATETEXPRIORITYCMDI;
  
typedef struct _MCDUPDATETEXSTATECMDI {
    ULONG command;
    MCDHANDLE hTex;
    MCDTEXTUREDATA *pTexData;
} MCDUPDATETEXSTATECMDI;
  
typedef struct _MCDTEXSTATUSCMDI {
    ULONG command;
    MCDHANDLE hTex;
} MCDTEXSTATUSCMDI;

typedef struct _MCDTEXKEYCMDI {
    ULONG command;
    MCDHANDLE hTex;
} MCDTEXKEYCMDI;

typedef struct _MCDLAYERPLANECMDI {
    ULONG command;
    LONG iPixelFormat;
    LONG iLayerPlane;
} MCDLAYERPLANECMDI;

typedef struct _MCDSETLAYERPALCMDI {
    ULONG command;
    LONG iLayerPlane;
    BOOL bRealize;
    LONG cEntries;
    COLORREF acr[1];
} MCDSETLAYERPALCMDI;

typedef struct _MCDDRAWPIXELSCMDI {
    ULONG command;
    ULONG width;
    ULONG height;
    ULONG format;
    ULONG type;
    BOOL  packed;
    VOID *pPixels;
} MCDDRAWPIXELSCMDI;

typedef struct _MCDREADPIXELSCMDI {
    ULONG command;
    LONG  x;
    LONG  y;
    ULONG width;
    ULONG height;
    ULONG format;
    ULONG type;
    VOID *pPixels;
} MCDREADPIXELSCMDI;

typedef struct _MCDCOPYPIXELSCMDI {
    ULONG command;
    LONG  x;
    LONG  y;
    ULONG width;
    ULONG height;
    ULONG format;
    ULONG type;
} MCDCOPYPIXELSCMDI;

typedef struct _MCDPIXELMAPCMDI {
    ULONG command;
    ULONG mapType;
    ULONG mapSize;
    VOID *pMap;
} MCDPIXELMAPCMDI;

typedef struct _MCDDESTROYWINDOWCMDI {
    ULONG command;
} MCDDESTROYWINDOWCMDI;

typedef struct _MCDGETTEXTUREFORMATSCMDI {
    ULONG command;
    int nFmts;
} MCDGETTEXTUREFORMATSCMDI;

typedef struct _MCDSWAPMULTIPLECMDI {
    ULONG command;
    UINT cBuffers;
    UINT auiFlags[MCDESC_MAX_EXTRA_WNDOBJ];
    ULONG_PTR adwMcdWindow[MCDESC_MAX_EXTRA_WNDOBJ];
} MCDSWAPMULTIPLECMDI;

typedef struct _MCDPROCESSCMDI {
    ULONG command;
    HANDLE hMCDPrimMem;
    MCDCOMMAND *pMCDFirstCmd;
    ULONG cmdFlagsAll;
    ULONG primFlags;
    MCDTRANSFORM *pMCDTransform;
    MCDMATERIALCHANGES *pMCDMatChanges;
} MCDPROCESSCMDI;

// Internal client-side memory structure

typedef struct _MCDMEMHDRI {
    ULONG flags;
    ULONG numBytes;
    VOID *maxMem;
    HANDLE hMCDMem;
    UCHAR *pMaxMem;
    UCHAR *pBase;
    MCDCONTEXT *pMCDContext;
} MCDMEMHDRI;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\mcd\inc\mcd.h ===
/******************************Module*Header*******************************\
* Module Name: mcd.h
*
* Common data structures for MCD driver interface.
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#ifndef _MCD_H
#define _MCD_H

//
// Maximum MCD scanline size assumed by OpenGL generic implementation.
//
#define MCD_MAX_SCANLINE    4096

#define MCD_MEM_READY   0x0001
#define MCD_MEM_BUSY    0x0002
#define MCD_MEM_INVALID 0x0003

#define MCD_MAXMIPMAPLEVEL 12

typedef struct _MCDCONTEXT {
    HDC hdc;
    MCDHANDLE hMCDContext;
    LONG ipfd;
    LONG iLayer;
    ULONG_PTR dwMcdWindow;
} MCDCONTEXT;

typedef struct _MCDRCINFOPRIV {
    MCDRCINFO mri;
    ULONG_PTR dwMcdWindow;
} MCDRCINFOPRIV;

typedef struct _GENMCDSWAP
{
    struct GLGENwindowRec *pwnd;
    WGLSWAP *pwswap;
} GENMCDSWAP;

typedef struct _GENMCDSTATE_ GENMCDSTATE;

//
// Shared memory allocated/freed via MCDAlloc and MCDFree, respectively.
//

typedef struct _GENMCDBUF_ {
    PVOID pv;
    ULONG size;
    HANDLE hmem;
} GENMCDBUF;

//
// The GENMCDSURFACE retains information about the state of the MCD buffers
// or surface.  It exists per-WNDOBJ (window).
//

typedef struct _GENMCDSURFACE_ {
    GENMCDBUF  McdColorBuf;     // Color and depth span buffers used to
    GENMCDBUF  McdDepthBuf;     // read/write MCD buffers if not directly
                                // accessible.

    ULONG *pDepthSpan;          // Interchange buffer to present z-span in
                                // generic format.  If McdDepthBuf is 32-bit,
                                // then this points to it (reformatted in
                                // place).  If 16-bit, then the interchange
                                // buffer is allocated separately.

    ULONG      depthBitMask;

    struct GLGENwindowRec *pwnd;          // WNDOBJ this surface is bound to.

} GENMCDSURFACE;

//
// The GENMCDSTATE retains information about the state of the MCD context.
// It exists per-context.
//

typedef struct _GENMCDSTATE_ {
    MCDCONTEXT McdContext;      // Created via MCDCreateContext.
                                // NOTE: This must be the first field.

    GENMCDSURFACE *pMcdSurf;    // pointer to MCD surface

    GENMCDBUF  *pMcdPrimBatch;  // Current shared memory window for batching
                                // primitives

    GENMCDBUF  McdCmdBatch;     // Used to pass state to MCD driver.

    ULONG      mcdDirtyState;   // Set of flags that tracks when MCD state
                                // is out of sync (i.e., "dirty") with respect
                                // to generic state.

    ULONG *pDepthSpan;          // Cached copy of the one in GENMCDSURFACE.

                                // Fallback z-test span function.
    void *softZSpanFuncPtr;

    GENMCDBUF  McdBuf1;         // If using DMA, we swap pMcdPrimBatch
    GENMCDBUF  McdBuf2;         // between these two buffers.  Otherwise,
                                // only McdBuf1 is initialized.

    MCDRCINFO McdRcInfo;        // Cache a copy of the MCD RC info structure.

    MCDRECTBUFFERS McdBuffers;  // Describes accessibility of MCD buffers.

    ULONG mcdFlags;             // Misc. other state flags.

    MCDPIXELFORMAT McdPixelFmt; // Cache a copy of the MCD pixel format.

    HANDLE hDdColor;            // Kernel-mode handles for DirectDraw
    HANDLE hDdDepth;
} GENMCDSTATE;

//
// Misc. flags for GENMCDSTATE.mcdFlags:
//

#define MCD_STATE_FORCEPICK     0x00000001
#define MCD_STATE_FORCERESIZE   0x00000002

//
// Dirty state flags for GENMCDSTATE.mcdDirtyState:
//

#define MCD_DIRTY_ENABLES               0x00000001
#define MCD_DIRTY_TEXTURE               0x00000002
#define MCD_DIRTY_FOG                   0x00000004
#define MCD_DIRTY_SHADEMODEL            0x00000008
#define MCD_DIRTY_POINTDRAW             0x00000010
#define MCD_DIRTY_LINEDRAW              0x00000020
#define MCD_DIRTY_POLYDRAW              0x00000040
#define MCD_DIRTY_ALPHATEST             0x00000080
#define MCD_DIRTY_DEPTHTEST             0x00000100
#define MCD_DIRTY_BLEND                 0x00000200
#define MCD_DIRTY_LOGICOP               0x00000400
#define MCD_DIRTY_FBUFCTRL              0x00000800
#define MCD_DIRTY_LIGHTMODEL            0x00001000
#define MCD_DIRTY_HINTS                 0x00002000
#define MCD_DIRTY_VIEWPORT              0x00004000
#define MCD_DIRTY_SCISSOR               0x00008000
#define MCD_DIRTY_CLIPCTRL              0x00010000
#define MCD_DIRTY_STENCILTEST           0x00020000
#define MCD_DIRTY_PIXELSTATE            0x00040000
#define MCD_DIRTY_TEXENV                0x00080000
#define MCD_DIRTY_TEXTRANSFORM          0x00100000
#define MCD_DIRTY_TEXGEN                0x00200000
#define MCD_DIRTY_MATERIAL              0x00400000
#define MCD_DIRTY_LIGHTS                0x00800000
#define MCD_DIRTY_COLORMATERIAL         0x01000000

#define MCD_DIRTY_RENDERSTATE           0x0003ffff
#define MCD_DIRTY_ALL                   0x01ffffff


// Internal driver information structure
typedef struct _MCDDRIVERINFOI {
    MCDDRIVERINFO mcdDriverInfo;
    MCDDRIVER mcdDriver;
} MCDDRIVERINFOI;


//
// Return values for MCDLock.
// Zero must be used for the system error because it may be returned
// from ExtEscape if the system is unable to make the escape call.
//
#define MCD_LOCK_SYSTEM_ERROR   0
#define MCD_LOCK_BUSY           1
#define MCD_LOCK_TAKEN          2

BOOL APIENTRY MCDGetDriverInfo(HDC hdc, struct _MCDDRIVERINFOI *pMCDDriverInfo);
LONG APIENTRY MCDDescribeMcdPixelFormat(HDC hdc, LONG iPixelFormat,
                                        MCDPIXELFORMAT *pMcdPixelFmt);
LONG APIENTRY MCDDescribePixelFormat(HDC hdc, LONG iPixelFormat,
                                     LPPIXELFORMATDESCRIPTOR ppfd);
BOOL APIENTRY MCDCreateContext(MCDCONTEXT *pMCDContext,
                               MCDRCINFOPRIV *pDrvRcInfo,
                               struct _GLSURF *pgsurf,
                               int ipfd,
                               ULONG flags);
BOOL APIENTRY MCDDeleteContext(MCDCONTEXT *pMCDContext);
UCHAR * APIENTRY MCDAlloc(MCDCONTEXT *pMCDContext, ULONG numBytes, MCDHANDLE *pMCDHandle, 
                          ULONG flags);
BOOL APIENTRY MCDFree(MCDCONTEXT *pMCDContext, VOID *pMCDMem);
VOID APIENTRY MCDBeginState(MCDCONTEXT *pMCDContext, VOID *pMCDMem);
BOOL APIENTRY MCDFlushState(VOID *pMCDMem);
BOOL APIENTRY MCDAddState(VOID *pMCDMem, ULONG stateToChange,
                          ULONG stateValue);
BOOL APIENTRY MCDAddStateStruct(VOID *pMCDMem, ULONG stateToChange,
                                VOID *pStateValue, ULONG stateValueSize);
BOOL APIENTRY MCDSetViewport(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                             MCDVIEWPORT *pMCDViewport);
BOOL APIENTRY MCDSetScissorRect(MCDCONTEXT *pMCDContext, RECTL *pRect,
                                BOOL bEnabled);
ULONG APIENTRY MCDQueryMemStatus(VOID *pMCDMem);
PVOID APIENTRY MCDProcessBatch(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                               ULONG batchSize, VOID *pMCDFirstCmd,
                               int cExtraSurfaces,
                               struct IDirectDrawSurface **pddsExtra);
BOOL APIENTRY MCDReadSpan(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                          ULONG x, ULONG y, ULONG numPixels, ULONG type);
BOOL APIENTRY MCDWriteSpan(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                           ULONG x, ULONG y, ULONG numPixels, ULONG type);
BOOL APIENTRY MCDClear(MCDCONTEXT *pMCDContext, RECTL rect, ULONG buffers);
BOOL APIENTRY MCDSwap(MCDCONTEXT *pMCDContext, ULONG flags);
BOOL APIENTRY MCDGetBuffers(MCDCONTEXT *pMCDContext,
                            MCDRECTBUFFERS *pMCDBuffers);
BOOL APIENTRY MCDAllocBuffers(MCDCONTEXT *pMCDContext, RECTL *pWndRect);
BOOL APIENTRY MCDBindContext(MCDCONTEXT *pMCDContext, HDC hdc,
                             struct GLGENwindowRec *pwnd);
BOOL APIENTRY MCDSync(MCDCONTEXT *pMCDContext);
MCDHANDLE APIENTRY MCDCreateTexture(MCDCONTEXT *pMCDContext, 
                                    MCDTEXTUREDATA *pTexData,
                                    ULONG flags,
                                    VOID *pSurface);
BOOL APIENTRY MCDDeleteTexture(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
BOOL APIENTRY MCDUpdateSubTexture(MCDCONTEXT *pMCDContext,
                                  MCDTEXTUREDATA *pTexData, MCDHANDLE hTex, 
                                  ULONG lod, RECTL *pRect);
BOOL APIENTRY MCDUpdateTexturePalette(MCDCONTEXT *pMCDContext, 
                                      MCDTEXTUREDATA *pTexData, MCDHANDLE hTex,
                                      ULONG start, ULONG numEntries);
BOOL APIENTRY MCDUpdateTexturePriority(MCDCONTEXT *pMCDContext, 
                                       MCDTEXTUREDATA *pTexData,
                                       MCDHANDLE hTex);
BOOL APIENTRY MCDUpdateTextureState(MCDCONTEXT *pMCDContext, 
                                    MCDTEXTUREDATA *pTexData,
                                    MCDHANDLE hTex);
ULONG APIENTRY MCDTextureStatus(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
ULONG APIENTRY MCDTextureKey(MCDCONTEXT *pMCDContext, MCDHANDLE hTex);
BOOL APIENTRY MCDDescribeMcdLayerPlane(HDC hdc, LONG iPixelFormat,
                                       LONG iLayerPlane,
                                       MCDLAYERPLANE *pMcdPixelFmt);
BOOL APIENTRY MCDDescribeLayerPlane(HDC hdc, LONG iPixelFormat,
                                    LONG iLayerPlane,
                                    LPLAYERPLANEDESCRIPTOR ppfd);
LONG APIENTRY MCDSetLayerPalette(HDC hdc, LONG iLayerPlane, BOOL bRealize,
                                 LONG cEntries, COLORREF *pcr);
ULONG APIENTRY MCDDrawPixels(MCDCONTEXT *pMCDContext, ULONG width, ULONG height,
                             ULONG format, ULONG type, VOID *pPixels, BOOL packed);
ULONG APIENTRY MCDReadPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y, ULONG width, ULONG height,
                             ULONG format, ULONG type, VOID *pPixels);
ULONG APIENTRY MCDCopyPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y, ULONG width, ULONG height,
                             ULONG type);
ULONG APIENTRY MCDPixelMap(MCDCONTEXT *pMCDContext, ULONG mapType, ULONG mapSize,
                           VOID *pMap);
void APIENTRY MCDDestroyWindow(HDC hdc, ULONG_PTR dwMcdWindow);
int APIENTRY MCDGetTextureFormats(MCDCONTEXT *pMCDContext, int nFmts,
                                  struct _DDSURFACEDESC *pddsd);
ULONG APIENTRY MCDLock(MCDCONTEXT *pMCDContext);
VOID APIENTRY MCDUnlock(MCDCONTEXT *pMCDContext);

#ifdef MCD95
typedef LPCRITICAL_SECTION (APIENTRY *MCDGETMCDCRITSECTFUNC)(void);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\mcd\client\mcd.c ===
//******************************Module*Header*******************************
// Module Name: mcd.c
//
// Main module for Mini Client Driver wrapper library.
//
// Copyright (c) 1995 Microsoft Corporation
//**************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <stdarg.h>
#include <ddrawp.h>
#include <ddrawi.h>
#include <windows.h>
#include <wtypes.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <glp.h>
#include <glgenwin.h>
#include <mcdrv.h>
#include <mcd2hack.h>
#include <mcd.h>
#include <mcdint.h>
#ifdef MCD95
#include "mcdrvint.h"
#endif
#include "debug.h"

ULONG verMajor, verMinor;

// Checks MCD version to see if the driver can accept direct buffer
// access.  Direct access was introduced in 1.1.
#define SUPPORTS_DIRECT() \
    (verMinor >= 0x10 || verMajor > 1)

// Checks for version 2.0 or higher
#define SUPPORTS_20() \
    (verMajor >= 2)

extern ULONG McdFlags;
extern ULONG McdPrivateFlags;
#if DBG
extern ULONG McdDebugFlags;
#endif

#ifdef MCD95
MCDRVINITFUNC       pMCDrvInit       = (MCDRVINITFUNC) NULL;
MCDENGESCFILTERFUNC pMCDEngEscFilter = (MCDENGESCFILTERFUNC) NULL;
MCDENGESCPREPFUNC   pMCDEngEscPrep   = (MCDENGESCPREPFUNC) NULL;
DHPDEV gdhpdev = (DHPDEV) NULL;
#define EXTESCAPE   Mcd95EscapeBypass
#else
#define EXTESCAPE   ExtEscape
#endif

#ifdef MCD95
//
// Local driver semaphore.
//

extern CRITICAL_SECTION gsemMcd;

/******************************Public*Routine******************************\
* Mcd95EscapeBypass
*
* Escape function for MCD95.
*
* Call via the function pointer retrieved via LoadLibrary/GetProcAddress.
* Synchronize to the global
*
* History:
*  09-Feb-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LONG WINAPI Mcd95EscapeBypass(HDC hdc, int iEscape,
                              int cjIn, PVOID pvIn,
                              int cjOut, PVOID pvOut)
{
    LONG lRet = 0;

    if ((iEscape == RXFUNCS) && pMCDEngEscPrep && pMCDEngEscFilter)
    {
        MCDHDR McdHdr;
        SURFOBJ bogusSurf;

        bogusSurf.dhpdev = gdhpdev;

        EnterCriticalSection(&gsemMcd);

        //
        // Prep the MCDHDR buffer.  Required before invoking
        // MCDEngEscFilter.
        //

        if ((*pMCDEngEscPrep)(sizeof(McdHdr), &McdHdr, cjIn, pvIn))
        {
            //
            // Pass to dispatch function.
            //

            (*pMCDEngEscFilter)(&bogusSurf, iEscape,
                                sizeof(McdHdr), &McdHdr,
                                cjOut, pvOut, (ULONG_PTR *) &lRet);
        }
        else
        {
            DBGPRINT("Mcd95EscapeBypass: MCDEngEscPrep failed\n");
        }

        LeaveCriticalSection(&gsemMcd);
    }

    return lRet;
}

/******************************Public*Routine******************************\
* Mcd95DriverInit
*
* Initialize the MCD driver.
*
* History:
*  14-Apr-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

typedef enum {
    MCDRV_NEEDINIT,
    MCDRV_INITFAIL,
    MCDRV_INITOK
} MCDRVSTATE;

BOOL Mcd95DriverInit(HDC hdc)
{
    HMODULE hmodMCD;
    MCDGETDRIVERNAME mcdDriverNames;
    MCDCMDI mcdCmd;
    static MCDRVSTATE McdInitState = MCDRV_NEEDINIT;

    EnterCriticalSection(&gsemMcd);

    if (McdInitState == MCDRV_NEEDINIT)
    {
        //
        // One shot at init.  Assume failure for now.
        //

        McdInitState = MCDRV_INITFAIL;

        //
        // Call Escape to determine name of MCD driver DLL and the
        // name of its Init entry point.
        //

        mcdCmd.command = MCDCMD_GETDRIVERNAME;
        mcdDriverNames.ulVersion = 1;

        if ((EXTESCAPE(hdc, RXFUNCS, sizeof(mcdCmd), (char *) &mcdCmd,
                       sizeof(mcdDriverNames),
                       (char *) &mcdDriverNames) <= 0) ||
            (!mcdDriverNames.pchDriverName) ||
            (!mcdDriverNames.pchFuncName))
        {
            DBGPRINT("MCDGetDriverInfo: MCDCMD_GETDRIVERNAME failed\n");

            goto Mcd95DriverInit_exit;
        }

        //
        // Load the MCD driver DLL and get entry points.
        //

        if (hmodMCD = LoadLibraryA(mcdDriverNames.pchDriverName))
        {
            HMODULE hmodMCDSRV;

            //
            // Get MCDrvInit entry point first.
            //

            pMCDrvInit = (MCDRVINITFUNC)
                GetProcAddress(hmodMCD, mcdDriverNames.pchFuncName);

            if (pMCDrvInit)
            {
                //
                // Call MCDrvInit to get MCDSRV32.DLL module handle.
                //

                hmodMCDSRV = (*pMCDrvInit)(hdc, &gdhpdev);
                if (hmodMCDSRV)
                {
                    //
                    // Get the MCDEngEscPrep and MCDEngEscFilter entry
                    // points.
                    //

                    pMCDEngEscPrep = (MCDENGESCPREPFUNC)
                        GetProcAddress(hmodMCDSRV, MCDENGESCPREPNAME);
                    pMCDEngEscFilter = (MCDENGESCFILTERFUNC)
                        GetProcAddress(hmodMCDSRV, MCDENGESCFILTERNAME);

                    if (pMCDEngEscPrep && pMCDEngEscFilter)
                    {
                        McdInitState = MCDRV_INITOK;
                    }
                    else
                    {
                        pMCDEngEscPrep = (MCDENGESCPREPFUNC) NULL;
                        pMCDEngEscFilter = (MCDENGESCFILTERFUNC) NULL;

                        DBGPRINT("Mcd95DriverInit: GetProcAddress failed\n");
                    }
                }
            }
            else
            {
                DBGPRINT1("MCDGetDriverInfo: GetProcAddress(%s) failed\n",
                          mcdDriverNames.pchFuncName);
            }
        }
        else
        {
            DBGPRINT1("MCDGetDriverInfo: LoadLibrary(%s) failed\n",
                      mcdDriverNames.pchDriverName);
        }
    }

Mcd95DriverInit_exit:

    LeaveCriticalSection(&gsemMcd);

    return (McdInitState == MCDRV_INITOK);
}
#endif

//*****************************Private*Routine******************************
//
// InitMcdEsc
//
// Initializes an MCDESC_HEADER for filling in
//
//**************************************************************************

// Placeholder in case any generic initialization becomes necessary
#define InitMcdEsc(pmeh) (pmeh)

//*****************************Private*Routine******************************
//
// InitMcdEscEmpty
//
// Initializes an MCDESC_HEADER for filling in
//
//**************************************************************************

#define InitMcdEscEmpty(pmeh) \
    (InitMcdEsc(pmeh), \
     (pmeh)->hRC = NULL, \
     (pmeh)->hSharedMem = NULL, \
     (pmeh)->pSharedMem = NULL, \
     (pmeh)->dwWindow = 0, \
     (pmeh))

//*****************************Private*Routine******************************
//
// InitMcdEscContext
//
// Initializes an MCDESC_HEADER for filling in
//
//**************************************************************************

#define InitMcdEscContext(pmeh, pmctx) \
    (InitMcdEsc(pmeh), \
     (pmeh)->hRC = (pmctx)->hMCDContext, \
     (pmeh)->dwWindow = (pmctx)->dwMcdWindow, \
     (pmeh))

//*****************************Private*Routine******************************
//
// InitMcdEscSurfaces
//
// Fills in some MCDESC_HEADER fields from context information
//
//**************************************************************************

#if DBG
extern ULONG APIENTRY glDebugEntry(int param, void *data);
#endif

MCDESC_HEADER *InitMcdEscSurfaces(MCDESC_HEADER *pmeh, MCDCONTEXT *pmctx)
{
    GENMCDSTATE *pmst;

    InitMcdEscContext(pmeh, pmctx);

    // We're assuming that the context passed in is always the one
    // statically placed in the GENMCDSTATE.  Attempt to verify this
    // by checking that the allocation size for the context is
    // the same as for a GENMCDSTATE.
    ASSERTOPENGL(glDebugEntry(3, pmctx) == sizeof(GENMCDSTATE),
                 "InitMcdEscSurfaces: Bad context\n");

    pmst = (GENMCDSTATE *)pmctx;

    pmeh->msrfColor.hSurf = pmst->hDdColor;
    pmeh->msrfDepth.hSurf = pmst->hDdDepth;

    return pmeh;
}

//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDGetDriverInfo(HDC hdc, MCDDRIVERINFOI *pMCDDriverInfo)
//
// Checks to determine if the device driver reports MCD capabilities.
//
//**************************************************************************

BOOL APIENTRY MCDGetDriverInfo(HDC hdc, MCDDRIVERINFOI *pMCDDriverInfo)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDDRIVERINFOCMDI)];
    MCDESC_HEADER *pmeh;
    MCDDRIVERINFOCMDI *pInfoCmd;

    if ( !(McdPrivateFlags & MCDPRIVATE_MCD_ENABLED) )
    {
        return FALSE;
    }

#ifdef MCD95
    if (!Mcd95DriverInit(hdc))
    {
        return FALSE;
    }
#endif

    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)(cmdBuffer));
    pmeh->flags = 0;

    pInfoCmd = (MCDDRIVERINFOCMDI *)(pmeh + 1);
    pInfoCmd->command = MCD_DRIVERINFO;

    // Force the table to empty
    memset(&pMCDDriverInfo->mcdDriver, 0, sizeof(MCDDRIVER));

    // Force the version to 0

    pMCDDriverInfo->mcdDriverInfo.verMajor = 0;

    if (!(BOOL)EXTESCAPE(hdc, MCDFUNCS,
                         sizeof(cmdBuffer),
                         (char *)pmeh, sizeof(MCDDRIVERINFOI),
                         (char *)pMCDDriverInfo))
        return FALSE;

    // See if the driver filled in a non-null version:

    if (pMCDDriverInfo->mcdDriverInfo.verMajor != 0)
    {
        verMajor = pMCDDriverInfo->mcdDriverInfo.verMajor;
        verMinor = pMCDDriverInfo->mcdDriverInfo.verMinor;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//******************************Public*Routine******************************
//
// LONG APIENTRY MCDDescribeMcdPixelFormat(HDC hdc,
//                                         LONG iPixelFormat,
//                                         MCDPIXELFORMAT *ppfd)
//
// Returns information about the specified hardware-dependent pixel format.
//
//**************************************************************************

LONG APIENTRY MCDDescribeMcdPixelFormat(HDC hdc, LONG iPixelFormat,
                                        MCDPIXELFORMAT *pMcdPixelFmt)
{
    LONG lRet = 0;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDPIXELFORMATCMDI)];
    MCDESC_HEADER *pmeh;
    MCDPIXELFORMATCMDI *pPixelFmtCmd;

    if ( !(McdPrivateFlags & MCDPRIVATE_PALETTEFORMATS) &&
         ((GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES)) == 8) &&
         (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) )
    {
        return lRet;
    }

    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)(cmdBuffer));
    pmeh->flags = 0;

    pPixelFmtCmd = (MCDPIXELFORMATCMDI *)(pmeh + 1);
    pPixelFmtCmd->command = MCD_DESCRIBEPIXELFORMAT;
    pPixelFmtCmd->iPixelFormat = iPixelFormat;

    lRet = (LONG)EXTESCAPE(hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, sizeof(MCDPIXELFORMAT),
                           (char *)pMcdPixelFmt);

    // Limit overlay/underlay planes to 15 each (as per spec).

    if (pMcdPixelFmt)
    {
        if (pMcdPixelFmt->cOverlayPlanes > 15)
            pMcdPixelFmt->cOverlayPlanes = 15;
        if (pMcdPixelFmt->cUnderlayPlanes > 15)
            pMcdPixelFmt->cUnderlayPlanes = 15;
    }

    return lRet;
}


//******************************Public*Routine******************************
//
// LONG APIENTRY MCDDescribePixelFormat(HDC hdc,
//                                      LONG iPixelFormat,
//                                      LPPIXELFORMATDESCRIPTOR ppfd)
//
// Returns a PIXELFORMATDESCRIPTOR describing the specified hardware-dependent
// pixel format.
//
//**************************************************************************

#define STANDARD_MCD_FLAGS \
    (PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_GENERIC_FORMAT | \
     PFD_GENERIC_ACCELERATED)

LONG APIENTRY MCDDescribePixelFormat(HDC hdc, LONG iPixelFormat,
                                     LPPIXELFORMATDESCRIPTOR ppfd)
{
    LONG lRet = 0;
    MCDPIXELFORMAT mcdPixelFmt;

    lRet = MCDDescribeMcdPixelFormat(hdc, iPixelFormat,
                                     ppfd ? &mcdPixelFmt : NULL);

    if (ppfd && lRet)
    {
        ppfd->nSize    = sizeof(*ppfd);
        ppfd->nVersion = 1;
        ppfd->dwFlags  = mcdPixelFmt.dwFlags | STANDARD_MCD_FLAGS |
                         ((mcdPixelFmt.dwFlags & PFD_DOUBLEBUFFER) ?
                          0 : PFD_SUPPORT_GDI);

        if (McdPrivateFlags & MCDPRIVATE_EMULATEICD)
            ppfd->dwFlags &= ~PFD_GENERIC_FORMAT;

        memcpy(&ppfd->iPixelType, &mcdPixelFmt.iPixelType,
               offsetof(MCDPIXELFORMAT, cDepthBits) -
               offsetof(MCDPIXELFORMAT, iPixelType));

        ppfd->cDepthBits = mcdPixelFmt.cDepthBits;

        if (ppfd->iPixelType == PFD_TYPE_RGBA)
        {
            if (ppfd->cColorBits < 8)
            {
                ppfd->cAccumBits      = 16;
                ppfd->cAccumRedBits   = 5;
                ppfd->cAccumGreenBits = 6;
                ppfd->cAccumBlueBits  = 5;
                ppfd->cAccumAlphaBits = 0;
            }
            else
            {
                if (ppfd->cColorBits <= 16)
                {
                    ppfd->cAccumBits      = 32;
                    ppfd->cAccumRedBits   = 11;
                    ppfd->cAccumGreenBits = 11;
                    ppfd->cAccumBlueBits  = 10;
                    ppfd->cAccumAlphaBits = 0;
                }
                else
                {
                    ppfd->cAccumBits      = 64;
                    ppfd->cAccumRedBits   = 16;
                    ppfd->cAccumGreenBits = 16;
                    ppfd->cAccumBlueBits  = 16;
                    ppfd->cAccumAlphaBits = 0;
                }
            }
        }
        else
        {
            ppfd->cAccumBits      = 0;
            ppfd->cAccumRedBits   = 0;
            ppfd->cAccumGreenBits = 0;
            ppfd->cAccumBlueBits  = 0;
            ppfd->cAccumAlphaBits = 0;
        }
        if (mcdPixelFmt.cStencilBits)
        {
            ppfd->cStencilBits = mcdPixelFmt.cStencilBits;
        }
        else
        {
            if (McdPrivateFlags & MCDPRIVATE_USEGENERICSTENCIL)
                ppfd->cStencilBits = 8;
            else
                ppfd->cStencilBits = 0;
        }
        ppfd->cAuxBuffers     = 0;
        ppfd->iLayerType      = PFD_MAIN_PLANE;
        ppfd->bReserved       = (BYTE) (mcdPixelFmt.cOverlayPlanes |
                                        (mcdPixelFmt.cUnderlayPlanes << 4));
        ppfd->dwLayerMask     = 0;
        ppfd->dwVisibleMask   = mcdPixelFmt.dwTransparentColor;
        ppfd->dwDamageMask    = 0;
    }

    return lRet;
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDCreateContext(MCDCONTEXT *pMCDContext,
//                                MCDRCINFO *pRcInfo,
//                                GLSURF *pgsurf,
//                                ULONG flags)
//
// Creates an MCD rendering context for the specified hdc/hwnd according
// to the specified flags.
//
//**************************************************************************

BOOL APIENTRY MCDCreateContext(MCDCONTEXT *pMCDContext,
                               MCDRCINFOPRIV *pRcInfo,
                               GLSURF *pgsurf,
                               int ipfd,
                               ULONG flags)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDCREATECONTEXT)];
    MCDESC_HEADER *pmeh;
    MCDCREATECONTEXT *pmcc;

    if (flags & MCDSURFACE_HWND)
    {
        // We don't have surfaces to pass in this case
        pmeh = InitMcdEscContext((MCDESC_HEADER *)cmdBuffer, pMCDContext);
        pmeh->flags = MCDESC_FL_CREATE_CONTEXT;
    }
    else if (SUPPORTS_DIRECT())
    {
        pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)cmdBuffer, pMCDContext);
        pmeh->flags = MCDESC_FL_CREATE_CONTEXT | MCDESC_FL_SURFACES;
    }
    else
    {
        return FALSE;
    }

    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;

    pmcc = (MCDCREATECONTEXT *)(pmeh + 1);

    if (flags & MCDSURFACE_HWND)
    {
        pmcc->escCreate.hwnd = pgsurf->hwnd;
    }
    else
    {
        pmcc->escCreate.hwnd = NULL;
    }
    pmcc->escCreate.flags = flags;

    pmcc->ipfd = ipfd;
    pmcc->iLayer = pgsurf->iLayer;
    pmcc->mcdFlags = McdFlags;
    pmcc->pRcInfo = pRcInfo;

    pMCDContext->hMCDContext =
        (MCDHANDLE)IntToPtr( EXTESCAPE(pgsurf->hdc, MCDFUNCS,
                                      sizeof(MCDESC_HEADER) + sizeof(MCDCREATECONTEXT),
                                      (char *)cmdBuffer, sizeof(MCDRCINFOPRIV),
                                      (char *)pRcInfo) );

    pMCDContext->hdc = pgsurf->hdc;
    pMCDContext->dwMcdWindow = pRcInfo->dwMcdWindow;

    return (pMCDContext->hMCDContext != (HANDLE)NULL);
}

#define MCD_MEM_ALIGN 32

//******************************Public*Routine******************************
//
// UCHAR * APIENTRY MCDAlloc(MCDCONTEXT *pMCDContext,
//                           ULONG numBytes,
//                           MCDHANDLE *pMCDHandle,
//                           ULONG flags);
//
// Allocate a chunk of shared memory to use for vertex and pixel data.
//
// The return value is a pointer to a shared memory region which can be
// subsequently used by the caller.  For vertex processing, caller should
// use MCDLockMemory()/MCDUnlockMemory to serialize hardware access to the
// memory.
//
//**************************************************************************

UCHAR * APIENTRY MCDAlloc(MCDCONTEXT *pMCDContext, ULONG numBytes,
                          HANDLE *pMCDHandle, ULONG flags)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDALLOCCMDI)];
    ULONG outBuffer;
    ULONG totalSize = numBytes + MCD_MEM_ALIGN + sizeof(MCDMEMHDRI);
    MCDALLOCCMDI *pCmdAlloc;
    MCDESC_HEADER *pmeh;
    VOID *pResult;
    MCDMEMHDRI *pMCDMemHdr;
    UCHAR *pBase;
    UCHAR *pAlign;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = NULL;
    pmeh->flags = 0;

    pCmdAlloc = (MCDALLOCCMDI *)(pmeh + 1);
    pCmdAlloc->command = MCD_ALLOC;
    pCmdAlloc->sourceProcessID = GetCurrentProcessId();
    pCmdAlloc->numBytes = totalSize;
    pCmdAlloc->flags = flags;

    pBase = (UCHAR *)IntToPtr( EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                                        sizeof(cmdBuffer),
                                        (char *)pmeh, 4, (char *)pMCDHandle) );

    if (!pBase)
        return (VOID *)NULL;

    pAlign = (UCHAR *)(((ULONG_PTR)(pBase + sizeof(MCDMEMHDRI)) +
                        (MCD_MEM_ALIGN - 1)) &
                       ~(MCD_MEM_ALIGN - 1));

    pMCDMemHdr = (MCDMEMHDRI *)(pAlign - sizeof(MCDMEMHDRI));

    pMCDMemHdr->flags = 0;
    pMCDMemHdr->numBytes = numBytes;
    pMCDMemHdr->pMaxMem = (VOID *)((char *)pMCDMemHdr + totalSize);
    pMCDMemHdr->hMCDMem = *pMCDHandle;
    pMCDMemHdr->pBase = pBase;

    return (VOID *)(pAlign);
}



//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDFree(MCDCONTEXT *pMCDContext,
//                       VOID *pMem);
//
// Frees a chunk of driver-allocated shared memory.
//
// Returns TRUE for success, FALSE for failure.
//
//**************************************************************************

BOOL APIENTRY MCDFree(MCDCONTEXT *pMCDContext, VOID *pMCDMem)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDFREECMDI)];
    MCDFREECMDI *pCmdFree;
    MCDESC_HEADER *pmeh;
    MCDMEMHDRI *pMCDMemHdr;

#ifdef MCD95
    //
    // Driver already shutdown, therefore memory already deleted.
    //

    if (!pMCDEngEscFilter)
        return TRUE;
#endif

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = NULL;
    pmeh->flags = 0;

    pCmdFree = (MCDFREECMDI *)(pmeh + 1);
    pCmdFree->command = MCD_FREE;
    pCmdFree->hMCDMem = pMCDMemHdr->hMCDMem;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// VOID APIENTRY MCDBeginState(MCDCONTEXT *pMCDContext, VOID *pMCDMem);
//
// Begins a batch of state commands to issue to the driver.
//
//**************************************************************************

VOID APIENTRY MCDBeginState(MCDCONTEXT *pMCDContext, VOID *pMCDMem)
{
    MCDMEMHDRI *pMCDMemHdr;
    MCDSTATECMDI *pMCDStateCmd;

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));
    pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;

    pMCDStateCmd->command = MCD_STATE;
    pMCDStateCmd->numStates = 0;
    pMCDStateCmd->pNextState = (MCDSTATE *)(pMCDStateCmd + 1);
    pMCDStateCmd->pMaxState = (MCDSTATE *)(pMCDMemHdr->pMaxMem);

    pMCDMemHdr->pMCDContext = pMCDContext;
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDFlushState(VOID pMCDMem);
//
// Flushes a batch of state commands to the driver.
//
// Returns TRUE for success, FALSE for failure.
//
//**************************************************************************

BOOL APIENTRY MCDFlushState(VOID *pMCDMem)
{
    MCDESC_HEADER meh;
    MCDMEMHDRI *pMCDMemHdr;
    MCDSTATECMDI *pMCDStateCmd;

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));
    pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;

    InitMcdEscContext(&meh, pMCDMemHdr->pMCDContext);
    meh.hSharedMem = pMCDMemHdr->hMCDMem;
    meh.pSharedMem = (char *)pMCDMem;
    meh.sharedMemSize = (ULONG)((char *)pMCDStateCmd->pNextState -
                          (char *)pMCDStateCmd);
    meh.flags = 0;

    if (!meh.sharedMemSize)
        return TRUE;

    return (BOOL)EXTESCAPE(pMCDMemHdr->pMCDContext->hdc, MCDFUNCS,
                           sizeof(MCDESC_HEADER), (char *)&meh,
                           0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDAddState(VOID *pMCDMem, ULONG stateToChange,
//                           ULONG stateValue);
//
// Adds a state to a state buffer (started with MCDBeginState).  If there
// is no room in the state stream (i.e., the memory buffer), the current
// batch of state commands is automatically flushed.
//
//
// Returns TRUE for success, FALSE for failure.  A FALSE return will occur
// if an automatic flush is performed which fails.
//
//**************************************************************************

BOOL APIENTRY MCDAddState(VOID *pMCDMem, ULONG stateToChange,
                          ULONG stateValue)
{
    MCDSTATECMDI *pMCDStateCmd;
    MCDSTATE *pState;
    BOOL retVal = TRUE;

    pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;

    if (((char *)pMCDStateCmd->pNextState + sizeof(MCDSTATE)) >=
        (char *)pMCDStateCmd->pMaxState) {

        MCDMEMHDRI *pMCDMemHdr = (MCDMEMHDRI *)
            ((char *)pMCDMem - sizeof(MCDMEMHDRI));

        retVal = MCDFlushState(pMCDMem);

        pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;
        pMCDStateCmd->command = MCD_STATE;
        pMCDStateCmd->numStates = 0;
        pMCDStateCmd->pNextState = (MCDSTATE *)(pMCDStateCmd + 1);
        pMCDStateCmd->pMaxState = (MCDSTATE *)(pMCDMemHdr->pMaxMem);
    }

    pMCDStateCmd->numStates++;
    pState = pMCDStateCmd->pNextState;
    pState->size = sizeof(MCDSTATE);
    pState->state = stateToChange;
    pState->stateValue = stateValue;
    pMCDStateCmd->pNextState++;

    return retVal;
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDAddStateStruct(VOID *pMCDMem, ULONG stateToChange,
//                                 VOID *pStateValue, ULONG stateValueSize)
//
//
// Adds a state structure to a state buffer (started with MCDBeginState).  If
// there is no room in the state stream (i.e., the memory buffer), the current
// batch of state commands is automatically flushed.
//
//
// Returns TRUE for success, FALSE for failure.  A FALSE return will occur
// if an automatic flush is performed which fails.
//
//**************************************************************************

BOOL APIENTRY MCDAddStateStruct(VOID *pMCDMem, ULONG stateToChange,
                                VOID *pStateValue, ULONG stateValueSize)
{
    MCDSTATECMDI *pMCDStateCmd;
    MCDSTATE *pState;
    BOOL retVal = FALSE;

    pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;

    if (((char *)pMCDStateCmd->pNextState + stateValueSize) >=
        (char *)pMCDStateCmd->pMaxState) {

        MCDMEMHDRI *pMCDMemHdr = (MCDMEMHDRI *)
            ((char *)pMCDMem - sizeof(MCDMEMHDRI));

        retVal = MCDFlushState(pMCDMem);

        pMCDStateCmd = (MCDSTATECMDI *)pMCDMem;
        pMCDStateCmd->command = MCD_STATE;
        pMCDStateCmd->numStates = 0;
        pMCDStateCmd->pNextState = (MCDSTATE *)(pMCDStateCmd + 1);
        pMCDStateCmd->pMaxState = (MCDSTATE *)(pMCDMemHdr->pMaxMem);
    }

    pMCDStateCmd->numStates++;
    pState = pMCDStateCmd->pNextState;
    pState->state = stateToChange;
    pState->size = offsetof(MCDSTATE, stateValue) + stateValueSize;
    memcpy((char *)&pState->stateValue, (char *)pStateValue, stateValueSize);
    pMCDStateCmd->pNextState =
        (MCDSTATE *)(((char *)pMCDStateCmd->pNextState) + pState->size);

    return retVal;
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDSetViewport(MCDCONTEXT *pMCDContext, VOID pMCDMem,
//                              MCDVIEWPORT pMCDViewport)
//
// Establishes the viewport scaling to convert transformed coordinates to
// screen coordinates.
//
//**************************************************************************

BOOL APIENTRY MCDSetViewport(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                             MCDVIEWPORT *pMCDViewport)
{
    MCDESC_HEADER meh;
    MCDMEMHDRI *pMCDMemHdr;
    MCDVIEWPORTCMDI *pMCDViewportCmd;

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));
    pMCDViewportCmd = (MCDVIEWPORTCMDI *)pMCDMem;

    pMCDViewportCmd->MCDViewport = *pMCDViewport;
    pMCDViewportCmd->command = MCD_VIEWPORT;

    InitMcdEscContext(&meh, pMCDContext);
    meh.hSharedMem = pMCDMemHdr->hMCDMem;
    meh.pSharedMem = (char *)pMCDMem;
    meh.sharedMemSize = sizeof(MCDVIEWPORTCMDI);
    meh.flags = 0;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(MCDESC_HEADER), (char *)&meh,
                           0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// ULONG APIENTRY MCDQueryMemStatus((VOID *pMCDMem);
//
// Returns the status of the specified memory block.  Return values are:
//
//      MCD_MEM_READY   - memory is available for client access
//      MCD_MEM_BUSY    - memory is busy due to driver access
//      MCD_MEM_INVALID - queried memory is invalid
//
//**************************************************************************

ULONG APIENTRY MCDQueryMemStatus(VOID *pMCDMem)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDMEMSTATUSCMDI)];
    MCDMEMHDRI *pMCDMemHdr =
        (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));
    MCDMEMSTATUSCMDI *pCmdMemStatus;
    MCDESC_HEADER *pmeh;

#ifdef MCD95
    //
    // Driver already shutdown, therefore memory already deleted.
    //

    if (!pMCDEngEscFilter)
        return MCD_MEM_INVALID;
#endif

    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)(cmdBuffer));
    pmeh->flags = 0;

    pCmdMemStatus = (MCDMEMSTATUSCMDI *)(pmeh + 1);
    pCmdMemStatus->command = MCD_QUERYMEMSTATUS;
    pCmdMemStatus->hMCDMem = pMCDMemHdr->hMCDMem;

    return (ULONG)EXTESCAPE(pMCDMemHdr->pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDProcessBatch(MCDCONTEXT *pMCDContext, VOID pMCDMem,
//                               ULONG batchSize, VOID *pMCDFirstCmd)
//
// Processes a batch of primitives pointed to by pMCDMem.
//
// Returns TRUE if the batch was processed without error, FALSE otherwise.
//
//**************************************************************************

PVOID APIENTRY MCDProcessBatch(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                               ULONG batchSize, VOID *pMCDFirstCmd,
                               int cExtraSurfaces,
                               LPDIRECTDRAWSURFACE *pdds)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + MCD_MAXMIPMAPLEVEL*sizeof(DWORD)];
    MCDESC_HEADER *pmeh;
    MCDMEMHDRI *pMCDMemHdr;
    int i;
    ULONG_PTR *pdwSurf;

#if DBG
    if (McdDebugFlags & MCDDEBUG_DISABLE_PROCBATCH)
    {
        MCDSync(pMCDContext);
        return pMCDFirstCmd;
    }
#endif

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)cmdBuffer, pMCDContext);
    pmeh->hSharedMem = pMCDMemHdr->hMCDMem;
    pmeh->pSharedMem = (char *)pMCDFirstCmd;
    pmeh->sharedMemSize = batchSize;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK | MCDESC_FL_BATCH;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES | MCDESC_FL_LOCK_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL ||
             cExtraSurfaces != 0)
    {
        return pMCDFirstCmd;
    }

    // Assert that we won't exceed the kernel's expectations
    ASSERTOPENGL(MCD_MAXMIPMAPLEVEL <= MCDESC_MAX_LOCK_SURFACES,
                 "MCD_MAXMIPMAPLEVEL too large\n");

    pmeh->cLockSurfaces = cExtraSurfaces;
    pdwSurf = (ULONG_PTR *)(pmeh+1);
    for (i = 0; i < cExtraSurfaces; i++)
    {
        *pdwSurf++ = ((LPDDRAWI_DDRAWSURFACE_INT)pdds[i])->lpLcl->hDDSurface;
    }

    return (PVOID)IntToPtr( EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                                      sizeof(cmdBuffer), (char *)pmeh,
                                      0, (char *)NULL) );
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDReadSpan(MCDCONTEXT *pMCDContext, VOID pMCDMem,
//                           ULONG x, ULONG y, ULONG numPixels, ULONG type)
//
// Reads a span of pixel data from the buffer requested by "type".
// The pixel values are returned in pMCDMem.
//
// Returns TRUE for success, FALSE for failure.
//
//**************************************************************************

BOOL APIENTRY MCDReadSpan(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                          ULONG x, ULONG y, ULONG numPixels, ULONG type)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSPANCMDI)];
    MCDESC_HEADER *pmeh;
    MCDMEMHDRI *pMCDMemHdr;
    MCDSPANCMDI *pMCDSpanCmd;

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)cmdBuffer, pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->sharedMemSize = 0;
    pmeh->flags = 0;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return FALSE;
    }

    pMCDSpanCmd = (MCDSPANCMDI *)(pmeh + 1);

    pMCDSpanCmd->command = MCD_READSPAN;
    pMCDSpanCmd->hMem = pMCDMemHdr->hMCDMem;
    pMCDSpanCmd->MCDSpan.x = x;
    pMCDSpanCmd->MCDSpan.y = y;
    pMCDSpanCmd->MCDSpan.numPixels = numPixels;
    pMCDSpanCmd->MCDSpan.type = type;
    pMCDSpanCmd->MCDSpan.pPixels = (VOID *)((char *)pMCDMem);

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer), (char *)pmeh, 0, (char *)NULL);
}

//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDWriteSpan(MCDCONTEXT *pMCDContext, VOID pMCDMem,
//                            ULONG x, ULONG y, ULONG numPixels, ULONG type)
//
// Writes a span of pixel data to the buffer requested by "type".
// The pixel values are given in pMCDMem.
//
// Returns TRUE for success, FALSE for failure.
//
//**************************************************************************

BOOL APIENTRY MCDWriteSpan(MCDCONTEXT *pMCDContext, VOID *pMCDMem,
                           ULONG x, ULONG y, ULONG numPixels, ULONG type)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSPANCMDI)];
    MCDESC_HEADER *pmeh;
    MCDMEMHDRI *pMCDMemHdr;
    MCDSPANCMDI *pMCDSpanCmd;

    pMCDMemHdr = (MCDMEMHDRI *)((char *)pMCDMem - sizeof(MCDMEMHDRI));

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)cmdBuffer, pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->sharedMemSize = 0;
    pmeh->flags = 0;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return FALSE;
    }

    pMCDSpanCmd = (MCDSPANCMDI *)(pmeh + 1);

    pMCDSpanCmd->command = MCD_WRITESPAN;
    pMCDSpanCmd->hMem = pMCDMemHdr->hMCDMem;
    pMCDSpanCmd->MCDSpan.x = x;
    pMCDSpanCmd->MCDSpan.y = y;
    pMCDSpanCmd->MCDSpan.numPixels = numPixels;
    pMCDSpanCmd->MCDSpan.type = type;
    pMCDSpanCmd->MCDSpan.pPixels = (VOID *)((char *)pMCDMem);

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer), (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDClear(MCDCONTEXT *pMCDContext, RECTL rect, ULONG buffers);
//
// Clears buffers specified for the given rectangle.  The current fill values
// will be used.
//
//**************************************************************************

BOOL APIENTRY MCDClear(MCDCONTEXT *pMCDContext, RECTL rect, ULONG buffers)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDCLEARCMDI)];
    MCDCLEARCMDI *pClearCmd;
    MCDESC_HEADER *pmeh;

#if DBG
    if (McdDebugFlags & MCDDEBUG_DISABLE_CLEAR)
    {
        MCDSync(pMCDContext);
        return FALSE;
    }
#endif

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return FALSE;
    }

    pClearCmd = (MCDCLEARCMDI *)(pmeh + 1);
    pClearCmd->command = MCD_CLEAR;
    pClearCmd->buffers = buffers;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDSetScissorRect(MCDCONTEXT *pMCDContext, RECTL *pRect,
//                                 BOOL bEnabled);
//
// Sets the scissor rectangle.
//
//**************************************************************************

//!! Need semaphore to remove display lock !!

BOOL APIENTRY MCDSetScissorRect(MCDCONTEXT *pMCDContext, RECTL *pRect,
                                BOOL bEnabled)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSCISSORCMDI)];
    MCDSCISSORCMDI *pScissorCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pScissorCmd = (MCDSCISSORCMDI *)(pmeh + 1);
    pScissorCmd->command = MCD_SCISSOR;
    pScissorCmd->rect = *pRect;
    pScissorCmd->bEnabled = bEnabled;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDSwap(MCDCONTEXT *pMCDContext, ULONG flags);
//
// Swaps the front and back buffers.
//
//**************************************************************************

BOOL APIENTRY MCDSwap(MCDCONTEXT *pMCDContext, ULONG flags)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSWAPCMDI)];
    MCDSWAPCMDI *pSwapCmd;
    MCDESC_HEADER *pmeh;

    // InitMcdEscSurfaces cannot be used because the context given
    // is a temporary one constructed on the fly since SwapBuffers
    // has only surface information.
    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;

    // Swap cannot be called on DirectDraw surfaces because DirectDraw
    // contexts cannot be double-buffered.  These handles can therefore
    // be forced to NULL.
    pmeh->msrfColor.hSurf = NULL;
    pmeh->msrfDepth.hSurf = NULL;

#ifdef MCD95
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK | MCDESC_FL_SWAPBUFFER;
#else
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;
#endif

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }

    pSwapCmd = (MCDSWAPCMDI *)(pmeh + 1);
    pSwapCmd->command = MCD_SWAP;
    pSwapCmd->flags = flags;
#ifdef MCD95
    pSwapCmd->hwnd = WindowFromDC(pMCDContext->hdc);
#endif

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDDeleteContext(MCDCONTEXT *pMCDContext);
//
// Deletes the specified context.  This will free the buffers associated with
// the context, but will *not* free memory or textures created with the
// context.
//
//**************************************************************************

BOOL APIENTRY MCDDeleteContext(MCDCONTEXT *pMCDContext)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDDELETERCCMDI)];
    MCDDELETERCCMDI *pDeleteRcCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pDeleteRcCmd = (MCDDELETERCCMDI *)(pmeh + 1);
    pDeleteRcCmd->command = MCD_DELETERC;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDAllocBuffers(MCDCONTEXT *pMCDContext)
//
// Allocates the buffers required for the specified context.
//
//**************************************************************************

BOOL APIENTRY MCDAllocBuffers(MCDCONTEXT *pMCDContext, RECTL *pWndRect)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDALLOCBUFFERSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDALLOCBUFFERSCMDI *pAllocBuffersCmd;

#if DBG
    if (McdDebugFlags & MCDDEBUG_DISABLE_ALLOCBUF)
    {
        return FALSE;
    }
#endif

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pAllocBuffersCmd = (MCDALLOCBUFFERSCMDI *)(pmeh + 1);
    pAllocBuffersCmd->command = MCD_ALLOCBUFFERS;
    pAllocBuffersCmd->WndRect = *pWndRect;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDGetBuffers(MCDCONTEXT *pMCDContext,
//                             MCDRECTBUFFERS *pMCDBuffers);
//
// Returns information about the buffers (front, back, and depth) associated
// with the specified context.
//
//**************************************************************************

BOOL APIENTRY MCDGetBuffers(MCDCONTEXT *pMCDContext,
                            MCDRECTBUFFERS *pMCDBuffers)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDGETBUFFERSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDGETBUFFERSCMDI *pGetBuffersCmd;

#if DBG
    if (McdDebugFlags & MCDDEBUG_DISABLE_GETBUF)
    {
        if (pMCDBuffers)
        {
            pMCDBuffers->mcdFrontBuf.bufFlags &= ~MCDBUF_ENABLED;
            pMCDBuffers->mcdBackBuf.bufFlags  &= ~MCDBUF_ENABLED;
            pMCDBuffers->mcdDepthBuf.bufFlags &= ~MCDBUF_ENABLED;
        }

        return TRUE;
    }
#endif

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pGetBuffersCmd = (MCDGETBUFFERSCMDI *)(pmeh + 1);
    pGetBuffersCmd->command = MCD_GETBUFFERS;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, sizeof(MCDRECTBUFFERS),
                           (char *)pMCDBuffers);
}


//******************************Public*Routine******************************
//
// ULONG MCDLock();
//
// Grab the MCD synchronization lock.
//
//**************************************************************************

static ULONG __MCDLockRequest(MCDCONTEXT *pMCDContext, ULONG tid)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDLOCKCMDI)];
    MCDLOCKCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDLOCKCMDI *)(pmeh + 1);
    pCmd->command = MCD_LOCK;

    return EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                     sizeof(cmdBuffer),
                     (char *)pmeh, 0, (char *)NULL);
}

ULONG APIENTRY MCDLock(MCDCONTEXT *pMCDContext)
{
    ULONG ulRet;
    ULONG tid;

    tid = GetCurrentThreadId();

    do
    {
        ulRet = __MCDLockRequest(pMCDContext, tid);
        if (ulRet == MCD_LOCK_BUSY)
            Sleep(0);
    }
    while (ulRet == MCD_LOCK_BUSY);

    return ulRet;
}


//******************************Public*Routine******************************
//
// VOID MCDUnlock();
//
// Release the MCD synchronization lock.
//
//**************************************************************************

VOID APIENTRY MCDUnlock(MCDCONTEXT *pMCDContext)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDLOCKCMDI)];
    MCDLOCKCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDLOCKCMDI *)(pmeh + 1);
    pCmd->command = MCD_UNLOCK;

    EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
              sizeof(cmdBuffer),
              (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// VOID MCDBindContext();
//
// Bind a new window to the specified context.
//
//**************************************************************************

BOOL APIENTRY MCDBindContext(MCDCONTEXT *pMCDContext, HDC hdc,
                             GLGENwindow *pwnd)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDBINDCONTEXTCMDI)];
    MCDBINDCONTEXTCMDI *pCmd;
    MCDESC_HEADER *pmeh;
    ULONG_PTR dwMcdWindow;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->dwWindow = pwnd->dwMcdWindow;
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDBINDCONTEXTCMDI *)(pmeh + 1);
    pCmd->command = MCD_BINDCONTEXT;
    pCmd->hWnd = pwnd->gwid.hwnd;

    dwMcdWindow = EXTESCAPE(hdc, MCDFUNCS,
                            sizeof(cmdBuffer),
                            (char *)pmeh, 0, (char *)NULL);
    if (dwMcdWindow != 0)
    {
        pMCDContext->hdc = hdc;
        pMCDContext->dwMcdWindow = dwMcdWindow;
        if (pwnd->dwMcdWindow == 0)
        {
            // Save MCD server-side window handle in the GENwindow
            pwnd->dwMcdWindow = dwMcdWindow;
        }
        else
        {
            ASSERTOPENGL(pwnd->dwMcdWindow == dwMcdWindow,
                         "dwMcdWindow mismatch\n");
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//******************************Public*Routine******************************
//
// BOOL MCDSync();
//
// Synchronizes the 3D hardware.
//
//**************************************************************************

BOOL APIENTRY MCDSync(MCDCONTEXT *pMCDContext)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSYNCCMDI)];
    MCDSYNCCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDSYNCCMDI *)(pmeh + 1);
    pCmd->command = MCD_SYNC;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// MCDHANDLE MCDCreateTexture();
//
// Creates and loads a texture on the MCD device.
//
//**************************************************************************

MCDHANDLE APIENTRY MCDCreateTexture(MCDCONTEXT *pMCDContext,
                                    MCDTEXTUREDATA *pTexData,
                                    ULONG flags,
                                    VOID *pSurface)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDCREATETEXCMDI)];
    MCDCREATETEXCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pCmd = (MCDCREATETEXCMDI *)(pmeh + 1);
    pCmd->command = MCD_CREATE_TEXTURE;
    pCmd->pTexData = pTexData;
    pCmd->flags = flags;
    pCmd->pSurface = pSurface;

    return (MCDHANDLE)IntToPtr( EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                                         sizeof(cmdBuffer),
                                         (char *)pmeh, 0, (char *)NULL) );
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDDeleteTexture(MCDCONTEXT *pMCDContext,
//                                MCDHANDLE hMCDTexture);
//
// Deletes the specified texture.  This will free the device memory associated
// with the texture.
//
//**************************************************************************

BOOL APIENTRY MCDDeleteTexture(MCDCONTEXT *pMCDContext, MCDHANDLE hTex)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDDELETETEXCMDI)];
    MCDDELETETEXCMDI *pDeleteTexCmd;
    MCDESC_HEADER *pmeh;

#ifdef MCD95
    //
    // Driver already shutdown, therefore memory already deleted.
    //

    if (!pMCDEngEscFilter)
        return MCD_MEM_INVALID;
#endif

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pDeleteTexCmd = (MCDDELETETEXCMDI *)(pmeh + 1);
    pDeleteTexCmd->command = MCD_DELETE_TEXTURE;
    pDeleteTexCmd->hTex = hTex;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL MCDUpdateSubTexture();
//
// Updates a texture (or region of a texture).
//
//**************************************************************************

BOOL APIENTRY MCDUpdateSubTexture(MCDCONTEXT *pMCDContext,
                                  MCDTEXTUREDATA *pTexData, MCDHANDLE hTex,
                                  ULONG lod, RECTL *pRect)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDUPDATESUBTEXCMDI)];
    MCDUPDATESUBTEXCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pCmd = (MCDUPDATESUBTEXCMDI *)(pmeh + 1);
    pCmd->command = MCD_UPDATE_SUB_TEXTURE;
    pCmd->hTex = hTex;
    pCmd->pTexData = pTexData;
    pCmd->lod = lod;
    pCmd->rect = *pRect;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL MCDUpdateTexturePalette();
//
// Updates the palette for the specified texture.
//
//**************************************************************************

BOOL APIENTRY MCDUpdateTexturePalette(MCDCONTEXT *pMCDContext,
                                      MCDTEXTUREDATA *pTexData, MCDHANDLE hTex,
                                      ULONG start, ULONG numEntries)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDUPDATETEXPALETTECMDI)];
    MCDUPDATETEXPALETTECMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pCmd = (MCDUPDATETEXPALETTECMDI *)(pmeh + 1);
    pCmd->command = MCD_UPDATE_TEXTURE_PALETTE;
    pCmd->hTex = hTex;
    pCmd->pTexData = pTexData;
    pCmd->start = start;
    pCmd->numEntries = numEntries;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL MCDUpdateTexturePriority();
//
// Updates the priority for the specified texture.
//
//**************************************************************************

BOOL APIENTRY MCDUpdateTexturePriority(MCDCONTEXT *pMCDContext,
                                       MCDTEXTUREDATA *pTexData,
                                       MCDHANDLE hTex)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDUPDATETEXPRIORITYCMDI)];
    MCDUPDATETEXPRIORITYCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pCmd = (MCDUPDATETEXPRIORITYCMDI *)(pmeh + 1);
    pCmd->command = MCD_UPDATE_TEXTURE_PRIORITY;
    pCmd->hTex = hTex;
    pCmd->pTexData = pTexData;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL MCDUpdateTextureStata();
//
// Updates the state for the specified texture.
//
//**************************************************************************

BOOL APIENTRY MCDUpdateTextureState(MCDCONTEXT *pMCDContext,
                                    MCDTEXTUREDATA *pTexData,
                                    MCDHANDLE hTex)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDUPDATETEXSTATECMDI)];
    MCDUPDATETEXSTATECMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

    pCmd = (MCDUPDATETEXSTATECMDI *)(pmeh + 1);
    pCmd->command = MCD_UPDATE_TEXTURE_STATE;
    pCmd->hTex = hTex;
    pCmd->pTexData = pTexData;

    return (BOOL)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// ULONG MCDTextureStatus();
//
// Returns the status for the specified texture.
//
//**************************************************************************

ULONG APIENTRY MCDTextureStatus(MCDCONTEXT *pMCDContext, MCDHANDLE hTex)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDTEXSTATUSCMDI)];
    MCDTEXSTATUSCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDTEXSTATUSCMDI *)(pmeh + 1);
    pCmd->command = MCD_TEXTURE_STATUS;
    pCmd->hTex = hTex;

    return (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                            sizeof(cmdBuffer),
                            (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// ULONG MCDTextureKey();
//
// Returns the driver-managed "key" for the specified texture.
//
//**************************************************************************

ULONG APIENTRY MCDTextureKey(MCDCONTEXT *pMCDContext, MCDHANDLE hTex)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDTEXKEYCMDI)];
    MCDTEXKEYCMDI *pCmd;
    MCDESC_HEADER *pmeh;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pCmd = (MCDTEXKEYCMDI *)(pmeh + 1);
    pCmd->command = MCD_GET_TEXTURE_KEY;
    pCmd->hTex = hTex;

    return (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                            sizeof(cmdBuffer),
                            (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDDescribeMcdLayerPlane(HDC hdc, LONG iPixelFormat,
//                                        LONG iLayerPlane,
//                                        MCDLAYERPLANE *pMcdPixelFmt)
//
// Returns hardware specific information about the specified layer plane.
//
//**************************************************************************

BOOL APIENTRY MCDDescribeMcdLayerPlane(HDC hdc, LONG iPixelFormat,
                                       LONG iLayerPlane,
                                       MCDLAYERPLANE *pMcdLayer)
{
    BOOL bRet = FALSE;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDLAYERPLANECMDI)];
    MCDESC_HEADER *pmeh;
    MCDLAYERPLANECMDI *pLayerPlaneCmd;

    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)(cmdBuffer));
    pmeh->flags = 0;

    pLayerPlaneCmd = (MCDLAYERPLANECMDI *)(pmeh + 1);
    pLayerPlaneCmd->command = MCD_DESCRIBELAYERPLANE;
    pLayerPlaneCmd->iPixelFormat = iPixelFormat;
    pLayerPlaneCmd->iLayerPlane = iLayerPlane;

    bRet = (BOOL)EXTESCAPE(hdc, MCDFUNCS,
                           sizeof(cmdBuffer),
                           (char *)pmeh, sizeof(MCDLAYERPLANE),
                           (char *)pMcdLayer);

    return bRet;
}


//******************************Public*Routine******************************
//
// BOOL APIENTRY MCDDescribeLayerPlane(HDC hdc, LONG iPixelFormat,
//                                     LONG iLayerPlane,
//                                     LPLAYERPLANEDESCRIPTOR ppfd)
//
// Returns LAYERPLANEDESCRIPTOR describing the specified layer plane.
//
//**************************************************************************

BOOL APIENTRY MCDDescribeLayerPlane(HDC hdc, LONG iPixelFormat,
                                    LONG iLayerPlane,
                                    LPLAYERPLANEDESCRIPTOR plpd)
{
    BOOL bRet = FALSE;
    MCDLAYERPLANE McdLayer;

    if (!MCDDescribeMcdLayerPlane(hdc, iPixelFormat, iLayerPlane, &McdLayer))
        return bRet;

    if (plpd)
    {
        plpd->nSize    = sizeof(*plpd);
        memcpy(&plpd->nVersion, &McdLayer.nVersion,
               offsetof(LAYERPLANEDESCRIPTOR, cAccumBits) -
               offsetof(LAYERPLANEDESCRIPTOR, nVersion));
        plpd->cAccumBits      = 0;
        plpd->cAccumRedBits   = 0;
        plpd->cAccumGreenBits = 0;
        plpd->cAccumBlueBits  = 0;
        plpd->cAccumAlphaBits = 0;
        plpd->cDepthBits      = 0;
        plpd->cStencilBits    = 0;
        plpd->cAuxBuffers     = McdLayer.cAuxBuffers;
        plpd->iLayerPlane     = McdLayer.iLayerPlane;
        plpd->bReserved       = 0;
        plpd->crTransparent   = McdLayer.crTransparent;

        bRet = TRUE;
    }

    return bRet;
}


//******************************Public*Routine******************************
//
// LONG APIENTRY MCDSetLayerPalette(HDC hdc, BOOL bRealize,
//                                  LONG cEntries, COLORREF *pcr)
//
// Sets the palette of the specified layer plane.
//
//**************************************************************************

LONG APIENTRY MCDSetLayerPalette(HDC hdc, LONG iLayerPlane, BOOL bRealize,
                                 LONG cEntries, COLORREF *pcr)
{
    LONG lRet = 0;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDSETLAYERPALCMDI) +
                   (255 * sizeof(COLORREF))];
    BYTE *pjBuffer = (BYTE *) NULL;
    MCDESC_HEADER *pmeh;
    MCDSETLAYERPALCMDI *pSetLayerPalCmd;

    // Use stack allocation if possible; otherwise, allocate heap memory for
    // the command buffer.

    if (cEntries <= 256)
    {
        pmeh = (MCDESC_HEADER *)(cmdBuffer);
    }
    else
    {
        LONG lBytes;

        lBytes = sizeof(MCDESC_HEADER) + sizeof(MCDSETLAYERPALCMDI) +
                 ((cEntries - 1) * sizeof(COLORREF));

        pjBuffer = (BYTE *) LocalAlloc(LMEM_FIXED, lBytes);
        pmeh = (MCDESC_HEADER *)pjBuffer;
    }

    if (pmeh != (MCDESC_HEADER *) NULL)
    {
        InitMcdEscEmpty(pmeh);
        pmeh->flags = MCDESC_FL_DISPLAY_LOCK;

        pSetLayerPalCmd = (MCDSETLAYERPALCMDI *)(pmeh + 1);
        pSetLayerPalCmd->command = MCD_SETLAYERPALETTE;
        pSetLayerPalCmd->iLayerPlane = iLayerPlane;
        pSetLayerPalCmd->bRealize = bRealize;
        pSetLayerPalCmd->cEntries = cEntries;
        memcpy(&pSetLayerPalCmd->acr[0], pcr, cEntries * sizeof(COLORREF));

        lRet = (BOOL)EXTESCAPE(hdc, MCDFUNCS,
                               sizeof(cmdBuffer),
                               (char *)pmeh, 0, (char *)NULL);
    }

    // Delete the heap memory if it was allocated for the command buffer.

    if (pjBuffer)
    {
        LocalFree(pjBuffer);
    }

    return lRet;
}

//******************************Public*Routine******************************
//
// ULONG APIENTRY MCDDrawPixels(MCDCONTEXT *pMCDContext, ULONG width,
//                              ULONG height, ULONG format, ULONG type,
//                              VOID *pPixels, BOOL packed)
//
// MCD version of glDrawPixels
//
//**************************************************************************

ULONG APIENTRY MCDDrawPixels(MCDCONTEXT *pMCDContext, ULONG width,
                             ULONG height, ULONG format, ULONG type,
                             VOID *pPixels, BOOL packed)
{
    ULONG ulRet = (ULONG) FALSE;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDDRAWPIXELSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDDRAWPIXELSCMDI *pPixelsCmd;

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return 0;
    }

    pPixelsCmd = (MCDDRAWPIXELSCMDI *)(pmeh + 1);
    pPixelsCmd->command = MCD_DRAW_PIXELS;
    pPixelsCmd->width = width;
    pPixelsCmd->height = height;
    pPixelsCmd->format = format;
    pPixelsCmd->type = type;
    pPixelsCmd->packed = packed;
    pPixelsCmd->pPixels = pPixels;

    ulRet = (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                             sizeof(cmdBuffer), (char *)pmeh,
                             0, (char *)NULL);

    return ulRet;
}

//******************************Public*Routine******************************
//
// ULONG APIENTRY MCDReadPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y,
//                              ULONG width, ULONG height, ULONG format,
//                              ULONG type, VOID *pPixels)
//
// MCD version of glReadPixels
//
//**************************************************************************

ULONG APIENTRY MCDReadPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y,
                             ULONG width, ULONG height, ULONG format,
                             ULONG type, VOID *pPixels)
{
    ULONG ulRet = (ULONG) FALSE;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDREADPIXELSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDREADPIXELSCMDI *pPixelsCmd;

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return 0;
    }

    pPixelsCmd = (MCDREADPIXELSCMDI *)(pmeh + 1);
    pPixelsCmd->command = MCD_READ_PIXELS;
    pPixelsCmd->x = x;
    pPixelsCmd->y = y;
    pPixelsCmd->width = width;
    pPixelsCmd->height = height;
    pPixelsCmd->format = format;
    pPixelsCmd->type = type;
    pPixelsCmd->pPixels = pPixels;

    ulRet = (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                             sizeof(cmdBuffer), (char *)pmeh,
                             0, (char *)NULL);

    return ulRet;
}

//******************************Public*Routine******************************
//
// ULONG APIENTRY MCDCopyPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y,
//                              ULONG width, ULONG height, ULONG type)
//
// MCD version of glCopyPixels
//
//**************************************************************************

ULONG APIENTRY MCDCopyPixels(MCDCONTEXT *pMCDContext, LONG x, LONG y,
                             ULONG width, ULONG height, ULONG type)
{
    ULONG ulRet = (ULONG) FALSE;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDCOPYPIXELSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDCOPYPIXELSCMDI *pPixelsCmd;

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    if (SUPPORTS_DIRECT())
    {
        pmeh->flags |= MCDESC_FL_SURFACES;
    }
    else if (pmeh->msrfColor.hSurf != NULL ||
             pmeh->msrfDepth.hSurf != NULL)
    {
        return 0;
    }

    pPixelsCmd = (MCDCOPYPIXELSCMDI *)(pmeh + 1);
    pPixelsCmd->command = MCD_COPY_PIXELS;
    pPixelsCmd->x = x;
    pPixelsCmd->y = y;
    pPixelsCmd->width = width;
    pPixelsCmd->height = height;
    pPixelsCmd->type = type;

    ulRet = (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                             sizeof(cmdBuffer), (char *)pmeh,
                             0, (char *)NULL);

    return ulRet;
}

//******************************Public*Routine******************************
//
// ULONG APIENTRY MCDPixelMap(MCDCONTEXT *pMCDContext, ULONG mapType,
//                            ULONG mapSize, VOID *pMap)
//
// MCD version of glPixelMap
//
//**************************************************************************

ULONG APIENTRY MCDPixelMap(MCDCONTEXT *pMCDContext, ULONG mapType,
                           ULONG mapSize, VOID *pMap)
{
    ULONG ulRet = (ULONG) FALSE;
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDPIXELMAPCMDI)];
    MCDESC_HEADER *pmeh;
    MCDPIXELMAPCMDI *pPixelsCmd;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)(cmdBuffer), pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pPixelsCmd = (MCDPIXELMAPCMDI *)(pmeh + 1);
    pPixelsCmd->command = MCD_PIXEL_MAP;
    pPixelsCmd->mapType = mapType;
    pPixelsCmd->mapSize = mapSize;
    pPixelsCmd->pMap = pMap;

    ulRet = (ULONG)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                             sizeof(cmdBuffer), (char *)pmeh,
                             0, (char *)NULL);

    return ulRet;
}

//******************************Public*Routine******************************
//
// MCDDestroyWindow
//
// Forwards user-mode window destruction notification to the server for
// resource cleanup
//
//**************************************************************************

void APIENTRY MCDDestroyWindow(HDC hdc, ULONG_PTR dwMcdWindow)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDPIXELMAPCMDI)];
    MCDESC_HEADER *pmeh;
    MCDDESTROYWINDOWCMDI *pmdwc;

    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)cmdBuffer);
    pmeh->dwWindow = dwMcdWindow;
    pmeh->flags = 0;

    pmdwc = (MCDDESTROYWINDOWCMDI *)(pmeh + 1);
    pmdwc->command = MCD_DESTROY_WINDOW;

    EXTESCAPE(hdc, MCDFUNCS,
              sizeof(cmdBuffer), (char *)pmeh,
              0, (char *)NULL);
}

//******************************Public*Routine******************************
//
// MCDGetTextureFormats
//
//**************************************************************************

int APIENTRY MCDGetTextureFormats(MCDCONTEXT *pMCDContext, int nFmts,
                                  struct _DDSURFACEDESC *pddsd)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER) + sizeof(MCDGETTEXTUREFORMATSCMDI)];
    MCDESC_HEADER *pmeh;
    MCDGETTEXTUREFORMATSCMDI *pmgtf;

    pmeh = InitMcdEscContext((MCDESC_HEADER *)cmdBuffer, pMCDContext);
    pmeh->hSharedMem = NULL;
    pmeh->pSharedMem = (VOID *)NULL;
    pmeh->flags = 0;

    pmgtf = (MCDGETTEXTUREFORMATSCMDI *)(pmeh + 1);
    pmgtf->command = MCD_GET_TEXTURE_FORMATS;
    pmgtf->nFmts = nFmts;

    return (int)EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                          sizeof(cmdBuffer), (char *)pmeh,
                          nFmts*sizeof(DDSURFACEDESC), (char *)pddsd);
}

//******************************Public*Routine******************************
//
// MCDSwapMultiple
//
//**************************************************************************

DWORD APIENTRY MCDSwapMultiple(HDC hdc, UINT cBuffers, GENMCDSWAP *pgms)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER)+
                   sizeof(HDC)*MCDESC_MAX_EXTRA_WNDOBJ+
                   sizeof(MCDSWAPMULTIPLECMDI)];
    MCDSWAPMULTIPLECMDI *pSwapMultCmd;
    MCDESC_HEADER *pmeh;
    UINT i;
    HDC *phdc;

    // InitMcdEscSurfaces cannot be used because the context given
    // is a temporary one constructed on the fly since SwapBuffers
    // has only surface information.
    pmeh = InitMcdEscEmpty((MCDESC_HEADER *)cmdBuffer);
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK | MCDESC_FL_EXTRA_WNDOBJ;
    pmeh->cExtraWndobj = cBuffers;

    phdc = (HDC *)(pmeh+1);
    pSwapMultCmd = (MCDSWAPMULTIPLECMDI *)((BYTE *)phdc+cBuffers*sizeof(HDC));
    pSwapMultCmd->command = MCD_SWAP_MULTIPLE;
    pSwapMultCmd->cBuffers = cBuffers;

    for (i = 0; i < cBuffers; i++)
    {
        *phdc++ = pgms->pwswap->hdc;
        pSwapMultCmd->auiFlags[i] = pgms->pwswap->uiFlags;
        pSwapMultCmd->adwMcdWindow[i] = pgms->pwnd->dwMcdWindow;
    }

    return (DWORD)EXTESCAPE(hdc, MCDFUNCS, sizeof(cmdBuffer),
                            (char *)pmeh, 0, (char *)NULL);
}


//******************************Public*Routine******************************
//
// MCDProcessBatch2
//
// Processes a batch of primitives pointed to by pMCDMem.
// This is the 2.0 front-end processing entry point.
//
// Returns last command processed or NULL if all are processed.
//
//**************************************************************************

PVOID APIENTRY MCDProcessBatch2(MCDCONTEXT *pMCDContext,
                                VOID *pMCDCmdMem,
                                VOID *pMCDPrimMem,
                                MCDCOMMAND *pMCDFirstCmd,
                                int cExtraSurfaces,
                                LPDIRECTDRAWSURFACE *pdds,
                                ULONG cmdFlagsAll,
                                ULONG primFlags,
                                MCDTRANSFORM *pMCDTransform,
                                MCDMATERIALCHANGES *pMCDMatChanges)
{
    BYTE cmdBuffer[sizeof(MCDESC_HEADER)+
                   MCD_MAXMIPMAPLEVEL*sizeof(DWORD)];
    MCDESC_HEADER *pmeh;
    MCDMEMHDRI *pMCDCmdMemHdr, *pMCDPrimMemHdr;
    int i;
    ULONG_PTR *pdwSurf;
    MCDPROCESSCMDI *pProcessCmd;

    // Version is checked in mcdcx.c.
    ASSERTOPENGL(SUPPORTS_20(), "MCDProcessBatch2 requires 2.0\n");
    // This function requires 2.0 so direct support should also exist.
    ASSERTOPENGL(SUPPORTS_DIRECT(), "MCDProcessBatch2 requires direct\n");

#if DBG
    if (McdDebugFlags & MCDDEBUG_DISABLE_PROCBATCH)
    {
        MCDSync(pMCDContext);
        return pMCDFirstCmd;
    }
#endif

    pMCDCmdMemHdr = (MCDMEMHDRI *)((char *)pMCDCmdMem - sizeof(MCDMEMHDRI));
    pMCDPrimMemHdr = (MCDMEMHDRI *)((char *)pMCDPrimMem - sizeof(MCDMEMHDRI));

    pmeh = InitMcdEscSurfaces((MCDESC_HEADER *)cmdBuffer, pMCDContext);
    pmeh->hSharedMem = pMCDCmdMemHdr->hMCDMem;
    pmeh->pSharedMem = (char *)pMCDCmdMem;
    pmeh->sharedMemSize = sizeof(MCDPROCESSCMDI);
    pmeh->flags = MCDESC_FL_DISPLAY_LOCK |
        MCDESC_FL_SURFACES | MCDESC_FL_LOCK_SURFACES;

    // Assert that we won't exceed the kernel's expectations
    ASSERTOPENGL(MCD_MAXMIPMAPLEVEL <= MCDESC_MAX_LOCK_SURFACES,
                 "MCD_MAXMIPMAPLEVEL too large\n");

    pmeh->cLockSurfaces = cExtraSurfaces;
    pdwSurf = (ULONG_PTR *)(pmeh+1);
    for (i = 0; i < cExtraSurfaces; i++)
    {
        *pdwSurf++ = ((LPDDRAWI_DDRAWSURFACE_INT)pdds[i])->lpLcl->hDDSurface;
    }

    pProcessCmd = (MCDPROCESSCMDI *)pMCDCmdMem;
    pProcessCmd->command = MCD_PROCESS;
    pProcessCmd->hMCDPrimMem = pMCDPrimMemHdr->hMCDMem;
    pProcessCmd->pMCDFirstCmd = pMCDFirstCmd;
    pProcessCmd->cmdFlagsAll = cmdFlagsAll;
    pProcessCmd->primFlags = primFlags;
    pProcessCmd->pMCDTransform = pMCDTransform;
    pProcessCmd->pMCDMatChanges = pMCDMatChanges;

    return (PVOID)IntToPtr( EXTESCAPE(pMCDContext->hdc, MCDFUNCS,
                                     sizeof(cmdBuffer), (char *)pmeh,
                                     0, (char *)NULL) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\mcd\inc\mcdrvint.h ===
/******************************Module*Header*******************************\
* Module Name: mcdrvint.h
*
* Internal server-side data structure for MCD driver interface.  The driver
* never sees these...
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#ifndef _MCDRVINT_H
#define _MCDRVINT_H

#define MCD_ALLOC_TAG   'xDCM'
#define MCD_MAX_ALLOC	0x40000

#if DBG

#define PRIVATE

VOID MCDDebugPrint(char *, ...);

#define MCDBG_PRINT             MCDDebugPrint

VOID MCDAssertFailed(char *, char *, int);

#define MCDASSERT(expr, msg) \
    if (!(expr)) MCDAssertFailed(msg, __FILE__, __LINE__); else 0

#else

#define MCDBG_PRINT
#define MCDASSERT(expr, msg)
#define PRIVATE		static

#endif

// Inline function to find the intersection of two rectangles:

_inline void MCDIntersectRect(RECTL *pRectInter, RECTL *pRectA, RECTL *pRectB)
{
    // Get intersection of left, right, top, and bottom edges of the
    // two source rectangles:

    pRectInter->left   = max(pRectA->left, pRectB->left);
    pRectInter->right  = min(pRectA->right, pRectB->right);
    pRectInter->top    = max(pRectA->top, pRectB->top);
    pRectInter->bottom = min(pRectA->bottom, pRectB->bottom);
}

#define CHECK_MEM_RANGE_RETVAL(ptr, pMin, pMax, retval)\
{\
    if (((char *)(ptr) > (char *)(pMax)) ||\
        ((char *)(ptr) < (char *)(pMin)))\
    {\
        MCDBG_PRINT("%s(%d): Buffer pointer out of range (%x [%x] %x).",__FILE__,__LINE__,pMin, ptr, pMax);\
        return retval;\
    }\
}

#define CHECK_SIZE_IN(pExec, structure)\
{\
    if (sizeof(structure) > ((char *)pExec->pCmdEnd - (char *)pExec->pCmd)) {\
        MCDBG_PRINT("%s(%d): Input buffer too small",__FILE__,__LINE__);\
        return FALSE;\
    }\
}

#define CHECK_SIZE_OUT(pExec, structure)\
{\
    if ((sizeof(structure) > pExec->cjOut) || (!pExec->pvOut)) {\
        MCDBG_PRINT("%s(%d): Output buffer too small: ptr[%x], size %d",__FILE__,__LINE__, pExec->pvOut, pExec->cjOut);\
        return FALSE;\
    }\
}

#define CHECK_FOR_RC(pExec)\
    if (!pExec->pRcPriv){ \
        MCDBG_PRINT("%s(%d): Invalid (null) RC",__FILE__,__LINE__);\
        return FALSE;\
    }

#define CHECK_FOR_MEM(pExec)\
    if (!pExec->pMemObj){ \
        MCDBG_PRINT("%s(%d): Invalid or null shared memory",__FILE__,__LINE__);\
        return FALSE;\
    }

#define CHECK_FOR_WND(pExec)\
    if (!pExec->pWndPriv){ \
        MCDBG_PRINT("%s(%d): Invalid window region", __FILE__, __LINE__);\
        return FALSE;\
    }

#define GET_MEMOBJ_RETVAL(pMemObj, hMemObj, retval)                           \
    (pMemObj) = (MCDMEMOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)(hMemObj),     \
                                                    MCDHANDLE_MEM);           \
    if (!(pMemObj))							      \
    {									      \
        MCDBG_PRINT("%s(%d): Invalid handle for shared memory.",	      \
                    __FILE__, __LINE__);				      \
        return retval;							      \
    }									      \
    if ((pMemObj)->lockCount)						      \
    {									      \
        MCDBG_PRINT("%s(%d): memory is locked by driver.",		      \
                    __FILE__, __LINE__);				      \
        return retval;							      \
    }

#define ENTER_MCD_LOCK()    
#define LEAVE_MCD_LOCK()    

// Number of list rectangles we can keep in our default buffer:

#define NUM_DEFAULT_CLIP_BUFFER_RECTS   20

// Size in bytes of default buffer size for storing our list of
// current clip rectangles:

#define SIZE_DEFAULT_CLIP_BUFFER        \
    2 * ((NUM_DEFAULT_CLIP_BUFFER_RECTS * sizeof(RECTL)) + sizeof(ULONG))


//
//
//
// Structures.
//
//
//
//

typedef struct _MCDLOCKINFO
{
    BOOL bLocked;
    struct _MCDWINDOWPRIV *pWndPrivOwner;
} MCDLOCKINFO;

typedef struct _MCDGLOBALINFO
{
    SURFOBJ *pso;
    MCDLOCKINFO lockInfo;
    ULONG verMajor;
    ULONG verMinor;
    MCDDRIVER mcdDriver;
    MCDGLOBALDRIVERFUNCS mcdGlobalFuncs;
} MCDGLOBALINFO;

typedef struct _MCDRCOBJ MCDRCOBJ;

typedef struct _MCDWINDOWPRIV {
    MCDWINDOW MCDWindow;            // Put this first since we'll be deriving
                                    // MCDWINDOWPRIV from MCDWINDOW
    MCDHANDLE handle;               // Driver handle for this window
    HWND hWnd;                      // Window with which this is associated
    MCDRCOBJ *objectList;           // List of objects associated with this
                                    // window 
    BOOL bRegionValid;              // Do we have a valid region?
    MCDGLOBALINFO *pGlobal;         // Driver global information
    MCDENUMRECTS *pClipUnscissored; // List of rectangles describing the
                                    // entire current clip region
    MCDENUMRECTS *pClipScissored;   // List of rectangles describing the
                                    // entire current clip region + scissors
    char defaultClipBuffer[SIZE_DEFAULT_CLIP_BUFFER];
                                    // Used for storing above rectangle lists
                                    //   when they can fit
    char *pAllocatedClipBuffer;     // Points to allocated storage for storing
                                    //   rectangle lists when they don't fit
                                    //   in 'defaultClipBuffer'.  NULL if
                                    //   not allocated.
    ULONG sizeClipBuffer;           // Size of clip storage pointed to by
                                    //   'pClipScissored' taking both
                                    //   lists into account.
    BOOL bBuffersValid;             // Validity of buffer cache.
    MCDRECTBUFFERS mbufCache;       // Cached buffer information.
    WNDOBJ *pwo;                    // WNDOBJ for this window.
} MCDWINDOWPRIV;

typedef struct _MCDRCPRIV {
    MCDRC MCDRc;
    BOOL bValid;
    BOOL bDrvValid;
    HWND hWnd;
    HDEV hDev;
    RECTL scissorsRect;
    BOOL scissorsEnabled;
    LONG reserved[4];
    ULONG surfaceFlags;             // surface flags with which RC was created
    MCDGLOBALINFO *pGlobal;
} MCDRCPRIV;

typedef enum {
    MCDHANDLE_RC,
    MCDHANDLE_MEM,
    MCDHANDLE_TEXTURE,
    MCDHANDLE_WINDOW
} MCDHANDLETYPE;

typedef struct _MCDTEXOBJ {
    MCDHANDLETYPE type;         // Object type
    MCDTEXTURE MCDTexture;
    ULONG_PTR pid;              // creator process ID
    ULONG size;                 // size of this structure
    MCDGLOBALINFO *pGlobal;
} MCDTEXOBJ;

typedef struct _MCDMEMOBJ {
    MCDHANDLETYPE type;         // Object type
    MCDMEM MCDMem;              // meat of the object
    ULONG_PTR pid;              // creator process ID
    ULONG size;                 // size of this structure
    ULONG lockCount;            // number of locks on the memory
    UCHAR *pMemBaseInternal;    // internal pointer to memory
    MCDGLOBALINFO *pGlobal;
} MCDMEMOBJ;

typedef struct _MCDRCOBJ {
    MCDHANDLETYPE type;
    MCDRCPRIV *pRcPriv;         // need this for driver free function
    ULONG_PTR pid;              // creator process ID
    ULONG size;                 // size of the RC-bound object
    MCDHANDLE handle;
    MCDRCOBJ *next;
} MCDRCOBJ;

typedef struct _MCDWINDOWOBJ {
    MCDHANDLETYPE type;
    MCDWINDOWPRIV MCDWindowPriv;
} MCDWINDOWOBJ;

typedef struct _MCDEXEC {
    MCDESC_HEADER *pmeh;        // MCDESC_HEADER for command buffer
    MCDHANDLE hMCDMem;          // handle to command memory
    MCDCMDI *pCmd;              // start of current command
    MCDCMDI *pCmdEnd;           // end of command buffer
    PVOID pvOut;                // output buffer
    LONG cjOut;                 // output buffer size
    LONG inBufferSize;          // input buffer size
    struct _MCDRCPRIV *pRcPriv; // current rendering context
    struct _MCDWINDOWPRIV *pWndPriv;   // window info
    struct _MCDGLOBALINFO *pGlobal;    // global info
    MCDMEMOBJ *pMemObj;         // shared-memory cache for commands/data
    MCDSURFACE MCDSurface;      // device surface
    WNDOBJ **ppwoMulti;         // Array of WNDOBJs for multi-swap
    HDEV hDev;                  // Engine handle (NT only)
} MCDEXEC;

ULONG_PTR MCDSrvProcess(MCDEXEC *pMCDExec);
MCDHANDLE MCDSrvCreateContext(MCDSURFACE *pMCDSurface,
                              MCDRCINFOPRIV *pMcdRcInfo,
                              MCDGLOBALINFO *pGlobal,
                              LONG iPixelFormat, LONG iLayer, HWND hWnd,
                              ULONG surfaceFlags, ULONG contextFlags);
MCDHANDLE MCDSrvCreateTexture(MCDEXEC *pMCDExec, MCDTEXTUREDATA *pTexData, 
                              VOID *pSurface, ULONG flags);
UCHAR * MCDSrvAllocMem(MCDEXEC *pMCDExec, ULONG numBytes,
                       ULONG flags, MCDHANDLE *phMem);
ULONG MCDSrvQueryMemStatus(MCDEXEC *pMCDExec, MCDHANDLE hMCDMem);
BOOL MCDSrvSetScissor(MCDEXEC *pMCDExec, RECTL *pRect, BOOL bEnabled);
MCDWINDOW *MCDSrvNewMCDWindow(MCDSURFACE *pMCDSurface, HWND hWnd,
                              MCDGLOBALINFO *pGlobal, HDEV hdev);


BOOL CALLBACK FreeMemObj(DRIVEROBJ *pDrvObj);
BOOL CALLBACK FreeTexObj(DRIVEROBJ *pDrvObj);
BOOL CALLBACK FreeRCObj(DRIVEROBJ *pDrvObj);
BOOL DestroyMCDObj(MCDHANDLE handle, MCDHANDLETYPE handleType);
VOID GetScissorClip(MCDWINDOWPRIV *pWndPriv, MCDRCPRIV *pRcPriv);

// Internal engine functions:

WNDOBJ *MCDEngGetWndObj(MCDSURFACE *pMCDSurface);
VOID MCDEngUpdateClipList(WNDOBJ *pwo);
DRIVEROBJ *MCDEngLockObject(MCDHANDLE hObj);
VOID MCDEngUnlockObject(MCDHANDLE hObj);
WNDOBJ *MCDEngCreateWndObj(MCDSURFACE *pMCDSurface, HWND hWnd,
                           WNDOBJCHANGEPROC pChangeProc);
MCDHANDLE MCDEngCreateObject(VOID *pOject, FREEOBJPROC pFreeObjFunc,
                             HDEV hDevEng);
BOOL MCDEngDeleteObject(MCDHANDLE hObj);
UCHAR *MCDEngAllocSharedMem(ULONG numBytes);
VOID MCDEngFreeSharedMem(UCHAR *pMem);
VOID *MCDEngGetPtrFromHandle(HANDLE handle, MCDHANDLETYPE type);
ULONG_PTR MCDEngGetProcessID();


// Debugging stuff:


#if DBG
UCHAR *MCDSrvDbgLocalAlloc(UINT, UINT);
VOID MCDSrvDbgLocalFree(UCHAR *);

#define MCDSrvLocalAlloc   MCDSrvDbgLocalAlloc
#define MCDSrvLocalFree    MCDSrvDbgLocalFree

VOID MCDebugPrint(char *, ...);

#define MCDBG_PRINT             MCDDebugPrint

#else

UCHAR *MCDSrvLocalAlloc(UINT, UINT);
VOID MCDSrvLocalFree(UCHAR *);
#define MCDBG_PRINT

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\mcd\server\mcdsrv.c ===
/******************************Module*Header*******************************\
* Module Name: mcdsrv.c
*
* This module contains the trusted component of the MCD server-side engine.
* This module performs handle management and parameter-checking and validation
* to the extent possible.  This module also makes the calls to the device
* driver, and provides callbacks to the driver for things such as handle
* referencing.
*
* Goals
* -----
*
* Pervasive throughout this implementation is the influence of the
* following goals:
*
* 1. Robustness
*
*    Windows NT is first and foremost a robust operating system.  There
*    is a simple measure for this: a robust system should never crash.
*    Because the display driver is a trusted component of the operating
*    system, and because the MCD is directly callable from OpenGL from
*    the client side of the OS (and thus untrusted), this has a significant
*    impact on the way we must do things.
*
* 2. Performance
*
*    Performance is the 'raison d'etre' of the MCD; we have tried to
*    have as thin a layer above the rendering code as we could.
*
* 3. Portability
*
*    This implementation is intended portable to different processor types,
*    and to the Windows 95 operating system.
*
* Obviously, Windows 95 implementations may choose to have a different
* order of priority for these goals, and so some of the robustness
* code may be eliminated.  But it is still recommended that it be kept;
* the overhead is reasonably minimal, and people really don't like it
* when their systems crash...
*
* The Rules of Robustness
* -----------------------
*
* 1. Nothing given by the caller can be trusted.
*
*    For example, handles cannot be trusted to be valid.  Handles passed
*    in may actually be for objects not owned by the caller.  Pointers
*    and offsets may not be correctly aligned.  Pointers, offsets, and
*    coordinates may be out of bounds.
*
* 2. Parameters can be asynchronously modified at any time.
*
*    Many commands come from shared memory sections, and any data therein
*    may be asynchronously modified by other threads in the calling
*    application.  As such, parameters may never be validated in-place
*    in the shared section, because the application may corrupt the data
*    after validation but before its use.  Instead, parameters must always
*    be first copied out of the window, and then validated on the safe
*    copy.
*
* 3. We must clean up.
*
*    Applications may die at any time before calling the appropriate
*    clean up functions.  As such, we have to be prepared to clean up
*    any resources ourselves when the application dies.
*
* Copyright (c) 1994, 1995, 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <windows.h>

#include <wtypes.h>

#include <winddi.h>
#include <mcdesc.h>

#include "mcdrv.h"
#include <mcd2hack.h>
#include "mcd.h"
#include "mcdint.h"
#include "mcdrvint.h"


// Checks MCD version to see if the driver can accept direct buffer
// access.  Direct access was introduced in 1.1.
#define SUPPORTS_DIRECT(pGlobal) \
    ((pGlobal)->verMinor >= 0x10 || (pGlobal)->verMajor > 1)


////////////////////////////////////////////////////////////////////////////
//
//
// Declarations for internal support functions for an MCD locking mechanism
// that can be used to synchronize multiple processes/thread that use MCD.
//
//
////////////////////////////////////////////////////////////////////////////

ULONG MCDSrvLock(MCDWINDOWPRIV *);
VOID MCDSrvUnlock(MCDWINDOWPRIV *);


////////////////////////////////////////////////////////////////////////////
//
// Declarations for internal per-driver-instance list that all global
// data is kept in.  The list is indexed by pso.
//
////////////////////////////////////////////////////////////////////////////

// Space for one old-style driver to hold its information statically.
MCDGLOBALINFO gStaticGlobalInfo;

BOOL           MCDSrvInitGlobalInfo(void);
void           MCDSrvUninitGlobalInfo(void);
MCDGLOBALINFO *MCDSrvAddGlobalInfo(SURFOBJ *pso);
MCDGLOBALINFO *MCDSrvGetGlobalInfo(SURFOBJ *pso);


////////////////////////////////////////////////////////////////////////////
//
//
// Server subsystem entry points.
//
//
////////////////////////////////////////////////////////////////////////////

//****************************************************************************
//
// MCD initialization functions.
//
// NT 4.0 MCD support exported MCDEngInit which display drivers call
// to initialize the MCD server-side code.  MCDEngInit only allowed
// one driver instance to initialize and never uninitialized.
//
// This doesn't work very well with mode changes or multimon so for
// NT 5.0 MCDEngInitEx was added.  MCDEngInitEx has two differences
// from MCDEngInit:
// 1. MCDEngInitEx takes a table of global driver functions instead of
//    just the MCDrvGetEntryPoints function.  Currently the table only
//    has one entry for MCDrvGetEntryPoints but it allows for future
//    expansion.
// 2. Calling MCDEngInitEx implies that the driver will call MCDEngUninit
//    so that per-driver-instance state can be cleaned up.
//
//****************************************************************************

BOOL MCDEngInternalInit(SURFOBJ *pso,
                        MCDGLOBALDRIVERFUNCS *pMCDGlobalDriverFuncs,
                        BOOL bAddPso)
{
    MCDSURFACE mcdSurface;
    MCDDRIVER mcdDriver;
    MCDGLOBALINFO *pGlobal;

    mcdSurface.pWnd = NULL;
    mcdSurface.pwo = NULL;
    mcdSurface.surfaceFlags = 0;
    mcdSurface.pso = pso;

    memset(&mcdDriver, 0, sizeof(MCDDRIVER));
    mcdDriver.ulSize = sizeof(MCDDRIVER);

    if (pMCDGlobalDriverFuncs->pMCDrvGetEntryPoints == NULL ||
        !pMCDGlobalDriverFuncs->pMCDrvGetEntryPoints(&mcdSurface, &mcdDriver))
    {
        MCDBG_PRINT("MCDEngInit: Could not get driver entry points.");
        return FALSE;
    }

    if (bAddPso)
    {
        if (!MCDSrvInitGlobalInfo())
        {
            return FALSE;
        }

        pGlobal = MCDSrvAddGlobalInfo(pso);
        if (pGlobal == NULL)
        {
            MCDSrvUninitGlobalInfo();
            return FALSE;
        }
    }
    else
    {
        pGlobal = &gStaticGlobalInfo;
    }
    
    // Guaranteed to be zero-filled and pso set so only fill in interesting
    // fields.
    // verMajor and verMinor can not be filled out yet so they are
    // left at zero to indicate the most conservative possible version
    // number.  They are filled in with correct information when DRIVERINFO
    // is processed.
    pGlobal->mcdDriver = mcdDriver;
    pGlobal->mcdGlobalFuncs = *pMCDGlobalDriverFuncs;
    
    return TRUE;
}

#define MGDF_SIZE (sizeof(ULONG)+sizeof(void *))

BOOL WINAPI MCDEngInitEx(SURFOBJ *pso,
                         MCDGLOBALDRIVERFUNCS *pMCDGlobalDriverFuncs,
                         void *pReserved)
{
    if (pso == NULL ||
        pMCDGlobalDriverFuncs->ulSize != MGDF_SIZE ||
        pReserved != NULL)
    {
        return FALSE;
    }
    
    return MCDEngInternalInit(pso, pMCDGlobalDriverFuncs, TRUE);
}

BOOL WINAPI MCDEngInit(SURFOBJ *pso,
                       MCDRVGETENTRYPOINTSFUNC pGetDriverEntryFunc)
{
    MCDGLOBALDRIVERFUNCS mgdf;

    // The old-style initialization function is being called so
    // we must assume that the uninit function will not be called.
    // This means that we cannot allocate resources for the global
    // info list since we won't be able to clean them up.  Without
    // a global info list we are restricted to using global variables
    // and thus only one old-style init is allowed per load.
    
    if (pso == NULL ||
        pGetDriverEntryFunc == NULL ||
        gStaticGlobalInfo.pso != NULL)
    {
        return FALSE;
    }

    gStaticGlobalInfo.pso = pso;
    
    memset(&mgdf, 0, sizeof(mgdf));
    mgdf.ulSize = sizeof(ULONG)+sizeof(void *);
    mgdf.pMCDrvGetEntryPoints = pGetDriverEntryFunc;
    
    return MCDEngInternalInit(pso, &mgdf, FALSE);
}


//****************************************************************************
// BOOL MCDEngEscFilter(SURFOBJ *, ULONG, ULONG, VOID *, ULONG cjOut,
//                      VOID *pvOut)
//
// MCD escape filter.  This function should return TRUE for any
// escapes functions which this filter processed, FALSE otherwise (in which
// case the caller should continue to process the escape).
//****************************************************************************

BOOL WINAPI MCDEngEscFilter(SURFOBJ *pso, ULONG iEsc,
                            ULONG cjIn, VOID *pvIn,
                            ULONG cjOut, VOID *pvOut, ULONG_PTR *pRetVal)
{
    MCDEXEC MCDExec;
    MCDESC_HEADER *pmeh;
    MCDESC_HEADER_NTPRIVATE *pmehPriv;

    switch (iEsc)
    {
        case QUERYESCSUPPORT:

            // Note:  we don't need to check cjIn for this case since
            // NT's GDI validates this for use.

            return (BOOL)(*pRetVal = (*(ULONG *) pvIn == MCDFUNCS));

        case MCDFUNCS:

            MCDExec.pmeh = pmeh = (MCDESC_HEADER *)pvIn;

            // This is an MCD function.  Under Windows NT, we've
            // got an MCDESC_HEADER_NTPRIVATE structure which we may need
            // to use if the escape does not use driver-created
            // memory.

            // Package the things we need into the MCDEXEC structure:

            pmehPriv = (MCDESC_HEADER_NTPRIVATE *)(pmeh + 1);

            MCDExec.ppwoMulti = (WNDOBJ **)pmehPriv->pExtraWndobj;
            MCDExec.MCDSurface.pwo = pmehPriv->pwo;

            if (pmeh->dwWindow != 0)
            {
                MCDWINDOWOBJ *pmwo;

                // The client side code has given us back the handle
                // to the MCDWINDOW structure as an identifier.  Since it
                // came from user-mode it is suspect and must be validated
                // before continuing.
                pmwo = (MCDWINDOWOBJ *)
                    MCDEngGetPtrFromHandle((MCDHANDLE)pmeh->dwWindow,
                                           MCDHANDLE_WINDOW);
                if (pmwo == NULL)
                {
                    return FALSE;
                }
                MCDExec.pWndPriv = &pmwo->MCDWindowPriv;
            }
            else
            {
                MCDExec.pWndPriv = NULL;
            }

            MCDExec.MCDSurface.pso = pso;
            MCDExec.MCDSurface.pWnd = (MCDWINDOW *)MCDExec.pWndPriv;
            MCDExec.MCDSurface.surfaceFlags = 0;

            MCDExec.pvOut = pvOut;
            MCDExec.cjOut = cjOut;

            if (!pmeh->hSharedMem) {

                *pRetVal = (ULONG)FALSE;

                if (!pmehPriv->pBuffer)
                    return (ULONG)TRUE;

                if (pmehPriv->bufferSize < sizeof(MCDCMDI))
                    return (ULONG)TRUE;

                MCDExec.pCmd = (MCDCMDI *)(pmehPriv->pBuffer);
                MCDExec.pCmdEnd = (MCDCMDI *)((char *)MCDExec.pCmd +
                                             pmehPriv->bufferSize);
                MCDExec.inBufferSize = pmehPriv->bufferSize;
                MCDExec.hMCDMem = (MCDHANDLE)NULL;
            } else
                MCDExec.hMCDMem = pmeh->hSharedMem;

            ENTER_MCD_LOCK();

            *pRetVal = MCDSrvProcess(&MCDExec);

            LEAVE_MCD_LOCK();

            return TRUE;

        default:
            return (ULONG)FALSE;
            break;
    }

    return (ULONG)FALSE;    // Should never get here...
}


//****************************************************************************
// BOOL MCDEngSetMemStatus(MCDMEM *pMCDMem, ULONG status);
//
// Sets the memory status to the desired value.  This is called by the
// driver to set and reset the busy flags for a chunk of memory to allow
// DMA.
//****************************************************************************


BOOL WINAPI MCDEngSetMemStatus(MCDMEM *pMCDMem, ULONG status)
{
    MCDMEMOBJ *pMemObj;
    ULONG retVal;

    pMemObj = (MCDMEMOBJ *)((char *)pMCDMem - sizeof(MCDHANDLETYPE));

    if (pMemObj->type != MCDHANDLE_MEM) {
        return FALSE;
    }

    switch (status) {
        case MCDRV_MEM_BUSY:
            pMemObj->lockCount++;
            break;
        case MCDRV_MEM_NOT_BUSY:
            pMemObj->lockCount--;
            break;
        default:
            return (ULONG)FALSE;
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//
// Private server-side funtions.
//
//
////////////////////////////////////////////////////////////////////////////

//****************************************************************************
// CallGetBuffers
//
// Wrapper for MCDrvGetBuffers that does appropriate checks, setup,
// cache management and data translation.
//****************************************************************************

PRIVATE
ULONG CallGetBuffers(MCDEXEC *pMCDExec, MCDRC *pRc, MCDRECTBUFFERS *pBuf)
{
    ULONG ulRet;
    
    if (!pMCDExec->pGlobal->mcdDriver.pMCDrvGetBuffers)
    {
        MCDBG_PRINT("MCDrvGetBuffers: missing entry point.");
        return FALSE;
    }

    // Clip lists need to be valid so drivers can do different
    // things based on whether the surface is trivially visible or not.
    GetScissorClip(pMCDExec->pWndPriv, pMCDExec->pRcPriv);
    
    // Should be casting to MCDRECTBUFFERS with correct
    // 1.1 header.
    ulRet = (ULONG)(*pMCDExec->pGlobal->mcdDriver.pMCDrvGetBuffers)
        (&pMCDExec->MCDSurface, pRc, (MCDBUFFERS *)pBuf);
            
    // Update cached buffers information on success.
    if (ulRet)
    {
        if (SUPPORTS_DIRECT(pMCDExec->pGlobal))
        {
            // This is a 1.1 or greater driver and has returned
            // full MCDRECTBUFFERS information.  Cache it
            // for possible later use.
                    
            pMCDExec->pWndPriv->bBuffersValid = TRUE;
            pMCDExec->pWndPriv->mbufCache = *pBuf;
        }
        else
        {
            MCDBUFFERS mbuf;
            MCDRECTBUFFERS *mrbuf;
                    
            // This is a 1.0 driver and has only returned
            // MCDBUFFERS information.  Expand it into
            // an MCDRECTBUFFERS.  The rectangles don't
            // really matter to software so they can
            // be zeroed.
                    
            mbuf = *(MCDBUFFERS *)pBuf;
            mrbuf = pBuf;
            *(MCDBUF *)&mrbuf->mcdFrontBuf = mbuf.mcdFrontBuf;
            memset(&mrbuf->mcdFrontBuf.bufPos, 0, sizeof(RECTL));
            *(MCDBUF *)&mrbuf->mcdBackBuf = mbuf.mcdBackBuf;
            memset(&mrbuf->mcdBackBuf.bufPos, 0, sizeof(RECTL));
            *(MCDBUF *)&mrbuf->mcdDepthBuf = mbuf.mcdDepthBuf;
            memset(&mrbuf->mcdDepthBuf.bufPos, 0, sizeof(RECTL));
        }
    }

    return ulRet;
}

//****************************************************************************
// ULONG_PTR MCDSrvProcess(MCDEXEC *pMCDExec)
//
// This is the main MCD function handler.  At this point, there should
// be no platform-specific code since these should have been resolved by
// the entry function.
//****************************************************************************

PRIVATE
ULONG_PTR MCDSrvProcess(MCDEXEC *pMCDExec)
{
    UCHAR *pMaxMem;
    UCHAR *pMinMem;
    MCDESC_HEADER *pmeh = pMCDExec->pmeh;
    MCDRC *pRc;
    MCDMEM *pMCDMem;
    MCDMEMOBJ *pMemObj;
    MCDRCPRIV *pRcPriv;
    ULONG_PTR ulRet;

    // If the command buffer is in shared memory, dereference the memory
    // from the handle and check the bounds.

    if (pMCDExec->hMCDMem)
    {
        GET_MEMOBJ_RETVAL(pMemObj, pmeh->hSharedMem, FALSE);

        pMinMem = pMemObj->MCDMem.pMemBase;

        // Note: we ignore the memory size in the header since it doesn't
        // really help us...
	
        pMaxMem = pMinMem + pMemObj->MCDMem.memSize;

        pMCDExec->pCmd = (MCDCMDI *)((char *)pmeh->pSharedMem);
        pMCDExec->pCmdEnd = (MCDCMDI *)pMaxMem;

        CHECK_MEM_RANGE_RETVAL(pMCDExec->pCmd, pMinMem, pMaxMem, FALSE);

        pMCDExec->inBufferSize = pmeh->sharedMemSize;

        pMCDExec->pMemObj = pMemObj;
    } else
        pMCDExec->pMemObj = (MCDMEMOBJ *)NULL;


    // Get the rendering context if we have one, and process the command:

    if (pmeh->hRC)
    {
        MCDRCOBJ *pRcObj;

        pRcObj = (MCDRCOBJ *)MCDEngGetPtrFromHandle(pmeh->hRC, MCDHANDLE_RC);

        if (!pRcObj)
        {
            MCDBG_PRINT("MCDSrvProcess: Invalid rendering context handle %x.",
                        pmeh->hRC);
            return FALSE;
        }

        pMCDExec->pRcPriv = pRcPriv = pRcObj->pRcPriv;

        if (!pRcPriv->bValid)
        {
            MCDBG_PRINT("MCDSrvProcess: RC has been invalidated for this window.");
            return FALSE;
        }

        if ((!pMCDExec->pWndPriv)) {
            if (pMCDExec->pCmd->command != MCD_BINDCONTEXT) {
                MCDBG_PRINT("MCDSrvProcess: NULL WndObj with RC.");
                return FALSE;
            }
        } else {
            // Validate the window in the RC with the window for this escape:

            if ((pRcPriv->hWnd != pMCDExec->pWndPriv->hWnd) &&
                (pMCDExec->pCmd->command != MCD_BINDCONTEXT))
            {
                MCDBG_PRINT("MCDSrvProcess: Invalid RC for this window.");
                return FALSE;
            }
        }

        // For Win95, we need to poll for the clip region:
        // Clipping needs to be un-broken
        if (pMCDExec->MCDSurface.pwo != NULL)
        {
            MCDEngUpdateClipList(pMCDExec->MCDSurface.pwo);
        }

        pMCDExec->MCDSurface.surfaceFlags |= pRcPriv->surfaceFlags;

    } else {
        pMCDExec->pRcPriv = (MCDRCPRIV *)NULL;
    }

    // Get global driver information.
    if (pMCDExec->pWndPriv != NULL)
    {
        pMCDExec->pGlobal = pMCDExec->pWndPriv->pGlobal;
    }
    else if (pMCDExec->pRcPriv != NULL)
    {
        pMCDExec->pGlobal = pMCDExec->pRcPriv->pGlobal;
    }
    else
    {
        pMCDExec->pGlobal =
            MCDSrvGetGlobalInfo(pMCDExec->MCDSurface.pso);
        if (pMCDExec->pGlobal == NULL)
        {
            MCDBG_PRINT("Unable to find global information");
            return FALSE;
        }
    }

    // If direct surface information was included then
    // fill out the extra surface information in the MCDSURFACE
    // NOCLIP setting?

#if MCD_VER_MAJOR >= 2 || (MCD_VER_MAJOR == 1 && MCD_VER_MINOR >= 0x10)
    pMCDExec->MCDSurface.direct.mcdFrontBuf.bufFlags = 0;
    pMCDExec->MCDSurface.direct.mcdBackBuf.bufFlags = 0;
    pMCDExec->MCDSurface.direct.mcdDepthBuf.bufFlags = 0;

    pMCDExec->MCDSurface.frontId = 0;
    pMCDExec->MCDSurface.backId = 0;
    pMCDExec->MCDSurface.depthId = 0;

    if (pmeh->flags & MCDESC_FL_SURFACES)
    {
        pMCDExec->MCDSurface.surfaceFlags |= MCDSURFACE_DIRECT;

        // Refresh cached buffer information if it's invalid
        // and we need it
        if (pmeh->msrfColor.hSurf == NULL &&
            pmeh->msrfDepth.hSurf == NULL)
        {
            if (pMCDExec->pWndPriv == NULL)
            {
                return FALSE;
            }

            if (!pMCDExec->pWndPriv->bBuffersValid)
            {
                MCDRECTBUFFERS mbuf;

                if (!CallGetBuffers(pMCDExec, NULL, &mbuf))
                {
                    return FALSE;
                }
            }

            pMCDExec->MCDSurface.direct = pMCDExec->pWndPriv->mbufCache;
        }
        else
        {
            if (pmeh->msrfColor.hSurf != NULL)
            {
                pMCDExec->MCDSurface.frontId = (DWORD)
                    pmeh->msrfColor.hSurf;
                pMCDExec->MCDSurface.direct.mcdFrontBuf.bufFlags =
                    MCDBUF_ENABLED;
                pMCDExec->MCDSurface.direct.mcdFrontBuf.bufOffset =
                    pmeh->msrfColor.lOffset;
                pMCDExec->MCDSurface.direct.mcdFrontBuf.bufStride =
                    pmeh->msrfColor.lStride;
                pMCDExec->MCDSurface.direct.mcdFrontBuf.bufPos =
                    pmeh->msrfColor.rclPos;
            }

            if (pmeh->msrfDepth.hSurf != NULL)
            {
                pMCDExec->MCDSurface.depthId = (DWORD)
                    pmeh->msrfDepth.hSurf;
                pMCDExec->MCDSurface.direct.mcdDepthBuf.bufFlags =
                    MCDBUF_ENABLED;
                pMCDExec->MCDSurface.direct.mcdDepthBuf.bufOffset =
                    pmeh->msrfDepth.lOffset;
                pMCDExec->MCDSurface.direct.mcdDepthBuf.bufStride =
                    pmeh->msrfDepth.lStride;
                pMCDExec->MCDSurface.direct.mcdDepthBuf.bufPos =
                    pmeh->msrfDepth.rclPos;
            }
        }
    }
#endif // 1.1


    /////////////////////////////////////////////////////////////////
    // If the drawing-batch flag is set, call the main driver drawing
    // routine:
    /////////////////////////////////////////////////////////////////

    if (pmeh->flags & MCDESC_FL_BATCH)
    {
        CHECK_FOR_RC(pMCDExec);
        CHECK_FOR_MEM(pMCDExec);
        GetScissorClip(pMCDExec->pWndPriv, pMCDExec->pRcPriv);
        if (!pMCDExec->pGlobal->mcdDriver.pMCDrvDraw)
        {
            if (pMCDExec->pGlobal->mcdDriver.pMCDrvSync)
            {
                (*pMCDExec->pGlobal->mcdDriver.pMCDrvSync)(&pMCDExec->MCDSurface,
                  &pMCDExec->pRcPriv->MCDRc);
            }
            return (ULONG_PTR)pMCDExec->pCmd;
        }
        return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvDraw)(&pMCDExec->MCDSurface,
                        &pMCDExec->pRcPriv->MCDRc, &pMemObj->MCDMem,
                        (UCHAR *)pMCDExec->pCmd, (UCHAR *)pMCDExec->pCmdEnd);
    }

    if (pmeh->flags & MCDESC_FL_CREATE_CONTEXT)
    {
        MCDCREATECONTEXT *pmcc = (MCDCREATECONTEXT *)pMCDExec->pCmd;
        MCDRCINFOPRIV *pMcdRcInfo = pmcc->pRcInfo;
        
        CHECK_SIZE_IN(pMCDExec, MCDCREATECONTEXT);
        CHECK_SIZE_OUT(pMCDExec, MCDRCINFOPRIV);

        try {
            EngProbeForRead(pMcdRcInfo, sizeof(MCDRCINFOPRIV),
                            sizeof(ULONG));
            RtlCopyMemory(pMCDExec->pvOut, pMcdRcInfo,
                          sizeof(MCDRCINFOPRIV));
        } except (EXCEPTION_EXECUTE_HANDLER) {
            MCDBG_PRINT("MCDrvCreateContext: Invalid memory for MCDRCINFO.");
            return FALSE;
        }

        pMcdRcInfo = (MCDRCINFOPRIV *)pMCDExec->pvOut;
        pMcdRcInfo->mri.requestFlags = 0;

        return (ULONG_PTR)MCDSrvCreateContext(&pMCDExec->MCDSurface,
                                          pMcdRcInfo, pMCDExec->pGlobal,
                                          pmcc->ipfd, pmcc->iLayer,
                                          pmcc->escCreate.hwnd,
                                          pmcc->escCreate.flags,
                                          pmcc->mcdFlags);
    }
    
    ////////////////////////////////////////////////////////////////////
    // Now, process all of the non-batched drawing and utility commands:
    ////////////////////////////////////////////////////////////////////

    switch (pMCDExec->pCmd->command) {

        case MCD_DESCRIBEPIXELFORMAT:

            CHECK_SIZE_IN(pMCDExec, MCDPIXELFORMATCMDI);

            if (pMCDExec->pvOut) {
                CHECK_SIZE_OUT(pMCDExec, MCDPIXELFORMAT);
            }

            {
                MCDPIXELFORMATCMDI *pMCDPixelFormat =
                    (MCDPIXELFORMATCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvDescribePixelFormat)
                    return 0;

                return (*pMCDExec->pGlobal->mcdDriver.pMCDrvDescribePixelFormat)
                    (&pMCDExec->MCDSurface,
                     pMCDPixelFormat->iPixelFormat,
                     pMCDExec->cjOut,
                     pMCDExec->pvOut, 0);
            }

        case MCD_DRIVERINFO:

            CHECK_SIZE_OUT(pMCDExec, MCDDRIVERINFOI);

            if (!pMCDExec->pGlobal->mcdDriver.pMCDrvInfo)
                return FALSE;

            ulRet = (*pMCDExec->pGlobal->mcdDriver.pMCDrvInfo)
                (&pMCDExec->MCDSurface,
                 (MCDDRIVERINFO *)pMCDExec->pvOut);
            
            if (ulRet)
            {
                // Copy driver function information so that the client
                // side can optimize calls by checking for functions on the
                // client side.

                memcpy(&((MCDDRIVERINFOI *)pMCDExec->pvOut)->mcdDriver,
                       &pMCDExec->pGlobal->mcdDriver, sizeof(MCDDRIVER));

                // Save version information in global info.

                pMCDExec->pGlobal->verMajor =
                    ((MCDDRIVERINFO *)pMCDExec->pvOut)->verMajor;
                pMCDExec->pGlobal->verMinor =
                    ((MCDDRIVERINFO *)pMCDExec->pvOut)->verMinor;
            }

            return ulRet;

        case MCD_DELETERC:

            CHECK_FOR_RC(pMCDExec);

            return (ULONG_PTR)DestroyMCDObj(pmeh->hRC, MCDHANDLE_RC);

        case MCD_ALLOC:

            CHECK_SIZE_IN(pMCDExec, MCDALLOCCMDI);
            CHECK_SIZE_OUT(pMCDExec, MCDHANDLE *);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDALLOCCMDI *pAllocCmd =
                    (MCDALLOCCMDI *)pMCDExec->pCmd;

                return (ULONG_PTR)MCDSrvAllocMem(pMCDExec, pAllocCmd->numBytes,
                                          pAllocCmd->flags,
                                          (MCDHANDLE *)pMCDExec->pvOut);
            }

        case MCD_FREE:

            CHECK_SIZE_IN(pMCDExec, MCDFREECMDI);

            {
                MCDFREECMDI *pFreeCmd =
                    (MCDFREECMDI *)pMCDExec->pCmd;

                return (ULONG_PTR)DestroyMCDObj(pFreeCmd->hMCDMem, MCDHANDLE_MEM);
            }

        case MCD_STATE:

            CHECK_SIZE_IN(pMCDExec, MCDSTATECMDI);
            CHECK_FOR_RC(pMCDExec);
            CHECK_FOR_MEM(pMCDExec);

            {
                MCDSTATECMDI *pStateCmd =
                    (MCDSTATECMDI *)pMCDExec->pCmd;
                UCHAR *pStart = (UCHAR *)(pStateCmd + 1);
                LONG totalBytes = pMCDExec->inBufferSize -
                                  sizeof(MCDSTATECMDI);

                if (totalBytes < 0) {
                    MCDBG_PRINT("MCDState: state buffer too small ( < 0).");
                    return FALSE;
                }

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvState) {
                    MCDBG_PRINT("MCDrvState: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvState)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc, &pMemObj->MCDMem, pStart,
                               totalBytes, pStateCmd->numStates);
            }

        case MCD_VIEWPORT:

            CHECK_SIZE_IN(pMCDExec, MCDVIEWPORTCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDVIEWPORTCMDI *pViewportCmd =
                    (MCDVIEWPORTCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvViewport) {
                    MCDBG_PRINT("MCDrvViewport: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvViewport)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc, &pViewportCmd->MCDViewport);
            }

        case MCD_QUERYMEMSTATUS:

            CHECK_SIZE_IN(pMCDExec, MCDMEMSTATUSCMDI);

            {
                MCDMEMSTATUSCMDI *pQueryMemCmd =
                    (MCDMEMSTATUSCMDI *)pMCDExec->pCmd;

                return MCDSrvQueryMemStatus(pMCDExec, pQueryMemCmd->hMCDMem);
            }


        case MCD_READSPAN:
        case MCD_WRITESPAN:

            CHECK_SIZE_IN(pMCDExec, MCDSPANCMDI);
            CHECK_FOR_RC(pMCDExec);
            GetScissorClip(pMCDExec->pWndPriv, pMCDExec->pRcPriv);

            {
                MCDSPANCMDI *pSpanCmd =
                    (MCDSPANCMDI *)pMCDExec->pCmd;

                GET_MEMOBJ_RETVAL(pMemObj, pSpanCmd->hMem, FALSE);

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvSpan) {
                    MCDBG_PRINT("MCDrvSpan: missing entry point.");
                    return FALSE;
                }

                pMinMem = pMemObj->MCDMem.pMemBase;
                pMaxMem = pMinMem + pMemObj->MCDMem.memSize;

                // At least check that the first pixel is in range.  The driver
                // must validate the end pixel...

                CHECK_MEM_RANGE_RETVAL(pSpanCmd->MCDSpan.pPixels, pMinMem, pMaxMem, FALSE);

                if (pMCDExec->pCmd->command == MCD_READSPAN)
                    return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvSpan)(&pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc, &pMemObj->MCDMem, &pSpanCmd->MCDSpan, TRUE);
                else
                    return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvSpan)(&pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc, &pMemObj->MCDMem, &pSpanCmd->MCDSpan, FALSE);
            }


        case MCD_CLEAR:

            CHECK_SIZE_IN(pMCDExec, MCDCLEARCMDI);
            CHECK_FOR_RC(pMCDExec);
            GetScissorClip(pMCDExec->pWndPriv, pMCDExec->pRcPriv);

            {
                MCDCLEARCMDI *pClearCmd =
                    (MCDCLEARCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvClear) {
                    MCDBG_PRINT("MCDrvClear: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvClear)(&pMCDExec->MCDSurface,
                            &pMCDExec->pRcPriv->MCDRc, pClearCmd->buffers);
            }

        case MCD_SWAP:

            CHECK_SIZE_IN(pMCDExec, MCDSWAPCMDI);
    	    CHECK_FOR_WND(pMCDExec);
            GetScissorClip(pMCDExec->pWndPriv, NULL);

            {
                MCDSWAPCMDI *pSwapCmd =
                    (MCDSWAPCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvSwap) {
                    MCDBG_PRINT("MCDrvSwap: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvSwap)
                    (&pMCDExec->MCDSurface,
                     pSwapCmd->flags);
            }

        case MCD_SCISSOR:

            CHECK_SIZE_IN(pMCDExec, MCDSCISSORCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDSCISSORCMDI *pMCDScissor = (MCDSCISSORCMDI *)pMCDExec->pCmd;

                return (ULONG_PTR)MCDSrvSetScissor(pMCDExec, &pMCDScissor->rect,
                                               pMCDScissor->bEnabled);
            }
            break;

        case MCD_ALLOCBUFFERS:

            CHECK_SIZE_IN(pMCDExec, MCDALLOCBUFFERSCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDALLOCBUFFERSCMDI *pMCDAllocBuffersCmd = (MCDALLOCBUFFERSCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pWndPriv->bRegionValid)
                    pMCDExec->pWndPriv->MCDWindow.clientRect =
                        pMCDAllocBuffersCmd->WndRect;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvAllocBuffers) {
                    MCDBG_PRINT("MCDrvAllocBuffers: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvAllocBuffers)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc);
            }

            break;

        case MCD_GETBUFFERS:

            CHECK_SIZE_IN(pMCDExec, MCDGETBUFFERSCMDI);
            CHECK_SIZE_OUT(pMCDExec, MCDRECTBUFFERS);
            CHECK_FOR_RC(pMCDExec);

            return CallGetBuffers(pMCDExec, &pMCDExec->pRcPriv->MCDRc,
                                  (MCDRECTBUFFERS *)pMCDExec->pvOut);

        case MCD_LOCK:

            CHECK_SIZE_IN(pMCDExec, MCDLOCKCMDI);
            CHECK_FOR_RC(pMCDExec);

            return MCDSrvLock(pMCDExec->pWndPriv);

            break;

        case MCD_UNLOCK:
            CHECK_SIZE_IN(pMCDExec, MCDLOCKCMDI);
            CHECK_FOR_RC(pMCDExec);

            MCDSrvUnlock(pMCDExec->pWndPriv);

            return TRUE;

            break;

        case MCD_BINDCONTEXT:

            CHECK_SIZE_IN(pMCDExec, MCDBINDCONTEXTCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                ULONG_PTR retVal;
                MCDBINDCONTEXTCMDI *pMCDBindContext = (MCDBINDCONTEXTCMDI *)pMCDExec->pCmd;
                MCDWINDOW *pWndRes;

                if ((!pMCDExec->pWndPriv)) {
		    pWndRes = MCDSrvNewMCDWindow(&pMCDExec->MCDSurface,
                                            pMCDBindContext->hWnd,
                                            pMCDExec->pGlobal,
                                            pMCDExec->pRcPriv->hDev);
                    if (!pWndRes)
                    {
                        MCDBG_PRINT("MCDBindContext: Creation of window object failed.");
                        return 0;
                    }

                    pMCDExec->pWndPriv = (MCDWINDOWPRIV *)pWndRes;

                }

                if (!pMCDExec->MCDSurface.pWnd) {
                    MCDBG_PRINT("MCDrvBindContext: NULL surface.");
                    return 0;
                }

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvBindContext) {
                    MCDBG_PRINT("MCDrvBindContext: missing entry point.");
                    return 0;
                }

                retVal = (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvBindContext)(&pMCDExec->MCDSurface,
                                 &pMCDExec->pRcPriv->MCDRc);

                if (retVal)
                {
                    pRcPriv->hWnd = pMCDBindContext->hWnd;
                    retVal = (ULONG_PTR)pMCDExec->pWndPriv->handle;
                }

                return retVal;

            }

            break;

        case MCD_SYNC:
            CHECK_SIZE_IN(pMCDExec, MCDSYNCCMDI);
            CHECK_FOR_RC(pMCDExec);

            if (!pMCDExec->pGlobal->mcdDriver.pMCDrvSync) {
                MCDBG_PRINT("MCDrvSync: missing entry point.");
                return FALSE;
            }

            return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvSync)(&pMCDExec->MCDSurface,
                           &pMCDExec->pRcPriv->MCDRc);

            break;

        case MCD_CREATE_TEXTURE:
            CHECK_SIZE_IN(pMCDExec, MCDCREATETEXCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDCREATETEXCMDI *pMCDCreateTex =
                    (MCDCREATETEXCMDI *)pMCDExec->pCmd;

                return (ULONG_PTR)MCDSrvCreateTexture(pMCDExec,
                                                  pMCDCreateTex->pTexData,
                                                  pMCDCreateTex->pSurface,
                                                  pMCDCreateTex->flags);
            }

            break;

        case MCD_DELETE_TEXTURE:
            CHECK_SIZE_IN(pMCDExec, MCDDELETETEXCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDDELETETEXCMDI *pMCDDeleteTex =
                    (MCDDELETETEXCMDI *)pMCDExec->pCmd;

                return (ULONG_PTR)DestroyMCDObj(pMCDDeleteTex->hTex,
                                            MCDHANDLE_TEXTURE);
            }

            break;

        case MCD_UPDATE_SUB_TEXTURE:
            CHECK_SIZE_IN(pMCDExec, MCDUPDATESUBTEXCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDUPDATESUBTEXCMDI *pMCDUpdateSubTex =
                    (MCDUPDATESUBTEXCMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDUpdateSubTex->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj ||
                    !pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateSubTexture)
                    return FALSE;

                pTexObj->MCDTexture.pMCDTextureData = pMCDUpdateSubTex->pTexData;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateSubTexture)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc,
                               &pTexObj->MCDTexture,
                               pMCDUpdateSubTex->lod,
                               &pMCDUpdateSubTex->rect);
            }

            break;

        case MCD_UPDATE_TEXTURE_PALETTE:
            CHECK_SIZE_IN(pMCDExec, MCDUPDATETEXPALETTECMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDUPDATETEXPALETTECMDI *pMCDUpdateTexPalette =
                    (MCDUPDATETEXPALETTECMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDUpdateTexPalette->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj ||
                    !pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTexturePalette)
                    return FALSE;

                pTexObj->MCDTexture.pMCDTextureData = pMCDUpdateTexPalette->pTexData;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTexturePalette)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc,
                               &pTexObj->MCDTexture,
                               pMCDUpdateTexPalette->start,
                               pMCDUpdateTexPalette->numEntries);
            }

            break;

        case MCD_UPDATE_TEXTURE_PRIORITY:
            CHECK_SIZE_IN(pMCDExec, MCDUPDATETEXPRIORITYCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDUPDATETEXPRIORITYCMDI *pMCDUpdateTexPriority =
                    (MCDUPDATETEXPRIORITYCMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDUpdateTexPriority->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj ||
                    !pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTexturePriority)
                    return FALSE;

                pTexObj->MCDTexture.pMCDTextureData = pMCDUpdateTexPriority->pTexData;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTexturePriority)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc,
                               &pTexObj->MCDTexture);

            }

            break;

        case MCD_UPDATE_TEXTURE_STATE:
            CHECK_SIZE_IN(pMCDExec, MCDUPDATETEXSTATECMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDUPDATETEXSTATECMDI *pMCDUpdateTexState =
                    (MCDUPDATETEXSTATECMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDUpdateTexState->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj ||
                    !pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTextureState)
                    return FALSE;

                pTexObj->MCDTexture.pMCDTextureData = pMCDUpdateTexState->pTexData;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvUpdateTextureState)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc,
                               &pTexObj->MCDTexture);

            }

            break;

        case MCD_TEXTURE_STATUS:
            CHECK_SIZE_IN(pMCDExec, MCDTEXSTATUSCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDTEXSTATUSCMDI *pMCDTexStatus =
                    (MCDTEXSTATUSCMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDTexStatus->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj ||
                    !pMCDExec->pGlobal->mcdDriver.pMCDrvTextureStatus)
                    return FALSE;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvTextureStatus)(&pMCDExec->MCDSurface,
                               &pMCDExec->pRcPriv->MCDRc,
                               &pTexObj->MCDTexture);
            }

            break;


        case MCD_GET_TEXTURE_KEY:
            CHECK_SIZE_IN(pMCDExec, MCDTEXKEYCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDTEXKEYCMDI *pMCDTexKey =
                    (MCDTEXKEYCMDI *)pMCDExec->pCmd;
                MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)MCDEngGetPtrFromHandle((MCDHANDLE)pMCDTexKey->hTex,
                                                      MCDHANDLE_TEXTURE);

                if (!pTexObj)
                    return FALSE;

                return pTexObj->MCDTexture.textureKey;
            }

            break;

        case MCD_DESCRIBELAYERPLANE:
            CHECK_SIZE_IN(pMCDExec, MCDLAYERPLANECMDI);

            if (pMCDExec->pvOut) {
                CHECK_SIZE_OUT(pMCDExec, MCDLAYERPLANE);
            }

            {
                MCDLAYERPLANECMDI *pMCDLayerPlane =
                    (MCDLAYERPLANECMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvDescribeLayerPlane)
                    return 0;

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvDescribeLayerPlane)
                    (&pMCDExec->MCDSurface,
                     pMCDLayerPlane->iPixelFormat,
                     pMCDLayerPlane->iLayerPlane,
                     pMCDExec->cjOut,
                     pMCDExec->pvOut, 0);
            }

            break;

        case MCD_SETLAYERPALETTE:
            CHECK_SIZE_IN(pMCDExec, MCDSETLAYERPALCMDI);

            {
                MCDSETLAYERPALCMDI *pMCDSetLayerPal =
                    (MCDSETLAYERPALCMDI *)pMCDExec->pCmd;

                // Check to see if palette array is big enough.

                CHECK_MEM_RANGE_RETVAL(&pMCDSetLayerPal->acr[pMCDSetLayerPal->cEntries-1],
                                       pMCDExec->pCmd, pMCDExec->pCmdEnd, FALSE);

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvSetLayerPalette) {
                    MCDBG_PRINT("MCDrvSetLayerPalette: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(*pMCDExec->pGlobal->mcdDriver.pMCDrvSetLayerPalette)
                    (&pMCDExec->MCDSurface,
                     pMCDSetLayerPal->iLayerPlane,
                     pMCDSetLayerPal->bRealize,
                     pMCDSetLayerPal->cEntries,
                     &pMCDSetLayerPal->acr[0]);
            }

            break;

        case MCD_DRAW_PIXELS:
            CHECK_SIZE_IN(pMCDExec, MCDDRAWPIXELSCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDDRAWPIXELSCMDI *pMCDPix =
                    (MCDDRAWPIXELSCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvDrawPixels) {
                    MCDBG_PRINT("MCDrvDrawPixels: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(pMCDExec->pGlobal->mcdDriver.pMCDrvDrawPixels)(
                                &pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc,
                                pMCDPix->width,
                                pMCDPix->height,
                                pMCDPix->format,
                                pMCDPix->type,
                                pMCDPix->pPixels,
                                pMCDPix->packed);
            }

            break;

        case MCD_READ_PIXELS:
            CHECK_SIZE_IN(pMCDExec, MCDREADPIXELSCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDREADPIXELSCMDI *pMCDPix =
                    (MCDREADPIXELSCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvReadPixels) {
                    MCDBG_PRINT("MCDrvReadPixels: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(pMCDExec->pGlobal->mcdDriver.pMCDrvReadPixels)(
                                &pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc,
                                pMCDPix->x,
                                pMCDPix->y,
                                pMCDPix->width,
                                pMCDPix->height,
                                pMCDPix->format,
                                pMCDPix->type,
                                pMCDPix->pPixels);
            }

            break;

        case MCD_COPY_PIXELS:
            CHECK_SIZE_IN(pMCDExec, MCDCOPYPIXELSCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDCOPYPIXELSCMDI *pMCDPix =
                    (MCDCOPYPIXELSCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvCopyPixels) {
                    MCDBG_PRINT("MCDrvCopyPixels: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(pMCDExec->pGlobal->mcdDriver.pMCDrvCopyPixels)(
                                &pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc,
                                pMCDPix->x,
                                pMCDPix->y,
                                pMCDPix->width,
                                pMCDPix->height,
                                pMCDPix->type);
            }

            break;

        case MCD_PIXEL_MAP:
            CHECK_SIZE_IN(pMCDExec, MCDPIXELMAPCMDI);
            CHECK_FOR_RC(pMCDExec);

            {
                MCDPIXELMAPCMDI *pMCDPix =
                    (MCDPIXELMAPCMDI *)pMCDExec->pCmd;

                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvPixelMap) {
                    MCDBG_PRINT("MCDrvPixelMap: missing entry point.");
                    return FALSE;
                }

                return (ULONG_PTR)(pMCDExec->pGlobal->mcdDriver.pMCDrvPixelMap)(
                                &pMCDExec->MCDSurface,
                                &pMCDExec->pRcPriv->MCDRc,
                                pMCDPix->mapType,
                                pMCDPix->mapSize,
                                pMCDPix->pMap);
            }

            break;

        case MCD_DESTROY_WINDOW:
            CHECK_SIZE_IN(pMCDExec, MCDDESTROYWINDOWCMDI);
            {
                if (pMCDExec->pWndPriv == NULL)
                {
                    MCDBG_PRINT("MCDrvDestroyWindow: NULL window\n");
                    return FALSE;
                }

                MCDEngDeleteObject(pMCDExec->pWndPriv->handle);
                return TRUE;
            }
            break;

        case MCD_GET_TEXTURE_FORMATS:
            CHECK_SIZE_IN(pMCDExec, MCDGETTEXTUREFORMATSCMDI);
            {
                MCDGETTEXTUREFORMATSCMDI *pmgtf =
                    (MCDGETTEXTUREFORMATSCMDI *)pMCDExec->pCmd;

                if (pMCDExec->pvOut)
                {
                    CHECK_SIZE_OUT(pMCDExec,
                                   pmgtf->nFmts*sizeof(DDSURFACEDESC));
                }

#if MCD_VER_MAJOR >= 2 || (MCD_VER_MAJOR == 1 && MCD_VER_MINOR >= 0x10)
                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvGetTextureFormats)
                {
                    MCDBG_PRINT("MCDrvGetTextureFormats: "
                                "missing entry point.");
                    return 0;
                }

                return (pMCDExec->pGlobal->mcdDriver.pMCDrvGetTextureFormats)(
                        &pMCDExec->MCDSurface,
                        pmgtf->nFmts,
                        (DDSURFACEDESC *)pMCDExec->pvOut);
#else
                return 0;
#endif // 1.1
            }
            break;

        case MCD_SWAP_MULTIPLE:
            CHECK_SIZE_IN(pMCDExec, MCDSWAPMULTIPLECMDI);

            {
                MCDSWAPMULTIPLECMDI *pSwapCmd =
                    (MCDSWAPMULTIPLECMDI *)pMCDExec->pCmd;
                MCDWINDOWPRIV *apWndPriv[MCDESC_MAX_EXTRA_WNDOBJ];
                UINT i;
                MCDWINDOWOBJ *pmwo;
                MCDRVSWAPMULTIPLEFUNC pSwapMultFunc;
                ULONG_PTR dwRet;

                pSwapMultFunc = NULL;
                for (i = 0; i < pSwapCmd->cBuffers; i++)
                {
                    if (pMCDExec->ppwoMulti[i] != NULL)
                    {
                        pmwo = (MCDWINDOWOBJ *)
                            MCDEngGetPtrFromHandle((MCDHANDLE)
                                                   pSwapCmd->adwMcdWindow[i],
                                                   MCDHANDLE_WINDOW);
                    }
                    else
                    {
                        pmwo = NULL;
                    }

                    if (pmwo == NULL)
                    {
                        apWndPriv[i] = NULL;
                    }
                    else
                    {
                        apWndPriv[i] = &pmwo->MCDWindowPriv;
                        GetScissorClip(apWndPriv[i], NULL);

#if MCD_VER_MAJOR >= 2 || (MCD_VER_MAJOR == 1 && MCD_VER_MINOR >= 0x10)
                        if (pSwapMultFunc == NULL)
                        {
                            pSwapMultFunc = apWndPriv[i]->pGlobal->mcdDriver.
                                pMCDrvSwapMultiple;
                        }
                        else if (pSwapMultFunc !=
                                 apWndPriv[i]->pGlobal->mcdDriver.
                                 pMCDrvSwapMultiple)
                        {
                            MCDBG_PRINT("MCDrvSwapMultiple: "
                                        "Mismatched SwapMultiple");
                            return FALSE;
                        }
#endif // 1.1
                    }
                }

                if (pSwapMultFunc != NULL)
                {
                    dwRet = pSwapMultFunc(pMCDExec->MCDSurface.pwo->psoOwner,
                                          pSwapCmd->cBuffers,
                                          (MCDWINDOW **)apWndPriv,
                                          (UINT *)pSwapCmd->auiFlags);
                }
                else
                {
                    MCDSURFACE *pms;

                    dwRet = 0;
                    pms = &pMCDExec->MCDSurface;
                    for (i = 0; i < pSwapCmd->cBuffers; i++)
                    {
                        if (apWndPriv[i] == NULL)
                        {
                            continue;
                        }

                        if (apWndPriv[i]->pGlobal->mcdDriver.
                            pMCDrvSwap == NULL)
                        {
                            MCDBG_PRINT("MCDrvSwapMultiple: Missing Swap");
                        }
                        else
                        {
                            pms->pWnd = (MCDWINDOW *)apWndPriv[i];
                            pms->pso = pMCDExec->ppwoMulti[i]->psoOwner;
                            pms->pwo = pMCDExec->ppwoMulti[i];
                            pms->surfaceFlags = 0;

                            if (apWndPriv[i]->pGlobal->mcdDriver.
                                pMCDrvSwap(pms, pSwapCmd->auiFlags[i]))
                            {
                                dwRet |= 1 << i;
                            }
                        }
                    }
                }

                return dwRet;
            }
            break;

        case MCD_PROCESS:
            CHECK_SIZE_IN(pMCDExec, MCDPROCESSCMDI);
            CHECK_FOR_RC(pMCDExec);
            CHECK_FOR_MEM(pMCDExec);
            {
                MCDPROCESSCMDI *pmp = (MCDPROCESSCMDI *)pMCDExec->pCmd;

                // Validate command buffer
                GET_MEMOBJ_RETVAL(pMemObj, pmp->hMCDPrimMem,
                                  (ULONG_PTR)pmp->pMCDFirstCmd);

                pMinMem = pMemObj->MCDMem.pMemBase;

                // Note: we ignore the memory size in the header since it
                // doesn't really help us...
	
                pMaxMem = pMinMem + pMemObj->MCDMem.memSize;

                CHECK_MEM_RANGE_RETVAL(pmp->pMCDFirstCmd, pMinMem,
                                       pMaxMem, (ULONG_PTR)pmp->pMCDFirstCmd);

                // Validate user-mode pointers passed down.
                __try
                {
                    EngProbeForRead(pmp->pMCDTransform, sizeof(MCDTRANSFORM),
                                    sizeof(DWORD));
                    // No meaningful check of the material changes can be
                    // done.  The driver is responsible for probing
                    // addresses used.
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    return (ULONG_PTR)pmp->pMCDFirstCmd;
                }
                
                GetScissorClip(pMCDExec->pWndPriv, pMCDExec->pRcPriv);

#if MCD_VER_MAJOR >= 2
                if (!pMCDExec->pGlobal->mcdDriver.pMCDrvProcess)
                {
                    if (pMCDExec->pGlobal->mcdDriver.pMCDrvSync)
                    {
                        (*pMCDExec->pGlobal->mcdDriver.pMCDrvSync)
                            (&pMCDExec->MCDSurface,
                             &pMCDExec->pRcPriv->MCDRc);
                    }
                    return (ULONG_PTR)pmp->pMCDFirstCmd;
                }

                return (pMCDExec->pGlobal->mcdDriver.pMCDrvProcess)(
                        &pMCDExec->MCDSurface, &pMCDExec->pRcPriv->MCDRc,
                        &pMemObj->MCDMem, (UCHAR *)pmp->pMCDFirstCmd, pMaxMem,
                        pmp->cmdFlagsAll, pmp->primFlags, pmp->pMCDTransform,
                        pmp->pMCDMatChanges);
#else
                if (pMCDExec->pGlobal->mcdDriver.pMCDrvSync)
                {
                    (*pMCDExec->pGlobal->mcdDriver.pMCDrvSync)
                        (&pMCDExec->MCDSurface,
                         &pMCDExec->pRcPriv->MCDRc);
                }
                return (ULONG_PTR)pmp->pMCDFirstCmd;
#endif // 2.0
            }
            break;
            
        default:
            MCDBG_PRINT("MCDSrvProcess: "
                        "Null rendering context invalid for command %d.",
                        pMCDExec->pCmd->command);
            return FALSE;
    }

    return FALSE;       // should never get here...
}



//****************************************************************************
// FreeRCObj()
//
// Engine callback for freeing the memory used for rendering-context
// handles.
//****************************************************************************

BOOL CALLBACK FreeRCObj(DRIVEROBJ *pDrvObj)
{
    MCDRCOBJ *pRcObj = (MCDRCOBJ *)pDrvObj->pvObj;
    MCDRCPRIV *pRcPriv = pRcObj->pRcPriv;

    if ((pRcPriv->bDrvValid) &&
        (pRcPriv->pGlobal->mcdDriver.pMCDrvDeleteContext))
    {
        (*pRcPriv->pGlobal->mcdDriver.pMCDrvDeleteContext)
            (&pRcPriv->MCDRc, pDrvObj->dhpdev);
    }

    MCDSrvLocalFree((UCHAR *)pRcPriv);
    MCDSrvLocalFree((UCHAR *)pRcObj);

    return TRUE;
}


//****************************************************************************
// MCDSrvCreateContext()
//
// Create a rendering context (RGBA or color-indexed) for the current
// hardware mode.  This call will also initialize window-tracking for
// the context (which is associated with the specified window).
//****************************************************************************

PRIVATE
MCDHANDLE MCDSrvCreateContext(MCDSURFACE *pMCDSurface,
                              MCDRCINFOPRIV *pMcdRcInfo,
                              MCDGLOBALINFO *pGlobal,
                              LONG iPixelFormat,
                              LONG iLayer,
                              HWND hWnd,
                              ULONG surfaceFlags,
                              ULONG contextFlags)
{
    MCDWINDOW *pWnd;
    MCDWINDOWPRIV *pWndPriv;
    MCDRCPRIV *pRcPriv;
    MCDHANDLE retVal;
    HWND hwnd;
    MCDRCOBJ *newRcObject;
    MCDRVTRACKWINDOWFUNC pTrackFunc = NULL;

    if (pGlobal->mcdDriver.pMCDrvCreateContext == NULL)
    {
        MCDBG_PRINT("MCDSrvCreateContext: No MCDrvCreateContext.");
        return NULL;
    }
    
    pRcPriv = (MCDRCPRIV *)MCDSrvLocalAlloc(0,sizeof(MCDRCPRIV));

    if (!pRcPriv) {
        MCDBG_PRINT("MCDSrvCreateContext: Could not allocate new context.");
        return (MCDHANDLE)NULL;
    }

    pRcPriv->pGlobal = pGlobal;
    
    // Cache the engine handle provided by the driver:

    pRcPriv->hDev = (*pGlobal->mcdDriver.pMCDrvGetHdev)(pMCDSurface);

    if (surfaceFlags & MCDSURFACE_HWND)
    {
        pMCDSurface->surfaceFlags |= MCDSURFACE_HWND;
    }
    if (surfaceFlags & MCDSURFACE_DIRECT)
    {
        pMCDSurface->surfaceFlags |= MCDSURFACE_DIRECT;
    }

    // cache the surface flags away in the private RC:

    pRcPriv->surfaceFlags = pMCDSurface->surfaceFlags;

    // Initialize tracking of this window with a MCDWINDOW
    // (via and WNDOBJ on NT) if we are not already tracking the
    // window:

    pWnd = MCDSrvNewMCDWindow(pMCDSurface, hWnd, pGlobal,
                              pRcPriv->hDev);
    if (pWnd == NULL)
    {
        MCDSrvLocalFree((HLOCAL)pRcPriv);
        return (MCDHANDLE)NULL;
    }
    pWndPriv = (MCDWINDOWPRIV *)pWnd;

    pRcPriv->hWnd = hWnd;

    newRcObject = (MCDRCOBJ *)MCDSrvLocalAlloc(0,sizeof(MCDRCOBJ));
    if (!newRcObject) {
        MCDSrvLocalFree((HLOCAL)pRcPriv);
        return (MCDHANDLE)NULL;
    }

    retVal = MCDEngCreateObject(newRcObject, FreeRCObj, pRcPriv->hDev);

    if (retVal) {
        newRcObject->pid = MCDEngGetProcessID();
        newRcObject->type = MCDHANDLE_RC;
        newRcObject->size = sizeof(MCDRCPRIV);
        newRcObject->pRcPriv = pRcPriv;
        newRcObject->handle = (MCDHANDLE)retVal;

        // Add the object to the list in the MCDWINDOW

        newRcObject->next = pWndPriv->objectList;
        pWndPriv->objectList = newRcObject;
    } else {
        MCDBG_PRINT("MCDSrvCreateContext: Could not create new handle.");

        MCDSrvLocalFree((HLOCAL)pRcPriv);
        MCDSrvLocalFree((HLOCAL)newRcObject);
        return (MCDHANDLE)NULL;
    }

    pRcPriv->bValid = TRUE;
    pRcPriv->scissorsEnabled = FALSE;
    pRcPriv->scissorsRect.left = 0;
    pRcPriv->scissorsRect.top = 0;
    pRcPriv->scissorsRect.right = 0;
    pRcPriv->scissorsRect.bottom = 0;
    pRcPriv->MCDRc.createFlags = contextFlags;
    pRcPriv->MCDRc.iPixelFormat = iPixelFormat;
    pRcPriv->MCDRc.iLayerPlane = iLayer;

    if (!(*pGlobal->mcdDriver.pMCDrvCreateContext)(pMCDSurface,
                                                   &pRcPriv->MCDRc,
                                                   &pMcdRcInfo->mri)) {
        DestroyMCDObj((HANDLE)retVal, MCDHANDLE_RC);
        return (MCDHANDLE)NULL;
    }

    // Return window private handle
    pMcdRcInfo->dwMcdWindow = (ULONG_PTR)pWndPriv->handle;

    // Now valid to call driver for deletion...

    pRcPriv->bDrvValid = TRUE;

    return (MCDHANDLE)retVal;
}


//****************************************************************************
// FreeTexObj()
//
// Engine callback for freeing the memory used for a texture.
//****************************************************************************

BOOL CALLBACK FreeTexObj(DRIVEROBJ *pDrvObj)
{
    MCDTEXOBJ *pTexObj = (MCDTEXOBJ *)pDrvObj->pvObj;

    // We should never get called if the driver is missing this entry point,
    // but the extra check can't hurt!
    //
    // pGlobal can be NULL for partially constructed objects.  It
    // is only NULL prior to calling the driver for creation, so if
    // it's NULL there's no reason to call the driver for cleanup.

    if (pTexObj->pGlobal != NULL &&
        pTexObj->pGlobal->mcdDriver.pMCDrvDeleteTexture != NULL)
    {
        (*pTexObj->pGlobal->mcdDriver.pMCDrvDeleteTexture)
            (&pTexObj->MCDTexture, pDrvObj->dhpdev);
    }

    MCDSrvLocalFree((HLOCAL)pTexObj);

    return TRUE;
}


//****************************************************************************
// MCDSrvCreateTexture()
//
// Creates an MCD texture.
//****************************************************************************

PRIVATE
MCDHANDLE MCDSrvCreateTexture(MCDEXEC *pMCDExec, MCDTEXTUREDATA *pTexData,
                              VOID *pSurface, ULONG flags)
{
    MCDRCPRIV *pRcPriv;
    MCDHANDLE hTex;
    MCDTEXOBJ *pTexObj;

    pRcPriv = pMCDExec->pRcPriv;

    if ((!pMCDExec->pGlobal->mcdDriver.pMCDrvDeleteTexture) ||
        (!pMCDExec->pGlobal->mcdDriver.pMCDrvCreateTexture)) {
        return (MCDHANDLE)NULL;
    }

    pTexObj = (MCDTEXOBJ *) MCDSrvLocalAlloc(0,sizeof(MCDTEXOBJ));
    if (!pTexObj) {
        MCDBG_PRINT("MCDCreateTexture: Could not allocate texture object.");
        return (MCDHANDLE)NULL;
    }

    hTex = MCDEngCreateObject(pTexObj, FreeTexObj, pRcPriv->hDev);

    if (!hTex) {
        MCDBG_PRINT("MCDSrvCreateTexture: Could not create texture object.");
        MCDSrvLocalFree((HLOCAL)pTexObj);
        return (MCDHANDLE)NULL;
    }

    // Initialize driver public information for driver call, but not
    // the private information.  The private information is not filled out
    // until after the driver call succeeds so that FreeTexObj knows
    // whether to call the driver or not when destroying a texture object.
    pTexObj->MCDTexture.pSurface = pSurface;
    pTexObj->MCDTexture.pMCDTextureData = pTexData;
    pTexObj->MCDTexture.createFlags = flags;

    // Call the driver if everything has gone well...

    if (!(*pMCDExec->pGlobal->mcdDriver.pMCDrvCreateTexture)
        (&pMCDExec->MCDSurface,
         &pRcPriv->MCDRc,
         &pTexObj->MCDTexture)) {
        //MCDBG_PRINT("MCDSrvCreateTexture: Driver could not create texture.");
        MCDEngDeleteObject(hTex);
        return (MCDHANDLE)NULL;
    }

    if (!pTexObj->MCDTexture.textureKey) {
        MCDBG_PRINT("MCDSrvCreateTexture: Driver returned null key.");
        MCDEngDeleteObject(hTex);
        return (MCDHANDLE)NULL;
    }

    pTexObj->pid = MCDEngGetProcessID();
    pTexObj->type = MCDHANDLE_TEXTURE;
    pTexObj->size = sizeof(MCDTEXOBJ);
    pTexObj->pGlobal = pMCDExec->pGlobal;

    return (MCDHANDLE)hTex;
}


//****************************************************************************
// FreeMemObj()
//
// Engine callback for freeing memory used by shared-memory handles.
//****************************************************************************

BOOL CALLBACK FreeMemObj(DRIVEROBJ *pDrvObj)
{
    MCDMEMOBJ *pMemObj = (MCDMEMOBJ *)pDrvObj->pvObj;

    // Free the memory using our engine ONLY if it is the same memory
    // we allocated in the first place.

    if (pMemObj->pMemBaseInternal)
        MCDEngFreeSharedMem(pMemObj->pMemBaseInternal);

    // pGlobal can be NULL for partially constructed objects.  It
    // is only NULL prior to calling the driver for creation, so if
    // it's NULL there's no reason to call the driver for cleanup.
    if (pMemObj->pGlobal != NULL &&
        pMemObj->pGlobal->mcdDriver.pMCDrvDeleteMem != NULL)
    {
        (*pMemObj->pGlobal->mcdDriver.pMCDrvDeleteMem)
            (&pMemObj->MCDMem, pDrvObj->dhpdev);
    }

    MCDSrvLocalFree((HLOCAL)pMemObj);

    return TRUE;
}


//****************************************************************************
// MCDSrvAllocMem()
//
// Creates a handle associated with the specified memory.
//****************************************************************************

PRIVATE
UCHAR * MCDSrvAllocMem(MCDEXEC *pMCDExec, ULONG numBytes,
                       ULONG flags, MCDHANDLE *phMem)
{
    MCDRCPRIV *pRcPriv;
    MCDHANDLE hMem;
    MCDMEMOBJ *pMemObj;

    pRcPriv = pMCDExec->pRcPriv;

    *phMem = (MCDHANDLE)FALSE;

    pMemObj = (MCDMEMOBJ *) MCDSrvLocalAlloc(0,sizeof(MCDMEMOBJ));

    if (!pMemObj) {
        MCDBG_PRINT("MCDSrvAllocMem: Could not allocate memory object.");
        return (MCDHANDLE)NULL;
    }

    hMem = MCDEngCreateObject(pMemObj, FreeMemObj, pRcPriv->hDev);

    if (!hMem) {
        MCDBG_PRINT("MCDSrvAllocMem: Could not create memory object.");
        MCDSrvLocalFree((HLOCAL)pMemObj);
        return (UCHAR *)NULL;
    }

    pMemObj->MCDMem.pMemBase = pMemObj->pMemBaseInternal =
        MCDEngAllocSharedMem(numBytes);

    if (!pMemObj->MCDMem.pMemBase) {
        MCDBG_PRINT("MCDSrvAllocMem: Could not allocate memory.");
        MCDEngDeleteObject(hMem);
        return (UCHAR *)NULL;
    }

    // Call the driver if everything has gone well, and the driver
    // entry points exist...

    if ((pMCDExec->pGlobal->mcdDriver.pMCDrvCreateMem) &&
        (pMCDExec->pGlobal->mcdDriver.pMCDrvDeleteMem)) {

        if (!(*pMCDExec->pGlobal->mcdDriver.pMCDrvCreateMem)
            (&pMCDExec->MCDSurface,
             &pMemObj->MCDMem)) {
            MCDBG_PRINT("MCDSrvAllocMem: "
                        "Driver not create memory type %x.", flags);
            MCDEngDeleteObject(hMem);
            return (UCHAR *)NULL;
        }
    }

    // Free the memory allocated with our engine if the driver has substituted
    // its own allocation...

    if (pMemObj->MCDMem.pMemBase != pMemObj->pMemBaseInternal) {
        MCDEngFreeSharedMem(pMemObj->pMemBaseInternal);
        pMemObj->pMemBaseInternal = (UCHAR *)NULL;
    }

    // Set up the private portion of memory object:

    pMemObj->pid = MCDEngGetProcessID();
    pMemObj->type = MCDHANDLE_MEM;
    pMemObj->size = sizeof(MCDMEMOBJ);
    pMemObj->pGlobal = pMCDExec->pGlobal;
    pMemObj->MCDMem.memSize = numBytes;
    pMemObj->MCDMem.createFlags = flags;

    *phMem = hMem;

    return pMemObj->MCDMem.pMemBase;
}


PRIVATE
ULONG MCDSrvQueryMemStatus(MCDEXEC *pMCDExec, MCDHANDLE hMCDMem)
{
    MCDMEMOBJ *pMemObj;

    pMemObj = (MCDMEMOBJ *)MCDEngGetPtrFromHandle(hMCDMem, MCDHANDLE_MEM);

    if (!pMemObj)
        return MCD_MEM_INVALID;

    if (pMemObj->lockCount)
        return MCD_MEM_BUSY;
    else
        return MCD_MEM_READY;
}


PRIVATE
BOOL MCDSrvSetScissor(MCDEXEC *pMCDExec, RECTL *pRect, BOOL bEnabled)
{
    MCDRCPRIV *pRcPriv;
    MCDRCOBJ *pRcObj;
    HWND hWnd;
    ULONG retVal = FALSE;

    pRcPriv = pMCDExec->pRcPriv;

    pRcPriv->scissorsEnabled = bEnabled;
    pRcPriv->scissorsRect = *pRect;

    return TRUE;
}


//****************************************************************************
// DestroyMCDObj()
//
// Deletes the specified object.  This can be memory, textures, or rendering
// contexts.
//
//****************************************************************************

PRIVATE
BOOL DestroyMCDObj(MCDHANDLE handle, MCDHANDLETYPE handleType)
{
    CHAR *pObject;

    pObject = (CHAR *)MCDEngGetPtrFromHandle(handle, handleType);

    if (!pObject)
        return FALSE;

//!!! Check for PID here...

    return (MCDEngDeleteObject(handle) != 0);
}


//****************************************************************************
// DecoupleMCDWindowObj()
//
// Breaks any existing links between an MCDWINDOW and its WNDOBJ
//****************************************************************************

PRIVATE
VOID DecoupleMCDWindow(MCDWINDOWPRIV *pWndPriv)
{
    // Clean up any outstanding lock
    MCDSrvUnlock(pWndPriv);

    // Delete reference in WNDOBJ.  WNDOBJ itself will be cleaned
    // up through normal window cleanup.
    if (pWndPriv->pwo != NULL)
    {
	if (pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow)
	{
	    (*pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow)
                (pWndPriv->pwo, (MCDWINDOW *)pWndPriv, WOC_DELETE);
	}

        WNDOBJ_vSetConsumer(pWndPriv->pwo, NULL);

	pWndPriv->pwo = NULL;
    }
}


//****************************************************************************
// DestroyMCDWindowObj()
//
// Destroy the specified MCDWINDOW and any associated handles (such rendering
// contexts).
//****************************************************************************

PRIVATE
VOID DestroyMCDWindowObj(MCDWINDOWOBJ *pmwo)
{
    MCDWINDOWPRIV *pWndPriv = &pmwo->MCDWindowPriv;
    MCDRCOBJ *nextObject;

    DecoupleMCDWindow(pWndPriv);

    // Delete all of the rendering contexts associated with the window:

#if _WIN95_
    while (pWndPriv->objectList)
    {
        nextObject = pWndPriv->objectList->next;
        MCDEngDeleteObject(pWndPriv->objectList->handle);
        pWndPriv->objectList = nextObject;
    }
#endif

    if (pWndPriv->pAllocatedClipBuffer)
        MCDSrvLocalFree(pWndPriv->pAllocatedClipBuffer);

    // Free the memory

    MCDSrvLocalFree((HLOCAL)pmwo);
}


//****************************************************************************
// GetScissorClip()
//
// Generate a new clip list based on the current list of clip rectanges
// for the window, and the specified scissor rectangle.
//****************************************************************************

PRIVATE
VOID GetScissorClip(MCDWINDOWPRIV *pWndPriv, MCDRCPRIV *pRcPriv)
{
    MCDWINDOW *pWnd;
    MCDENUMRECTS *pClipUnscissored;
    MCDENUMRECTS *pClipScissored;
    RECTL *pRectUnscissored;
    RECTL *pRectScissored;
    RECTL rectScissor;
    ULONG numUnscissoredRects;
    ULONG numScissoredRects;

    pWnd = (MCDWINDOW *)pWndPriv;

    if (!pRcPriv || !pRcPriv->scissorsEnabled)
    {
        // Scissors aren't enabled, so the unscissored and scissored
        // clip lists are identical:

        pWnd->pClip = pWnd->pClipUnscissored = pWndPriv->pClipUnscissored;
    }
    else
    {
        // The scissored list will go in the second half of our clip
        // buffer:

        pClipUnscissored
            = pWndPriv->pClipUnscissored;

        pClipScissored
            = (MCDENUMRECTS*) ((BYTE*) pClipUnscissored + pWndPriv->sizeClipBuffer / 2);

        pWnd->pClip = pWndPriv->pClipScissored = pClipScissored;
	pWnd->pClipUnscissored = pClipUnscissored;

        // Convert scissor to screen coordinates:

        rectScissor.left   = pRcPriv->scissorsRect.left   + pWndPriv->MCDWindow.clientRect.left;
        rectScissor.right  = pRcPriv->scissorsRect.right  + pWndPriv->MCDWindow.clientRect.left;
        rectScissor.top    = pRcPriv->scissorsRect.top    + pWndPriv->MCDWindow.clientRect.top;
        rectScissor.bottom = pRcPriv->scissorsRect.bottom + pWndPriv->MCDWindow.clientRect.top;

        pRectUnscissored = &pClipUnscissored->arcl[0];
        pRectScissored = &pClipScissored->arcl[0];
        numScissoredRects = 0;

        for (numUnscissoredRects = pClipUnscissored->c;
             numUnscissoredRects != 0;
             numUnscissoredRects--, pRectUnscissored++)
        {
            // Since our clipping rectangles are ordered from top to
            // bottom, we can early-out if the tops of the remaining
            // rectangles are not in the scissor rectangle

            if (rectScissor.bottom <= pRectUnscissored->top)
                break;

            // Continue without updating new clip list is there is
            // no overlap.

            if ((rectScissor.left  >= pRectUnscissored->right)  ||
                (rectScissor.top   >= pRectUnscissored->bottom) ||
                (rectScissor.right <= pRectUnscissored->left))
               continue;

            // If we reach this point, we must intersect the given rectangle
            // with the scissor.

            MCDIntersectRect(pRectScissored, pRectUnscissored, &rectScissor);

            numScissoredRects++;
            pRectScissored++;
        }

        pClipScissored->c = numScissoredRects;
    }
}

//****************************************************************************
// GetClipLists()
//
// Updates the clip list for the specified window.  Space is also allocated
// the scissored clip list.
//
//****************************************************************************

PRIVATE
VOID GetClipLists(WNDOBJ *pwo, MCDWINDOWPRIV *pWndPriv)
{
    MCDENUMRECTS *pDefault;
    ULONG numClipRects;
    char *pClipBuffer;
    ULONG sizeClipBuffer;

    pDefault = (MCDENUMRECTS*) &pWndPriv->defaultClipBuffer[0];

#if 1
    if (pwo->coClient.iDComplexity == DC_TRIVIAL)
    {
        if ((pwo->rclClient.left >= pwo->rclClient.right) ||
            (pwo->rclClient.top  >= pwo->rclClient.bottom))
        {
            pDefault->c = 0;
        }
        else
        {
            pDefault->c = 1;
            pDefault->arcl[0] = pwo->rclClient;
        }
    }
    else if (pwo->coClient.iDComplexity == DC_RECT)
#else
    if (pwo->coClient.iDComplexity == DC_RECT)
#endif
    {
        if (pWndPriv->pAllocatedClipBuffer)
            MCDSrvLocalFree(pWndPriv->pAllocatedClipBuffer);
        pWndPriv->pAllocatedClipBuffer = NULL;
        pWndPriv->pClipUnscissored = pDefault;
        pWndPriv->pClipScissored = pDefault;
        pWndPriv->sizeClipBuffer = SIZE_DEFAULT_CLIP_BUFFER;

        if ((pwo->coClient.rclBounds.left >= pwo->coClient.rclBounds.right) ||
            (pwo->coClient.rclBounds.top  >= pwo->coClient.rclBounds.bottom))
        {
            // Full-screen VGA mode is represented by a DC_RECT clip object
            // with an empty bounding rectangle.  We'll denote it by
            // setting the rectangle count to zero:

            pDefault->c = 0;
        }
        else
        {
            pDefault->c = 1;
            pDefault->arcl[0] = pwo->coClient.rclBounds;
        }
    }
    else
    {
        WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Note that this is divide-by-2 for the buffer size because we
        // need room for two copies of the rectangle list:

        if (WNDOBJ_bEnum(pwo, SIZE_DEFAULT_CLIP_BUFFER / 2, (ULONG*) pDefault))
        {
            // Okay, the list of rectangles won't fit in our default buffer.
            // Unfortunately, there is no way to obtain the total count of clip
            // rectangles other than by enumerating them all, as cEnumStart
            // will occasionally give numbers that are far too large (because
            // GDI itself doesn't feel like counting them all).
            //
            // Note that we can use the full default buffer here for this
            // enumeration loop:

            numClipRects = pDefault->c;
            while (WNDOBJ_bEnum(pwo, SIZE_DEFAULT_CLIP_BUFFER, (ULONG*) pDefault))
                numClipRects += pDefault->c;

            // Don't forget that we are given a valid output buffer even
            // when 'bEnum' returns FALSE:

            numClipRects += pDefault->c;

            pClipBuffer = pWndPriv->pAllocatedClipBuffer;
            sizeClipBuffer = 2 * (numClipRects * sizeof(RECTL) + sizeof(ULONG));

            if ((pClipBuffer == NULL) || (sizeClipBuffer > pWndPriv->sizeClipBuffer))
            {
                // Our allocated buffer is too small; we have to free it and
                // allocate a new one.  Take the opportunity to add some
                // growing room to our allocation:

                sizeClipBuffer += 8 * sizeof(RECTL);    // Arbitrary growing room

                if (pClipBuffer)
                    MCDSrvLocalFree(pClipBuffer);

                pClipBuffer = (char *) MCDSrvLocalAlloc(LMEM_FIXED, sizeClipBuffer);

                if (pClipBuffer == NULL)
                {
                    // Oh no: we couldn't allocate enough room for the clip list.
                    // So pretend we have no visible area at all:

                    pWndPriv->pAllocatedClipBuffer = NULL;
                    pWndPriv->pClipUnscissored = pDefault;
                    pWndPriv->pClipScissored = pDefault;
                    pWndPriv->sizeClipBuffer = SIZE_DEFAULT_CLIP_BUFFER;
                    pDefault->c = 0;
                    return;
                }

                pWndPriv->pAllocatedClipBuffer = pClipBuffer;
                pWndPriv->pClipUnscissored = (MCDENUMRECTS*) pClipBuffer;
                pWndPriv->pClipScissored = (MCDENUMRECTS*) pClipBuffer;
                pWndPriv->sizeClipBuffer = sizeClipBuffer;
            }

            // Now actually get all the clip rectangles:

            WNDOBJ_cEnumStart(pwo, CT_RECTANGLES, CD_RIGHTDOWN, 0);
            WNDOBJ_bEnum(pwo, sizeClipBuffer, (ULONG*) pClipBuffer);
        }
        else
        {
            // How nice, there are no more clip rectangles, which meant that
            // the entire list fits in our default clip buffer, with room
            // for the scissored version of the list:

            if (pWndPriv->pAllocatedClipBuffer)
                MCDSrvLocalFree(pWndPriv->pAllocatedClipBuffer);
            pWndPriv->pAllocatedClipBuffer = NULL;
            pWndPriv->pClipUnscissored = pDefault;
            pWndPriv->pClipScissored = pDefault;
            pWndPriv->sizeClipBuffer = SIZE_DEFAULT_CLIP_BUFFER;
        }
    }
}


//****************************************************************************
// WndObjChangeProc()
//
// This is the callback function for window-change notification.  We update
// our clip list, and also allow the hardware to respond to the client
// and surface deltas, as well as the client message itself.
//****************************************************************************

VOID CALLBACK WndObjChangeProc(WNDOBJ *pwo, FLONG fl)
{
    MCDGLOBALINFO *pGlobal;
    
    if (pwo)
    {
        MCDWINDOWPRIV *pWndPriv = (MCDWINDOWPRIV *)pwo->pvConsumer;

        //MCDBG_PRINT("WndObjChangeProc: %s, pWndPriv = 0x%08lx\n",
        //    fl == WOC_RGN_CLIENT        ? "WOC_RGN_CLIENT       " :
        //    fl == WOC_RGN_CLIENT_DELTA  ? "WOC_RGN_CLIENT_DELTA " :
        //    fl == WOC_RGN_SURFACE       ? "WOC_RGN_SURFACE      " :
        //    fl == WOC_RGN_SURFACE_DELTA ? "WOC_RGN_SURFACE_DELTA" :
        //    fl == WOC_DELETE            ? "WOC_DELETE           " :
        //                                  "unknown",
        //    pWndPriv);

    //!!!HACK -- surface region tracking doesn't have an MCDWINDOWPRIV (yet...)

    // Client region tracking and deletion requires a valid MCDWINDOWPRIV.

        if (((fl == WOC_RGN_CLIENT) || (fl == WOC_RGN_CLIENT_DELTA) ||
             (fl == WOC_DELETE)))
        {
            if (!pWndPriv)
            {
                return;
            }

            // Invalidate cache because buffers may have moved
            pWndPriv->bBuffersValid = FALSE;
        }

        switch (fl)
        {
            case WOC_RGN_CLIENT:        // Capture the clip list

                GetClipLists(pwo, pWndPriv);

                pWndPriv->MCDWindow.clientRect = pwo->rclClient;
                pWndPriv->MCDWindow.clipBoundsRect = pwo->coClient.rclBounds;
		pWndPriv->bRegionValid = TRUE;
                if (pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow != NULL)
                {
                    (*pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow)
                        (pwo, (MCDWINDOW *)pWndPriv, fl);
                }
                break;

            case WOC_RGN_CLIENT_DELTA:
                if (pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow != NULL)
                {
                    (*pWndPriv->pGlobal->mcdDriver.pMCDrvTrackWindow)
                        (pwo, (MCDWINDOW *)pWndPriv, fl);
                }
                break;

            case WOC_RGN_SURFACE:
            case WOC_RGN_SURFACE_DELTA:

            //!!!HACK -- use NULL for pWndPriv; we didn't set it, so we can't
            //!!!        trust it

                pGlobal = MCDSrvGetGlobalInfo(pwo->psoOwner);
                if (pGlobal != NULL &&
                    pGlobal->mcdDriver.pMCDrvTrackWindow != NULL)
                {
                    (pGlobal->mcdDriver.pMCDrvTrackWindow)
                        (pwo, (MCDWINDOW *)NULL, fl);
                }
                break;

            case WOC_DELETE:
            //MCDBG_PRINT("WndObjChangeProc: WOC_DELETE.");

            // Window is being deleted, so destroy our private window data,
            // and set the consumer field of the WNDOBJ to NULL:

                if (pWndPriv)
                {
		    DecoupleMCDWindow(pWndPriv);
                }
                break;

            default:
                break;
         }
    }
}

//****************************************************************************
// FreeMCDWindowObj()
//
// Callback to clean up MCDWINDOWs
//****************************************************************************

BOOL CALLBACK FreeMCDWindowObj(DRIVEROBJ *pDrvObj)
{
    MCDWINDOWOBJ *pmwo = (MCDWINDOWOBJ *)pDrvObj->pvObj;

    DestroyMCDWindowObj(pmwo);

    return TRUE;
}

//****************************************************************************
// NewMCDWindowObj()
//
// Creates and initializes a new MCDWINDOW and initializes tracking of the
// associated window through callback notification.
//****************************************************************************

PRIVATE
MCDWINDOWOBJ *NewMCDWindowObj(MCDSURFACE *pMCDSurface,
                              MCDGLOBALINFO *pGlobal,
                              HDEV hdev)
{
    MCDWINDOW *pWnd;
    MCDWINDOWPRIV *pWndPriv;
    MCDWINDOWOBJ *pmwo;
    MCDENUMRECTS *pDefault;
    MCDHANDLE handle;

    pmwo = (MCDWINDOWOBJ *)MCDSrvLocalAlloc(0, sizeof(MCDWINDOWOBJ));
    if (!pmwo)
    {
        return NULL;
    }

    // Create a driver object for this window
    handle = MCDEngCreateObject(pmwo, FreeMCDWindowObj, hdev);
    if (handle == 0)
    {
        MCDBG_PRINT("NewMCDWindow: Could not create new handle.");
        MCDSrvLocalFree((UCHAR *)pmwo);
        return NULL;
    }

    pWndPriv = &pmwo->MCDWindowPriv;
    pWnd = &pWndPriv->MCDWindow;

    // Initialize the structure members:

    pmwo->type = MCDHANDLE_WINDOW;
    pWndPriv->objectList = NULL;
    pWndPriv->handle = handle;
    pWndPriv->bBuffersValid = FALSE;
    pWndPriv->pGlobal = pGlobal;

    // Initialize the clipping:

    pDefault = (MCDENUMRECTS*) &pWndPriv->defaultClipBuffer[0];
    pDefault->c = 0;
    pWndPriv->pAllocatedClipBuffer = NULL;
    pWndPriv->pClipUnscissored = pDefault;
    pWndPriv->sizeClipBuffer = SIZE_DEFAULT_CLIP_BUFFER;
    pWndPriv->sizeClipBuffer = SIZE_DEFAULT_CLIP_BUFFER;
    pWnd->pClip = pDefault;

    return pmwo;
}


//****************************************************************************
// MCDSrvNewWndObj()
//
// Creates a new WNDOBJ for window tracking.
//****************************************************************************

PRIVATE
WNDOBJ *MCDSrvNewWndObj(MCDSURFACE *pMCDSurface, HWND hWnd, WNDOBJ *pwoIn,
                        MCDGLOBALINFO *pGlobal, HDEV hdev)
{
    MCDWINDOW *pWnd;
    MCDWINDOWPRIV *pWndPriv;
    WNDOBJ *pwo;
    MCDWINDOWOBJ *pmwo;

    pmwo = NewMCDWindowObj(pMCDSurface, pGlobal, hdev);
    if (!pmwo)
    {
        return NULL;
    }

    pWndPriv = &pmwo->MCDWindowPriv;
    pWnd = &pWndPriv->MCDWindow;

    pWndPriv->hWnd = hWnd;

    // Handle the case where a WNDOBJ already exists but hasn't been
    // initialized for MCD usage in addition to the new creation case.
    if (pwoIn == NULL)
    {
        pwo = MCDEngCreateWndObj(pMCDSurface, hWnd, WndObjChangeProc);

        if (!pwo || ((LONG_PTR)pwo == -1))
        {
            MCDBG_PRINT("NewMCDWindowTrack: could not create WNDOBJ.");
            MCDEngDeleteObject(pmwo->MCDWindowPriv.handle);
            return NULL;
        }
    }
    else
    {
        pwo = pwoIn;
    }

    // Set the consumer field in the WNDOBJ:

    WNDOBJ_vSetConsumer(pwo, (PVOID)pWndPriv);

    // Point back to the WNDOBJ
    pWndPriv->pwo = pwo;

    return pwo;
}

//****************************************************************************
// MCDSrvNewMcdWindow()
//
// Creates a new MCDWINDOW for window tracking.
//****************************************************************************

PRIVATE
MCDWINDOW *MCDSrvNewMCDWindow(MCDSURFACE *pMCDSurface, HWND hWnd,
                              MCDGLOBALINFO *pGlobal, HDEV hdev)
{
    MCDWINDOW *pWnd;
    MCDWINDOWPRIV *pWndPriv;
    MCDWINDOWOBJ *pmwo;

    // Initialize tracking of this window with a MCDWINDOW
    // (via a WNDOBJ on NT) if we are not already tracking the
    // window:

    if (pMCDSurface->surfaceFlags & MCDSURFACE_HWND)
    {
        WNDOBJ *pwo;

        pwo = MCDEngGetWndObj(pMCDSurface);

        // Sometimes a WNDOBJ has been used and the MCD state destroyed so
	// the consumer is NULL but the WNDOBJ exists.  In that case
	// we need to create a new MCDWINDOW for it.
        if (!pwo || !pwo->pvConsumer)
        {
	    pwo = MCDSrvNewWndObj(pMCDSurface, hWnd, pwo, pGlobal, hdev);

            if (!pwo)
            {
                MCDBG_PRINT("MCDSrvNewMcdWindow: "
                            "Creation of window object failed.");
                return NULL;
            }

            ((MCDWINDOW *)pwo->pvConsumer)->pvUser = NULL;
        }

        pWnd = (MCDWINDOW *)pwo->pvConsumer;
    }
    else
    {
#if MCD_VER_MAJOR >= 2 || (MCD_VER_MAJOR == 1 && MCD_VER_MINOR >= 0x10)
        MCDENUMRECTS *pDefault;
        PDD_SURFACE_GLOBAL pGbl;

        pmwo = NewMCDWindowObj(pMCDSurface, pGlobal, hdev);
        if (!pmwo)
        {
            MCDBG_PRINT("MCDSrvNewMcdWindow: "
                        "Creation of window object failed.");
            return NULL;
        }

        pWnd = &pmwo->MCDWindowPriv.MCDWindow;

        // Real clipping info
        pWndPriv = (MCDWINDOWPRIV *)pWnd;

        pGbl = ((PDD_SURFACE_LOCAL)pMCDSurface->frontId)->lpGbl;
        pWndPriv->MCDWindow.clientRect.left = pGbl->xHint;
        pWndPriv->MCDWindow.clientRect.top = pGbl->yHint;
        pWndPriv->MCDWindow.clientRect.right = pGbl->xHint+pGbl->wWidth;
        pWndPriv->MCDWindow.clientRect.bottom = pGbl->yHint+pGbl->wHeight;
        pWndPriv->MCDWindow.clipBoundsRect = pWndPriv->MCDWindow.clientRect;
        pWndPriv->bRegionValid = TRUE;

        pDefault = (MCDENUMRECTS*) &pWndPriv->defaultClipBuffer[0];
        pDefault->c = 1;
        pDefault->arcl[0] = pWndPriv->MCDWindow.clientRect;
#else
        return NULL;
#endif // 1.1
    }

    pMCDSurface->pWnd = pWnd;
    pWndPriv = (MCDWINDOWPRIV *)pWnd;
    pWndPriv->hWnd = hWnd;

    return pWnd;
}

////////////////////////////////////////////////////////////////////////////
//
//
// MCD locking support.
//
//
////////////////////////////////////////////////////////////////////////////


//****************************************************************************
// ULONG MCDSrvLock(MCDWINDOWPRIV *pWndPriv);
//
// Lock the MCD driver for the specified window.  Fails if lock is already
// held by another window.
//****************************************************************************

ULONG MCDSrvLock(MCDWINDOWPRIV *pWndPriv)
{
    ULONG ulRet = MCD_LOCK_BUSY;
    MCDLOCKINFO *pLockInfo;

    pLockInfo = &pWndPriv->pGlobal->lockInfo;
    if (!pLockInfo->bLocked || pLockInfo->pWndPrivOwner == pWndPriv)
    {
        pLockInfo->bLocked = TRUE;
        pLockInfo->pWndPrivOwner = pWndPriv;
        ulRet = MCD_LOCK_TAKEN;
    }

    return ulRet;
}


//****************************************************************************
// VOID MCDSrvUnlock(MCDWINDOWPRIV *pWndPriv);
//
// Releases the MCD driver lock if held by the specified window.
//****************************************************************************

VOID MCDSrvUnlock(MCDWINDOWPRIV *pWndPriv)
{
    MCDLOCKINFO *pLockInfo;

    //!!!dbug -- could add a lock count, but not really needed right now

    pLockInfo = &pWndPriv->pGlobal->lockInfo;
    if (pLockInfo->pWndPrivOwner == pWndPriv)
    {
        pLockInfo->bLocked = FALSE;
        pLockInfo->pWndPrivOwner = 0;
    }
}


//****************************************************************************
// 
// Per-driver-instance information list handling.
//
//****************************************************************************

#define GLOBAL_INFO_BLOCK 8

ENGSAFESEMAPHORE ssemGlobalInfo;
MCDGLOBALINFO *pGlobalInfo;
int iGlobalInfoAllocated = 0;
int iGlobalInfoUsed = 0;

BOOL MCDSrvInitGlobalInfo(void)
{
    return EngInitializeSafeSemaphore(&ssemGlobalInfo);
}

MCDGLOBALINFO *MCDSrvAddGlobalInfo(SURFOBJ *pso)
{
    MCDGLOBALINFO *pGlobal;
    
    EngAcquireSemaphore(ssemGlobalInfo.hsem);

    // Ensure space for new entry
    if (iGlobalInfoUsed >= iGlobalInfoAllocated)
    {
        pGlobal = (MCDGLOBALINFO *)
            MCDSrvLocalAlloc(0, (iGlobalInfoAllocated+GLOBAL_INFO_BLOCK)*
                             sizeof(MCDGLOBALINFO));
        if (pGlobal != NULL)
        {
            // Copy old data if necessary
            if (iGlobalInfoAllocated > 0)
            {
                memcpy(pGlobal, pGlobalInfo, iGlobalInfoAllocated*
                       sizeof(MCDGLOBALINFO));
                MCDSrvLocalFree((UCHAR *)pGlobalInfo);
            }

            // Set new information
            pGlobalInfo = pGlobal;
            iGlobalInfoAllocated += GLOBAL_INFO_BLOCK;
            iGlobalInfoUsed++;

            // pGlobal is guaranteed zero-filled because of MCDSrvLocalAlloc's
            // behavior, so just fill in the pso.
            pGlobal += iGlobalInfoAllocated;
            pGlobal->pso = pso;
        }
        else
        {
            // Falls out and returns NULL
        }
    }
    else
    {
        MCDGLOBALINFO *pGlobal;
        int i;

        pGlobal = pGlobalInfo;
        for (i = 0; i < iGlobalInfoAllocated; i++)
        {
            if (pGlobal->pso == pso)
            {
                // This should never happen.
                MCDBG_PRINT("MCDSrvAddGlobalInfo: duplicate pso");
                pGlobal = NULL;
                break;
            }
                      
            if (pGlobal->pso == NULL)
            {
                iGlobalInfoUsed++;
                
                // Initialize pso for use.
                memset(pGlobal, 0, sizeof(*pGlobal));
                pGlobal->pso = pso;
                break;
            }

            pGlobal++;
        }
    }

    EngReleaseSemaphore(ssemGlobalInfo.hsem);

    return pGlobal;
}

MCDGLOBALINFO *MCDSrvGetGlobalInfo(SURFOBJ *pso)
{
    MCDGLOBALINFO *pGlobal;
    int i;

    // For backwards compatibility we handle one instance
    // using global data.  If the incoming pso matches the
    // pso in the static data then just return it.
    // It is important to check this before entering the semaphore
    // since the semaphore is not created if only legacy drivers
    // have attached.
    if (pso == gStaticGlobalInfo.pso)
    {
        return &gStaticGlobalInfo;
    }

    // Technically we shouldn't have to check this, since MCD processing
    // should not occur unless:
    // 1. It's an old style driver and hits the static case above.
    // 2. It's a new style driver and the semaphore has been created.
    // Unfortunately not all drivers are well-behaved, plus there's a
    // potentialy legacy driver bug where drivers don't check for init
    // failure and try to call MCD anyway.
    if (ssemGlobalInfo.hsem == NULL)
    {
        MCDBG_PRINT("MCDSrvGetGlobalInfo: no hsem");
        return NULL;
    }
    
    EngAcquireSemaphore(ssemGlobalInfo.hsem);

    pGlobal = pGlobalInfo;
    for (i = 0; i < iGlobalInfoAllocated; i++)
    {
        if (pGlobal->pso == pso)
        {
            break;
        }

        pGlobal++;
    }

    // Technically we shouldn't have to check this, because if
    // we made it into the non-static code path a matching pso should
    // be registered.  As with the above check, though, it's better
    // safe than sorry.
    if (i >= iGlobalInfoAllocated)
    {
        MCDBG_PRINT("MCDSrvGetGlobalInfo: no pso match");
        pGlobal = NULL;
    }
    
    EngReleaseSemaphore(ssemGlobalInfo.hsem);

    return pGlobal;
}

void MCDSrvUninitGlobalInfo(void)
{
    EngDeleteSafeSemaphore(&ssemGlobalInfo);
}

void WINAPI MCDEngUninit(SURFOBJ *pso)
{
    MCDGLOBALINFO *pGlobal;
    int i;

    // This should never happen.
    if (ssemGlobalInfo.hsem == NULL)
    {
        MCDBG_PRINT("MCDEngUninit: no hsem");
        return;
    }
    
    EngAcquireSemaphore(ssemGlobalInfo.hsem);

    pGlobal = pGlobalInfo;
    for (i = 0; i < iGlobalInfoAllocated; i++)
    {
        if (pGlobal->pso == pso)
        {
            break;
        }

        pGlobal++;
    }

    if (i >= iGlobalInfoAllocated)
    {
        // This should never happen.
        MCDBG_PRINT("MCDEngUninit: No pso match");
    }
    else if (--iGlobalInfoUsed == 0)
    {
        MCDSrvLocalFree((UCHAR *)pGlobalInfo);
        iGlobalInfoAllocated = 0;
    }
    else
    {
        pGlobal->pso = NULL;
    }
    
    EngReleaseSemaphore(ssemGlobalInfo.hsem);
    MCDSrvUninitGlobalInfo();
}

//****************************************************************************
// BOOL HalInitSystem(ULONG a, ULONG b)
//
// This is a dummy function needed to use the standard makefile.def since
// we're pretending we're an NT HAL.
//****************************************************************************

BOOL HalInitSystem(ULONG a, ULONG b)
{
    return TRUE;
}


//******************************Public*Routine******************************
//
// BOOL WINAPI DllEntry(HINSTANCE hDLLInst, DWORD fdwReason,
//                      LPVOID lpvReserved);
//
// DLL entry point invoked for each process and thread that attaches to
// this DLL.
//
//**************************************************************************

BOOL WINAPI DllEntry(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            // The DLL is being loaded for the first time by a given process.
            // Perform per-process initialization here.  If the initialization
            // is successful, return TRUE; if unsuccessful, return FALSE.
            break;

        case DLL_PROCESS_DETACH:
            // The DLL is being unloaded by a given process.  Do any
            // per-process clean up here, such as undoing what was done in
            // DLL_PROCESS_ATTACH.  The return value is ignored.

            break;

        case DLL_THREAD_ATTACH:
            // A thread is being created in a process that has already loaded
            // this DLL.  Perform any per-thread initialization here.  The
            // return value is ignored.

            break;

        case DLL_THREAD_DETACH:
            // A thread is exiting cleanly in a process that has already
            // loaded this DLL.  Perform any per-thread clean up here.  The
            // return value is ignored.

            break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\mcd\server\mcdeng.c ===
/******************************Module*Header*******************************\
* Module Name: mcdeng.c
*
* Internal server-side MCD engine functions to perform functions such as
* driver object management, memory allocation, etc.
*
* Copyright (c) 1996 Microsoft Corporation
*
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <windef.h>
#include <wingdi.h>

#include <windows.h>
#include <wtypes.h>

#include <winddi.h>
#include <mcdesc.h>

#include "mcdrv.h"
#include <mcd2hack.h>
#include "mcd.h"
#include "mcdint.h"
#include "mcdrvint.h"


WNDOBJ *MCDEngGetWndObj(MCDSURFACE *pMCDSurface)
{
    return pMCDSurface->pwo;
}


VOID MCDEngUpdateClipList(WNDOBJ *pwo)
{
    return;
}

DRIVEROBJ *MCDEngLockObject(MCDHANDLE hObj)
{
    return (DRIVEROBJ *)EngLockDriverObj((HDRVOBJ)hObj);
}

VOID MCDEngUnlockObject(MCDHANDLE hObj)
{
    EngUnlockDriverObj((HDRVOBJ)hObj);
}

WNDOBJ *MCDEngCreateWndObj(MCDSURFACE *pMCDSurface, HWND hWnd,
                           WNDOBJCHANGEPROC pChangeProc)
{
    return EngCreateWnd(pMCDSurface->pso,
                        hWnd,
                        pChangeProc,
                        (WO_RGN_CLIENT_DELTA     |
                         WO_RGN_CLIENT           |
                         WO_RGN_SURFACE_DELTA    |
                         WO_RGN_SURFACE          |
                         WO_RGN_UPDATE_ALL
                        ), 0);
}

MCDHANDLE MCDEngCreateObject(VOID *pObject, FREEOBJPROC pFreeObjFunc,
                             HDEV hDevEng)
{
    return (MCDHANDLE)EngCreateDriverObj(pObject,
                                         pFreeObjFunc,
                                         hDevEng);
}

BOOL MCDEngDeleteObject(MCDHANDLE hObj)
{
    return (EngDeleteDriverObj((HDRVOBJ)hObj, TRUE, FALSE) != 0);
}

UCHAR *MCDEngAllocSharedMem(ULONG numBytes)
{
    return (UCHAR *)EngAllocUserMem(min(numBytes, MCD_MAX_ALLOC),
                                    MCD_ALLOC_TAG);
}

VOID MCDEngFreeSharedMem(UCHAR *pMem)
{
    EngFreeUserMem((VOID *)pMem);
}

//****************************************************************************
// MCDEngGetPtrFromHandle()
//
// Converts a driver handle to a pointer.  Note that we lock and unlock
// the object, and do not hold the lock during use of the pointer.  This
// simplifies much of the other logic in the driver, especially in
// early- or error-return cases, and is safe since we as single-threaded
// inside the driver.
//****************************************************************************

VOID *MCDEngGetPtrFromHandle(MCDHANDLE handle, MCDHANDLETYPE type)
{
    MCDRCOBJ *pRcObject;
    DRIVEROBJ *pDrvObj;

    pDrvObj = (DRIVEROBJ *)EngLockDriverObj((HDRVOBJ)handle);

    if (!pDrvObj)
    {
        MCDBG_PRINT("GetPtrFromHandle: Couldn't unlock driver object.");
        return (PVOID)NULL;
    }
    else
    {
        pRcObject = (MCDRCOBJ *)pDrvObj->pvObj;
        EngUnlockDriverObj((HDRVOBJ)handle);

        if (pRcObject->type != type)
        {
            MCDBG_PRINT("MCDSrvGetPtrFromHandle: Wrong type: got %d, expected %d.",
                        pRcObject->type, type);
            return (PVOID)NULL;
        }
        else
            return pRcObject;
    }
}

ULONG_PTR MCDEngGetProcessID()
{
    return (ULONG_PTR)EngGetProcessHandle();
}


#if DBG

ULONG MCDLocalMemSize = 0;

UCHAR *MCDSrvDbgLocalAlloc(UINT flags, UINT size)
{
    UCHAR *pRet;

    if (pRet = (UCHAR *)EngAllocMem(FL_ZERO_MEMORY, size + sizeof(ULONG),
                                    MCD_ALLOC_TAG)) {
        MCDLocalMemSize += size;
        *((ULONG *)pRet) = size;
        return (pRet + sizeof(ULONG));
    } else
        return (UCHAR *)NULL;
}


VOID MCDSrvDbgLocalFree(UCHAR *pMem)
{
    if (!pMem) {
        MCDBG_PRINT("MCDSrvDbgLocalFree: Attempt to free NULL pointer.");
        return;
    }

    pMem -= sizeof(ULONG);

    MCDLocalMemSize -= *((ULONG *)pMem);

    EngFreeMem((VOID *)pMem);
}

VOID MCDDebugPrint(char *pMessage, ...)
{
    char buffer[256];
    int len;
    va_list ap;

    va_start(ap, pMessage);

    EngDebugPrint("[MCD] ", pMessage, ap);
    EngDebugPrint("", "\n", ap);

    va_end(ap);
}

VOID MCDAssertFailed(char *pMessage, char *pFile, int line)
{
    MCDDebugPrint("%s(%d): %s", pFile, line, pMessage);
    EngDebugBreak();
}

#else


UCHAR *MCDSrvLocalAlloc(UINT flags, UINT size)
{

    return (UCHAR *)EngAllocMem(FL_ZERO_MEMORY, size, MCD_ALLOC_TAG);
}


VOID MCDSrvLocalFree(UCHAR *pMem)
{
    EngFreeMem((VOID *)pMem);
}


#endif /* DBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\alloc.c ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#if DBG

// Set glRandomMallocFail to a positive value, say 40, to enable random
// allocation failures.  The failure will occur every glRandomMallocFail
// times.
long glRandomMallocFail = 0;
static long glRandomFailCount;

// glSize is the size of memory in use.
ULONG glSize = 0;
ULONG glHighWater = 0;
ULONG glReal = 0;

static void AdjustSizes(LONG delta, void *mem)
{
    ULONG nbytes;

#ifdef GL_REAL_SIZE
    nbytes = HeapSize(GetProcessHeap(), 0, mem);
#else
    nbytes = 0;
#endif
    
    if (delta < 0)
    {
        glSize -= (ULONG)(-delta);
        glReal -= nbytes;
        
        if ((int) glSize < 0)
        {
            DBGPRINT("glSize underflows\n");
        }
    }
    else if (delta > 0)
    {
        glSize += delta;
        glReal += nbytes;
        
        if ((int) glSize < 0)
        {
            DBGPRINT("glSize overflows\n");
        }
        
        if (glSize > glHighWater)
        {
#ifdef GL_SHOW_HIGH_WATER
            DbgPrint("glSize high %8d (%8d)\n", glSize, glReal);
#endif
            glHighWater = glSize;
        }
    }
}

typedef struct _MEM_HDR
{
    ULONG nbytes;
    ULONG signature[3];
} MEM_HDR;

// 'GLal' in byte order
#define MEM_ALLOC_SIG 0x6C614C47
// 'GLfr' in byte order
#define MEM_FREE_SIG 0x72664C47

#define MEM_HDR_SIZE sizeof(MEM_HDR)
#define MEM_HDR_PTR(mem) ((MEM_HDR *)((BYTE *)(mem)-MEM_HDR_SIZE))

// XXX We may want to protect these debug allocation functions with a
// critical section.
void * FASTCALL
dbgAlloc(UINT nbytes, DWORD flags)
{
    PVOID mem;

    // If random failure is enabled, fail this call randomly.

    if (glRandomMallocFail)
    {
        if (++glRandomFailCount >= glRandomMallocFail)
        {
            DBGPRINT("dbgAlloc random failing\n");
            glRandomFailCount = 0;
            return NULL;
        }
    }

    if (nbytes == 0)
    {
        DBGERROR("nbytes == 0\n");
        return NULL;
    }
    
    // Allocate extra bytes for debug house keeping.

    mem = HeapAlloc(GetProcessHeap(), flags, nbytes+MEM_HDR_SIZE);

    // Do house keeping and add allocation size so far.

    if (mem)
    {
        MEM_HDR *pmh = (MEM_HDR *)mem;

        pmh->nbytes = nbytes;
        pmh->signature[0] = MEM_ALLOC_SIG;
        pmh->signature[1] = MEM_ALLOC_SIG;
        pmh->signature[2] = MEM_ALLOC_SIG;
        AdjustSizes((LONG)nbytes, mem);
        mem = (PVOID) (pmh+1);
    }
    else
    {
        DBGLEVEL1(LEVEL_ERROR, "dbgAlloc could not allocate %u bytes\n",
                  nbytes);
    }

    DBGLEVEL2(LEVEL_ALLOC, "dbgAlloc of %u returned 0x%x\n", nbytes, mem);
    
    return mem;
}

void FASTCALL
dbgFree(void *mem)
{
    MEM_HDR *pmh;
    
    if (!mem)
    {
#ifdef FREE_OF_NULL_ERR
	// Freeing NULL happens currently so this error results
	// in a little too much spew.
        DBGERROR("mem is NULL\n");
#endif
        return;
    }

    // Verify that the signature is not corrupted.

    pmh = MEM_HDR_PTR(mem);
    if (pmh->signature[0] != MEM_ALLOC_SIG ||
        pmh->signature[1] != MEM_ALLOC_SIG ||
        pmh->signature[2] != MEM_ALLOC_SIG)
    {
        WARNING("Possible memory corruption\n");
    }

    // Make sure it is freed once only.

    pmh->signature[0] = MEM_FREE_SIG;
    pmh->signature[1] = MEM_FREE_SIG;
    pmh->signature[2] = MEM_FREE_SIG;

    // Subtract the allocation size.

    AdjustSizes(-(LONG)pmh->nbytes, pmh);

    HeapFree(GetProcessHeap(), 0, pmh);
    
    DBGLEVEL1(LEVEL_ALLOC, "dbgFree of 0x%x\n", mem);
}

void * FASTCALL
dbgRealloc(void *mem, UINT nbytes)
{
    PVOID memNew;
    MEM_HDR *pmh;

    // If random failure is enabled, fail this call randomly.

    if (glRandomMallocFail)
    {
        if (++glRandomFailCount >= glRandomMallocFail)
        {
            DBGPRINT("dbgRealloc random failing\n");
            glRandomFailCount = 0;
            return NULL;
        }
    }

    if (mem != NULL)
    {
	// Verify that the signature is not corrupted.
        
        pmh = MEM_HDR_PTR(mem);
        if (pmh->signature[0] != MEM_ALLOC_SIG ||
            pmh->signature[1] != MEM_ALLOC_SIG ||
            pmh->signature[2] != MEM_ALLOC_SIG)
        {
            WARNING("Possible memory corruption\n");
        }

        AdjustSizes(-(LONG)pmh->nbytes, pmh);
        
        // Reallocate nbytes+extra bytes.
        memNew = HeapReAlloc(GetProcessHeap(), 0, pmh, nbytes+MEM_HDR_SIZE);
    }
    else
    {
        // Old memory pointer is NULL, so allocate a new chunk.
        memNew = HeapAlloc(GetProcessHeap(), 0, nbytes+MEM_HDR_SIZE);

        // We've allocated new memory so initialize its signature.
        if (memNew != NULL)
        {
            pmh = (MEM_HDR *)memNew;
            pmh->signature[0] = MEM_ALLOC_SIG;
            pmh->signature[1] = MEM_ALLOC_SIG;
            pmh->signature[2] = MEM_ALLOC_SIG;
        }
    }

    if (memNew != NULL)
    {
        // Do house keeping and update allocation size so far.

        AdjustSizes(nbytes, memNew);
        pmh = (MEM_HDR *)memNew;
        pmh->nbytes = nbytes;
        memNew = (PVOID) (pmh+1);
    }
    else
    {
        if (mem != NULL)
        {
            AdjustSizes((LONG)pmh->nbytes, pmh);
        }
        
        DBGLEVEL1(LEVEL_ERROR, "dbgRealloc could not allocate %u bytes\n",
                  nbytes);
    }

    DBGLEVEL3(LEVEL_ALLOC, "dbgRealloc of 0x%X:%u returned 0x%x\n",
              mem, nbytes, memNew);

    return memNew;
}

int FASTCALL
dbgMemSize(void *mem)
{
    MEM_HDR *pmh;
    
    pmh = MEM_HDR_PTR(mem);
    
    if (pmh->signature[0] != MEM_ALLOC_SIG ||
        pmh->signature[1] != MEM_ALLOC_SIG ||
        pmh->signature[2] != MEM_ALLOC_SIG)
    {
        return -1;
    }
    
    return (int)pmh->nbytes;
}

#endif // DBG

ULONG APIENTRY glDebugEntry(int param, void *data)
{
#if DBG
    switch(param)
    {
    case 0:
	return glSize;
    case 1:
	return glHighWater;
    case 2:
	return glReal;
    case 3:
        return dbgMemSize(data);
    }
#endif
    return 0;
}

#define MEM_ALIGN 32

void * FASTCALL
AllocAlign32(UINT nbytes)
{
    void *mem;
    void **aligned;

    // We allocate enough extra memory for the alignment and our header
    // which just consists of a pointer:

    mem = ALLOC(nbytes + MEM_ALIGN + sizeof(void *));
    if (!mem)
    {
        DBGLEVEL1(LEVEL_ERROR, "AllocAlign32 could not allocate %u bytes\n",
                  nbytes);
        return NULL;
    }

    aligned = (void **)(((ULONG_PTR)mem + sizeof(void *) +
                         (MEM_ALIGN - 1)) & ~(MEM_ALIGN - 1));
    *(aligned-1) = mem;
    
    return aligned;
}

void FASTCALL
FreeAlign32(void *mem)
{
    if ( NULL == mem )
    {
        DBGERROR("NULL pointer passed to FreeAlign32\n");
        return;
    }

    FREE(*((void **)mem-1));
}

void * FASTCALL
gcAlloc( __GLcontext *gc, UINT nbytes, DWORD flags )
{
    void *mem;

#if DBG
    mem = dbgAlloc(nbytes, flags);
#else
    mem = HeapAlloc(GetProcessHeap(), flags, nbytes);
#endif
    if (NULL == mem)
    {
        ((__GLGENcontext *)gc)->errorcode = GLGEN_OUT_OF_MEMORY;
        __glSetErrorEarly(gc, GL_OUT_OF_MEMORY);
    }
    return mem;
}

void * FASTCALL
GCREALLOC( __GLcontext *gc, void *mem, UINT nbytes )
{
    void *newMem;

    // The Win32 realloc functions do not have free-on-zero behavior,
    // so fake it.
    if (nbytes == 0)
    {
	if (mem != NULL)
	{
	    FREE(mem);
	}
	return NULL;
    }

    // The Win32 realloc functions don't handle a NULL old pointer,
    // so explicitly turn such calls into allocs.
    if (mem == NULL)
    {
	newMem = ALLOC(nbytes);
    }
    else
    {
	newMem = REALLOC(mem, nbytes);
    }

    if (NULL == newMem)
    {
        ((__GLGENcontext *)gc)->errorcode = GLGEN_OUT_OF_MEMORY;
        __glSetErrorEarly(gc, GL_OUT_OF_MEMORY);
    }

    return newMem;
}

void * FASTCALL
GCALLOCALIGN32( __GLcontext *gc, UINT nbytes )
{
    void *mem;

    mem = AllocAlign32(nbytes);
    if (NULL == mem)
    {
        ((__GLGENcontext *)gc)->errorcode = GLGEN_OUT_OF_MEMORY;
        __glSetErrorEarly(gc, GL_OUT_OF_MEMORY);
    }
    return mem;
}

// Tunable parameters for temporary memory allocation

#define MAX_TEMP_BUFFERS    4
#define TEMP_BUFFER_SIZE    4096

struct MemHeaderRec
{
    LONG  inUse;
    ULONG nbytes;
    void  *mem;
};

typedef struct MemHeaderRec MemHeader;

MemHeader TempMemHeader[MAX_TEMP_BUFFERS];

// InitTempAlloc
//      Initializes the temporary memory allocation header and allocates the
//      temporary memory buffers.
//
// Synopsis:
//      BOOL InitTempAlloc()
//
// History:
//      02-DEC-93 Eddie Robinson [v-eddier] Wrote it.
//
BOOL FASTCALL
InitTempAlloc(void)
{
    int   i;
    PBYTE buffers;
    static LONG initCount = -1;
    
    if (initCount >= 0)
        return TRUE;

    if (InterlockedIncrement(&initCount) != 0)
        return TRUE;

// Allocate buffers for the first time.

    buffers = ALLOC(MAX_TEMP_BUFFERS*TEMP_BUFFER_SIZE);
    if (!buffers)
    {
        InterlockedDecrement(&initCount);           // try again later
        return FALSE;
    }

    for (i = 0; i < MAX_TEMP_BUFFERS; i++)
    {
        TempMemHeader[i].nbytes = TEMP_BUFFER_SIZE;
        TempMemHeader[i].mem = (void *) buffers;
        TempMemHeader[i].inUse = -1;      // must be last
        buffers += TEMP_BUFFER_SIZE;
    }
    
    return TRUE;
}                                  

// gcTempAlloc
//      Allocates temporary memory from a static array, if possible.  Otherwise
//      it calls ALLOC
//
// Synopsis:
//      void * gcTempAlloc(__GLcontext *gc, UINT nbytes)
//          gc      points to the OpenGL context structure
//          nbytes  specifies the number of bytes to allocate
//
// History:
//  02-DEC-93 Eddie Robinson [v-eddier] Wrote it.
//
void * FASTCALL
gcTempAlloc(__GLcontext *gc, UINT nbytes)
{
    int i;
    void *mem;

    if (nbytes == 0)
    {
        // Zero-byte allocations do occur so don't make this a warning
        // to avoid excessive debug spew.
        DBGLEVEL(LEVEL_ALLOC, "gcTempAlloc: failing zero byte alloc\n");
        return NULL;
    }
    
    for (i = 0; i < MAX_TEMP_BUFFERS; i++)
    {
        if (nbytes <= TempMemHeader[i].nbytes)
        {
            if (InterlockedIncrement(&TempMemHeader[i].inUse))
            {
                InterlockedDecrement(&TempMemHeader[i].inUse);
            }
            else
            {
                DBGLEVEL2(LEVEL_ALLOC, "gcTempAlloc of %u returned 0x%x\n",
                          nbytes, TempMemHeader[i].mem);
                GC_TEMP_BUFFER_ALLOC(gc, TempMemHeader[i].mem);
                return(TempMemHeader[i].mem);
            }
        }
    }
    
    mem = ALLOC(nbytes);
    if (!mem)
    {
        WARNING1("gcTempAlloc: memory allocation error size %d\n", nbytes);
        ((__GLGENcontext *)gc)->errorcode = GLGEN_OUT_OF_MEMORY;
        __glSetErrorEarly(gc, GL_OUT_OF_MEMORY);
    }
    
    DBGLEVEL2(LEVEL_ALLOC, "gcTempAlloc of %u returned 0x%x\n", nbytes, mem);
    GC_TEMP_BUFFER_ALLOC(gc, mem);
    
    return mem;
}

// gcTempFree
//      Marks allocated static buffer as unused or calls FREE.
//
// Synopsis:
//      void gcTempFree(__GLcontext *gc, void *mem)
//          mem    specifies the adress of the memory to free
//
// History:
//  02-DEC-93 Eddie Robinson [v-eddier] Wrote it.
//
void FASTCALL
gcTempFree(__GLcontext *gc, void *mem)
{
    int i;
    
    DBGLEVEL1(LEVEL_ALLOC, "gcTempFree of 0x%x\n", mem);

    GC_TEMP_BUFFER_FREE(gc, mem);
    for (i = 0; i < MAX_TEMP_BUFFERS; i++)
    {
        if (mem == TempMemHeader[i].mem)
        {
            InterlockedDecrement(&TempMemHeader[i].inUse);
            return;
        }
    }
    
    FREE( mem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\debug.c ===
//+---------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// debug.c
//
// Debug build support routines.
//
// History:
//  Mon Jun 02 17:07:23 1997	-by-	Drew Bliss [drewb]
//   Created
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

#include <imports.h>
#include <devlock.h>

#if DBG

static void printNormalFloat( float fval )
{
    int logi, logval_i, logval_f;
    float logval, logf;
    int negative=0;

    if( fval < (float) 0.0 )
	negative = 1;
    fval = __GL_ABSF(fval);

    logval = (float) (log( fval ) / log( 10 ));

    logi = (int) logval;
    logf = logval - logi;

    if( (logval <= (float) 0) && (logf != (float) 0.0) ) {
	logi -= 1;
	logf += (float) 1.0;
    }
    logval = (float) pow(10,logf);
    if( negative )
	DbgPrint( "-" );
#if 0
    DbgPrint( "%fE%d", logval, logi );
#else
    logval_i = (int) logval;
    logval_f = (int) ((logval - (float) logval_i) * (float) 10000.0 + (float) 0.5);
    DbgPrint( "%d.%dE%d", logval_i, logval_f, logi );
#endif
}

void printFloat( char *comment, void *mval, int printHex ) 
{
// IEEE single format: sign bits : 1
//		       exponent  : 7
//		       fraction  : 24
// Representation:	low word : Fraction low
//		       high word : 0-6: Fraction high
//				   7-14: Exponent
//				     15: Sign
    char *ploww, *phighw;
    short loww, highw;
    long lval = 0, fraction;
    int sign, exponent;
    float fval;

    ploww = (char *) mval;
    phighw = (char *) ((char *) mval) + 2;
    memcpy( &loww, ploww, 2 );
    memcpy( &highw, phighw, 2 );
    memcpy( &lval, mval, 4 );

    sign = (highw & 0x8000) >> 15;
    fraction = lval & 0x007fffff;
    exponent = (highw & 0x7f80) >> 7;

    DbgPrint( "%s", comment );
    if( printHex )
    	DbgPrint( "0x%x, ", lval );
    if( exponent == 255 ) {
	if( fraction == 0 ) {
	    if( sign )
		DbgPrint( "-" );
	    DbgPrint( "infinity" );
	}
	else
	    DbgPrint( "NaN" );
    }
    else if( exponent == 0 ) {
	if( fraction == 0 ) 
	    DbgPrint( "0.0" );
	else {
	    memcpy( &fval, mval, 4 );
	    printNormalFloat( fval );
	}
    }
    else {
	    memcpy( &fval, mval, 4 );
	    printNormalFloat( fval );
	}
}

/*****************************************************************************\
* DbgPrintFloat
*
* Prints floating point numbers from within server, in exponent notation with
* 4 significant digits (e.g 1.7392E-23).  Also prints string preceeding number.
* Checks for deviant cases, such as NaN's or infinity.
* 
\*****************************************************************************/

void DbgPrintFloat( char *comment, float fval ) 
{
    printFloat( comment, &fval, 0 );
}

/*****************************************************************************\
* DbgPrintFloatP
*
* Same as DbgPrintFloat, but takes a pointer to the float to print.  Also
* prints out the hex representation of the float.
* Used in cases where the float may not be a valid float.
* 
\*****************************************************************************/

void DbgPrintFloatP( char *comment, void *mval ) 
{
    printFloat( comment, mval, 1 );
}

#if defined(VERBOSE_DDSLOCK)

//
// Define DDGLOCK if you know the location of the DDraw global lock
// (DDRAW!CheapMutexCrossProcess) and want to see its counts.
//
typedef struct _DDRAW_GLOBAL_LOCK
{
    LONG LockCount;
    LONG RecursionCount;
    DWORD Tid;
    DWORD Pid;
} DDRAW_GLOBAL_LOCK;

// #define DDGLOCK ((DDRAW_GLOBAL_LOCK *)0x76959048)

/******************************Public*Routine******************************\
*
* DDSLOCK
*
* Tracks DirectDraw surface locks
*
* History:
*  Wed May 28 13:42:23 1997	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HRESULT dbgDdsLock(LPDIRECTDRAWSURFACE pdds, DDSURFACEDESC *pddsd,
                   DWORD flags, char *file, int line)
{
    HRESULT hr;
#ifdef DDGLOCK
    volatile DDRAW_GLOBAL_LOCK *glock = DDGLOCK;
#endif

    DbgPrint("%2X:Lock %08lX %4d:%s\n",
             GetCurrentThreadId(), pdds, line, file);
    
#ifdef DDGLOCK
    DbgPrint("   %2d %2d %2X\n", glock->LockCount, glock->RecursionCount,
             glock->Tid);
#endif
    
    hr = pdds->lpVtbl->Lock(pdds, NULL, pddsd, flags, NULL);
    
#ifdef DDGLOCK
    DbgPrint("   %2d %2d %2X\n", glock->LockCount, glock->RecursionCount,
             glock->Tid);
#endif
    
    return hr;
}

/******************************Public*Routine******************************\
*
* DDSUNLOCK
*
* Tracks DirectDrawSurface unlocks
*
* History:
*  Wed May 28 13:42:39 1997	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HRESULT dbgDdsUnlock(LPDIRECTDRAWSURFACE pdds, void *ptr,
                     char *file, int line)
{
    HRESULT hr;
#ifdef DDGLOCK
    volatile DDRAW_GLOBAL_LOCK *glock = DDGLOCK;
    LONG preLock;
#endif

    DbgPrint("%2X:Unlk %08lX %4d:%s\n",
             GetCurrentThreadId(), pdds, line, file);
    
#ifdef DDGLOCK
    DbgPrint("   %2d %2d %2X\n", glock->LockCount, glock->RecursionCount,
             glock->Tid);
    preLock = glock->LockCount;
#endif
    
    hr = pdds->lpVtbl->Unlock(pdds, ptr);
    
#ifdef DDGLOCK
    DbgPrint("   %2d %2d %2X\n", glock->LockCount, glock->RecursionCount,
             glock->Tid);
    if (preLock <= glock->LockCount)
    {
        DebugBreak();
    }
#endif
    
    return hr;
}

#endif // VERBOSE_DDSLOCK

#endif  // DBG

#ifdef _WIN95_
// Provide a DbgPrint implementation on Win95 since the system's doesn't
// do anything.
ULONG DbgPrint(PCH Format, ...)
{
    char achMsg[256];
    va_list vlArgs;

    va_start(vlArgs, Format);
    _vsnprintf(achMsg, sizeof(achMsg), Format, vlArgs);
    va_end(vlArgs);
    OutputDebugString(achMsg);
    return TRUE;
}
#endif // _WIN95_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\ddirx.h ===
/*

Copyright (c) 1994, Microsoft Corporation

Module Name:

    ddirx.h

Abstract:

    Defines and types for Rendering/CAD DDI Extension Interface.

*/

#define DDIRXFUNCS        0x8000

typedef LONG LONGFIX;
typedef HANDLE DDIHANDLE;

/* Rendering-function header */

#define RX_CLIPINFO     0x0001

typedef struct _DDIRXHDR {
    ULONG flags;
    ULONG cCmd;
    DDIHANDLE hDDIrc;
    DDIHANDLE hMem;
    ULONG ulMemOffset;
} DDIRXHDR;

/* Rendering-function header */

typedef struct _DDIRXCMD {
    USHORT idFunc;
    USHORT flags;
    ULONG cData;
    ULONG buffer[1];
} DDIRXCMD;

typedef struct _DDIRXCLIPINFO {
    ULONG flags;
    ULONG idClip;
    ULONG cClip;
    RECT rclClient;
    RECT rclClip[1];    
} DDIRXCLIPINFO;

#define FRONT_BUFFER    0
#define BACK_BUFFER     1

#define RX_FLAT         0
#define RX_SMOOTH       1

#define RX_COLOR_INDEXED    0
#define RX_COLOR_RGBA       1

#define RX_DISABLE          0
#define RX_ENABLE_FASTEST   1
#define RX_ENABLE_NICEST    2

#define RX_LINEPAT          1
#define RX_FILLPAT          2
#define RX_ROP2             3
#define RX_GLCOMPAT         4
#define RX_WRITEBUFFER      5
#define RX_PLANEMASK        6
#define RX_ZMASK            7
#define RX_Z_ENABLE         8
#define RX_ALPHA_ENABLE     9
#define RX_LAST_PIXEL       10
#define RX_TEX_MAG          11
#define RX_TEX_MIN          12
#define RX_SRCBLEND         13
#define RX_DSTBLEND         14
#define RX_TEXBLEND         15
#define RX_COLORMODE        16
#define RX_PIXELMODE        17
#define RX_ZFUNC            18
#define RX_ALPHAREF         19
#define RX_ALPHAFUNC        20
#define RX_DITHER           21
#define RX_BLEND            22
#define RX_FILL             23
#define RX_TEXTURE          24
#define RX_FILLCOLOR        25
#define RX_FILLZ            26
#define RX_SOLIDCOLOR       27
#define RX_TRANSPCOLOR      28
#define RX_TRANSP_ENABLE    29
#define RX_FLOAT_ENABLE     30
#define RX_MASK_START       31
#define RX_AAPOINT_MODE     32
#define RX_AALINE_MODE      33
#define RX_AAPOLY_MODE      34
#define RX_SHADEMODE        35
#define RX_VERTEXTYPE       36
#define RX_SCANTYPE         37


typedef struct _COLORREFA {
    BYTE b;
    BYTE g;
    BYTE r;
    BYTE a;
} COLORREFA;

typedef struct _COLORREFAFIX {
    LONGFIX b;
    LONGFIX g;
    LONGFIX r;
    LONGFIX a;
} COLORREFAFIX;

typedef struct _PTFIX {
    LONGFIX x;
    LONGFIX y;
} PTFIX;

typedef struct _PTFIXZ {
    LONGFIX x;
    LONGFIX y;
    ULONG z;
} PTFIXZ;

typedef struct _PTFIXZTEX {
    LONGFIX x;
    LONGFIX y;
    ULONG z;
    LONGFIX s;
    LONGFIX t;
    FLOAT q;
    FLOAT w;
} PTFIXZTEX;

typedef struct _COLORPTFIXZTEX {
    LONGFIX b;
    LONGFIX g;
    LONGFIX r;
    LONGFIX a;
    LONGFIX x;
    LONGFIX y;
    LONG z;
    LONGFIX s;
    LONGFIX t;
    FLOAT q;
    FLOAT w;
} COLORPTFIXZTEX;

typedef struct _RXLINEPAT {
    USHORT repFactor;
    USHORT linePattern;
} RXLINEPAT;


typedef struct _RXFILLPAT {
    ULONG fillPattern[32];
} RXFILLPAT;

typedef struct _RXBITBLT {
    ULONG pixType;
    DDIHANDLE hSrc;
    DDIHANDLE hDest;
    ULONG xSrc;
    ULONG ySrc;
    ULONG xDest;
    ULONG yDest;
    ULONG width;
    ULONG height;
    ULONG srcWidth;
    ULONG srcHeight;
    ULONG destWidth;
    ULONG destHeight;
} RXBITBLT;

#define RX_COLOR_COMPONENT  1
#define RX_Z_COMPONENT      2

#define RX_FL_FILLCOLOR     0x0001
#define RX_FL_FILLZ         0x0002

// Comparison functions.  Test passes if new pixel value meets the
// specified condition with the current pixel value.

#define RX_CMP_NEVER        0x0001
#define RX_CMP_LESS         0x0002
#define RX_CMP_EQUAL        0x0004
#define RX_CMP_LEQUAL       0x0008
#define RX_CMP_GREATER      0x0010
#define RX_CMP_NOTEQUAL     00x020
#define RX_CMP_GEQUAL       0x0040
#define RX_CMP_ALWAYS       0x0080
#define RX_CMP_ALLGL        0x00ff

// Primitive-drawing capability flags

#define RX_SCANPRIM		0x0001
#define RX_LINEPRIM		0x0002
#define RX_FILLPRIM		0x0004
#define RX_BITBLT		0x0008

// Z-buffer resource flags

#define RX_Z_PER_WINDOW         0x0001
#define RX_Z_PER_SCREEN         0x0002

// Mask capability flags

#define RX_MASK_MSB             0x0001
#define RX_MASK_LSB             0x0002
#define RX_MASK_PLANES          0x0004

// Blending flags

#define RX_BLND_ZERO            0x0001
#define RX_BLND_ONE             0x0002
#define RX_BLND_SRC_COLOR       0x0004
#define RX_BLND_INV_SRC_COLOR   0x0008
#define RX_BLND_SRC_ALPHA       0x0010
#define RX_BLND_INV_SRC_ALPHA   0x0020
#define RX_BLND_DST_ALPHA       0x0040
#define RX_BLND_INV_DST_ALPHA   0x0080
#define RX_BLND_DST_COLOR       0x0100
#define RX_BLND_INV_DST_COLOR   0x0200
#define RX_BLND_SRC_ALPHA_SAT   0x0400
#define RX_BLND_ALLGL           0x07ff

// Texture-mapping flags

#define RX_TEX_NEAREST              0x0001
#define RX_TEX_LINEAR               0x0002
#define RX_TEX_MIP_NEAREST          0x0004
#define RX_TEX_MIP_LINEAR           0x0008
#define RX_TEX_LINEAR_MIP_NEAREST   0x0010
#define RX_TEX_LINEAR_MIP_LINEAR    0x0020
 
// Texture blending flags

#define RX_TEX_DECAL        0x0001
#define RX_TEX_MODULATE     0x0002

// Raster/color capability flags

#define RX_RASTER_DITHER          0x0001
#define RX_RASTER_ROP2            0x0002
#define RX_RASTER_LINEPAT         0x0004
#define RX_RASTER_FILLPAT         0x0008
#define RX_RASTER_TRANSPARENCY    0x0010

typedef struct _RXCAPS {
    ULONG verMajor;
    ULONG verMinor;
    ULONG maskCaps;
    ULONG rasterCaps;
    ULONG drawCaps;
    ULONG aaCaps;
    ULONG cCaps;
    ULONG zCaps;
    ULONG zCmpCaps;
    ULONG srcBlendCaps;
    ULONG dstBlendCaps;
    ULONG alphaCmpCaps;
    ULONG texCaps;        
    ULONG texFilterCaps;        
    ULONG texBlendCaps;        
    ULONG texMaxWidth;        
    ULONG texMaxHeight;        
    ULONG miscCaps;
} RXCAPS;

#define RX_DEV_BITMAP   1
#define RX_MEM_BITMAP   2

typedef struct _RXSURFACEINFO {
    USHORT surfType;
    UCHAR cBytesPerPixel;
    UCHAR rDepth;
    UCHAR gDepth;
    UCHAR bDepth;
    UCHAR aDepth;
    UCHAR rBitShift;
    UCHAR gBitShift;
    UCHAR bBitShift;
    UCHAR aBitShift;
    UCHAR zBytesPerPixel;
    UCHAR zDepth;
    UCHAR zBitShift;
    VOID *pZBits;
    LONG zScanDelta;
} RXSURFACEINFO;

typedef struct _RXSHAREMEM {
    HANDLE hSourceProcess;
    HANDLE hSource;
    DWORD dwOffset;
    DWORD dwSize;
} RXSHAREMEM;


#define RX_SCAN_PIX         0x0001
#define RX_SCAN_COLOR       0x0002
#define RX_SCAN_COLORZ      0x0003
#define RX_SCAN_COLORZTEX   0x0004

#define RX_SCAN_DELTA   0x0001
#define RX_SCAN_MASK    0x0002

typedef struct _RXSCAN {
    USHORT x;
    USHORT y;
    USHORT flags;
    USHORT count;
} RXSCAN;

#define FL_SCAN3D_DELTA     0x0001
#define FL_SCAN3D_PIX       0x0002
#define FL_SCAN3D_MASK      0x0004

typedef struct _RXSCANTEMPLATE {
    RXSCAN rxScan;
    COLORREFAFIX fixColor;
    PTFIXZTEX ptTex;
} RXSCANTEMPLATE;

#define RX_RESOURCE_TEX   1

#define RX_MEMCACHE       1
#define RX_MEMDEV         2
#define RX_MEMANY         3

typedef struct _RXTEXTURE {
    ULONG level;
    ULONG width;
    ULONG height;
    ULONG border;
} RXTEXTURE;

// Primitive types

#define RXPRIM_POINTS       1
#define RXPRIM_LINESTRIP    2
#define RXPRIM_TRISTRIP     3
#define RXPRIM_QUADSTRIP    4

#define RX_PTFIX            1
#define RX_PTFIXZ           2
#define RX_PTFIXZTEX        3

#define RX_INFO_CAPS            1
#define RX_INFO_SURFACE         2

#define DDIRX_GETINFO           1
#define DDIRX_CREATECONTEXT     2
#define DDIRX_DELETERESOURCE    3
#define DDIRX_MAPMEM            4
#define DDIRX_GETSURFACEHANDLE  5
#define DDIRX_SETSTATE          6
#define DDIRX_FILLRECT          7
#define DDIRX_BITBLT            8
#define DDIRX_POLYSCAN          9
#define DDIRX_ALLOCRESOURCE     10
#define DDIRX_LOADTEXTURE       11
#define DDIRX_PRIMSTRIP         12
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genaccel.c ===
/******************************Module*Header*******************************\
* Module Name: genaccel.c                                                  *
*                                                                          *
* This module provides support routines for acceleration functions.        *
*                                                                          *
* Created: 18-Feb-1994                                                     *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "genline.h"

#ifdef GL_WIN_specular_fog
#define DO_NICEST_FOG(gc)\
         ((gc->state.hints.fog == GL_NICEST) && !(gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG))
#else //GL_WIN_specular_fog
#define DO_NICEST_FOG(gc)\
         (gc->state.hints.fog == GL_NICEST) 
#endif //GL_WIN_specular_fog

static ULONG internalSolidTexture[4] = {0xffffffff, 0xffffffff,
                                        0xffffffff, 0xffffffff};

GENTEXCACHE *GetGenTexCache(__GLcontext *gc, __GLtexture *tex)
{
    ULONG size;
    GENTEXCACHE *pGenTex;
    ULONG internalFormat;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    // Replace maps are only used for a subset of possible modes
    //   8 or 16bpp
    //   16-bit Z
    //
    //   No dithering.  Since dithering can turn on and off there
    //   are two cases:
    //     Dither off at TexImage time but on at texturing time -
    //       We create a map that's unused
    //     Dither on and then off - We won't create a map at
    //       TexImage time but it'll be created on the fly when
    //       dithering is turned on and everything is repicked
    //
    // Replace maps aren't created for DirectDraw textures because
    // the data isn't constant
    
    if (GENACCEL(gc).bpp < 8 ||
        GENACCEL(gc).bpp > 16 ||
        ((modeFlags & (__GL_SHADE_DEPTH_TEST | __GL_SHADE_DEPTH_ITER)) &&
         gc->modes.depthBits > 16) ||
        (modeFlags & __GL_SHADE_DITHER) ||
        gc->texture.ddtex.levels > 0)
    {
        return NULL;
    }

    internalFormat = tex->level[0].internalFormat;

    // We only support 8-bit palettes that are fully populated
    if (internalFormat == GL_COLOR_INDEX16_EXT ||
        (internalFormat == GL_COLOR_INDEX8_EXT &&
         tex->paletteSize != 256))
    {
        return NULL;
    }
    
    pGenTex = tex->pvUser;

    // Check and see whether the cached information can be reused
    // for the texture passed in
    if (pGenTex != NULL)
    {
        // gc's don't match so this must be a shared texture
        // Don't attempt to create a replace map for this gc
        if (gc != pGenTex->gc)
        {
            return NULL;
        }

        // Size and format must match to reuse the existing data area
        // If they don't, release the existing buffer.  A new one
        // will then be allocated
        if (internalFormat == GL_COLOR_INDEX8_EXT)
        {
            if (pGenTex->internalFormat != internalFormat ||
                pGenTex->width != tex->paletteTotalSize)
            {
                GCFREE(gc, pGenTex);
                tex->pvUser = NULL;
            }
        }
        else
        {
            if (pGenTex->internalFormat != internalFormat ||
                pGenTex->width != tex->level[0].width ||
                pGenTex->height != tex->level[0].height)
            {
                GCFREE(gc, pGenTex);
                tex->pvUser = NULL;
            }
        }
    }

    if (tex->pvUser == NULL)
    {
        if (internalFormat == GL_COLOR_INDEX8_EXT)
        {
            size = tex->paletteTotalSize * sizeof(DWORD);
        }
        else
        {
            size = tex->level[0].width * tex->level[0].height *
                GENACCEL(gc).xMultiplier;
        }

        pGenTex = (GENTEXCACHE *)GCALLOC(gc, size + sizeof(GENTEXCACHE));

        if (pGenTex != NULL)
        {
            tex->pvUser = pGenTex;
            pGenTex->gc = gc;
            pGenTex->paletteTimeStamp =
                ((__GLGENcontext *)gc)->PaletteTimestamp;
            if (internalFormat == GL_COLOR_INDEX8_EXT)
            {
                pGenTex->height = 0;
                pGenTex->width = tex->paletteTotalSize;
            }
            else
            {
            pGenTex->height = tex->level[0].height;
            pGenTex->width = tex->level[0].width;
            }
            pGenTex->internalFormat = internalFormat;
            pGenTex->texImageReplace = (UCHAR *)(pGenTex+1);
        }
    }

    return pGenTex;
}

BOOL FASTCALL __fastGenLoadTexImage(__GLcontext *gc, __GLtexture *tex)
{
    UCHAR *texBuffer;
    GLint internalFormat = tex->level[0].internalFormat;
    GENTEXCACHE *pGenTex;

    if (tex->level[0].buffer == NULL ||
	((internalFormat != GL_BGR_EXT) &&
         (internalFormat != GL_BGRA_EXT) &&
         (internalFormat != GL_COLOR_INDEX8_EXT)))
    {
        return FALSE;
    }

    // OK, the texture doesn't have a compressed replace-mode format, so
    // make one...

    if ((internalFormat == GL_BGR_EXT) ||
        (internalFormat == GL_BGRA_EXT)) {

        ULONG size;
        UCHAR *replaceBuffer;
        ULONG bytesPerPixel = GENACCEL(gc).xMultiplier;

        pGenTex = GetGenTexCache(gc, tex);
        if (pGenTex == NULL)
        {
            return FALSE;
        }

        texBuffer = (UCHAR *)tex->level[0].buffer;
        replaceBuffer = pGenTex->texImageReplace;

        {
            __GLcolorBuffer *cfb = gc->drawBuffer;
            ULONG rShift = cfb->redShift;
            ULONG gShift = cfb->greenShift;
            ULONG bShift = cfb->blueShift;
            ULONG rBits = ((__GLGENcontext *)gc)->gsurf.pfd.cRedBits;
            ULONG gBits = ((__GLGENcontext *)gc)->gsurf.pfd.cGreenBits;
            ULONG bBits = ((__GLGENcontext *)gc)->gsurf.pfd.cBlueBits;
            BYTE *pXlat = ((__GLGENcontext *)gc)->pajTranslateVector;
            ULONG i;

            size = tex->level[0].width * tex->level[0].height;
            for (i = 0; i < size; i++, texBuffer += 4) {
                ULONG color;

                color = ((((ULONG)texBuffer[2] << rBits) >> 8) << rShift) |
                    ((((ULONG)texBuffer[1] << gBits) >> 8) << gShift) |
                    ((((ULONG)texBuffer[0] << bBits) >> 8) << bShift);

                if (GENACCEL(gc).bpp == 8)
                    *replaceBuffer = pXlat[color & 0xff];
                else
                    *((USHORT *)replaceBuffer) = (USHORT)color;

                replaceBuffer += bytesPerPixel;
            }
        }
    } else {

        ULONG size;
        ULONG *replaceBuffer;

        // If we don't have palette data yet we can't create the
        // fast version.  It will be created when the ColorTable
        // call happens
        if (tex->paletteTotalData == NULL)
        {
            return FALSE;
        }

        pGenTex = GetGenTexCache(gc, tex);
        if (pGenTex == NULL)
        {
            return FALSE;
        }

        texBuffer = (UCHAR *)tex->paletteTotalData;
        replaceBuffer = (ULONG *)pGenTex->texImageReplace;
        size = tex->paletteTotalSize;

        {
            __GLcolorBuffer *cfb = gc->drawBuffer;
            ULONG rShift = cfb->redShift;
            ULONG gShift = cfb->greenShift;
            ULONG bShift = cfb->blueShift;
            ULONG rBits = ((__GLGENcontext *)gc)->gsurf.pfd.cRedBits;
            ULONG gBits = ((__GLGENcontext *)gc)->gsurf.pfd.cGreenBits;
            ULONG bBits = ((__GLGENcontext *)gc)->gsurf.pfd.cBlueBits;
            BYTE *pXlat = ((__GLGENcontext *)gc)->pajTranslateVector;
            ULONG i;

            for (i = 0; i < size; i++, texBuffer += 4) {
                ULONG color;

                color = ((((ULONG)texBuffer[2] << rBits) >> 8) << rShift) |
                    ((((ULONG)texBuffer[1] << gBits) >> 8) << gShift) |
                    ((((ULONG)texBuffer[0] << bBits) >> 8) << bShift);

                if (GENACCEL(gc).bpp == 8)
                    color = pXlat[color & 0xff];

                *replaceBuffer++ = (color | ((ULONG)texBuffer[3] << 24));
            }
        }
    }

    GENACCEL(gc).texImageReplace =
        ((GENTEXCACHE *)tex->pvUser)->texImageReplace;

    return TRUE;
}


/*
** Pick the fastest triangle rendering implementation available based on
** the current mode set.  Use any available accelerated resources if
** available, or use the generic routines for unsupported modes.
*/

void FASTCALL __fastGenCalcDeltas(__GLcontext *gc, __GLvertex *a, __GLvertex *b, __GLvertex *c);
void FASTCALL __fastGenCalcDeltasTexRGBA(__GLcontext *gc, __GLvertex *a, __GLvertex *b, __GLvertex *c);
void FASTCALL __fastGenDrvCalcDeltas(__GLcontext *gc, __GLvertex *a, __GLvertex *b, __GLvertex *c);

void __fastGenSetInitialParameters(__GLcontext *gc, const __GLvertex *a,
                                   __GLfloat dx, __GLfloat dy);
void __fastGenSetInitialParametersTexRGBA(__GLcontext *gc, const __GLvertex *a,
                                          __GLfloat dx, __GLfloat dy);

void __ZippyFT(
    __GLcontext *gc,
    __GLvertex *a,
    __GLvertex *b,
    __GLvertex *c,
    GLboolean ccw);

VOID FASTCALL InitAccelTextureValues(__GLcontext *gc, __GLtexture *tex)
{
    ULONG wLog2;
    ULONG hLog2;

    GENACCEL(gc).tex = tex;
    GENACCEL(gc).texImage = (ULONG *)tex->level[0].buffer;
    if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT ||
        tex->level[0].internalFormat == GL_COLOR_INDEX16_EXT)
    {
        GENACCEL(gc).texPalette = (ULONG *)tex->paletteTotalData;
    }
    else
    {
        GENACCEL(gc).texPalette = NULL;
    }

    wLog2 = tex->level[0].widthLog2;
    hLog2 = tex->level[0].heightLog2;

    GENACCEL(gc).sMask = (~(~0 << wLog2)) << TEX_SCALESHIFT;
    GENACCEL(gc).tMask = (~(~0 << hLog2)) << TEX_SCALESHIFT;
    GENACCEL(gc).tShift = TEX_SCALESHIFT - (wLog2 + TEX_SHIFTPER4BPPTEXEL);
    GENACCEL(gc).tMaskSubDiv =
        (~(~0 << hLog2)) << (wLog2 + TEX_T_FRAC_BITS + TEX_SHIFTPER1BPPTEXEL);
    GENACCEL(gc).tShiftSubDiv =
        TEX_SCALESHIFT - (wLog2 + TEX_T_FRAC_BITS + TEX_SHIFTPER1BPPTEXEL);
    GENACCEL(gc).texXScale = (__GLfloat)tex->level[0].width * TEX_SCALEFACT;
    GENACCEL(gc).texYScale = (__GLfloat)tex->level[0].height * TEX_SCALEFACT;
}

BOOL FASTCALL bUseGenTriangles(__GLcontext *gc)
{
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    GLuint enables = gc->state.enables.general;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    ULONG bpp = GENACCEL(gc).bpp;
    int iType;
    BOOL fZippy;
    BOOL bTryFastTexRGBA;
    PFNZIPPYSUB pfnZippySub;
    BOOL fUseFastGenSpan;
    GLboolean bMcdZ;
    ULONG internalFormat;
    ULONG textureMode;
    BOOL bRealTexture;
    BOOL bAccelDecal;

    if ((enables & (__GL_ALPHA_TEST_ENABLE |
                    __GL_STENCIL_TEST_ENABLE)) ||
        (modeFlags & (__GL_SHADE_STENCIL_TEST | __GL_SHADE_LOGICOP |
                      __GL_SHADE_ALPHA_TEST | __GL_SHADE_SLOW_FOG
#ifdef GL_WIN_specular_fog
                      | __GL_SHADE_SPEC_FOG
#endif //GL_WIN_specular_fog
                      )) ||
        !gc->state.raster.rMask ||
        !gc->state.raster.gMask ||
        !gc->state.raster.bMask ||
        (gc->drawBuffer->buf.flags & COLORMASK_ON) ||
        ALPHA_WRITE_ENABLED( gc->drawBuffer ) ||
        (gengc->gsurf.pfd.cColorBits < 8) ||
        ((modeFlags & __GL_SHADE_DEPTH_TEST) && (!gc->state.depth.writeEnable))
       )
        return FALSE;

    if (modeFlags & __GL_SHADE_TEXTURE) {
        internalFormat = gc->texture.currentTexture->level[0].internalFormat;
        textureMode = gc->state.texture.env[0].mode;
        bAccelDecal = (gc->texture.currentTexture->level[0].baseFormat !=
                       GL_RGBA);
        
        if (!((((textureMode == GL_DECAL) && bAccelDecal) ||
               (textureMode == GL_REPLACE) ||
               (textureMode == GL_MODULATE)) &&
              (gc->texture.currentTexture &&
               (gc->texture.currentTexture->params.minFilter == GL_NEAREST) &&
               (gc->texture.currentTexture->params.magFilter == GL_NEAREST) &&
               (gc->texture.currentTexture->params.sWrapMode == GL_REPEAT) &&
               (gc->texture.currentTexture->params.tWrapMode == GL_REPEAT) &&
               (gc->texture.currentTexture->level[0].border == 0) &&
               (internalFormat == GL_BGR_EXT ||
                internalFormat == GL_BGRA_EXT ||
                internalFormat == GL_COLOR_INDEX8_EXT))))
            return FALSE;

        InitAccelTextureValues(gc, gc->texture.currentTexture);
    }

    bMcdZ = ((((__GLGENcontext *)gc)->pMcdState != NULL) &&
             (((__GLGENcontext *)gc)->pMcdState->pDepthSpan != NULL) &&
             (((__GLGENcontext *)gc)->pMcdState->pMcdSurf != NULL) &&
             !(((__GLGENcontext *)gc)->pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED));

    bTryFastTexRGBA = ((gc->state.raster.drawBuffer != GL_FRONT_AND_BACK) &&
                       ((modeFlags & __GL_SHADE_DEPTH_TEST &&
                         modeFlags & __GL_SHADE_DEPTH_ITER)
                    || (!(modeFlags & __GL_SHADE_DEPTH_TEST) &&
                        !(modeFlags & __GL_SHADE_DEPTH_ITER))) &&
                       (modeFlags & __GL_SHADE_STIPPLE) == 0);

    fZippy = (bTryFastTexRGBA &&
              ((gc->drawBuffer->buf.flags & DIB_FORMAT) != 0) &&
              ((gc->drawBuffer->buf.flags & MEMORY_DC) != 0) &&
              gc->transform.reasonableViewport);

    GENACCEL(gc).flags &= ~(
            GEN_DITHER | GEN_RGBMODE | GEN_TEXTURE | GEN_SHADE |
            GEN_FASTZBUFFER | GEN_LESS | SURFACE_TYPE_DIB | GEN_TEXTURE_ORTHO
        );

    if ((enables & __GL_BLEND_ENABLE) ||
        (modeFlags & __GL_SHADE_TEXTURE)) {
        GENACCEL(gc).__fastCalcDeltaPtr = __fastGenCalcDeltasTexRGBA;
        GENACCEL(gc).__fastSetInitParamPtr = __fastGenSetInitialParametersTexRGBA;
    } else {
        GENACCEL(gc).__fastCalcDeltaPtr = __fastGenCalcDeltas;
        GENACCEL(gc).__fastSetInitParamPtr = __fastGenSetInitialParameters;
    }

#ifdef GL_WIN_phong_shading      
    if (modeFlags & __GL_SHADE_PHONG)
    {
        gc->procs.fillTriangle = __glFillPhongTriangle;
    }
    else
#endif //GL_WIN_phong_shading      
    {
#ifdef _MCD_
        // If MCD driver is being used, then we need to call the "floating
        // point state safe" version of fillTriangle.  This version will
        // not attempt to span floating point operations over a call that
        // may invoke the MCD driver (which will corrupt the FP state).

        if (gengc->pMcdState)
        {
            gc->procs.fillTriangle = __fastGenMcdFillTriangle;
        }
        else
        {
            gc->procs.fillTriangle = __fastGenFillTriangle;
        }
#else //_MCD_
        gc->procs.fillTriangle = __fastGenFillTriangle;
#endif //_MCD_
    }
    
    // If we're doing perspective-corrected texturing, we will support
    // the following combinations:
    //  z....... <, <=
    //  alpha... src, 1-src
    //  dither.. on/off
    //  bpp..... 332, 555, 565, 888

    // NOTE:  We will always try this path first for general texturing.

    if ((modeFlags & __GL_SHADE_TEXTURE) || (enables & __GL_BLEND_ENABLE)) {
        LONG pixType = -1;

        if (gc->state.hints.perspectiveCorrection != GL_NICEST)
            GENACCEL(gc).flags |= GEN_TEXTURE_ORTHO;

        if (!bTryFastTexRGBA)
            goto perspTexPathFail;

        if ((enables & __GL_BLEND_ENABLE) &&
            ((gc->state.raster.blendSrc != GL_SRC_ALPHA) ||
             (gc->state.raster.blendDst != GL_ONE_MINUS_SRC_ALPHA)))
            return FALSE;

        if (!(modeFlags & __GL_SHADE_TEXTURE)) {

            if (!(modeFlags & __GL_SHADE_RGB))
                goto perspTexPathFail;

            bRealTexture = FALSE;
            
            GENACCEL(gc).flags |= GEN_TEXTURE_ORTHO;
            GENACCEL(gc).texPalette = NULL;
            textureMode = GL_MODULATE;
            internalFormat = GL_BGRA_EXT;
            GENACCEL(gc).texImage =  (ULONG *)internalSolidTexture;
            GENACCEL(gc).sMask = 0;
            GENACCEL(gc).tMask = 0;
            GENACCEL(gc).tShift = 0;
            GENACCEL(gc).tMaskSubDiv = 0;
            GENACCEL(gc).tShiftSubDiv = 0;
        }
        else
        {
            bRealTexture = TRUE;
        }

        if (bpp == 8) {
            if ((gengc->gc.drawBuffer->redShift   == 0) &&
                (gengc->gc.drawBuffer->greenShift == 3) &&
                (gengc->gc.drawBuffer->blueShift  == 6))
                pixType = 0;
        } else if (bpp == 16) {
            if ((gengc->gc.drawBuffer->greenShift == 5) &&
                (gengc->gc.drawBuffer->blueShift  == 0)) {

                if (gengc->gc.drawBuffer->redShift == 10)
                    pixType = 1;
                else if (gengc->gc.drawBuffer->redShift == 11)
                    pixType = 2;
            }
        } else if ((bpp == 32) || (bpp == 24)) {
            if ((gengc->gc.drawBuffer->redShift == 16) &&
                (gengc->gc.drawBuffer->greenShift == 8) &&
                (gengc->gc.drawBuffer->blueShift  == 0))
                pixType = 3;
        }

        if (pixType < 0)
            goto perspTexPathFail;

        pixType *= 6;

        if (modeFlags & __GL_SHADE_DEPTH_ITER) {

            if (bMcdZ)
                goto perspTexPathFail;

            if (!((gc->state.depth.testFunc == GL_LESS) ||
                 (gc->state.depth.testFunc == GL_LEQUAL)))
                goto perspTexPathFail;

            if (gc->modes.depthBits > 16)
                goto perspTexPathFail;

            if (gc->state.depth.testFunc == GL_LEQUAL)
                pixType += 1;
            else
                pixType += 2;

            GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTZ;
        }

        if (enables & __GL_BLEND_ENABLE)
            pixType += 3;

        // Note:  For selecting the sub-triangle filling routine, assume
        // that we will use one of the "zippy" routines.  Then, check at the
        // end whether or not we can actually do this, or if we have to fall
        // back to a more generic (and slower) routine.

        if (internalFormat != GL_COLOR_INDEX8_EXT &&
            internalFormat != GL_COLOR_INDEX16_EXT) {

            //
            // Handle full RGB(A) textures
            //

            // Check if we can support the size...

            if (bRealTexture &&
                GENACCEL(gc).tex &&
                ((GENACCEL(gc).tex->level[0].widthLog2 > TEX_MAX_SIZE_LOG2) ||
                 (GENACCEL(gc).tex->level[0].heightLog2 > TEX_MAX_SIZE_LOG2)))
                goto perspTexPathFail;

            if ((textureMode == GL_DECAL) ||
                (textureMode == GL_REPLACE)) {

                // we don't handle the goofy alpha case for decal...

                if ((textureMode == GL_DECAL) &&
                    (enables & __GL_BLEND_ENABLE))
                    return FALSE;

                // If we're not dithering, we can go with the compressed
                // texture format.  Otherwise, we're forced to use flat-shading
                // procs to get the texture colors to dither properly.  Ouch...

                // We'd like to also go through this path if a DirectDraw
                // texture is used because replace maps can't be created,
                // but they only work with dithering
                if (modeFlags & __GL_SHADE_DITHER) {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexFlatFuncs[pixType];
                } else {
                    if ((bpp >= 8 && bpp <= 16) &&
                        !(enables & __GL_BLEND_ENABLE)) {

                        // handle the case where we can use compressed textures
                        // for optimal performance.  We do this for bit depths
                        // <= 16 bits, no dithering, and no blending.

                        if (!GENACCEL(gc).tex->pvUser) {
                            if (!__fastGenLoadTexImage(gc, GENACCEL(gc).tex))
                                return FALSE;
                        } else {

                            // If the compressed texture image was created for
                            // another gc, revert to using the RGBA image.
                            // We do this by using the alpha paths.
                            //
                            // NOTE:  This logic depends on A being forced to
                            // 1 for all RGB textures.

                            if (gc != ((GENTEXCACHE *)GENACCEL(gc).tex->pvUser)->gc)
                            {
                                pixType += 3;
                            }
                            else
                            {
                                // Check that the cached data is the right size
                                ASSERTOPENGL(((GENTEXCACHE *)GENACCEL(gc).tex->pvUser)->width == GENACCEL(gc).tex->level[0].width &&
                                             ((GENTEXCACHE *)GENACCEL(gc).tex->pvUser)->height == GENACCEL(gc).tex->level[0].height,
                                             "Cached texture size mismatch\n");
                            }
                        }
                    }

                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexReplaceFuncs[pixType];
                }

                if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                    GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTTex;

            } else if (textureMode == GL_MODULATE) {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexSmoothFuncs[pixType];
                    if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                        GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTRGBTex;
                } else {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexFlatFuncs[pixType];
                    if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                        GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTTex;
                }
            }
        } else {
            //
            // Handle palettized textures
            //

            // Check if we can support the size...

            if (bRealTexture &&
                GENACCEL(gc).tex &&
                ((GENACCEL(gc).tex->level[0].widthLog2 > TEX_MAX_SIZE_LOG2) ||
                 (GENACCEL(gc).tex->level[0].heightLog2 > TEX_MAX_SIZE_LOG2)))
                return FALSE;

            if ((textureMode == GL_DECAL) ||
                (textureMode == GL_REPLACE)) {

                // we don't handle the goofy alpha case for decal...

                if ((textureMode == GL_DECAL) &&
                    (enables & __GL_BLEND_ENABLE))
                    return FALSE;

                // If we're not dithering, we can go with the compressed
                // texture format.  Otherwise, we're forced to use flat-shading
                // procs to get the texture colors to dither properly.  Ouch...

                // We'd like to also go through this path if a DirectDraw
                // texture is used because replace maps can't be created,
                // but they only work with dithering
                if (modeFlags & __GL_SHADE_DITHER) {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexFlatFuncs[pixType];
                } else {

                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexPalReplaceFuncs[pixType];

                    if (bpp >= 8 && bpp <= 16) {
                        // handle the case where we can use compressed paletted
                        // textures for optimal performance.  We do this for
                        // bit depths <= 16 bits with no dithering.

                        if (!GENACCEL(gc).tex->pvUser) {
                            if (!__fastGenLoadTexImage(gc, GENACCEL(gc).tex))
                                return FALSE;
                        } else {

        // If the compressed texture image was created for
        // another gc, we have no choice but to fall back to flat shading.
        // We should find a better solution for this...
                            if (gc != ((GENTEXCACHE *)GENACCEL(gc).tex->pvUser)->gc)
                            {
                                GENACCEL(gc).__fastTexSpanFuncPtr =
                                    __fastPerspTexFlatFuncs[pixType];
                            }
                            else
                            {
                                ASSERTOPENGL(((GENTEXCACHE *)GENACCEL(gc).tex->pvUser)->width == GENACCEL(gc).tex->paletteTotalSize,
                                             "Cached texture size mismatch\n");
                            }
                        }
                    }
                }

                if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                    GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTTex;

            } else if (textureMode == GL_MODULATE) {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexSmoothFuncs[pixType];
                    if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                        GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTRGBTex;
                } else {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexFlatFuncs[pixType];
                    if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                        GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTTex;
                }
            }
        }

        if (!fZippy)
            GENACCEL(gc).__fastFillSubTrianglePtr = __fastGenFillSubTriangleTexRGBA;
        else
            GENACCEL(gc).flags |= SURFACE_TYPE_DIB;

        return TRUE;

    }

perspTexPathFail:

    // We don't support any alpha modes yet...

    if (enables & __GL_BLEND_ENABLE)
        return FALSE;

    fUseFastGenSpan = FALSE;

    if (bpp == 8) {
        iType = 2;
        if (
               (gengc->gc.drawBuffer->redShift   != 0)
            || (gengc->gc.drawBuffer->greenShift != 3)
            || (gengc->gc.drawBuffer->blueShift  != 6)
           ) {
            fUseFastGenSpan = TRUE;
        }
    } else if (bpp == 16) {
        if (
               (gengc->gc.drawBuffer->greenShift == 5)
            && (gengc->gc.drawBuffer->blueShift  == 0)
           ) {
            if (gengc->gc.drawBuffer->redShift == 10) {
                iType = 3;
            } else if (gengc->gc.drawBuffer->redShift == 11) {
                iType = 4;
            } else {
                iType = 3;
                fUseFastGenSpan = TRUE;
            }
        } else {
            iType = 3;
            fUseFastGenSpan = TRUE;
        }
    } else {
        if (bpp == 24) {
            iType = 0;
        } else {
            iType = 1;
        }
        if (
               (gengc->gc.drawBuffer->redShift   != 16)
            || (gengc->gc.drawBuffer->greenShift != 8)
            || (gengc->gc.drawBuffer->blueShift  != 0)
           ) {
            fUseFastGenSpan = TRUE;
        }
    }

    if (modeFlags & __GL_SHADE_DITHER) {
        if (   (bpp == 8)
            || (bpp == 16)
            || ((modeFlags & __GL_SHADE_DEPTH_ITER) == 0)
           ) {
            GENACCEL(gc).flags |= GEN_DITHER;
        }
        iType += 5;
    }

    // Use the accelerated span functions (with no inline z-buffering) if
    // we support the z-buffer function AND we're not using hardware
    // z-buffering:

    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
        if (bMcdZ) {
            fUseFastGenSpan = TRUE;
        } else if (!fZippy) {
            fUseFastGenSpan = TRUE;
        } else if (gc->state.depth.testFunc == GL_LESS) {
            GENACCEL(gc).flags |= GEN_LESS;
        } else if (gc->state.depth.testFunc != GL_LEQUAL) {
            fUseFastGenSpan = TRUE;
        }
        iType += 10;
    }

    if (modeFlags & __GL_SHADE_RGB) {
        GENACCEL(gc).flags |= GEN_RGBMODE;
        pfnZippySub = __ZippyFSTRGB;

        if (modeFlags & __GL_SHADE_TEXTURE) {
            GENACCEL(gc).flags |= (GEN_TEXTURE | GEN_TEXTURE_ORTHO);

            if (gc->state.hints.perspectiveCorrection == GL_NICEST)
                return FALSE;

            if (internalFormat == GL_COLOR_INDEX8_EXT ||
                internalFormat == GL_COLOR_INDEX16_EXT)
                return FALSE;

            if (textureMode == GL_DECAL) {
                if (modeFlags & __GL_SHADE_DITHER)
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastGenTexFuncs[iType];
                else
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastGenTexDecalFuncs[iType];

                pfnZippySub = __ZippyFSTTex;
            } else {
                GENACCEL(gc).flags |= GEN_SHADE;
                pfnZippySub = __ZippyFSTRGBTex;
                GENACCEL(gc).__fastTexSpanFuncPtr =
                    __fastGenTexFuncs[iType];
            }

            if (GENACCEL(gc).__fastTexSpanFuncPtr == __fastGenSpan) {
                fUseFastGenSpan = TRUE;
            }
        } else {
            GENACCEL(gc).__fastSmoothSpanFuncPtr = __fastGenRGBFuncs[iType];
            GENACCEL(gc).__fastFlatSpanFuncPtr   = __fastGenRGBFlatFuncs[iType];

            if (GENACCEL(gc).__fastSmoothSpanFuncPtr == __fastGenSpan) {
                fUseFastGenSpan = TRUE;
            }
        }
    } else {
        pfnZippySub = __ZippyFSTCI;
        GENACCEL(gc).__fastSmoothSpanFuncPtr = __fastGenCIFuncs[iType];
        GENACCEL(gc).__fastFlatSpanFuncPtr = __fastGenCIFlatFuncs[iType];
    }

    if (modeFlags & __GL_SHADE_STIPPLE)
    {
        fUseFastGenSpan = TRUE;
    }
    
    if (fUseFastGenSpan) {
        GENACCEL(gc).__fastTexSpanFuncPtr          = __fastGenSpan;
        GENACCEL(gc).__fastSmoothSpanFuncPtr       = __fastGenSpan;
        GENACCEL(gc).__fastFlatSpanFuncPtr         = __fastGenSpan;
        GENACCEL(gc).__fastFillSubTrianglePtr      = __fastGenFillSubTriangle;
    } else {
        if (fZippy) {
            GENACCEL(gc).flags |= SURFACE_TYPE_DIB;

            if (   (iType == 2)
                && (
                    (modeFlags
                     & (__GL_SHADE_RGB | __GL_SHADE_SMOOTH)
                    ) == 0
                   )
               ) {
                GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTCI8Flat;
            } else if (iType >= 10) {
                GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTZ;
                GENACCEL(gc).flags |= GEN_FASTZBUFFER;
            } else {
                GENACCEL(gc).flags &= ~(HAVE_STIPPLE);
                GENACCEL(gc).__fastFillSubTrianglePtr = pfnZippySub;
            }
        } else {
            GENACCEL(gc).__fastFillSubTrianglePtr = __fastGenFillSubTriangle;
        }
    }

    return TRUE;
}

void FASTCALL __fastGenPickTriangleProcs(__GLcontext *gc)
{
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLGENcontext *genGc = (__GLGENcontext *)gc;

    CASTINT(gc->polygon.shader.rLittle) = 0;
    CASTINT(gc->polygon.shader.rBig) =    0;
    CASTINT(gc->polygon.shader.gLittle) = 0;
    CASTINT(gc->polygon.shader.gBig) =    0;
    CASTINT(gc->polygon.shader.bLittle) = 0;
    CASTINT(gc->polygon.shader.bBig) =    0;
    CASTINT(gc->polygon.shader.sLittle) = 0;
    CASTINT(gc->polygon.shader.sBig) =    0;
    CASTINT(gc->polygon.shader.tLittle) = 0;
    CASTINT(gc->polygon.shader.tBig) =    0;

    GENACCEL(gc).spanDelta.r = 0;
    GENACCEL(gc).spanDelta.g = 0;
    GENACCEL(gc).spanDelta.b = 0;
    GENACCEL(gc).spanDelta.a = 0;

    /*
    ** Setup cullFace so that a single test will do the cull check.
    */
    if (modeFlags & __GL_SHADE_CULL_FACE) {
        switch (gc->state.polygon.cull) {
          case GL_FRONT:
            gc->polygon.cullFace = __GL_CULL_FLAG_FRONT;
            break;
          case GL_BACK:
            gc->polygon.cullFace = __GL_CULL_FLAG_BACK;
            break;
          case GL_FRONT_AND_BACK:
            gc->procs.renderTriangle = __glDontRenderTriangle;
            gc->procs.fillTriangle = 0;         /* Done to find bugs */
            return;
        }
    } else {
        gc->polygon.cullFace = __GL_CULL_FLAG_DONT;
    }

    /* Build lookup table for face direction */
    switch (gc->state.polygon.frontFaceDirection) {
      case GL_CW:
        if (gc->constants.yInverted) {
            gc->polygon.face[__GL_CW] = __GL_BACKFACE;
            gc->polygon.face[__GL_CCW] = __GL_FRONTFACE;
        } else {
            gc->polygon.face[__GL_CW] = __GL_FRONTFACE;
            gc->polygon.face[__GL_CCW] = __GL_BACKFACE;
        }
        break;
      case GL_CCW:
        if (gc->constants.yInverted) {
            gc->polygon.face[__GL_CW] = __GL_FRONTFACE;
            gc->polygon.face[__GL_CCW] = __GL_BACKFACE;
        } else {
            gc->polygon.face[__GL_CW] = __GL_BACKFACE;
            gc->polygon.face[__GL_CCW] = __GL_FRONTFACE;
        }
        break;
    }

    /* Make polygon mode indexable and zero based */
    gc->polygon.mode[__GL_FRONTFACE] =
        (GLubyte) (gc->state.polygon.frontMode & 0xf);
    gc->polygon.mode[__GL_BACKFACE] =
        (GLubyte) (gc->state.polygon.backMode & 0xf);

    if (gc->renderMode == GL_FEEDBACK) {
        gc->procs.renderTriangle = __glFeedbackTriangle;
        gc->procs.fillTriangle = 0;             /* Done to find bugs */
        return;
    }
    if (gc->renderMode == GL_SELECT) {
        gc->procs.renderTriangle = __glSelectTriangle;
        gc->procs.fillTriangle = 0;             /* Done to find bugs */
        return;
    }

    if ((gc->state.polygon.frontMode == gc->state.polygon.backMode) &&
        (gc->state.polygon.frontMode == GL_FILL)) {
      if (modeFlags & __GL_SHADE_SMOOTH_LIGHT) {
          gc->procs.renderTriangle = __glRenderSmoothTriangle;
#ifdef GL_WIN_phong_shading
      } else if (modeFlags & __GL_SHADE_PHONG) {
          gc->procs.renderTriangle = __glRenderPhongTriangle;
#endif //GL_WIN_phong_shading
      } else {
          gc->procs.renderTriangle = __glRenderFlatTriangle;
      }
    } else {
        gc->procs.renderTriangle = __glRenderTriangle;
    }

    if (gc->state.enables.general & __GL_POLYGON_SMOOTH_ENABLE) {
#ifdef GL_WIN_phong_shading
        if (modeFlags & __GL_SHADE_PHONG)
            gc->procs.fillTriangle = __glFillAntiAliasedPhongTriangle;
        else
#endif //GL_WIN_phong_shading
            gc->procs.fillTriangle = __glFillAntiAliasedTriangle;
    } else {
        if ((gc->state.raster.drawBuffer == GL_NONE) ||
            !bUseGenTriangles(gc))
#ifdef GL_WIN_phong_shading
            if (modeFlags & __GL_SHADE_PHONG)
                gc->procs.fillTriangle = __glFillPhongTriangle;
            else
#endif //GL_WIN_phong_shading
                gc->procs.fillTriangle = __glFillTriangle;
    }

    if ((modeFlags & __GL_SHADE_CHEAP_FOG) && 
        !(modeFlags & __GL_SHADE_SMOOTH_LIGHT)) {
        gc->procs.fillTriangle2 = gc->procs.fillTriangle;
        gc->procs.fillTriangle = __glFillFlatFogTriangle;
    }
#ifdef GL_WIN_specular_fog
    /*
    ** The case where 1) Specular fog is enabled AND 2) flat-shaded
    */
    if ((modeFlags & (__GL_SHADE_SPEC_FOG | 
                      __GL_SHADE_SMOOTH_LIGHT |
                      __GL_SHADE_PHONG)) == __GL_SHADE_SPEC_FOG)
    {
        gc->procs.fillTriangle2 = gc->procs.fillTriangle;
        gc->procs.fillTriangle = __glFillFlatSpecFogTriangle;
    }
#endif //GL_WIN_specular_fog
}


void FASTCALL __fastGenPickSpanProcs(__GLcontext *gc)
{
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    GLuint enables = gc->state.enables.general;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    __GLspanFunc *sp;
    __GLstippledSpanFunc *ssp;
    int spanCount;
    GLboolean replicateSpan;
    GLboolean bMcdZ = ((((__GLGENcontext *)gc)->pMcdState != NULL) &&
                       (((__GLGENcontext *)gc)->pMcdState->pDepthSpan != NULL) &&
                       (((__GLGENcontext *)gc)->pMcdState->pMcdSurf != NULL) &&
                       !(((__GLGENcontext *)gc)->pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED));

    // Always reset the color scale values at the beginning of the pick
    // procs.  Lines, triangles, and spans may all use these values...

    GENACCEL(gc).rAccelScale = (GLfloat)ACCEL_FIX_SCALE;
    GENACCEL(gc).gAccelScale = (GLfloat)ACCEL_FIX_SCALE;
    GENACCEL(gc).bAccelScale = (GLfloat)ACCEL_FIX_SCALE;

    // Note:  we need to scale between 0 and 255 to get proper alpha
    // blending.  The software-accelerated blending code assumes this
    // scaling for simplicity...

    GENACCEL(gc).aAccelScale = (GLfloat)(ACCEL_FIX_SCALE) *
                               (GLfloat)255.0 / gc->drawBuffer->alphaScale;

    replicateSpan = GL_FALSE;
    sp = gc->procs.span.spanFuncs;
    ssp = gc->procs.span.stippledSpanFuncs;

    /* Load phase one procs */
    if (!gc->transform.reasonableViewport) {
        *sp++ = __glClipSpan;
        *ssp++ = NULL;
    }

    if (modeFlags & __GL_SHADE_STIPPLE) {
        *sp++ = __glStippleSpan;
        *ssp++ = __glStippleStippledSpan;

        if (modeFlags & __GL_SHADE_DEPTH_TEST)
        {
            if (bMcdZ)
            {
                GENACCEL(gc).__fastStippleDepthTestSpan =
                    GenMcdStippleAnyDepthTestSpan;
            }
            else
            {
                if (gc->state.depth.testFunc == GL_LESS)
                {
                    if (gc->modes.depthBits == 32)
                    {
                        GENACCEL(gc).__fastStippleDepthTestSpan =
                            __fastGenStippleLt32Span;
                    }
                    else
                    {
                        GENACCEL(gc).__fastStippleDepthTestSpan =
                            __fastGenStippleLt16Span;
                    }
                }
                else
                {
                    GENACCEL(gc).__fastStippleDepthTestSpan =
                        __fastGenStippleAnyDepthTestSpan;
                }
            }
        }
        else
        {
            GENACCEL(gc).__fastStippleDepthTestSpan = __glStippleSpan;
        }
    }

    /* Load phase three procs */
    if (modeFlags & __GL_SHADE_RGB) {
        if (modeFlags & __GL_SHADE_SMOOTH) {
            *sp = __glShadeRGBASpan;
            *ssp = __glShadeRGBASpan;
#ifdef GL_WIN_phong_shading
        } else if (modeFlags & __GL_SHADE_PHONG) {
            *sp = __glPhongRGBASpan;
            *ssp = __glPhongRGBASpan;
        
#endif //GL_WIN_phong_shading
        } else {
            *sp = __glFlatRGBASpan;
            *ssp = __glFlatRGBASpan;
        }
    } else {
        if (modeFlags & __GL_SHADE_SMOOTH) {
            *sp = __glShadeCISpan;
            *ssp = __glShadeCISpan;
#ifdef GL_WIN_phong_shading
        } else if (modeFlags & __GL_SHADE_PHONG) {
            *sp = __glPhongCISpan;
            *ssp = __glPhongCISpan;
#endif //GL_WIN_phong_shading
        } else {
            *sp = __glFlatCISpan;
            *ssp = __glFlatCISpan;
        }
    }
    sp++;
    ssp++;

    if (modeFlags & __GL_SHADE_TEXTURE) {
        *sp++ = __glTextureSpan;
        *ssp++ = __glTextureStippledSpan;
    }

#ifdef GL_WIN_specular_fog
    if (modeFlags & (__GL_SHADE_SLOW_FOG | __GL_SHADE_SPEC_FOG))
#else //GL_WIN_specular_fog
    if (modeFlags & __GL_SHADE_SLOW_FOG)
#endif //GL_WIN_specular_fog
    {
        if (DO_NICEST_FOG (gc)) {
            *sp = __glFogSpanSlow;
            *ssp = __glFogStippledSpanSlow;
        } else {
            *sp = __glFogSpan;
            *ssp = __glFogStippledSpan;
        }
        sp++;
        ssp++;
    }

    if (modeFlags & __GL_SHADE_ALPHA_TEST) {
        *sp++ = __glAlphaTestSpan;
        *ssp++ = __glAlphaTestStippledSpan;
    }

    /* Load phase two procs */
    if (modeFlags & __GL_SHADE_STENCIL_TEST) {
        *sp++ = __glStencilTestSpan;
        *ssp++ = __glStencilTestStippledSpan;
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {
            if (bMcdZ) {
                *sp = GenMcdDepthTestStencilSpan;
                *ssp = GenMcdDepthTestStencilStippledSpan;
            } else {
                *sp = __glDepthTestStencilSpan;
                *ssp = __glDepthTestStencilStippledSpan;
            }
        } else {
            *sp = __glDepthPassSpan;
            *ssp = __glDepthPassStippledSpan;
        }
        sp++;
        ssp++;
    } else {
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {
            if (bMcdZ) {
                *sp++  =  GenMcdDepthTestSpan;
                *ssp++ = GenMcdDepthTestStippledSpan;
                if (gc->state.depth.writeEnable)
                    ((__GLGENcontext *)gc)->pMcdState->softZSpanFuncPtr =
                        __fastDepthFuncs[gc->state.depth.testFunc & 0x7];
                else
                    ((__GLGENcontext *)gc)->pMcdState->softZSpanFuncPtr =
                        (__GLspanFunc)NULL;

                GENACCEL(gc).__fastZSpanFuncPtr = GenMcdDepthTestSpan;
            } else {
                if (gc->state.depth.writeEnable) {
                    if( gc->modes.depthBits == 32 ) {
                        *sp++ = GENACCEL(gc).__fastZSpanFuncPtr =
                            __fastDepthFuncs[gc->state.depth.testFunc & 0x7];
                    } else {
                        *sp++ = GENACCEL(gc).__fastZSpanFuncPtr =
                            __fastDepth16Funcs[gc->state.depth.testFunc & 0x7];
                    }
                } else {
                    *sp++ = GENACCEL(gc).__fastZSpanFuncPtr =
                        __glDepthTestSpan;
                }

                *ssp++ = __glDepthTestStippledSpan;
            }
        }
    }

    if (gc->state.raster.drawBuffer == GL_FRONT_AND_BACK) {
        spanCount = (int)((ULONG_PTR)(sp - gc->procs.span.spanFuncs));
        gc->procs.span.n = spanCount;
        replicateSpan = GL_TRUE;
    }

    /* Span routines deal with masking, dithering, logicop, blending */
    *sp++ = cfb->storeSpan;
    *ssp++ = cfb->storeStippledSpan;

    spanCount = (int)((ULONG_PTR)(sp - gc->procs.span.spanFuncs));
    gc->procs.span.m = spanCount;
    if (replicateSpan) {
        gc->procs.span.processSpan = __glProcessReplicateSpan;
    } else {
        gc->procs.span.processSpan = __glProcessSpan;
        gc->procs.span.n = spanCount;
    }
}

// These are the bits in modeFlags that affect lines

#ifdef GL_WIN_specular_fog
#define __FAST_LINE_SPEC_FOG __GL_SHADE_SPEC_FOG
#else
#define __FAST_LINE_SPEC_FOG 0
#endif //GL_WIN_specular_fog

#ifdef GL_WIN_phong_shading
#define __FAST_LINE_PHONG __GL_SHADE_PHONG
#else
#define __FAST_LINE_PHONG 0
#endif //GL_WIN_phong_shading

#define __FAST_LINE_MODE_FLAGS \
    (__GL_SHADE_DEPTH_TEST | __GL_SHADE_SMOOTH | __GL_SHADE_TEXTURE | \
     __GL_SHADE_LINE_STIPPLE | __GL_SHADE_STENCIL_TEST | __GL_SHADE_LOGICOP | \
     __GL_SHADE_BLEND | __GL_SHADE_ALPHA_TEST | __GL_SHADE_MASK | \
     __GL_SHADE_SLOW_FOG | __GL_SHADE_CHEAP_FOG | __FAST_LINE_SPEC_FOG | \
     __FAST_LINE_PHONG)

/******************************Public*Routine******************************\
* __fastGenPickLineProcs
*
* Picks the line-rendering procedures.  Most of this function was copied from
* the soft code.  Some differences include:
*   1. The beginPrim function pointers are hooked by the accelerated code
*   2. If the attribute state is such that acceleration can be used,
*      __fastGenLineSetup is called to initialize the state machine.
*
* History:
*  22-Mar-1994 -by- Eddie Robinson [v-eddier]
* Wrote it.
\**************************************************************************/


void FASTCALL __fastGenPickLineProcs(__GLcontext *gc)
{
    __GLGENcontext *genGc = (__GLGENcontext *) gc;
    GENACCEL *genAccel;
    GLuint enables = gc->state.enables.general;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLspanFunc *sp;
    __GLstippledSpanFunc *ssp;
    int spanCount;
    GLboolean wideLine;
    GLboolean replicateLine;
    GLuint aaline;
    GLboolean bMcdZ = ((genGc->pMcdState != NULL) &&
                       (genGc->pMcdState->pDepthSpan != NULL) &&
                       (genGc->pMcdState->pMcdSurf != NULL) &&
                       !(genGc->pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED));

    /*
    ** The fast line code replaces the line function pointers, so reset them
    ** to a good state
    */
    gc->procs.lineBegin  = __glNopLineBegin;
    gc->procs.lineEnd    = __glNopLineEnd;

    if (gc->renderMode == GL_FEEDBACK) {
        gc->procs.renderLine = __glFeedbackLine;
    } else if (gc->renderMode == GL_SELECT) {
        gc->procs.renderLine = __glSelectLine;
    } else {
        if (genAccel = (GENACCEL *) genGc->pPrivateArea) {
            if (!(modeFlags & __FAST_LINE_MODE_FLAGS & ~genAccel->flLineAccelModes) &&
                !(gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE) &&
                !(gc->state.enables.general & __GL_SCISSOR_TEST_ENABLE) &&
                !(gc->state.raster.drawBuffer == GL_NONE) &&
                !gc->buffers.doubleStore &&
                !genGc->pMcdState &&
                (genGc->dwCurrentFlags & (GLSURF_HDC | GLSURF_METAFILE)) ==
                GLSURF_HDC)
            {
                __fastLineComputeOffsets(genGc);

#if NT_NO_BUFFER_INVARIANCE
                if (!(gc->drawBuffer->buf.flags & DIB_FORMAT)) {
                    if (genAccel->bFastLineDispAccel) {
                        if (__fastGenLineSetupDisplay(gc))
                            return;
                    }
                } else {
                    if (genAccel->bFastLineDIBAccel) {
                        if (__fastGenLineSetupDIB(gc))
                            return;
                    }
                }
#else
                if (genAccel->bFastLineDispAccel) {
                    if (__fastGenLineSetupDisplay(gc))
                        return;
                }
#endif
            }
        }

        if (__glGenSetupEitherLines(gc))
        {
            return;
        }

        replicateLine = wideLine = GL_FALSE;

        aaline = gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE;
        if (aaline)
        {
            gc->procs.renderLine = __glRenderAntiAliasLine;
        }
        else
        {
            gc->procs.renderLine = __glRenderAliasLine;
        }
        
        sp = gc->procs.line.lineFuncs;
        ssp = gc->procs.line.stippledLineFuncs;

        if (!aaline && (modeFlags & __GL_SHADE_LINE_STIPPLE)) {
            *sp++ = __glStippleLine;
            *ssp++ = NULL;
        }

        if (!aaline && gc->state.line.aliasedWidth > 1) {
            wideLine = GL_TRUE;
        }
        spanCount = (int)((ULONG_PTR)(sp - gc->procs.line.lineFuncs));
        gc->procs.line.n = spanCount;

        *sp++ = __glScissorLine;
        *ssp++ = __glScissorStippledLine;

        if (!aaline) {
            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                *sp++ = __glStencilTestLine;
                *ssp++ = __glStencilTestStippledLine;
                if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                    if (bMcdZ) {
                        *sp = GenMcdDepthTestStencilLine;
                        *ssp = GenMcdDepthTestStencilStippledLine;
                    } else if( gc->modes.depthBits == 32 ) {
                        *sp = __glDepthTestStencilLine;
                        *ssp = __glDepthTestStencilStippledLine;
                    }
                    else {
                        *sp = __glDepth16TestStencilLine;
                        *ssp = __glDepth16TestStencilStippledLine;
                    }
                } else {
                    *sp = __glDepthPassLine;
                    *ssp = __glDepthPassStippledLine;
                }
                sp++;
                ssp++;
            } else {
                if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                    if (gc->state.depth.testFunc == GL_NEVER) {
                        /* Unexpected end of line routine picking! */
                        spanCount = (int)((ULONG_PTR)(sp - gc->procs.line.lineFuncs));
                        gc->procs.line.m = spanCount;
                        gc->procs.line.l = spanCount;
                        goto pickLineProcessor;
#ifdef __GL_USEASMCODE
                    } else {
                        unsigned long ix;

                        if (gc->state.depth.writeEnable) {
                            ix = 0;
                        } else {
                            ix = 8;
                        }
                        ix += gc->state.depth.testFunc & 0x7;

                        if (ix == (GL_LEQUAL & 0x7)) {
                            *sp++ = __glDepthTestLine_LEQ_asm;
                        } else {
                            *sp++ = __glDepthTestLine_asm;
                            gc->procs.line.depthTestPixel = LDepthTestPixel[ix];
                        }
#else
                    } else {
                        if (bMcdZ) {
                            *sp++ = GenMcdDepthTestLine;
                        } else {
                            if( gc->modes.depthBits == 32 )
                                *sp++ = __glDepthTestLine;
                            else
                                *sp++ = __glDepth16TestLine;
                        }
#endif
                    }
                    if (bMcdZ) {
                        *ssp++ = GenMcdDepthTestStippledLine;
                    } else {
                        if( gc->modes.depthBits == 32 )
                            *ssp++ = __glDepthTestStippledLine;
                        else
                            *ssp++ = __glDepth16TestStippledLine;
                    }
                }
            }
        }

        /* Load phase three procs */
        if (modeFlags & __GL_SHADE_RGB) {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                *sp = __glShadeRGBASpan;
                *ssp = __glShadeRGBASpan;
#ifdef GL_WIN_phong_shading
            } else if (modeFlags & __GL_SHADE_PHONG) {
                *sp = __glPhongRGBASpan;
                *ssp = __glPhongRGBASpan;
#endif //GL_WIN_phong_shading
            } else {
                *sp = __glFlatRGBASpan;
                *ssp = __glFlatRGBASpan;
            }
        } else {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                *sp = __glShadeCISpan;
                *ssp = __glShadeCISpan;
#ifdef GL_WIN_phong_shading
            } else if (modeFlags & __GL_SHADE_PHONG) {
                *sp = __glPhongCISpan;
                *ssp = __glPhongCISpan;
#endif //GL_WIN_phong_shading
            } else {
                *sp = __glFlatCISpan;
                *ssp = __glFlatCISpan;
            }
        }
        sp++;
        ssp++;
        if (modeFlags & __GL_SHADE_TEXTURE) {
            *sp++ = __glTextureSpan;
            *ssp++ = __glTextureStippledSpan;
        }
#ifdef GL_WIN_specular_fog
        if (modeFlags & (__GL_SHADE_SLOW_FOG | __GL_SHADE_SPEC_FOG))
#else //GL_WIN_specular_fog
        if (modeFlags & __GL_SHADE_SLOW_FOG)
#endif //GL_WIN_specular_fog
        {
            if (DO_NICEST_FOG (gc)) {
                *sp = __glFogSpanSlow;
                *ssp = __glFogStippledSpanSlow;
            } else {
                *sp = __glFogSpan;
                *ssp = __glFogStippledSpan;
            }
            sp++;
            ssp++;
        }

        if (aaline) {
            *sp++ = __glAntiAliasLine;
            *ssp++ = __glAntiAliasStippledLine;
        }

        if (aaline) {
            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                *sp++ = __glStencilTestLine;
                *ssp++ = __glStencilTestStippledLine;
                if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                    if (bMcdZ) {
                        *sp = GenMcdDepthTestStencilLine;
                        *ssp = GenMcdDepthTestStencilStippledLine;
                    } else if( gc->modes.depthBits == 32 ) {
                        *sp = __glDepthTestStencilLine;
                        *ssp = __glDepthTestStencilStippledLine;
                    }
                    else {
                        *sp = __glDepth16TestStencilLine;
                        *ssp = __glDepth16TestStencilStippledLine;
                    }
                } else {
                    *sp = __glDepthPassLine;
                    *ssp = __glDepthPassStippledLine;
                }
                sp++;
                ssp++;
            } else {
                if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                    if (gc->state.depth.testFunc == GL_NEVER) {
                        /* Unexpected end of line routine picking! */
                        spanCount = (int)((ULONG_PTR)(sp - gc->procs.line.lineFuncs));
                        gc->procs.line.m = spanCount;
                        gc->procs.line.l = spanCount;
                        goto pickLineProcessor;
#ifdef __GL_USEASMCODE
                    } else {
                        unsigned long ix;

                        if (gc->state.depth.writeEnable) {
                            ix = 0;
                        } else {
                            ix = 8;
                        }
                        ix += gc->state.depth.testFunc & 0x7;
                        *sp++ = __glDepthTestLine_asm;
                        gc->procs.line.depthTestPixel = LDepthTestPixel[ix];
#else
                    } else {
                        if (bMcdZ)
                            *sp++ = GenMcdDepthTestLine;
                        else if( gc->modes.depthBits == 32 )
                            *sp++ = __glDepthTestLine;
                        else
                            *sp++ = __glDepth16TestLine;
#endif
                    }
                    if (bMcdZ)
                        *ssp++ = GenMcdDepthTestStippledLine;
                    else if (gc->modes.depthBits == 32)
                        *ssp++ = __glDepthTestStippledLine;
                    else
                        *ssp++ = __glDepth16TestStippledLine;
                }
            }
        }

        if (modeFlags & __GL_SHADE_ALPHA_TEST) {
            *sp++ = __glAlphaTestSpan;
            *ssp++ = __glAlphaTestStippledSpan;
        }

        if (gc->buffers.doubleStore) {
            replicateLine = GL_TRUE;
        }
        spanCount = (int)((ULONG_PTR)(sp - gc->procs.line.lineFuncs));
        gc->procs.line.m = spanCount;

        *sp++ = __glStoreLine;
        *ssp++ = __glStoreStippledLine;

        spanCount = (int)((ULONG_PTR)(sp - gc->procs.line.lineFuncs));
        gc->procs.line.l = spanCount;

        sp = &gc->procs.line.wideLineRep;
        ssp = &gc->procs.line.wideStippledLineRep;
        if (wideLine) {
            *sp = __glWideLineRep;
            *ssp = __glWideStippleLineRep;
            sp = &gc->procs.line.drawLine;
            ssp = &gc->procs.line.drawStippledLine;
        }
        if (replicateLine) {
            *sp = __glDrawBothLine;
            *ssp = __glDrawBothStippledLine;
        } else {
            *sp = __glNopGCBOOL;
            *ssp = __glNopGCBOOL;
            gc->procs.line.m = gc->procs.line.l;
        }
        if (!wideLine) {
            gc->procs.line.n = gc->procs.line.m;
        }

pickLineProcessor:
        if (!wideLine && !replicateLine && spanCount == 3) {
            gc->procs.line.processLine = __glProcessLine3NW;
        } else {
            gc->procs.line.processLine = __glProcessLine;
        }
        if ((modeFlags & __GL_SHADE_CHEAP_FOG) &&
                !(modeFlags & __GL_SHADE_SMOOTH_LIGHT)) {
            gc->procs.renderLine2 = gc->procs.renderLine;
            gc->procs.renderLine = __glRenderFlatFogLine;
        }
    }
}

BOOL FASTCALL __glGenCreateAccelContext(__GLcontext *gc)
{
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    ULONG bpp;

    pfmt = &genGc->gsurf.pfd;
    bpp = pfmt->cColorBits;

    genGc->pPrivateArea = (VOID *)(&genGc->genAccel);

    __glQueryLineAcceleration(gc);

    gc->procs.pickTriangleProcs = __fastGenPickTriangleProcs;
    gc->procs.pickSpanProcs     = __fastGenPickSpanProcs;

    // Set up constant-color values:

    GENACCEL(gc).constantR = ((1 << pfmt->cRedBits) - 1) << 16;
    GENACCEL(gc).constantG = ((1 << pfmt->cGreenBits) - 1) << 16;
    GENACCEL(gc).constantB = ((1 << pfmt->cBlueBits) - 1) << 16;
    if( pfmt->cAlphaBits )
        GENACCEL(gc).constantA = ((1 << pfmt->cAlphaBits) - 1) << 16;
    else
        GENACCEL(gc).constantA = 0xff << 16;

    GENACCEL(gc).bpp = bpp;
    GENACCEL(gc).xMultiplier = ((bpp + 7) / 8);

    if (gc->modes.depthBits == 16 )
        GENACCEL(gc).zScale = (__GLfloat)65536.0;
    else
        GENACCEL(gc).zScale = (__GLfloat)1.0;

    return TRUE;
}


MCDHANDLE FASTCALL __glGenLoadTexture(__GLcontext *gc, __GLtexture *tex,
                                      ULONG flags)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    MCDHANDLE texHandle;
    DWORD texKey;

#ifdef _MCD_
    if (gengc->pMcdState) {
        texHandle = GenMcdCreateTexture(gengc, tex, flags);
        if (texHandle) {
            tex->textureKey = GenMcdTextureKey(gengc, texHandle);
            gc->textureKey = tex->textureKey;
        }
        return texHandle;
    } else
#endif
        return 0;
}


BOOL FASTCALL __glGenMakeTextureCurrent(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey)
{
    GLint internalFormat;

    if (!tex)
        return FALSE;

    InitAccelTextureValues(gc, tex);

    // Update the driver texture key in the context:

    if (((__GLGENcontext *)gc)->pMcdState && (gc->textureKey = tex->textureKey)) {
        GenMcdUpdateTextureState((__GLGENcontext *)gc, tex, loadKey);
    }

    // Previously we called bUseGenTriangles here to determine whether we were
    // doing 'fast' texturing, and if so, setup the texture cache pointers
    // below.  But this slowed down texture bind time, so for now we always
    // execute this next section of code (safe, since we check for valid ptrs).

    if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT)
    {
        if (tex->pvUser)
            GENACCEL(gc).texImageReplace =
                ((GENTEXCACHE *)tex->pvUser)->texImageReplace;
    }
    else if (tex->level[0].internalFormat != GL_COLOR_INDEX16_EXT)
    {
        if (tex->pvUser)
            GENACCEL(gc).texImageReplace =
                ((GENTEXCACHE *)tex->pvUser)->texImageReplace;

        GENACCEL(gc).texPalette = NULL;
    }

    return TRUE;
}


BOOL FASTCALL __glGenUpdateTexture(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey)
{

//!! NOTE !!
//!! This should really be broken into separate load and update calls since
//!! loading and updating are different operations.  The texture texture
//!! data cache will never shrink with the current implementation.

    // Do not quit if the load fails because we want the repick to occur
    // in MakeTextureCurrent in both the success and failure cases
    __fastGenLoadTexImage(gc, tex);

    __glGenMakeTextureCurrent(gc, tex, loadKey);

    return TRUE;
}


void FASTCALL __glGenFreeTexture(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey)
{
    __GLGENcontext  *gengc = (__GLGENcontext *)gc;

    if (GENACCEL(gc).texImage)
        GENACCEL(gc).texImage = NULL;

    if (tex->pvUser) {
        GCFREE(gc, tex->pvUser);
        tex->pvUser = NULL;
    }

#ifdef _MCD_
    if (gengc->pMcdState && loadKey) {
        GenMcdDeleteTexture(gengc, loadKey);
    }
#endif
}

void FASTCALL __glGenUpdateTexturePalette(__GLcontext *gc, __GLtexture *tex,
                                          MCDHANDLE loadKey, ULONG start,
                                          ULONG count)
{
    UCHAR *texBuffer;
    GENTEXCACHE *pGenTex;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    BYTE *pXlat = ((__GLGENcontext *)gc)->pajTranslateVector;
    ULONG rBits, gBits, bBits;
    ULONG rShift, gShift, bShift;
    ULONG i, end;
    ULONG *replaceBuffer;

    ASSERTOPENGL(tex->paletteTotalData != NULL,
                 "__GenUpdateTexturePalette: null texture data\n");

#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState && loadKey) {
        GenMcdUpdateTexturePalette((__GLGENcontext *)gc, tex, loadKey, start, 
                                   count);
    }
#endif

    pGenTex = GetGenTexCache(gc, tex);
    if (!pGenTex)
        return;

    GENACCEL(gc).texImageReplace = pGenTex->texImageReplace;

    replaceBuffer = (ULONG *)(pGenTex->texImageReplace) + start;
    texBuffer = (UCHAR *)(tex->paletteTotalData + start);

    rShift = cfb->redShift;
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;
    rBits = ((__GLGENcontext *)gc)->gsurf.pfd.cRedBits;
    gBits = ((__GLGENcontext *)gc)->gsurf.pfd.cGreenBits;
    bBits = ((__GLGENcontext *)gc)->gsurf.pfd.cBlueBits;

    end = start + count;

    for (i = start; i < end; i++, texBuffer += 4) {
        ULONG color;

        color = ((((ULONG)texBuffer[2] << rBits) >> 8) << rShift) |
                ((((ULONG)texBuffer[1] << gBits) >> 8) << gShift) |
                ((((ULONG)texBuffer[0] << bBits) >> 8) << bShift);

        if (GENACCEL(gc).bpp == 8)
            color = pXlat[color & 0xff];

        *replaceBuffer++ = (color | ((ULONG)texBuffer[3] << 24));
    }
}

#ifdef GL_EXT_flat_paletted_lighting
void FASTCALL __glGenSetPaletteOffset(__GLcontext *gc, __GLtexture *tex,
                                      GLint offset)
{
    GENTEXCACHE *pGenTex;

    if (GENACCEL(gc).texPalette == NULL)
    {
        return;
    }
    
    GENACCEL(gc).texPalette = (ULONG *)tex->paletteTotalData+offset;
    
    pGenTex = GetGenTexCache(gc, tex);
    if (pGenTex == NULL)
    {
        return;
    }

    // Replace map for paletted textures is a replace map of the
    // entire palette, so offset it
    if (GENACCEL(gc).texImageReplace != NULL)
    {
        GENACCEL(gc).texImageReplace = (UCHAR *)
            ((ULONG *)pGenTex->texImageReplace+offset);
    }
    
    // Consider - Call MCD
}
#endif

void FASTCALL __glGenDestroyAccelContext(__GLcontext *gc)
{
    __GLGENcontext *genGc = (__GLGENcontext *)gc;

    /* Free any platform-specific private data area */

    if (genGc->pPrivateArea) {

        if (GENACCEL(gc).pFastLineBuffer) {
            GCFREE(gc, GENACCEL(gc).pFastLineBuffer);
#ifndef _CLIENTSIDE_
            wglDeletePath(GENACCEL(gc).pFastLinePathobj);
#endif
        }

        genGc->pPrivateArea = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genaline.c ===
/******************************Module*Header*******************************\
* Module Name: genaline.c                                                  *
*                                                                          *
* This module provides accelerated interpolated line support.              *
*                                                                          *
* Created: 8-Dec-1995                                                      *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* 23-Jan-1996   Drew Bliss      [drewb]                                    *
*  Cut down antialiasing code to provide aliased versions                  *
*  Optimized line setup                                                    *
*                                                                          *
* Copyright (c) 1995-1996 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// #define DO_CHECK_PIXELS

#ifdef _X86_
#include <gli386.h>
#endif

#include "genline.h"

#ifndef NO_COMPILER_BUG
#undef __GL_FLOAT_SIMPLE_BEGIN_DIVIDE
#undef __GL_FLOAT_SIMPLE_END_DIVIDE
#define __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(a, b, c) \
    __GL_FLOAT_BEGIN_DIVIDE(a, b, &(c))
#define __GL_FLOAT_SIMPLE_END_DIVIDE(r) \
    __GL_FLOAT_END_DIVIDE(&(r))
#endif

// Also used by soft line code
BOOL FASTCALL __glInitLineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint start, end;
    __GLfloat x0,y0,x1,y1;
    __GLfloat minorStart;
    __GLfloat fdx, fdy;
    __GLfloat offset;
    __GLfloat slope;
    __GLlineState *ls = &gc->state.line;
    __GLfloat halfWidth;
    GLint x0frac, x1frac, y0frac, y1frac, totDist;
    GLint ix0, ix1, iy0, iy1, idx, idy;
    __GLcolorBuffer *cfb = gc->drawBuffer;

    ASSERT_CHOP_ROUND();
    
    gc->line.options.v0 = v0;
    gc->line.options.v1 = v1;
    gc->line.options.width = ls->aliasedWidth;

    x0 = v0->window.x;
    y0 = v0->window.y;
    x1 = v1->window.x;
    y1 = v1->window.y;

#ifdef DO_CHECK_PIXELS
    if (x0 < gc->transform.fminx || x0 >= gc->transform.fmaxx ||
        y0 < gc->transform.fminy || y0 >= gc->transform.fmaxy ||
        x1 < gc->transform.fminx || x1 >= gc->transform.fmaxx ||
        y1 < gc->transform.fminy || y1 >= gc->transform.fmaxy)
    {
        DbgPrint("Line coordinates out %.3lf,%.3lf - %.3lf,%.3lf%s\n",
                 x0, y0, x1, y1,
                 !gc->transform.reasonableViewport ? " (unreasonable)" : "");
    }
#endif
    
    fdx = x1-x0;
    fdy = y1-y0;

    halfWidth = (ls->aliasedWidth - 1) * __glHalf;

    ix0 = __GL_VERTEX_FLOAT_TO_INT(x0);
    x0frac = __GL_VERTEX_FLOAT_FRACTION(x0);
    iy0 = __GL_VERTEX_FLOAT_TO_INT(y0);
    y0frac = __GL_VERTEX_FLOAT_FRACTION(y0);
    ix1 = __GL_VERTEX_FLOAT_TO_INT(x1);
    x1frac = __GL_VERTEX_FLOAT_FRACTION(x1);
    iy1 = __GL_VERTEX_FLOAT_TO_INT(y1);
    y1frac = __GL_VERTEX_FLOAT_FRACTION(y1);

#if 0
    DbgPrint("Line %.3lf,%.3lf - %.3lf,%.3lf\n", x0, y0, x1, y1);
    DbgPrint("Line %d.%03d,%d.%03d - %d.%03d,%d.%03d\n",
             ix0, x0frac, iy0, y0frac, ix1, x1frac, iy1, y1frac);
#endif
    
    // An interesting property of window coordinates is that subtracting
    // two of them cancels the exponent so the result is the fixed-point
    // difference
    idx = CASTINT(x1)-CASTINT(x0);
    idy = CASTINT(y1)-CASTINT(y0);
    
    if (idx > 0) {
	if (idy > 0) {
	    if (idx > idy) {	/* dx > dy > 0 */
		gc->line.options.yBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth+GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth+1;

posxmajor:			/* dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = 1;
		gc->line.options.xLittle = 1;
                gc->polygon.shader.sbufLittle = GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufLittle = 1;
                
		__GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, fdx, slope);

		start = ix0;
		end = ix1;

		y0frac -= __GL_VERTEX_FRAC_HALF;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac + x0frac - __GL_VERTEX_FRAC_ONE;
		if (totDist > 0) start++;

                y1frac -= __GL_VERTEX_FRAC_HALF;
                if (y1frac < 0) y1frac = -y1frac;

                totDist = y1frac + x1frac - __GL_VERTEX_FRAC_ONE;
                if (totDist > 0) end++;

		offset = start + __glHalf - x0;

		gc->line.options.length = fdx;
		gc->line.options.numPixels = end - start;

xmajorfinish:
		gc->line.options.axis = __GL_X_MAJOR;
		gc->line.options.xStart = start;
		gc->line.options.offset = offset;

		__GL_FLOAT_SIMPLE_END_DIVIDE(slope);
                gc->line.options.oneOverLength = slope;
                slope *= fdy;

		minorStart = y0 + offset*slope - halfWidth;
		gc->line.options.yStart = __GL_VERTEX_FLOAT_TO_INT(minorStart);
                if (gc->line.options.yStart < gc->transform.miny)
                {
                    gc->line.options.yStart = gc->transform.miny;
                    gc->line.options.fraction = 0;
                }
                else if (gc->line.options.yStart >= gc->transform.maxy)
                {
                    gc->line.options.yStart = gc->transform.maxy-1;
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTE_FRACTION(
                                (1 << __GL_VERTEX_FRAC_BITS)-1);
                }
                else
                {
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTED_FRACTION(minorStart);
                }
		gc->line.options.dfraction = FLT_FRACTION(slope);
	    } else {		/* dy >= dx > 0 */
		gc->line.options.xBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth+GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth+1;
                
posymajor:			/* dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = 1;
		gc->line.options.yLittle = 1;
                gc->polygon.shader.sbufLittle = cfb->buf.outerWidth;
                gc->polygon.shader.zbufLittle = gc->depthBuffer.buf.outerWidth;
                
		__GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, fdy, slope);
                    
		start = iy0;
		end = iy1;

		x0frac -= __GL_VERTEX_FRAC_HALF;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = y0frac + x0frac - __GL_VERTEX_FRAC_ONE;
		if (totDist > 0) start++;

                x1frac -= __GL_VERTEX_FRAC_HALF;
                if (x1frac < 0) x1frac = -x1frac;

                totDist = y1frac + x1frac - __GL_VERTEX_FRAC_ONE;
                if (totDist > 0) end++;

		offset = start + __glHalf - y0;

		gc->line.options.length = fdy;
		gc->line.options.numPixels = end - start;

ymajorfinish:
		gc->line.options.axis = __GL_Y_MAJOR;
		gc->line.options.yStart = start;
		gc->line.options.offset = offset;

                __GL_FLOAT_SIMPLE_END_DIVIDE(slope);
                gc->line.options.oneOverLength = slope;
                slope *= fdx;
                
		minorStart = x0 + offset*slope - halfWidth;
		gc->line.options.xStart = __GL_VERTEX_FLOAT_TO_INT(minorStart);
                if (gc->line.options.xStart < gc->transform.minx)
                {
                    gc->line.options.xStart = gc->transform.minx;
                    gc->line.options.fraction = 0;
                }
                else if (gc->line.options.xStart >= gc->transform.maxx)
                {
                    gc->line.options.xStart = gc->transform.maxx-1;
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTE_FRACTION(
                                (1 << __GL_VERTEX_FRAC_BITS)-1);
                }
                else
                {
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTED_FRACTION(minorStart);
                }
		gc->line.options.dfraction = FLT_FRACTION(slope);
	    }
	} else {
	    if (idx > -idy) {	/* dx > -dy >= 0 */
		gc->line.options.yBig = -1;
                gc->polygon.shader.sbufBig =
                    GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = 1-gc->depthBuffer.buf.outerWidth;
		goto posxmajor;
	    } else {		/* -dy >= dx >= 0, dy != 0 */
		gc->line.options.xBig = 1;
                gc->polygon.shader.sbufBig =
                    GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = 1-gc->depthBuffer.buf.outerWidth;
negymajor:			/* -dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = -1;
		gc->line.options.yLittle = -1;
                gc->polygon.shader.sbufLittle = -cfb->buf.outerWidth;
                gc->polygon.shader.zbufLittle = -gc->depthBuffer.buf.outerWidth;

                __GL_FLOAT_BEGIN_DIVIDE(__glOne, -fdy, &slope);

		start = iy0;
		end = iy1;

		x0frac -= __GL_VERTEX_FRAC_HALF;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = x0frac - y0frac;
		if (totDist > 0) start--;

                x1frac -= __GL_VERTEX_FRAC_HALF;
                if (x1frac < 0) x1frac = -x1frac;

                totDist = x1frac - y1frac;
                if (totDist > 0) end--;

		offset = y0 - (start + __glHalf);

		gc->line.options.length = -fdy;
		gc->line.options.numPixels = start - end;
		goto ymajorfinish;
	    }
	}
    } else {
	if (idy > 0) {
	    if (-idx > idy) {	/* -dx > dy > 0 */
		gc->line.options.yBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth-GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth-1;
negxmajor:			/* -dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = -1;
		gc->line.options.xLittle = -1;
                gc->polygon.shader.sbufLittle = -GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufLittle = -1;

                __GL_FLOAT_BEGIN_DIVIDE(__glOne, -fdx, &slope);

		start = ix0;
		end = ix1;

		y0frac -= __GL_VERTEX_FRAC_HALF;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac - x0frac;
		if (totDist > 0) start--;

                y1frac -= __GL_VERTEX_FRAC_HALF;
                if (y1frac < 0) y1frac = -y1frac;

                totDist = y1frac - x1frac;
                if (totDist > 0) end--;

		offset = x0 - (start + __glHalf);

		gc->line.options.length = -fdx;
		gc->line.options.numPixels = start - end;

		goto xmajorfinish;
	    } else {		/* dy >= -dx >= 0, dy != 0 */
		gc->line.options.xBig = -1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth-GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth-1;
		goto posymajor;
	    }
	} else {
	    if (idx < idy) {	/* -dx > -dy >= 0 */
		gc->line.options.yBig = -1;
                gc->polygon.shader.sbufBig =
                    -GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = -1-gc->depthBuffer.buf.outerWidth;
		goto negxmajor;
	    } else {		/* -dy >= -dx >= 0 */
		if ((idx | idy) == 0) {
		    gc->line.options.numPixels = 0;
		    return FALSE;
		}
		gc->line.options.xBig = -1;
                gc->polygon.shader.sbufBig =
                    -GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = -1-gc->depthBuffer.buf.outerWidth;
		goto negymajor;
	    }
	}
    }

#ifdef DO_CHECK_PIXELS
    if (gc->line.options.numPixels > 0)
    {
        ix0 = gc->line.options.xStart;
        iy0 = gc->line.options.yStart;
        if (ix0 < gc->transform.minx || ix0 >= gc->transform.maxx ||
            iy0 < gc->transform.miny || iy0 >= gc->transform.maxy)
        {
            DbgPrint("Start out of bounds %d,%d (%d,%d - %d,%d) for %d,%d\n",
                     ix0, iy0,
                     gc->transform.minx, gc->transform.miny,
                     gc->transform.maxx, gc->transform.maxy,
                     idx, idy);
            DbgPrint("  Line %.3lf,%.3lf - %.3lf,%.3lf\n", x0, y0, x1, y1);
            DbgPrint("  Viewport %.3lf,%.3lf - %.3lf,%.3lf%s\n",
                     gc->state.viewport.xCenter, gc->state.viewport.yCenter,
                     gc->state.viewport.xScale, gc->state.viewport.yScale,
                     !gc->transform.reasonableViewport ?
                     " (unreasonable)" : "");
        }
    }
#endif
    
    return gc->line.options.numPixels > 0;
}

// Only used by fast single-pixel line code
// It differs from glInitLineData only in the removal of halfWidth
BOOL FASTCALL __glInitThinLineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint start, end;
    __GLfloat x0,y0,x1,y1;
    __GLfloat minorStart;
    __GLfloat fdx, fdy;
    __GLfloat offset;
    __GLfloat slope;
    GLint x0frac, x1frac, y0frac, y1frac, totDist;
    GLint ix0, ix1, iy0, iy1, idx, idy;
    __GLcolorBuffer *cfb = gc->drawBuffer;

    ASSERT_CHOP_ROUND();

    ASSERTOPENGL(gc->state.line.aliasedWidth == __glOne,
                 "ThinAlias setup for wrong line state\n");

    x0 = v0->window.x;
    y0 = v0->window.y;
    x1 = v1->window.x;
    y1 = v1->window.y;

#ifdef DO_CHECK_PIXELS
    gc->line.options.v0 = v0;
    gc->line.options.v1 = v1;

    if (x0 < gc->transform.fminx || x0 >= gc->transform.fmaxx ||
        y0 < gc->transform.fminy || y0 >= gc->transform.fmaxy ||
        x1 < gc->transform.fminx || x1 >= gc->transform.fmaxx ||
        y1 < gc->transform.fminy || y1 >= gc->transform.fmaxy)
    {
        DbgPrint("Line coordinates out %.3lf,%.3lf - %.3lf,%.3lf%s\n",
                 x0, y0, x1, y1,
                 !gc->transform.reasonableViewport ? " (unreasonable)" : "");
    }
#endif
    
    fdx = x1-x0;
    fdy = y1-y0;

    ix0 = __GL_VERTEX_FLOAT_TO_INT(x0);
    x0frac = __GL_VERTEX_FLOAT_FRACTION(x0);
    iy0 = __GL_VERTEX_FLOAT_TO_INT(y0);
    y0frac = __GL_VERTEX_FLOAT_FRACTION(y0);
    ix1 = __GL_VERTEX_FLOAT_TO_INT(x1);
    x1frac = __GL_VERTEX_FLOAT_FRACTION(x1);
    iy1 = __GL_VERTEX_FLOAT_TO_INT(y1);
    y1frac = __GL_VERTEX_FLOAT_FRACTION(y1);

#if 0
    DbgPrint("Line %.3lf,%.3lf - %.3lf,%.3lf\n", x0, y0, x1, y1);
    DbgPrint("Line %d.%03d,%d.%03d - %d.%03d,%d.%03d\n",
             ix0, x0frac, iy0, y0frac, ix1, x1frac, iy1, y1frac);
#endif
    
    // An interesting property of window coordinates is that subtracting
    // two of them cancels the exponent so the result is the fixed-point
    // difference
    idx = CASTINT(x1)-CASTINT(x0);
    idy = CASTINT(y1)-CASTINT(y0);
    
    if (idx > 0) {
	if (idy > 0) {
	    if (idx > idy) {	/* dx > dy > 0 */
		gc->line.options.yBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth+GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth+1;

posxmajor:			/* dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = 1;
		gc->line.options.xLittle = 1;
                gc->polygon.shader.sbufLittle = GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufLittle = 1;
                
		__GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, fdx, slope);

		start = ix0;
		end = ix1;

		y0frac -= __GL_VERTEX_FRAC_HALF;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac + x0frac - __GL_VERTEX_FRAC_ONE;
		if (totDist > 0) start++;

                y1frac -= __GL_VERTEX_FRAC_HALF;
                if (y1frac < 0) y1frac = -y1frac;

                totDist = y1frac + x1frac - __GL_VERTEX_FRAC_ONE;
                if (totDist > 0) end++;

		offset = start + __glHalf - x0;

		gc->line.options.length = fdx;
		gc->line.options.numPixels = end - start;

xmajorfinish:
		gc->line.options.axis = __GL_X_MAJOR;
		gc->line.options.xStart = start;
		gc->line.options.offset = offset;

		__GL_FLOAT_SIMPLE_END_DIVIDE(slope);
                gc->line.options.oneOverLength = slope;
                slope *= fdy;

		minorStart = y0 + offset*slope;
		gc->line.options.yStart = __GL_VERTEX_FLOAT_TO_INT(minorStart);
                if (gc->line.options.yStart < gc->transform.miny)
                {
                    gc->line.options.yStart = gc->transform.miny;
                    gc->line.options.fraction = 0;
                }
                else if (gc->line.options.yStart >= gc->transform.maxy)
                {
                    gc->line.options.yStart = gc->transform.maxy-1;
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTE_FRACTION(
                                (1 << __GL_VERTEX_FRAC_BITS)-1);
                }
                else
                {
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTED_FRACTION(minorStart);
                }

		gc->line.options.dfraction = FLT_FRACTION(slope);
	    } else {		/* dy >= dx > 0 */
		gc->line.options.xBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth+GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth+1;
                
posymajor:			/* dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = 1;
		gc->line.options.yLittle = 1;
                gc->polygon.shader.sbufLittle = cfb->buf.outerWidth;
                gc->polygon.shader.zbufLittle = gc->depthBuffer.buf.outerWidth;
                
		__GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, fdy, slope);
                    
		start = iy0;
		end = iy1;

		x0frac -= __GL_VERTEX_FRAC_HALF;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = y0frac + x0frac - __GL_VERTEX_FRAC_ONE;
		if (totDist > 0) start++;

                x1frac -= __GL_VERTEX_FRAC_HALF;
                if (x1frac < 0) x1frac = -x1frac;

                totDist = y1frac + x1frac - __GL_VERTEX_FRAC_ONE;
                if (totDist > 0) end++;

		offset = start + __glHalf - y0;

		gc->line.options.length = fdy;
		gc->line.options.numPixels = end - start;

ymajorfinish:
		gc->line.options.axis = __GL_Y_MAJOR;
		gc->line.options.yStart = start;
		gc->line.options.offset = offset;

                __GL_FLOAT_SIMPLE_END_DIVIDE(slope);
                gc->line.options.oneOverLength = slope;
                slope *= fdx;
                
		minorStart = x0 + offset*slope;
		gc->line.options.xStart = __GL_VERTEX_FLOAT_TO_INT(minorStart);
                if (gc->line.options.xStart < gc->transform.minx)
                {
                    gc->line.options.xStart = gc->transform.minx;
                    gc->line.options.fraction = 0;
                }
                else if (gc->line.options.xStart >= gc->transform.maxx)
                {
                    gc->line.options.xStart = gc->transform.maxx-1;
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTE_FRACTION(
                                (1 << __GL_VERTEX_FRAC_BITS)-1);
                }
                else
                {
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTED_FRACTION(minorStart);
                }
                
		gc->line.options.dfraction = FLT_FRACTION(slope);
	    }
	} else {
	    if (idx > -idy) {	/* dx > -dy >= 0 */
		gc->line.options.yBig = -1;
                gc->polygon.shader.sbufBig =
                    GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = 1-gc->depthBuffer.buf.outerWidth;
		goto posxmajor;
	    } else {		/* -dy >= dx >= 0, dy != 0 */
		gc->line.options.xBig = 1;
                gc->polygon.shader.sbufBig =
                    GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = 1-gc->depthBuffer.buf.outerWidth;
negymajor:			/* -dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = -1;
		gc->line.options.yLittle = -1;
                gc->polygon.shader.sbufLittle = -cfb->buf.outerWidth;
                gc->polygon.shader.zbufLittle = -gc->depthBuffer.buf.outerWidth;

                __GL_FLOAT_BEGIN_DIVIDE(__glOne, -fdy, &slope);

		start = iy0;
		end = iy1;

		x0frac -= __GL_VERTEX_FRAC_HALF;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = x0frac - y0frac;
		if (totDist > 0) start--;

                x1frac -= __GL_VERTEX_FRAC_HALF;
                if (x1frac < 0) x1frac = -x1frac;

                totDist = x1frac - y1frac;
                if (totDist > 0) end--;

		offset = y0 - (start + __glHalf);

		gc->line.options.length = -fdy;
		gc->line.options.numPixels = start - end;
		goto ymajorfinish;
	    }
	}
    } else {
	if (idy > 0) {
	    if (-idx > idy) {	/* -dx > dy > 0 */
		gc->line.options.yBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth-GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth-1;
negxmajor:			/* -dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = -1;
		gc->line.options.xLittle = -1;
                gc->polygon.shader.sbufLittle = -GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufLittle = -1;

                __GL_FLOAT_BEGIN_DIVIDE(__glOne, -fdx, &slope);

		start = ix0;
		end = ix1;

		y0frac -= __GL_VERTEX_FRAC_HALF;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac - x0frac;
		if (totDist > 0) start--;

                y1frac -= __GL_VERTEX_FRAC_HALF;
                if (y1frac < 0) y1frac = -y1frac;

                totDist = y1frac - x1frac;
                if (totDist > 0) end--;

		offset = x0 - (start + __glHalf);

		gc->line.options.length = -fdx;
		gc->line.options.numPixels = start - end;

		goto xmajorfinish;
	    } else {		/* dy >= -dx >= 0, dy != 0 */
		gc->line.options.xBig = -1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth-GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth-1;
		goto posymajor;
	    }
	} else {
	    if (idx < idy) {	/* -dx > -dy >= 0 */
		gc->line.options.yBig = -1;
                gc->polygon.shader.sbufBig =
                    -GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = -1-gc->depthBuffer.buf.outerWidth;
		goto negxmajor;
	    } else {		/* -dy >= -dx >= 0 */
		if ((idx | idy) == 0) {
		    gc->line.options.numPixels = 0;
		    return FALSE;
		}
		gc->line.options.xBig = -1;
                gc->polygon.shader.sbufBig =
                    -GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = -1-gc->depthBuffer.buf.outerWidth;
		goto negymajor;
	    }
	}
    }

#ifdef DO_CHECK_PIXELS
    if (gc->line.options.numPixels > 0)
    {
        ix0 = gc->line.options.xStart;
        iy0 = gc->line.options.yStart;
        if (ix0 < gc->transform.minx || ix0 >= gc->transform.maxx ||
            iy0 < gc->transform.miny || iy0 >= gc->transform.maxy)
        {
            DbgPrint("Start out of bounds %d,%d (%d,%d - %d,%d) for %d,%d\n",
                     ix0, iy0,
                     gc->transform.minx, gc->transform.miny,
                     gc->transform.maxx, gc->transform.maxy,
                     idx, idy);
            DbgPrint("  Line %.3lf,%.3lf - %.3lf,%.3lf\n", x0, y0, x1, y1);
            DbgPrint("  Viewport %.3lf,%.3lf - %.3lf,%.3lf%s\n",
                     gc->state.viewport.xCenter, gc->state.viewport.yCenter,
                     gc->state.viewport.xScale, gc->state.viewport.yScale,
                     !gc->transform.reasonableViewport ?
                     " (unreasonable)" : "");
        }
    }
#endif
    
    return gc->line.options.numPixels > 0;
}

// Called to render both anti-aliased and aliased lines
void FASTCALL __glGenRenderEitherLine(__GLcontext *gc, __GLvertex *v0, 
                                      __GLvertex *v1, GLuint flags)
{
    __GLfloat invDelta;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    CHOP_ROUND_ON();

    if (!(*GENACCEL(gc).__fastGenInitLineData)(gc, v0, v1))
    {
        CHOP_ROUND_OFF();
        return;
    }

    ASSERTOPENGL(GENACCEL(gc).rAccelScale == FIX_SCALEFACT,
                 "rAccelScale != FIX_SCALEFACT\n");
    ASSERTOPENGL(GENACCEL(gc).gAccelScale == FIX_SCALEFACT,
                 "gAccelScale != FIX_SCALEFACT\n");
    ASSERTOPENGL(GENACCEL(gc).bAccelScale == FIX_SCALEFACT,
                 "bAccelScale != FIX_SCALEFACT\n");
    // Alpha is always scaled between 0 and 255

    invDelta = gc->line.options.oneOverLength;
    
    /*
    ** Set up increments for any enabled line options.
    */

    if ((gc->drawBuffer->buf.flags & DIB_FORMAT) == 0)
    {
        // For non-DIBs we pick up the bytes from ColorsBits so
        // the pixel pointer doesn't move
        gc->polygon.shader.sbufLittle = 0;
        gc->polygon.shader.sbufBig = 0;
    }

    if (modeFlags & __GL_SHADE_SMOOTH)
    {
        __GLcolor *c0 = v0->color;
        __GLcolor *c1 = v1->color;

        /*
        ** Calculate red, green, blue and alpha value increments.
        */

        if (gc->modes.rgbMode)
        {
            __GLfloat dr, dg, db;
            
#ifdef _X86_
            __asm
            {
                ; Compute dr, dg and db
                mov eax, c0
                mov edx, c1
                fld DWORD PTR [eax+COLOR_r]
                fld DWORD PTR [eax+COLOR_g]
                fld DWORD PTR [eax+COLOR_b]
                fld DWORD PTR [edx+COLOR_r]
                fsub st(0), st(3)
                fld DWORD PTR [edx+COLOR_g]
                fsub st(0), st(3)
                fld DWORD PTR [edx+COLOR_b]
                fsub st(0), st(3)
                mov edx, gc
                fstp db
                fstp dg
                fstp dr
                
                FLT_STACK_RGB_TO_GC_FIXED(GC_SHADER_R,
                                          GC_SHADER_G,
                                          GC_SHADER_B)
            }
#else
            dr = c1->r - c0->r;
            CASTFIX(gc->polygon.shader.frag.color.r) =
                UNSAFE_FLT_TO_FIX(c0->r);
        
            dg = c1->g - c0->g;
            CASTFIX(gc->polygon.shader.frag.color.g) =
                UNSAFE_FLT_TO_FIX(c0->g);
            
            db = c1->b - c0->b;
            CASTFIX(gc->polygon.shader.frag.color.b) =
                UNSAFE_FLT_TO_FIX(c0->b);
#endif
            
            if ((CASTINT(dr) | CASTINT(dg) | CASTINT(db)) == 0)
            {
                CASTINT(gc->polygon.shader.drdx) = 0;
                CASTINT(gc->polygon.shader.dgdx) = 0;
                CASTINT(gc->polygon.shader.dbdx) = 0;
            }
            else
            {
#ifdef _X86_
                __asm
                {
                    fld dr
                    fld dg
                    fld db
                    fld invDelta
                    fmul __glVal65536
                    mov edx, gc
                    fmul st(3), st(0)
                    fmul st(2), st(0)
                    fmulp st(1), st(0)
                    fistp DWORD PTR [edx+GC_SHADE_dbdx]
                    fistp DWORD PTR [edx+GC_SHADE_dgdx]
                    fistp DWORD PTR [edx+GC_SHADE_drdx]
                }
#else
                CASTFIX(gc->polygon.shader.drdx) =
                    UNSAFE_FLT_TO_FIX(dr * invDelta);
                CASTFIX(gc->polygon.shader.dgdx) =
                    UNSAFE_FLT_TO_FIX(dg * invDelta);
                CASTFIX(gc->polygon.shader.dbdx) =
                    UNSAFE_FLT_TO_FIX(db * invDelta);
#endif
            }

            if (gc->state.enables.general & __GL_BLEND_ENABLE)
            {
                __GLfloat da;
                
                da = c1->a - c0->a;
                CASTFIX(gc->polygon.shader.frag.color.a) =
                    UNSAFE_FTOL(c0->a * GENACCEL(gc).aAccelScale);
                
                if (__GL_FLOAT_EQZ(da))
                {
                    CASTINT(gc->polygon.shader.dadx) = 0;
                }
                else
                {
                    CASTFIX(gc->polygon.shader.dadx) =
                        UNSAFE_FTOL(da * invDelta * GENACCEL(gc).aAccelScale);
                }
            }
        }
        else
        {
            __GLfloat dr;
            
            dr = c1->r - c0->r;
            CASTFIX(gc->polygon.shader.frag.color.r) =
                UNSAFE_FLT_TO_FIX(c0->r);

            if (__GL_FLOAT_EQZ(dr))
            {
                CASTINT(gc->polygon.shader.drdx) = 0;
            }
            else
            {
                CASTFIX(gc->polygon.shader.drdx) =
                    UNSAFE_FLT_TO_FIX(dr * invDelta);
            }
        }
    }
    else
    {
        __GLcolor *c1 = v0->color;

        if (gc->modes.rgbMode)
        {
#ifdef _X86_
            __asm
            {
                mov eax, c1
                fld DWORD PTR [eax+COLOR_r]
                fld DWORD PTR [eax+COLOR_g]
                fld DWORD PTR [eax+COLOR_b]
                mov edx, gc
                
                FLT_STACK_RGB_TO_GC_FIXED(GC_SHADER_R,
                                          GC_SHADER_G,
                                          GC_SHADER_B)
            }
#else
            CASTFIX(gc->polygon.shader.frag.color.r) =
                UNSAFE_FLT_TO_FIX(c1->r);
            CASTFIX(gc->polygon.shader.frag.color.g) =
                UNSAFE_FLT_TO_FIX(c1->g);
            CASTFIX(gc->polygon.shader.frag.color.b) =
                UNSAFE_FLT_TO_FIX(c1->b);
#endif

            if (gc->state.enables.general & __GL_BLEND_ENABLE)
            {
                CASTFIX(gc->polygon.shader.frag.color.a) =
                    UNSAFE_FTOL(c1->a * GENACCEL(gc).aAccelScale);
            }
        }
        else
        {
            CASTFIX(gc->polygon.shader.frag.color.r) =
                UNSAFE_FLT_TO_FIX(c1->r);
        }
    }
    
    if (modeFlags & __GL_SHADE_DEPTH_ITER)
    {
        // The increment is in USHORT units so it only needs to be
        // scaled in the 32-bit Z buffer case
        if (gc->depthBuffer.buf.elementSize == 4)
        {
            gc->polygon.shader.zbufLittle <<= 1;
            gc->polygon.shader.zbufBig <<= 1;
        }

        /*
        ** Calculate window z coordinate increment and starting position.
        */
        if(( gc->modes.depthBits == 16 ) &&
           ( gc->depthBuffer.scale <= (GLuint)0xffff ))
        {
            ASSERTOPENGL(Z16_SCALE == FIX_SCALEFACT,
                         "Z16 scaling different from fixed\n");
            
            gc->polygon.shader.dzdx =
                FLT_TO_Z16_SCALE((v1->window.z - v0->window.z) * invDelta);
            gc->polygon.shader.frag.z =
                FTOL(v0->window.z*Z16_SCALE + gc->polygon.shader.dzdx *
                     gc->line.options.offset);
        }
        else
        {
            gc->polygon.shader.dzdx =
                FTOL((v1->window.z - v0->window.z) * invDelta);
            gc->polygon.shader.frag.z =
                FTOL(v0->window.z + gc->polygon.shader.dzdx *
                     gc->line.options.offset);
        }
    } 

    (*GENACCEL(gc).__fastGenLineProc)(gc);

    CHOP_ROUND_OFF();
}

#define DITHER_PIXEL(pPix, x, y)\
{\
    ULONG r, g, b;\
    DWORD ditherVal;\
\
    ditherVal = ditherShade[((x) & 0x3) + \
                            (((y) & 0x3) << 3)];\
\
    r = ((rAccum + ditherVal) >> (16-RSHIFT)) & RMASK;\
    g = ((gAccum + ditherVal) >> (16-GSHIFT)) & GMASK;\
    b = ((bAccum + ditherVal) >> (16-BSHIFT)) & BMASK;\
\
    WRITE_PIX(pPix);\
}

#define BLEND_PIXEL(pPix, alpha, x, y)\
{\
    ULONG pix;\
    ULONG rDisplay, gDisplay, bDisplay, aDisplay;\
    ULONG r, g, b;\
    ULONG invAlpha;\
    DWORD ditherVal;\
\
    ditherVal = ditherShade[((x) & 0x3) + \
                            (((y) & 0x3) << 3)];\
\
    aDisplay = (gbMulTable[((aAccum >> 16) & 0xff) | (alpha)]) << 8;\
\
    pix = READ_PIX(pPix);\
\
    rDisplay = ((pix & RMASK) >> RSHIFT) << (8 - RBITS);\
    gDisplay = ((pix & GMASK) >> GSHIFT) << (8 - GBITS);\
    bDisplay = ((pix & BMASK) >> BSHIFT) << (8 - BBITS);\
\
    if (gc->state.raster.blendDst == GL_ONE) { \
\
        r = (gbMulTable[((rAccum >> (RBITS+8)) & 0xff) | aDisplay] + rDisplay)\
             + (ditherVal >> (RBITS + 8));\
        g = (gbMulTable[((gAccum >> (GBITS+8)) & 0xff) | aDisplay] + gDisplay)\
             + (ditherVal >> (GBITS + 8));\
        b = (gbMulTable[((bAccum >> (BBITS+8)) & 0xff) | aDisplay] + bDisplay)\
             + (ditherVal >> (BBITS + 8));\
        r = ((gbSatTable[r] << (RBITS+8)) \
             >> (16 - RSHIFT)) & RMASK;\
        g = ((gbSatTable[g] << (GBITS+8)) \
             >> (16 - GSHIFT)) & GMASK;\
        b = ((gbSatTable[b] << (BBITS+8)) \
             >> (16 - BSHIFT)) & BMASK;\
\
    } else { \
\
        invAlpha = 0xff00 - (ULONG)aDisplay;\
\
        rDisplay = gbMulTable[rDisplay | invAlpha];\
        gDisplay = gbMulTable[gDisplay | invAlpha];\
        bDisplay = gbMulTable[bDisplay | invAlpha];\
\
        r = ((((gbMulTable[((rAccum >> (RBITS+8)) & 0xff) | aDisplay] + rDisplay)\
             << (RBITS+8)) + ditherVal) >> (16 - RSHIFT)) & RMASK;\
\
        g = ((((gbMulTable[((gAccum >> (GBITS+8)) & 0xff) | aDisplay] + gDisplay)\
             << (GBITS+8)) + ditherVal) >> (16 - GSHIFT)) & GMASK;\
\
        b = ((((gbMulTable[((bAccum >> (BBITS+8)) & 0xff) | aDisplay] + bDisplay)\
             << (BBITS+8)) + ditherVal) >> (16 - BSHIFT)) & BMASK;\
    } \
\
    WRITE_PIX(pPix);\
}


#define WRITE_PIXEL_GEN(pPix, alpha, x, y)\
if (gc->state.enables.general & __GL_BLEND_ENABLE) {\
    ULONG pix;\
    ULONG rDisplay, gDisplay, bDisplay, aDisplay;\
    ULONG r, g, b;\
    ULONG invAlpha;\
    DWORD ditherVal;\
\
    if (modeFlags & __GL_SHADE_DITHER) {\
        ditherVal = ditherShade[((x) & 0x3) + \
                                (((y) & 0x3) << 3)];\
    } else\
        ditherVal = 0;\
\
    aDisplay = (gbMulTable[((aAccum >> 16) & 0xff) | (alpha)]) << 8;\
\
    switch (bytesPerPixel) {\
        case 1:\
            pix = ((__GLGENcontext *)gc)->pajInvTranslateVector[*((BYTE *)(pPix))];\
            rDisplay = ((pix & rMask) >> rShift) << (8 - rBits);\
            gDisplay = ((pix & gMask) >> gShift) << (8 - gBits);\
            bDisplay = ((pix & bMask) >> bShift) << (8 - bBits);\
            break;\
        case 2:\
            pix = *((USHORT *)(pPix));\
            rDisplay = ((pix & rMask) >> rShift) << (8 - rBits);\
            gDisplay = ((pix & gMask) >> gShift) << (8 - gBits);\
            bDisplay = ((pix & bMask) >> bShift) << (8 - bBits);\
            break;\
        case 3:\
        default:\
            if (rShift > bShift) {\
                rDisplay = pPix[2];\
                gDisplay = pPix[1];\
                bDisplay = pPix[0];\
            } else {\
                rDisplay = pPix[0];\
                gDisplay = pPix[1];\
                bDisplay = pPix[2];\
            }\
            break;\
    }\
\
    if (gc->state.raster.blendDst == GL_ONE) { \
\
        r = (gbMulTable[((rAccum >> (rBits+8)) & 0xff) | aDisplay] + rDisplay)\
             + (ditherVal >> (rBits + 8));\
        g = (gbMulTable[((gAccum >> (gBits+8)) & 0xff) | aDisplay] + gDisplay)\
             + (ditherVal >> (gBits + 8));\
        b = (gbMulTable[((bAccum >> (bBits+8)) & 0xff) | aDisplay] + bDisplay)\
             + (ditherVal >> (bBits + 8));\
        r = ((gbSatTable[r] << (rBits+8)) \
             >> (16 - rShift)) & rMask;\
        g = ((gbSatTable[g] << (gBits+8)) \
             >> (16 - gShift)) & gMask;\
        b = ((gbSatTable[b] << (bBits+8)) \
             >> (16 - bShift)) & bMask;\
\
    } else { \
\
        invAlpha = 0xff00 - (ULONG)aDisplay;\
\
        rDisplay = gbMulTable[rDisplay | invAlpha];\
        gDisplay = gbMulTable[gDisplay | invAlpha];\
        bDisplay = gbMulTable[bDisplay | invAlpha];\
\
        r = ((((gbMulTable[((rAccum >> (rBits+8)) & 0xff) | aDisplay] + rDisplay)\
             << (rBits+8)) + ditherVal) >> (16 - rShift)) & rMask;\
\
        g = ((((gbMulTable[((gAccum >> (gBits+8)) & 0xff) | aDisplay] + gDisplay)\
             << (gBits+8)) + ditherVal) >> (16 - gShift)) & gMask;\
\
        b = ((((gbMulTable[((bAccum >> (bBits+8)) & 0xff) | aDisplay] + bDisplay)\
             << (bBits+8)) + ditherVal) >> (16 - bShift)) & bMask;\
    } \
\
    switch (bytesPerPixel) {\
        case 1:\
            pPix[0] = ((__GLGENcontext *)gc)->xlatPalette[r | g | b];\
            break;\
        case 2:\
            *((USHORT *)pPix) = (USHORT)(r | g | b);\
            break;\
        case 3:\
            pix = r | g | b;\
            *((USHORT UNALIGNED *)pPix) = (USHORT)pix;\
            pPix[2] = (BYTE)(pix >> 16);\
            break;\
        default:\
            *((DWORD *)pPix) = (DWORD)(r | g | b);\
            break;\
    }\
} else {\
    ULONG r, g, b;\
    DWORD ditherVal;\
    ULONG pix;\
\
    if (modeFlags & __GL_SHADE_DITHER) {\
        ditherVal = ditherShade[((x) & 0x3) + (((y) & 0x3) << 3)];\
    } else\
        ditherVal = 0;\
\
    r = ((rAccum + ditherVal) >> (16-rShift)) & rMask;\
    g = ((gAccum + ditherVal) >> (16-gShift)) & gMask;\
    b = ((bAccum + ditherVal) >> (16-bShift)) & bMask;\
\
    switch (bytesPerPixel) {\
        case 1:\
            pPix[0] = ((__GLGENcontext *)gc)->xlatPalette[r | g | b];\
            break;\
        case 2:\
            *((USHORT *)pPix) = (USHORT)(r | g | b);\
            break;\
        case 3:\
            pix = r | g | b;\
            *((USHORT UNALIGNED *)pPix) = (USHORT)pix;\
            pPix[2] = (BYTE)(pix >> 16);\
            break;\
        default:\
            *((DWORD *)pPix) = (DWORD)(r | g | b);\
            break;\
    }\
}

#ifdef DO_CHECK_PIXELS
#define CHECK_PIXEL(gc, cfb, count, bx, by) \
{\
    GLint fbX, fbY;\
\
    fbX = __GL_UNBIAS_X(gc, bx);\
    fbY = __GL_UNBIAS_Y(gc, by);\
    if (!(fbX >= 0 && fbX < (cfb)->buf.width &&\
          fbY >= 0 && fbY < (cfb)->buf.height))\
    {\
        DbgPrint("Pixel out of bounds at %c %d of %d: %d,%d (%d,%d)\n",\
                 (gc)->line.options.axis == __GL_Y_MAJOR ? 'Y' : 'X',\
                 (gc)->line.options.numPixels-(count),\
                 (gc)->line.options.numPixels,\
                 fbX, fbY, (cfb)->buf.width, (cfb)->buf.height);\
        DbgPrint("  Line %.3lf,%.3lf - %.3lf,%.3lf\n",\
                 (gc)->line.options.v0->window.x,\
                 (gc)->line.options.v0->window.y,\
                 (gc)->line.options.v1->window.x,\
                 (gc)->line.options.v1->window.y);\
    }\
}
#else
#define CHECK_PIXEL(gc, cfb, w, x, y)
#endif
 
#define FAST_AA_LINE \
{\
    GLint xLittle, xBig, yLittle, yBig;\
    GLint fragX2, fragY2;\
    BYTE *pPix;\
    BYTE *pPix2;\
    USHORT *pZ;\
    USHORT *pZ2;\
    __GLfragment frag;\
    __GLcolorBuffer *cfb = gc->drawBuffer;\
    LONG rAccum, gAccum, bAccum, aAccum;\
    LONG pixAdjStep;\
    ULONG zAdjStep;\
    ULONG coverage, invCoverage;\
    LONG fragXinc;\
    LONG fragYinc;\
    LONG bytesPerPixel;\
    __GLzValue zAccum;\
    GLint clipX1 = gc->transform.clipX1;\
    GLint clipY1 = gc->transform.clipY1;\
\
    GLint fraction, dfraction;\
    GLint w;\
    GLuint modeFlags = gc->polygon.shader.modeFlags;\
\
    ASSERTOPENGL((cfb->buf.flags &\
                  (DIB_FORMAT | NO_CLIP)) == (DIB_FORMAT | NO_CLIP),\
                 "FAST_AA_LINE on clipping surface\n");\
\
    fraction = gc->line.options.fraction;\
    dfraction = gc->line.options.dfraction;\
\
    xBig = gc->line.options.xBig;\
    yBig = gc->line.options.yBig;\
    xLittle = gc->line.options.xLittle;\
    yLittle = gc->line.options.yLittle;\
\
    frag.x = gc->line.options.xStart;\
    frag.y = gc->line.options.yStart;\
\
    bytesPerPixel = GENACCEL(gc).xMultiplier;\
\
    if (gc->line.options.axis == __GL_Y_MAJOR) {\
        pixAdjStep = bytesPerPixel;\
        zAdjStep = 1;\
        fragXinc = 1;\
        fragYinc = 0;\
    } else {\
        pixAdjStep = cfb->buf.outerWidth;\
        zAdjStep = gc->depthBuffer.buf.outerWidth;\
        fragXinc = 0;\
        fragYinc = 1;\
    }\
\
    pPix = (BYTE *)((ULONG_PTR)cfb->buf.base +\
        (__GL_UNBIAS_Y(gc, frag.y) + cfb->buf.yOrigin) * cfb->buf.outerWidth +\
        (__GL_UNBIAS_X(gc, frag.x) + cfb->buf.xOrigin) * bytesPerPixel);\
\
    if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
        zAccum = gc->polygon.shader.frag.z;\
\
	if( gc->modes.depthBits == 32 ) {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),\
                                           frag.x, frag.y);\
\
            zAdjStep *= 2;\
	} else {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer,\
                                           (__GLz16Value*),\
                                           frag.x, frag.y);\
        }\
\
    }\
\
    rAccum = CASTFIX(gc->polygon.shader.frag.color.r);\
    gAccum = CASTFIX(gc->polygon.shader.frag.color.g);\
    bAccum = CASTFIX(gc->polygon.shader.frag.color.b);\
    aAccum = CASTFIX(gc->polygon.shader.frag.color.a);\
\
    w = gc->line.options.numPixels;\
    for (;;)\
    {\
        CHECK_PIXEL(gc, cfb, w, frag.x, frag.y);\
\
        invCoverage = ((fraction << 1) & 0xff000000) >> 16;\
	coverage = 0xff00 - invCoverage;\
\
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ ))\
                goto noWrite1;\
        }\
\
        BLEND_PIXEL(pPix, coverage, frag.x, frag.y);\
noWrite1:\
\
        fragX2 = frag.x + fragXinc;\
        fragY2 = frag.y + fragYinc;\
        if ((fragX2 >= clipX1) || (fragY2 >= clipY1)) {\
            goto noWrite2;\
        }\
\
        pZ2 = pZ+zAdjStep;\
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ2 ))\
                goto noWrite2;\
        }\
\
	pPix2 = pPix + pixAdjStep;\
        BLEND_PIXEL(pPix2, invCoverage, fragX2, fragY2);\
noWrite2:\
\
        if (--w <= 0)\
            return GL_TRUE;\
\
        fraction += dfraction;\
	if (fraction < 0) {\
	    fraction &= ~0x80000000;\
	    frag.x += xBig;\
	    frag.y += yBig;\
            pPix += gc->polygon.shader.sbufBig;\
            pZ += gc->polygon.shader.zbufBig;\
	} else {\
	    frag.x += xLittle;\
	    frag.y += yLittle;\
            pPix += gc->polygon.shader.sbufLittle;\
            pZ += gc->polygon.shader.zbufLittle;\
	}\
\
        if (modeFlags & __GL_SHADE_SMOOTH) {\
            rAccum += CASTFIX(gc->polygon.shader.drdx);\
            gAccum += CASTFIX(gc->polygon.shader.dgdx);\
            bAccum += CASTFIX(gc->polygon.shader.dbdx);\
            aAccum += CASTFIX(gc->polygon.shader.dadx);\
        }\
\
        if (modeFlags & __GL_SHADE_DEPTH_ITER) {\
	    zAccum += gc->polygon.shader.dzdx;\
        }\
    }\
\
    return GL_TRUE;\
}


/************************************************************************/


#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          0
#define GSHIFT          3
#define BSHIFT          6
#define RBITS		3
#define GBITS		3
#define BBITS		2
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             8
#define READ_PIX(pPix) \
    ((__GLGENcontext *)gc)->pajInvTranslateVector[*((BYTE *)(pPix))]
#define WRITE_PIX(pPix) \
    pPix[0] = ((__GLGENcontext *)gc)->xlatPalette[r | g | b]

GLboolean FASTCALL __fastGenAntiAliasLine332(__GLcontext *gc)
FAST_AA_LINE


#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          10
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		5
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define READ_PIX(pPix) \
    *((USHORT *)(pPix))
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenAntiAliasLine555(__GLcontext *gc)
FAST_AA_LINE


#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          11
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		6
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define READ_PIX(pPix) \
    *((USHORT *)(pPix))
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenAntiAliasLine565(__GLcontext *gc)
FAST_AA_LINE

GLboolean FASTCALL __fastGenAntiAliasLine(__GLcontext *gc)
{
    GLint xLittle, xBig, yLittle, yBig;
    GLint fragX2, fragY2;
    BYTE *pPix;
    BYTE *pPix2;
    USHORT *pZ;
    USHORT *pZ2;
    __GLfragment frag;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    LONG rAccum, gAccum, bAccum, aAccum;
    ULONG rMask, gMask, bMask;
    ULONG rShift, gShift, bShift;
    ULONG rBits, gBits, bBits;
    LONG bytesPerPixel;
    LONG pixAdjStep;
    ULONG zAdjStep;
    ULONG coverage, invCoverage;
    LONG fragXinc;
    LONG fragYinc;
    GLint cfbX, cfbY;
    int copyPix;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    __GLzValue zAccum;
    GLint clipX1 = gc->transform.clipX1;
    GLint clipY1 = gc->transform.clipY1;

    GLint fraction, dfraction;
    GLint w;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    w = gc->line.options.numPixels;

    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;

    frag.x = gc->line.options.xStart;
    frag.y = gc->line.options.yStart;

    bytesPerPixel = GENACCEL(gc).xMultiplier;

    if (gc->line.options.axis == __GL_Y_MAJOR) {
        pixAdjStep = bytesPerPixel;
        zAdjStep = 1;
        fragXinc = 1;
        fragYinc = 0;
        // For Y-major non-DIB lines we can copy both affected pixels
        // at once since they are adjacent in memory
        copyPix = 2;
    } else {
        if ((cfb->buf.flags & DIB_FORMAT) != 0)
        {
            pixAdjStep = cfb->buf.outerWidth;
        }
        else
        {
            pixAdjStep = 0;
        }
        zAdjStep = gc->depthBuffer.buf.outerWidth;
        fragXinc = 0;
        fragYinc = 1;
        copyPix = 1;
    }

    if ((cfb->buf.flags & DIB_FORMAT) != 0)
    {
        pPix = (BYTE *)((ULONG_PTR)cfb->buf.base +
            (__GL_UNBIAS_Y(gc, frag.y) + cfb->buf.yOrigin) * cfb->buf.outerWidth + 
            (__GL_UNBIAS_X(gc, frag.x) + cfb->buf.xOrigin) * bytesPerPixel);
    }
    else
    {
        pPix = gengc->ColorsBits;
    }

    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
        zAccum = gc->polygon.shader.frag.z;

	if( gc->modes.depthBits == 32 ) {
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                           frag.x, frag.y);
            // Adjust for pZ being a USHORT * but traversing a 32-bit
            // depth buffer
            zAdjStep *= 2;
	} else {
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer,
                                           (__GLz16Value*),
                                           frag.x, frag.y);
        }
    }

    rShift = cfb->redShift;
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;

    rMask = gc->modes.redMask;
    gMask = gc->modes.greenMask;
    bMask = gc->modes.blueMask;

    rBits = gc->modes.redBits;
    gBits = gc->modes.greenBits;
    bBits = gc->modes.blueBits;

    rAccum = CASTFIX(gc->polygon.shader.frag.color.r);
    gAccum = CASTFIX(gc->polygon.shader.frag.color.g);
    bAccum = CASTFIX(gc->polygon.shader.frag.color.b);
    aAccum = CASTFIX(gc->polygon.shader.frag.color.a);


    for (;;)
    {
        CHECK_PIXEL(gc, cfb, w, frag.x, frag.y);

        invCoverage = ((fraction << 1) & 0xff000000) >> 16;
	coverage = 0xff00 - invCoverage;

        if ((cfb->buf.flags & DIB_FORMAT) == 0)
        {
            cfbX = __GL_UNBIAS_X(gc, frag.x)+cfb->buf.xOrigin;
            cfbY = __GL_UNBIAS_Y(gc, frag.y)+cfb->buf.yOrigin;
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, copyPix, FALSE);
        }

        if (modeFlags & __GL_SHADE_DEPTH_TEST) {
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ ))
                goto noWrite1;
        }

        if ((cfb->buf.flags & (NO_CLIP | DIB_FORMAT)) == DIB_FORMAT)
        {
            cfbX = __GL_UNBIAS_X(gc, frag.x)+cfb->buf.xOrigin;
            cfbY = __GL_UNBIAS_Y(gc, frag.y)+cfb->buf.yOrigin;
            if (!wglPixelVisible(cfbX, cfbY))
            {
                goto noWrite1;
            }
        }
        
        WRITE_PIXEL_GEN(pPix, coverage, frag.x, frag.y);
        
        if ((cfb->buf.flags & DIB_FORMAT) == 0 && copyPix == 1)
        {
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, copyPix, TRUE);
        }
        
noWrite1:

        fragX2 = frag.x + fragXinc;
        fragY2 = frag.y + fragYinc;
        if ((fragX2 >= clipX1) || (fragY2 >= clipY1)) {
            goto noWrite2;
        }

        pZ2 = pZ+zAdjStep;
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ2 ))
                goto noWrite2;
        }

        if ((cfb->buf.flags & (NO_CLIP | DIB_FORMAT)) == DIB_FORMAT)
        {
            cfbX = __GL_UNBIAS_X(gc, fragX2)+cfb->buf.xOrigin;
            cfbY = __GL_UNBIAS_Y(gc, fragY2)+cfb->buf.yOrigin;
            if (!wglPixelVisible(cfbX, cfbY))
            {
                goto noWrite2;
            }
        }
        
	pPix2 = pPix + pixAdjStep;

        if ((cfb->buf.flags & DIB_FORMAT) == 0 && copyPix == 1)
        {
            cfbX += fragXinc;
            cfbY += fragYinc;
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, copyPix, FALSE);
        }

        WRITE_PIXEL_GEN(pPix2, invCoverage, fragX2, fragY2);
        
noWrite2:

        if ((cfb->buf.flags & DIB_FORMAT) == 0)
        {
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, copyPix, TRUE);
        }
        
        if (--w <= 0)
            return GL_TRUE;

        fraction += dfraction;
	if (fraction < 0) {
	    fraction &= ~0x80000000;
	    frag.x += xBig;
	    frag.y += yBig;
            pPix += gc->polygon.shader.sbufBig;
            pZ += gc->polygon.shader.zbufBig;
	} else {
	    frag.x += xLittle;
	    frag.y += yLittle;
            pPix += gc->polygon.shader.sbufLittle;
            pZ += gc->polygon.shader.zbufLittle;
	}

        if (modeFlags & __GL_SHADE_SMOOTH) {
            rAccum += CASTFIX(gc->polygon.shader.drdx);
            gAccum += CASTFIX(gc->polygon.shader.dgdx);
            bAccum += CASTFIX(gc->polygon.shader.dbdx);
            aAccum += CASTFIX(gc->polygon.shader.dadx);
        }

        if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	    zAccum += gc->polygon.shader.dzdx;
        }
    }

    return GL_TRUE;
}

/************************************************************************/

#define FAST_A_LINE_BLEND \
{\
    GLint xLittle, xBig, yLittle, yBig;\
    BYTE *pPix;\
    USHORT *pZ;\
    __GLfragment frag;\
    __GLcolorBuffer *cfb = gc->drawBuffer;\
    LONG rAccum, gAccum, bAccum, aAccum;\
    LONG bytesPerPixel;\
    __GLzValue zAccum;\
    GLint fraction, dfraction;\
    GLint w;\
    GLuint modeFlags = gc->polygon.shader.modeFlags;\
    ULONG coverage = 0xff00;\
\
    ASSERTOPENGL((cfb->buf.flags &\
                  (DIB_FORMAT | NO_CLIP)) == (DIB_FORMAT | NO_CLIP),\
                 "FAST_A_LINE_BLEND on clipping surface\n");\
\
    fraction = gc->line.options.fraction;\
    dfraction = gc->line.options.dfraction;\
\
    xBig = gc->line.options.xBig;\
    yBig = gc->line.options.yBig;\
    xLittle = gc->line.options.xLittle;\
    yLittle = gc->line.options.yLittle;\
\
    frag.x = gc->line.options.xStart;\
    frag.y = gc->line.options.yStart;\
\
    bytesPerPixel = GENACCEL(gc).xMultiplier;\
\
    pPix = (BYTE *)((ULONG_PTR)cfb->buf.base +\
        (__GL_UNBIAS_Y(gc, frag.y) + cfb->buf.yOrigin) * cfb->buf.outerWidth +\
        (__GL_UNBIAS_X(gc, frag.x) + cfb->buf.xOrigin) * bytesPerPixel);\
\
    if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
        zAccum = gc->polygon.shader.frag.z;\
\
	if( gc->modes.depthBits == 32 ) {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),\
                                           frag.x, frag.y);\
\
	} else {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer,\
                                           (__GLz16Value*),\
                                           frag.x, frag.y);\
        }\
\
    }\
\
    rAccum = CASTFIX(gc->polygon.shader.frag.color.r);\
    gAccum = CASTFIX(gc->polygon.shader.frag.color.g);\
    bAccum = CASTFIX(gc->polygon.shader.frag.color.b);\
    aAccum = CASTFIX(gc->polygon.shader.frag.color.a);\
\
    w = gc->line.options.numPixels;\
    for (;;)\
    {\
        CHECK_PIXEL(gc, cfb, w, frag.x, frag.y);\
\
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ))\
                goto NoWrite;\
        }\
\
        BLEND_PIXEL(pPix, coverage, frag.x, frag.y);\
NoWrite:\
\
        if (--w <= 0)\
            return GL_TRUE;\
\
        fraction += dfraction;\
	if (fraction < 0) {\
	    fraction &= ~0x80000000;\
	    frag.x += xBig;\
	    frag.y += yBig;\
            pPix += gc->polygon.shader.sbufBig;\
            pZ += gc->polygon.shader.zbufBig;\
	} else {\
	    frag.x += xLittle;\
	    frag.y += yLittle;\
            pPix += gc->polygon.shader.sbufLittle;\
            pZ += gc->polygon.shader.zbufLittle;\
	}\
\
        if (modeFlags & __GL_SHADE_SMOOTH) {\
            rAccum += CASTFIX(gc->polygon.shader.drdx);\
            gAccum += CASTFIX(gc->polygon.shader.dgdx);\
            bAccum += CASTFIX(gc->polygon.shader.dbdx);\
            aAccum += CASTFIX(gc->polygon.shader.dadx);\
        }\
\
        if (modeFlags & __GL_SHADE_DEPTH_ITER) {\
	    zAccum += gc->polygon.shader.dzdx;\
        }\
    }\
\
    return GL_TRUE;\
}

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          0
#define GSHIFT          3
#define BSHIFT          6
#define RBITS		3
#define GBITS		3
#define BBITS		2
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             8
#define READ_PIX(pPix) \
    ((__GLGENcontext *)gc)->pajInvTranslateVector[*((BYTE *)(pPix))]
#define WRITE_PIX(pPix) \
    pPix[0] = ((__GLGENcontext *)gc)->xlatPalette[r | g | b]

GLboolean FASTCALL __fastGenBlendAliasLine332(__GLcontext *gc)
FAST_A_LINE_BLEND

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT         10
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		5
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define READ_PIX(pPix) \
    *((USHORT *)(pPix))
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenBlendAliasLine555(__GLcontext *gc)
FAST_A_LINE_BLEND

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT         11
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		6
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define READ_PIX(pPix) \
    *((USHORT *)(pPix))
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenBlendAliasLine565(__GLcontext *gc)
FAST_A_LINE_BLEND

/************************************************************************/

#define FAST_A_LINE_NO_BLEND \
{\
    GLint xLittle, xBig, yLittle, yBig;\
    BYTE *pPix;\
    USHORT *pZ;\
    __GLfragment frag;\
    __GLcolorBuffer *cfb = gc->drawBuffer;\
    LONG rAccum, gAccum, bAccum;\
    LONG bytesPerPixel;\
    __GLzValue zAccum;\
    GLint fraction, dfraction;\
    GLint w;\
    GLuint modeFlags = gc->polygon.shader.modeFlags;\
\
    ASSERTOPENGL((cfb->buf.flags &\
                  (DIB_FORMAT | NO_CLIP)) == (DIB_FORMAT | NO_CLIP),\
                 "FAST_A_LINE_NO_BLEND on clipping surface\n");\
\
    fraction = gc->line.options.fraction;\
    dfraction = gc->line.options.dfraction;\
\
    xBig = gc->line.options.xBig;\
    yBig = gc->line.options.yBig;\
    xLittle = gc->line.options.xLittle;\
    yLittle = gc->line.options.yLittle;\
\
    frag.x = gc->line.options.xStart;\
    frag.y = gc->line.options.yStart;\
\
    bytesPerPixel = GENACCEL(gc).xMultiplier;\
\
    pPix = (BYTE *)((ULONG_PTR)cfb->buf.base +\
        (__GL_UNBIAS_Y(gc, frag.y) + cfb->buf.yOrigin) * cfb->buf.outerWidth +\
        (__GL_UNBIAS_X(gc, frag.x) + cfb->buf.xOrigin) * bytesPerPixel);\
\
    if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
        zAccum = gc->polygon.shader.frag.z;\
\
	if( gc->modes.depthBits == 32 ) {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),\
                                           frag.x, frag.y);\
\
	} else {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer,\
                                           (__GLz16Value*),\
                                           frag.x, frag.y);\
        }\
\
    }\
\
    rAccum = CASTFIX(gc->polygon.shader.frag.color.r);\
    gAccum = CASTFIX(gc->polygon.shader.frag.color.g);\
    bAccum = CASTFIX(gc->polygon.shader.frag.color.b);\
\
    w = gc->line.options.numPixels;\
    for (;;)\
    {\
        CHECK_PIXEL(gc, cfb, w, frag.x, frag.y);\
\
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ))\
                goto NoWrite;\
        }\
\
        DITHER_PIXEL(pPix, frag.x, frag.y);\
NoWrite:\
\
        if (--w <= 0)\
            return GL_TRUE;\
\
        fraction += dfraction;\
	if (fraction < 0) {\
	    fraction &= ~0x80000000;\
	    frag.x += xBig;\
	    frag.y += yBig;\
            pPix += gc->polygon.shader.sbufBig;\
            pZ += gc->polygon.shader.zbufBig;\
	} else {\
	    frag.x += xLittle;\
	    frag.y += yLittle;\
            pPix += gc->polygon.shader.sbufLittle;\
            pZ += gc->polygon.shader.zbufLittle;\
	}\
\
        if (modeFlags & __GL_SHADE_SMOOTH) {\
            rAccum += CASTFIX(gc->polygon.shader.drdx);\
            gAccum += CASTFIX(gc->polygon.shader.dgdx);\
            bAccum += CASTFIX(gc->polygon.shader.dbdx);\
        }\
\
        if (modeFlags & __GL_SHADE_DEPTH_ITER) {\
	    zAccum += gc->polygon.shader.dzdx;\
        }\
    }\
\
    return GL_TRUE;\
}

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          0
#define GSHIFT          3
#define BSHIFT          6
#define RBITS		3
#define GBITS		3
#define BBITS		2
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             8
#define WRITE_PIX(pPix) \
    pPix[0] = ((__GLGENcontext *)gc)->xlatPalette[r | g | b]

GLboolean FASTCALL __fastGenNoBlendAliasLine332(__GLcontext *gc)
FAST_A_LINE_NO_BLEND

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          10
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		5
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenNoBlendAliasLine555(__GLcontext *gc)
FAST_A_LINE_NO_BLEND

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          11
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		6
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenNoBlendAliasLine565(__GLcontext *gc)
FAST_A_LINE_NO_BLEND

// WRITE_PIXEL_GEN handles both blending and no blending so this
// generic routine works for both of those cases
GLboolean FASTCALL __fastGenAliasLine(__GLcontext *gc)
{
    GLint xLittle, xBig, yLittle, yBig;
    BYTE *pPix;
    USHORT *pZ;
    __GLfragment frag;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    LONG rAccum, gAccum, bAccum, aAccum;
    ULONG rMask, gMask, bMask;
    ULONG rShift, gShift, bShift;
    ULONG rBits, gBits, bBits;
    LONG bytesPerPixel;
    GLint cfbX, cfbY;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    __GLzValue zAccum;
    GLint fraction, dfraction;
    GLint w;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    
    // Only present for placeholder in WRITE_PIXEL_GEN macro
    ULONG coverage = 0xff00;

    w = gc->line.options.numPixels;

    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;

    frag.x = gc->line.options.xStart;
    frag.y = gc->line.options.yStart;

    bytesPerPixel = GENACCEL(gc).xMultiplier;

    if ((cfb->buf.flags & DIB_FORMAT) != 0)
    {
        pPix = (BYTE *)((ULONG_PTR)cfb->buf.base +
            (__GL_UNBIAS_Y(gc, frag.y) + cfb->buf.yOrigin) * cfb->buf.outerWidth + 
            (__GL_UNBIAS_X(gc, frag.x) + cfb->buf.xOrigin) * bytesPerPixel);
    }
    else
    {
        pPix = gengc->ColorsBits;
    }

    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
        zAccum = gc->polygon.shader.frag.z;

	if( gc->modes.depthBits == 32 ) {
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                           frag.x, frag.y);
	} else {
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer,
                                           (__GLz16Value*),
                                           frag.x, frag.y);
        }
    }

    rShift = cfb->redShift;
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;

    rMask = gc->modes.redMask;
    gMask = gc->modes.greenMask;
    bMask = gc->modes.blueMask;

    rBits = gc->modes.redBits;
    gBits = gc->modes.greenBits;
    bBits = gc->modes.blueBits;

    rAccum = CASTFIX(gc->polygon.shader.frag.color.r);
    gAccum = CASTFIX(gc->polygon.shader.frag.color.g);
    bAccum = CASTFIX(gc->polygon.shader.frag.color.b);
    aAccum = CASTFIX(gc->polygon.shader.frag.color.a);

    for (;;)
    {
        CHECK_PIXEL(gc, cfb, w, frag.x, frag.y);
        
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ))
                goto NoWrite;
        }

        if ((cfb->buf.flags & (NO_CLIP | DIB_FORMAT)) == DIB_FORMAT)
        {
            cfbX = __GL_UNBIAS_X(gc, frag.x)+cfb->buf.xOrigin;
            cfbY = __GL_UNBIAS_Y(gc, frag.y)+cfb->buf.yOrigin;
            if (!wglPixelVisible(cfbX, cfbY))
            {
                goto NoWrite;
            }
        }
        
        if ((cfb->buf.flags & DIB_FORMAT) == 0)
        {
            cfbX = __GL_UNBIAS_X(gc, frag.x)+cfb->buf.xOrigin;
            cfbY = __GL_UNBIAS_Y(gc, frag.y)+cfb->buf.yOrigin;
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, 1, FALSE);
        }

        WRITE_PIXEL_GEN(pPix, coverage, frag.x, frag.y);

        if ((cfb->buf.flags & DIB_FORMAT) == 0)
        {
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, 1, TRUE);
        }

    NoWrite:
        
        if (--w <= 0)
            return GL_TRUE;
        
        fraction += dfraction;
	if (fraction < 0) {
	    fraction &= ~0x80000000;
	    frag.x += xBig;
	    frag.y += yBig;
            pPix += gc->polygon.shader.sbufBig;
            pZ += gc->polygon.shader.zbufBig;
	} else {
	    frag.x += xLittle;
	    frag.y += yLittle;
            pPix += gc->polygon.shader.sbufLittle;
            pZ += gc->polygon.shader.zbufLittle;
	}

        if (modeFlags & __GL_SHADE_SMOOTH) {
            rAccum += CASTFIX(gc->polygon.shader.drdx);
            gAccum += CASTFIX(gc->polygon.shader.dgdx);
            bAccum += CASTFIX(gc->polygon.shader.dbdx);
            aAccum += CASTFIX(gc->polygon.shader.dadx);
        }

        if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	    zAccum += gc->polygon.shader.dzdx;
        }
    }

    return GL_TRUE;
}

/************************************************************************/

// Bits 0-1 are for pixel format
// Bit    2 is for GL_BLEND enable
// Bit    3 is for GL_LINE_SMOOTH_ENABLE
fastGenLineProc pfnFastGenLineProcs[] =
{
    __fastGenAliasLine,
    __fastGenNoBlendAliasLine332,
    __fastGenNoBlendAliasLine555,
    __fastGenNoBlendAliasLine565,
        
    __fastGenAliasLine,
    __fastGenBlendAliasLine332,
    __fastGenBlendAliasLine555,
    __fastGenBlendAliasLine565,
    
    __fastGenAntiAliasLine,
    __fastGenAntiAliasLine,
    __fastGenAntiAliasLine,
    __fastGenAntiAliasLine,
    
    __fastGenAntiAliasLine,
    __fastGenAntiAliasLine332,
    __fastGenAntiAliasLine555,
    __fastGenAntiAliasLine565
};

//
// Assumptions for accelerated lines:
//
// no blending, or (SRC, 1-SRC), or (SRC, 1)
// not both buffers
// not stippled
// not stenciled
// not textured
// not alpha-tested
// not masked, zmasked
// no logicOp
// not slow fog
// not color-indexed
// not wide

#define __SLOW_LINE_MODE_FLAGS \
    (__GL_SHADE_TEXTURE | __GL_SHADE_LINE_STIPPLE | \
     __GL_SHADE_STENCIL_TEST | __GL_SHADE_LOGICOP | \
     __GL_SHADE_ALPHA_TEST | __GL_SHADE_MASK | \
     __GL_SHADE_SLOW_FOG)

BOOL FASTCALL __glGenSetupEitherLines(__GLcontext *gc)
{
#ifdef _MCD_
    GENMCDSTATE *pMcdState = ((__GLGENcontext *) gc)->pMcdState;
#endif
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    LONG bytesPerPixel;
    int fmt;
    BOOL bAccelerate =
        (((__GLGENcontext *)gc)->gsurf.pfd.cColorBits >= 8) &&
        (gc->state.raster.drawBuffer != GL_FRONT_AND_BACK) &&
        (gc->state.raster.drawBuffer != GL_NONE) &&
        ( ! ALPHA_WRITE_ENABLED( gc->drawBuffer ) ) &&
        (
         ((gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) &&
           (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) &&
           (gc->state.depth.writeEnable)) ||
          (!(gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) &&
           !(gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER))
         ) &&
         (gc->transform.reasonableViewport) &&
         (gc->state.line.aliasedWidth == 1) &&
         (modeFlags & __GL_SHADE_RGB) &&
#ifdef GL_WIN_phong_shading
         !(modeFlags & __GL_SHADE_PHONG) &&
#endif //GL_WIN_phong_shading
#ifdef GL_WIN_specular_fog
         !(modeFlags & __GL_SHADE_SPEC_FOG) &&
#endif //GL_WIN_specular_fog
         (!(modeFlags & __SLOW_LINE_MODE_FLAGS)) &&
          (!(gc->state.enables.general & __GL_BLEND_ENABLE) ||
           ((gc->state.raster.blendSrc == GL_SRC_ALPHA) &&
            ((gc->state.raster.blendDst == GL_ONE_MINUS_SRC_ALPHA) ||
             (gc->state.raster.blendDst == GL_ONE)))
          );

#ifdef _MCD_
    bAccelerate &= (!pMcdState || (pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED));
#endif

    // Resort to soft code if we can't handle the line:

    if (!bAccelerate)
    {
        return FALSE;
    }
    else if (gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE)
    {
        if (gc->state.hints.lineSmooth == GL_NICEST)
        {
            return FALSE;
        }
    }
    else if ((modeFlags & __GL_SHADE_CHEAP_FOG) &&
             (modeFlags & __GL_SHADE_SMOOTH_LIGHT) == 0)
    {
        // We only support cheap fog done by the front end, not
        // flat cheap fog done by the render procs
        return FALSE;
    }

    GENACCEL(gc).xMultiplier = bytesPerPixel = 
        (((__GLGENcontext *)gc)->gsurf.pfd.cColorBits + 7) >> 3;

    // Set up our local z-buffer procs:
    if (modeFlags & __GL_SHADE_DEPTH_ITER)
        __fastGenPickZStoreProc(gc);
    
    gc->procs.renderLine = __glGenRenderEitherLine;

    // Assume generic format
    fmt = 0;

    // For deep-color modes, we don't support most-significant-byte
    // formats...
    // For non-MSB deep-color modes, we only support generic rendering
    if (bytesPerPixel > 2)
    {
        if (((gc->drawBuffer->redShift > 16) ||
             (gc->drawBuffer->greenShift > 16) ||
             (gc->drawBuffer->blueShift > 16)))
        {
            return FALSE;
        }
        else
        {
            goto PickProc;
        }
    }

    // Just use generic acceleration if we're not 
    // dithering, since these are hardwired into the fastest routines...
    // We also only support unclipped surfaces in the fastest routines

    if (!(modeFlags & __GL_SHADE_DITHER) ||
        (gc->drawBuffer->buf.flags & (DIB_FORMAT | NO_CLIP)) !=
        (DIB_FORMAT | NO_CLIP))
    {
        goto PickProc;
    }

    // Now, check for supported color formats for fastest modes:

    if ((bytesPerPixel == 1) &&
        (gc->drawBuffer->redShift   == 0) &&
        (gc->drawBuffer->greenShift == 3) &&
        (gc->drawBuffer->blueShift  == 6))
    {
        fmt = 1;
    }
    else if (bytesPerPixel == 2)
    {
        if ((gc->drawBuffer->greenShift == 5) &&
            (gc->drawBuffer->blueShift  == 0))
        {
            if (gc->drawBuffer->redShift == 10)
            {
                fmt = 2;
            }
            else if (gc->drawBuffer->redShift == 11)
            {
                fmt = 3;
            }
        }
    }

 PickProc:
    if (gc->state.enables.general & __GL_BLEND_ENABLE)
    {
        fmt += 4;
    }
    if (gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE)
    {
        fmt += 8;
    }
    
    GENACCEL(gc).__fastGenLineProc = pfnFastGenLineProcs[fmt];

    if (gc->state.line.aliasedWidth != 1)
    {
        GENACCEL(gc).__fastGenInitLineData = __glInitLineData;
    }
    else
    {
        GENACCEL(gc).__fastGenInitLineData = __glInitThinLineData;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genattri.c ===
#include "precomp.h"
#pragma hdrstop

void APIPRIVATE __glim_Enable(GLenum cap)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (cap) {
      case GL_ALPHA_TEST:
        if (gc->state.enables.general & __GL_ALPHA_TEST_ENABLE) return;
        gc->state.enables.general |= __GL_ALPHA_TEST_ENABLE;
        break;
      case GL_BLEND:
        if (gc->state.enables.general & __GL_BLEND_ENABLE) return;
        gc->state.enables.general |= __GL_BLEND_ENABLE;
        break;
      case GL_COLOR_MATERIAL:
        if (gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) return;
        gc->state.enables.general |= __GL_COLOR_MATERIAL_ENABLE;
        ComputeColorMaterialChange(gc);
        (*gc->procs.pickColorMaterialProcs)(gc);
        (*gc->procs.applyColor)(gc);
        break;
      case GL_CULL_FACE:
        if (gc->state.enables.general & __GL_CULL_FACE_ENABLE) return;
        gc->state.enables.general |= __GL_CULL_FACE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
        
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_DEPTH_TEST:
        if (gc->state.enables.general & __GL_DEPTH_TEST_ENABLE) return;
        gc->state.enables.general |= __GL_DEPTH_TEST_ENABLE;
        if (gc->modes.depthBits) {
            if (!gc->modes.haveDepthBuffer)
                LazyAllocateDepth(gc);
                // XXX if this fails should we be setting the enable bit?
        } else {
            gc->state.depth.testFunc = GL_ALWAYS;
#ifdef _MCD_
            MCD_STATE_DIRTY(gc, DEPTHTEST);
#endif
        }
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
        break;
      case GL_POLYGON_OFFSET_POINT:
        if (gc->state.enables.general & __GL_POLYGON_OFFSET_POINT_ENABLE) 
            return;
        gc->state.enables.general |= __GL_POLYGON_OFFSET_POINT_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POINT);
        break;
      case GL_POLYGON_OFFSET_LINE:
        if (gc->state.enables.general & __GL_POLYGON_OFFSET_LINE_ENABLE)
            return;
        gc->state.enables.general |= __GL_POLYGON_OFFSET_LINE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
        break;
      case GL_POLYGON_OFFSET_FILL:
        if (gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE)
            return;
        gc->state.enables.general |= __GL_POLYGON_OFFSET_FILL_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
        break;
      case GL_DITHER:
        if (gc->state.enables.general & __GL_DITHER_ENABLE) return;
        gc->state.enables.general |= __GL_DITHER_ENABLE;
        break;
#ifdef GL_WIN_specular_fog
      case GL_FOG_SPECULAR_TEXTURE_WIN:
        if (gc->state.enables.general & __GL_FOG_SPEC_TEX_ENABLE) return;
        gc->state.enables.general |= __GL_FOG_SPEC_TEX_ENABLE;
        break;
#endif //GL_WIN_specular_fog
      case GL_FOG:
        if (gc->state.enables.general & __GL_FOG_ENABLE) return;
        gc->state.enables.general |= __GL_FOG_ENABLE;
        break;
      case GL_LIGHTING:
        if (gc->state.enables.general & __GL_LIGHTING_ENABLE) return;
        gc->state.enables.general |= __GL_LIGHTING_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
#ifdef NT
        ComputeColorMaterialChange(gc);
#endif
        (*gc->procs.pickColorMaterialProcs)(gc);
        (*gc->procs.applyColor)(gc);
        return;
      case GL_LINE_SMOOTH:
        if (gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE) return;
        gc->state.enables.general |= __GL_LINE_SMOOTH_ENABLE;
        break;
      case GL_LINE_STIPPLE:
        if (gc->state.enables.general & __GL_LINE_STIPPLE_ENABLE) return;
        gc->state.enables.general |= __GL_LINE_STIPPLE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_INDEX_LOGIC_OP:
        if (gc->state.enables.general & __GL_INDEX_LOGIC_OP_ENABLE) return;
        gc->state.enables.general |= __GL_INDEX_LOGIC_OP_ENABLE;
        break;
      case GL_COLOR_LOGIC_OP:
        if (gc->state.enables.general & __GL_COLOR_LOGIC_OP_ENABLE) return;
        gc->state.enables.general |= __GL_COLOR_LOGIC_OP_ENABLE;
        break;
      case GL_NORMALIZE:
        if (gc->state.enables.general & __GL_NORMALIZE_ENABLE) return;
        gc->state.enables.general |= __GL_NORMALIZE_ENABLE;
        break;
      case GL_POINT_SMOOTH:
        if (gc->state.enables.general & __GL_POINT_SMOOTH_ENABLE) return;
        gc->state.enables.general |= __GL_POINT_SMOOTH_ENABLE;
        break;
      case GL_POLYGON_SMOOTH:
        if (gc->state.enables.general & __GL_POLYGON_SMOOTH_ENABLE) return;
        gc->state.enables.general |= __GL_POLYGON_SMOOTH_ENABLE;
        break;
      case GL_POLYGON_STIPPLE:
        if (gc->state.enables.general & __GL_POLYGON_STIPPLE_ENABLE) return;
        gc->state.enables.general |= __GL_POLYGON_STIPPLE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_SCISSOR_TEST:
        if (gc->state.enables.general & __GL_SCISSOR_TEST_ENABLE) return;
        gc->state.enables.general |= __GL_SCISSOR_TEST_ENABLE;
#ifdef NT
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, SCISSOR);
#endif
        // applyViewport does both
        (*gc->procs.applyViewport)(gc);
#else
        (*gc->procs.computeClipBox)(gc);
        (*gc->procs.applyScissor)(gc);
#endif
        break;
      case GL_STENCIL_TEST:
        if (gc->state.enables.general & __GL_STENCIL_TEST_ENABLE) return;
        gc->state.enables.general |= __GL_STENCIL_TEST_ENABLE;

        if (!gc->modes.haveStencilBuffer && gc->modes.stencilBits) {
            LazyAllocateStencil(gc);
            // XXX if this fails should we be setting the enable bit?
        }
        break;
      case GL_TEXTURE_1D:
        if (gc->state.enables.general & __GL_TEXTURE_1D_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_1D_ENABLE;
        break;
      case GL_TEXTURE_2D:
        if (gc->state.enables.general & __GL_TEXTURE_2D_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_2D_ENABLE;
        break;
      case GL_AUTO_NORMAL:
        if (gc->state.enables.general & __GL_AUTO_NORMAL_ENABLE) return;
        gc->state.enables.general |= __GL_AUTO_NORMAL_ENABLE;
        break;
      case GL_TEXTURE_GEN_S:
        if (gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_GEN_S_ENABLE;
        break;
      case GL_TEXTURE_GEN_T:
        if (gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_GEN_T_ENABLE;
        break;
      case GL_TEXTURE_GEN_R:
        if (gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_GEN_R_ENABLE;
        break;
      case GL_TEXTURE_GEN_Q:
        if (gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_GEN_Q_ENABLE;
        break;
#ifdef GL_WIN_multiple_textures
    case GL_TEXCOMBINE_CLAMP_WIN:
        if (gc->state.enables.general & __GL_TEXCOMBINE_CLAMP_ENABLE)
        {
            return;
        }
        gc->state.enables.general |= __GL_TEXCOMBINE_CLAMP_ENABLE;
        break;
#endif // GL_WIN_multiple_textures
#ifdef GL_EXT_flat_paletted_lighting
      case GL_PALETTED_LIGHTING_EXT:
        gc->state.enables.general |= __GL_PALETTED_LIGHTING_ENABLE;
        break;
#endif

      case GL_CLIP_PLANE0: case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2: case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4: case GL_CLIP_PLANE5:
        cap -= GL_CLIP_PLANE0;
        if (gc->state.enables.clipPlanes & (1 << cap)) return;
        gc->state.enables.clipPlanes |= (1 << cap);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, CLIPCTRL);
#endif
        break;
      case GL_LIGHT0: case GL_LIGHT1:
      case GL_LIGHT2: case GL_LIGHT3:
      case GL_LIGHT4: case GL_LIGHT5:
      case GL_LIGHT6: case GL_LIGHT7:
        cap -= GL_LIGHT0;
        if (gc->state.enables.lights & (1 << cap)) return;
        gc->state.enables.lights |= (1 << cap);
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
        MCD_STATE_DIRTY(gc, LIGHTS);
        return;
      case GL_MAP1_COLOR_4:
      case GL_MAP1_NORMAL:
      case GL_MAP1_INDEX:
      case GL_MAP1_TEXTURE_COORD_1: case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3: case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3: case GL_MAP1_VERTEX_4:
        cap = __GL_EVAL1D_INDEX(cap);
        if (gc->state.enables.eval1 & (GLushort) (1 << cap)) return;
        gc->state.enables.eval1 |= (GLushort) (1 << cap);
        break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_NORMAL:
      case GL_MAP2_INDEX:
      case GL_MAP2_TEXTURE_COORD_1: case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3: case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3: case GL_MAP2_VERTEX_4:
        cap = __GL_EVAL2D_INDEX(cap);
        if (gc->state.enables.eval2 & (GLushort) (1 << cap)) return;
        gc->state.enables.eval2 |= (GLushort) (1 << cap);
        break;

      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, ENABLES);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genci.h ===
#ifndef __GENCI_H__
#define __GENCI_H__

void FASTCALL __glGenInitCI(__GLcontext *gc, __GLcolorBuffer *cfb, GLenum type);
void FASTCALL __glGenFreeCI(__GLcontext *gc, __GLcolorBuffer *cfb);
GLuint FASTCALL ColorToIndex( __GLGENcontext *genGc, GLuint color );

#endif /* !__GENCI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genci.c ===
#include "precomp.h"
#pragma hdrstop

#include "genclear.h"

// Null stores...

static void FASTCALL Store_NOT(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
}

static GLboolean FASTCALL StoreSpanNone(__GLcontext *gc)
{
    return GL_FALSE;
}


/* XXX! Current policy for >8-bit ColorIndex:

    - The index<->Color mapping will be kept in gengc->pajTranslateVector,
      viewed as an array of longs.  The first entry in the array will be
      the number of valid entries in the table.
    - gengc->pajTranslateVector will never be NULL, it is always allocated
      at MakeCurrent, and tracks any palette changes.
    - the minimum indexBits is 8 if the pixel format is > 8 bits deep
*/

/******************************Public*Routine******************************\
* dibSetPixelCI
*
* Special case version of GDI SetPixel API for use when the destination
* surface is a DIB and rendering in color index mode.
*
* This function *must* be used in lieu of gdiCopyPixels if we are
* accessing the screen directly as it is not safe to call GDI entry
* points with a screen lock
*
* History:
*  29-May-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void dibSetPixelCI(__GLGENcontext *gengc, __GLcolorBuffer *cfb,
                    GLint x, GLint y, DWORD dwColor)
{
    GLuint flags;

    flags = cfb->buf.flags;

    ASSERTOPENGL(flags & DIB_FORMAT,
                 "dibSetPixelCI called on non-DIB\n");
    
    if ( (flags & NO_CLIP) || wglPixelVisible(x, y) )
    {
        if ( gengc->gsurf.pfd.cColorBits > 4 )
        {
            VOID *pvDib;
            UINT cjPixel = gengc->gsurf.pfd.cColorBits >> 3;

            pvDib = (VOID *) (((BYTE *) gengc->gc.front->buf.base) +
                              gengc->gc.front->buf.outerWidth * y +
                              cjPixel * x);

            if ( gengc->gsurf.pfd.cColorBits == 8 )
                *((BYTE *) pvDib) = gengc->pajTranslateVector[dwColor];
            else
            {
                GLuint *pTrans = ((GLuint *) gengc->pajTranslateVector) + 1;

                dwColor &= cfb->redMax;

                switch (gengc->gsurf.pfd.cColorBits)
                {
                case 16:
                    *((WORD *) pvDib) = (WORD) pTrans[dwColor];
                    break;
                case 24:
                    Copy3Bytes(pvDib, &(pTrans[dwColor]));
                    break;
                case 32:
                    *((DWORD *) pvDib) = (DWORD) pTrans[dwColor];
                    break;
                default:
                    WARNING1("dibSetPixelCI: bad cColorBits = %ld\n",
                             gengc->gsurf.pfd.cColorBits);
                    break;
                }
            }
        }
        else
        {
            BYTE *puj = (BYTE *)((ULONG_PTR)cfb->buf.base +
                              (y*cfb->buf.outerWidth) + (x >> 1));

            dwColor = gengc->pajTranslateVector[dwColor & 0xf] & 0xf;
            if( x & 1 )
                *puj = (*puj & 0xf0) | (BYTE) dwColor;
            else
                *puj = (*puj & 0x0f) | (BYTE) (dwColor << 4);
        }
    }
}

/*
** No dither, no logicOp.
*/
static void FASTCALL Store(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    __GLcontext *gc      = cfb->buf.gc;
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    COLORREF Cr;
    DWORD index;

    DBGLEVEL(32, "Store(CI)\n");

    index = (DWORD) (frag->color.r + __glHalf);

    Cr = PALETTEINDEX(index);

    x = __GL_UNBIAS_X(gc, frag->x);
    y = __GL_UNBIAS_Y(gc, frag->y);

    if ( !(genGc->fsLocks & LOCKFLAG_FRONT_BUFFER) )
        SetPixel( CURRENT_DC, x, y, Cr );
    else
        dibSetPixelCI(genGc, cfb, x, y, index);

}
/* XXX! The Store_* routines do not handle double buffering.  Gilman
	has said that they will not be compatible with his 'cursor
	tear-down' strategy.  Therefore we probably won't use them.
	BUT, they are about 30% faster than their Display*Store
	counterparts, so we'll keep them around for further study
*/

/*
** Dither, no logicOp.
*/
static void FASTCALL Store_D(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    __GLcontext *gc      = cfb->buf.gc;
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    COLORREF Cr;
    DWORD index;


    DBGLEVEL(32, "Store_D\n");

    index = (DWORD) (frag->color.r + __glHalf);

    Cr = PALETTEINDEX(index);

    x = __GL_UNBIAS_X(gc, frag->x);
    y = __GL_UNBIAS_Y(gc, frag->y);

    if ( !(genGc->fsLocks & LOCKFLAG_FRONT_BUFFER) )
        SetPixel( CURRENT_DC, x, y, Cr );
    else
        dibSetPixelCI(genGc, cfb, x, y, index);
}

/*
** No dither, logicOp
*/
static void FASTCALL Store_L(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    __GLcontext *gc      = cfb->buf.gc;
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    COLORREF Cr;
    DWORD index;

    DBGLEVEL(32, "Store_L\n");

    index = (DWORD) (frag->color.r + __glHalf);

    Cr = PALETTEINDEX(index);

    x = __GL_UNBIAS_X(gc, frag->x);
    y = __GL_UNBIAS_Y(gc, frag->y);

    if ( !(genGc->fsLocks & LOCKFLAG_FRONT_BUFFER) )
        SetPixel( CURRENT_DC, x, y, Cr );
    else
        dibSetPixelCI(genGc, cfb, x, y, index);
}

/*
** Dither, logicOp
*/
static void FASTCALL Store_DL(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    __GLcontext *gc      = cfb->buf.gc;
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    COLORREF Cr;
    DWORD index;

    DBGLEVEL(32, "Store_DL\n");

    index = (DWORD) (frag->color.r + __glHalf);

    Cr = PALETTEINDEX(index);

    x = __GL_UNBIAS_X(gc, frag->x);
    y = __GL_UNBIAS_Y(gc, frag->y);

    if ( !(genGc->fsLocks & LOCKFLAG_FRONT_BUFFER) )
        SetPixel( CURRENT_DC, x, y, Cr );
    else
        dibSetPixelCI(genGc, cfb, x, y, index);
}

GLuint FASTCALL ColorToIndex( __GLGENcontext *genGc, GLuint color )
{
    int i, imax;
    GLuint *pTrans = (GLuint *) genGc->pajTranslateVector;

    color &= genGc->gc.modes.rgbMask;

    imax = *pTrans++;  // first element of pTrans is # entries

    for( i=0; i<imax; i++ ) {
	if( color == *pTrans++ )
	    return i;
    }
    return 0;
}

GLuint FASTCALL DoLogicOp( GLenum logicOp, GLuint SrcColor, GLuint DstColor )
{
    GLuint result;

    switch (logicOp) {
	case GL_CLEAR:         result = 0; break;
	case GL_AND:           result = SrcColor & DstColor; break;
	case GL_AND_REVERSE:   result = SrcColor & (~DstColor); break;
	case GL_COPY:          result = SrcColor; break;
	case GL_AND_INVERTED:  result = (~SrcColor) & DstColor; break;
	case GL_NOOP:          result = DstColor; break;
	case GL_XOR:           result = SrcColor ^ DstColor; break;
	case GL_OR:            result = SrcColor | DstColor; break;
	case GL_NOR:           result = ~(SrcColor | DstColor); break;
	case GL_EQUIV:         result = ~(SrcColor ^ DstColor); break;
	case GL_INVERT:        result = ~DstColor; break;
	case GL_OR_REVERSE:    result = SrcColor | (~DstColor); break;
	case GL_COPY_INVERTED: result = ~SrcColor; break;
	case GL_OR_INVERTED:   result = (~SrcColor) | DstColor; break;
	case GL_NAND:          result = ~(SrcColor & DstColor); break;
	case GL_SET:           result = (GLuint)~0; break;
    }
    return result;
}

/************************************************************************/

void FASTCALL DIBIndex4CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;
    GLubyte index;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    if ( (cfb->buf.flags & NO_CLIP) ||
            (*gengc->pfnPixelVisible)(x, y) ) {
    	index = (BYTE) (frag->color.r + inc);
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x >> 1));

	if( cfb->buf.flags & NEED_FETCH ) {
	    GLubyte DstIndex;

            if (x & 1)
                DstIndex = gengc->pajInvTranslateVector[*puj & 0x0f];
            else
                DstIndex = gengc->pajInvTranslateVector[(*puj & 0xf0) >> 4];

    	    // apply logicop

    	    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
                
	        index = (GLubyte) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex );
                index &= 0xf;
    	    }

    	    // apply indexmask

	    if( cfb->buf.flags & INDEXMASK_ON ) {
		index = (GLubyte)((index & cfb->sourceMask) | (DstIndex & cfb->destMask));
	    }
	}
	index = gengc->pajTranslateVector[index & 0xf] & 0xf;
	if( x & 1 )
	    *puj = (*puj & 0xf0) | index;
	else
	    *puj = (*puj & 0x0f) | (index << 4);
    }
}

// Put fragment into created DIB and call copybits for one pixel
void FASTCALL DisplayIndex4CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;
    GLubyte index;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    index = (BYTE) (frag->color.r + inc);
    puj = gengc->ColorsBits;

    if( cfb->buf.flags & NEED_FETCH ) {
        GLubyte DstIndex;

        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        DstIndex = gengc->pajInvTranslateVector[(*puj & 0xf0) >> 4];

        // apply logicop

        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {

            index = (GLubyte) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex );
            index &= 0xf;
        }

        // apply indexmask

        if( cfb->buf.flags & INDEXMASK_ON ) {
            index = (GLubyte)((index & cfb->sourceMask) | (DstIndex & cfb->destMask));
        }
    }
    *puj = gengc->pajTranslateVector[index & 0xf] << 4;
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);
}

/************************************************************************/

void FASTCALL DIBIndex8CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;
    GLubyte index;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    if ( (cfb->buf.flags & NO_CLIP) ||
            (*gengc->pfnPixelVisible)(x, y) ) {
    	index = (BYTE) (frag->color.r + inc);
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);

	if( cfb->buf.flags & NEED_FETCH ) {
	    GLubyte DstIndex = gengc->pajInvTranslateVector[*puj];

    	    // apply logicop

    	    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {

	        index = (GLubyte) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex );
    	    }

    	    // apply indexmask

	    if( cfb->buf.flags & INDEXMASK_ON ) {
                index = (GLubyte)((DstIndex & cfb->destMask) | (index & cfb->sourceMask));
	    }
	}

        *puj = gengc->pajTranslateVector[index];
    }
}

/************************************************************************/

void FASTCALL DisplayIndex8CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;
    GLubyte index;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    index = (BYTE) (frag->color.r + inc);
    puj = gengc->ColorsBits;

    if( cfb->buf.flags & NEED_FETCH ) {
        GLubyte DstIndex;

        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        DstIndex = gengc->pajInvTranslateVector[*puj];

        // apply logicop

        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
            index = (GLubyte) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex );
        }

        // apply indexmask

        if( cfb->buf.flags & INDEXMASK_ON ) {
            index = (GLubyte)((DstIndex & cfb->destMask) | (index & cfb->sourceMask));
        }
    }

    *puj = gengc->pajTranslateVector[index];
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);
}

/************************************************************************/

void FASTCALL DIBRGBCIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint index;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    GLuint color, *pTrans;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    if ( (cfb->buf.flags & NO_CLIP) ||
            (*gengc->pfnPixelVisible)(x, y) ) {

    	index = (GLuint) (frag->color.r + __glHalf);
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x * 3));
        pTrans = ((GLuint *) gengc->pajTranslateVector) + 1;

	if( cfb->buf.flags & NEED_FETCH ) {
    	    GLuint DstIndex; // represents both RGB and index

	    Copy3Bytes( &DstIndex, puj );
	    DstIndex = ColorToIndex( gengc, DstIndex );

    	    // apply logicop

    	    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
	        index = (GLuint) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex);
    	    }

    	    // apply indexmask

	    if( cfb->buf.flags & INDEXMASK_ON ) {
                index = ((GLuint) DstIndex & cfb->destMask) |
		        (index & cfb->sourceMask);
	    }
	}
	index &= cfb->redMax;     // ceiling
	color = pTrans[index];  // guaranteed to be in range
	Copy3Bytes( puj, &color );
    }
}

/************************************************************************/

void FASTCALL DisplayRGBCIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint index, color, *pTrans;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    index = (GLuint) (frag->color.r + __glHalf);
    puj = gengc->ColorsBits;
    pTrans = (GLuint *) gengc->pajTranslateVector;

    if( cfb->buf.flags & NEED_FETCH ) {
        GLuint DstIndex; // represents both RGB and index

        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        Copy3Bytes( &DstIndex, puj );
        DstIndex = ColorToIndex( gengc, DstIndex );

        // apply logicop

        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
            index = (GLuint) DoLogicOp( gc->state.raster.logicOp, 
                                        (GLuint) index, (GLuint) DstIndex );
        }

        // apply indexmask

        if( cfb->buf.flags & INDEXMASK_ON ) {
            index = ((GLuint) DstIndex & cfb->destMask) |
                (index & cfb->sourceMask);
        }
    }

    // Get RGB values that correspond to index

    index &= cfb->redMax; // ceiling
    color = pTrans[index+1];  // guaranteed to be in range
    Copy3Bytes( puj, &color );
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);
}

/************************************************************************/

void FASTCALL DIBBitfield16CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLushort index, *pus;
    GLuint *pTrans;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    if ( (cfb->buf.flags & NO_CLIP) ||
            (*gengc->pfnPixelVisible)(x, y) ) {

    	index = (GLushort) (frag->color.r + inc);
        pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 1));
        pTrans = (GLuint *) gengc->pajTranslateVector;

	if( cfb->buf.flags & NEED_FETCH ) {
    	    GLushort DstIndex; // represents both RGB and index

            DstIndex = *pus;
	    DstIndex = (GLushort) ColorToIndex( gengc, (GLuint) DstIndex );

    	    // apply logicop

    	    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
	        index = (GLushort) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex);
    	    }

    	    // apply indexmask

	    if( cfb->buf.flags & INDEXMASK_ON ) {
                index = (GLushort)((DstIndex & cfb->destMask) | (index & cfb->sourceMask));
	    }
	}
	index &= cfb->redMax;
	*pus = (GLushort) pTrans[index+1];
    }
}

// Put fragment into created DIB and call copybits for one pixel
void FASTCALL DisplayBitfield16CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLushort index, *pus;
    GLuint *pTrans;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    index = (GLushort) (frag->color.r + inc);
    pus = gengc->ColorsBits;
    pTrans = (GLuint *) gengc->pajTranslateVector;

    if( cfb->buf.flags & NEED_FETCH ) {
        GLushort DstIndex; // represents both RGB and index

        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        DstIndex = *pus;
        DstIndex = (GLushort) ColorToIndex( gengc, (GLuint) DstIndex );

        // apply logicop

        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
            index = (GLushort) DoLogicOp( gc->state.raster.logicOp, 
                                          (GLuint) index, (GLuint) DstIndex);
        }

        // apply indexmask

        if( cfb->buf.flags & INDEXMASK_ON ) {
            index = (GLushort)((DstIndex & cfb->destMask) | (index & cfb->sourceMask));
        }
    }
    index &= cfb->redMax;
    *pus = (GLushort) pTrans[index+1];
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);
}

/************************************************************************/

void FASTCALL DIBBitfield32CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLuint index, *pul, *pTrans;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    if ( (cfb->buf.flags & NO_CLIP) ||
            (*gengc->pfnPixelVisible)(x, y) ) {

    	index = (GLuint) (frag->color.r + __glHalf);
        pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 2));
        pTrans = ((GLuint *) gengc->pajTranslateVector) + 1;

	if( cfb->buf.flags & NEED_FETCH ) {
    	    GLuint DstIndex; // represents both RGB and index

            DstIndex = ColorToIndex( gengc, *pul );

    	    // apply logicop

    	    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
	        index = (GLuint) DoLogicOp( gc->state.raster.logicOp, index,
						 DstIndex );
    	    }

    	    // apply indexmask

	    if( cfb->buf.flags & INDEXMASK_ON ) {
                index = (GLuint)((DstIndex & cfb->destMask) | (index & cfb->sourceMask));
	    }
	}
	index &= cfb->redMax;
	*pul = pTrans[index];
    }
}

// Put fragment into created DIB and call copybits for one pixel
void FASTCALL DisplayBitfield32CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLuint index, *pul, *pTrans;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    index = (GLuint) (frag->color.r + __glHalf);
    pul = gengc->ColorsBits;
    pTrans = ((GLuint *) gengc->pajTranslateVector) + 1;

    if( cfb->buf.flags & NEED_FETCH ) {
        GLuint DstIndex; // represents both RGB and index

        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        DstIndex = ColorToIndex( gengc, *pul );
 
        // apply logicop

        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
            index = (GLuint) DoLogicOp( gc->state.raster.logicOp, index,
                                        DstIndex );
        }

        // apply indexmask

        if( cfb->buf.flags & INDEXMASK_ON ) {
            index = (DstIndex & cfb->destMask) | (index & cfb->sourceMask);
        }
    }
    index &= cfb->redMax;
    *pul = pTrans[index];
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);
}

/************************************************************************/

static GLboolean FASTCALL SlowStoreSpan(__GLcontext *gc)
{
    int x, x1;
    int i;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint w;

    DBGENTRY("CI:StoreSpan\n");

    w = gc->polygon.shader.length;

    frag.y = gc->polygon.shader.frag.y;
    x = gc->polygon.shader.frag.x;
    x1 = gc->polygon.shader.frag.x + w;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    for (i = x; i < x1; i++) {
        frag.x = i;
        frag.color.r = cp->r;
        cp++;

        (*cfb->store)(cfb, &frag);
    }

    return GL_FALSE;
}


static GLboolean FASTCALL SlowStoreStippledSpan(__GLcontext *gc)
{
    int x;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    __GLstippleWord inMask, bit, *sp;
    GLint count;
    GLint w;

    DBGENTRY("CI:StoreStippledSpan\n");

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    frag.y = gc->polygon.shader.frag.y;
    x = gc->polygon.shader.frag.x;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp++;
        bit = (GLuint) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                frag.x = x;
                frag.color.r = cp->r;

                (*cfb->store)(cfb, &frag);
            }
            x++;
            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
    }

    return GL_FALSE;
}

void
CIFetchNone(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    result->r = 0.0F;
}

void
CIReadSpanNone(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                GLint w)
{
    GLint i;
    __GLcolor *pResults;

    for (i = 0, pResults = results; i < w; i++, pResults++)
    {
        pResults->r = 0.0F;
    }
}       
                    
void
DIBIndex4CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x >> 1));

    pixel = *puj;
    if (!(x & 1))
        pixel >>= 4;

    result->r = (__GLfloat) gengc->pajInvTranslateVector[pixel & 0xf];
}

void
DIBIndex8CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);

    result->r = (__GLfloat) gengc->pajInvTranslateVector[*puj];
}

void
DIBRGBCIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                         (y*cfb->buf.outerWidth) + (x * 3));
    Copy3Bytes( &iColor, puj );
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
DIBBitfield16CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 1));
    iColor = (GLuint) *pus;
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
DIBBitfield32CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                        (y*cfb->buf.outerWidth) + (x << 2));
    iColor = *pul; // need to clamp to <= 24 bits ?
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
DisplayIndex4CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    pixel = *puj >> 4;
    result->r = (__GLfloat) gengc->pajInvTranslateVector[pixel];
}

void
DisplayIndex8CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    result->r = (__GLfloat) gengc->pajInvTranslateVector[*puj];
}

void
DisplayRGBCIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    Copy3Bytes( &iColor, puj );
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
DisplayBitfield16CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                         __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    pus = gengc->ColorsBits;
    iColor = (GLuint) *pus;
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
DisplayBitfield32CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                         __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    pul = gengc->ColorsBits;
    iColor = *pul; // need to clamp to <= 24 bits ?
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
Index4CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                 GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;
    __GLcolor *pResults;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if (bDIB)
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) +
                          (x >> 1));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
        x = 0;
    }
    pResults = results;
    if (x & 1)
    {
        pixel = *puj++;
        pResults->r = (__GLfloat) gengc->pajInvTranslateVector[pixel & 0xf];
        pResults++;
        w--;
    }
    while (w > 1)
    {
        pixel = *puj >> 4;
        pResults->r = (__GLfloat) gengc->pajInvTranslateVector[pixel];
        pResults++;
        pixel = *puj++;
        pResults->r = (__GLfloat) gengc->pajInvTranslateVector[pixel & 0xf];
        pResults++;
        w -= 2;
    }
    if (w > 0)
    {
        pixel = *puj >> 4;
        pResults->r = (__GLfloat) gengc->pajInvTranslateVector[pixel];
    }        
}

void
DIBIndex4CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                    GLint w)
{
    Index4CIReadSpan(cfb, x, y, results, w, TRUE);
}
    		 
void
DisplayIndex4CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                         __GLcolor *results, GLint w)
{
    Index4CIReadSpan(cfb, x, y, results, w, FALSE);
}

void
Index8CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                 GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;
    GLint i;
    __GLcolor *pResults;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if (bDIB)
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }
    for (i = 0, pResults = results; i < w; i++, pResults++)
    {
        pResults->r = (__GLfloat) gengc->pajInvTranslateVector[*puj++];
    }
}

void    
DIBIndex8CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                    GLint w)
{
    Index8CIReadSpan(cfb, x, y, results, w, TRUE);
}
  		     
void    
DisplayIndex8CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                        __GLcolor *results, GLint w)
{
    Index8CIReadSpan(cfb, x, y, results, w, FALSE);
}

void
RGBCIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
              GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;
    GLint i;
    __GLcolor *pResults;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if (bDIB)
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                         (y*cfb->buf.outerWidth) + (x * 3));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }
    for (i = 0, pResults = results; i < w; i++, pResults++, puj += 3)
    {
	Copy3Bytes( &iColor, puj );
	pResults->r = (float) ColorToIndex( gengc, iColor );
    }
}

void    
DIBRGBCIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                 GLint w)
{
    RGBCIReadSpan(cfb, x, y, results, w, TRUE);
}
  		     
void    
DisplayRGBCIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                     GLint w)
{
    RGBCIReadSpan(cfb, x, y, results, w, FALSE);
}

void
Bitfield16CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                     __GLcolor *results, GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus;
    GLint i;
    __GLcolor *pResults;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if (bDIB)
    {
        pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 1));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        pus = gengc->ColorsBits;
    }
    for (i = 0, pResults = results; i < w; i++, pResults++)
    {
        iColor = *pus++;
        pResults->r = (__GLfloat) ColorToIndex( gengc, iColor );
    }
}

void    
DIBBitfield16CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                        __GLcolor *results, GLint w)
{
    Bitfield16CIReadSpan(cfb, x, y, results, w, TRUE);
}
  		     
void    
DisplayBitfield16CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                            __GLcolor *results, GLint w)
{
    Bitfield16CIReadSpan(cfb, x, y, results, w, FALSE);
}

void
Bitfield32CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                     __GLcolor *results, GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul;
    GLint i;
    __GLcolor *pResults;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if (bDIB)
    {
        pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 2));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        pul = gengc->ColorsBits;
    }
    for (i = 0, pResults = results; i < w; i++, pResults++)
    {
        iColor = *pul++;
        pResults->r = (__GLfloat) ColorToIndex( gengc, iColor );
    }
}

void    
DIBBitfield32CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                        __GLcolor *results, GLint w)
{
    Bitfield32CIReadSpan(cfb, x, y, results, w, TRUE);
}
  		     
void    
DisplayBitfield32CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                            __GLcolor *results, GLint w)
{
    Bitfield32CIReadSpan(cfb, x, y, results, w, FALSE);
}

/************************************************************************/

static void Resize(__GLGENbuffers *buffers, __GLcolorBuffer *cfb,
                   GLint w, GLint h)
{
    DBGENTRY("CI:Resize\n");

#ifdef __GL_LINT
    dp = dp;
#endif
    cfb->buf.width = w;
    cfb->buf.height = h;
}

/************************************************************************/

static void (FASTCALL *StoreProcs[4])(__GLcolorBuffer*, const __GLfragment*) = {
    Store,
    Store_D,
    Store_L,
    Store_DL,
};

void FASTCALL PickCI(__GLcontext *gc, __GLcolorBuffer *cfb)
{
    GLuint enables = gc->state.enables.general;
    GLint ix = 0;
    __GLGENcontext *gengc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLboolean needFetch = GL_FALSE;

    DBGENTRY("PickCI\n");

    /* predetermine if fetch required for Store procs: we'll assume 
       always need to if logicOp or indexMask (i.e: assume if needFetch
       not set, then no logicOp or indexMask used)
    */

    if( gc->state.raster.writeMask == cfb->redMax ) {
        cfb->buf.flags = cfb->buf.flags & ~INDEXMASK_ON;
    	cfb->sourceMask = cfb->redMax;  // mf: these 2 may not be needed
    	cfb->destMask = ~cfb->sourceMask;
    } else {
    	cfb->sourceMask = gc->state.raster.writeMask & cfb->redMax;
    	cfb->destMask = ~cfb->sourceMask & cfb->redMax;
        cfb->buf.flags = cfb->buf.flags | INDEXMASK_ON;
	needFetch = GL_TRUE;
    }
	
    if (enables & __GL_DITHER_ENABLE) {
        ix |= 1;
    }
    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
        ix |= 2;
	needFetch = GL_TRUE; // don't need to fetch for some logicOps, but
			     // we'll deal with that later
    }
	
    if( needFetch )
    	cfb->buf.flags = cfb->buf.flags | NEED_FETCH;
    else
    	cfb->buf.flags = cfb->buf.flags & ~NEED_FETCH;

    cfb->store = StoreProcs[ix];

    // Figure out store and fetch routines
    if (gc->state.raster.drawBuffer == GL_NONE)
    {
        cfb->store = Store_NOT;
        cfb->fetch = CIFetchNone;
        cfb->readColor = CIFetchNone;
        cfb->readSpan = CIReadSpanNone;
        cfb->storeSpan = StoreSpanNone;
        cfb->storeStippledSpan = StoreSpanNone;
    }
    else
    {
        gengc = (__GLGENcontext *)gc;
        pfmt = &gengc->gsurf.pfd;
        if (cfb->buf.flags & DIB_FORMAT)
        {
            switch(pfmt->cColorBits) {

            case 4:
                cfb->fetch = DIBIndex4CIFetch;
                cfb->readColor = DIBIndex4CIFetch;
                cfb->readSpan = DIBIndex4CIReadSpan;
    		cfb->store = DIBIndex4CIStore;
		cfb->clear = Index4Clear;
                break;

            case 8:
                cfb->fetch = DIBIndex8CIFetch;
                cfb->readColor = DIBIndex8CIFetch;
                cfb->readSpan = DIBIndex8CIReadSpan;
    		cfb->store = DIBIndex8CIStore;
		cfb->clear = Index8Clear;
                break;

            case 16:
                cfb->fetch = DIBBitfield16CIFetch;
                cfb->readColor = DIBBitfield16CIFetch;
                cfb->readSpan = DIBBitfield16CIReadSpan;
    		cfb->store = DIBBitfield16CIStore;
		cfb->clear = Bitfield16Clear;
                break;

            case 24:
                cfb->readSpan = DIBRGBCIReadSpan;
                cfb->readColor = DIBRGBCIFetch;
                cfb->fetch = DIBRGBCIFetch;
		cfb->store = DIBRGBCIStore;
		cfb->clear = RGBClear;
                break;

            case 32:
                cfb->fetch = DIBBitfield32CIFetch;
                cfb->readColor = DIBBitfield32CIFetch;
                cfb->readSpan = DIBBitfield32CIReadSpan;
    		cfb->store = DIBBitfield32CIStore;
		cfb->clear = Bitfield32Clear;
                break;
            }
        }
        else
        {
            switch(pfmt->cColorBits) {

            case 4:
                cfb->fetch = DisplayIndex4CIFetch;
                cfb->readColor = DisplayIndex4CIFetch;
                cfb->readSpan = DisplayIndex4CIReadSpan;
    		cfb->store = DisplayIndex4CIStore;
		cfb->clear = Index4Clear;
                break;

            case 8:
                cfb->fetch = DisplayIndex8CIFetch;
                cfb->readColor = DisplayIndex8CIFetch;
                cfb->readSpan = DisplayIndex8CIReadSpan;
    		cfb->store = DisplayIndex8CIStore;
		cfb->clear = Index8Clear;
                break;
    
            case 16:
                cfb->fetch = DisplayBitfield16CIFetch;
                cfb->readColor = DisplayBitfield16CIFetch;
                cfb->readSpan = DisplayBitfield16CIReadSpan;
    		cfb->store = DisplayBitfield16CIStore;
		cfb->clear = Bitfield16Clear;
                break;

            case 24:
                cfb->readSpan = DisplayRGBCIReadSpan;
                cfb->fetch = DisplayRGBCIFetch;
                cfb->readColor = DisplayRGBCIFetch;
		cfb->store = DisplayRGBCIStore;
		cfb->clear = RGBClear;
                break;

            case 32:
                cfb->fetch = DisplayBitfield32CIFetch;
                cfb->readColor = DisplayBitfield32CIFetch;
                cfb->readSpan = DisplayBitfield32CIReadSpan;
    		cfb->store = DisplayBitfield32CIStore;
		cfb->clear = Bitfield32Clear;
                break;
            }
        }
    }
}

void FASTCALL __glGenInitCI(__GLcontext *gc, __GLcolorBuffer *cfb, GLenum type)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;

    DBGENTRY("__glGenInitCI\n");

    __glInitGenericCB(gc, cfb);

    cfb->pick       = PickCI;
    gc->redVertexScale   = cfb->redScale   = (__GLfloat)1.0;
    gc->greenVertexScale = cfb->greenScale = (__GLfloat)1.0;
    gc->blueVertexScale  = cfb->blueScale  = (__GLfloat)1.0;
    gc->alphaVertexScale = cfb->alphaScale = (__GLfloat)1.0;

    cfb->buf.elementSize   = sizeof(GLubyte);
    cfb->resize            = Resize;
    cfb->fetchSpan         = __glFetchSpan;
    cfb->fetchStippledSpan = __glFetchSpan;
    cfb->storeSpan         = SlowStoreSpan;
    cfb->storeStippledSpan = SlowStoreStippledSpan;

    pfmt = &gengc->gsurf.pfd;

/* XXX! redMax is used for index lighting in soft, and for setting 
    raster.writeMask
*/
    cfb->redMax = (1 << gc->modes.indexBits) - 1;
    cfb->redShift = pfmt->cRedShift;
    cfb->greenShift = pfmt->cGreenShift;
    cfb->blueShift = pfmt->cBlueShift;
    cfb->allShifts =
        (cfb->redShift << 0) |
        (cfb->greenShift << 8) |
        (cfb->blueShift << 16) |
        (cfb->alphaShift << 24);

    glGenInitCommon(gengc, cfb, type);

}

void FASTCALL __glGenFreeCI(__GLcontext *gc, __GLcolorBuffer *cfb)
{

    DBGENTRY("__glGenFreeCI\n");

#ifdef __GL_LINT
    gc = gc;
    cfb = cfb;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genaccum.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include "devlock.h"

void APIPRIVATE __glim_Accum(GLenum op, GLfloat value)
{
    __GLaccumBuffer *fb;
    __GL_SETUP();
    GLuint beginMode;
    void (*accumOp)(__GLaccumBuffer *fb, __GLfloat val);

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	    __glim_Accum(op,value);
	    return;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

    fb = &gc->accumBuffer;
    if (!gc->modes.accumBits || gc->modes.colorIndexMode) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }
    if (!gc->modes.haveAccumBuffer) {
        LazyAllocateAccum(gc);
        if (!gc->modes.haveAccumBuffer)	// LazyAllocate failed
            return;
    }
    switch (op) {
      case GL_ACCUM:
        accumOp = fb->accumulate;
	break;
      case GL_LOAD:
        accumOp = fb->load;
	break;
      case GL_RETURN:
        accumOp = fb->ret;
	break;
      case GL_MULT:
        accumOp = fb->mult;
	break;
      case GL_ADD:
        accumOp = fb->add;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    if (gc->renderMode == GL_RENDER) {
        BOOL bResetViewportAdj = FALSE;

        if (((__GLGENcontext *)gc)->pMcdState) {
            //
            // MCD does not hook glBitmap, so we go straight to the
            // simulations.  Therefore, if we are grabbing the device
            // lock lazily, we need to grab it now.
            //

	    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc,
                                       COLOR_LOCK_FLAGS)) {
                __glSetError(GL_OUT_OF_MEMORY);
                return;
            }

            //
            // We may need to temporarily reset the viewport adjust values
            // before calling simulations.  If GenMcdResetViewportAdj returns
            // TRUE, the viewport is changed and we need restore later with
            // VP_NOBIAS.
            //

            bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
        }

        (*accumOp)(fb, value);

        //
        // Restore viewport values if needed.
        //

        if (bResetViewportAdj)
        {
            GenMcdResetViewportAdj(gc, VP_NOBIAS);
        }
    }
}


/************************************************************************/

static void FASTCALL Pick(__GLcontext *gc, __GLaccumBuffer *afb)
{
#ifdef __GL_LINT
    gc = gc;
    afb = afb;
#endif
}

static void Load32(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, ow, skip;
    GLint redShift, greenShift, blueShift;
    GLuint redMask, greenMask, blueMask;
    __GLfloat rval, gval, bval;
    GLuint *ac;
    __GLcolorBuffer *cfb;
    __GLcolor *cbuf;

    __GLuicolor *shift, *mask, *sign;
    __GLcolor cval, *cp;
    GLint i;

    shift = &afb->shift;
    mask  = &afb->mask;
    sign  = &afb->sign;
    cval.r = val * afb->redScale;
    cval.g = val * afb->greenScale;
    cval.b = val * afb->blueScale;
    cval.a = val * afb->alphaScale;
    
    w = x1 - x0;
    cbuf = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
    if (!cbuf)
        return;

    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    cfb = gc->readBuffer;
    ow = w;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;

    for (; y0 < y1; y0++, ac+= skip ) {
	__GLcolor *cp = &cbuf[0];
	(*cfb->readSpan)(cfb, x0, y0, &cbuf[0], w);

        if( ! gc->modes.alphaBits ) {
	    for( i = 0; i < w; i++, ac++, cp++ ) {
	        *ac = (((GLuint)(cp->r * cval.r) & mask->r) << shift->r) |
	                (((GLuint)(cp->g * cval.g) & mask->g) << shift->g) |
	                (((GLuint)(cp->b * cval.b) & mask->b) << shift->b);
	    }
        } else 
            // accum buffer has alpha component
	    for( i = 0; i < w; i++, ac++, cp++ ) {
	        *ac = (((GLuint)(cp->r * cval.r) & mask->r) << shift->r) |
	                (((GLuint)(cp->g * cval.g) & mask->g) << shift->g) |
	                (((GLuint)(cp->b * cval.b) & mask->b) << shift->b) |
	                (((GLuint)(cp->a * cval.a) & mask->a) << shift->a);
	    }
        }
    gcTempFree(gc, cbuf);
}

// Macros for accumulation operations on color components

#define ACCUM_ACCUM_MASKED_COLOR_COMPONENT( col, fbcol, shift, sign, mask, val) \
    col = (*ac >> shift) & mask; \
    if (col & sign) \
        col |= ~mask; \
    col += (GLint) (fbcol * val);

#define ACCUM_ADD_MASKED_COLOR_COMPONENT( col, shift, sign, mask, val) \
    col = (*ac >> shift) & mask; \
    if (col & sign) \
	col |= ~mask; \
    col = (GLint) (col + val);

#define ACCUM_MULT_MASKED_COLOR_COMPONENT( col, shift, sign, mask, val) \
    col = (*ac >> shift) & mask; \
    if (col & sign) \
        col |= ~mask; \
    col = (GLint) (col * val);

static void Accumulate32(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, ow, skip, w4, w1;
    GLint r, g, b;
    GLuint *ac, acVal;
    __GLfloat rval, gval, bval;
    __GLcolorBuffer *cfb;
    __GLcolor *cbuf;
    __GLuicolor *shift, *mask, *sign;
    __GLcolor cval, *cp;
    GLint a;

    shift = &afb->shift;
    mask  = &afb->mask;
    sign  = &afb->sign;
    cval.r = val * afb->redScale;
    cval.g = val * afb->greenScale;
    cval.b = val * afb->blueScale;
    cval.a = val * afb->alphaScale;

    w = x1 - x0;
    cbuf = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
    if (!cbuf)
        return;

    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    cfb = gc->readBuffer;
    ow = w;
    skip = afb->buf.outerWidth - w;

    for (; y0 < y1; y0++, ac+= skip ) {
	(*cfb->readSpan)(cfb, x0, y0, &cbuf[0], ow);

        cp = &cbuf[0];
        if( ! gc->modes.alphaBits ) {

	    for( w = ow; w; w--, ac++, cp++ ) {

                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( r, cp->r, shift->r, sign->r, 
                                              mask->r, cval.r);
                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( g, cp->g, shift->g, sign->g, 
                                              mask->g, cval.g);
                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( b, cp->b, shift->b, sign->b, 
                                              mask->b, cval.b);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b);
	    }

	} else {

	    for( w = ow; w; w--, ac++, cp++ ) {

                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( r, cp->r, shift->r, sign->r, 
                                              mask->r, cval.r);
                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( g, cp->g, shift->g, sign->g, 
                                              mask->g, cval.g);
                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( b, cp->b, shift->b, sign->b, 
                                              mask->b, cval.b);
                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( a, cp->a, shift->a, sign->a, 
                                              mask->a, cval.a);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b) |
                        ((a & mask->a) << shift->a);
	    }

        }
    }
    gcTempFree(gc, cbuf);
}

static void Mult32(__GLaccumBuffer *afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    GLuint acVal, *ac;
    GLint r, g, b;

    __GLuicolor *shift, *mask, *sign;
    GLint i;
    GLint a;

    shift = &afb->shift;
    mask  = &afb->mask;
    sign  = &afb->sign;
    
    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    w = x1 - x0;
    skip = afb->buf.outerWidth - w;

    if (val == __glZero) {
	/* Zero out the buffers contents */
	for (; y0 < y1; y0++) {
	    GLint ww = w;
	    while (ww > 0) {
		*ac++ = 0;
		ww--;
	    }
	    ac += skip;
	}
	return;
    }

    w4 = w >> 2;
    w1 = w & 3;
    for (; y0 < y1; y0++, ac+= skip) {
        if( ! gc->modes.alphaBits ) {

    	    for( i = 0; i < w; i++, ac++ ) {
                ACCUM_MULT_MASKED_COLOR_COMPONENT( r, shift->r, sign->r, 
                                              mask->r, val);
                ACCUM_MULT_MASKED_COLOR_COMPONENT( g, shift->g, sign->g, 
                                              mask->g, val);
                ACCUM_MULT_MASKED_COLOR_COMPONENT( b, shift->b, sign->b, 
                                              mask->b, val);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b);
            }
        } else {
	    for( i = 0; i < w; i++, ac++ ) {
                ACCUM_MULT_MASKED_COLOR_COMPONENT( r, shift->r, sign->r, 
                                              mask->r, val);
                ACCUM_MULT_MASKED_COLOR_COMPONENT( g, shift->g, sign->g, 
                                              mask->g, val);
                ACCUM_MULT_MASKED_COLOR_COMPONENT( b, shift->b, sign->b, 
                                              mask->b, val);
                ACCUM_MULT_MASKED_COLOR_COMPONENT( a, shift->a, sign->a, 
                                              mask->a, val);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b) |
                        ((a & mask->a) << shift->a);
            }
        }
    }
}

static void Add32(__GLaccumBuffer *afb, __GLfloat value)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    GLint rval, gval, bval;
    GLuint acVal, *ac;
    GLint r, g, b;

    __GLuicolor *shift, *mask, *sign;
    __GLicolor cval;
    GLint i;
    GLint a;

    shift = &afb->shift;
    mask  = &afb->mask;
    sign  = &afb->sign;
    cval.r = (GLint)
	(value * gc->frontBuffer.redScale * afb->redScale + __glHalf);
    cval.g = (GLint)
	(value * gc->frontBuffer.greenScale * afb->greenScale + __glHalf);
    cval.b = (GLint)
	(value * gc->frontBuffer.blueScale * afb->blueScale + __glHalf);
    cval.a = (GLint)
	(value * gc->frontBuffer.alphaScale * afb->alphaScale + __glHalf);

    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    w = x1 - x0;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;

    for (; y0 < y1; y0++, ac+= skip) {
        if( ! gc->modes.alphaBits ) {

    	    for( i = 0; i < w; i++, ac++ ) {
                ACCUM_ADD_MASKED_COLOR_COMPONENT( r, shift->r, sign->r, 
                                              mask->r, cval.r);
                ACCUM_ADD_MASKED_COLOR_COMPONENT( g, shift->g, sign->g, 
                                              mask->g, cval.g);
                ACCUM_ADD_MASKED_COLOR_COMPONENT( b, shift->b, sign->b, 
                                              mask->b, cval.b);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b);
            }
        } else {
	    for( i = 0; i < w; i++, ac++ ) {
                ACCUM_ADD_MASKED_COLOR_COMPONENT( r, shift->r, sign->r, 
                                              mask->r, cval.r);
                ACCUM_ADD_MASKED_COLOR_COMPONENT( g, shift->g, sign->g, 
                                              mask->g, cval.g);
                ACCUM_ADD_MASKED_COLOR_COMPONENT( b, shift->b, sign->b, 
                                              mask->b, cval.b);
                ACCUM_ADD_MASKED_COLOR_COMPONENT( a, shift->a, sign->a, 
                                              mask->a, cval.a);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b) |
                        ((a & mask->a) << shift->a);
            }
        }
    }
}

static void Return32(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, next;
    GLuint *ac;
    __GLcolorBuffer *cfb;
    __GLcolorBuffer *cfb2;
    __GLfragment frag;
    __GLcolor *pAccumCol;
    // The returnspan routines use FTOL 
    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    w = x1 - x0;
    next = afb->buf.outerWidth;
    frag.y = y0;

    // Preallocate a color buffer for the return span functions
    pAccumCol = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
    if( NULL == pAccumCol )
        return;
    afb->colors = pAccumCol;

    if (gc->buffers.doubleStore) {
	/* Store to both buffers */
	cfb = &gc->frontBuffer;
	cfb2 = &gc->backBuffer;
	for (; y0 < y1; y0++) {
	    (*cfb->returnSpan)(cfb, x0, y0, (__GLaccumCell *)ac, val, w);
	    (*cfb2->returnSpan)(cfb2, x0, y0, (__GLaccumCell *)ac, val, w);
	    ac += next;
	}
    } else {
	cfb = gc->drawBuffer;
	for (; y0 < y1; y0++) {
	    (*cfb->returnSpan)(cfb, x0, y0, (__GLaccumCell *)ac, val, w);
	    ac += next;
	}
    }
    FPU_RESTORE_MODE();
    gcTempFree( gc, pAccumCol );
}

static void FASTCALL Clear32(__GLaccumBuffer* afb)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    GLuint *ac, acVal;
    GLint r, g, b;
    __GLcolorBuffer *cfb = &gc->frontBuffer;
    __GLcolor *val = &gc->state.accum.clear;
    GLint a;

    /*
    ** Convert abstract color into specific color value.
    */
    r = (GLint) (val->r * cfb->redScale * afb->redScale);
    g = (GLint) (val->g * cfb->greenScale * afb->greenScale);
    b = (GLint) (val->b * cfb->blueScale * afb->blueScale);
    a = (GLint) (val->a * cfb->alphaScale * afb->alphaScale);
    acVal = ((r & afb->mask.r) << afb->shift.r) |
            ((g & afb->mask.g) << afb->shift.g) |
            ((b & afb->mask.b) << afb->shift.b);
    if( gc->modes.alphaBits )
        acVal |= (a & afb->mask.a) << afb->shift.a;
            
    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    w = gc->transform.clipX1 - x0;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;
    for (; y0 < y1; y0++) {
	w = w4;
	while (--w >= 0) {
	    ac[0] = acVal;
	    ac[1] = acVal;
	    ac[2] = acVal;
	    ac[3] = acVal;
	    ac += 4;
	}
	w = w1;
	while (--w >= 0) {
	    *ac++ = acVal;
	}
	ac += skip;
    }
}

void FASTCALL __glInitAccum32(__GLcontext *gc, __GLaccumBuffer *afb)
{
    __GLGENcontext *gengc;
    PIXELFORMATDESCRIPTOR *pfmt;

    gengc = (__GLGENcontext *) gc;
    pfmt = &gengc->gsurf.pfd;
    afb->buf.elementSize = sizeof(GLuint);
    afb->buf.gc = gc;
    if (gc->modes.rgbMode) {
	__GLcolorBuffer *cfb;
	__GLfloat redScale, greenScale, blueScale;
	__GLfloat alphaScale;

	redScale = (__GLfloat) (1 << pfmt->cAccumRedBits)/2 - 1;
	greenScale = (__GLfloat) (1 << pfmt->cAccumGreenBits)/2 - 1;
	blueScale = (__GLfloat) (1 << pfmt->cAccumBlueBits)/2 - 1;

	cfb = &gc->frontBuffer;
	afb->redScale = redScale / (cfb->redScale);
	afb->greenScale = greenScale / (cfb->greenScale);
	afb->blueScale = blueScale / (cfb->blueScale);
        afb->alphaScale = (__GLfloat) 1.0;

	afb->oneOverRedScale = 1 / afb->redScale;
	afb->oneOverGreenScale = 1 / afb->greenScale;
	afb->oneOverBlueScale = 1 / afb->blueScale;
	afb->oneOverAlphaScale = 1 / afb->alphaScale;
        afb->shift.r = 0;
        afb->shift.g = pfmt->cAccumRedBits;
        afb->shift.b = afb->shift.g + pfmt->cAccumGreenBits;
        afb->mask.r = (1 << pfmt->cAccumRedBits) - 1;
        afb->mask.g = (1 << pfmt->cAccumGreenBits) - 1;
        afb->mask.b = (1 << pfmt->cAccumBlueBits) - 1;
        afb->sign.r = 1 << (pfmt->cAccumRedBits - 1);
        afb->sign.g = 1 << (pfmt->cAccumGreenBits - 1);
        afb->sign.b = 1 << (pfmt->cAccumBlueBits - 1);
        if( gc->modes.alphaBits ) {
            alphaScale = (__GLfloat) (1 << pfmt->cAccumAlphaBits)/2 - 1;
            afb->alphaScale = alphaScale / (cfb->alphaScale);
            afb->oneOverAlphaScale = 1 / afb->alphaScale;
            afb->shift.a = afb->shift.b + pfmt->cAccumBlueBits;
            afb->mask.a = (1 << pfmt->cAccumAlphaBits) - 1;
            afb->sign.a = 1 << (pfmt->cAccumAlphaBits - 1);
        }
    }
    afb->pick = Pick;
    afb->clear = Clear32;
    afb->accumulate = Accumulate32;
    afb->load = Load32;
    afb->ret = Return32;
    afb->mult = Mult32;
    afb->add = Add32;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genclear.h ===
/******************************Module*Header*******************************\
* Module Name: genclear.h
*
* Created: 03-Dec-1993 00:33:51
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

void FASTCALL Index4Clear(__GLcolorBuffer *);
void FASTCALL Index8Clear(__GLcolorBuffer *);
void FASTCALL RGBClear(__GLcolorBuffer *);
void FASTCALL Bitfield16Clear(__GLcolorBuffer *);
void FASTCALL Bitfield32Clear(__GLcolorBuffer *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genclear.c ===
/******************************Module*Header*******************************\
* Module Name: genclear.c
*
* Clear functions.
*
* Created: 01-Dec-1993 16:11:17
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "genci.h"
#include "genrgb.h"
#include "devlock.h"

/******************************Public*Routine******************************\
* __glim_Clear
*
* Generic proc table entry point for glClear.  It allocates ancillary buffers
* the first time they are used
*
* History:
*  14-Dec-1993 -by- Eddie Robinson [v-eddier]
* Wrote it.
\**************************************************************************/

void APIPRIVATE __glim_Clear(GLbitfield mask)
{
    __GL_SETUP();
    GLuint beginMode;

    beginMode = gc->beginMode;
    if ( beginMode != __GL_NOT_IN_BEGIN )
    {
        if ( beginMode == __GL_NEED_VALIDATE )
        {
            (*gc->procs.validate)(gc);
            gc->beginMode = __GL_NOT_IN_BEGIN;
            __glim_Clear(mask);
            return;
        }
        else
        {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
    }

    if ( mask & ~(GL_COLOR_BUFFER_BIT | GL_ACCUM_BUFFER_BIT
                  | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) )
    {
        __glSetError(GL_INVALID_VALUE);
        return;
    }

    if ( gc->renderMode == GL_RENDER )
    {
        BOOL bResetViewportAdj = FALSE;

#ifdef _MCD_
    // Let MCD have first chance at clearing any of the MCD managed buffers.

        if ( ((__GLGENcontext *) (gc))->pMcdState &&
             (mask & (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT |
                      GL_STENCIL_BUFFER_BIT)) )
        {
        // Don't attempt to clear depth/stencil buffer if it does not exist.

            if ( !gc->modes.depthBits )
                mask &= ~GL_DEPTH_BUFFER_BIT;

            if ( !gc->modes.stencilBits )
                mask &= ~GL_STENCIL_BUFFER_BIT;

        // GenMcdClear will clear the mask bits of the buffers it
        // successfully cleared.

            GenMcdClear((__GLGENcontext *) gc, &mask);

        // If simulations are needed for any of the MCD buffers, now is
        // the time to grab the device lock.

            if (mask & (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT |
                        GL_STENCIL_BUFFER_BIT))
            {
            // Abandon the clear if we cannot acquire the lock.

                if (!glsrvLazyGrabSurfaces((__GLGENcontext *) gc,
                                           COLOR_LOCK_FLAGS |
                                           DEPTH_LOCK_FLAGS))
                    return;

            // We may need to temporarily reset the viewport adjust values
            // before calling simulations.  If GenMcdResetViewportAdj returns
            // TRUE, the viewport is changed and we need restore later with
            // VP_NOBIAS.

                bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
            }
        }
#endif

        if ( mask & GL_COLOR_BUFFER_BIT )
        {
            // Clear the software alpha buffer here too, as approppriate

            switch ( gc->state.raster.drawBuffer )
            {
              case GL_NONE:
                break;
              case GL_FRONT:
                (*gc->front->clear)(gc->front);
                if( ALPHA_BUFFER_WRITE( gc->front ) )
                    (*gc->front->alphaBuf.clear)(&gc->front->alphaBuf);
                break;

              case GL_FRONT_AND_BACK:
                (*gc->front->clear)(gc->front);
                if( ALPHA_BUFFER_WRITE( gc->front ) )
                    (*gc->front->alphaBuf.clear)(&gc->front->alphaBuf);
                // fall through...

              case GL_BACK:
                if ( gc->modes.doubleBufferMode ) {
                    (*gc->back->clear)(gc->back);
                    if( ALPHA_BUFFER_WRITE( gc->back ) )
                        (*gc->back->alphaBuf.clear)(&gc->back->alphaBuf);
                }
                break;
#if __GL_NUMBER_OF_AUX_BUFFERS > 0
              case GL_AUX0:
              case GL_AUX1:
              case GL_AUX2:
              case GL_AUX3:
                i = gc->state.raster.drawBuffer - GL_AUX0;
                if ( i < gc->modes.maxAuxBuffers )
                    (*gc->auxBuffer[i].clear)(&gc->auxBuffer[i]);
                break;
#endif
            }
        }

        if ( (mask & GL_DEPTH_BUFFER_BIT) && gc->modes.depthBits )
        {
            if ( !gc->modes.haveDepthBuffer )
                LazyAllocateDepth(gc);

//XXX Any reason we have to check base???
//XXX That doesn't really fit with 3d DDI model!  So check haveDepthBuffer
//XXX instead...
            if ( gc->modes.haveDepthBuffer )
                (*gc->depthBuffer.clear)(&gc->depthBuffer);
        }

        if ( (mask & GL_ACCUM_BUFFER_BIT) && gc->modes.accumBits )
        {
            if ( !gc->modes.haveAccumBuffer )
                LazyAllocateAccum(gc);

            if ( gc->accumBuffer.buf.base )
                (*gc->accumBuffer.clear)(&gc->accumBuffer);
        }

        if ( (mask & GL_STENCIL_BUFFER_BIT) && gc->modes.stencilBits )
        {
            if ( !gc->modes.haveStencilBuffer )
                LazyAllocateStencil(gc);

            if ( gc->stencilBuffer.buf.base )
                (*gc->stencilBuffer.clear)(&gc->stencilBuffer);
        }

    // Restore viewport values if needed.

        if (bResetViewportAdj)
        {
            GenMcdResetViewportAdj(gc, VP_NOBIAS);
        }
    }
}

/******************************Public*Routine******************************\
* InitClearRectangle
*
* If the wndobj is complex, need to start the enumeration
*
* History:
*  23-Jun-1994 Gilman Wong [gilmanw]
* Use cache of clip rectangles.
*
*  24-Jan-1994 -by- Scott Carr [v-scottc]
* Wrote it.
\**************************************************************************/

void FASTCALL InitClearRectangle(GLGENwindow *pwnd, GLint *pEnumState)
{
    __GLGENbuffers *buffers = pwnd->buffers;

    ASSERTOPENGL(pwnd->clipComplexity == CLC_COMPLEX,
                 "InitClearRectangle(): not CLC_COMPLEX\n");

#ifndef _CLIENTSIDE_
// Check the uniqueness signature.  Note that if the clip cache is
// uninitialized, the clip cache uniqueness is -1 (which is invalid).

    if (buffers->clip.WndUniq != buffers->WndUniq)
    {
        if (buffers->clip.prcl)
            (*private->free)(buffers->clip.prcl);

    // How many clip rectangles?

        buffers->clip.crcl = wglGetClipRects(pwnd, NULL);

    // Allocate a new clip cache.

        buffers->clip.prcl =
            (RECTL *) (*private->malloc)(buffers->clip.crcl * sizeof(RECTL));

        if (!buffers->clip.prcl)
        {
            buffers->clip.crcl = 0;
            return;
        }

    // Get the clip rectangles.

        buffers->clip.crcl = wglGetClipRects(pwnd, buffers->clip.prcl);
        buffers->clip.WndUniq = buffers->WndUniq;
    }
#else
    {
    // In the client-side case, we don't need to cache rectangles.  We already
    // have the rectangles cached for direct screen access.
    // Just grab a copy of the pointer and count from the
    // cached RGNDATA structure in the GLGENwindow.

        buffers->clip.crcl = pwnd->prgndat->rdh.nCount;
        buffers->clip.prcl = (RECTL *) pwnd->prgndat->Buffer;
        buffers->clip.WndUniq = buffers->WndUniq;
    }
#endif

    *pEnumState = 0;
}

/******************************Public*Routine******************************\
* GetClearSubRectangle
*
* Enumerate the rectangles (inclusive-exclusive) in screen coordinates that
* need to be cleared.  If the clipping region is complex, InitClearRectangle
* must be called prior to calling GetClearSubRectangle.
*
* Returns:
*   TRUE if there are more clip rectangles, FALSE if no more.
*
* History:
*  23-Jun-1994 Gilman Wong [gilmanw]
* Use cache of clip rectangles.
*
*  03-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLboolean
GetClearSubRectangle(
    __GLcolorBuffer *cfb,
    RECTL *prcl,
    GLGENwindow *pwnd,
    GLint *pEnumState)
{
    __GLcontext *gc = cfb->buf.gc;
    GLint x, y, x1, y1;
    GLboolean retval;
    RECTL *prcl2;

// Get the OpenGL clipping rectangle and convert to screen coordinates.

    //!!!XXX -- We want to return the clear rectangle as inclusive-exclusive.
    //!!!XXX    Does the gc->tranform.clip* coordinates represent
    //!!!XXX    inclusive-exclusive or inclusive-inclusive?

    x = gc->transform.clipX0;
    y = gc->transform.clipY0;
    x1 = gc->transform.clipX1;
    y1 = gc->transform.clipY1;
    if ((x1 - x == 0) || (y1 - y == 0)) {
        prcl->left = prcl->right = 0;
        prcl->top = prcl->bottom = 0;
        return GL_FALSE;
    }

    prcl->left = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    prcl->right = __GL_UNBIAS_X(gc, x1) + cfb->buf.xOrigin;
    prcl->bottom = __GL_UNBIAS_Y(gc, y1) + cfb->buf.yOrigin;
    prcl->top = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

// Now get the windowing system clipping.  There are three cases: CLC_TRIVIAL,
// CLC_COMPLEX, and CLC_RECTANGLE.

// CLC_TRIVIAL case -- no clipping, use rclClient.

    if (pwnd->clipComplexity == CLC_TRIVIAL)
    {
        prcl2 = &pwnd->rclClient;

        if ((pwnd->rclClient.left == 0) && (pwnd->rclClient.right == 0))
        {
            prcl->left = prcl->right = 0;
            return GL_FALSE;
        }

        retval = GL_FALSE;
    }

// CLC_COMPLEX case -- rectangles have already been enumerated and put into
// the clip cache.  The pEnumState parameter tracks current rectangle to be
// enumerated.

    else if (pwnd->clipComplexity == CLC_COMPLEX)
    {
        __GLGENbuffers *buffers = ((__GLGENcontext *)gc)->pwndLocked->buffers;

        ASSERTOPENGL(buffers->WndUniq == buffers->clip.WndUniq,
                     "GetClearSubRectangle(): clip cache is dirty\n");

        if (*pEnumState < buffers->clip.crcl)
        {
            prcl2 = &buffers->clip.prcl[*pEnumState];
            *pEnumState += 1;
            retval = (*pEnumState < buffers->clip.crcl);
        }
        else
        {
            RIP("GetClearSubRectangle(): no more rectangles!\n");
            prcl->left = prcl->right = 0;
            return GL_FALSE;
        }
    }

// CLC_RECT case -- only one rectangle, use rclBounds.

    else
    {
        ASSERTOPENGL(pwnd->clipComplexity == CLC_RECT,
                     "Unexpected clipComplexity\n");
        prcl2 = &pwnd->rclBounds;

        if ((pwnd->rclBounds.left == 0) && (pwnd->rclBounds.right == 0))
        {
            prcl->left = prcl->right = 0;
            return GL_FALSE;
        }

        retval = GL_FALSE;
    }

// Sanity check the rectangle.

    ASSERTOPENGL(
        (prcl2->right - prcl2->left) <= __GL_MAX_WINDOW_WIDTH
        && (prcl2->bottom - prcl2->top) <= __GL_MAX_WINDOW_HEIGHT,
        "GetClearSubRectangle(): bad visible rect size\n"
        );

// Need to take intersection of prcl & prcl2.

    if (prcl2->left > prcl->left)
        prcl->left = prcl2->left;
    if (prcl2->right < prcl->right)
        prcl->right = prcl2->right;
    if (prcl2->top > prcl->top)
        prcl->top = prcl2->top;
    if (prcl2->bottom < prcl->bottom)
        prcl->bottom = prcl2->bottom;

    if ((prcl->left >= prcl->right) || (prcl->top >= prcl->bottom))
        prcl->left = prcl->right = 0;   // empty inclusive-exclusive rect

    return retval;
}

/******************************Public*Routine******************************\
* ScrnRGBCIReadSpan
*
* Reads a span of RGB, and converts to ColorIndex
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
ScrnRGBCIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, GLuint *pResults,
              GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;
    GLint i;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;

    if (bDIB) {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                         (y*cfb->buf.outerWidth) + (x * 3));
    }
    else {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }
    for (i = 0; i < w; i++, puj += 3)
    {
        iColor = *( (GLuint *) puj) & 0xffffff;
        *pResults++ = ColorToIndex( gengc, iColor );
    }
}

/******************************Public*Routine******************************\
* ScrnBitfield16CIReadSpan
*
* Reads a span of Bitfield16, and converts to ColorIndex
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
ScrnBitfield16CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                     GLuint *pResults, GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus;
    GLint i;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;

    if (bDIB) {
        pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 1));
    }
    else {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        pus = gengc->ColorsBits;
    }
    for (i = 0; i < w; i++)
    {
        iColor = *pus++;
        *pResults++ = ColorToIndex( gengc, iColor );
    }
}

/******************************Public*Routine******************************\
* ScrnBitfield32CIReadSpan
*
* Reads a span of Bitfield32, and converts to ColorIndex
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
ScrnBitfield32CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                     GLuint *pResults, GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul;
    GLint i;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;

    if (bDIB) {
        pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 2));
    }
    else {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        pul = gengc->ColorsBits;
    }
    for (i = 0; i < w; i++)
    {
        iColor = *pul++;
        *pResults++ = ColorToIndex( gengc, iColor );
    }
}

/******************************Public*Routine******************************\
* CalcDitherMatrix
*
* Calculate the 16 element dither matrix, or return FALSE if dithering
* would have no effect.
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

GLboolean
CalcDitherMatrix( __GLcolorBuffer *cfb, GLboolean bRGBA, GLboolean bMasking,
                  GLboolean bBitfield16, GLubyte *mDither )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    UINT    i, j;           // indices into the dither array
    GLushort result;         // dithered color value (in 332 RGB)
    __GLcolor *clear;
    GLfloat inc = DITHER_INC(15); // largest dither increment
    GLushort *msDither = (GLushort *) mDither;
    GLuint *pTrans = (GLuint *) (gengc->pajTranslateVector + 1);

    // see if we can ignore dithering altogether

    if( bRGBA ) {
        clear = &gc->state.raster.clear;

        if( ((BYTE)(clear->r*gc->frontBuffer.redScale) ==
             (BYTE)(clear->r*gc->frontBuffer.redScale + inc)) &&
            ((BYTE)(clear->g*gc->frontBuffer.greenScale) ==
             (BYTE)(clear->g*gc->frontBuffer.greenScale + inc)) &&
            ((BYTE)(clear->b*gc->frontBuffer.blueScale) ==
             (BYTE)(clear->b*gc->frontBuffer.blueScale + inc))  ) {

                return GL_FALSE;
        }
    }
    else {  // Color Index (cast to short so works for up to 16-bit)
        if( (GLushort) (gc->state.raster.clearIndex) ==
             (GLushort) (gc->state.raster.clearIndex + inc)) {
                return GL_FALSE;
        }
    }

//XXX -- could cache this in the gengc

    for (j = 0; j < 4; j++)
    {
        for (i = 0; i < 4; i++)
        {
            inc = fDitherIncTable[__GL_DITHER_INDEX(i, j)];

            if( bRGBA ) {
                result =
                    ((BYTE)(clear->r*gc->frontBuffer.redScale + inc) <<
                        cfb->redShift) |
                    ((BYTE)(clear->g*gc->frontBuffer.greenScale + inc) <<
                        cfb->greenShift) |
                    ((BYTE)(clear->b*gc->frontBuffer.blueScale + inc) <<
                        cfb->blueShift);
            }
            else {
                result = (BYTE) (gc->state.raster.clearIndex + inc);
                result &= cfb->redMax;
            }

            if( bBitfield16 ) {
                if( !bMasking ) {
                    if( bRGBA )
                        *msDither++ = result;
                    else
                        *msDither++ = (GLushort)pTrans[result];
                }
                else
                    *msDither++ = (GLushort)(result & cfb->sourceMask);
            }
            else {
                if( !bMasking )
                    *mDither++ = gengc->pajTranslateVector[(GLubyte)result];
                else
                    *mDither++ = (GLubyte)(result & cfb->sourceMask);
            }
        }
    }
    return TRUE;
}

/******************************Public*Routine******************************\
* Index4DitherClear
*
* Clear function for Display 4-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
Index4DitherClear(__GLcolorBuffer *cfb, RECTL *rcl, GLubyte *mDither,
                    GLboolean bDIB )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    UINT    cjSpan;             // length of span in bytes
    GLubyte *pDither;           // dithered color, relative to window origin
    UINT    i, j;               // indices into the dither array
    GLubyte *puj, *pujStart;    // pointer into span buffer
    GLint   ySpan;              // index to window row to clear
    GLushort pattern, *pus;     // replicatable 4-nibble dither pattern
    GLuint    lRightByte,       // right edge of span that is byte aligned
              lLeftByte;        // left edge of span that is byte aligned
    GLuint  cSpanWidth;         // span width in pixels
    GLuint   dithX, dithY;      // x,y offsets into dither matrix
    GLubyte dithQuad[4];        // dither repetion quad along a span

    lLeftByte = (rcl->left + 1) / 2;
    lRightByte = rcl->right / 2;
    cjSpan = lRightByte - lLeftByte;
    cSpanWidth = rcl->right - rcl->left;

    if( bDIB )
        pujStart = (GLubyte *)
                   ((ULONG_PTR)cfb->buf.base +
                    (rcl->top*cfb->buf.outerWidth) + lLeftByte);

    // calc dither offset in x,y
    dithX = (rcl->left - cfb->buf.xOrigin) & 3;
    dithY = (rcl->top  - cfb->buf.yOrigin) & 3;

    for (j = 0; (j < 4) && ((rcl->top + j) < (UINT)rcl->bottom); j++)
    {
        // Arrange the 4-pixel dither repetition pattern in x.  This
        // pattern is relative to rcl->left.

        pDither = mDither + ((dithY+j)&3)*4;
        for( i = 0; i < 4; i ++ ) {
            dithQuad[i] = pDither[(dithX+i)&3];
        }

        // Copy the clear pattern into the span buffer.

        puj = gengc->ColorsBits;
        pus = (GLushort *) puj;

        // For every line, we can replicate a 2-byte(4-nibble) pattern
        // into the span buffer.  This will allow us to quickly output
        // the byte aligned portion of the dithered span.
        //
        // If we are writing to a DIB and the first pixel does not fall
        // on a byte boundary, then the buffer will replicate (using
        // the dithQuad pattern) the dither pattern:
        //
        //  <dith 1> <dith 2> <dith 3> <dith 0>
        //
        // (The non-aligned first dither pixel will have to be handled
        // separately).
        //
        // Otherwise (if we are writing to a display managed surface or
        // the first pixel does fall on a byte boundary), then the buffer
        // will replicate the dither pattern:
        //
        //  <dith 0> <dith 1> <dith 2> <dith 3>
        //
        // Note -- for a VGA, the layout of the pixels in a ushort is:
        //
        //          | -------------- ushort --------------- |
        //          | ---- byte 1 ----- | ---- byte 0 ----- |
        //           <pixel 2> <pixel 3> <pixel 0> <pixel 1>

        if( bDIB && (rcl->left & 1) ) {  // not on byte boundary
            // dither: 1230  pattern: 3012
            pattern = (dithQuad[3] << 12) | (dithQuad[0] << 8) |
                      (dithQuad[1] << 4 ) | (dithQuad[2]);
        }
        else {                          // all other cases
            // dither: 0123  pattern: 2301
            pattern = (dithQuad[2] << 12) | (dithQuad[3] << 8) |
                      (dithQuad[0] << 4 ) | (dithQuad[1]);
        }

        // Replicate pattern into ColorsBits (round up to next short)

        for( i = (rcl->right - rcl->left + 3)/4; i; i-- ) {
            *pus++ = pattern;
        }

        // Copy the span to the display for every 4th row of the window.

        if( bDIB ) {
            for (ySpan = rcl->top + j, puj = pujStart;
                 ySpan < rcl->bottom;
                 ySpan+=4,
                 puj = (GLubyte *)((ULONG_PTR)puj + 4*cfb->buf.outerWidth) ) {

                RtlCopyMemory_UnalignedDst( puj, gengc->ColorsBits, cjSpan );
            }

            // Take care of non-byte aligned left edge.

            if( rcl->left & 1 ) {
                for (ySpan = rcl->top + j, puj = (pujStart-1);
                     ySpan < rcl->bottom;
                     ySpan+=4,
                     puj = (GLubyte *)((ULONG_PTR)puj + 4*cfb->buf.outerWidth) )

                *puj = (*puj & 0xf0) | (dithQuad[0] & 0x0f);
            }

            // Take care of non-byte aligned right edge.

            if( rcl->right & 1 ) {
                GLuint dindex = ((rcl->right - 1) - cfb->buf.xOrigin)&3;

                for (ySpan = rcl->top + j, puj = (pujStart + cjSpan);
                     ySpan < rcl->bottom;
                     ySpan+=4,
                     puj = (GLubyte *)((ULONG_PTR)puj + 4*cfb->buf.outerWidth) )

                *puj = (*puj & 0x0f) | (dithQuad[dindex] << 4);
            }

            pujStart += cfb->buf.outerWidth;
        }
        else {
            for (ySpan = rcl->top + j; ySpan < rcl->bottom; ySpan+=4)
            {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                            ySpan, cSpanWidth, TRUE);
            }
        }
    }
}

/******************************Public*Routine******************************\
* Index4MaskedClear
*
* Clear function for Index4 Masked clears
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
Index4MaskedClear(__GLcolorBuffer *cfb, RECTL *rcl, GLubyte index,
                  GLubyte *mDither)
{
    GLint cSpanWidth, ySpan, w;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    GLboolean bDIB;
    GLubyte *puj, *puj2;
    GLubyte result, pixel, src;
    GLubyte *pTrans, *pInvTrans, *clearDither;
    GLuint i,j;
    GLuint   dithX, dithY;      // x,y offsets into dither matrix

    cSpanWidth = rcl->right - rcl->left;
    bDIB  = cfb->buf.flags & DIB_FORMAT ? TRUE : FALSE;
    pTrans = (GLubyte *) gengc->pajTranslateVector;
    pInvTrans = (GLubyte *) gengc->pajInvTranslateVector;

    puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base +
                             (rcl->top*cfb->buf.outerWidth) + (rcl->left>>1))
                     : gengc->ColorsBits;

    if( mDither ) {
        // calc dither offset in x,y
        dithX = (rcl->left - cfb->buf.xOrigin) & 3;
        dithY = (rcl->top - cfb->buf.yOrigin) & 3;
    }

    for (ySpan = rcl->top, j=0; ySpan < rcl->bottom; ySpan++, j++) {

        i = 0;

        if( !bDIB ) {
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, FALSE);
        }

        if( mDither )
            clearDither = mDither + ((dithY + j)&3)*4;

        src = (GLubyte)(index & cfb->sourceMask);
        w = cSpanWidth;
        puj2 = puj;

        if ( rcl->left & 1 ) {
            result = (GLubyte)(pInvTrans[*puj2 & 0xf] & cfb->destMask);
            if( mDither ) {
                src = clearDither[dithX];
                i++;
            }
            result = pTrans[src | result];
            *puj2++ = (*puj2 & 0xf0) | result;
            w--;
        }

        while( w > 1 ) {
            pixel = (GLubyte)(pInvTrans[*puj2 >> 4] & cfb->destMask);
            pixel = pTrans[src | pixel];
            result = pixel << 4;
            pixel = (GLubyte)(pInvTrans[*puj2 & 0x0f] & cfb->destMask);
            if( mDither )
                src = clearDither[(dithX + i)&3];
            pixel = pTrans[src | pixel];
            *puj2++ = result | pixel;
            w -= 2;
            i++;
        }

        if( w ) {
            result = (GLubyte)(pInvTrans[*puj2 >> 4] & cfb->destMask);
            if( mDither )
                src = clearDither[(dithX + i)&3];
            result = pTrans[src | result];
            *puj2++ = (*puj2 & 0x0f) | (result << 4);
        }

        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, TRUE);

        if( bDIB ) {
            puj += cfb->buf.outerWidth;
        }
    }
}

/******************************Public*Routine******************************\
* DIBIndex4Clear
*
* Clear function for DIB 4-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL DIBIndex4Clear(__GLcolorBuffer *cfb, RECTL *rcl, BYTE clearColor)
{
    UINT    cjSpan;             // length of span in bytes
    LONG    lRightByte,         // right edge of span that is byte aligned
            lLeftByte;          // left edge of span that is byte aligned
    GLubyte *puj, *pujEnd;      // pointers into DIB

    lLeftByte = (rcl->left + 1) / 2;
    lRightByte = rcl->right / 2;
    cjSpan = lRightByte - lLeftByte;

    // Copy the clear color into the DIB.

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + lLeftByte);
    pujEnd = (GLubyte *)((ULONG_PTR)puj + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

    // Note: exit condition is (pul != pulEnd) rather than (pul < pulEnd)
    // because the DIB may be upside down which means that pul is moving
    // "backward" in memory rather than "forward".

    for ( ; puj != pujEnd; puj = (GLubyte *)((ULONG_PTR)puj + cfb->buf.outerWidth) )
    {
        RtlFillMemory((PVOID) puj, cjSpan, clearColor);
    }

    // Take care of possible 1 nibble overhang on the left.

    if ( rcl->left & 1 )
    {
    // Inclusive-exclusive, so on the left we want to turn on the pixel that
    // that is the "right" pixel in the byte.

        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + (rcl->left/2));
        pujEnd = (GLubyte *)((ULONG_PTR)puj + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

        for ( ; puj != pujEnd; puj = (GLubyte *)((ULONG_PTR)puj + cfb->buf.outerWidth) )
            *puj = (*puj & 0xf0) | (clearColor & 0x0f);
    }

    // Take care of possible 1 nibble overhang on the right.

    if ( rcl->right & 1 )
    {
    // Inclusive-exclusive, so on the right we want to turn on the pixel that
    // that is the "left" pixel in the byte.

        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + (rcl->right/2));
        pujEnd = (GLubyte *)((ULONG_PTR)puj + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

        for ( ; puj != pujEnd; puj = (GLubyte *)((ULONG_PTR)puj + cfb->buf.outerWidth) )
            *puj = (*puj & 0x0f) | (clearColor & 0xf0);
    }
}

/******************************Public*Routine******************************\
* Index4Clear
*
* Clear function for all 4-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL Index4Clear(__GLcolorBuffer *cfb)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLubyte clearColor;         // clear color in 32BPP format
    RECTL   rcl;                // clear rectangle in screen coord.
    GLGENwindow *pwnd;
    GLboolean bMoreRects = GL_TRUE;
    GLboolean bDither = GL_FALSE;
    GLboolean bMasking = (cfb->buf.flags & COLORMASK_ON) != 0;
    GLboolean bDIB = (cfb->buf.flags & DIB_FORMAT) != 0;
    GLboolean bUseMcdSpans = gengc->pMcdState && !bDIB;
    GLboolean bRGBA;
    GLubyte ditherMatrix[4][4];
    GLint ClipEnumState;

    DBGENTRY("Index4Clear\n");

    pfmt = &gengc->gsurf.pfd;
    bRGBA = (pfmt->iPixelType == PFD_TYPE_RGBA);

    /* if dithering enabled, see if we can ignore it, and if not,
        precompute a dither matrix
    */
    if( gc->state.enables.general & __GL_DITHER_ENABLE ) {
        bDither = CalcDitherMatrix( cfb, bRGBA, bMasking, GL_FALSE,
                                    (GLubyte *)ditherMatrix );
    }

    // Convert the clear color to 4BPP format.

    if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
        clearColor =
              ((BYTE)(gc->state.raster.clear.r*gc->frontBuffer.redScale +
                      __glHalf) << cfb->redShift) |
              ((BYTE)(gc->state.raster.clear.g*gc->frontBuffer.greenScale +
                     __glHalf) << cfb->greenShift) |
              ((BYTE)(gc->state.raster.clear.b*gc->frontBuffer.blueScale +
                      __glHalf) << cfb->blueShift);
    }
    else {
        clearColor = (BYTE) (gc->state.raster.clearIndex + 0.5F);
        clearColor &= cfb->redMax;
    }
    clearColor = gengc->pajTranslateVector[clearColor];
    clearColor = (clearColor << 4) | clearColor;

    // Get clear rectangle in screen coordinates.
    pwnd = cfb->bitmap->pwnd;
    if (pwnd->clipComplexity == CLC_COMPLEX) {
        InitClearRectangle(pwnd, &ClipEnumState);
#ifdef LATER
    } else if (   !bMasking
               && !bDither
               && bDIB
               && gengc->fDirtyRegionEnabled
               && !RECTLISTIsMax(&gengc->rlClear)
               && ((GLuint)clearColor == gengc->clearColor)
              ) {
        //
        // use dirty region rects
        //

        if (!RECTLISTIsEmpty(&gengc->rlClear)) {
            PYLIST pylist = gengc->rlClear.pylist;

            while (pylist != NULL) {
                PXLIST pxlist = pylist->pxlist;

                rcl.top = pylist->s;
                rcl.bottom = pylist->e;

                while (pxlist != NULL) {
                    rcl.left = pxlist->s;
                    rcl.right = pxlist->e;
                    DIBIndex4Clear( cfb, &rcl, clearColor );
                    pxlist = pxlist->pnext;
                }
                pylist = pylist->pnext;
            }

            //
            // Union the blt region with the Clear region
            // and set the clear region to empty
            //

            RECTLISTOrAndClear(&gengc->rlBlt, &gengc->rlClear);
        }

        return;
    }

    if (gengc->fDirtyRegionEnabled) {
        //
        // if we come through this path then for some reason we
        // are clearing the entire window
        //

        RECTLISTSetEmpty(&gengc->rlClear);
        RECTLISTSetMax(&gengc->rlBlt);

        //
        // remember the clear color
        //

        gengc->clearColor = (GLuint)clearColor;
#endif
    }

    while (bMoreRects)
    {
        // Must use MCD spans if buffer not accessible as DIB.  In such a
        // case, window offset has been removed (see GenMcdUpdateBufferInfo),
        // so a window relative rectangle is required for the clear.  Also,
        // because the driver handles clipping, we do not need to enumerate
        // rects.

        if (bUseMcdSpans) {
            rcl.left = __GL_UNBIAS_X(gc, gc->transform.clipX0);
            rcl.right = __GL_UNBIAS_X(gc, gc->transform.clipX1);
            rcl.bottom = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
            rcl.top = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
            bMoreRects = FALSE;
        } else
            bMoreRects = GetClearSubRectangle(cfb, &rcl, pwnd, &ClipEnumState);

        if (rcl.right == rcl.left)
            continue;

        // Case: no dithering, no masking

        if( !bMasking && !bDither ) {
            if (bDIB)
                DIBIndex4Clear( cfb, &rcl, clearColor );
            else if (bUseMcdSpans)
                Index4MaskedClear( cfb, &rcl, clearColor, NULL );
            else
                wglFillRect(gengc, pwnd, &rcl,
                            (ULONG) clearColor & 0x0000000F);
        }

        // Case: any masking

        else if( bMasking ) {
            Index4MaskedClear( cfb, &rcl, clearColor,
                               bDither ? (GLubyte *)ditherMatrix : NULL );
        }

        // Case: just dithering

        else {
            Index4DitherClear(cfb, &rcl, (GLubyte *)ditherMatrix, bDIB );
        }
    }
}

/******************************Public*Routine******************************\
* Index8DitherClear
*
* Clear device managed surface to the dithered clear color indicated
* in the __GLcolorBuffer.
*
* History:
*  06-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void
Index8DitherClear(__GLcolorBuffer *cfb, RECTL *rcl, GLubyte *mDither,
                         GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    UINT    cjSpan;             // length of span in bytes
    GLubyte *pDither;       // dithered color, relative to window origin
    UINT    i, j;               // indices into the dither array
    GLubyte *puj, *pujStart;           // pointer into span buffer
    GLint   ySpan;          // index to window row to clear
    GLuint   dithX, dithY;      // x,y offsets into dither matrix
    GLubyte dithQuad[4];        // dither repetion quad along a span

    cjSpan = rcl->right - rcl->left;

    if( bDIB )
        pujStart = (GLubyte *)
                   ((ULONG_PTR)cfb->buf.base +
                    (rcl->top*cfb->buf.outerWidth) + rcl->left);

    // calc dither offset in x,y
    dithX = (rcl->left - cfb->buf.xOrigin) & 3;
    dithY = (rcl->top  - cfb->buf.yOrigin) & 3;

    for (j = 0; (j < 4) && ((rcl->top + j) < (UINT)rcl->bottom); j++)
    {
        // arrange the 4-pixel dither repetition pattern in x
        pDither = mDither + ((dithY+j)&3)*4;
        for( i = 0; i < 4; i ++ ) {
            dithQuad[i] = pDither[(dithX+i)&3];
        }

        // Copy the clear color into the span buffer.

        puj = gengc->ColorsBits;

        for (i = cjSpan / 4; i; i--)
        {
            *puj++ = dithQuad[0];
            *puj++ = dithQuad[1];
            *puj++ = dithQuad[2];
            *puj++ = dithQuad[3];
        }

        for (i = 0; i < (cjSpan & 3); i++)
        {
            *puj++ = dithQuad[i];
        }

    // Copy the span to the display for every 4th row of the window.

    //!!!XXX -- It may be worth writing a (*gengc->pfnCopyPixelsN) routine which
    //!!!XXX will do the loop in one call.  This will save not only call
    //!!!XXX overhead but also other engine locking overhead.  Something
    //!!!XXX like: (*gengc->pfnCopyPixelsN)(hdc, hbm, x, y, w, n, yDelta)

        if( bDIB ) {
            for (ySpan = rcl->top + j, puj = pujStart;
                 ySpan < rcl->bottom;
                 ySpan+=4,
                 puj = (GLubyte *)((ULONG_PTR)puj + 4*cfb->buf.outerWidth) ) {

                RtlCopyMemory_UnalignedDst( puj, gengc->ColorsBits, cjSpan );
            }
            pujStart += cfb->buf.outerWidth;
        }
        else {
            for (ySpan = rcl->top + j; ySpan < rcl->bottom; ySpan+=4)
            {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                            ySpan, cjSpan, TRUE);
            }
        }
    }
}

/******************************Public*Routine******************************\
* Index8MaskedClear
*
* Clear function for Index8 Masked clears
* (Also handles dithering when masking on)
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
Index8MaskedClear(__GLcolorBuffer *cfb, RECTL *rcl, GLubyte index,
                  GLubyte *mDither)
{
    GLint cSpanWidth, ySpan;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    GLboolean bDIB;
    GLubyte *puj, *puj2, *pujEnd;
    GLubyte result, src;
    GLubyte *pTrans, *pInvTrans, *clearDither;
    GLuint i,j;
    GLuint   dithX, dithY;      // x,y offsets into dither matrix

    cSpanWidth = rcl->right - rcl->left;
    bDIB  = cfb->buf.flags & DIB_FORMAT ? TRUE : FALSE;
    pTrans = (GLubyte *) gengc->pajTranslateVector;
    pInvTrans = (GLubyte *) gengc->pajInvTranslateVector;

    puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base +
                             (rcl->top*cfb->buf.outerWidth) + rcl->left)
                     : gengc->ColorsBits;
    pujEnd = puj + cSpanWidth;

    src = (GLubyte)(index & cfb->sourceMask);

    if( mDither ) {
        // calc dither offset in x,y
        dithX = (rcl->left - cfb->buf.xOrigin) & 3;
        dithY = (rcl->top - cfb->buf.yOrigin) & 3;
    }

    for (ySpan = rcl->top, j = 0; ySpan < rcl->bottom; ySpan++, j++) {

        if( !bDIB ) {
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, FALSE);
        }

        if( mDither ) {
            clearDither = mDither + ((dithY + j)&3)*4;
            for( puj2 = puj, i = 0; puj2 < pujEnd; puj2++, i++ ) {
                result = (GLubyte)(pInvTrans[*puj2] & cfb->destMask);
                src = clearDither[(dithX + i)&3];
                *puj2 = pTrans[result | src];
            }
        } else {
            for( puj2 = puj, i = 0; puj2 < pujEnd; puj2++, i++ ) {
                result = (GLubyte)(pInvTrans[*puj2] & cfb->destMask);
                *puj2 = pTrans[result | src];
            }
        }


        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, TRUE);

        if( bDIB ) {
            puj += cfb->buf.outerWidth;
            pujEnd = puj + cSpanWidth;
        }
    }
}

/******************************Public*Routine******************************\
* DIBIndex8Clear
*
* Clear function for DIB 8-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL DIBIndex8Clear(__GLcolorBuffer *cfb, RECTL *rcl, BYTE index)
{
    int width = rcl->right - rcl->left;
    int height = (rcl->bottom - rcl->top);
    GLubyte *puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + rcl->left);
    GLubyte *pujEnd;

    if (cfb->buf.outerWidth > 0) {
        if (width == cfb->buf.outerWidth) {
            RtlFillMemory((PVOID) puj, width * height, index);
            return;
        }
    } else {
        if (width == -cfb->buf.outerWidth) {
            RtlFillMemory(
                (PVOID)((ULONG_PTR)puj - width * (height - 1)),
                width * height,
                index);
            return;
        }
    }

    pujEnd = (GLubyte *)((ULONG_PTR)puj + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

    // Note: exit condition is (pul != pulEnd) rather than (pul < pulEnd)
    // because the DIB may be upside down which means that pul is moving
    // "backward" in memory rather than "forward".

    for ( ; puj != pujEnd; puj = (GLubyte *)((ULONG_PTR)puj + cfb->buf.outerWidth) ) {
        RtlFillMemory((PVOID) puj, width, index);
    }
}

/******************************Public*Routine******************************\
* Index8Clear
*
* Clear function for all 8-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
*  Oct-03-1995 -by- Marc Fortier [marcfo]
* Don't translate color if masking enabled
\**************************************************************************/

void FASTCALL Index8Clear(__GLcolorBuffer *cfb)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    BYTE clearColor;
    RECTL  rcl;
    GLGENwindow *pwnd;
    GLboolean bMoreRects = GL_TRUE;
    GLboolean bDither = GL_FALSE;
    GLboolean bMasking = (cfb->buf.flags & COLORMASK_ON) != 0;
    GLboolean bDIB = (cfb->buf.flags & DIB_FORMAT) != 0;
    GLboolean bUseMcdSpans = gengc->pMcdState && !bDIB;
    GLboolean bRGBA;
    GLubyte ditherMatrix[4][4];
    GLint ClipEnumState;

    DBGENTRY("Index8Clear\n");

    pfmt = &gengc->gsurf.pfd;
    bRGBA = (pfmt->iPixelType == PFD_TYPE_RGBA);

    /* if dithering enabled, see if we can ignore it, and if not,
        precompute a dither matrix
    */

    if( gc->state.enables.general & __GL_DITHER_ENABLE ) {
        bDither = CalcDitherMatrix( cfb, bRGBA, bMasking, GL_FALSE,
                                    (GLubyte *)ditherMatrix );
    }

    // Convert clear value to index

    if( bRGBA ) {
        clearColor =
      ((BYTE)(gc->state.raster.clear.r*gc->frontBuffer.redScale + __glHalf) <<
                cfb->redShift) |
      ((BYTE)(gc->state.raster.clear.g*gc->frontBuffer.greenScale + __glHalf) <<
                cfb->greenShift) |
      ((BYTE)(gc->state.raster.clear.b*gc->frontBuffer.blueScale + __glHalf) <<
                cfb->blueShift);
    }
    else {
        clearColor = (BYTE) (gc->state.raster.clearIndex + __glHalf);
        clearColor &= cfb->redMax;
    }
    // translate color to index
    if( !bMasking )
        clearColor = gengc->pajTranslateVector[clearColor];

    // Get clear rectangle in screen coordinates.

    pwnd = cfb->bitmap->pwnd;
    if (pwnd->clipComplexity == CLC_COMPLEX) {
        InitClearRectangle(pwnd, &ClipEnumState);
#ifdef LATER
    } else if (   !bMasking
               && !bDither
               && bDIB
               && gengc->fDirtyRegionEnabled
               && !RECTLISTIsMax(&gengc->rlClear)
               && ((GLuint)clearColor == gengc->clearColor)
              ) {
        //
        // use dirty region rects
        //

        if (!RECTLISTIsEmpty(&gengc->rlClear)) {
            PYLIST pylist = gengc->rlClear.pylist;

            while (pylist != NULL) {
                PXLIST pxlist = pylist->pxlist;

                rcl.top = pylist->s;
                rcl.bottom = pylist->e;

                while (pxlist != NULL) {
                    rcl.left = pxlist->s;
                    rcl.right = pxlist->e;
                    DIBIndex8Clear( cfb, &rcl, clearColor );
                    pxlist = pxlist->pnext;
                }
                pylist = pylist->pnext;
            }

            //
            // Union the blt region with the Clear region
            // and set the clear region to empty
            //

            RECTLISTOrAndClear(&gengc->rlBlt, &gengc->rlClear);
        }

        return;
    }

    if (gengc->fDirtyRegionEnabled) {
        //
        // if we come through this path then for some reason we
        // are clearing the entire window
        //

        RECTLISTSetEmpty(&gengc->rlClear);
        RECTLISTSetMax(&gengc->rlBlt);

        //
        // remember the clear color
        //

        gengc->clearColor = (GLuint)clearColor;
#endif
    }

    while (bMoreRects)
    {
        // Must use MCD spans if buffer not accessible as DIB.  In such a
        // case, window offset has been removed (see GenMcdUpdateBufferInfo),
        // so a window relative rectangle is required for the clear.  Also,
        // because the driver handles clipping, we do not need to enumerate
        // rects.

        if (bUseMcdSpans) {
            rcl.left = __GL_UNBIAS_X(gc, gc->transform.clipX0);
            rcl.right = __GL_UNBIAS_X(gc, gc->transform.clipX1);
            rcl.bottom = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
            rcl.top = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
            bMoreRects = FALSE;
        } else
            bMoreRects = GetClearSubRectangle(cfb, &rcl, pwnd, &ClipEnumState);
        if (rcl.right == rcl.left)
            continue;

        // Case: no dithering, no masking

        if( !bMasking && !bDither ) {

            if( bDIB )
                DIBIndex8Clear( cfb, &rcl, clearColor );
            else if (bUseMcdSpans)
                Index8MaskedClear( cfb, &rcl, clearColor, NULL );
            else
                wglFillRect(gengc, pwnd, &rcl,
                            (ULONG) clearColor & 0x000000FF);
        }

        // Case: masking, maybe dithering

        else if( bMasking ) {
            Index8MaskedClear( cfb, &rcl, clearColor,
                               bDither ? (GLubyte *)ditherMatrix : NULL );
        }

        // Case: just dithering

        else {
            Index8DitherClear(cfb, &rcl, (GLubyte *)ditherMatrix, bDIB );
        }
    }
}

/******************************Public*Routine******************************\
* RGBMaskedClear
*
* Clear function for 24-bit (RGB/BGR) Masked clears
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
RGBMaskedClear(__GLcolorBuffer *cfb, RECTL *rcl, GLuint color, GLuint index)
{
    GLint cSpanWidth, ySpan;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    __GLcontext *gc = (__GLcontext *) gengc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLboolean bDIB;
    GLuint *destColors, *cp;
    GLubyte *puj, *puj2, *pujEnd;
    GLuint result, src;
    GLuint *pTrans;

    pfmt = &gengc->gsurf.pfd;
    cSpanWidth = rcl->right - rcl->left;
    bDIB  = cfb->buf.flags & DIB_FORMAT ? TRUE : FALSE;
    if( pfmt->iPixelType != PFD_TYPE_RGBA ) {

        destColors = (GLuint *) gcTempAlloc(gc, cSpanWidth*sizeof(GLuint));
        if( NULL == destColors )
            return;

        pTrans = (GLuint *) gengc->pajTranslateVector + 1;
    }

    puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base +
                             (rcl->top*cfb->buf.outerWidth) + (rcl->left*3))
                     : gengc->ColorsBits;
    pujEnd = puj + 3*cSpanWidth;
    for (ySpan = rcl->top; ySpan < rcl->bottom; ySpan++) {

        if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
            // fetch based on bDIB
            if( !bDIB ) {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, FALSE);
            }
            src = color & cfb->sourceMask;
            for( puj2 = puj; puj2 < pujEnd; puj2+=3 ) {
                Copy3Bytes( &result, puj2 );  // get dst pixel
                result   = src | (result & cfb->destMask);
                Copy3Bytes( puj2, &result );
            }
        }
        else {  // Color Index
            ScrnRGBCIReadSpan( cfb, rcl->left, ySpan, destColors, cSpanWidth,
                                 bDIB );
            cp = destColors;
            src = index & cfb->sourceMask;
            for( puj2 = puj; puj2 < pujEnd; puj2+=3, cp++ ) {
                result = src | (*cp & cfb->destMask);
                result = pTrans[result];
                Copy3Bytes( puj2, &result );
            }
        }

        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, TRUE);

        if( bDIB ) {
            puj += cfb->buf.outerWidth;
            pujEnd = puj + 3*cSpanWidth;
        }
    }
    if( pfmt->iPixelType != PFD_TYPE_RGBA )
        gcTempFree(gc, destColors);
}

/******************************Public*Routine******************************\
* DIBRGBClear
*
* Clear function for 24-bit (RGB/BGR) DIB pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL DIBRGBClear(__GLcolorBuffer *cfb, RECTL *rcl, GLubyte *color)
{
    __GLcontext *gc = cfb->buf.gc;
    GLint width = (rcl->right - rcl->left) * 3;
    GLuint *pul = (GLuint *) (((ULONG_PTR)cfb->buf.base +
                              rcl->top*cfb->buf.outerWidth) + (rcl->left*3));
    GLuint *pulEnd;
    GLubyte clear0, clear1, clear2;
    BYTE *ScanLineBuf;

    ScanLineBuf = (BYTE *) gcTempAlloc (gc, width);

    if (ScanLineBuf)  {

        // Alloc succeeds

        clear0 = color[0]; clear1 = color[1]; clear2 = color[2];
        RtlFillMemory24((PVOID)ScanLineBuf, width, clear0, clear1, clear2);
        pulEnd = (GLuint *)((ULONG_PTR)pul + 
                            ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));
        // Note: exit condition is (pul != pulEnd) rather than (pul < pulEnd)
        // because the DIB may be upside down which means that pul is moving
        // "backward" in memory rather than "forward".

        for ( ; pul != pulEnd; 
                pul = (GLuint *)((ULONG_PTR)pul + cfb->buf.outerWidth))
             memcpy((PVOID) pul, ScanLineBuf, width);

        gcTempFree(gc, ScanLineBuf); 

    }
}

/******************************Public*Routine******************************\
* RGBClear
*
* Clear function for all 24-bit (RGB/BGR) pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL RGBClear(__GLcolorBuffer *cfb)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    RECTL  rcl;
    GLuint clearColor;
    GLGENwindow *pwnd;
    GLboolean bMoreRects = GL_TRUE;
    DWORD index;
    GLint ClipEnumState;
    GLboolean bMasking = (cfb->buf.flags & COLORMASK_ON) != 0;
    GLboolean bDIB = (cfb->buf.flags & DIB_FORMAT) != 0;
    GLboolean bUseMcdSpans = gengc->pMcdState && !bDIB;

    DBGENTRY("RGBClear\n");

    // Convert the clear color to individual RGB components.

    pfmt = &gengc->gsurf.pfd;
    if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
        GLubyte clearR, clearG, clearB;
        GLubyte *pClearColor;

        clearR = (GLubyte)(gc->state.raster.clear.r*gc->frontBuffer.redScale);
        clearG = (GLubyte)(gc->state.raster.clear.g*gc->frontBuffer.greenScale);
        clearB = (GLubyte)(gc->state.raster.clear.b*gc->frontBuffer.blueScale);

        pClearColor = (GLubyte *) &clearColor;
        if( cfb->redShift == 16 ) {
            // BGR mode
            *pClearColor++ = clearB;
            *pClearColor++ = clearG;
            *pClearColor = clearR;
        }
        else {
            // RGB mode
            *pClearColor++ = clearR;
            *pClearColor++ = clearG;
            *pClearColor = clearB;
        }
    }
    else {
        GLuint *pTrans;

        index = (DWORD) (gc->state.raster.clearIndex + 0.5F);
        index &= cfb->redMax;
        pTrans = (GLuint *) gengc->pajTranslateVector;
        clearColor = pTrans[index+1];
    }

    // Get clear rectangle in screen coordinates.
    pwnd = cfb->bitmap->pwnd;
    if (pwnd->clipComplexity == CLC_COMPLEX) {
        InitClearRectangle(pwnd, &ClipEnumState);
#ifdef LATER
    } else if (   !bMasking
               && bDIB
               && gengc->fDirtyRegionEnabled
               && !RECTLISTIsMax(&gengc->rlClear)
               && ((GLuint)clearColor == gengc->clearColor)
              ) {
        //
        // use dirty region rects
        //

        if (!RECTLISTIsEmpty(&gengc->rlClear)) {
            PYLIST pylist = gengc->rlClear.pylist;

            while (pylist != NULL) {
                PXLIST pxlist = pylist->pxlist;

                rcl.top = pylist->s;
                rcl.bottom = pylist->e;

                while (pxlist != NULL) {
                    rcl.left = pxlist->s;
                    rcl.right = pxlist->e;
                    DIBRGBClear( cfb, &rcl, (GLubyte *) &clearColor);
                    pxlist = pxlist->pnext;
                }
                pylist = pylist->pnext;
            }

            //
            // Union the blt region with the Clear region
            // and set the clear region to empty
            //

            RECTLISTOrAndClear(&gengc->rlBlt, &gengc->rlClear);
        }

        return;
    }

    if (gengc->fDirtyRegionEnabled) {
        //
        // if we come through this path then for some reason we
        // are clearing the entire window
        //

        RECTLISTSetEmpty(&gengc->rlClear);
        RECTLISTSetMax(&gengc->rlBlt);

        //
        // remember the clear color
        //

        gengc->clearColor = (GLuint)clearColor;
#endif
    }

    while (bMoreRects)
    {
        // Must use MCD spans if buffer not accessible as DIB.  In such a
        // case, window offset has been removed (see GenMcdUpdateBufferInfo),
        // so a window relative rectangle is required for the clear.  Also,
        // because the driver handles clipping, we do not need to enumerate
        // rects.

        if (bUseMcdSpans) {
            rcl.left = __GL_UNBIAS_X(gc, gc->transform.clipX0);
            rcl.right = __GL_UNBIAS_X(gc, gc->transform.clipX1);
            rcl.bottom = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
            rcl.top = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
            bMoreRects = FALSE;
        } else
            bMoreRects = GetClearSubRectangle(cfb, &rcl, pwnd, &ClipEnumState);
        if (rcl.right == rcl.left)
            continue;

        // Call aproppriate clear function

        if (bMasking || bUseMcdSpans) { // or INDEXMASK_ON
            RGBMaskedClear( cfb, &rcl, clearColor, index );
        }
        else {
            if (bDIB)
                DIBRGBClear( cfb, &rcl, (GLubyte *) &clearColor);
            else
                wglFillRect(gengc, pwnd, &rcl,
                            (ULONG) clearColor & 0x00FFFFFF);
        }
    }
}

/******************************Public*Routine******************************\
* Bitfield16DitherClear
*
* Clear device managed surface to the dithered clear color indicated
* in the __GLcolorBuffer.
*
* History:
*  06-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void
Bitfield16DitherClear(__GLcolorBuffer *cfb, RECTL *rcl, GLushort *mDither,
                         GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    GLushort *pDither;              // dithered color, relative to window origin
    UINT     i, j;
    GLushort *pus, *pusStart;           // pointer into span buffer
    GLint   ySpan;                      // index to window row to clear
    GLuint  cSpanWidth, cSpanWidth2;
    GLint   outerWidth4;
    GLuint   dithX, dithY;      // x,y offsets into dither matrix
    GLushort dithQuad[4];       // dither repetion quad along a span

    cSpanWidth = rcl->right - rcl->left;

    if( bDIB )
    {
        pusStart = (GLushort *)
                   ((ULONG_PTR)cfb->buf.base +
                    (rcl->top*cfb->buf.outerWidth) + (rcl->left << 1));

        /*
         *  Dither patterns repeat themselves every four rows
         */

        outerWidth4 = cfb->buf.outerWidth << 2;

        /*
         *  cSpanWidth is in pixels, convert it to bytes
         */

        cSpanWidth2 = cSpanWidth << 1;
    }

    // calc dither offset in x,y
    dithX = (rcl->left - cfb->buf.xOrigin) & 3;
    dithY = (rcl->top  - cfb->buf.yOrigin) & 3;

    for (j = 0; (j < 4) && ((rcl->top + j) < (UINT)rcl->bottom); j++)
    {
        // arrange the 4-pixel dither repetition pattern in x
        pDither = mDither + ((dithY+j)&3)*4;
        for( i = 0; i < 4; i ++ ) {
            dithQuad[i] = pDither[(dithX+i)&3];
        }

        // Copy the clear color into the span buffer.

        pus = gengc->ColorsBits;

        for (i = cSpanWidth / 4; i; i--)
        {
            *pus++ = dithQuad[0];
            *pus++ = dithQuad[1];
            *pus++ = dithQuad[2];
            *pus++ = dithQuad[3];
        }

        for (i = 0; i < (cSpanWidth & 3); i++)
        {
            *pus++ = dithQuad[i];
        }

        // Copy the span to the display for every 4th row of the window.

        if( bDIB ) {

            for (ySpan = rcl->top + j, pus = pusStart;
                 ySpan < rcl->bottom;
                 ySpan+=4,
                 pus = (GLushort *)((ULONG_PTR)pus + outerWidth4) ) {

                 RtlCopyMemory_UnalignedDst( pus, gengc->ColorsBits, cSpanWidth2 );
            }
            pusStart = (GLushort *)((ULONG_PTR)pusStart + cfb->buf.outerWidth);
        }
        else {
            for (ySpan = rcl->top + j; ySpan < rcl->bottom; ySpan+=4)
            {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                            ySpan, cSpanWidth, TRUE);
            }
        }
    }
}

/******************************Public*Routine******************************\
* Bitfield16MaskedClear
*
* Clear function for Bitfield16 Masked clears
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
Bitfield16MaskedClear(__GLcolorBuffer *cfb, RECTL *rcl, GLushort color,
                      GLuint index, GLushort *mDither)
{
    GLint cSpanWidth, ySpan;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    __GLcontext *gc = (__GLcontext *) gengc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLboolean bDIB;
    GLuint *destColors, *cp;
    GLushort *pus, *pus2, *pusEnd, *clearDither;
    GLushort result, src;
    GLuint *pTrans, i, j;
    GLuint   dithX, dithY;      // x,y offsets into dither matrix

    pfmt = &gengc->gsurf.pfd;
    cSpanWidth = rcl->right - rcl->left;
    bDIB  = cfb->buf.flags & DIB_FORMAT ? TRUE : FALSE;
    if( pfmt->iPixelType != PFD_TYPE_RGBA ) {
        destColors = (GLuint *) gcTempAlloc(gc, cSpanWidth*sizeof(GLuint));
        if( NULL == destColors )
            return;
        pTrans = (GLuint *) gengc->pajTranslateVector + 1;
    }

    pus = bDIB ? (GLushort *)((ULONG_PTR)cfb->buf.base +
                             (rcl->top*cfb->buf.outerWidth) + (rcl->left<<1))
                     : gengc->ColorsBits;
    pusEnd = pus + cSpanWidth;

    if( mDither ) {
        // calc dither offset in x,y
        dithX = (rcl->left - cfb->buf.xOrigin) & 3;
        dithY = (rcl->top - cfb->buf.yOrigin) & 3;
    }

    for (ySpan = rcl->top, j = 0; ySpan < rcl->bottom; ySpan++, j++) {

        if( mDither )
            clearDither = mDither + ((dithY + j)&3)*4;

        if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
            // fetch based on bDIB
            if( !bDIB ) {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, FALSE);
            }
            src = (GLushort)(color & cfb->sourceMask);
            for( pus2 = pus, i = 0; pus2 < pusEnd; pus2++, i++ ) {
                if( mDither )
                    src = clearDither[(dithX + i)&3];
                *pus2 = (GLushort)(src | (*pus2 & cfb->destMask));
            }
        }
        else {  // Color Index
            ScrnBitfield16CIReadSpan( cfb, rcl->left, ySpan, destColors,
                                        cSpanWidth, bDIB );
            cp = destColors;
            src = (GLushort)(index & cfb->sourceMask);
            for( pus2 = pus, i = 0; pus2 < pusEnd; pus2++, cp++, i++ ) {
                if( mDither )
                    src = clearDither[(dithX + i)&3];
                result = (GLushort)(src | (*cp & cfb->destMask));
                result = (GLushort)pTrans[result];
                *pus2 = result;
            }
        }

        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, TRUE);

        if( bDIB ) {
            pus = (GLushort *)((ULONG_PTR)pus + cfb->buf.outerWidth);
            pusEnd = pus + cSpanWidth;
        }
    }
    if( pfmt->iPixelType != PFD_TYPE_RGBA )
        gcTempFree(gc, destColors);
}

/******************************Public*Routine******************************\
* DIBBitfield16Clear
*
* Clear function for 16-bit DIB pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL DIBBitfield16Clear(__GLcolorBuffer *cfb, RECTL *rcl, GLushort clearColor)
{
    GLint    cSpanWidth;        // span width to clear
    GLushort *pus, *pusEnd;     // pointers into DIB

    cSpanWidth = rcl->right - rcl->left;

    pus = (GLushort *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + (rcl->left<<1));
    pusEnd = (GLushort *)((ULONG_PTR)pus + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

    // Note: exit condition is (pul != pulEnd) rather than (pul < pulEnd)
    // because the DIB may be upside down which means that pul is moving
    // "backward" in memory rather than "forward".

    for ( ; pus != pusEnd; pus = (GLushort *)((ULONG_PTR)pus + cfb->buf.outerWidth) )
    {
        RtlFillMemoryUshort(pus, cSpanWidth * sizeof(GLushort), clearColor);
    }
}

//!!!XXX -- don't need yet, but let's keep it around just in case
#if 0
/******************************Public*Routine******************************\
* DisplayBitfield16Clear
*
* Clear device managed surface to the clear color indicated
* in the __GLcolorBuffer.
*
* History:
*  16-Feb-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void
DisplayBitfield16Clear(__GLcolorBuffer *cfb, RECTL *rcl,
                         GLushort clearColor)
{
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    GLushort *pus, *pusEnd;
    GLint cSpanWidth;        // in pixels
    GLint ySpan;

    cSpanWidth = rcl->right - rcl->left;

    pus = (GLushort *) gengc->ColorsBits;
    pusEnd = pus + cSpanWidth;

// Initialize a span buffer to clear color.

    LocalRtlFillMemoryUshort(pus, cSpanWidth*sizeof(GLushort), clearColor);

    for ( ySpan = rcl->top; ySpan < rcl->bottom; ySpan++ )
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                    ySpan, cSpanWidth, TRUE);
    }
}
#endif

/******************************Public*Routine******************************\
* Bitfield16Clear
*
* Clear function for all 16-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL Bitfield16Clear(__GLcolorBuffer *cfb)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLushort clearColor;
    RECTL  rcl;
    GLGENwindow *pwnd;
    GLboolean bMoreRects = GL_TRUE;
    GLboolean bDither = GL_FALSE;
    GLboolean bMasking = (cfb->buf.flags & COLORMASK_ON) != 0;
    GLboolean bDIB = (cfb->buf.flags & DIB_FORMAT) != 0;
    GLboolean bUseMcdSpans = gengc->pMcdState && !bDIB;
    GLboolean bRGBA;
    GLushort ditherMatrix[4][4];
    DWORD index;
    GLint ClipEnumState;

    DBGENTRY("Bitfield16Clear\n");

    pfmt = &gengc->gsurf.pfd;
    bRGBA = (pfmt->iPixelType == PFD_TYPE_RGBA);

    /* if dithering enabled, see if we can ignore it, and if not,
        precompute a dither matrix
    */

    if( gc->state.enables.general & __GL_DITHER_ENABLE ) {
        bDither = CalcDitherMatrix( cfb, bRGBA, bMasking, GL_TRUE,
                                    (GLubyte *)ditherMatrix );
    }

    // Convert clear value

    if( bRGBA ) {
        clearColor =
      ((BYTE)(gc->state.raster.clear.r*gc->frontBuffer.redScale + __glHalf) <<
                cfb->redShift) |
      ((BYTE)(gc->state.raster.clear.g*gc->frontBuffer.greenScale + __glHalf) <<
                cfb->greenShift) |
      ((BYTE)(gc->state.raster.clear.b*gc->frontBuffer.blueScale + __glHalf) <<
                cfb->blueShift);
        if( ALPHA_IN_PIXEL( cfb ) )
            clearColor |= 
      ((BYTE)(gc->state.raster.clear.a*gc->frontBuffer.alphaScale + __glHalf) <<
                cfb->alphaShift);
    }
    else {
        GLuint *pTrans;

        index = (DWORD) (gc->state.raster.clearIndex + 0.5F);
        index &= cfb->redMax;
        pTrans = (GLuint *) gengc->pajTranslateVector;
        clearColor = (GLushort) pTrans[index+1];
    }

    // Get clear rectangle in screen coordinates.
    pwnd = cfb->bitmap->pwnd;
    if (pwnd->clipComplexity == CLC_COMPLEX) {
        InitClearRectangle(pwnd, &ClipEnumState);
#ifdef LATER
    } else if (   !bMasking
               && !bDither
               && bDIB
               && gengc->fDirtyRegionEnabled
               && !RECTLISTIsMax(&gengc->rlClear)
               && ((GLuint)clearColor == gengc->clearColor)
              ) {
        //
        // use dirty region rects
        //

        if (!RECTLISTIsEmpty(&gengc->rlClear)) {
            PYLIST pylist = gengc->rlClear.pylist;

            while (pylist != NULL) {
                PXLIST pxlist = pylist->pxlist;

                rcl.top = pylist->s;
                rcl.bottom = pylist->e;

                while (pxlist != NULL) {
                    rcl.left = pxlist->s;
                    rcl.right = pxlist->e;
                    DIBBitfield16Clear( cfb, &rcl, clearColor );
                    pxlist = pxlist->pnext;
                }
                pylist = pylist->pnext;
            }

            //
            // Union the blt region with the Clear region
            // and set the clear region to empty
            //

            RECTLISTOrAndClear(&gengc->rlBlt, &gengc->rlClear);
        }

        return;
    }

    if (gengc->fDirtyRegionEnabled) {
        //
        // if we come through this path then for some reason we
        // are clearing the entire window
        //

        RECTLISTSetEmpty(&gengc->rlClear);
        RECTLISTSetMax(&gengc->rlBlt);

        //
        // remember the clear color
        //

        gengc->clearColor = (GLuint)clearColor;
#endif
    }

    while (bMoreRects)
    {
        // Must use MCD spans if buffer not accessible as DIB.  In such a
        // case, window offset has been removed (see GenMcdUpdateBufferInfo),
        // so a window relative rectangle is required for the clear.  Also,
        // because the driver handles clipping, we do not need to enumerate
        // rects.

        if (bUseMcdSpans) {
            rcl.left = __GL_UNBIAS_X(gc, gc->transform.clipX0);
            rcl.right = __GL_UNBIAS_X(gc, gc->transform.clipX1);
            rcl.bottom = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
            rcl.top = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
            bMoreRects = FALSE;
        } else
            bMoreRects = GetClearSubRectangle(cfb, &rcl, pwnd, &ClipEnumState);
        if (rcl.right == rcl.left)
            continue;

        // Case: no dithering, no masking

        if( !bMasking && !bDither) {
            if (bDIB)
                DIBBitfield16Clear( cfb, &rcl, clearColor );
            else if (bUseMcdSpans)
                Bitfield16MaskedClear( cfb, &rcl, clearColor, index, NULL );
            else
                wglFillRect(gengc, pwnd, &rcl,
                            (ULONG) clearColor & 0x0000FFFF);

        }

        // Case: masking, maybe dithering

        else if( bMasking ) {
            Bitfield16MaskedClear( cfb, &rcl, clearColor, index,
                                   bDither ? (GLushort *)ditherMatrix : NULL );
        }

        // Case: just dithering

        else {
            Bitfield16DitherClear(cfb, &rcl, (GLushort *)ditherMatrix, bDIB );
        }
    }

}

/******************************Public*Routine******************************\
* Bitfield32MaskedClear
*
* Clear function for Bitfield16 Masked clears
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
Bitfield32MaskedClear(__GLcolorBuffer *cfb, RECTL *rcl, GLuint color, GLuint index)
{
    GLint cSpanWidth, ySpan;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    __GLcontext *gc = (__GLcontext *) gengc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLboolean bDIB;
    GLuint *destColors, *cp;
    GLuint *pul, *pul2, *pulEnd;
    GLuint result, src;
    GLuint *pTrans;

    pfmt = &gengc->gsurf.pfd;
    cSpanWidth = rcl->right - rcl->left;
    bDIB  = cfb->buf.flags & DIB_FORMAT ? TRUE : FALSE;
    if( pfmt->iPixelType != PFD_TYPE_RGBA ) {
        destColors = (GLuint *) gcTempAlloc(gc, cSpanWidth*sizeof(GLuint));
        if( NULL == destColors )
            return;
        pTrans = (GLuint *) gengc->pajTranslateVector + 1;
    }

    pul = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base +
                             (rcl->top*cfb->buf.outerWidth) + (rcl->left<<2))
                     : gengc->ColorsBits;
    pulEnd = pul + cSpanWidth;
    for (ySpan = rcl->top; ySpan < rcl->bottom; ySpan++) {

        if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
            // fetch based on bDIB
            if( !bDIB ) {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, FALSE);
            }
            src = color & cfb->sourceMask;
            for( pul2 = pul; pul2 < pulEnd; pul2++) {
                *pul2 = src | (*pul2 & cfb->destMask);
            }
        }
        else {  // Color Index
            ScrnBitfield32CIReadSpan( cfb, rcl->left, ySpan, destColors,
                                        cSpanWidth, bDIB );
            cp = destColors;
            src = index & cfb->sourceMask;
            for( pul2 = pul; pul2 < pulEnd; pul2++, cp++ ) {
                result = src | (*cp & cfb->destMask);
                result = pTrans[result];
                *pul2 = result;
            }
        }

        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, TRUE);

        if( bDIB ) {
            pul = (GLuint *)((ULONG_PTR)pul + cfb->buf.outerWidth);
            pulEnd = pul + cSpanWidth;
        }
    }
    if( pfmt->iPixelType != PFD_TYPE_RGBA )
        gcTempFree(gc, destColors);
}

/******************************Public*Routine******************************\
* DIBBitfield32Clear
*
* Clear function for 32-bit DIB pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL DIBBitfield32Clear(__GLcolorBuffer *cfb, RECTL *rcl, GLuint clearColor)
{
    GLint width = (rcl->right - rcl->left) * sizeof(ULONG);
    GLint height = (rcl->bottom - rcl->top);
    GLuint *pul = (GLuint *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + (rcl->left<<2));
    GLuint *pulEnd;

    if (cfb->buf.outerWidth > 0) {
        if (width == cfb->buf.outerWidth) {
            RtlFillMemoryUlong((PVOID) pul, width * height, clearColor);
            return;
        }
    } else {
        if (width == -cfb->buf.outerWidth) {
            RtlFillMemoryUlong(
                (PVOID)((ULONG_PTR)pul - width * (height - 1)),
                width * height,
                clearColor);
            return;
        }
    }

    pulEnd = (GLuint *)((ULONG_PTR)pul + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

    // Note: exit condition is (pul != pulEnd) rather than (pul < pulEnd)
    // because the DIB may be upside down which means that pul is moving
    // "backward" in memory rather than "forward".

    for ( ; pul != pulEnd; pul = (GLuint *)((ULONG_PTR)pul + cfb->buf.outerWidth))
    {
        RtlFillMemoryUlong((PVOID) pul, width, clearColor);
    }
}

/******************************Public*Routine******************************\
* Bitfield32Clear
*
* Clear function for all 32-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL Bitfield32Clear(__GLcolorBuffer *cfb)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLuint clearColor;
    RECTL  rcl;
    DWORD  index;
    GLGENwindow *pwnd;
    GLboolean bMoreRects = GL_TRUE;
    GLint ClipEnumState;
    GLboolean bMasking = (cfb->buf.flags & COLORMASK_ON) != 0;
    GLboolean bDIB = (cfb->buf.flags & DIB_FORMAT) != 0;
    GLboolean bUseMcdSpans = gengc->pMcdState && !bDIB;

    DBGENTRY("Bitfield32Clear\n");

    // Convert clear value

    pfmt = &gengc->gsurf.pfd;
    if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
        clearColor =
      ((BYTE)(gc->state.raster.clear.r*gc->frontBuffer.redScale + __glHalf) <<
                cfb->redShift) |
      ((BYTE)(gc->state.raster.clear.g*gc->frontBuffer.greenScale + __glHalf) <<
                cfb->greenShift) |
      ((BYTE)(gc->state.raster.clear.b*gc->frontBuffer.blueScale + __glHalf) <<
                cfb->blueShift);
        if( ALPHA_IN_PIXEL( cfb ) )
            clearColor |= 
      ((BYTE)(gc->state.raster.clear.a*gc->frontBuffer.alphaScale + __glHalf) <<
                cfb->alphaShift);
    }
    else {
        GLuint *pTrans;

        index = (DWORD) (gc->state.raster.clearIndex + 0.5F);
        index &= cfb->redMax;
        pTrans = (GLuint *) gengc->pajTranslateVector;
        clearColor = pTrans[index+1];
    }

    // Get clear rectangle in screen coordinates.
    pwnd = cfb->bitmap->pwnd;
    if (pwnd->clipComplexity == CLC_COMPLEX) {
        InitClearRectangle(pwnd, &ClipEnumState);
#ifdef LATER
    } else if (   !bMasking
               && bDIB
               && gengc->fDirtyRegionEnabled
               && !RECTLISTIsMax(&gengc->rlClear)
               && ((GLuint)clearColor == gengc->clearColor)
              ) {
        //
        // use dirty region rects
        //

        if (!RECTLISTIsEmpty(&gengc->rlClear)) {
            PYLIST pylist = gengc->rlClear.pylist;

            while (pylist != NULL) {
                PXLIST pxlist = pylist->pxlist;

                rcl.top = pylist->s;
                rcl.bottom = pylist->e;

                while (pxlist != NULL) {
                    rcl.left = pxlist->s;
                    rcl.right = pxlist->e;
                    DIBBitfield32Clear( cfb, &rcl, clearColor );
                    pxlist = pxlist->pnext;
                }
                pylist = pylist->pnext;
            }

            //
            // Union the blt region with the Clear region
            // and set the clear region to empty
            //

            RECTLISTOrAndClear(&gengc->rlBlt, &gengc->rlClear);
        }

        return;
    }

    if (gengc->fDirtyRegionEnabled) {
        //
        // if we come through this path then for some reason we
        // are clearing the entire window
        //

        RECTLISTSetEmpty(&gengc->rlClear);
        RECTLISTSetMax(&gengc->rlBlt);

        //
        // remember the clear color
        //

        gengc->clearColor = (GLuint)clearColor;
#endif
    }

    while (bMoreRects)
    {
        // Must use MCD spans if buffer not accessible as DIB.  In such a
        // case, window offset has been removed (see GenMcdUpdateBufferInfo),
        // so a window relative rectangle is required for the clear.  Also,
        // because the driver handles clipping, we do not need to enumerate
        // rects.

        if (bUseMcdSpans) {
            rcl.left = __GL_UNBIAS_X(gc, gc->transform.clipX0);
            rcl.right = __GL_UNBIAS_X(gc, gc->transform.clipX1);
            rcl.bottom = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
            rcl.top = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
            bMoreRects = FALSE;
        } else
            bMoreRects = GetClearSubRectangle(cfb, &rcl, pwnd, &ClipEnumState);
        if (rcl.right == rcl.left)
            continue;

        // Call aproppriate clear function

        if (bMasking || bUseMcdSpans) { // or INDEXMASK_ON
            Bitfield32MaskedClear( cfb, &rcl, clearColor, index );
        }
        else {
            if (bDIB)
                DIBBitfield32Clear( cfb, &rcl, clearColor );
            else
                wglFillRect(gengc, pwnd, &rcl, (ULONG) clearColor);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genline.c ===
/*
** Copyright 1991,1992,1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include "genline.h"
#include "devlock.h"

/******************************Public*Routine******************************\
* __fastGenLineSetupDisplay
*
* Initializes the accelerated line-rendering state machine for display surfaces.
* There are basically 4 levels in the state machine:
*   1. lineBegin
*           This function initializes the initial states of the lower levels.
*
*   2. lineVertex
*           This function adds vertices to the path
* 
*   3. lineEnd
*           This function calls the routine to stroke the path.
*
* History:
*  09-Jan-1996 -by- Drew Bliss [drewb]
*   Totally rewrote fast line support
*  29-Mar-1994 [v-eddier]
*   Changed name when __fastGenLineSetupDIB was added.
*  22-Mar-1994 -by- Eddie Robinson [v-eddier]
*   Wrote it.
\**************************************************************************/

BOOL FASTCALL __fastGenLineSetupDisplay(__GLcontext *gc)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    GENACCEL *genAccel = (GENACCEL *) gengc->pPrivateArea;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    // allocate line buffer
    
    if (!genAccel->pFastLineBuffer) {
        if (!(genAccel->pFastLineBuffer =
              (BYTE *) GCALLOC(gc, __FAST_LINE_BUFFER_SIZE)))
            return FALSE;
    }
    
    // Set the line rasterization function pointers
    gc->procs.lineBegin = __fastGenLineBegin;
    gc->procs.lineEnd = __fastGenLineEnd;
    
    if (gc->state.line.aliasedWidth > 1)
    {
        gc->procs.renderLine = __fastGenLineWide;
    }
    else
    {
        gc->procs.renderLine = __fastGenLine;
    }
    
    return TRUE;
}

/******************************Public*Routine******************************\
*
* __fastLineComputeOffsets
*
* Precomputes static offsets for fast line drawing
*
* History:
*  Tue Aug 15 18:10:29 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL __fastLineComputeOffsets(__GLGENcontext *gengc)
{
    GENACCEL *genAccel;

    genAccel = (GENACCEL *)gengc->pPrivateArea;
    ASSERTOPENGL(genAccel != NULL,
                 "ComputeFastLineOffsets with no genaccel\n");
    
// If acceleration is wired-in, set the offsets for line drawing.
// These offsets include the following:
//      subtraction of the viewport bias
//      addition of the client window origin
//      subtraction of .5 to align GL pixel centers with GDI's pixel centers
//      addition of 1/32 to round the value which will be converted to
//          28.4 fixed point

#ifdef _CLIENTSIDE_
    // Window-relative coordinates
    genAccel->fastLineOffsetX = 0 -
        gengc->gc.constants.viewportXAdjust - (__GLfloat) (0.5 - 0.03125);

    genAccel->fastLineOffsetY = 0 -
        gengc->gc.constants.viewportYAdjust - (__GLfloat) (0.5 - 0.03125);
#else
    // Screen-relative coordinates
    genAccel->fastLineOffsetX = gengc->gc.drawBuffer->buf.xOrigin - 
        gengc->gc.constants.viewportXAdjust - (__GLfloat) (0.5 - 0.03125);

    genAccel->fastLineOffsetY = gengc->gc.drawBuffer->buf.yOrigin - 
        gengc->gc.constants.viewportYAdjust - (__GLfloat) (0.5 - 0.03125);
#endif
}

/******************************Public*Routine******************************\
* __fastLineComputeColor*
*
* Computes the color index to use for line drawing.  These functions are
* called through a function pointer whenever the vertex color changes.
*
* History:
*  22-Mar-1994 -by- Eddie Robinson [v-eddier]
* Wrote it.
\**************************************************************************/

GLubyte vujRGBtoVGA[8] = {
    0x0, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf
};

ULONG FASTCALL __fastLineComputeColorRGB4(__GLcontext *gc, __GLcolor *color)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    PIXELFORMATDESCRIPTOR *pfmt = &gengc->gsurf.pfd;
    int ir, ig, ib;

    ir = (int) color->r;
    ig = (int) color->g;
    ib = (int) color->b;
    return (ULONG) vujRGBtoVGA[(ir << pfmt->cRedShift) |
                               (ig << pfmt->cGreenShift) |
                               (ib << pfmt->cBlueShift)];
}

ULONG FASTCALL __fastLineComputeColorRGB8(__GLcontext *gc, __GLcolor *color)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    PIXELFORMATDESCRIPTOR *pfmt = &gengc->gsurf.pfd;
    int ir, ig, ib;

    ir = (int) color->r;
    ig = (int) color->g;
    ib = (int) color->b;
    return (ULONG) gengc->pajTranslateVector[(ir << pfmt->cRedShift) |
                                             (ig << pfmt->cGreenShift) |
                                             (ib << pfmt->cBlueShift)];
}

ULONG FASTCALL __fastLineComputeColorRGB(__GLcontext *gc, __GLcolor *color)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    PIXELFORMATDESCRIPTOR *pfmt = &gengc->gsurf.pfd;
    int ir, ig, ib;

    ir = (int) color->r;
    ig = (int) color->g;
    ib = (int) color->b;
    return (ULONG) ((ir << pfmt->cRedShift) |
                    (ig << pfmt->cGreenShift) |
                    (ib << pfmt->cBlueShift));
}

ULONG FASTCALL __fastLineComputeColorCI4and8(__GLcontext *gc, __GLcolor *color)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;

    return (ULONG) gengc->pajTranslateVector[(int)color->r];
}

ULONG FASTCALL __fastLineComputeColorCI(__GLcontext *gc, __GLcolor *color)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    GLuint *pTrans = (GLuint *) gengc->pajTranslateVector;
    
    return (ULONG) pTrans[(int)(color->r)+1];
}

/******************************Public*Routine******************************\
* __glQueryLineAcceleration
*
* Determines if lines are accelerated through the DDI and performs some
* initialization.  Currently, this routine only checks for acceleration via
* the standard DDI.  Eventually, it could support checking for acceleration
* via the extended DDI.
*
* History:
*  22-Mar-1994 -by- Eddie Robinson [v-eddier]
* Wrote it.
\**************************************************************************/

void FASTCALL __glQueryLineAcceleration(__GLcontext *gc)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    GENACCEL *genAccel = (GENACCEL *) gengc->pPrivateArea;
    PIXELFORMATDESCRIPTOR *pfmt;

    pfmt = &gengc->gsurf.pfd;

    // On the client side we can draw into any surface with GDI
    // and (presumably) get the best possible plain 2D line drawing
    // performance
    genAccel->bFastLineDIBAccel = TRUE;

    //XXX eventually, check rxcaps and set appropriate mode bits

    genAccel->bFastLineDispAccel = TRUE;
    
    // set modes supported by hardware.  These are equivalent to the
    // gc->polygon.shader.modeFlags checked in the pick function
    
    genAccel->flLineAccelModes = 0;

    // Set the color computation function

    if (pfmt->iPixelType == PFD_TYPE_RGBA) {
        switch (pfmt->cColorBits) {
          case 4:
            genAccel->fastLineComputeColor = __fastLineComputeColorRGB4;
            break;
          case 8:
            genAccel->fastLineComputeColor = __fastLineComputeColorRGB8;
            break;
          case 16:
          case 24:
          case 32:
            genAccel->fastLineComputeColor = __fastLineComputeColorRGB;
            break;
          default:
            genAccel->bFastLineDispAccel = FALSE;
            return;
        }
    } else {
        switch (pfmt->cColorBits) {
          case 4:
          case 8:
            genAccel->fastLineComputeColor = __fastLineComputeColorCI4and8;
            break;
          case 16:
          case 24:
          case 32:
            genAccel->fastLineComputeColor = __fastLineComputeColorCI;
            break;
          default:
            genAccel->bFastLineDispAccel = FALSE;
            return;
        }
    }
}    

/**************************************************************************/

// Macros to hide how the single pFastLineBuffer is divided into two
// sections, one for points and one for counts
#define FAST_LINE_FIRST_POINT(genAccel) \
    ((POINT *)(genAccel)->pFastLineBuffer)

#define FAST_LINE_FIRST_COUNT(genAccel) \
    ((DWORD *)((genAccel)->pFastLineBuffer+__FAST_LINE_BUFFER_SIZE)- \
     __FAST_LINE_BUFFER_COUNTS)
    
#define FAST_LINE_LAST_POINT(genAccel) \
    ((POINT *)FAST_LINE_FIRST_COUNT(genAccel)-1)
    
#define FAST_LINE_LAST_COUNT(genAccel) \
    ((DWORD *)((genAccel)->pFastLineBuffer+__FAST_LINE_BUFFER_SIZE)-1)

/******************************Public*Routine******************************\
*
* __fastGenLineBegin
*
* Initializes fast line state
*
* History:
*  Mon Jan 08 19:22:32 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL __fastGenLineBegin(__GLcontext *gc)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    GENACCEL *genAccel = &gengc->genAccel;

    genAccel->pFastLinePoint = FAST_LINE_FIRST_POINT(genAccel)-1;
    genAccel->pFastLineCount = FAST_LINE_FIRST_COUNT(genAccel)-1;
    genAccel->fastLineCounts = 0;
}

/******************************Public*Routine******************************\
*
* __fastGenLineEnd
*
* Renders any current lines in the fast line buffer and
* then resets the fast line state
*
* History:
*  Mon Jan 08 19:22:52 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL __fastGenLineEnd(__GLcontext *gc)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    GENACCEL *genAccel = &gengc->genAccel;
    ULONG ulSolidColor;
    HDC hdc;
    HPEN hpen;

    if (genAccel->fastLineCounts == 0)
    {
        return;
    }
    
    // If there is no lock, we must have failed to reacquire the lock
    // from the previous call to wglStrokePath.  This is an error condition
    // and we should not continue.

    if (gengc->fsLocks == 0)
    {
	WARNING("fastGenLineEnd: no lock\n");
	return;
    }

    // We need to sychronize with GDI before making GDI calls
    glsrvSynchronizeWithGdi(gengc, gengc->pwndLocked,
                            COLOR_LOCK_FLAGS | DEPTH_LOCK_FLAGS);

    // If this color is the same as the one we've cached, use the
    // cached information
    hdc = CURRENT_DC_GC(gc);
    if (!gengc->fStrokeInvalid && hdc == gengc->hdcStroke)
    {
        hpen = gengc->hpenStroke;
        ASSERTOPENGL(hpen != NULL, "Cached stroke pen is null\n");
    }
    else
    {
        if (gengc->hpenStroke != NULL)
        {
            // Deselect the object before deletion
            if (gengc->hdcStroke != NULL)
            {
                SelectObject(gengc->hdcStroke, GetStockObject(BLACK_PEN));
                gengc->hdcStroke = NULL;
            }
            
            DeleteObject(gengc->hpenStroke);
        }

        ulSolidColor = wglTranslateColor(gengc->crStroke, hdc,
                                         gengc, &gengc->gsurf.pfd);
        hpen = CreatePen(PS_SOLID, 0, ulSolidColor);
        gengc->hpenStroke = hpen;
        
        if (hpen == NULL ||
            SelectObject(hdc, hpen) == NULL)
        {
            if (hpen != NULL)
            {
                DeleteObject(hpen);
                gengc->hpenStroke = NULL;
            }
            
            gengc->cStroke.r = -1.0f;
            gengc->fStrokeInvalid = TRUE;
            goto Exit;
        }

        gengc->hdcStroke = hdc;
        gengc->fStrokeInvalid = FALSE;
    }

#ifdef DBG_VERBOSE
    {
        DWORD i;
        DWORD *count;
        POINT *pt;

        count = FAST_LINE_FIRST_COUNT(genAccel);
        pt = FAST_LINE_FIRST_POINT(genAccel);
        for (i = 0; i < genAccel->fastLineCounts; i++)
        {
            DbgPrint("Polyline with %d points at %d\n",
                     *count, pt-FAST_LINE_FIRST_POINT(genAccel));
            pt += *count;
            count++;
        }
    }
#endif
    
    PolyPolyline(hdc,
                 FAST_LINE_FIRST_POINT(genAccel),
                 FAST_LINE_FIRST_COUNT(genAccel),
                 genAccel->fastLineCounts);

 Exit:
    // No more need for GDI operations
    glsrvDecoupleFromGdi(gengc, gengc->pwndLocked,
                         COLOR_LOCK_FLAGS | DEPTH_LOCK_FLAGS);
    
    // Reset
    __fastGenLineBegin(gc);
}

/******************************Public*Routine******************************\
*
* __fastGenLineSetStrokeColor
*
* Updates cached pen with current color if necessary
*
* History:
*  Wed Jan 17 20:37:15 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL __fastGenLineSetStrokeColor(__GLGENcontext *gengc, __GLcolor *color)
{
    if (__GL_FLOAT_NE(color->r, gengc->cStroke.r) ||
	(gengc->gsurf.pfd.iPixelType == PFD_TYPE_RGBA
	 && (__GL_FLOAT_NE(color->g, gengc->cStroke.g) ||
	     __GL_FLOAT_NE(color->b, gengc->cStroke.b))))
    {
        ASSERTOPENGL(color->r >= 0.0f, "Invalid color\n");
        
#ifdef DBG_VERBOSE
        if (gengc->cStroke.r >= 0.0f)
        {
            DbgPrint("Color change\n");
        }
#endif
        
        // Flush whatever we have so far
        __fastGenLineEnd(&gengc->gc);

        // Set current color
	if (gengc->gsurf.pfd.iPixelType == PFD_TYPE_RGBA)
	    gengc->cStroke = *color;
	else
	    gengc->cStroke.r = color->r;
        gengc->crStroke =
            gengc->genAccel.fastLineComputeColor((__GLcontext *)gengc,
                                                 &gengc->cStroke);
        // Invalidate cached pen
        gengc->fStrokeInvalid = TRUE;

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/******************************Public*Routine******************************\
*
* __fastGenLine
*
* Accumulates incoming vertices in the fast line buffer
* Thin line version
*
* History:
*  Mon Jan 08 19:23:19 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL __fastGenLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                            GLuint flags)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    GENACCEL *genAccel = &gengc->genAccel;
    POINT pt;

#ifdef DBG_VERBOSE
    DbgPrint("Counts %d, count %d, flags %X\n",
             genAccel->fastLineCounts,
             genAccel->pFastLineCount >= FAST_LINE_FIRST_COUNT(genAccel) ?
             *genAccel->pFastLineCount : -1,
             flags);
#endif
    
    // Check for flushing conditions.  We flush if:
    //  The provoking vertex's color is different from the current color
    //  This is the first vertex of a line and we don't have space for
    //   a new count and two vertices
    //  This is not the first vertex of a line and we don't have space for
    //   a new vertex
    //
    // According to spec we have to use color form a second vertex for flat
    // shaded case
    //
    if (__fastGenLineSetStrokeColor(gengc, v1->color))
    {
        // Since we flushed, the current vertex is now the beginning
        // of a polyline
        flags |= __GL_LVERT_FIRST;
    }

    if (((flags & __GL_LVERT_FIRST) != 0 &&
         (genAccel->pFastLinePoint+1 >= FAST_LINE_LAST_POINT(genAccel) ||
          genAccel->pFastLineCount >= FAST_LINE_LAST_COUNT(genAccel))) ||
        ((flags & __GL_LVERT_FIRST) == 0 &&
         genAccel->pFastLinePoint >= FAST_LINE_LAST_POINT(genAccel)))
    {
#ifdef DBG_VERBOSE
        DbgPrint("Overflow\n");
#endif
        
        __fastGenLineEnd(gc);

        // Since we flushed, the current vertex is now the beginning
        // of a polyline
        flags |= __GL_LVERT_FIRST;
    }

    // If we're starting a polyline, update the counts and add
    // the vertex data
    if (flags & __GL_LVERT_FIRST)
    {
#ifdef DBG_VERBOSE
        if (genAccel->pFastLineCount >= FAST_LINE_FIRST_COUNT(genAccel))
        {
            DbgPrint("First ended polyline with %d points\n",
                     *genAccel->pFastLineCount);
        }
#endif
        // Check to make sure we don't ever create segments with only
        // one vertex
        ASSERTOPENGL(genAccel->pFastLineCount <
                     FAST_LINE_FIRST_COUNT(genAccel) ||
                     *genAccel->pFastLineCount > 1,
                     "Line segment with only one vertex\n");

        genAccel->fastLineCounts++;
        genAccel->pFastLineCount++;
        *genAccel->pFastLineCount = 1;
        
        // Compute device coordinates
        pt.x = __FAST_LINE_FLTTODEV(v0->window.x + genAccel->fastLineOffsetX);
        pt.y = __FAST_LINE_FLTTODEV(v0->window.y + genAccel->fastLineOffsetY);
        *(++genAccel->pFastLinePoint) = pt;
    }
    
    ASSERTOPENGL(genAccel->pFastLineCount >=
                 FAST_LINE_FIRST_COUNT(genAccel) &&
                 *genAccel->pFastLineCount > 0,
                 "Added fast point without count\n");
    
    // Compute device coordinates
    pt.x = __FAST_LINE_FLTTODEV(v1->window.x + genAccel->fastLineOffsetX);
    pt.y = __FAST_LINE_FLTTODEV(v1->window.y + genAccel->fastLineOffsetY);
    (*genAccel->pFastLineCount)++;
    *(++genAccel->pFastLinePoint) = pt;
    
    // Check on counts also
    ASSERTOPENGL(genAccel->pFastLineCount <= FAST_LINE_LAST_COUNT(genAccel),
                 "Fast line count buffer overflow\n");
    ASSERTOPENGL(genAccel->pFastLinePoint <= FAST_LINE_LAST_POINT(genAccel),
                 "Fast line point buffer overflow\n");
    
    // Make sure the current color is being maintained properly
    ASSERTOPENGL((v1->color->r == gengc->cStroke.r) &&
		 (gengc->gsurf.pfd.iPixelType == PFD_TYPE_COLORINDEX ||
                     (v1->color->g == gengc->cStroke.g &&
		      v1->color->b == gengc->cStroke.b)),
                 "Fast line color mismatch\n");
}

/******************************Public*Routine******************************\
*
* __fastGenLineWide
*
* Accumulates incoming vertices in the fast line buffer
* Wide line version
* For wide lines we can't maintain connectivity because of the
* way OpenGL wide lines are defined.  Instead, each segment
* of a wide line is decomposed into aliasedWidth unconnected
* line segments
*
* History:
*  Tue Jan 09 11:32:10 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL __fastGenLineWide(__GLcontext *gc, __GLvertex *v0,
                                __GLvertex *v1, GLuint flags)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    GENACCEL *genAccel = &gengc->genAccel;
    POINT pt1, pt2;
    GLint width;
    long adjust;
    GLfloat dx, dy;

    // Set the current pen color
    // According to spec we have to use color form a second vertex for flat
    // shaded case
    //
    __fastGenLineSetStrokeColor(gengc, v1->color);
    
    // We have a wide line segment from v0 to v1
    // Compute its width and add an appropriate number of
    // side-by-side thin segments to create the wide form

    // Compute device coordinates
    pt1.x = __FAST_LINE_FLTTODEV(v0->window.x +
                                 genAccel->fastLineOffsetX);
    pt1.y = __FAST_LINE_FLTTODEV(v0->window.y +
                                 genAccel->fastLineOffsetY);
    pt2.x = __FAST_LINE_FLTTODEV(v1->window.x +
                                 genAccel->fastLineOffsetX);
    pt2.y = __FAST_LINE_FLTTODEV(v1->window.y +
                                 genAccel->fastLineOffsetY);
    
    width = gc->state.line.aliasedWidth;

    /*
    ** Compute the minor-axis adjustment for the first line segment
    ** this can be a fixed point value with 4 fractional bits
    */
    adjust = ((width - 1) * __FAST_LINE_UNIT_VALUE) / 2;
        
    // Determine the major axis
    dx = v0->window.x - v1->window.x;
    if (dx < 0.0)
    {
        dx = -dx;
    }
    dy = v0->window.y - v1->window.y;
    if (dy < 0.0)
    {
        dy = -dy;
    }

    if (dx > dy)
    {
        pt1.y -= adjust;
        pt2.y -= adjust;

        while (width-- > 0)
        {
            // Make sure we have room for another count and two more
            // vertices
            if (genAccel->pFastLinePoint+1 >= FAST_LINE_LAST_POINT(genAccel) ||
                genAccel->pFastLineCount >= FAST_LINE_LAST_COUNT(genAccel))
            {
                __fastGenLineEnd(gc);
            }
            
            genAccel->fastLineCounts++;
            genAccel->pFastLineCount++;
            *genAccel->pFastLineCount = 2;
            *(++genAccel->pFastLinePoint) = pt1;
            *(++genAccel->pFastLinePoint) = pt2;

            pt1.y++;
            pt2.y++;
        }
    }
    else
    {
        pt1.x -= adjust;
        pt2.x -= adjust;

        while (width-- > 0)
        {
            // Make sure we have room for another count and two more
            // vertices
            if (genAccel->pFastLinePoint+1 >= FAST_LINE_LAST_POINT(genAccel) ||
                genAccel->pFastLineCount >= FAST_LINE_LAST_COUNT(genAccel))
            {
                __fastGenLineEnd(gc);
            }
            
            genAccel->fastLineCounts++;
            genAccel->pFastLineCount++;
            *genAccel->pFastLineCount = 2;
            *(++genAccel->pFastLinePoint) = pt1;
            *(++genAccel->pFastLinePoint) = pt2;

            pt1.x++;
            pt2.x++;
        }
    }
}

#if NT_NO_BUFFER_INVARIANCE

PFN_RENDER_LINE __fastGenRenderLineDIBFuncs[32] = {
    __fastGenRenderLineDIBCI8,
    __fastGenRenderLineDIBCI16,
    __fastGenRenderLineDIBCIRGB,
    __fastGenRenderLineDIBCIBGR,
    __fastGenRenderLineDIBCI32,
    NULL,
    NULL,
    NULL,
    __fastGenRenderLineDIBRGB8,
    __fastGenRenderLineDIBRGB16,
    __fastGenRenderLineDIBRGB,
    __fastGenRenderLineDIBBGR,
    __fastGenRenderLineDIBRGB32,
    NULL,
    NULL,
    NULL,
    __fastGenRenderLineWideDIBCI8,
    __fastGenRenderLineWideDIBCI16,
    __fastGenRenderLineWideDIBCIRGB,
    __fastGenRenderLineWideDIBCIBGR,
    __fastGenRenderLineWideDIBCI32,
    NULL,
    NULL,
    NULL,
    __fastGenRenderLineWideDIBRGB8,
    __fastGenRenderLineWideDIBRGB16,
    __fastGenRenderLineWideDIBRGB,
    __fastGenRenderLineWideDIBBGR,
    __fastGenRenderLineWideDIBRGB32,
    NULL,
    NULL,
    NULL
};

/******************************Public*Routine******************************\
* __fastGenLineSetupDIB
*
* Initializes the accelerated line-rendering function pointer for bitmap
* surfaces.  All accelerated lines drawn to bitmaps are drawn by the
* gc->procs.renderLine funtion pointer.
*
* History:
*  29-Mar-1994 -by- Eddie Robinson [v-eddier]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL __fastGenLineSetupDIB(__GLcontext *gc)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    PIXELFORMATDESCRIPTOR *pfmt = &gengc->gsurf.pfd;
    GLint index;

    switch (pfmt->cColorBits) {
      case 8:
        index = 0;
        break;
      case 16:
        index = 1;
        break;
      case 24:
        if (pfmt->cRedShift == 0)
            index = 2;
        else
            index = 3;
        break;
      case 32:
        index = 4;
        break;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB)
        index |= 0x08;
        
    if (gc->state.line.aliasedWidth > 1)
        index |= 0x10;

    gc->procs.renderLine = __fastGenRenderLineDIBFuncs[index];
    return TRUE;
}

void FASTCALL __fastGenRenderLineDIBRGB8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, pixel;
    GLint x, y;

    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned char) __fastLineComputeColorRGB8(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + x +
                                    (y * cfb->buf.outerWidth));

    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB
}

void FASTCALL __fastGenRenderLineDIBRGB16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned short *addr, pixel;
    GLint x, y, outerWidth_2;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned short) __fastLineComputeColorRGB(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned short *) ((GLint)cfb->buf.base + (x << 1) +
                                     (y * cfb->buf.outerWidth));

    outerWidth_2 = cfb->buf.outerWidth >> 1;

    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * outerWidth_2);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * outerWidth_2);
           
    __FAST_LINE_STROKE_DIB
}

void FASTCALL __fastGenRenderLineDIBRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, ir, ig, ib;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    cp = v1->color;
    ir = (unsigned char) cp->r;
    ig = (unsigned char) cp->g;
    ib = (unsigned char) cp->b;
    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                                    (y * cfb->buf.outerWidth));
                                    
    addrLittle = (gc->line.options.xLittle * 3) +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = (gc->line.options.xBig * 3) +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB24
}

void FASTCALL __fastGenRenderLineDIBBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, ir, ig, ib;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    cp = v1->color;
    ir = (unsigned char) cp->b;
    ig = (unsigned char) cp->g;
    ib = (unsigned char) cp->r;
    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                                    (y * cfb->buf.outerWidth));

    addrLittle = (gc->line.options.xLittle * 3) +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = (gc->line.options.xBig * 3) +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB24
}

void FASTCALL __fastGenRenderLineDIBRGB32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned long *addr, pixel;
    GLint x, y, outerWidth_4;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = __fastLineComputeColorRGB(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned long *) ((GLint)cfb->buf.base + (x << 2) +
                              (y * cfb->buf.outerWidth));

    outerWidth_4 = cfb->buf.outerWidth >> 2;
    
    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * outerWidth_4);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * outerWidth_4);
           
    __FAST_LINE_STROKE_DIB
}

void FASTCALL __fastGenRenderLineDIBCI8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned char) __fastLineComputeColorCI4and8(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + x +
                                    (y * cfb->buf.outerWidth));

    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB
}

void FASTCALL __fastGenRenderLineDIBCI16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned short *addr, pixel;
    GLint x, y, outerWidth_2;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned short) __fastLineComputeColorCI(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned short *) ((GLint)cfb->buf.base + (x << 1) +
                               (y * cfb->buf.outerWidth));

    outerWidth_2 = cfb->buf.outerWidth >> 1;
    
    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * outerWidth_2);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * outerWidth_2);
           
    __FAST_LINE_STROKE_DIB
}

/*
** XXX GRE swabs bytes in palette, DIBCIRGB & DIBCIBGR are identical now
*/
void FASTCALL __fastGenRenderLineDIBCIRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, ir, ig, ib;
    unsigned long pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    // Red is lsb of pixel
    pixel = __fastLineComputeColorCI(gc, v1->color);
    ir = (unsigned char) (pixel & 0xff);
    ig = (unsigned char) ((pixel >> 8) & 0xff);
    ib = (unsigned char) ((pixel >> 16) & 0xff);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                                    (y * cfb->buf.outerWidth));

    addrLittle = (gc->line.options.xLittle * 3) +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = (gc->line.options.xBig * 3) +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB24
}

void FASTCALL __fastGenRenderLineDIBCIBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, ir, ig, ib;
    unsigned long pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    // Blue is lsb of pixel
    pixel = __fastLineComputeColorCI(gc, v1->color);
    // Swap blue and red
    ir = (unsigned char) (pixel & 0xff);
    ig = (unsigned char) ((pixel >> 8) & 0xff);
    ib = (unsigned char) ((pixel >> 16) & 0xff);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                                    (y * cfb->buf.outerWidth));

    addrLittle = (gc->line.options.xLittle * 3) +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = (gc->line.options.xBig * 3) +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB24
}

void FASTCALL __fastGenRenderLineDIBCI32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned long *addr, pixel;
    GLint x, y, outerWidth_4;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = __fastLineComputeColorCI(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned long *) ((GLint)cfb->buf.base + (x << 2) +
                              (y * cfb->buf.outerWidth));

    outerWidth_4 = cfb->buf.outerWidth >> 2;
    
    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * outerWidth_4);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * outerWidth_4);
           
    __FAST_LINE_STROKE_DIB
}

void FASTCALL __fastGenRenderLineWideDIBRGB8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned char) __fastLineComputeColorRGB8(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + x +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBRGB16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned short *addr, pixel;
    GLint x, y, outerWidth_2;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned short) __fastLineComputeColorRGB(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned short *) ((GLint)cfb->buf.base + (x << 1) +
                               (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    outerWidth_2 = cfb->buf.outerWidth >> 1;

    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = outerWidth_2;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * outerWidth_2);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * outerWidth_2);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * outerWidth_2);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * outerWidth_2);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, ir, ig, ib;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    cp = v1->color;
    ir = (unsigned char) cp->r;
    ig = (unsigned char) cp->g;
    ib = (unsigned char) cp->b;
    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = (gc->line.options.xLittle * 3) +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = (gc->line.options.xBig * 3) +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 3;

        addrLittle = ((gc->line.options.xLittle - width) * 3) +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = ((gc->line.options.xBig - width) * 3) +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB24_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, ir, ig, ib;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    cp = v1->color;
    ir = (unsigned char) cp->b;
    ig = (unsigned char) cp->g;
    ib = (unsigned char) cp->r;
    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = (gc->line.options.xLittle * 3) +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = (gc->line.options.xBig * 3) +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 3;

        addrLittle = ((gc->line.options.xLittle - width) * 3) +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = ((gc->line.options.xBig - width) * 3) +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB24_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBRGB32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned long *addr, pixel;
    GLint x, y, outerWidth_4;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = __fastLineComputeColorRGB(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned long *) ((GLint)cfb->buf.base + (x << 2) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    outerWidth_4 = cfb->buf.outerWidth >> 2;

    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = outerWidth_4;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * outerWidth_4);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * outerWidth_4);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * outerWidth_4);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * outerWidth_4);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBCI8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned char) __fastLineComputeColorCI4and8(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + x +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBCI16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned short *addr, pixel;
    GLint x, y, outerWidth_2;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned short) __fastLineComputeColorCI(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned short *) ((GLint)cfb->buf.base + (x << 1) +
                               (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    outerWidth_2 = cfb->buf.outerWidth >> 1;

    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = outerWidth_2;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * outerWidth_2);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * outerWidth_2);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * outerWidth_2);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * outerWidth_2);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBCIRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, ir, ig, ib;
    unsigned long pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    // Red is lsb of pixel
    pixel = __fastLineComputeColorCI(gc, v1->color);
    ir = (unsigned char) (pixel & 0xff);
    ig = (unsigned char) ((pixel >> 8) & 0xff);
    ib = (unsigned char) ((pixel >> 16) & 0xff);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = (gc->line.options.xLittle * 3) +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = (gc->line.options.xBig * 3) +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 3;

        addrLittle = ((gc->line.options.xLittle - width) * 3) +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = ((gc->line.options.xBig - width) * 3) +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB24_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBCIBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, ir, ig, ib;
    unsigned long pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    // Blue is lsb of pixel
    pixel = __fastLineComputeColorCI(gc, v1->color);
    // Swap blue and red
    ir = (unsigned char) (pixel & 0xff);
    ig = (unsigned char) ((pixel >> 8) & 0xff);
    ib = (unsigned char) ((pixel >> 16) & 0xff);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = (gc->line.options.xLittle * 3) +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = (gc->line.options.xBig * 3) +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 3;

        addrLittle = ((gc->line.options.xLittle - width) * 3) +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = ((gc->line.options.xBig - width) * 3) +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB24_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBCI32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned long *addr, pixel;
    GLint x, y, outerWidth_4;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = __fastLineComputeColorCI(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned long *) ((GLint)cfb->buf.base + (x << 2) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    outerWidth_4 = cfb->buf.outerWidth >> 2;

    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = outerWidth_4;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * outerWidth_4);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * outerWidth_4);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * outerWidth_4);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * outerWidth_4);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

#endif //NT_NO_BUFFER_INVARIANCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genline.h ===
/*
** Macros and externs used by genline.c
*/

extern ULONG FASTCALL __fastLineComputeColorRGB4(__GLcontext *gc, __GLcolor *color);
extern ULONG FASTCALL __fastLineComputeColorRGB8(__GLcontext *gc, __GLcolor *color);
extern ULONG FASTCALL __fastLineComputeColorRGB(__GLcontext *gc, __GLcolor *color);
extern ULONG FASTCALL __fastLineComputeColorCI4and8(__GLcontext *gc, __GLcolor *color);
extern ULONG FASTCALL __fastLineComputeColorCI(__GLcontext *gc, __GLcolor *color);

extern void FASTCALL __fastGenLineBegin(__GLcontext *gc);
extern void FASTCALL __fastGenLineEnd(__GLcontext *gc);
extern void FASTCALL __fastGenLine(__GLcontext *gc, __GLvertex *v0,
                                   __GLvertex *v1, GLuint flags);
extern void FASTCALL __fastGenLineWide(__GLcontext *gc, __GLvertex *v0,
                                       __GLvertex *v1, GLuint flags);

BOOL FASTCALL __fastGenLineSetupDisplay(__GLcontext *gc);
void FASTCALL __glQueryLineAcceleration(__GLcontext *gc);

BOOL FASTCALL __glGenSetupEitherLines(__GLcontext *gc);

/*
** float-to-fix macro converts floats to 28.4
*/
#define __FAST_LINE_FLTTOFIX(x) ((long)((x) * 16.0f))

// Converts a floating-point coordinate to an appropriate device coordinate
#ifdef _CLIENTSIDE_
#define __FAST_LINE_FLTTODEV(x) ((long)(x))
#define __FAST_LINE_UNIT_VALUE  1
#else
#define __FAST_LINE_FLTTODEV(x) __FAST_LINE_FLTTOFIX(x)
#define __FAST_LINE_UNIT_VALUE  16
#endif
    
/*
** line-stroking macros for DIB surfaces
*/

#ifdef NT_NO_BUFFER_INVARIANCE

BOOL FASTCALL __fastGenLineSetupDIB(__GLcontext *gc);

/*
** __FAST_LINE_STROKE_DIB
**
** Strokes a thin solid line into a DIB surface.  Performs scissoring.
** Works for 8, 16, and 32 BPP
**
*/
#define __FAST_LINE_STROKE_DIB                                          \
{                                                                       \
    len = gc->line.options.numPixels;                                   \
    fraction = gc->line.options.fraction;                               \
    dfraction = gc->line.options.dfraction;                             \
                                                                        \
    if (!gc->transform.reasonableViewport) {                            \
        GLint clipX0, clipX1, clipY0, clipY1;                           \
        GLint xStart, yStart, xEnd, yEnd;                               \
        GLint xLittle, yLittle, xBig, yBig;                             \
        GLint highWord, lowWord, bigs, littles;                         \
                                                                        \
        clipX0 = gc->transform.clipX0;                                  \
        clipX1 = gc->transform.clipX1;                                  \
        clipY0 = gc->transform.clipY0;                                  \
        clipY1 = gc->transform.clipY1;                                  \
                                                                        \
        xBig = gc->line.options.xBig;                                   \
        yBig = gc->line.options.yBig;                                   \
                                                                        \
        xStart = gc->line.options.xStart;                               \
        yStart = gc->line.options.yStart;                               \
                                                                        \
        /* If the start point is in the scissor region, we attempt to   \
        ** trivially accept the line.                                   \
        */                                                              \
        if (xStart >= clipX0 && xStart < clipX1 &&                      \
	    yStart >= clipY0 && yStart < clipY1) {                      \
                                                                        \
	    len--;	/* Makes our math simpler */                    \
	    /* Trivial accept attempt */                                \
	    xEnd = xStart + xBig * len;                                 \
	    yEnd = yStart + yBig * len;                                 \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		len++;                                                  \
	        goto no_scissor;                                        \
	    }                                                           \
                                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
                                                                        \
	    /*                                                          \
            ** Invert negative minor slopes so we can assume            \
            ** dfraction > 0                                            \
            */                                                          \
	    if (dfraction < 0) {                                        \
	        dfraction = -dfraction;                                 \
	        fraction = 0x7fffffff - fraction;                       \
	    }                                                           \
                                                                        \
	    /* Now we compute number of littles and bigs in this line */\
                                                                        \
	    /* We perform a 16 by 32 bit multiply.  Ugh. */             \
	    highWord = (((GLuint) dfraction) >> 16) * len +             \
		       (((GLuint) fraction) >> 16);                     \
	    lowWord = (dfraction & 0xffff) * len + (fraction & 0xffff); \
	    highWord += (((GLuint) lowWord) >> 16);                     \
	    bigs = ((GLuint) highWord) >> 15;                           \
	    littles = len - bigs;                                       \
                                                                        \
	    /* Second trivial accept attempt */                         \
	    xEnd = xStart + xBig*bigs + xLittle*littles;                \
	    yEnd = yStart + yBig*bigs + yLittle*littles;                \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		len++;                                                  \
	        goto no_scissor;                                        \
	    }                                                           \
            len++;	/* Restore len */                               \
        } else {                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
        }                                                               \
                                                                        \
        /*                                                              \
        ** The line needs to be scissored.                              \
        ** Well, it should only happen rarely, so we can afford         \
        ** to make it slow.  We achieve this by tediously stippling the \
        ** line.  (rather than clipping it, of course, which would be   \
        ** faster but harder).                                          \
        */                                                              \
                                                                        \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                      \
            RECTL rcl;                                                  \
                                                                        \
            xEnd = x + xBig * (len - 1);                                \
            yEnd = y + yBig * (len - 1);                                \
                                                                        \
            if (x < xEnd) {                                             \
                rcl.left  = x;                                          \
                rcl.right = xEnd + 1;                                   \
            } else {                                                    \
                rcl.left  = xEnd;                                       \
                rcl.right = x + 1;                                      \
            }                                                           \
            if (y < yEnd) {                                             \
                rcl.top    = y;                                         \
                rcl.bottom = yEnd + 1;                                  \
            } else {                                                    \
                rcl.top    = yEnd;                                      \
                rcl.bottom = y + 1;                                     \
            }                                                           \
            switch (wglRectVisible(&rcl)) {                             \
              case WGL_RECT_ALL:                                        \
                goto scissor_no_complex;                                \
                break;                                                  \
              case WGL_RECT_NONE:                                       \
                goto no_draw;                                           \
                break;                                                  \
            }                                                           \
                                                                        \
            /* Line is partially visible, check each pixel */           \
                                                                        \
            while (--len >= 0) {                                        \
	        if (wglPixelVisible(x, y) &&                            \
                    xStart >= clipX0 && xStart < clipX1 &&              \
		    yStart >= clipY0 && yStart < clipY1) {              \
		    *addr = pixel;                                      \
	        }                                                       \
	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
		    fraction &= ~0x80000000;                            \
		    x      += xBig;                                     \
		    y      += yBig;                                     \
		    xStart += xBig;                                     \
		    yStart += yBig;                                     \
		    addr   += addrBig;                                  \
	        } else {                                                \
		    x      += xLittle;                                  \
		    y      += yLittle;                                  \
		    xStart += xLittle;                                  \
		    yStart += yLittle;                                  \
		    addr   += addrLittle;                               \
	        }                                                       \
	    }                                                           \
        } else {                                                        \
scissor_no_complex:                                                     \
            while (--len >= 0) {                                        \
	        if (xStart >= clipX0 && xStart < clipX1 &&              \
		    yStart >= clipY0 && yStart < clipY1) {              \
		    *addr = pixel;                                      \
	        }                                                       \
	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
		    fraction &= ~0x80000000;                            \
		    xStart += xBig;                                     \
		    yStart += yBig;                                     \
		    addr   += addrBig;                                  \
	        } else {                                                \
		    xStart += xLittle;                                  \
		    yStart += yLittle;                                  \
		    addr   += addrLittle;                               \
	        }                                                       \
	    }                                                           \
	}                                                               \
    } else {                                                            \
no_scissor:                                                             \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                    \
            RECTL rcl;                                                  \
            GLint xEnd, yEnd, xBig, yBig, xLittle, yLittle;             \
                                                                        \
            xBig    = gc->line.options.xBig;                            \
            yBig    = gc->line.options.yBig;                            \
            xLittle = gc->line.options.xLittle;                         \
            yLittle = gc->line.options.yLittle;                         \
                                                                        \
            xEnd = x + xBig * (len - 1);                                \
            yEnd = y + yBig * (len - 1);                                \
                                                                        \
            if (x < xEnd) {                                             \
                rcl.left  = x;                                          \
                rcl.right = xEnd + 1;                                   \
            } else {                                                    \
                rcl.left  = xEnd;                                       \
                rcl.right = x + 1;                                      \
            }                                                           \
            if (y < yEnd) {                                             \
                rcl.top    = y;                                         \
                rcl.bottom = yEnd + 1;                                  \
            } else {                                                    \
                rcl.top    = yEnd;                                      \
                rcl.bottom = y + 1;                                     \
            }                                                           \
            switch (wglRectVisible(&rcl)) {                             \
              case WGL_RECT_ALL:                                        \
                goto no_complex;                                        \
                break;                                                  \
              case WGL_RECT_NONE:                                       \
                goto no_draw;                                           \
                break;                                                  \
            }                                                           \
                                                                        \
            /* Line is partially visible, check each pixel */           \
                                                                        \
            while (--len >= 0) {                                        \
                if (wglPixelVisible(x, y))                              \
                    *addr = pixel;                                      \
                                                                        \
    	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            x    += xBig;                                       \
	            y    += yBig;                                       \
	            addr += addrBig;                                    \
	        } else {                                                \
	            x    += xLittle;                                    \
	            y    += yLittle;                                    \
	            addr += addrLittle;                                 \
	        }                                                       \
            }                                                           \
        } else {                                                        \
no_complex:                                                             \
            while (--len >= 0) {                                        \
                *addr = pixel;                                          \
                                                                        \
    	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            addr += addrBig;                                    \
	        } else {                                                \
	            addr += addrLittle;                                 \
	        }                                                       \
            }                                                           \
        }                                                               \
    }                                                                   \
no_draw:;                                                               \
}


/*
** __FAST_LINE_STROKE_DIB24
**
** Strokes a thin solid line into a DIB surface.  Performs scissoring.
** Works for 24 BPP
**
*/
#define __FAST_LINE_STROKE_DIB24                                        \
{                                                                       \
    len = gc->line.options.numPixels;                                   \
    fraction = gc->line.options.fraction;                               \
    dfraction = gc->line.options.dfraction;                             \
                                                                        \
    if (!gc->transform.reasonableViewport) {                            \
        GLint clipX0, clipX1, clipY0, clipY1;                           \
        GLint xStart, yStart, xEnd, yEnd;                               \
        GLint xLittle, yLittle, xBig, yBig;                             \
        GLint highWord, lowWord, bigs, littles;                         \
                                                                        \
        clipX0 = gc->transform.clipX0;                                  \
        clipX1 = gc->transform.clipX1;                                  \
        clipY0 = gc->transform.clipY0;                                  \
        clipY1 = gc->transform.clipY1;                                  \
                                                                        \
        xBig = gc->line.options.xBig;                                   \
        yBig = gc->line.options.yBig;                                   \
                                                                        \
        xStart = gc->line.options.xStart;                               \
        yStart = gc->line.options.yStart;                               \
                                                                        \
        /* If the start point is in the scissor region, we attempt to   \
        ** trivially accept the line.                                   \
        */                                                              \
        if (xStart >= clipX0 && xStart < clipX1 &&                      \
	    yStart >= clipY0 && yStart < clipY1) {                      \
                                                                        \
	    len--;	/* Makes our math simpler */                    \
	    /* Trivial accept attempt */                                \
	    xEnd = xStart + xBig * len;                                 \
	    yEnd = yStart + yBig * len;                                 \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		len++;                                                  \
	        goto no_scissor;                                        \
	    }                                                           \
                                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
                                                                        \
	    /*                                                          \
            ** Invert negative minor slopes so we can assume            \
            ** dfraction > 0                                            \
            */                                                          \
	    if (dfraction < 0) {                                        \
	        dfraction = -dfraction;                                 \
	        fraction = 0x7fffffff - fraction;                       \
	    }                                                           \
                                                                        \
	    /* Now we compute number of littles and bigs in this line */\
                                                                        \
	    /* We perform a 16 by 32 bit multiply.  Ugh. */             \
	    highWord = (((GLuint) dfraction) >> 16) * len +             \
		       (((GLuint) fraction) >> 16);                     \
	    lowWord = (dfraction & 0xffff) * len + (fraction & 0xffff); \
	    highWord += (((GLuint) lowWord) >> 16);                     \
	    bigs = ((GLuint) highWord) >> 15;                           \
	    littles = len - bigs;                                       \
                                                                        \
	    /* Second trivial accept attempt */                         \
	    xEnd = xStart + xBig*bigs + xLittle*littles;                \
	    yEnd = yStart + yBig*bigs + yLittle*littles;                \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		len++;                                                  \
	        goto no_scissor;                                        \
	    }                                                           \
            len++;	/* Restore len */                               \
        } else {                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
        }                                                               \
                                                                        \
        /*                                                              \
        ** The line needs to be scissored.                              \
        ** Well, it should only happen rarely, so we can afford         \
        ** to make it slow.  We achieve this by tediously stippling the \
        ** line.  (rather than clipping it, of course, which would be   \
        ** faster but harder).                                          \
        */                                                              \
                                                                        \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                    \
            RECTL rcl;                                                  \
                                                                        \
            xEnd = x + xBig * (len - 1);                                \
            yEnd = y + yBig * (len - 1);                                \
                                                                        \
            if (x < xEnd) {                                             \
                rcl.left  = x;                                          \
                rcl.right = xEnd + 1;                                   \
            } else {                                                    \
                rcl.left  = xEnd;                                       \
                rcl.right = x + 1;                                      \
            }                                                           \
            if (y < yEnd) {                                             \
                rcl.top    = y;                                         \
                rcl.bottom = yEnd + 1;                                  \
            } else {                                                    \
                rcl.top    = yEnd;                                      \
                rcl.bottom = y + 1;                                     \
            }                                                           \
            switch (wglRectVisible(&rcl)) {                             \
              case WGL_RECT_ALL:                                        \
                goto scissor_no_complex;                                \
                break;                                                  \
              case WGL_RECT_NONE:                                       \
                goto no_draw;                                           \
                break;                                                  \
            }                                                           \
                                                                        \
            /* Line is partially visible, check each pixel */           \
                                                                        \
            while (--len >= 0) {                                        \
	        if (wglPixelVisible(x, y) &&                            \
                    xStart >= clipX0 && xStart < clipX1 &&              \
		    yStart >= clipY0 && yStart < clipY1) {              \
		    addr[0] = ir;                                       \
		    addr[1] = ig;                                       \
		    addr[2] = ib;                                       \
	        }                                                       \
	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
		    fraction &= ~0x80000000;                            \
		    x      += xBig;                                     \
		    y      += yBig;                                     \
		    xStart += xBig;                                     \
		    yStart += yBig;                                     \
		    addr   += addrBig;                                  \
	        } else {                                                \
		    x      += xLittle;                                  \
		    y      += yLittle;                                  \
		    xStart += xLittle;                                  \
		    yStart += yLittle;                                  \
		    addr   += addrLittle;                               \
	        }                                                       \
	    }                                                           \
        } else {                                                        \
scissor_no_complex:                                                     \
            while (--len >= 0) {                                        \
	        if (xStart >= clipX0 && xStart < clipX1 &&              \
		    yStart >= clipY0 && yStart < clipY1) {              \
		    addr[0] = ir;                                       \
		    addr[1] = ig;                                       \
		    addr[2] = ib;                                       \
	        }                                                       \
	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
		    fraction &= ~0x80000000;                            \
		    xStart += xBig;                                     \
		    yStart += yBig;                                     \
		    addr   += addrBig;                                  \
	        } else {                                                \
		    xStart += xLittle;                                  \
		    yStart += yLittle;                                  \
		    addr   += addrLittle;                               \
	        }                                                       \
	    }                                                           \
        }                                                               \
    } else {                                                            \
no_scissor:                                                             \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                    \
            RECTL rcl;                                                  \
            GLint xEnd, yEnd, xBig, yBig, xLittle, yLittle;             \
                                                                        \
            xBig    = gc->line.options.xBig;                            \
            yBig    = gc->line.options.yBig;                            \
            xLittle = gc->line.options.xLittle;                         \
            yLittle = gc->line.options.yLittle;                         \
                                                                        \
            xEnd = x + xBig * (len - 1);                                \
            yEnd = y + yBig * (len - 1);                                \
                                                                        \
            if (x < xEnd) {                                             \
                rcl.left  = x;                                          \
                rcl.right = xEnd + 1;                                   \
            } else {                                                    \
                rcl.left  = xEnd;                                       \
                rcl.right = x + 1;                                      \
            }                                                           \
            if (y < yEnd) {                                             \
                rcl.top    = y;                                         \
                rcl.bottom = yEnd + 1;                                  \
            } else {                                                    \
                rcl.top    = yEnd;                                      \
                rcl.bottom = y + 1;                                     \
            }                                                           \
            switch (wglRectVisible(&rcl)) {                             \
              case WGL_RECT_ALL:                                        \
                goto no_complex;                                        \
                break;                                                  \
              case WGL_RECT_NONE:                                       \
                goto no_draw;                                           \
                break;                                                  \
            }                                                           \
                                                                        \
            /* Line is partially visible, check each pixel */           \
                                                                        \
            while (--len >= 0) {                                        \
                if (wglPixelVisible(x, y)) {                            \
                    addr[0] = ir;                                       \
                    addr[1] = ig;                                       \
                    addr[2] = ib;                                       \
                }                                                       \
    	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            addr += addrBig;                                    \
	        } else {                                                \
	            addr += addrLittle;                                 \
	        }                                                       \
            }                                                           \
	} else {                                                        \
no_complex:                                                             \
            while (--len >= 0) {                                        \
                addr[0] = ir;                                           \
                addr[1] = ig;                                           \
                addr[2] = ib;                                           \
    	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            addr += addrBig;                                    \
	        } else {                                                \
	            addr += addrLittle;                                 \
	        }                                                       \
            }                                                           \
        }                                                               \
    }                                                                   \
no_draw:;                                                               \
}


/*
** __FAST_LINE_STROKE_DIB_WIDE
**
** Strokes a wide solid line into a DIB surface.  Performs scissoring.
** Works for 8, 16, and 32 BPP
**
*/
#define __FAST_LINE_STROKE_DIB_WIDE                                     \
{                                                                       \
    len = gc->line.options.numPixels;                                   \
    fraction = gc->line.options.fraction;                               \
    dfraction = gc->line.options.dfraction;                             \
                                                                        \
    /*                                                                  \
    ** Since one or more of the strokes of a wide line may lie outside  \
    ** the viewport, wide lines always go through the scissoring checks \
    */                                                                  \
    {                                                                   \
        GLint clipX0, clipX1, clipY0, clipY1;                           \
        GLint xStart, yStart, xEnd, yEnd;                               \
        GLint xLittle, yLittle, xBig, yBig;                             \
        GLint highWord, lowWord, bigs, littles;                         \
                                                                        \
        clipX0 = gc->transform.clipX0;                                  \
        clipX1 = gc->transform.clipX1;                                  \
        clipY0 = gc->transform.clipY0;                                  \
        clipY1 = gc->transform.clipY1;                                  \
                                                                        \
        xBig = gc->line.options.xBig;                                   \
        yBig = gc->line.options.yBig;                                   \
                                                                        \
        xStart = gc->line.options.xStart;                               \
        yStart = gc->line.options.yStart;                               \
                                                                        \
        /* If the start point is in the scissor region, we attempt to   \
        ** trivially accept the line.                                   \
        */                                                              \
        if (xStart >= clipX0 && xStart < clipX1 &&                      \
	    yStart >= clipY0 && yStart < clipY1) {                      \
                                                                        \
	    len--;	/* Makes our math simpler */                    \
	    width--;                                                    \
	    /* Trivial accept attempt */                                \
	    xEnd = xStart + xBig * len;                                 \
	    yEnd = yStart + yBig * len;                                 \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		                                                        \
                if (gc->line.options.axis == __GL_X_MAJOR) {            \
                    if (((yStart + width) >= clipY0) &&                 \
                        ((yStart + width) <  clipY1) &&                 \
                        ((yEnd + width)   >= clipY0) &&                 \
                        ((yEnd + width)   <  clipY1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        } else {                                                \
                    if (((xStart + width) >= clipX0) &&                 \
                        ((xStart + width) <  clipX1) &&                 \
                        ((xEnd + width)   >= clipX0) &&                 \
                        ((xEnd + width)   <  clipX1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        }                                                       \
	    }                                                           \
                                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
                                                                        \
	    /*                                                          \
            ** Invert negative minor slopes so we can assume            \
            ** dfraction > 0                                            \
            */                                                          \
	    if (dfraction < 0) {                                        \
	        dfraction = -dfraction;                                 \
	        fraction = 0x7fffffff - fraction;                       \
	    }                                                           \
                                                                        \
	    /* Now we compute number of littles and bigs in this line */\
                                                                        \
	    /* We perform a 16 by 32 bit multiply.  Ugh. */             \
	    highWord = (((GLuint) dfraction) >> 16) * len +             \
		       (((GLuint) fraction) >> 16);                     \
	    lowWord = (dfraction & 0xffff) * len + (fraction & 0xffff); \
	    highWord += (((GLuint) lowWord) >> 16);                     \
	    bigs = ((GLuint) highWord) >> 15;                           \
	    littles = len - bigs;                                       \
                                                                        \
	    /* Second trivial accept attempt */                         \
	    xEnd = xStart + xBig*bigs + xLittle*littles;                \
	    yEnd = yStart + yBig*bigs + yLittle*littles;                \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
                                                                        \
                if (gc->line.options.axis == __GL_X_MAJOR) {            \
                    if (((yStart + width) >= clipY0) &&                 \
                        ((yStart + width) <  clipY1) &&                 \
                        ((yEnd + width)   >= clipY0) &&                 \
                        ((yEnd + width)   <  clipY1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        } else {                                                \
                    if (((xStart + width) >= clipX0) &&                 \
                        ((xStart + width) <  clipX1) &&                 \
                        ((xEnd + width)   >= clipX0) &&                 \
                        ((xEnd + width)   <  clipX1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        }                                                       \
	    }                                                           \
            len++;	/* Restore len and width */                     \
	    width++;                                                    \
        } else {                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
        }                                                               \
                                                                        \
        /*                                                              \
        ** The line needs to be scissored.                              \
        ** Well, it should only happen rarely, so we can afford         \
        ** to make it slow.  We achieve this by tediously stippling the \
        ** line.  (rather than clipping it, of course, which would be   \
        ** faster but harder).                                          \
        */                                                              \
                                                                        \
        if (gc->line.options.axis == __GL_X_MAJOR) {                    \
            GLint yTmp0;                                                \
                                                                        \
            if (!((GLuint)cfb->buf.other & NO_CLIP)) {                \
                RECTL rcl;                                              \
                GLint yTmp1;                                            \
                                                                        \
                xEnd = x + xBig * (len - 1);                            \
                yEnd = y + yBig * (len - 1);                            \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + 1;                               \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + 1;                                  \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + width;                          \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + width;                             \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto scissor_x_no_complex;                          \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
    	            if (xStart >= clipX0 && xStart < clipX1) {          \
                        yTmp0 = yStart;                                 \
                        yTmp1 = y;                                      \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (wglPixelVisible(x, yTmp1) &&            \
                                yTmp0 >= clipY0 && yTmp0 < clipY1) {    \
    		                *addr = pixel;                          \
                            }                                           \
                            addr += addrMinor;                          \
                            yTmp0++;                                    \
                            yTmp1++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
scissor_x_no_complex:                                                   \
                while (--len >= 0) {                                    \
    	            if (xStart >= clipX0 && xStart < clipX1) {          \
                        yTmp0 = yStart;                                 \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (yTmp0 >= clipY0 && yTmp0 < clipY1) {    \
    		                *addr = pixel;                          \
                            }                                           \
                            addr += addrMinor;                          \
                            yTmp0++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	} else {                                                        \
            GLint xTmp0;                                                \
                                                                        \
            if (!((GLuint)cfb->buf.other & NO_CLIP)) {                \
                RECTL rcl;                                              \
                GLint xTmp1;                                            \
                                                                        \
                xEnd = x + xBig * (len - 1);                            \
                yEnd = y + yBig * (len - 1);                            \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + width;                           \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + width;                              \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + 1;                              \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + 1;                                 \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto scissor_y_no_complex;                          \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
    	            if (yStart >= clipY0 && yStart < clipY1) {          \
                        xTmp0 = xStart;                                 \
                        xTmp1 = x;                                      \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (wglPixelVisible(xTmp1, y) &&            \
                                xTmp0 >= clipX0 && xTmp0 < clipX1) {    \
    		                *addr = pixel;                          \
                            }                                           \
                            addr += addrMinor;                          \
                            xTmp0++;                                    \
                            xTmp1++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
scissor_y_no_complex:                                                   \
                while (--len >= 0) {                                    \
    	            if (yStart >= clipY0 && yStart < clipY1) {          \
                        xTmp0 = xStart;                                 \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (xTmp0 >= clipX0 && xTmp0 < clipX1) {    \
    		                *addr = pixel;                          \
                            }                                           \
                            addr += addrMinor;                          \
                            xTmp0++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	}                                                               \
        goto no_draw;                                                   \
no_scissor:                                                             \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                    \
            RECTL rcl;                                                  \
                                                                        \
            xEnd = x + xBig * (len - 1);                                \
            yEnd = y + yBig * (len - 1);                                \
                                                                        \
            xLittle = gc->line.options.xLittle;                         \
            yLittle = gc->line.options.yLittle;                         \
                                                                        \
            if (gc->line.options.axis == __GL_X_MAJOR) {                \
                GLint yTmp;                                             \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + 1;                               \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + 1;                                  \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + width;                          \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + width;                             \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto no_scissor_no_complex;                         \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
                    yTmp = y;                                           \
                    w = width;                                          \
                    while (--w >= 0) {                                  \
                        if (wglPixelVisible(x, yTmp)) {                 \
    		            *addr = pixel;                              \
                        }                                               \
                        addr += addrMinor;                              \
                        yTmp++;                                         \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
                GLint xTmp;                                             \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + width;                           \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + width;                              \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + 1;                              \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + 1;                                 \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto no_scissor_no_complex;                         \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
                    xTmp = x;                                           \
                    w = width;                                          \
                    while (--w >= 0) {                                  \
                        if (wglPixelVisible(xTmp, y)) {                 \
    		            *addr = pixel;                              \
                        }                                               \
                        addr += addrMinor;                              \
                        xTmp++;                                         \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	} else {                                                        \
no_scissor_no_complex:                                                  \
            while (--len >= 0) {                                        \
                w = width;                                              \
                while (--w >= 0) {                                      \
                    *addr = pixel;                                      \
                    addr += addrMinor;                                  \
                }                                                       \
  	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            addr += addrBig;                                    \
	        } else {                                                \
	            addr += addrLittle;                                 \
	        }                                                       \
	    }                                                           \
	}                                                               \
    }                                                                   \
no_draw:;                                                               \
}


/*
** __FAST_LINE_STROKE_DIB24_WIDE
**
** Strokes a wide solid line into a DIB surface.  Performs scissoring.
** Works for 24 BPP
**
*/
#define __FAST_LINE_STROKE_DIB24_WIDE                                   \
{                                                                       \
    len = gc->line.options.numPixels;                                   \
    fraction = gc->line.options.fraction;                               \
    dfraction = gc->line.options.dfraction;                             \
                                                                        \
    /*                                                                  \
    ** Since one or more of the strokes of a wide line may lie outside  \
    ** the viewport, wide lines always go through the scissoring checks \
    */                                                                  \
    {                                                                   \
        GLint clipX0, clipX1, clipY0, clipY1;                           \
        GLint xStart, yStart, xEnd, yEnd;                               \
        GLint xLittle, yLittle, xBig, yBig;                             \
        GLint highWord, lowWord, bigs, littles;                         \
                                                                        \
        clipX0 = gc->transform.clipX0;                                  \
        clipX1 = gc->transform.clipX1;                                  \
        clipY0 = gc->transform.clipY0;                                  \
        clipY1 = gc->transform.clipY1;                                  \
                                                                        \
        xBig = gc->line.options.xBig;                                   \
        yBig = gc->line.options.yBig;                                   \
                                                                        \
        xStart = gc->line.options.xStart;                               \
        yStart = gc->line.options.yStart;                               \
                                                                        \
        /* If the start point is in the scissor region, we attempt to   \
        ** trivially accept the line.                                   \
        */                                                              \
        if (xStart >= clipX0 && xStart < clipX1 &&                      \
	    yStart >= clipY0 && yStart < clipY1) {                      \
                                                                        \
	    len--;	/* Makes our math simpler */                    \
	    width--;                                                    \
	    /* Trivial accept attempt */                                \
	    xEnd = xStart + xBig * len;                                 \
	    yEnd = yStart + yBig * len;                                 \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		                                                        \
                if (gc->line.options.axis == __GL_X_MAJOR) {            \
                    if (((yStart + width) >= clipY0) &&                 \
                        ((yStart + width) <  clipY1) &&                 \
                        ((yEnd + width)   >= clipY0) &&                 \
                        ((yEnd + width)   <  clipY1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        } else {                                                \
                    if (((xStart + width) >= clipX0) &&                 \
                        ((xStart + width) <  clipX1) &&                 \
                        ((xEnd + width)   >= clipX0) &&                 \
                        ((xEnd + width)   <  clipX1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        }                                                       \
	    }                                                           \
                                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
                                                                        \
	    /*                                                          \
            ** Invert negative minor slopes so we can assume            \
            ** dfraction > 0                                            \
            */                                                          \
	    if (dfraction < 0) {                                        \
	        dfraction = -dfraction;                                 \
	        fraction = 0x7fffffff - fraction;                       \
	    }                                                           \
                                                                        \
	    /* Now we compute number of littles and bigs in this line */\
                                                                        \
	    /* We perform a 16 by 32 bit multiply.  Ugh. */             \
	    highWord = (((GLuint) dfraction) >> 16) * len +             \
		       (((GLuint) fraction) >> 16);                     \
	    lowWord = (dfraction & 0xffff) * len + (fraction & 0xffff); \
	    highWord += (((GLuint) lowWord) >> 16);                     \
	    bigs = ((GLuint) highWord) >> 15;                           \
	    littles = len - bigs;                                       \
                                                                        \
	    /* Second trivial accept attempt */                         \
	    xEnd = xStart + xBig*bigs + xLittle*littles;                \
	    yEnd = yStart + yBig*bigs + yLittle*littles;                \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
                                                                        \
                if (gc->line.options.axis == __GL_X_MAJOR) {            \
                    if (((yStart + width) >= clipY0) &&                 \
                        ((yStart + width) <  clipY1) &&                 \
                        ((yEnd + width)   >= clipY0) &&                 \
                        ((yEnd + width)   <  clipY1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        } else {                                                \
                    if (((xStart + width) >= clipX0) &&                 \
                        ((xStart + width) <  clipX1) &&                 \
                        ((xEnd + width)   >= clipX0) &&                 \
                        ((xEnd + width)   <  clipX1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        }                                                       \
	    }                                                           \
            len++;	/* Restore len and width */                     \
	    width++;                                                    \
        } else {                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
        }                                                               \
                                                                        \
        /*                                                              \
        ** The line needs to be scissored.                              \
        ** Well, it should only happen rarely, so we can afford         \
        ** to make it slow.  We achieve this by tediously stippling the \
        ** line.  (rather than clipping it, of course, which would be   \
        ** faster but harder).                                          \
        */                                                              \
                                                                        \
        if (gc->line.options.axis == __GL_X_MAJOR) {                    \
            GLint yTmp0;                                                \
                                                                        \
            if (!((GLuint)cfb->buf.other & NO_CLIP)) {                \
                RECTL rcl;                                              \
                GLint yTmp1;                                            \
                                                                        \
                xEnd = x + xBig * (len - 1);                            \
                yEnd = y + yBig * (len - 1);                            \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + 1;                               \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + 1;                                  \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + width;                          \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + width;                             \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto scissor_x_no_complex;                          \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
    	            if (xStart >= clipX0 && xStart < clipX1) {          \
                        yTmp0 = yStart;                                 \
                        yTmp1 = y;                                      \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (wglPixelVisible(x, yTmp1) &&            \
                                yTmp0 >= clipY0 && yTmp0 < clipY1) {    \
    		                addr[0] = ir;                           \
    		                addr[1] = ig;                           \
    		                addr[2] = ib;                           \
                            }                                           \
                            addr += addrMinor;                          \
                            yTmp0++;                                    \
                            yTmp1++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
scissor_x_no_complex:                                                   \
                while (--len >= 0) {                                    \
    	            if (xStart >= clipX0 && xStart < clipX1) {          \
                        yTmp0 = yStart;                                 \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (yTmp0 >= clipY0 && yTmp0 < clipY1) {    \
    		                addr[0] = ir;                           \
    		                addr[1] = ig;                           \
    		                addr[2] = ib;                           \
                            }                                           \
                            addr += addrMinor;                          \
                            yTmp0++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	} else {                                                        \
            GLint xTmp0;                                                \
                                                                        \
            if (!((GLuint)cfb->buf.other & NO_CLIP)) {                \
                RECTL rcl;                                              \
                GLint xTmp1;                                            \
                                                                        \
                xEnd = x + xBig * (len - 1);                            \
                yEnd = y + yBig * (len - 1);                            \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + width;                           \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + width;                              \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + 1;                              \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + 1;                                 \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto scissor_y_no_complex;                          \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
    	            if (yStart >= clipY0 && yStart < clipY1) {          \
                        xTmp0 = xStart;                                 \
                        xTmp1 = x;                                      \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (wglPixelVisible(xTmp1, y) &&            \
                                xTmp0 >= clipX0 && xTmp0 < clipX1) {    \
    		                addr[0] = ir;                           \
    		                addr[1] = ig;                           \
    		                addr[2] = ib;                           \
                            }                                           \
                            addr += addrMinor;                          \
                            xTmp0++;                                    \
                            xTmp1++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
scissor_y_no_complex:                                                   \
                while (--len >= 0) {                                    \
    	            if (yStart >= clipY0 && yStart < clipY1) {          \
                        xTmp0 = xStart;                                 \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (xTmp0 >= clipX0 && xTmp0 < clipX1) {    \
    		                addr[0] = ir;                           \
    		                addr[1] = ig;                           \
    		                addr[2] = ib;                           \
                            }                                           \
                            addr += addrMinor;                          \
                            xTmp0++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	}                                                               \
        goto no_draw;                                                   \
no_scissor:                                                             \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                    \
            RECTL rcl;                                                  \
                                                                        \
            xLittle = gc->line.options.xLittle;                         \
            yLittle = gc->line.options.yLittle;                         \
                                                                        \
            if (gc->line.options.axis == __GL_X_MAJOR) {                \
                GLint yTmp;                                             \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + 1;                               \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + 1;                                  \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + width;                          \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + width;                             \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto no_scissor_no_complex;                         \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
                    yTmp = y;                                           \
                    w = width;                                          \
                    while (--w >= 0) {                                  \
                        if (wglPixelVisible(x, yTmp)) {                 \
    		            addr[0] = ir;                               \
    		            addr[1] = ig;                               \
    		            addr[2] = ib;                               \
                        }                                               \
                        addr += addrMinor;                              \
                        yTmp++;                                         \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
                GLint xTmp;                                             \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + width;                           \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + width;                              \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + 1;                              \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + 1;                                 \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto no_scissor_no_complex;                         \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
                    xTmp = x;                                           \
                    w = width;                                          \
                    while (--w >= 0) {                                  \
                        if (wglPixelVisible(xTmp, y)) {                 \
    		            addr[0] = ir;                               \
    		            addr[1] = ig;                               \
    		            addr[2] = ib;                               \
                        }                                               \
                        addr += addrMinor;                              \
                        xTmp++;                                         \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	} else {                                                        \
no_scissor_no_complex:                                                  \
            while (--len >= 0) {                                        \
                w = width;                                              \
                while (--w >= 0) {                                      \
    		    addr[0] = ir;                                       \
    		    addr[1] = ig;                                       \
    		    addr[2] = ib;                                       \
                    addr += addrMinor;                                  \
                }                                                       \
  	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            addr += addrBig;                                    \
	        } else {                                                \
	            addr += addrLittle;                                 \
	        }                                                       \
	    }                                                           \
	}                                                               \
    }                                                                   \
no_draw:;                                                               \
}

#endif // NT_NO_BUFFER_INVARIANCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\genpoly.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#ifdef _X86_

#define SHADER  __GLcontext.polygon.shader
#define GENGCACCEL __GLGENcontext.genAccel
#define SPANDELTA __GLGENcontext.genAccel.spanDelta
#define SPANVALUE __GLGENcontext.genAccel.spanValue

#endif

#define ENABLE_ASM  1

#if DBG
//#define FORCE_NPX_DEBUG 1
#endif

/**************************************************************************\
\**************************************************************************/

/* This routine sets gc->polygon.shader.cfb to gc->drawBuffer */

void FASTCALL __fastGenFillSubTriangle(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint spanWidth, clipY0, clipY1;
    ULONG ulSpanVisibility;
    GLint cWalls;
    GLint *Walls;
#ifdef NT
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    GLuint maxWidth;
#else
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
#endif
    BOOL bSurfaceDIB;
    BOOL bClipped;
    GLint xScr, yScr;
    GLint zFails;
    __GLzValue *zbuf, z;
    GLint r, g, b, s, t;
    __GLGENcontext  *gengc = (__GLGENcontext *)gc;
    __genSpanFunc cSpanFunc = GENACCEL(gc).__fastSpanFuncPtr;
    __GLspanFunc zSpanFunc = GENACCEL(gc).__fastZSpanFuncPtr;
    int scansize;

#ifdef NT
    maxWidth = (gc->transform.clipX1 - gc->transform.clipX0) + 31;
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (maxWidth+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return;
        }
    }
    else
    {
        words = stackWords;
    }
#endif

    gc->polygon.shader.stipplePat = words;
    scansize = gc->polygon.shader.cfb->buf.outerWidth;

    bSurfaceDIB = (gc->polygon.shader.cfb->buf.flags & DIB_FORMAT) != 0;
    bClipped = (!(gc->drawBuffer->buf.flags & NO_CLIP)) &&
                 bSurfaceDIB;

    if (bSurfaceDIB)
        GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
    else
        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);

    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;

    r = GENACCEL(gc).spanValue.r;
    g = GENACCEL(gc).spanValue.g;
    b = GENACCEL(gc).spanValue.b;
    s = GENACCEL(gc).spanValue.s;
    t = GENACCEL(gc).spanValue.t;

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
        z = gc->polygon.shader.frag.z;

	if( gc->modes.depthBits == 32 )
	    zbuf = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                   ixLeft, iyBottom);
	else
	    zbuf = (__GLzValue *)__GL_DEPTH_ADDR(&gc->depthBuffer,
                                                 (__GLz16Value*),
                                                 ixLeft, iyBottom);
    } else if ((gc->polygon.shader.modeFlags & __GL_SHADE_STIPPLE) == 0) {
        GLuint w;

        if (w = ((gc->transform.clipX1 - gc->transform.clipX0) + 31) >> 3)
            RtlFillMemoryUlong(words, w, ~((ULONG)0));
        GENACCEL(gc).flags &= ~(HAVE_STIPPLE);
    }

    //
    // render the spans
    //

    while (iyBottom < iyTop) {
	spanWidth = ixRight - ixLeft;
	/*
	** Only render spans that have non-zero width and which are
	** not scissored out vertically.
	*/
	if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) {
	    gc->polygon.shader.frag.x = ixLeft;
	    gc->polygon.shader.frag.y = iyBottom;
            gc->polygon.shader.zbuf = zbuf;
            gc->polygon.shader.frag.z = z;

            GENACCEL(gc).spanValue.r = r;
            GENACCEL(gc).spanValue.g = g;
            GENACCEL(gc).spanValue.b = b;
            GENACCEL(gc).spanValue.s = s;
            GENACCEL(gc).spanValue.t = t;

            // take care of horizontal scissoring

            if (!gc->transform.reasonableViewport) {
                GLint clipX0 = gc->transform.clipX0;
                GLint clipX1 = gc->transform.clipX1;

                // see if we skip entire span

                if ((ixRight <= clipX0) || (ixLeft >= clipX1))
                    goto advance;

                // now clip right and left

                if (ixRight > clipX1)
                    spanWidth = (clipX1 - ixLeft);

                if (ixLeft < clipX0) {
              	    GLuint delta;

                    delta = clipX0 - ixLeft;
                    spanWidth -= delta;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
                        GENACCEL(gc).spanValue.r += delta * GENACCEL(gc).spanDelta.r;
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
                            GENACCEL(gc).spanValue.g += delta * GENACCEL(gc).spanDelta.g;
                            GENACCEL(gc).spanValue.b += delta * GENACCEL(gc).spanDelta.b;
                        }
                    }
                    if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
                        GENACCEL(gc).spanValue.s += delta * GENACCEL(gc).spanDelta.s;
                        GENACCEL(gc).spanValue.t += delta * GENACCEL(gc).spanDelta.t;
                    }

            	    gc->polygon.shader.frag.x = clipX0;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
                        if( gc->modes.depthBits == 32 )
                            gc->polygon.shader.zbuf += delta;
                        else
                            (__GLz16Value *)gc->polygon.shader.zbuf += delta;

                        gc->polygon.shader.frag.z +=
                            (gc->polygon.shader.dzdx * delta);

                    }
                }
            }

            // now have span length

	    gc->polygon.shader.length = spanWidth;

            // If a stipple is active, process it first
            if (gc->polygon.shader.modeFlags & __GL_SHADE_STIPPLE)
            {
                // If no pixels are left after stippling and depth
                // testing then we can skip the span
                // Note that this function handles the no-depth-
                // testing case also
                gc->polygon.shader.done = GL_FALSE;
                if (!(*GENACCEL(gc).__fastStippleDepthTestSpan)(gc) ||
                    gc->polygon.shader.done)
                {
                    goto advance;
                }

                GENACCEL(gc).flags |= HAVE_STIPPLE;
            }

            // Do z-buffering if needed, and short-circuit rest of span
            // operations if nothing will be drawn.

            else if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
                // initially assume no stippling

                GENACCEL(gc).flags &= ~(HAVE_STIPPLE);
                if ((zFails = (*zSpanFunc)(gc)) == 1)
                    goto advance;
                else if (zFails)
                    GENACCEL(gc).flags |= HAVE_STIPPLE;
            }

            if (gc->state.raster.drawBuffer == GL_FRONT_AND_BACK) {

                gc->polygon.shader.cfb = &gc->frontBuffer;

                xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) +
                       gc->frontBuffer.buf.xOrigin;
                yScr = __GL_UNBIAS_Y(gc, iyBottom) +
                       gc->frontBuffer.buf.yOrigin;

                // If the front buffer is a DIB, we're drawing straight to
                // the screen, so we must check clipping.

                if ((gc->frontBuffer.buf.flags &
                    (DIB_FORMAT | NO_CLIP)) == DIB_FORMAT) {

                    ulSpanVisibility = wglSpanVisible(xScr, yScr, spanWidth,
                                                      &cWalls, &Walls);

                    // If the span is completely visible, we can treat the
                    // screen as a DIB.

                    if (ulSpanVisibility == WGL_SPAN_ALL) {
                        GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
                        (*cSpanFunc)(gengc);
                    } else if (ulSpanVisibility == WGL_SPAN_PARTIAL) {
                        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                        if (GENACCEL(gc).flags & HAVE_STIPPLE)
                            (*gengc->pfnCopyPixels)(gengc,
                                                    gc->polygon.shader.cfb,
                                                    xScr, yScr, spanWidth,
                                                    FALSE);
                        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                        (*cSpanFunc)(gengc);
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                TRUE);
                    }

                } else {
                    GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                    if (GENACCEL(gc).flags & HAVE_STIPPLE)
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                FALSE);
                    GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                    (*cSpanFunc)(gengc);
                    (*gengc->pfnCopyPixels)(gengc,
                                            gc->polygon.shader.cfb,
                                            xScr, yScr, spanWidth,
                                            TRUE);
                }

                // The back buffer is always DIB-compatible

                gc->polygon.shader.cfb = &gc->backBuffer;
                GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
                (*cSpanFunc)(gengc);
            } else {
                if (bClipped) {
                    xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) +
                           gc->drawBuffer->buf.xOrigin;
                    yScr = __GL_UNBIAS_Y(gc, iyBottom) +
                           gc->drawBuffer->buf.yOrigin;

                    ulSpanVisibility = wglSpanVisible(xScr, yScr, spanWidth,
                                                      &cWalls, &Walls);

                    if (ulSpanVisibility == WGL_SPAN_ALL) {
                        GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
                        (*cSpanFunc)(gengc);
                    } else if (ulSpanVisibility == WGL_SPAN_PARTIAL) {
                        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                        if (GENACCEL(gc).flags & HAVE_STIPPLE)
                            (*gengc->pfnCopyPixels)(gengc,
                                                    gc->polygon.shader.cfb,
                                                    xScr, yScr, spanWidth,
                                                    FALSE);
                        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                        (*cSpanFunc)(gengc);
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                TRUE);
                    }

                } else if (bSurfaceDIB) {
                    (*cSpanFunc)(gengc);
                } else {
                    xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) +
                           gc->drawBuffer->buf.xOrigin;
                    yScr = __GL_UNBIAS_Y(gc, iyBottom) +
                           gc->drawBuffer->buf.yOrigin;

                    GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                    if (GENACCEL(gc).flags & HAVE_STIPPLE)
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                FALSE);
                    (*cSpanFunc)(gengc);
                    if (!bSurfaceDIB)
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                TRUE);
                }
            }
	}

advance:

        GENACCEL(gc).pPix += scansize;

	/* Advance right edge fixed point, adjusting for carry */
	ixRightFrac += gc->polygon.shader.dxRightFrac;
	if (ixRightFrac < 0) {
	    /* Carry/Borrow'd. Use large step */
	    ixRight += gc->polygon.shader.dxRightBig;
	    ixRightFrac &= ~0x80000000;
	} else {
	    ixRight += gc->polygon.shader.dxRightLittle;
	}

	iyBottom++;
	ixLeftFrac += gc->polygon.shader.dxLeftFrac;
	if (ixLeftFrac < 0) {
	    /* Carry/Borrow'd.  Use large step */
	    ixLeft += gc->polygon.shader.dxLeftBig;
	    ixLeftFrac &= ~0x80000000;

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rBig);
		    g += *((GLint *)&gc->polygon.shader.gBig);
		    b += *((GLint *)&gc->polygon.shader.bBig);
		}
                if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
		    s += *((GLint *)&gc->polygon.shader.sBig);
		    t += *((GLint *)&gc->polygon.shader.tBig);
                }
	    } else {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rBig);
		}
	    }

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zBig;
		/* The implicit multiply is taken out of the loop */
		zbuf = (__GLzValue*)((GLubyte*)zbuf +
                       gc->polygon.shader.zbufBig);
	    }
	} else {
	    /* Use small step */
	    ixLeft += gc->polygon.shader.dxLeftLittle;
	    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rLittle);
		    g += *((GLint *)&gc->polygon.shader.gLittle);
		    b += *((GLint *)&gc->polygon.shader.bLittle);
		}
                if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
		    s += *((GLint *)&gc->polygon.shader.sLittle);
		    t += *((GLint *)&gc->polygon.shader.tLittle);
                }
	    } else {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rLittle);
		}
            }
	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zLittle;
		/* The implicit multiply is taken out of the loop */
		zbuf = (__GLzValue*)((GLubyte*)zbuf +
		        gc->polygon.shader.zbufLittle);
	    }
	}
    }

    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;
    gc->polygon.shader.frag.z = z;
    GENACCEL(gc).spanValue.r = r;
    GENACCEL(gc).spanValue.g = g;
    GENACCEL(gc).spanValue.b = b;
    GENACCEL(gc).spanValue.s = s;
    GENACCEL(gc).spanValue.t = t;

#ifdef NT
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
#endif
}


void FASTCALL __fastGenFillSubTriangleTexRGBA(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint spanWidth, clipY0, clipY1;
    ULONG ulSpanVisibility;
    GLint cWalls;
    GLint *Walls;
    BOOL bSurfaceDIB;
    BOOL bClipped;
    GLint xScr, yScr;
    __GLzValue *zbuf, z;
    GLint r, g, b, a, s, t;
    __GLfloat qw;
    __GLGENcontext  *gengc = (__GLGENcontext *)gc;
    __genSpanFunc cSpanFunc = GENACCEL(gc).__fastSpanFuncPtr;
    int scansize;
    BOOL bReadPixels = (gc->state.enables.general & __GL_BLEND_ENABLE) ||
                       (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST);
#ifdef _MCD_
    GLboolean bMcdZ = ((gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) &&
                       (gengc->pMcdState != NULL) &&
                       (gengc->pMcdState->pDepthSpan != NULL) &&
                       (gengc->pMcdState->pMcdSurf != NULL) &&
                       !(gengc->pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED));
#endif


    scansize = gc->polygon.shader.cfb->buf.outerWidth;

    bSurfaceDIB = (gc->polygon.shader.cfb->buf.flags & DIB_FORMAT) != 0;
    bClipped = (!(gc->drawBuffer->buf.flags & NO_CLIP)) &&
                 bSurfaceDIB;

    if (bSurfaceDIB)
        GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
    else
        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);

    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;

    r = GENACCEL(gc).spanValue.r;
    g = GENACCEL(gc).spanValue.g;
    b = GENACCEL(gc).spanValue.b;
    a = GENACCEL(gc).spanValue.a;
    s = GENACCEL(gc).spanValue.s;
    t = GENACCEL(gc).spanValue.t;
    qw = gc->polygon.shader.frag.qw;

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
        z = gc->polygon.shader.frag.z;

#ifdef _MCD_
        if (bMcdZ)
        {
            zbuf = (__GLzValue *)gengc->pMcdState->pMcdSurf->McdDepthBuf.pv;
        }
        else
#endif
        {
            if( gc->modes.depthBits == 32 )
                zbuf = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                       ixLeft, iyBottom);
            else
                zbuf = (__GLzValue *)__GL_DEPTH_ADDR(&gc->depthBuffer,
                                                     (__GLz16Value*),
                                                     ixLeft, iyBottom);
        }
    }

    //
    // render the spans
    //

    while (iyBottom < iyTop) {
	spanWidth = ixRight - ixLeft;
	/*
	** Only render spans that have non-zero width and which are
	** not scissored out vertically.
	*/
	if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) {
	    gc->polygon.shader.frag.x = ixLeft;
	    gc->polygon.shader.frag.y = iyBottom;
            gc->polygon.shader.zbuf = zbuf;
            gc->polygon.shader.frag.z = z;

            GENACCEL(gc).spanValue.r = r;
            GENACCEL(gc).spanValue.g = g;
            GENACCEL(gc).spanValue.b = b;
            GENACCEL(gc).spanValue.a = a;
            GENACCEL(gc).spanValue.s = s;
            GENACCEL(gc).spanValue.t = t;
            gc->polygon.shader.frag.qw = qw;

            // take care of horizontal scissoring

            if (!gc->transform.reasonableViewport) {
                GLint clipX0 = gc->transform.clipX0;
                GLint clipX1 = gc->transform.clipX1;

                // see if we skip entire span

                if ((ixRight <= clipX0) || (ixLeft >= clipX1))
                    goto advance;

                // now clip right and left

                if (ixRight > clipX1)
                    spanWidth = (clipX1 - ixLeft);

                if (ixLeft < clipX0) {
              	    GLuint delta;

                    delta = clipX0 - ixLeft;
                    spanWidth -= delta;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
                        GENACCEL(gc).spanValue.r += delta * GENACCEL(gc).spanDelta.r;
                        GENACCEL(gc).spanValue.g += delta * GENACCEL(gc).spanDelta.g;
                        GENACCEL(gc).spanValue.b += delta * GENACCEL(gc).spanDelta.b;
                        GENACCEL(gc).spanValue.a += delta * GENACCEL(gc).spanDelta.a;
                    }
                    if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
                        GENACCEL(gc).spanValue.s += delta * GENACCEL(gc).spanDelta.s;
                        GENACCEL(gc).spanValue.t += delta * GENACCEL(gc).spanDelta.t;
        	        gc->polygon.shader.frag.qw += delta * gc->polygon.shader.dqwdx;
                    }

            	    gc->polygon.shader.frag.x = clipX0;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
                        if( gc->modes.depthBits == 32 )
                            gc->polygon.shader.zbuf += delta;
                        else
                            (__GLz16Value *)gc->polygon.shader.zbuf += delta;

                        gc->polygon.shader.frag.z +=
                            (gc->polygon.shader.dzdx * delta);
                    }
                }
            }


            // now have span length

	    gc->polygon.shader.length = spanWidth;

#ifdef _MCD_
            // read from driver z buffer into z span buffer

            if (bMcdZ) {
                GenMcdReadZRawSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                                   iyBottom, spanWidth);
            }
#endif

            if (bClipped) {
                xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) +
                       gc->drawBuffer->buf.xOrigin;
                yScr = __GL_UNBIAS_Y(gc, iyBottom) +
                       gc->drawBuffer->buf.yOrigin;

                ulSpanVisibility = wglSpanVisible(xScr, yScr, spanWidth,
                                                  &cWalls, &Walls);

                if (ulSpanVisibility == WGL_SPAN_ALL) {
                    GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
                    (*cSpanFunc)(gengc);
                } else if (ulSpanVisibility == WGL_SPAN_PARTIAL) {
                    GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                    if (bReadPixels)
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                FALSE);
                    (*cSpanFunc)(gengc);
                    (*gengc->pfnCopyPixels)(gengc,
                                            gc->polygon.shader.cfb,
                                            xScr, yScr, spanWidth,
                                            TRUE);
                }

            } else if (bSurfaceDIB) {
                (*cSpanFunc)(gengc);
            } else {
                xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) +
                       gc->drawBuffer->buf.xOrigin;
                yScr = __GL_UNBIAS_Y(gc, iyBottom) +
                       gc->drawBuffer->buf.yOrigin;

                GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                if (bReadPixels)
                    (*gengc->pfnCopyPixels)(gengc,
                                            gc->polygon.shader.cfb,
                                            xScr, yScr, spanWidth,
                                            FALSE);
                (*cSpanFunc)(gengc);
                if (!bSurfaceDIB)
                    (*gengc->pfnCopyPixels)(gengc,
                                            gc->polygon.shader.cfb,
                                            xScr, yScr, spanWidth,
                                            TRUE);
            }

#ifdef _MCD_
            // write z span buffer back to driver z buffer

            if (bMcdZ) {
                GenMcdWriteZRawSpan(&gc->depthBuffer,
                                    gc->polygon.shader.frag.x,
                                    iyBottom, spanWidth);
            }
#endif

        }

advance:

        GENACCEL(gc).pPix += scansize;

	/* Advance right edge fixed point, adjusting for carry */
	ixRightFrac += gc->polygon.shader.dxRightFrac;
	if (ixRightFrac < 0) {
	    /* Carry/Borrow'd. Use large step */
	    ixRight += gc->polygon.shader.dxRightBig;
	    ixRightFrac &= ~0x80000000;
	} else {
	    ixRight += gc->polygon.shader.dxRightLittle;
	}

	iyBottom++;
	ixLeftFrac += gc->polygon.shader.dxLeftFrac;
	if (ixLeftFrac < 0) {
	    /* Carry/Borrow'd.  Use large step */
	    ixLeft += gc->polygon.shader.dxLeftBig;
	    ixLeftFrac &= ~0x80000000;

            if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
	        r += *((GLint *)&gc->polygon.shader.rBig);
	        g += *((GLint *)&gc->polygon.shader.gBig);
	        b += *((GLint *)&gc->polygon.shader.bBig);
	        a += *((GLint *)&gc->polygon.shader.aBig);
	    }
            if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
	        s += *((GLint *)&gc->polygon.shader.sBig);
	        t += *((GLint *)&gc->polygon.shader.tBig);
                qw += gc->polygon.shader.qwBig;
            }

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zBig;
                /* The implicit multiply is taken out of the loop */
#ifdef _MCD_
                if (!bMcdZ)
#endif
                {
                    zbuf = (__GLzValue*)((GLubyte*)zbuf +
                           gc->polygon.shader.zbufBig);
                }
	    }
	} else {
	    /* Use small step */
	    ixLeft += gc->polygon.shader.dxLeftLittle;
            if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
	        r += *((GLint *)&gc->polygon.shader.rLittle);
	        g += *((GLint *)&gc->polygon.shader.gLittle);
	        b += *((GLint *)&gc->polygon.shader.bLittle);
	        a += *((GLint *)&gc->polygon.shader.aLittle);
	    }
            if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
                s += *((GLint *)&gc->polygon.shader.sLittle);
	        t += *((GLint *)&gc->polygon.shader.tLittle);
                qw += gc->polygon.shader.qwLittle;
            }

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zLittle;
		/* The implicit multiply is taken out of the loop */
#ifdef _MCD_
                if (!bMcdZ)
#endif
                {
                    zbuf = (__GLzValue*)((GLubyte*)zbuf +
                            gc->polygon.shader.zbufLittle);
                }
	    }
	}
    }

    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;
    gc->polygon.shader.frag.z = z;
    gc->polygon.shader.zbuf = zbuf;
    GENACCEL(gc).spanValue.r = r;
    GENACCEL(gc).spanValue.g = g;
    GENACCEL(gc).spanValue.b = b;
    GENACCEL(gc).spanValue.a = a;
    GENACCEL(gc).spanValue.s = s;
    GENACCEL(gc).spanValue.t = t;
    gc->polygon.shader.frag.qw = qw;
}

/**************************************************************************\
\**************************************************************************/

void FASTCALL GenDrvFillSubTriangle(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint spanWidth, clipY0, clipY1;
#ifdef NT
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    GLuint maxWidth;
#else
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
#endif
    GLint zFails;
    __GLzValue *zbuf = NULL, z;
    GLint r, g, b, a, s, t;
    __GLGENcontext  *gengc = (__GLGENcontext *)gc;
    __genSpanFunc cSpanFunc = GENACCEL(gc).__fastSpanFuncPtr;
    __GLspanFunc zSpanFunc = GENACCEL(gc).__fastZSpanFuncPtr;

#ifdef NT
    maxWidth = (gc->transform.clipX1 - gc->transform.clipX0) + 31;
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (maxWidth+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return;
        }
    }
    else
    {
        words = stackWords;
    }
#endif

    gc->polygon.shader.stipplePat = words;
    gc->polygon.shader.cfb = gc->drawBuffer;

    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;

    r = GENACCEL(gc).spanValue.r;
    g = GENACCEL(gc).spanValue.g;
    b = GENACCEL(gc).spanValue.b;
    a = GENACCEL(gc).spanValue.a;
    s = GENACCEL(gc).spanValue.s;
    t = GENACCEL(gc).spanValue.t;

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
        z = gc->polygon.shader.frag.z;

	if( gc->modes.depthBits == 32 )
	    zbuf = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                   ixLeft, iyBottom);
	else
	    zbuf = (__GLzValue *)__GL_DEPTH_ADDR(&gc->depthBuffer,
                                                 (__GLz16Value*),
                                                 ixLeft, iyBottom);
    } else {
        GLuint w;

        if (w = ((gc->transform.clipX1 - gc->transform.clipX0) + 31) >> 3)
            RtlFillMemoryUlong(words, w, ~((ULONG)0));
        GENACCEL(gc).flags &= ~(HAVE_STIPPLE);
    }

    while (iyBottom < iyTop) {
	spanWidth = ixRight - ixLeft;
	/*
	** Only render spans that have non-zero width and which are
	** not scissored out vertically.
	*/
	if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) {
	    gc->polygon.shader.frag.x = ixLeft;
	    gc->polygon.shader.frag.y = iyBottom;
            gc->polygon.shader.zbuf = zbuf;
            gc->polygon.shader.frag.z = z;

            GENACCEL(gc).spanValue.r = r;
            GENACCEL(gc).spanValue.g = g;
            GENACCEL(gc).spanValue.b = b;
            GENACCEL(gc).spanValue.a = a;
            GENACCEL(gc).spanValue.s = s;
            GENACCEL(gc).spanValue.t = t;

            // take care of horizontal scissoring

            if (!gc->transform.reasonableViewport) {
                GLint clipX0 = gc->transform.clipX0;
                GLint clipX1 = gc->transform.clipX1;

                // see if we skip entire span

                if ((ixRight <= clipX0) || (ixLeft >= clipX1))
                    goto advance;

                // now clip right and left

                if (ixRight > clipX1)
                    spanWidth = (clipX1 - ixLeft);

                if (ixLeft < clipX0) {
              	    GLuint delta;

                    delta = clipX0 - ixLeft;
                    spanWidth -= delta;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
                        GENACCEL(gc).spanValue.r += delta * GENACCEL(gc).spanDelta.r;
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
                            GENACCEL(gc).spanValue.g += delta * GENACCEL(gc).spanDelta.g;
                            GENACCEL(gc).spanValue.b += delta * GENACCEL(gc).spanDelta.b;
                        }
                    }
                    if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
                        GENACCEL(gc).spanValue.s += delta * GENACCEL(gc).spanDelta.s;
                        GENACCEL(gc).spanValue.t += delta * GENACCEL(gc).spanDelta.t;
                    }

            	    gc->polygon.shader.frag.x = clipX0;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
                        if( gc->modes.depthBits == 32 )
                            gc->polygon.shader.zbuf += delta;
                        else
                            (__GLz16Value *)gc->polygon.shader.zbuf += delta;

                        gc->polygon.shader.frag.z +=
                            (gc->polygon.shader.dzdx * delta);
                    }
                }
            }

            // now have span length

	    gc->polygon.shader.length = spanWidth;

            // Do z-buffering if needed, and short-circuit rest of span
            // operations if nothing will be drawn.

            if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
                // initially assume no stippling

                GENACCEL(gc).flags &= ~(HAVE_STIPPLE);
                if ((zFails = (*zSpanFunc)(gc)) == 1)
                    goto advance;
                else if (zFails)
                    GENACCEL(gc).flags |= HAVE_STIPPLE;
            }

            (*cSpanFunc)(gengc);
        }

advance:

	/* Advance right edge fixed point, adjusting for carry */
	ixRightFrac += gc->polygon.shader.dxRightFrac;
	if (ixRightFrac < 0) {
	    /* Carry/Borrow'd. Use large step */
	    ixRight += gc->polygon.shader.dxRightBig;
	    ixRightFrac &= ~0x80000000;
	} else {
	    ixRight += gc->polygon.shader.dxRightLittle;
	}

	iyBottom++;
	ixLeftFrac += gc->polygon.shader.dxLeftFrac;
	if (ixLeftFrac < 0) {
	    /* Carry/Borrow'd.  Use large step */
	    ixLeft += gc->polygon.shader.dxLeftBig;
	    ixLeftFrac &= ~0x80000000;

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rBig);
		    g += *((GLint *)&gc->polygon.shader.gBig);
		    b += *((GLint *)&gc->polygon.shader.bBig);
		    a += *((GLint *)&gc->polygon.shader.aBig);
		}
                if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
		    s += *((GLint *)&gc->polygon.shader.sBig);
		    t += *((GLint *)&gc->polygon.shader.tBig);
                }
	    } else {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rBig);
		}
	    }

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zBig;
		/* The implicit multiply is taken out of the loop */
		zbuf = (__GLzValue*)((GLubyte*)zbuf +
                       gc->polygon.shader.zbufBig);
	    }
	} else {
	    /* Use small step */
	    ixLeft += gc->polygon.shader.dxLeftLittle;
	    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rLittle);
		    g += *((GLint *)&gc->polygon.shader.gLittle);
		    b += *((GLint *)&gc->polygon.shader.bLittle);
		    a += *((GLint *)&gc->polygon.shader.aLittle);
		}
                if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
		    s += *((GLint *)&gc->polygon.shader.sLittle);
		    t += *((GLint *)&gc->polygon.shader.tLittle);
                }
	    } else {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rLittle);
		}
            }
	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zLittle;
		/* The implicit multiply is taken out of the loop */
		zbuf = (__GLzValue*)((GLubyte*)zbuf +
		        gc->polygon.shader.zbufLittle);
	    }
	}
    }
    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;
    gc->polygon.shader.frag.z = z;
    GENACCEL(gc).spanValue.r = r;
    GENACCEL(gc).spanValue.g = g;
    GENACCEL(gc).spanValue.b = b;
    GENACCEL(gc).spanValue.a = a;
    GENACCEL(gc).spanValue.s = s;
    GENACCEL(gc).spanValue.t = t;

#ifdef NT
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
#endif
}

/**************************************************************************\
\**************************************************************************/

void GenSnapXLeft(__GLcontext *gc, __GLfloat xLeft, __GLfloat dxdyLeft)
{
    GLint ixLeft, ixLeftFrac;

    ixLeft = __GL_VERTEX_FLOAT_TO_INT(xLeft);
    ixLeftFrac = __GL_VERTEX_PROMOTED_FRACTION(xLeft) + 0x40000000;

    gc->polygon.shader.ixLeftFrac = ixLeftFrac & ~0x80000000;
    gc->polygon.shader.ixLeft = ixLeft + (((GLuint) ixLeftFrac) >> 31);

    /* Compute big and little steps */
    gc->polygon.shader.dxLeftLittle = FTOL(dxdyLeft);
    gc->polygon.shader.dxLeftFrac =
        FLT_FRACTION(dxdyLeft - gc->polygon.shader.dxLeftLittle);

    if (gc->polygon.shader.dxLeftFrac < 0) {
	gc->polygon.shader.dxLeftBig = gc->polygon.shader.dxLeftLittle - 1;
    } else {
	gc->polygon.shader.dxLeftBig = gc->polygon.shader.dxLeftLittle + 1;
    }

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
	/*
	** Compute the big and little depth buffer steps.  We walk the
	** memory pointers for the depth buffer along the edge of the
	** triangle as we walk the edge.  This way we don't have to
	** recompute the buffer address as we go.
	*/
        if (gc->depthBuffer.buf.elementSize == 2) {
            gc->polygon.shader.zbufLittle =
                (gc->depthBuffer.buf.outerWidth +
                 gc->polygon.shader.dxLeftLittle) << 1;
	    gc->polygon.shader.zbufBig =
                (gc->depthBuffer.buf.outerWidth +
                 gc->polygon.shader.dxLeftBig) << 1;
        } else {
            gc->polygon.shader.zbufLittle =
                (gc->depthBuffer.buf.outerWidth +
                 gc->polygon.shader.dxLeftLittle) << 2;
	    gc->polygon.shader.zbufBig =
                (gc->depthBuffer.buf.outerWidth +
                 gc->polygon.shader.dxLeftBig) << 2;
        }
    }
}

/**************************************************************************\
\**************************************************************************/

void GenSnapXRight(__GLcontext *gc, __GLfloat xRight, __GLfloat dxdyRight)
{
    GLint ixRight, ixRightFrac;

    ixRight = __GL_VERTEX_FLOAT_TO_INT(xRight);
    ixRightFrac = __GL_VERTEX_PROMOTED_FRACTION(xRight) + 0x40000000;

    gc->polygon.shader.ixRightFrac = ixRightFrac & ~0x80000000;
    gc->polygon.shader.ixRight = ixRight + (((GLuint) ixRightFrac) >> 31);

    /* Compute big and little steps */
    gc->polygon.shader.dxRightLittle = FTOL(dxdyRight);
    gc->polygon.shader.dxRightFrac =
        FLT_FRACTION(dxdyRight - gc->polygon.shader.dxRightLittle);

    if (gc->polygon.shader.dxRightFrac < 0) {
	gc->polygon.shader.dxRightBig = gc->polygon.shader.dxRightLittle - 1;
    } else {
	gc->polygon.shader.dxRightBig = gc->polygon.shader.dxRightLittle + 1;
    }
}

/**************************************************************************\
\**************************************************************************/


void __fastGenSetInitialParameters(
    __GLcontext *gc,
    const __GLvertex *a,
    __GLfloat fdx,
    __GLfloat fdy)
{

#define sh gc->polygon.shader
#define bPolygonOffset \
        (gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE)

    __GLfloat zOffset;
    __GLfloat dxLeftLittle;

#if _X86_ && ENABLE_ASM

    LARGE_INTEGER temp;

    _asm{

    mov     edx, gc
    fild    DWORD PTR [OFFSET(SHADER.dxLeftLittle)][edx]
    mov     edi, [OFFSET(SHADER.modeFlags)][edx]
    test    edi, __GL_SHADE_DEPTH_ITER
    fstp    dxLeftLittle
    je      noZ
    }

        _asm{

        mov     ebx, [OFFSET(__GLcontext.state.enables.general)][edx]
        mov     ecx, __glZero
        test    ebx, __GL_POLYGON_OFFSET_FILL_ENABLE
        mov     zOffset, ecx

        je      noPolyOffset
        }

        zOffset = __glPolygonOffsetZ(gc);
        _asm{
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }

noPolyOffset:

        _asm{

        mov     eax, a
        fld     fdx
        fmul    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
        fld     fdy
        fmul    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
                            // zy zx
        fxch    ST(1)
                            // zx zy
        fadd    DWORD PTR [OFFSET(__GLvertex.window.z)][eax]

        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
                            // zl zy zx
        fxch    ST(1)       // zy zl zx
        fadd    zOffset
        fxch    ST(1)       // zl zy zx
        fadd    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
                            // zl zy zx (+1)
        fxch    ST(1)       // zy zl zx
        faddp   ST(2), ST   // zl z
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                            // ZL z (+1)
        fxch    ST(1)       // z ZL
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                            // Z ZL
        fxch    ST(1)       // ZL Z
        fistp   temp
        mov     eax, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.zLittle)][edx], eax
        fistp   temp
        mov     eax, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.frag.z)][edx], eax
        }


        #if FORCE_NPX_DEBUG
        {
        ULONG fragZ = FTOL((a->window.z + fdx*sh.dzdxf +
                         (fdy*sh.dzdyf + zOffset)) * GENACCEL(gc).zScale);
        __GLfloat zLittle = ((sh.dzdyf + sh.dxLeftLittle * sh.dzdxf)) * GENACCEL(gc).zScale;
        LONG shZLittle = FTOL(zLittle);

        if (sh.frag.z != fragZ)
            DbgPrint("fragZ %x %x\n", fragZ, sh.frag.z);
        if (sh.zLittle != shZLittle)
            DbgPrint("sh.zLittle %x %x\n", shZLittle, sh.zLittle);
        }
        _asm {
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }
        #endif // FORCE_NPX_DEBUG

noZ:
    _asm{
    test    edi, __GL_SHADE_SMOOTH
    je      done
    test    edi, __GL_SHADE_RGB
    jne     rgbShade
    }

// ciShade:

        {
            CASTFIX(sh.rLittle) =
                FLT_TO_FIX(gc->polygon.shader.drdy +
                           dxLeftLittle * gc->polygon.shader.drdx);
            GENACCEL(gc).spanValue.r =
                FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy);
        }
        _asm{
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        jmp     done
        }

rgbShade:

        _asm
        {
        mov     eax, a

        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.drdx)][edx]
        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dgdx)][edx]    // g r
        fxch    ST(1)                                   // r g
        fadd    DWORD PTR [OFFSET(SHADER.drdy)][edx]    // R g
        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dbdx)][edx]    // b R g
        fxch    ST(2)                                   // g R b
        fadd    DWORD PTR [OFFSET(SHADER.dgdy)][edx]    // G R b
        fxch    ST(2)                                   // b R G
        fadd    DWORD PTR [OFFSET(SHADER.dbdy)][edx]    // B R G
        fxch    ST(1)                                   // R B G
        fmul    __glVal65536                            // sR B  G
        fxch    ST(2)                                   // G  B  sR
        fmul    __glVal65536                            // sG B  sR
        fxch    ST(1)                                   // B  sG sR
        fmul    __glVal65536                            // sB sG sR
        fxch    ST(2)                                   // sR sG sB
        fistp   DWORD PTR [OFFSET(SHADER.rLittle)][edx]
        fistp   DWORD PTR [OFFSET(SHADER.gLittle)][edx]
        fistp   DWORD PTR [OFFSET(SHADER.bLittle)][edx]

        fld     DWORD PTR [OFFSET(SHADER.drdx)][edx]
        mov     eax, [OFFSET(__GLvertex.color)][eax]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.drdy)][edx]
        fmul    fdy                                     // r r
        fxch    ST(1)                                   // r r
        fadd    DWORD PTR [OFFSET(__GLcolor.r)][eax]

        fld     DWORD PTR [OFFSET(SHADER.dgdx)][edx]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.dgdy)][edx]
        fmul    fdy                                     // g g r r
        fxch    ST(1)                                   // g g r r
        fadd    DWORD PTR [OFFSET(__GLcolor.g)][eax]

        fld     DWORD PTR [OFFSET(SHADER.dbdx)][edx]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.dbdy)][edx]
        fmul    fdy                                     // b b g g r r
        fxch    ST(1)                                   // b b g g r r
        fadd    DWORD PTR [OFFSET(__GLcolor.b)][eax]

        fxch    ST(4)                                   // r b g g b r
        faddp   ST(5), ST                               // b g g b r
        fxch    ST(2)                                   // g g b b r
        faddp   ST(1), ST                               // g b b r
        fxch    ST(2)                                   // b b g r
        faddp   ST(1), ST                               // b g r
        fxch    ST(2)                                   // r g b
        fmul    __glVal65536                            // R g b
        fxch    ST(1)                                   // g R b
        fmul    __glVal65536                            // G R b
        fxch    ST(2)                                   // b R G
        fmul    __glVal65536                            // B R G
        fxch    ST(1)                                   // R B G
        fadd    __glVal128                              // R B G
        fxch    ST(2)                                   // G B R
        fadd    __glVal128                              // G B R
        fxch    ST(1)                                   // B G R
        fadd    __glVal128                              // B G R
        fxch    ST(2)                                   // R G B
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.r)][edx]
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.g)][edx]
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.b)][edx]

        }

        #if FORCE_NPX_DEBUG
        {
        LONG rLittle = FLT_TO_FIX(gc->polygon.shader.drdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.drdx);
        LONG gLittle = FLT_TO_FIX(gc->polygon.shader.dgdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.dgdx);
        LONG bLittle = FLT_TO_FIX(gc->polygon.shader.dbdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.dbdx);
        LONG spanR = FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy)+0x0080;
        LONG spanG = FLT_TO_FIX(a->color->g + fdx * sh.dgdx + fdy * sh.dgdy)+0x0080;
        LONG spanB = FLT_TO_FIX(a->color->b + fdx * sh.dbdx + fdy * sh.dbdy)+0x0080;

        if (CASTFIX(sh.rLittle) != rLittle)
            DbgPrint("rLittle: %x %x\n", rLittle, sh.rLittle);
        if (CASTFIX(sh.gLittle) != gLittle)
            DbgPrint("gLittle: %x %x\n", gLittle, sh.gLittle);
        if (CASTFIX(sh.bLittle) != bLittle)
            DbgPrint("bLittle: %x %x\n", bLittle, sh.bLittle);

        if (spanR != GENACCEL(gc).spanValue.r)
            DbgPrint("spanR: %x %x\n", spanR, GENACCEL(gc).spanValue.r);
        if (spanG != GENACCEL(gc).spanValue.g)
            DbgPrint("spanG: %x %x\n", spanG, GENACCEL(gc).spanValue.g);
        if (spanB != GENACCEL(gc).spanValue.b)
            DbgPrint("spanB: %x %x\n", spanB, GENACCEL(gc).spanValue.b);

        }
        _asm {
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }
        #endif // FORCE_NPX_DEBUG

done:

    _asm {

        mov     eax, [OFFSET(SHADER.dxLeftBig)][edx]
        mov     ecx, [OFFSET(SHADER.dxLeftLittle)][edx]

        cmp     eax, ecx
        jle     littleGreater

	test	edi, __GL_SHADE_SMOOTH
        je      bigNoSmooth

        mov     eax, [OFFSET(SHADER.rLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.r)][edx]
        mov     esi, [OFFSET(SHADER.gLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.g)][edx]
        add     eax, ecx
        add     esi, ebx
        mov     [OFFSET(SHADER.rBig)][edx], eax
        mov     [OFFSET(SHADER.gBig)][edx], esi

        mov     eax, [OFFSET(SHADER.bLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.b)][edx]
        mov     esi, [OFFSET(SHADER.zLittle)][edx]
        mov     ebx, [OFFSET(SHADER.dzdx)][edx]
        add     eax, ecx
        add     esi, ebx
        mov     [OFFSET(SHADER.bBig)][edx], eax
        mov     [OFFSET(SHADER.zBig)][edx], esi

    bigNoSmooth:
	test	edi, __GL_SHADE_DEPTH_ITER
        je      done2

        mov     eax, [OFFSET(SHADER.zLittle)][edx]
        mov     ecx, [OFFSET(SHADER.dzdx)][edx]
        add     eax, ecx
        mov     [OFFSET(SHADER.zBig)][edx], eax

        jmp     done2

littleGreater:

	test	edi, __GL_SHADE_SMOOTH
        je      smallNoSmooth

        mov     eax, [OFFSET(SHADER.rLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.r)][edx]
        mov     esi, [OFFSET(SHADER.gLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.g)][edx]
        sub     eax, ecx
        sub     esi, ebx
        mov     [OFFSET(SHADER.rBig)][edx], eax
        mov     [OFFSET(SHADER.gBig)][edx], esi

        mov     eax, [OFFSET(SHADER.bLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.b)][edx]
        mov     esi, [OFFSET(SHADER.zLittle)][edx]
        mov     ebx, [OFFSET(SHADER.dzdx)][edx]
        sub     eax, ecx
        sub     esi, ebx
        mov     [OFFSET(SHADER.bBig)][edx], eax
        mov     [OFFSET(SHADER.zBig)][edx], esi

    smallNoSmooth:
	test	edi, __GL_SHADE_DEPTH_ITER
        je      done2

        mov     eax, [OFFSET(SHADER.zLittle)][edx]
        mov     ecx, [OFFSET(SHADER.dzdx)][edx]
        sub     eax, ecx
        mov     [OFFSET(SHADER.zBig)][edx], eax
done2:
    }

#else _X86_

    __GLfloat zLittle;

    dxLeftLittle = (__GLfloat)sh.dxLeftLittle;

    if (sh.modeFlags & __GL_SHADE_SMOOTH) {
        if (sh.modeFlags & __GL_SHADE_RGB) {

            CASTFIX(sh.rLittle) =
                FLT_TO_FIX(gc->polygon.shader.drdy +
                           dxLeftLittle * gc->polygon.shader.drdx);
            CASTFIX(sh.gLittle) =
                FLT_TO_FIX(gc->polygon.shader.dgdy +
                           dxLeftLittle * gc->polygon.shader.dgdx);
            CASTFIX(sh.bLittle) =
                FLT_TO_FIX(gc->polygon.shader.dbdy +
                           dxLeftLittle * gc->polygon.shader.dbdx);

            GENACCEL(gc).spanValue.r =
                FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy);
            GENACCEL(gc).spanValue.g =
                FLT_TO_FIX(a->color->g + fdx * sh.dgdx + fdy * sh.dgdy);
            GENACCEL(gc).spanValue.b =
                FLT_TO_FIX(a->color->b + fdx * sh.dbdx + fdy * sh.dbdy);
        } else {
            CASTFIX(sh.rLittle) =
                FLT_TO_FIX(gc->polygon.shader.drdy +
                           dxLeftLittle * gc->polygon.shader.drdx);
            GENACCEL(gc).spanValue.r =
                FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy);
        }
    }

    if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
        zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
        sh.frag.z = FTOL((a->window.z + fdx*sh.dzdxf +
                         (fdy*sh.dzdyf + zOffset)) * GENACCEL(gc).zScale);
        zLittle = ((sh.dzdyf + sh.dxLeftLittle * sh.dzdxf)) * GENACCEL(gc).zScale;
        sh.zLittle = FTOL(zLittle);
    }

    if (sh.dxLeftBig > sh.dxLeftLittle) {

	if (sh.modeFlags & __GL_SHADE_SMOOTH) {
            CASTFIX(sh.rBig) = CASTFIX(sh.rLittle) + GENACCEL(gc).spanDelta.r;
            CASTFIX(sh.gBig) = CASTFIX(sh.gLittle) + GENACCEL(gc).spanDelta.g;
            CASTFIX(sh.bBig) = CASTFIX(sh.bLittle) + GENACCEL(gc).spanDelta.b;
        }

	if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
            sh.zBig = sh.zLittle + sh.dzdx;
	}
    } else {	

	if (sh.modeFlags & __GL_SHADE_SMOOTH) {
            CASTFIX(sh.rBig) = CASTFIX(sh.rLittle) - GENACCEL(gc).spanDelta.r;
            CASTFIX(sh.gBig) = CASTFIX(sh.gLittle) - GENACCEL(gc).spanDelta.g;
            CASTFIX(sh.bBig) = CASTFIX(sh.bLittle) - GENACCEL(gc).spanDelta.b;
        }

	if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
            sh.zBig = sh.zLittle - sh.dzdx;
	}
    }
#endif
}


void __fastGenSetInitialParametersTexRGBA(
    __GLcontext *gc,
    const __GLvertex *a,
    __GLfloat fdx,
    __GLfloat fdy)
{
#define sh gc->polygon.shader

    __GLfloat zOffset;
    __GLfloat dxLeftLittle;

#if _X86_ && ENABLE_ASM

    LARGE_INTEGER temp;

    _asm{

    mov     edx, gc
    mov     edi, [OFFSET(SHADER.modeFlags)][edx]
    fild    DWORD PTR [OFFSET(SHADER.dxLeftLittle)][edx]
    test    edi, __GL_SHADE_TEXTURE
    mov     eax, [OFFSET(__GLcontext.state.texture.env)][edx]
    je      notTexture
    mov     ebx, [OFFSET(__GLtextureEnvState.mode)][eax]
    cmp     ebx, GL_REPLACE
    je      fastReplace
    cmp     ebx, GL_DECAL
    jne     notTexture
fastReplace:
    fstp    dxLeftLittle
    jmp     colorDone

notTexture:

    test    edi, __GL_SHADE_SMOOTH
    fstp    dxLeftLittle
    je      colorDone

    }
        _asm
        {
        mov     eax, a
        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.drdx)][edx]
        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dgdx)][edx]    // g r
        fxch    ST(1)                                   // r g
        fadd    DWORD PTR [OFFSET(SHADER.drdy)][edx]    // R g
        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dbdx)][edx]    // b R g
        fxch    ST(2)                                   // g R b
        fadd    DWORD PTR [OFFSET(SHADER.dgdy)][edx]    // G R b
        fxch    ST(2)                                   // b R G
        fadd    DWORD PTR [OFFSET(SHADER.dbdy)][edx]    // B R G
        fxch    ST(1)                                   // R B G
        fmul    __glVal65536                            // sR B  G
        fxch    ST(2)                                   // G  B  sR
        fmul    __glVal65536                            // sG B  sR
        fxch    ST(1)                                   // B  sG sR
        fmul    __glVal65536                            // sB sG sR
        fxch    ST(2)                                   // sR sG sB
        fistp   DWORD PTR [OFFSET(SHADER.rLittle)][edx]
        mov     eax, [OFFSET(__GLvertex.color)][eax]
        fistp   DWORD PTR [OFFSET(SHADER.gLittle)][edx]
        fistp   DWORD PTR [OFFSET(SHADER.bLittle)][edx]


        fld     DWORD PTR [OFFSET(SHADER.drdx)][edx]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.drdy)][edx]
        fmul    fdy                                     // r r
        fxch    ST(1)                                   // r r
        fadd    DWORD PTR [OFFSET(__GLcolor.r)][eax]

        fld     DWORD PTR [OFFSET(SHADER.dgdx)][edx]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.dgdy)][edx]
        fmul    fdy                                     // g g r r
        fxch    ST(1)                                   // g g r r
        fadd    DWORD PTR [OFFSET(__GLcolor.g)][eax]

        fld     DWORD PTR [OFFSET(SHADER.dbdx)][edx]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.dbdy)][edx]
        fmul    fdy                                     // b b g g r r
        fxch    ST(1)                                   // b b g g r r
        fadd    DWORD PTR [OFFSET(__GLcolor.b)][eax]

        fxch    ST(4)                                   // r b g g b r
        faddp   ST(5), ST                               // b g g b r
        fxch    ST(2)                                   // g g b b r
        faddp   ST(1), ST                               // g b b r
        fxch    ST(2)                                   // b b g r
        faddp   ST(1), ST                               // b g r
        fxch    ST(2)                                   // r g b
        fmul    __glVal65536                            // R g b
        fxch    ST(1)                                   // g R b
        fmul    __glVal65536                            // G R b
        fxch    ST(2)                                   // b R G
        fmul    __glVal65536                            // B R G
        fxch    ST(1)                                   // R B G
        fadd    __glVal128                              // R B G
        fxch    ST(2)                                   // G B R
        fadd    __glVal128                              // G B R
        fxch    ST(1)                                   // B G R
        fadd    __glVal128                              // B G R
        fxch    ST(2)                                   // R G B
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.r)][edx]
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.g)][edx]
        mov     ebx, [OFFSET(__GLcontext.state.enables.general)][edx]
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.b)][edx]

        }

        _asm{
        test    ebx, __GL_BLEND_ENABLE
        je      noBlend

        }
            _asm{
            mov     eax, a

            fld     DWORD PTR [OFFSET(SHADER.dadx)][edx]
            mov     eax, DWORD PTR [OFFSET(__GLvertex.color)][eax]
            fmul    fdx
            fld     DWORD PTR [OFFSET(SHADER.dady)][edx]
            fmul    fdy                                     // a a
            fxch    ST(1)
            fadd    DWORD PTR [OFFSET(__GLcolor.a)][eax]    // a a

            fld     dxLeftLittle
            fmul    DWORD PTR [OFFSET(SHADER.dadx)][edx]    // al a a
            fxch    ST(1)                                   // a al a
            faddp   ST(2), ST                               // al a
            fadd    DWORD PTR [OFFSET(SHADER.dady)][edx]    // al a (+1)
            fxch    ST(1)                                   // a al
            fmul    DWORD PTR [OFFSET(GENGCACCEL.aAccelScale)][edx]
                                                            // A al
            fxch    ST(1)                                   // al A
            fmul    DWORD PTR [OFFSET(GENGCACCEL.aAccelScale)][edx]
                                                            // AL A (+1)
            fxch    ST(1)                                   // A AL
            fadd    __glVal128                              // A AL (+1)
            fxch    ST(1)                                   // AL A
            fistp   DWORD PTR [OFFSET(SHADER.aLittle)][edx]
            fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.a)][edx]

            }

            #if FORCE_NPX_DEBUG
            {
            LONG aLittle = FTOL((gc->polygon.shader.dady +
                                (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.dadx) *
                                GENACCEL(gc).aAccelScale);

            LONG spanA = FTOL((a->color->a + fdx * sh.dadx + fdy * sh.dady) *
                              GENACCEL(gc).aAccelScale)+0x0080;

            if (aLittle != CASTFIX(sh.aLittle))
                DbgPrint("sh.aLittle %x %x\n", aLittle, CASTFIX(sh.aLittle));
            if (spanA != GENACCEL(gc).spanValue.a)
                DbgPrint("spanValue.a %x %x\n", spanA, GENACCEL(gc).spanValue.a);
            }
            _asm {
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            }
            #endif // FORCE_NPX_DEBUG

noBlend:

        #if FORCE_NPX_DEBUG
        {
        LONG rLittle = FLT_TO_FIX(gc->polygon.shader.drdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.drdx);
        LONG gLittle = FLT_TO_FIX(gc->polygon.shader.dgdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.dgdx);
        LONG bLittle = FLT_TO_FIX(gc->polygon.shader.dbdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.dbdx);
        LONG spanR = FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy)+0x0080;
        LONG spanG = FLT_TO_FIX(a->color->g + fdx * sh.dgdx + fdy * sh.dgdy)+0x0080;
        LONG spanB = FLT_TO_FIX(a->color->b + fdx * sh.dbdx + fdy * sh.dbdy)+0x0080;

        if (CASTFIX(sh.rLittle) != rLittle)
            DbgPrint("rLittle: %x %x\n", rLittle, sh.rLittle);
        if (CASTFIX(sh.gLittle) != gLittle)
            DbgPrint("gLittle: %x %x\n", gLittle, sh.gLittle);
        if (CASTFIX(sh.bLittle) != bLittle)
            DbgPrint("bLittle: %x %x\n", bLittle, sh.bLittle);

        if (spanR != GENACCEL(gc).spanValue.r)
            DbgPrint("spanR: %x %x\n", spanR, GENACCEL(gc).spanValue.r);
        if (spanG != GENACCEL(gc).spanValue.g)
            DbgPrint("spanG: %x %x\n", spanG, GENACCEL(gc).spanValue.g);
        if (spanB != GENACCEL(gc).spanValue.b)
            DbgPrint("spanB: %x %x\n", spanB, GENACCEL(gc).spanValue.b);
        }
        _asm {
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }

        #endif // FORCE_NPX_DEBUG

colorDone:

    _asm{
    test    edi, __GL_SHADE_TEXTURE
    je      doneTexture

        mov     ebx, [OFFSET(__GLcontext.state.hints.perspectiveCorrection)][edx]
        cmp     ebx, GL_NICEST
        je      nicestTex
    }

            _asm{
            mov     eax, a

            fld     dxLeftLittle
            fmul    DWORD PTR [OFFSET(SHADER.dsdx)][edx]
            fld     dxLeftLittle
            fmul    DWORD PTR [OFFSET(SHADER.dtdx)][edx]
                                            // dt ds
            fld     fdx
            fmul    DWORD PTR [OFFSET(SHADER.dsdx)][edx]
            fld     fdy
            fmul    DWORD PTR [OFFSET(SHADER.dsdy)][edx]
            fxch    ST(1)                   // s  s dt ds
            fadd    DWORD PTR [OFFSET(__GLvertex.texture.x)][eax]

            fxch    ST(3)                   // ds s dt s
            fadd    DWORD PTR [OFFSET(SHADER.dsdy)][edx]

            fld     fdx
            fmul    DWORD PTR [OFFSET(SHADER.dtdx)][edx]
            fld     fdy
            fmul    DWORD PTR [OFFSET(SHADER.dtdy)][edx]
            fxch    ST(1)                   // t t ds s dt s
            fadd    DWORD PTR [OFFSET(__GLvertex.texture.y)][eax]

            fxch    ST(4)                   // dt t ds s t s
            fadd    DWORD PTR [OFFSET(SHADER.dtdy)][edx]

            fxch    ST(5)                   // s t ds s t dt
            faddp   ST(3), ST               // t ds s t dt
            faddp   ST(3), ST               // ds s t dt
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]
                                            // DS s t dt
            fxch    ST(3)                   // dt s t DS
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]
                                            // DT s t DS
            fxch    ST(1)                   // s DT t DS
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]
                                            // S DT t DS
            fxch    ST(2)                   // t DT S DS
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]
                                            // T DT S DS
            fxch    ST(3)                   // DS DT S T

            fistp   DWORD PTR [OFFSET(SHADER.sLittle)][edx]
            fistp   DWORD PTR [OFFSET(SHADER.tLittle)][edx]
            fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.s)][edx]
            fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.t)][edx]

            #if !FORCE_NPX_DEBUG
            jmp     doneTexture
            #endif
            }

            #if FORCE_NPX_DEBUG
            {
            LONG sLittle = FTOL((gc->polygon.shader.dsdy + (__GLfloat)sh.dxLeftLittle *
                           gc->polygon.shader.dsdx) * GENACCEL(gc).texXScale);
            LONG tLittle = FTOL((gc->polygon.shader.dtdy + (__GLfloat)sh.dxLeftLittle *
                           gc->polygon.shader.dtdx) * GENACCEL(gc).texYScale);
            LONG spanS = FTOL((a->texture.x +
                         (fdx * sh.dsdx) + (fdy * sh.dsdy)) * GENACCEL(gc).texXScale);
            LONG spanT = FTOL((a->texture.y +
                         (fdx * sh.dtdx) + (fdy * sh.dtdy)) * GENACCEL(gc).texYScale);

            if (sLittle != CASTFIX(sh.sLittle))
                DbgPrint("sLittle %x %x\n", sLittle, CASTFIX(sh.sLittle));
            if (tLittle != CASTFIX(sh.tLittle))
                DbgPrint("tLittle %x %x\n", tLittle, CASTFIX(sh.tLittle));

            if (GENACCEL(gc).spanValue.s != spanS)
                DbgPrint("spanValue.s %x %x\n", spanS, GENACCEL(gc).spanValue.s);
            if (GENACCEL(gc).spanValue.t != spanT)
                DbgPrint("spanValue.t %x %x\n", spanT, GENACCEL(gc).spanValue.t);
            }
            _asm {
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            jmp     doneTexture;
            }
            #endif // FORCE_NPX_DEBUG

nicestTex:

            _asm{
            mov     eax, a

            fld     dxLeftLittle
            fmul    DWORD PTR [OFFSET(SHADER.dsdx)][edx]
            fld     dxLeftLittle
            fmul    DWORD PTR [OFFSET(SHADER.dtdx)][edx]
                                            // dt ds

            fld     DWORD PTR fdx
            fmul    DWORD PTR [OFFSET(SHADER.dqwdx)][edx]
                                            // qwx dt ds
            fxch    ST(2)
                                            // ds dt qwx
            fadd    DWORD PTR [OFFSET(SHADER.dsdy)][edx]
            fxch    ST(1)                   // dt ds qwx
            fadd    DWORD PTR [OFFSET(SHADER.dtdy)][edx]
            fxch    ST(2)                   // qwx ds dt

            fld     DWORD PTR fdy
            fmul    DWORD PTR [OFFSET(SHADER.dqwdy)][edx]
                                            // qwy qwx ds dt
            fxch    ST(2)                   // ds qwx qwy dt
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]
            fxch    ST(3)                   // dt qwx qwy ds
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]
            fxch    ST(2)                   // qwy qwx dt ds

            fld     DWORD PTR [OFFSET(__GLvertex.texture.w)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]
                                            // qww qwy qwx dt ds

            fxch    ST(4)                   // ds qwy qwx dt qww
            fistp   DWORD PTR [OFFSET(SHADER.sLittle)][edx]
                                            // qwy qwx dt qww

            faddp   ST(1), ST               // qw dt qww
            fxch    ST(1)                   // dt qw qww
            fistp   DWORD PTR [OFFSET(SHADER.tLittle)][edx]
                                            // qw qww

            fld     DWORD PTR [OFFSET(SHADER.dqwdx)][edx]
            fmul    dxLeftLittle            // lt qw qww
            fxch    ST(1)                   // qw lt qww
            faddp   ST(2), ST               // lt qw

            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]
                                            // s  lt qw
            fxch    ST(1)                   // lt s  qw
            fadd    DWORD PTR [OFFSET(SHADER.dqwdy)][edx]
            fxch    ST(1)                   // s  lt qw
            fld     fdx
            fmul    DWORD PTR [OFFSET(SHADER.dsdx)][edx]
            fld     fdy
            fmul    DWORD PTR [OFFSET(SHADER.dsdy)][edx]
            fxch    ST(1)                   // s  s  s  lt qw
            faddp   ST(2), ST               // s  s  lt qw

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]
            fld     fdx
            fmul    DWORD PTR [OFFSET(SHADER.dtdx)][edx]

                                            // t  t  s  s  lt qw
            fxch    ST(2)                   // s  t  t  s  lt qw
            faddp   ST(3), ST               // t  t  s  lt qw
            fld     fdy
            fmul    DWORD PTR [OFFSET(SHADER.dtdy)][edx]

            fxch    ST(1)                   // t  t  t  s  lt qw
            faddp   ST(2), ST               // t  t  s  lt qw
            fxch    ST(2)                   // s  t  t  lt qw

            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]
                                            // S  t  t  lt qw

            fxch    ST(4)                   // qw t  t  lt S
            fstp    DWORD PTR [OFFSET(SHADER.frag.qw)][edx]

            faddp   ST(1), ST               // t  lt S
            fxch    ST(1)                   // lt t  S
            fstp    DWORD PTR [OFFSET(SHADER.qwLittle)][edx]
                                            // t  S
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]   // (+1)
                                            // T S
            fxch    ST(1)                   // S T
            fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.s)][edx]
            fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.t)][edx]

            }

            #if FORCE_NPX_DEBUG
            {
            LONG sLittle = FTOL((gc->polygon.shader.dsdy + dxLeftLittle *
                           gc->polygon.shader.dsdx) * GENACCEL(gc).texXScale);
            LONG tLittle = FTOL((gc->polygon.shader.dtdy + dxLeftLittle *
                           gc->polygon.shader.dtdx) * GENACCEL(gc).texYScale);
            __GLfloat qw = (a->texture.w * a->window.w) + (fdx * sh.dqwdx) +
                           (fdy * sh.dqwdy);
            __GLfloat qwLittle = sh.dqwdy + dxLeftLittle * sh.dqwdx;
            LONG spanS = FTOL(((a->texture.x * a->window.w) +
                         (fdx * sh.dsdx) + (fdy * sh.dsdy)) * GENACCEL(gc).texXScale);
            LONG spanT = FTOL(((a->texture.y * a->window.w) +
                         (fdx * sh.dtdx) + (fdy * sh.dtdy)) * GENACCEL(gc).texYScale);

            if (sLittle != CASTFIX(sh.sLittle))
                DbgPrint("sLittle %x %x\n", sLittle, CASTFIX(sh.sLittle));
            if (tLittle != CASTFIX(sh.tLittle))
                DbgPrint("tLittle %x %x\n", tLittle, CASTFIX(sh.tLittle));

            if (qw != sh.frag.qw)
                DbgPrint("qw %f %f\n", qw, sh.frag.qw);
            if (qwLittle != sh.qwLittle)
                DbgPrint("qw %f %f\n", qwLittle, sh.qwLittle);

            if (GENACCEL(gc).spanValue.s != spanS)
                DbgPrint("spanValue.s %x %x\n", spanS, GENACCEL(gc).spanValue.s);
            if (GENACCEL(gc).spanValue.t != spanT)
                DbgPrint("spanValue.t %x %x\n", spanT, GENACCEL(gc).spanValue.t);
            }
            _asm {
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            }
            #endif // FORCE_NPX_DEBUG

doneTexture:

    _asm{
    test    edi, __GL_SHADE_DEPTH_ITER
    je      noZ
    }

        _asm{

        mov     ebx, [OFFSET(__GLcontext.state.enables.general)][edx]
        mov     ecx, __glZero
        test    ebx, __GL_POLYGON_OFFSET_FILL_ENABLE
        mov     zOffset, ecx

        je      noPolyOffset
        }

        zOffset = __glPolygonOffsetZ(gc);

        _asm{
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }

noPolyOffset:

        _asm{

        mov     eax, a
        fld     fdx
        fmul    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
        fld     fdy
        fmul    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
                            // zy zx
        fxch    ST(1)
                            // zx zy
        fadd    DWORD PTR [OFFSET(__GLvertex.window.z)][eax]

        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
                            // zl zy zx
        fxch    ST(1)       // zy zl zx
        fadd    zOffset
        fxch    ST(1)       // zl zy zx
        fadd    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
                            // zl zy zx (+1)
        fxch    ST(1)       // zy zl zx
        faddp   ST(2), ST   // zl z
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                            // ZL z (+1)
        fxch    ST(1)       // z ZL
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                            // Z ZL
        fxch    ST(1)       // ZL Z
        fistp   temp
        mov     eax, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.zLittle)][edx], eax
        fistp   temp
        mov     eax, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.frag.z)][edx], eax
        }


        #if FORCE_NPX_DEBUG
        {
        ULONG fragZ = FTOL((a->window.z + fdx*sh.dzdxf +
                         (fdy*sh.dzdyf + zOffset)) * GENACCEL(gc).zScale);
        __GLfloat zLittle = ((sh.dzdyf + sh.dxLeftLittle * sh.dzdxf)) * GENACCEL(gc).zScale;
        LONG shZLittle = FTOL(zLittle);

        if (sh.frag.z != fragZ)
            DbgPrint("fragZ %x %x\n", fragZ, sh.frag.z);
        if (sh.zLittle != shZLittle)
            DbgPrint("sh.zLittle %x %x\n", shZLittle, sh.zLittle);
        }
        _asm {
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }
        #endif // FORCE_NPX_DEBUG

noZ:

    _asm {

        mov     eax, [OFFSET(SHADER.dxLeftBig)][edx]
        mov     ecx, [OFFSET(SHADER.dxLeftLittle)][edx]

        cmp     eax, ecx
        jle     littleGreater

	test	edi, __GL_SHADE_SMOOTH
        je      bigNoSmooth

        mov     eax, [OFFSET(SHADER.rLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.r)][edx]
        mov     esi, [OFFSET(SHADER.gLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.g)][edx]
        add     eax, ecx
        add     esi, ebx
        mov     [OFFSET(SHADER.rBig)][edx], eax
        mov     [OFFSET(SHADER.gBig)][edx], esi

        mov     eax, [OFFSET(SHADER.bLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.b)][edx]
        mov     esi, [OFFSET(SHADER.aLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.a)][edx]
        add     eax, ecx
        add     esi, ebx
        mov     [OFFSET(SHADER.bBig)][edx], eax
        mov     [OFFSET(SHADER.aBig)][edx], esi

    bigNoSmooth:
	test	edi, __GL_SHADE_TEXTURE
        je      bigNoTexture


        fld     DWORD PTR [OFFSET(SHADER.qwLittle)][edx]
        mov     eax, [OFFSET(SHADER.sLittle)][edx]
        fadd    DWORD PTR [OFFSET(SHADER.dqwdx)][edx]
        mov     ecx, [OFFSET(SPANDELTA.s)][edx]
        mov     esi, [OFFSET(SHADER.tLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.t)][edx]
        add     eax, ecx
        add     esi, ebx
        mov     [OFFSET(SHADER.sBig)][edx], eax
        mov     [OFFSET(SHADER.tBig)][edx], esi
        fstp    DWORD PTR [OFFSET(SHADER.qwBig)][edx]

    bigNoTexture:
	test	edi, __GL_SHADE_DEPTH_ITER
        je      done

        mov     eax, [OFFSET(SHADER.zLittle)][edx]
        mov     ecx, [OFFSET(SHADER.dzdx)][edx]
        add     eax, ecx
        mov     [OFFSET(SHADER.zBig)][edx], eax

        jmp     done

littleGreater:

	test	edi, __GL_SHADE_SMOOTH
        je      smallNoSmooth

        mov     eax, [OFFSET(SHADER.rLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.r)][edx]
        mov     esi, [OFFSET(SHADER.gLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.g)][edx]
        sub     eax, ecx
        sub     esi, ebx
        mov     [OFFSET(SHADER.rBig)][edx], eax
        mov     [OFFSET(SHADER.gBig)][edx], esi

        mov     eax, [OFFSET(SHADER.bLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.b)][edx]
        mov     esi, [OFFSET(SHADER.aLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.a)][edx]
        sub     eax, ecx
        sub     esi, ebx
        mov     [OFFSET(SHADER.bBig)][edx], eax
        mov     [OFFSET(SHADER.aBig)][edx], esi


    smallNoSmooth:
	test	edi, __GL_SHADE_TEXTURE
        je      smallNoTexture


        fld     DWORD PTR [OFFSET(SHADER.qwLittle)][edx]
        mov     eax, [OFFSET(SHADER.sLittle)][edx]
        fsub    DWORD PTR [OFFSET(SHADER.dqwdx)][edx]
        mov     ecx, [OFFSET(SPANDELTA.s)][edx]
        mov     esi, [OFFSET(SHADER.tLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.t)][edx]
        sub     eax, ecx
        sub     esi, ebx
        mov     [OFFSET(SHADER.sBig)][edx], eax
        mov     [OFFSET(SHADER.tBig)][edx], esi
        fstp    DWORD PTR [OFFSET(SHADER.qwBig)][edx]

    smallNoTexture:
	test	edi, __GL_SHADE_DEPTH_ITER
        je      done

        mov     eax, [OFFSET(SHADER.zLittle)][edx]
        mov     ecx, [OFFSET(SHADER.dzdx)][edx]
        sub     eax, ecx
        mov     [OFFSET(SHADER.zBig)][edx], eax
done:
    }

#else

    __GLfloat zLittle;
    __GLfloat tmp1, tmp2;

    dxLeftLittle = (float)sh.dxLeftLittle;

    // Don't bother with the color deltas if we're decaling or replacing
    // with textures.

    if ((gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) &&
        ((gc->state.texture.env[0].mode == GL_REPLACE) ||
         (gc->state.texture.env[0].mode == GL_DECAL))) {
        ;
    } else if (sh.modeFlags & __GL_SHADE_SMOOTH) {

        CASTFIX(sh.rLittle) =
            FLT_TO_FIX(gc->polygon.shader.drdy +
                       dxLeftLittle * gc->polygon.shader.drdx);
        CASTFIX(sh.gLittle) =
            FLT_TO_FIX(gc->polygon.shader.dgdy +
                       dxLeftLittle * gc->polygon.shader.dgdx);
        CASTFIX(sh.bLittle) =
            FLT_TO_FIX(gc->polygon.shader.dbdy +
                       dxLeftLittle * gc->polygon.shader.dbdx);

        GENACCEL(gc).spanValue.r =
            FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy)+0x0080;
        GENACCEL(gc).spanValue.g =
            FLT_TO_FIX(a->color->g + fdx * sh.dgdx + fdy * sh.dgdy)+0x0080;
        GENACCEL(gc).spanValue.b =
            FLT_TO_FIX(a->color->b + fdx * sh.dbdx + fdy * sh.dbdy)+0x0080;

        if (gc->state.enables.general & __GL_BLEND_ENABLE) {

            CASTFIX(sh.aLittle) =
                FTOL((gc->polygon.shader.dady +
                      dxLeftLittle * gc->polygon.shader.dadx) *
                     GENACCEL(gc).aAccelScale);

            GENACCEL(gc).spanValue.a =
                FTOL((a->color->a + fdx * sh.dadx + fdy * sh.dady) *
                     GENACCEL(gc).aAccelScale)+0x0080;
        }
    }

    if (sh.modeFlags & __GL_SHADE_TEXTURE) {

        if (gc->state.hints.perspectiveCorrection != GL_NICEST) {

            tmp1 = (gc->polygon.shader.dsdy + dxLeftLittle *
                    gc->polygon.shader.dsdx) * GENACCEL(gc).texXScale;
            tmp2 = (gc->polygon.shader.dtdy + dxLeftLittle *
                    gc->polygon.shader.dtdx) * GENACCEL(gc).texYScale;

            CASTFIX(sh.sLittle) = FTOL(tmp1);
            CASTFIX(sh.tLittle) = FTOL(tmp2);

            tmp1 = (a->texture.x +
                    (fdx * sh.dsdx) + (fdy * sh.dsdy)) * GENACCEL(gc).texXScale;

            tmp2 = (a->texture.y +
                    (fdx * sh.dtdx) + (fdy * sh.dtdy)) * GENACCEL(gc).texYScale;

            GENACCEL(gc).spanValue.s = FTOL(tmp1);
            GENACCEL(gc).spanValue.t = FTOL(tmp2);

        } else {

            tmp1 = (gc->polygon.shader.dsdy + dxLeftLittle *
                    gc->polygon.shader.dsdx) * GENACCEL(gc).texXScale;
            tmp2 = (gc->polygon.shader.dtdy + dxLeftLittle *
                    gc->polygon.shader.dtdx) * GENACCEL(gc).texYScale;

            CASTFIX(sh.sLittle) = FTOL(tmp1);
            CASTFIX(sh.tLittle) = FTOL(tmp2);

            sh.frag.qw = (a->texture.w * a->window.w) + (fdx * sh.dqwdx) +
                         (fdy * sh.dqwdy);

            sh.qwLittle = sh.dqwdy + dxLeftLittle * sh.dqwdx;

            tmp1 = ((a->texture.x * a->window.w) +
                    (fdx * sh.dsdx) + (fdy * sh.dsdy)) * GENACCEL(gc).texXScale;

            tmp2 = ((a->texture.y * a->window.w) +
                    (fdx * sh.dtdx) + (fdy * sh.dtdy)) * GENACCEL(gc).texYScale;

            GENACCEL(gc).spanValue.s = FTOL(tmp1);
            GENACCEL(gc).spanValue.t = FTOL(tmp2);
        }
    }


    if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
        zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
        sh.frag.z = FTOL((a->window.z + fdx*sh.dzdxf +
                         (fdy*sh.dzdyf + zOffset)) * GENACCEL(gc).zScale);
        zLittle = ((sh.dzdyf + sh.dxLeftLittle * sh.dzdxf)) * GENACCEL(gc).zScale;
        sh.zLittle = FTOL(zLittle);
    }

    if (sh.dxLeftBig > sh.dxLeftLittle) {

	if (sh.modeFlags & __GL_SHADE_SMOOTH) {
            CASTFIX(sh.rBig) = CASTFIX(sh.rLittle) + GENACCEL(gc).spanDelta.r;
            CASTFIX(sh.gBig) = CASTFIX(sh.gLittle) + GENACCEL(gc).spanDelta.g;
            CASTFIX(sh.bBig) = CASTFIX(sh.bLittle) + GENACCEL(gc).spanDelta.b;
            if (gc->state.enables.general & __GL_BLEND_ENABLE)
                CASTFIX(sh.aBig) = CASTFIX(sh.aLittle) + GENACCEL(gc).spanDelta.a;
        }

        if (sh.modeFlags & __GL_SHADE_TEXTURE) {
            CASTFIX(sh.sBig) = CASTFIX(sh.sLittle) + GENACCEL(gc).spanDelta.s;
            CASTFIX(sh.tBig) = CASTFIX(sh.tLittle) + GENACCEL(gc).spanDelta.t;
            sh.qwBig = sh.qwLittle + sh.dqwdx;
        }

	if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
            sh.zBig = sh.zLittle + sh.dzdx;
	}
    } else {	

	if (sh.modeFlags & __GL_SHADE_SMOOTH) {
            CASTFIX(sh.rBig) = CASTFIX(sh.rLittle) - GENACCEL(gc).spanDelta.r;
            CASTFIX(sh.gBig) = CASTFIX(sh.gLittle) - GENACCEL(gc).spanDelta.g;
            CASTFIX(sh.bBig) = CASTFIX(sh.bLittle) - GENACCEL(gc).spanDelta.b;
            if (gc->state.enables.general & __GL_BLEND_ENABLE)
                CASTFIX(sh.aBig) = CASTFIX(sh.aLittle) - GENACCEL(gc).spanDelta.a;
        }

        if (sh.modeFlags & __GL_SHADE_TEXTURE) {
            CASTFIX(sh.sBig) = CASTFIX(sh.sLittle) - GENACCEL(gc).spanDelta.s;
            CASTFIX(sh.tBig) = CASTFIX(sh.tLittle) - GENACCEL(gc).spanDelta.t;
            sh.qwBig = sh.qwLittle - sh.dqwdx;
        }

	if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
            sh.zBig = sh.zLittle - sh.dzdx;
	}
    }
#endif
}

/**************************************************************************\
\**************************************************************************/


void FASTCALL __fastGenCalcDeltas(
    __GLcontext *gc,
    __GLvertex *a,
    __GLvertex *b,
    __GLvertex *c)
{
    __GLfloat oneOverArea, t1, t2, t3, t4;

#if _X86_ && ENABLE_ASM

    LARGE_INTEGER temp;

    _asm{

    mov     edx, gc
    fld     __glOne
    fdiv    DWORD PTR [OFFSET(SHADER.area)][edx]
    mov     edi, [OFFSET(SHADER.modeFlags)][edx]
    test    edi, __GL_SHADE_RGB
    je      notRGB
        test    edi, __GL_SHADE_SMOOTH
        je      notSmoothRGB
    }

            _asm{

            mov     eax, a
            mov     ebx, b
            mov     ecx, c

            fstp    oneOverArea                         // finish divide

            fld     DWORD PTR [OFFSET(SHADER.dyAC)][edx]
            mov     eax, [OFFSET(__GLvertex.color)][eax]
            fmul    oneOverArea
            fld     DWORD PTR [OFFSET(SHADER.dyBC)][edx]
            mov     ebx, [OFFSET(__GLvertex.color)][ebx]
            fmul    oneOverArea                         // dyBC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxAC)][edx]
            mov     ecx, [OFFSET(__GLvertex.color)][ecx]
            fmul    oneOverArea                         // dxAC dyBC dyAC
            fxch    ST(1)                               // dyBC dxAC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxBC)][edx]
            fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
            fxch    ST(3)                               // dyAC dyBC dxAC dxBC
            fstp    t1
            fstp    t2
            fstp    t3
            fstp    t4

            // Now, calculate deltas:

                // Red

            fld     DWORD PTR [OFFSET(__GLcolor.r)][eax]
            fsub    DWORD PTR [OFFSET(__GLcolor.r)][ecx]
            fld     DWORD PTR [OFFSET(__GLcolor.r)][ebx]
            fsub    DWORD PTR [OFFSET(__GLcolor.r)][ecx]
                            // drBC drAC
            fld     ST(1)       // drAC drBC drAC
            fmul    t2          // drACt2 drBC drAC
            fld     ST(1)       // drBC drACt2 drBC drAC
            fmul    t1          // drBCt1 drACt2 drBC drAC
            fxch    ST(2)       // drBC drACt2 drBCt1 drAC
            fmul    t3          // drBCt3 drACt2 drBCt1 drAC
            fxch    ST(3)       // drAC drACt2 drBCt1 drBCt3
            fmul    t4          // drACt4 drACt2 drBCt1 drBCt3
            fxch    ST(2)       // drBCt1 drACt2 drACt4 drBCt3
            fsubp   ST(1), ST   // drACBC drACt4 drBCt3

            fld     DWORD PTR [OFFSET(__GLcolor.g)][ebx]
            fsub    DWORD PTR [OFFSET(__GLcolor.g)][ecx]
                            // dgBC drACBC drACt4 drBCt3
            fxch    ST(2)       // drACt4 drACBC dgBC drBCt3
            fsubp   ST(3), ST   // drACBC dgBC drBCAC
            fst     DWORD PTR [OFFSET(SHADER.drdx)][edx]
            fmul    __glVal65536
                            // DRACBC dgBC drBCAC
            fxch    ST(2)       // drBCAC dgBC DRACBC
            fstp    DWORD PTR [OFFSET(SHADER.drdy)][edx]
                            // dgBC DRACBC
            fld     DWORD PTR [OFFSET(__GLcolor.g)][eax]
            fsub    DWORD PTR [OFFSET(__GLcolor.g)][ecx]
                            // dgAC dgBC DRACBC
            fxch    ST(2)       // DRACBC dgBC dgAC
            fistp   DWORD PTR [OFFSET(SPANDELTA.r)][edx]

                // Green
                                // dgBC dgAC
            fld     ST(1)       // dgAC dgBC dgAC
            fmul    t2          // dgACt2 dgBC dgAC
            fld     ST(1)       // dgBC dgACt2 dgBC dgAC
            fmul    t1          // dgBCt1 dgACt2 dgBC dgAC
            fxch    ST(2)       // dgBC dgACt2 dgBCt1 dgAC
            fmul    t3          // dgBCt3 dgACt2 dgBCt1 dgAC
            fxch    ST(3)       // dgAC dgACt2 dgBCt1 dgBCt3
            fmul    t4          // dgACt4 dgACt2 dgBCt1 dgBCt3
            fxch    ST(2)       // dgBCt1 dgACt2 dgACt4 dgBCt3
            fsubp   ST(1), ST   // dgACBC dgACt4 dgBCt3

            fld     DWORD PTR [OFFSET(__GLcolor.b)][ebx]
            fsub    DWORD PTR [OFFSET(__GLcolor.b)][ecx]
                                // dbBC dgACBC dgACt4 dgBCt3
            fxch    ST(2)       // dgACt4 dgACBC dbBC dgBCt3
            fsubp   ST(3), ST   // dgACBC dbBC dgBCAC
            fst     DWORD PTR [OFFSET(SHADER.dgdx)][edx]
            fmul    __glVal65536
                                // DGACBC dbBC dgBCAC
            fxch    ST(2)       // dgBCAC dbBC DGACBC
            fstp    DWORD PTR [OFFSET(SHADER.dgdy)][edx]
                                // dbBC DGACBC
            fld     DWORD PTR [OFFSET(__GLcolor.b)][eax]
            fsub    DWORD PTR [OFFSET(__GLcolor.b)][ecx]
                                // dbAC dbBC DGACBC
            fxch    ST(2)       // DGACBC dbBC dbAC
            fistp   DWORD PTR [OFFSET(SPANDELTA.g)][edx]

                // Blue
                                // dbBC dbAC
            fld     ST(1)       // dbAC dbBC dbAC
            fmul    t2          // dbACt2 dbBC dbAC
            fld     ST(1)       // dbBC dbACt2 dbBC dbAC
            fmul    t1          // dbBCt1 dbACt2 dbBC dbAC
            fxch    ST(2)       // dbBC dbACt2 dbBCt1 dbAC
            fmul    t3          // dbBCt3 dbACt2 dbBCt1 dbAC
            fxch    ST(3)       // dbAC dbACt2 dbBCt1 dbBCt3
            fmul    t4          // dbACt4 dbACt2 dbBCt1 dbBCt3
            fxch    ST(2)       // dbBCt1 dbACt2 dbACt4 dbBCt3
            fsubp   ST(1), ST   // dbACBC dbACt4 dbBCt3
            fxch    ST(1)       // dbACt4 dbACBC dbBCt3
            fsubp   ST(2), ST   // dbACBC dbBCAC (+1)
            fst     DWORD PTR [OFFSET(SHADER.dbdx)][edx]
            fmul    __glVal65536
                                // DBACBC dbBCAC
            fxch    ST(1)       // dbBCAC DBACBC
            fstp    DWORD PTR [OFFSET(SHADER.dbdy)][edx]
            fistp   DWORD PTR [OFFSET(SPANDELTA.b)][edx]

            mov     ebx, [OFFSET(GENGCACCEL.__fastSmoothSpanFuncPtr)][edx]
            mov     [OFFSET(GENGCACCEL.__fastSpanFuncPtr)][edx], ebx

            mov     eax, [OFFSET(SPANDELTA.r)][edx]
            mov     ebx, [OFFSET(SPANDELTA.g)][edx]
            mov     ecx, [OFFSET(SPANDELTA.b)][edx]
            or      eax, ebx
            or      eax, ecx
            jne     notZeroDelta

            mov     eax, [OFFSET(GENGCACCEL.flags)][edx]
            test    eax, GEN_FASTZBUFFER
            jne     notZeroDelta

            mov     ebx, [OFFSET(GENGCACCEL.__fastFlatSpanFuncPtr)][edx]
            mov     [OFFSET(GENGCACCEL.__fastSpanFuncPtr)][edx], ebx

notZeroDelta:

            #if !FORCE_NPX_DEBUG
            jmp     colorDone
            #endif

            }

            #if FORCE_NPX_DEBUG
            {
	    __GLfloat drAC, dgAC, dbAC, daAC;
	    __GLfloat drBC, dgBC, dbBC, daBC;
	    __GLcolor *ac, *bc, *cc;
            __GLfloat ft1 = gc->polygon.shader.dyAC * oneOverArea;
            __GLfloat ft2 = gc->polygon.shader.dyBC * oneOverArea;
            __GLfloat ft3 = gc->polygon.shader.dxAC * oneOverArea;
            __GLfloat ft4 = gc->polygon.shader.dxBC * oneOverArea;
            __GLfloat drdx;
            __GLfloat drdy;
            __GLfloat dgdx;
            __GLfloat dgdy;
            __GLfloat dbdx;
            __GLfloat dbdy;
            LONG spanR, spanG, spanB;

            ac = a->color;
            bc = b->color;
            cc = c->color;

            drAC = ac->r - cc->r;
            drBC = bc->r - cc->r;
            dgAC = ac->g - cc->g;
            dgBC = bc->g - cc->g;
            dbAC = ac->b - cc->b;
            dbBC = bc->b - cc->b;

            drdx = drAC * t2 - drBC * t1;
            drdy = drBC * t3 - drAC * t4;
            dgdx = dgAC * t2 - dgBC * t1;
            dgdy = dgBC * t3 - dgAC * t4;
            dbdx = dbAC * t2 - dbBC * t1;
            dbdy = dbBC * t3 - dbAC * t4;

            spanR = FLT_TO_FIX(drdx);
            spanG = FLT_TO_FIX(dgdx);
            spanB = FLT_TO_FIX(dbdx);

            if (ft1 != t1)
                DbgPrint("t1 %f %f\n", t1, ft1);
            if (ft2 != t2)
                DbgPrint("t2 %f %f\n", t2, ft2);
            if (ft3 != t3)
                DbgPrint("t3 %f %f\n", t3, ft3);
            if (ft4 != t4)
                DbgPrint("t4 %f %f\n", t4, ft4);

            if (drdx != gc->polygon.shader.drdx)
                DbgPrint("drdx %f %f\n", drdx, gc->polygon.shader.drdx);
            if (drdy != gc->polygon.shader.drdy)
                DbgPrint("drdy %f %f\n", drdy, gc->polygon.shader.drdy);
            if (dgdx != gc->polygon.shader.dgdx)
                DbgPrint("dgdx %f %f\n", dgdx, gc->polygon.shader.dgdx);
            if (dgdy != gc->polygon.shader.dgdy)
                DbgPrint("dgdy %f %f\n", dgdy, gc->polygon.shader.dgdy);
            if (dbdx != gc->polygon.shader.dbdx)
                DbgPrint("dbdx %f %f\n", dbdx, gc->polygon.shader.dbdx);
            if (dbdy != gc->polygon.shader.dbdy)
                DbgPrint("dbdy %f %f\n", dbdy, gc->polygon.shader.dbdy);

            if (spanR != GENACCEL(gc).spanDelta.r)
                DbgPrint("spanDelta.r %x %x\n", spanR, GENACCEL(gc).spanDelta.r);
            if (spanG!= GENACCEL(gc).spanDelta.g)
                DbgPrint("spanDelta.g %x %x\n", spanG, GENACCEL(gc).spanDelta.g);
            if (spanB != GENACCEL(gc).spanDelta.b)
                DbgPrint("spanDelta.b %x %x\n", spanB, GENACCEL(gc).spanDelta.b);
            }
            _asm{
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            jmp     colorDone
            }
            #endif // FORCE_NPX_DEBUG


notSmoothRGB:

            _asm{

            mov     eax, [OFFSET(__GLcontext.vertex.provoking)][edx]

            fld     __glVal65536
            mov     eax, [OFFSET(__GLvertex.color)][eax]
            fmul    DWORD PTR [OFFSET(__GLcolor.r)][eax]
            fld     __glVal65536
            fmul    DWORD PTR [OFFSET(__GLcolor.g)][eax]
            fld     __glVal65536
            fmul    DWORD PTR [OFFSET(__GLcolor.b)][eax]
                                                          // B G R
            fxch    ST(2)                                 // R G B
            fistp   DWORD PTR [OFFSET(SPANVALUE.r)][edx]  // G B
            fistp   DWORD PTR [OFFSET(SPANVALUE.g)][edx]
            fistp   DWORD PTR [OFFSET(SPANVALUE.b)][edx]

            mov     ebx, [OFFSET(GENGCACCEL.__fastFlatSpanFuncPtr)][edx]
            mov     [OFFSET(GENGCACCEL.__fastSpanFuncPtr)][edx], ebx

            jmp     colorDone

            }

notRGB:

	if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH)
        {
	    __GLfloat drAC;
	    __GLfloat drBC;
	    __GLcolor *ac, *bc, *cc;

            ac = a->color;
            bc = b->color;
	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;

            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;

	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;

            GENACCEL(gc).spanDelta.r =
                FLT_TO_FIX(gc->polygon.shader.drdx);

            if (GENACCEL(gc).spanDelta.r == 0)
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastFlatSpanFuncPtr;
            }
            else
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastSmoothSpanFuncPtr;
            }
	}
        else
        {
            GENACCEL(gc).spanValue.r =
                FLT_TO_FIX(gc->vertex.provoking->color->r);

            GENACCEL(gc).__fastSpanFuncPtr =
                GENACCEL(gc).__fastFlatSpanFuncPtr;
	}

        _asm{
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }


colorDone:

    _asm{
    test    edi, __GL_SHADE_DEPTH_ITER
    je      noZ

        test    edi, __GL_SHADE_SMOOTH
        jne     areaOK
    }

            _asm{

            fstp    oneOverArea                         // finish divide

            fld     DWORD PTR [OFFSET(SHADER.dyAC)][edx]
            fmul    oneOverArea
            fld     DWORD PTR [OFFSET(SHADER.dyBC)][edx]
            fmul    oneOverArea                         // dyBC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxAC)][edx]
            fmul    oneOverArea                         // dxAC dyBC dyAC
            fxch    ST(1)                               // dyBC dxAC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxBC)][edx]
            fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
            fxch    ST(3)                               // dyAC dyBC dxAC dxBC
            fstp    t1
            fstp    t2
            fstp    t3
            fstp    t4
            }

            #if FORCE_NPX_DEBUG
            {
            __GLfloat ft1 = gc->polygon.shader.dyAC * oneOverArea;
            __GLfloat ft2 = gc->polygon.shader.dyBC * oneOverArea;
            __GLfloat ft3 = gc->polygon.shader.dxAC * oneOverArea;
            __GLfloat ft4 = gc->polygon.shader.dxBC * oneOverArea;

            if (ft1 != t1)
                DbgPrint("zt1 %f %f\n", t1, ft1);
            if (ft2 != t2)
                DbgPrint("zt2 %f %f\n", t2, ft2);
            if (ft3 != t3)
                DbgPrint("zt3 %f %f\n", t3, ft3);
            if (ft4 != t4)
                DbgPrint("zt4 %f %f\n", t4, ft4);
            }
            _asm{
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            }
            #endif // FORCE_NPX_DEBUG
areaOK:

        _asm{

        mov     ecx, c
        mov     eax, a
        mov     ebx, b

        fld     DWORD PTR [OFFSET(__GLvertex.window.z)][eax]
        fsub    DWORD PTR [OFFSET(__GLvertex.window.z)][ecx]
        fld     DWORD PTR [OFFSET(__GLvertex.window.z)][ebx]
        fsub    DWORD PTR [OFFSET(__GLvertex.window.z)][ecx]
                                                        // dzBC dzAC
        fld     ST(1)                                   // dzAC dzBC dzAC
        fmul    t2                                      // ACt2 dzBC dzAC
        fld     ST(1)                                   // dzBC ACt2 dzBC dzAC
        fmul    t1                                      // BCt1 ACt2 dzBC dzAC
        fxch    ST(3)                                   // dzAC ACt2 dzBC BCt1
        fmul    t4                                      // ACt4 ACt2 dzBC BCt1
        fxch    ST(2)                                   // dzBC ACt2 ACt4 BCt1
        fmul    t3                                      // BCt3 ACt2 ACt4 BCt1
        fsubrp  ST(2),ST                                // ACt2 BCAC BCt1
        fsubrp  ST(2),ST                                // BCAC ACBC
        fxch    ST(1)                                   // ACBC BCAC
                                                        // dzdx dzdy
        fld     ST(0)                                   // dzdx dzdx dzdy
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                                                        // dzdxS dzdx dzdy
        fxch    ST(2)                                   // dzdy dzdx dzdxS
        fstp    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
        fstp    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
        fistp   temp
        mov     ebx, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.dzdx)][edx], ebx
        mov     DWORD PTR [OFFSET(SPANDELTA.z)][edx], ebx
        #if !FORCE_NPX_DEBUG
        jmp     deltaDone
        #endif
        }

        #if FORCE_NPX_DEBUG
        {
        __GLfloat dzdxf;
        __GLfloat dzdyf;
        __GLfloat dzAC, dzBC;
        ULONG spanDeltaZ;

        dzAC = a->window.z - c->window.z;
        dzBC = b->window.z - c->window.z;

        dzdxf = dzAC * t2 - dzBC * t1;
        dzdyf = dzBC * t3 - dzAC * t4;
        spanDeltaZ = FTOL(dzdxf * GENACCEL(gc).zScale);

        if (dzdxf != gc->polygon.shader.dzdxf)
            DbgPrint("dzdxf %f %f\n", dzdxf, gc->polygon.shader.dzdxf);
        if (dzdyf != gc->polygon.shader.dzdyf)
            DbgPrint("dzdyf %f %f\n", dzdyf, gc->polygon.shader.dzdyf);

        if (spanDeltaZ != GENACCEL(gc).spanDelta.z)
            DbgPrint("spanDeltaZ %x %x\n", spanDeltaZ, GENACCEL(gc).spanDelta.z);
        goto deltaDone;
        }
        #endif // FORCE_NPX_DEBUG
noZ:

    _asm{
    test    edi, __GL_SHADE_SMOOTH
    jne     deltaDone
    fstp    ST(0)
    }

deltaDone:
    return;

#else // _X86_

    /* Pre-compute one over polygon area */

    __GL_FLOAT_BEGIN_DIVIDE(__glOne, gc->polygon.shader.area, &oneOverArea);

    /*
    ** t1-4 are delta values for unit changes in x or y for each
    ** parameter.
    */

    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB)
    {
	if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH)
        {

	    __GLfloat drAC, dgAC, dbAC, daAC;
	    __GLfloat drBC, dgBC, dbBC, daBC;
	    __GLcolor *ac, *bc, *cc;

            ac = a->color;
            bc = b->color;
	    cc = c->color;

	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;
	    dgAC = ac->g - cc->g;
	    dgBC = bc->g - cc->g;
	    dbAC = ac->b - cc->b;
	    dbBC = bc->b - cc->b;

            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;

	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
	    gc->polygon.shader.dgdx = dgAC * t2 - dgBC * t1;
	    gc->polygon.shader.dgdy = dgBC * t3 - dgAC * t4;
	    gc->polygon.shader.dbdx = dbAC * t2 - dbBC * t1;
	    gc->polygon.shader.dbdy = dbBC * t3 - dbAC * t4;

            GENACCEL(gc).spanDelta.r = FLT_TO_FIX(gc->polygon.shader.drdx);
            GENACCEL(gc).spanDelta.g = FLT_TO_FIX(gc->polygon.shader.dgdx);
            GENACCEL(gc).spanDelta.b = FLT_TO_FIX(gc->polygon.shader.dbdx);

            if (   ((GENACCEL(gc).spanDelta.r | GENACCEL(gc).spanDelta.g |
                     GENACCEL(gc).spanDelta.b) == 0)
                && ((GENACCEL(gc).flags & GEN_FASTZBUFFER) == 0))
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastFlatSpanFuncPtr;
            }
            else
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastSmoothSpanFuncPtr;
            }
	}
        else
        {
            __GLcolor *flatColor = gc->vertex.provoking->color;

            GENACCEL(gc).spanValue.r = FLT_TO_FIX(flatColor->r);
            GENACCEL(gc).spanValue.g = FLT_TO_FIX(flatColor->g);
            GENACCEL(gc).spanValue.b = FLT_TO_FIX(flatColor->b);

            GENACCEL(gc).__fastSpanFuncPtr =
                GENACCEL(gc).__fastFlatSpanFuncPtr;
	}
    }
    else
    {
	if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH)
        {
	    __GLfloat drAC;
	    __GLfloat drBC;
	    __GLcolor *ac, *bc, *cc;

            ac = a->color;
            bc = b->color;
	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;

            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;

	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;

            GENACCEL(gc).spanDelta.r =
                FLT_TO_FIX(gc->polygon.shader.drdx);

            if (GENACCEL(gc).spanDelta.r == 0)
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastFlatSpanFuncPtr;
            }
            else
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastSmoothSpanFuncPtr;
            }
	}
        else
        {
            GENACCEL(gc).spanValue.r =
                FLT_TO_FIX(gc->vertex.provoking->color->r);

            GENACCEL(gc).__fastSpanFuncPtr =
                GENACCEL(gc).__fastFlatSpanFuncPtr;
	}
    }

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER)
    {
	__GLfloat dzAC, dzBC;

        if ((gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) == 0)
        {
            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;
        }

	dzAC = a->window.z - c->window.z;
	dzBC = b->window.z - c->window.z;
	gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
	gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;
        GENACCEL(gc).spanDelta.z = gc->polygon.shader.dzdx =
            FTOL(gc->polygon.shader.dzdxf * GENACCEL(gc).zScale);
    }
    else if ((gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) == 0)
    {
        // In this case the divide hasn't been terminated yet so
        // we need to complete it even though we don't use the result
        __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
    }
#endif // _X86_
}


void FASTCALL __fastGenCalcDeltasTexRGBA(
    __GLcontext *gc,
    __GLvertex *a,
    __GLvertex *b,
    __GLvertex *c)
{
    __GLfloat oneOverArea, t1, t2, t3, t4;
    GLboolean oneOverAreaDone;

#if _X86_ && ENABLE_ASM

    LARGE_INTEGER temp;

    _asm{

    mov     edx, gc
    xor     eax, eax
    mov     oneOverAreaDone, al
    mov     edi, [OFFSET(SHADER.modeFlags)][edx]
    fld     __glOne
    fdiv    DWORD PTR [OFFSET(SHADER.area)][edx]
    mov     ebx, [OFFSET(GENGCACCEL.__fastTexSpanFuncPtr)][edx]
    test    edi, __GL_SHADE_TEXTURE
    mov     [OFFSET(GENGCACCEL.__fastSpanFuncPtr)][edx], ebx
    mov     eax, [OFFSET(__GLcontext.state.texture.env)][edx]
    je      notReplace
    mov     ebx, [OFFSET(__GLtextureEnvState.mode)][eax]
    cmp     ebx, GL_REPLACE
    je      fastReplace
    cmp     ebx, GL_DECAL
    jne     notReplace
    }

fastReplace:

        _asm{
        mov     eax, [OFFSET(GENGCACCEL.constantR)][edx]
        mov     ebx, [OFFSET(GENGCACCEL.constantG)][edx]
        mov     [OFFSET(SPANVALUE.r)][edx], eax
        mov     [OFFSET(SPANVALUE.g)][edx], ebx
        mov     eax, [OFFSET(GENGCACCEL.constantB)][edx]
        mov     ebx, [OFFSET(GENGCACCEL.constantA)][edx]
        mov     [OFFSET(SPANVALUE.b)][edx], eax
        mov     [OFFSET(SPANVALUE.a)][edx], ebx
        jmp     colorDone
        }

notReplace:

    _asm{
    test    edi, __GL_SHADE_SMOOTH
    je      doFlat
    mov     al, 1
    mov     oneOverAreaDone, al
    }

// smooth:

        _asm{

        mov     eax, a
        mov     ebx, b
        mov     ecx, c

        fstp    oneOverArea                         // finish divide

        fld     DWORD PTR [OFFSET(SHADER.dyAC)][edx]
        mov     eax, [OFFSET(__GLvertex.color)][eax]
        fmul    oneOverArea
        fld     DWORD PTR [OFFSET(SHADER.dyBC)][edx]
        mov     ebx, [OFFSET(__GLvertex.color)][ebx]
        fmul    oneOverArea                         // dyBC dyAC
        fld     DWORD PTR [OFFSET(SHADER.dxAC)][edx]
        mov     ecx, [OFFSET(__GLvertex.color)][ecx]
        fmul    oneOverArea                         // dxAC dyBC dyAC
        fxch    ST(1)                               // dyBC dxAC dyAC
        fld     DWORD PTR [OFFSET(SHADER.dxBC)][edx]
        fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
        fxch    ST(3)                               // dyAC dyBC dxAC dxBC
        fstp    t1
        fstp    t2
        fstp    t3
        fstp    t4

        // Now, calculate deltas:

            // Red

        fld     DWORD PTR [OFFSET(__GLcolor.r)][eax]
        fsub    DWORD PTR [OFFSET(__GLcolor.r)][ecx]
        fld     DWORD PTR [OFFSET(__GLcolor.r)][ebx]
        fsub    DWORD PTR [OFFSET(__GLcolor.r)][ecx]
                            // drBC drAC
        fld     ST(1)       // drAC drBC drAC
        fmul    t2          // drACt2 drBC drAC
        fld     ST(1)       // drBC drACt2 drBC drAC
        fmul    t1          // drBCt1 drACt2 drBC drAC
        fxch    ST(2)       // drBC drACt2 drBCt1 drAC
        fmul    t3          // drBCt3 drACt2 drBCt1 drAC
        fxch    ST(3)       // drAC drACt2 drBCt1 drBCt3
        fmul    t4          // drACt4 drACt2 drBCt1 drBCt3
        fxch    ST(2)       // drBCt1 drACt2 drACt4 drBCt3
        fsubp   ST(1), ST   // drACBC drACt4 drBCt3

        fld     DWORD PTR [OFFSET(__GLcolor.g)][ebx]
        fsub    DWORD PTR [OFFSET(__GLcolor.g)][ecx]
                            // dgBC drACBC drACt4 drBCt3
        fxch    ST(2)       // drACt4 drACBC dgBC drBCt3
        fsubp   ST(3), ST   // drACBC dgBC drBCAC
        fst     DWORD PTR [OFFSET(SHADER.drdx)][edx]
        fmul    __glVal65536
                            // DRACBC dgBC drBCAC
        fxch    ST(2)       // drBCAC dgBC DRACBC
        fstp    DWORD PTR [OFFSET(SHADER.drdy)][edx]
                            // dgBC DRACBC
        fld     DWORD PTR [OFFSET(__GLcolor.g)][eax]
        fsub    DWORD PTR [OFFSET(__GLcolor.g)][ecx]
                            // dgAC dgBC DRACBC
        fxch    ST(2)       // DRACBC dgBC dgAC
        fistp   DWORD PTR [OFFSET(SPANDELTA.r)][edx]

            // Green
                            // dgBC dgAC
        fld     ST(1)       // dgAC dgBC dgAC
        fmul    t2          // dgACt2 dgBC dgAC
        fld     ST(1)       // dgBC dgACt2 dgBC dgAC
        fmul    t1          // dgBCt1 dgACt2 dgBC dgAC
        fxch    ST(2)       // dgBC dgACt2 dgBCt1 dgAC
        fmul    t3          // dgBCt3 dgACt2 dgBCt1 dgAC
        fxch    ST(3)       // dgAC dgACt2 dgBCt1 dgBCt3
        fmul    t4          // dgACt4 dgACt2 dgBCt1 dgBCt3
        fxch    ST(2)       // dgBCt1 dgACt2 dgACt4 dgBCt3
        fsubp   ST(1), ST   // dgACBC dgACt4 dgBCt3

        fld     DWORD PTR [OFFSET(__GLcolor.b)][ebx]
        fsub    DWORD PTR [OFFSET(__GLcolor.b)][ecx]
                            // dbBC dgACBC dgACt4 dgBCt3
        fxch    ST(2)       // dgACt4 dgACBC dbBC dgBCt3
        fsubp   ST(3), ST   // dgACBC dbBC dgBCAC
        fst     DWORD PTR [OFFSET(SHADER.dgdx)][edx]
        fmul    __glVal65536
                            // DGACBC dbBC dgBCAC
        fxch    ST(2)       // dgBCAC dbBC DGACBC
        fstp    DWORD PTR [OFFSET(SHADER.dgdy)][edx]
                            // dbBC DGACBC
        fld     DWORD PTR [OFFSET(__GLcolor.b)][eax]
        fsub    DWORD PTR [OFFSET(__GLcolor.b)][ecx]
                            // dbAC dbBC DGACBC
        fxch    ST(2)       // DGACBC dbBC dbAC
        fistp   DWORD PTR [OFFSET(SPANDELTA.g)][edx]

            // Blue
                            // dbBC dbAC
        fld     ST(1)       // dbAC dbBC dbAC
        fmul    t2          // dbACt2 dbBC dbAC
        fld     ST(1)       // dbBC dbACt2 dbBC dbAC
        fmul    t1          // dbBCt1 dbACt2 dbBC dbAC
        fxch    ST(2)       // dbBC dbACt2 dbBCt1 dbAC
        fmul    t3          // dbBCt3 dbACt2 dbBCt1 dbAC
        fxch    ST(3)       // dbAC dbACt2 dbBCt1 dbBCt3
        fmul    t4          // dbACt4 dbACt2 dbBCt1 dbBCt3
        fxch    ST(2)       // dbBCt1 dbACt2 dbACt4 dbBCt3
        fsubp   ST(1), ST   // dbACBC dbACt4 dbBCt3
        fxch    ST(1)       // dbACt4 dbACBC dbBCt3
        fsubp   ST(2), ST   // dbACBC dbBCAC (+1)
        fst     DWORD PTR [OFFSET(SHADER.dbdx)][edx]
        fmul    __glVal65536
                            // DBACBC dbBCAC
        fxch    ST(1)       // dbBCAC DBACBC
        fstp    DWORD PTR [OFFSET(SHADER.dbdy)][edx]
        test    [OFFSET(__GLcontext.state.enables.general)][edx], __GL_BLEND_ENABLE
        fistp   DWORD PTR [OFFSET(SPANDELTA.b)][edx]

        je      colorDone

            fld     DWORD PTR [OFFSET(__GLcolor.a)][eax]
            fsub    DWORD PTR [OFFSET(__GLcolor.a)][ecx]
                                        // daAC
            fld     DWORD PTR [OFFSET(__GLcolor.a)][ebx]
            fsub    DWORD PTR [OFFSET(__GLcolor.a)][ecx]
                                        // daBC daAC
            fld     ST(1)               // daAC daBC daAC
            fmul    t2                  // daACt2 daBC daAC
            fld     ST(1)               // daBC daACt2 daBC daAC
            fmul    t1                  // daBCt1 daACt2 daBC daAC
            fxch    ST(3)               // daAC daACt2 daBC daBCt1
            fmul    t4                  // daACt4 daACt2 daBC daBCt1
            fxch    ST(2)               // daBC daACt2 daACt4 daBCt1
            fmul    t3                  // daBCt3 daACt2 daACt4 daBCt1

            fxch    ST(3)               // daBCt1 daACt2 daACt4 daBCt3
            fsubp   ST(1), ST           // daACBC daACt4 daBCt3
            fxch    ST(1)               // daACt4 daACBC daBCt3
            fsubp   ST(2), ST           // daACBC daBCAC (+1)
            fst     DWORD PTR [OFFSET(SHADER.dadx)][edx]
            fmul    DWORD PTR [OFFSET(GENGCACCEL.aAccelScale)][edx]
            fxch    ST(1)
            fstp    DWORD PTR [OFFSET(SHADER.dady)][edx]
            fistp   DWORD PTR [OFFSET(SPANDELTA.a)][edx] // (+1)
            #if !FORCE_NPX_DEBUG
            jmp     colorDone
            #endif
        }

        #if FORCE_NPX_DEBUG
        {
        __GLfloat drAC, dgAC, dbAC, daAC;
        __GLfloat drBC, dgBC, dbBC, daBC;
        __GLcolor *ac, *bc, *cc;
        __GLfloat ft1 = gc->polygon.shader.dyAC * oneOverArea;
        __GLfloat ft2 = gc->polygon.shader.dyBC * oneOverArea;
        __GLfloat ft3 = gc->polygon.shader.dxAC * oneOverArea;
        __GLfloat ft4 = gc->polygon.shader.dxBC * oneOverArea;
        __GLfloat drdx;
        __GLfloat drdy;
        __GLfloat dgdx;
        __GLfloat dgdy;
        __GLfloat dbdx;
        __GLfloat dbdy;
        LONG spanR, spanG, spanB;

        ac = a->color;
        bc = b->color;
        cc = c->color;

        drAC = ac->r - cc->r;
        drBC = bc->r - cc->r;
        dgAC = ac->g - cc->g;
        dgBC = bc->g - cc->g;
        dbAC = ac->b - cc->b;
        dbBC = bc->b - cc->b;

        drdx = drAC * t2 - drBC * t1;
        drdy = drBC * t3 - drAC * t4;
        dgdx = dgAC * t2 - dgBC * t1;
        dgdy = dgBC * t3 - dgAC * t4;
        dbdx = dbAC * t2 - dbBC * t1;
        dbdy = dbBC * t3 - dbAC * t4;

        spanR = FLT_TO_FIX(drdx);
        spanG = FLT_TO_FIX(dgdx);
        spanB = FLT_TO_FIX(dbdx);

        if (ft1 != t1)
            DbgPrint("t1 %f %f\n", t1, ft1);
        if (ft2 != t2)
            DbgPrint("t2 %f %f\n", t2, ft2);
        if (ft3 != t3)
            DbgPrint("t3 %f %f\n", t3, ft3);
        if (ft4 != t4)
            DbgPrint("t4 %f %f\n", t4, ft4);

        if (drdx != gc->polygon.shader.drdx)
            DbgPrint("drdx %f %f\n", drdx, gc->polygon.shader.drdx);
        if (drdy != gc->polygon.shader.drdy)
            DbgPrint("drdy %f %f\n", drdy, gc->polygon.shader.drdy);
        if (dgdx != gc->polygon.shader.dgdx)
            DbgPrint("dgdx %f %f\n", dgdx, gc->polygon.shader.dgdx);
        if (dgdy != gc->polygon.shader.dgdy)
            DbgPrint("dgdy %f %f\n", dgdy, gc->polygon.shader.dgdy);
        if (dbdx != gc->polygon.shader.dbdx)
            DbgPrint("dbdx %f %f\n", dbdx, gc->polygon.shader.dbdx);
        if (dbdy != gc->polygon.shader.dbdy)
            DbgPrint("dbdy %f %f\n", dbdy, gc->polygon.shader.dbdy);

        if (spanR != GENACCEL(gc).spanDelta.r)
            DbgPrint("spanDelta.r %x %x\n", spanR, GENACCEL(gc).spanDelta.r);
        if (spanG!= GENACCEL(gc).spanDelta.g)
            DbgPrint("spanDelta.g %x %x\n", spanG, GENACCEL(gc).spanDelta.g);
        if (spanB != GENACCEL(gc).spanDelta.b)
            DbgPrint("spanDelta.b %x %x\n", spanB, GENACCEL(gc).spanDelta.b);

        if (gc->state.enables.general & __GL_BLEND_ENABLE) {
            __GLfloat dadx;
            __GLfloat dady;
            LONG a;

            daAC = ac->a - cc->a;
            daBC = bc->a - cc->a;
            dadx = daAC * t2 - daBC * t1;
            dady = daBC * t3 - daAC * t4;

            a = FTOL(gc->polygon.shader.dadx * GENACCEL(gc).aAccelScale);

            if (dadx != gc->polygon.shader.dadx)
                DbgPrint("dadx %f %f\n", dadx, gc->polygon.shader.dadx);
            if (dady != gc->polygon.shader.dady)
                DbgPrint("dady %f %f\n", dady, gc->polygon.shader.dady);
            if (a != GENACCEL(gc).spanDelta.a)
                DbgPrint("spanDelta.a %x %x\n", a, GENACCEL(gc).spanDelta.a);
            }
        }
        _asm {
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        jmp     colorDone
        }
        #endif // FORCE_NPX_DEBUG

doFlat:
	_asm{

        mov     eax, [OFFSET(__GLcontext.vertex.provoking)][edx]

        fld     __glVal65536
        mov     eax, [OFFSET(__GLvertex.color)][eax]
        fmul    DWORD PTR [OFFSET(__GLcolor.r)][eax]
        fld     __glVal65536
        fmul    DWORD PTR [OFFSET(__GLcolor.g)][eax]
        mov     ebx, [OFFSET(__GLcontext.state.enables.general)][edx]
        fld     __glVal65536
        test    ebx, __GL_BLEND_ENABLE
        fmul    DWORD PTR [OFFSET(__GLcolor.b)][eax]

        je      noFlatBlend

        fld     DWORD PTR [OFFSET(GENGCACCEL.aAccelScale)][edx]
        fmul    DWORD PTR [OFFSET(__GLcolor.a)][eax]
                                                          // A B G R
        fxch    ST(3)                                     // R B G A
        fistp   DWORD PTR [OFFSET(SPANVALUE.r)][edx]
        fistp   DWORD PTR [OFFSET(SPANVALUE.b)][edx]
        fistp   DWORD PTR [OFFSET(SPANVALUE.g)][edx]
        fistp   DWORD PTR [OFFSET(SPANVALUE.a)][edx]
        jmp     short flatDone

noFlatBlend:
                                                          // B G R
        fxch    ST(2)                                     // R G B
        fistp   DWORD PTR [OFFSET(SPANVALUE.r)][edx]      // G B
        fistp   DWORD PTR [OFFSET(SPANVALUE.g)][edx]
        fistp   DWORD PTR [OFFSET(SPANVALUE.b)][edx]

flatDone:

        }

colorDone:

    _asm{
    test    edi, __GL_SHADE_TEXTURE
    mov     eax, [OFFSET(GENGCACCEL.texImage)][edx]
    je      texDone
    test    eax, eax
    je      texDone
    }

        _asm{
        mov     al, oneOverAreaDone
        mov     ebx, [OFFSET(__GLcontext.state.hints.perspectiveCorrection)][edx]
        test    al, al
        jne     areaDoneAlready
        }
            _asm{

            fstp    oneOverArea                         // finish divide

            fld     DWORD PTR [OFFSET(SHADER.dyAC)][edx]
            fmul    oneOverArea
            fld     DWORD PTR [OFFSET(SHADER.dyBC)][edx]
            fmul    oneOverArea                         // dyBC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxAC)][edx]
            fmul    oneOverArea                         // dxAC dyBC dyAC
            fxch    ST(1)                               // dyBC dxAC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxBC)][edx]
            fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
            fxch    ST(3)                               // dyAC dyBC dxAC dxBC
            fstp    t1
            inc     eax
            fstp    t2
            mov     oneOverAreaDone, al
            fstp    t3
            fstp    t4
            }

areaDoneAlready:

        _asm{
        cmp     ebx, GL_NICEST
        je      doNicest
        }
            _asm{
            mov     eax, a
            mov     ecx, c
            mov     ebx, b

            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][eax]
            fsub    DWORD PTR [OFFSET(__GLvertex.texture.x)][ecx]
                                    // dsAC
            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][ebx]
            fsub    DWORD PTR [OFFSET(__GLvertex.texture.x)][ecx]
                                    // dsBC dsAC

            fld     ST(1)           // dsAC dsBC dsAC
            fmul    t2
            fxch    ST(2)           // dsAC dsBC dsACt2
            fmul    t4              // dsACt4 dsBC dsACt2
            fld     ST(1)           // dsBC dsACt4 dsBC dsACt2
            fmul    t1              // dsBCt1 dsACt4 dsBC dsACt2
            fxch    ST(2)           // dsBC dsACt4 dsBCt1 dsACt2
            fmul    t3              // dsBCt3 dsACt4 dsBCt1 dsACt2
            fxch    ST(2)           // dsBCt1 dsACt4 dsBCt3 dsACt2
            fsubp   ST(3), ST       // dsACt4 dsBCt3 dsACBC

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][ebx]
            fsub    DWORD PTR [OFFSET(__GLvertex.texture.y)][ecx]
                                    // dtBC dsACt4 dsBCt3 dsACBC
            fxch    ST(1)           // dsACt4 dtBC dsBCt3 dsACBC
            fsubp   ST(2), ST       // dtBC dsBCAC dsACBC
            fxch    ST(2)           // dsACBC dsBCAC dtBC
            fst     DWORD PTR [OFFSET(SHADER.dsdx)][edx]
                                    // dsdx dsBCAC dtBC

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][eax]
            fsub    DWORD PTR [OFFSET(__GLvertex.texture.y)][ecx]
                                    // dtAC dsdx dsBCAC dtBC
            fxch    ST(2)           // dsBCAC dsdx dtAC dtBC
            fstp    DWORD PTR [OFFSET(SHADER.dsdy)][edx]
                                    // dsdx dtAC dtBC

            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]

                                    // deltaS dtAC dtBC
            fxch    ST(2)           // dtBC dtAC deltaS
            fld     ST(1)           // dtAC dtBC dtAC deltaS
            fmul    t2              // dtACt2 dtBC dtAC deltaS
            fxch    ST(2)           // dtAC dtBC dtACt2 deltaS
            fmul    t4              // dtACt4 dtBC dtACt2 deltaS
            fld     ST(1)           // dtBC dtACt4 dtBC dtACt2 deltaS
            fmul    t1              // dtBCt1 dtACt4 dtBC dtACt2 deltaS
            fxch    ST(2)           // dtBC dtACt4 dtBCt1 dtACt2 deltaS
            fmul    t3              // dtBCt3 dtACt4 dtBCt1 dtACt2 deltaS
            fxch    ST(2)           // dtBCt1 dtACt4 dtBCt3 dtACt2 deltaS
            fsubp   ST(3), ST       // dtACt4 dtBCt3 dtACBC deltaS

            fxch    ST(3)           // deltaS dtBCt3 dtACBC dtACt4
            fistp   DWORD PTR [OFFSET(SPANDELTA.s)][edx]
                                    // dtBCt3 dtACBC dtACt4

            fsubrp  ST(2), ST       // dtACBC dtBCAC
            fst     DWORD PTR [OFFSET(SHADER.dtdx)][edx]
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]
            fxch    ST(1)           // dtBCAC deltaT
            fstp    DWORD PTR [OFFSET(SHADER.dtdy)][edx]
            mov     eax, [OFFSET(SPANDELTA.s)][edx]
            fistp   DWORD PTR [OFFSET(SPANDELTA.t)][edx]

            shl     eax, TEX_SUBDIV_LOG2
            mov     ebx, [OFFSET(SPANDELTA.t)][edx]
            shl     ebx, TEX_SUBDIV_LOG2
            mov     [OFFSET(GENGCACCEL.sStepX)][edx], eax
            mov     [OFFSET(GENGCACCEL.tStepX)][edx], ebx


            #if !FORCE_NPX_DEBUG
            jmp     texDone
            #endif
            }

            #if FORCE_NPX_DEBUG
            {
            __GLfloat awinv, bwinv, cwinv, scwinv, tcwinv, qwcwinv;
            __GLfloat dsAC, dsBC, dtAC, dtBC, dqwAC, dqwBC;
            __GLfloat dsdx, dsdy;
            __GLfloat dtdx, dtdy;
            LONG spanDeltaS, spanDeltaT;

            dsAC = a->texture.x - c->texture.x;
            dsBC = b->texture.x - c->texture.x;
            dsdx = dsAC * t2 - dsBC * t1;
            dsdy = dsBC * t3 - dsAC * t4;
            dtAC = a->texture.y - c->texture.y;
            dtBC = b->texture.y - c->texture.y;
            dtdx = dtAC * t2 - dtBC * t1;
            dtdy = dtBC * t3 - dtAC * t4;

            spanDeltaS = FTOL(dsdx * GENACCEL(gc).texXScale);
            spanDeltaT = FTOL(dtdx * GENACCEL(gc).texYScale);

            if (gc->polygon.shader.dsdx != dsdx)
                DbgPrint("dsdx %f %f\n", dsdx, gc->polygon.shader.dsdx);
            if (gc->polygon.shader.dsdy != dsdy)
                DbgPrint("dsdy %f %f\n", dsdy, gc->polygon.shader.dsdy);

            if (gc->polygon.shader.dtdx != dtdx)
                DbgPrint("dtdx %f %f\n", dtdx, gc->polygon.shader.dtdx);
            if (gc->polygon.shader.dtdy != dtdy)
                DbgPrint("dtdy %f %f\n", dtdy, gc->polygon.shader.dtdy);

            if (spanDeltaS != GENACCEL(gc).spanDelta.s)
                DbgPrint("spanDelta.s %x %x\n", spanDeltaS, GENACCEL(gc).spanDelta.s);
            if (spanDeltaT != GENACCEL(gc).spanDelta.t)
                DbgPrint("spanDelta.t %x %x\n", spanDeltaT, GENACCEL(gc).spanDelta.t);

            }
            _asm {
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            jmp     texDone
            }
            #endif // FORCE_NPX_DEBUG

doNicest:

// LATER - remove store/read of dsdx, dydx

            _asm{
            mov     ecx, c
            mov     ebx, b
            mov     eax, a

            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][ecx]   // sc
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ecx]
            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]    // dsA sc
            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][ebx]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ebx]
                                    // dsB dsA sc
            fxch    ST(2)           // sc dsA dsB

            fsub    ST(1), ST       // sc dsAC dsB

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][ecx]   // tcwinv
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ecx]
                                    // tc sc dsAC dsB

            fxch    ST(1)           // sc tc dsAC dsB
            fsubp   ST(3), ST       // tc dsAC dsBC
            fxch    ST(2)           // dsBC dsAC tc

            fld     ST(1)           // dsAC dsBC dsAC tc
            fmul    t2
            fxch    ST(2)           // dsAC dsBC dsACt2 tc
            fmul    t4              // dsACt4 dsBC dsACt2 tc
            fld     ST(1)           // dsBC dsACt4 dsBC dsACt2 tc
            fmul    t1              // dsBCt1 dsACt4 dsBC dsACt2 tc
            fxch    ST(2)           // dsBC dsACt4 dsBCt1 dsACt2 tc
            fmul    t3              // dsBCt3 dsACt4 dsBCt1 dsACt2 tc
            fxch    ST(2)           // dsBCt1 dsACt4 dsBCt3 dsACt2 tc
            fsubp   ST(3), ST       // dsACt4 dsBCt3 dsACBC tc

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]
                                    // dtA dsACt4 dsBCt3 dsACBC tc
            fxch    ST(1)           // dsACt4 dtA dsBCt3 dsACBC tc
            fsubp   ST(2), ST       // dtA dsBCAC dsACBC tc
            fxch    ST(2)           // dsACBC dsBCAC dtA tc
            fstp    DWORD PTR [OFFSET(SHADER.dsdx)][edx]
                                    // dsBCAC dtA tc

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][ebx]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ebx]
                                    // dtB dsBCAC dtA tc
            fxch    ST(1)           // dsBCAC dtB dtA tc
            fstp    DWORD PTR [OFFSET(SHADER.dsdy)][edx]
                                    // dtB dtA tc

            fxch    ST(2)           // tc dtA dtB
            fsub    ST(1), ST       // tc dtAC dtB
            fsubp   ST(2), ST       // dtAC dtBC

            fld     DWORD PTR [OFFSET(__GLvertex.texture.w)][ecx]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ecx]
                                    // qw dtAC dtBC
            fxch    ST(2)           // dtBC dtAC qw
            fld     ST(1)           // dtAC dtBC dtAC qw
            fmul    t2              // dtACt2 dtBC dtAC qw
            fxch    ST(2)           // dtAC dtBC dtACt2 qw
            fmul    t4              // dtACt4 dtBC dtACt2 qw
            fld     ST(1)           // dtBC dtACt4 dtBC dtACt2 qw
            fmul    t1              // dtBCt1 dtACt4 dtBC dtACt2 qw
            fxch    ST(2)           // dtBC dtACt4 dtBCt1 dtACt2 qw
            fmul    t3              // dtBCt3 dtACt4 dtBCt1 dtACt2 qw
            fxch    ST(2)           // dtBCt1 dtACt4 dtBCt3 dtACt2 qw
            fsubp   ST(3), ST       // dtACt4 dtBCt3 dtACBC qw

            fld     DWORD PTR [OFFSET(__GLvertex.texture.w)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]
                                    // dqA dtACt4 dtBCt3 dtACBC qw

            fxch    ST(1)           // dtACt4 dqA dtBCt3 dtACBC qw
            fsubp   ST(2), ST       // dqA dtBCAC dtACBC qw
            fxch    ST(2)           // dtACBC dtBCAC dqA qw
            fstp    DWORD PTR [OFFSET(SHADER.dtdx)][edx]
                                    // dsBCAC dqA qw
            fld     DWORD PTR [OFFSET(__GLvertex.texture.w)][ebx]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ebx]
                                    // dqB dsBCAC dqA qw

            fxch    ST(3)           // qw dsBCAC dqA dqB
            fsub    ST(2), ST       // qw dsBCAC dqAC dqB
            fxch    ST(1)           // dsBCAC qw dqAC dqB
            fstp    DWORD PTR [OFFSET(SHADER.dtdy)][edx]
                                    // qw dqAC dqB
            fsubp   ST(2), ST       // dqAC dqBC
            fxch    ST(1)           // dqBC dqAC

            fld     ST(1)           // dqAC dqBC dqAC
            fmul    t2              // dqACt2 dqBC dqAC
            fxch    ST(2)           // dqAC dqBC dqACt2
            fmul    t4              // dqACt4 dqBC dqACt2
            fld     ST(1)           // dqBC dqACt4 dqBC dqACt2
            fmul    t1              // dqBCt1 dqACt4 dqBC dqACt2
            fxch    ST(2)           // dqBC dqACt4 dqBCt1 dqACt2
            fmul    t3              // dqBCt3 dqACt4 dqBCt1 dqACt2
            fxch    ST(2)           // dqBCt1 dqACt4 dqBCt3 dqACt2
            fsubp   ST(3), ST       // dqACt4 dqBCt3 dqACBC
            fxch    ST(2)           // dqACBC dqBCt3 dqACt4

            fld     DWORD PTR [OFFSET(SHADER.dsdx)][edx]
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]
                                    // deltaS dqACBC dqBCt3 dqACt4

            fxch    ST(3)           // dqACt4 dqACBC dqBCt3 deltaS
            fsubp   ST(2), ST       // dqACBC dqBCAC deltaS

            fld     DWORD PTR [OFFSET(SHADER.dtdx)][edx]
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]
                                    // deltaT dqACBC dqBCAC deltaS
            fld     __glTexSubDiv
            fmul    ST, ST(2)
                                    // qwStep deltaT dqACBC dqBCAC deltaS
            fxch    ST(4)           // deltaS deltaT dqACBC dqBCAC qwStep
            fistp   DWORD PTR [OFFSET(SPANDELTA.s)][edx]
            fistp   DWORD PTR [OFFSET(SPANDELTA.t)][edx]
                                    // dqACBC dqBCAC qwStep
            fstp    DWORD PTR [OFFSET(SHADER.dqwdx)][edx]
            fstp    DWORD PTR [OFFSET(SHADER.dqwdy)][edx]
            mov     eax, [OFFSET(SPANDELTA.s)][edx]
            fstp    DWORD PTR [OFFSET(GENGCACCEL.qwStepX)][edx]

            shl     eax, TEX_SUBDIV_LOG2
            mov     ebx, [OFFSET(SPANDELTA.t)][edx]
            shl     ebx, TEX_SUBDIV_LOG2
            mov     [OFFSET(GENGCACCEL.sStepX)][edx], eax
            mov     [OFFSET(GENGCACCEL.tStepX)][edx], ebx

            }

            #if FORCE_NPX_DEBUG
            {
            __GLfloat awinv, bwinv, cwinv, scwinv, tcwinv, qwcwinv;
            __GLfloat dsAC, dsBC, dtAC, dtBC, dqwAC, dqwBC;
            __GLfloat dsdx, dsdy;
            __GLfloat dtdx, dtdy;
            __GLfloat dqwdx, dqwdy;
            __GLfloat qwStepX;
            LONG spanDeltaS, spanDeltaT;

            awinv = a->window.w;
            bwinv = b->window.w;
            cwinv = c->window.w;
            scwinv = c->texture.x * cwinv;
            tcwinv = c->texture.y * cwinv;
            qwcwinv = c->texture.w * cwinv;

            dsAC = a->texture.x * awinv - scwinv;
            dsBC = b->texture.x * bwinv - scwinv;
            dsdx = dsAC * t2 - dsBC * t1;
            dsdy = dsBC * t3 - dsAC * t4;

            dtAC = a->texture.y * awinv - tcwinv;
            dtBC = b->texture.y * bwinv - tcwinv;
            dtdx = dtAC * t2 - dtBC * t1;
            dtdy = dtBC * t3 - dtAC * t4;

            dqwAC = a->texture.w * awinv - qwcwinv;
            dqwBC = b->texture.w * bwinv - qwcwinv;
            dqwdx = dqwAC * t2 - dqwBC * t1;
            dqwdy = dqwBC * t3 - dqwAC * t4;

            spanDeltaS = FTOL(dsdx * GENACCEL(gc).texXScale);
            spanDeltaT = FTOL(dtdx * GENACCEL(gc).texYScale);

            qwStepX = (gc->polygon.shader.dqwdx * (__GLfloat)TEX_SUBDIV);

            if (gc->polygon.shader.dsdx != dsdx)
                DbgPrint("dsdx %f %f\n", dsdx, gc->polygon.shader.dsdx);
            if (gc->polygon.shader.dsdy != dsdy)
                DbgPrint("dsdy %f %f\n", dsdy, gc->polygon.shader.dsdy);

            if (gc->polygon.shader.dtdx != dtdx)
                DbgPrint("dtdx %f %f\n", dtdx, gc->polygon.shader.dtdx);
            if (gc->polygon.shader.dtdy != dtdy)
                DbgPrint("dtdy %f %f\n", dtdy, gc->polygon.shader.dtdy);

            if (gc->polygon.shader.dqwdx != dqwdx)
                DbgPrint("dqdx %f %f\n", dqwdx, gc->polygon.shader.dqwdx);
            if (gc->polygon.shader.dqwdy != dqwdy)
                DbgPrint("dqdy %f %f\n", dqwdy, gc->polygon.shader.dqwdy);

            if (spanDeltaS != GENACCEL(gc).spanDelta.s)
                DbgPrint("spanDelta.s %x %x\n", spanDeltaS, GENACCEL(gc).spanDelta.s);
            if (spanDeltaT != GENACCEL(gc).spanDelta.t)
                DbgPrint("spanDelta.t %x %x\n", spanDeltaT, GENACCEL(gc).spanDelta.t);

            if (qwStepX != GENACCEL(gc).qwStepX)
                DbgPrint("qwStepX %f %f\n", qwStepX, GENACCEL(gc).qwStepX);
            }
            _asm {
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            }
            #endif // FORCE_NPX_DEBUG
texDone:

    _asm{
    test    edi, __GL_SHADE_DEPTH_ITER
    je      noZ
    mov     al, oneOverAreaDone
    test    al, al
    jne     areaDoneAlready2
    }

        _asm{

        fstp    oneOverArea                         // finish divide

        fld     DWORD PTR [OFFSET(SHADER.dyAC)][edx]
        fmul    oneOverArea
        fld     DWORD PTR [OFFSET(SHADER.dyBC)][edx]
        fmul    oneOverArea                         // dyBC dyAC
        fld     DWORD PTR [OFFSET(SHADER.dxAC)][edx]
        fmul    oneOverArea                         // dxAC dyBC dyAC
        fxch    ST(1)                               // dyBC dxAC dyAC
        fld     DWORD PTR [OFFSET(SHADER.dxBC)][edx]
        fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
        fxch    ST(3)                               // dyAC dyBC dxAC dxBC
        fstp    t1
        inc     eax
        fstp    t2
        mov     oneOverAreaDone, al
        fstp    t3
        fstp    t4
        }

areaDoneAlready2:

        _asm{

        mov     ecx, c
        mov     eax, a
        mov     ebx, b

        fld     DWORD PTR [OFFSET(__GLvertex.window.z)][eax]
        fsub    DWORD PTR [OFFSET(__GLvertex.window.z)][ecx]
        fld     DWORD PTR [OFFSET(__GLvertex.window.z)][ebx]
        fsub    DWORD PTR [OFFSET(__GLvertex.window.z)][ecx]
                                                        // dzBC dzAC
        fld     ST(1)                                   // dzAC dzBC dzAC
        fmul    t2                                      // ACt2 dzBC dzAC
        fld     ST(1)                                   // dzBC ACt2 dzBC dzAC
        fmul    t1                                      // BCt1 ACt2 dzBC dzAC
        fxch    ST(3)                                   // dzAC ACt2 dzBC BCt1
        fmul    t4                                      // ACt4 ACt2 dzBC BCt1
        fxch    ST(2)                                   // dzBC ACt2 ACt4 BCt1
        fmul    t3                                      // BCt3 ACt2 ACt4 BCt1
        fsubrp  ST(2),ST                                // ACt2 BCAC BCt1
        fsubrp  ST(2),ST                                // BCAC ACBC
        fxch    ST(1)                                   // ACBC BCAC
                                                        // dzdx dzdy
        fld     ST(0)                                   // dzdx dzdx dzdy
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                                                        // dzdxS dzdx dzdy
        fxch    ST(2)                                   // dzdy dzdx dzdxS
        fstp    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
        fstp    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
        fistp   temp
        mov     ebx, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.dzdx)][edx], ebx
        mov     DWORD PTR [OFFSET(SPANDELTA.z)][edx], ebx
        #if !FORCE_NPX_DEBUG
        jmp     deltaDone
        #endif
        }

        #if FORCE_NPX_DEBUG
        {
	__GLfloat dzAC, dzBC;
        __GLfloat dzdxf;
        __GLfloat dzdyf;
        ULONG spanDeltaZ;

        dzAC = a->window.z - c->window.z;
        dzBC = b->window.z - c->window.z;

        dzdxf = dzAC * t2 - dzBC * t1;
        dzdyf = dzBC * t3 - dzAC * t4;
        spanDeltaZ = FTOL(dzdxf * GENACCEL(gc).zScale);

        if (dzdxf != gc->polygon.shader.dzdxf)
            DbgPrint("dzdxf %f %f\n", dzdxf, gc->polygon.shader.dzdxf);
        if (dzdyf != gc->polygon.shader.dzdyf)
            DbgPrint("dzdyf %f %f\n", dzdyf, gc->polygon.shader.dzdyf);

        if (spanDeltaZ != GENACCEL(gc).spanDelta.z)
            DbgPrint("spanDeltaZ %x %x\n", spanDeltaZ, GENACCEL(gc).spanDelta.z);
        }
        #endif // FORCE_NPX_DEBUG

noZ:

    _asm{
    mov     al, oneOverAreaDone
    test    al, al
    jne     deltaDone
    fstp    ST(0)
    }

deltaDone:
    return;

#else

    /* Pre-compute one over polygon area */

    __GL_FLOAT_BEGIN_DIVIDE(__glOne, gc->polygon.shader.area, &oneOverArea);
    oneOverAreaDone = GL_FALSE;

    /*
    ** Compute delta values for unit changes in x or y for each
    ** parameter.
    */

    GENACCEL(gc).__fastSpanFuncPtr = GENACCEL(gc).__fastTexSpanFuncPtr;

    if ((gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) &&
        ((gc->state.texture.env[0].mode == GL_REPLACE) ||
         (gc->state.texture.env[0].mode == GL_DECAL))) {

        GENACCEL(gc).spanValue.r = GENACCEL(gc).constantR;
        GENACCEL(gc).spanValue.g = GENACCEL(gc).constantG;
        GENACCEL(gc).spanValue.b = GENACCEL(gc).constantB;
        GENACCEL(gc).spanValue.a = GENACCEL(gc).constantA;

    } else if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
        __GLfloat drAC, dgAC, dbAC, daAC;
        __GLfloat drBC, dgBC, dbBC, daBC;
        __GLcolor *ac, *bc, *cc;

        oneOverAreaDone = GL_TRUE;

        ac = a->color;
        bc = b->color;
        cc = c->color;

        drAC = ac->r - cc->r;
        drBC = bc->r - cc->r;
        dgAC = ac->g - cc->g;
        dgBC = bc->g - cc->g;
        dbAC = ac->b - cc->b;
        dbBC = bc->b - cc->b;

        __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
        t1 = gc->polygon.shader.dyAC * oneOverArea;
        t2 = gc->polygon.shader.dyBC * oneOverArea;
        t3 = gc->polygon.shader.dxAC * oneOverArea;
        t4 = gc->polygon.shader.dxBC * oneOverArea;

        gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
        gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
        gc->polygon.shader.dgdx = dgAC * t2 - dgBC * t1;
        gc->polygon.shader.dgdy = dgBC * t3 - dgAC * t4;
        gc->polygon.shader.dbdx = dbAC * t2 - dbBC * t1;
        gc->polygon.shader.dbdy = dbBC * t3 - dbAC * t4;

        GENACCEL(gc).spanDelta.r = FLT_TO_FIX(gc->polygon.shader.drdx);
        GENACCEL(gc).spanDelta.g = FLT_TO_FIX(gc->polygon.shader.dgdx);
        GENACCEL(gc).spanDelta.b = FLT_TO_FIX(gc->polygon.shader.dbdx);

        if (gc->state.enables.general & __GL_BLEND_ENABLE) {
            daAC = ac->a - cc->a;
	    daBC = bc->a - cc->a;
	    gc->polygon.shader.dadx = daAC * t2 - daBC * t1;
	    gc->polygon.shader.dady = daBC * t3 - daAC * t4;
            GENACCEL(gc).spanDelta.a =
                FTOL(gc->polygon.shader.dadx * GENACCEL(gc).aAccelScale);
        }

#ifdef GENERIC_CAN_BLEND
//!! Note: this is not enabled in the assembly code above

        if (   ((GENACCEL(gc).spanDelta.r | GENACCEL(gc).spanDelta.g | GENACCEL(gc).spanDelta.b) == 0)
            && ((GENACCEL(gc).flags & GEN_FASTZBUFFER) == 0)
           ) {
            GENACCEL(gc).__fastSpanFuncPtr = GENACCEL(gc).__fastFlatSpanFuncPtr;
        } else {
            GENACCEL(gc).__fastSpanFuncPtr = GENACCEL(gc).__fastSmoothSpanFuncPtr;
        }
#endif
    } else {

        __GLcolor *flatColor = gc->vertex.provoking->color;

        GENACCEL(gc).spanValue.r = FLT_TO_FIX(flatColor->r);
        GENACCEL(gc).spanValue.g = FLT_TO_FIX(flatColor->g);
        GENACCEL(gc).spanValue.b = FLT_TO_FIX(flatColor->b);
        if (gc->state.enables.general & __GL_BLEND_ENABLE)
            GENACCEL(gc).spanValue.a = FTOL(flatColor->a * GENACCEL(gc).aAccelScale);
#ifdef GENERIC_CAN_BLEND
//!! Note: this is not enabled in the assembly code above
        GENACCEL(gc).__fastSpanFuncPtr = GENACCEL(gc).__fastFlatSpanFuncPtr;
#endif
    }

    if ((gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) && (GENACCEL(gc).texImage)) {
        __GLfloat awinv, bwinv, cwinv, scwinv, tcwinv, qwcwinv;
        __GLfloat dsAC, dsBC, dtAC, dtBC, dqwAC, dqwBC;

#ifdef GENERIC_CAN_BLEND
        GENACCEL(gc).__fastSpanFuncPtr = GENACCEL(gc).__fastTexSpanFuncPtr;
#endif

        if (!oneOverAreaDone)
        {
            oneOverAreaDone = GL_TRUE;
            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;
        }

        if (gc->state.hints.perspectiveCorrection != GL_NICEST) {
            dsAC = a->texture.x - c->texture.x;
            dsBC = b->texture.x - c->texture.x;
            gc->polygon.shader.dsdx = dsAC * t2 - dsBC * t1;
            gc->polygon.shader.dsdy = dsBC * t3 - dsAC * t4;
            dtAC = a->texture.y - c->texture.y;
            dtBC = b->texture.y - c->texture.y;
            gc->polygon.shader.dtdx = dtAC * t2 - dtBC * t1;
            gc->polygon.shader.dtdy = dtBC * t3 - dtAC * t4;

            GENACCEL(gc).spanDelta.s =
                FTOL(gc->polygon.shader.dsdx * GENACCEL(gc).texXScale);

            GENACCEL(gc).spanDelta.t =
                FTOL(gc->polygon.shader.dtdx * GENACCEL(gc).texYScale);
            GENACCEL(gc).sStepX = (GENACCEL(gc).spanDelta.s * TEX_SUBDIV);
            GENACCEL(gc).tStepX = (GENACCEL(gc).spanDelta.t * TEX_SUBDIV);

        } else {
            awinv = a->window.w;
            bwinv = b->window.w;
            cwinv = c->window.w;
            scwinv = c->texture.x * cwinv;
            tcwinv = c->texture.y * cwinv;
            qwcwinv = c->texture.w * cwinv;

            dsAC = a->texture.x * awinv - scwinv;
            dsBC = b->texture.x * bwinv - scwinv;
            gc->polygon.shader.dsdx = dsAC * t2 - dsBC * t1;
            gc->polygon.shader.dsdy = dsBC * t3 - dsAC * t4;

            dtAC = a->texture.y * awinv - tcwinv;
            dtBC = b->texture.y * bwinv - tcwinv;
            gc->polygon.shader.dtdx = dtAC * t2 - dtBC * t1;
            gc->polygon.shader.dtdy = dtBC * t3 - dtAC * t4;

            dqwAC = a->texture.w * awinv - qwcwinv;
            dqwBC = b->texture.w * bwinv - qwcwinv;
            gc->polygon.shader.dqwdx = dqwAC * t2 - dqwBC * t1;
            gc->polygon.shader.dqwdy = dqwBC * t3 - dqwAC * t4;

            GENACCEL(gc).spanDelta.s = FTOL(gc->polygon.shader.dsdx * GENACCEL(gc).texXScale);
            GENACCEL(gc).spanDelta.t = FTOL(gc->polygon.shader.dtdx * GENACCEL(gc).texYScale);

            GENACCEL(gc).qwStepX = (gc->polygon.shader.dqwdx * (__GLfloat)TEX_SUBDIV);
            GENACCEL(gc).sStepX = (GENACCEL(gc).spanDelta.s * TEX_SUBDIV);
            GENACCEL(gc).tStepX = (GENACCEL(gc).spanDelta.t * TEX_SUBDIV);
        }
    }

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
	__GLfloat dzAC, dzBC;

        if (!oneOverAreaDone) {
            oneOverAreaDone = GL_TRUE;

            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;
        }

	dzAC = a->window.z - c->window.z;
	dzBC = b->window.z - c->window.z;
	gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
	gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;
        GENACCEL(gc).spanDelta.z = gc->polygon.shader.dzdx =
            FTOL(gc->polygon.shader.dzdxf * GENACCEL(gc).zScale);
    }

    if (!oneOverAreaDone)
    {
        // In this case the divide hasn't been terminated yet so
        // we need to complete it even though we don't use the result
        __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
    }
#endif // _X86_
}


/**************************************************************************\
\**************************************************************************/

void FASTCALL __fastGenFillTriangle(
    __GLcontext *gc,
    __GLvertex *a,
    __GLvertex *b,
    __GLvertex *c,
    GLboolean ccw)
{
    GLint aIY, bIY, cIY;
    __GLfloat dxdyAC, dxdyBC, dxdyBA;
    __GLfloat dx, dy;
    __GLfloat invDyAB, invDyBC, invDyAC;

    #if DBG && CHECK_FPU
    {
        USHORT cw;

        __asm {
            _asm fnstcw   cw
            _asm mov     ax, cw
            _asm and     ah, (~0x3f)
            _asm mov     cw,ax
            _asm fldcw   cw
        }
    }
    #endif

    //
    // Snap each y coordinate to its pixel center
    //

    aIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(a->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    cIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(c->window.y)+
                                   __GL_VERTEX_FRAC_HALF);

    if (aIY == cIY) {
        return;
    }

    bIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(b->window.y)+
                                   __GL_VERTEX_FRAC_HALF);

    if (cIY - aIY > __GL_MAX_INV_TABLE)
        goto bigTriangle;

    gc->polygon.shader.cfb = gc->drawBuffer;

    CASTFIX(invDyAB) = CASTFIX(invTable[CASTFIX(b->window.y) - CASTFIX(a->window.y)]) | 0x80000000;
    CASTFIX(invDyBC) = CASTFIX(invTable[CASTFIX(c->window.y) - CASTFIX(b->window.y)]) | 0x80000000;
    CASTFIX(invDyAC) = CASTFIX(invTable[CASTFIX(c->window.y) - CASTFIX(a->window.y)]) | 0x80000000;

    //
    // Calculate delta values for unit changes in x or y
    //

    GENACCEL(gc).__fastCalcDeltaPtr(gc, a, b, c);

    //
    // calculate the destination address
    //

    GENACCEL(gc).pPix =
          (BYTE *)gc->polygon.shader.cfb->buf.base
        + (  gc->polygon.shader.cfb->buf.outerWidth
           * (
                aIY
              - gc->constants.viewportYAdjust
              + gc->polygon.shader.cfb->buf.yOrigin
             )
          )
        + (  GENACCEL(gc).xMultiplier
           * (
              - gc->constants.viewportXAdjust
              + gc->polygon.shader.cfb->buf.xOrigin
             )
          );

    // Calculate destination Z
    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
    {
        if ( gc->modes.depthBits == 32 )
        {
            gc->polygon.shader.zbuf =
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                0, aIY);
        }
        else
        {
            gc->polygon.shader.zbuf = (__GLzValue *)
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                0, aIY);
        }
    }

    /*
    ** This algorithm always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */

    if (ccw)
    {
	dy = (aIY + __glHalf) - a->window.y;

        dxdyAC = gc->polygon.shader.dxAC * invDyAC;

	GenSnapXLeft(gc, a->window.x + dy*dxdyAC, dxdyAC);

	dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;

	GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) * invDyAB;

	    GenSnapXRight(gc, a->window.x + dy*dxdyBA, dxdyBA);

            if (bIY == cIY)
                gc->polygon.shader.modeFlags |= __GL_SHADE_LAST_SUBTRI;

            GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

            if (bIY != cIY)
            {
                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
	}

        if (bIY != cIY)
        {

	    dy = (bIY + __glHalf) - b->window.y;

	    dxdyBC = (b->window.x - c->window.x) * invDyBC;

	    GenSnapXRight(gc, b->window.x + dy*dxdyBC, dxdyBC);

            gc->polygon.shader.modeFlags |= __GL_SHADE_LAST_SUBTRI;

            GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }
    else
    {

	dy = (aIY + __glHalf) - a->window.y;

        dxdyAC = gc->polygon.shader.dxAC * invDyAC;

	GenSnapXRight(gc, a->window.x + dy*dxdyAC, dxdyAC);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) * invDyAB;

	    GenSnapXLeft(gc, a->window.x + dy*dxdyBA, dxdyBA);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

            if (bIY == cIY)
                gc->polygon.shader.modeFlags |= __GL_SHADE_LAST_SUBTRI;

            GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

            if (bIY != cIY)
            {
                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
	}

	if (bIY != cIY)
        {
	    dy = (bIY + __glHalf) - b->window.y;

            dxdyBC = gc->polygon.shader.dxBC * invDyBC;

	    GenSnapXLeft(gc, b->window.x + dy*dxdyBC, dxdyBC);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, b, dx, dy);

            gc->polygon.shader.modeFlags |= __GL_SHADE_LAST_SUBTRI;

            GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }

    gc->polygon.shader.modeFlags &= ~(__GL_SHADE_LAST_SUBTRI);

    return;

bigTriangle:

    __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxAC,
                            gc->polygon.shader.dyAC,
                            &dxdyAC);

    gc->polygon.shader.cfb = gc->drawBuffer;

    //
    // Calculate delta values for unit changes in x or y
    //

    GENACCEL(gc).__fastCalcDeltaPtr(gc, a, b, c);

    //
    // calculate the destination address
    //

    GENACCEL(gc).pPix =
          (BYTE *)gc->polygon.shader.cfb->buf.base
        + (  gc->polygon.shader.cfb->buf.outerWidth
           * (
                aIY
              - gc->constants.viewportYAdjust
              + gc->polygon.shader.cfb->buf.yOrigin
             )
          )
        + (  GENACCEL(gc).xMultiplier
           * (
              - gc->constants.viewportXAdjust
              + gc->polygon.shader.cfb->buf.xOrigin
             )
          );

    // Calculate destination Z
    if ((gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) &&
        aIY != bIY)
    {
        if ( gc->modes.depthBits == 32 )
        {
            gc->polygon.shader.zbuf =
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                0, aIY);
        }
        else
        {
            gc->polygon.shader.zbuf = (__GLzValue *)
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                0, aIY);
        }
    }

    /*
    ** This algorithm always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */

    if (ccw)
    {
	dy = (aIY + __glHalf) - a->window.y;

        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);

	GenSnapXLeft(gc, a->window.x + dy*dxdyAC, dxdyAC);

	dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
	GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) /
                (a->window.y - b->window.y);
	    GenSnapXRight(gc, a->window.x + dy*dxdyBA, dxdyBA);

            if (bIY != cIY)
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

                __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                        gc->polygon.shader.dyBC,
                                        &dxdyBC);

                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
            else
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);
            }
	}
        else if (bIY != cIY)
        {
            if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
            {
                if ( gc->modes.depthBits == 32 )
                {
                    gc->polygon.shader.zbuf =
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                        0, bIY);
                }
                else
                {
                    gc->polygon.shader.zbuf = (__GLzValue *)
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                        0, bIY);
                }
            }

            __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                    gc->polygon.shader.dyBC,
                                    &dxdyBC);
        }

	if (bIY != cIY)
        {
	    dy = (bIY + __glHalf) - b->window.y;

            __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyBC);

	    GenSnapXRight(gc, b->window.x + dy*dxdyBC, dxdyBC);
	    GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }
    else
    {
	dy = (aIY + __glHalf) - a->window.y;

        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);

	GenSnapXRight(gc, a->window.x + dy*dxdyAC, dxdyAC);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) /
                (a->window.y - b->window.y);
	    GenSnapXLeft(gc, a->window.x + dy*dxdyBA, dxdyBA);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

            if (bIY != cIY)
            {
                __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                        gc->polygon.shader.dyBC,
                                        &dxdyBC);

                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
            else
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);
            }
	}
        else if (bIY != cIY)
        {
            if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
            {
                if ( gc->modes.depthBits == 32 )
                {
                    gc->polygon.shader.zbuf =
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                        0, bIY);
                }
                else
                {
                    gc->polygon.shader.zbuf = (__GLzValue *)
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                        0, bIY);
                }
            }

            __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                    gc->polygon.shader.dyBC,
                                    &dxdyBC);
        }

	if (bIY != cIY)
        {
	    dy = (bIY + __glHalf) - b->window.y;

            __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyBC);

	    GenSnapXLeft(gc, b->window.x + dy*dxdyBC, dxdyBC);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, b, dx, dy);
	    GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }

    CHOP_ROUND_OFF();
}

/**************************************************************************\
* __fastGenMcdFillTriangle
*
* Just like __fastGenFillTriangle, except that the floating point macros
* __GL_FLOAT_BEGIN_DIVIDE and __GL_FLOAT_SIMPLE_END_DIVIDE are not allowed
* to straddle a function call to the driver (i.e., __fastFillSubTrianglePtr
* calls the display driver span functions if direct frame buffer access is
* not available.
\**************************************************************************/

void FASTCALL __fastGenMcdFillTriangle(
    __GLcontext *gc,
    __GLvertex *a,
    __GLvertex *b,
    __GLvertex *c,
    GLboolean ccw)
{
    GLint aIY, bIY, cIY;
    __GLfloat dxdyAC, dxdyBC, dxdyBA;
    __GLfloat dx, dy;

    CHOP_ROUND_ON();

    //
    // Calculate delta values for unit changes in x or y
    //

    GENACCEL(gc).__fastCalcDeltaPtr(gc, a, b, c);

    __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxAC,
                            gc->polygon.shader.dyAC,
                            &dxdyAC);

    //
    // can this be moved up even farther?
    //

    gc->polygon.shader.cfb = gc->drawBuffer;

    //
    // Snap each y coordinate to its pixel center
    //

    aIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(a->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    bIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(b->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    cIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(c->window.y)+
                                   __GL_VERTEX_FRAC_HALF);

    //
    // calculate the destination address
    //

    GENACCEL(gc).pPix =
          (BYTE *)gc->polygon.shader.cfb->buf.base
        + (  gc->polygon.shader.cfb->buf.outerWidth
           * (
                aIY
              - gc->constants.viewportYAdjust
              + gc->polygon.shader.cfb->buf.yOrigin
             )
          )
        + (  GENACCEL(gc).xMultiplier
           * (
              - gc->constants.viewportXAdjust
              + gc->polygon.shader.cfb->buf.xOrigin
             )
          );

    // Calculate destination Z
    if ((gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) &&
        aIY != bIY)
    {
        if ( gc->modes.depthBits == 32 )
        {
            gc->polygon.shader.zbuf =
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                0, aIY);
        }
        else
        {
            gc->polygon.shader.zbuf = (__GLzValue *)
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                0, aIY);
        }
    }

    /*
    ** This algorithm always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */

    if (ccw)
    {
	dy = (aIY + __glHalf) - a->window.y;

        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);

	GenSnapXLeft(gc, a->window.x + dy*dxdyAC, dxdyAC);

	dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
	GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) /
                (a->window.y - b->window.y);
	    GenSnapXRight(gc, a->window.x + dy*dxdyBA, dxdyBA);

            if (bIY != cIY)
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

                __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                        gc->polygon.shader.dyBC,
                                        &dxdyBC);

                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
            else
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);
            }
	}
        else if (bIY != cIY)
        {
            if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
            {
                if ( gc->modes.depthBits == 32 )
                {
                    gc->polygon.shader.zbuf =
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                        0, bIY);
                }
                else
                {
                    gc->polygon.shader.zbuf = (__GLzValue *)
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                        0, bIY);
                }
            }

            __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                    gc->polygon.shader.dyBC,
                                    &dxdyBC);
        }

	if (bIY != cIY)
        {
	    dy = (bIY + __glHalf) - b->window.y;

            __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyBC);

	    GenSnapXRight(gc, b->window.x + dy*dxdyBC, dxdyBC);
	    GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }
    else
    {
	dy = (aIY + __glHalf) - a->window.y;

        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);

	GenSnapXRight(gc, a->window.x + dy*dxdyAC, dxdyAC);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) /
                (a->window.y - b->window.y);
	    GenSnapXLeft(gc, a->window.x + dy*dxdyBA, dxdyBA);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

            if (bIY != cIY)
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

                __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                        gc->polygon.shader.dyBC,
                                        &dxdyBC);

                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
            else
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);
            }
	}
        else if (bIY != cIY)
        {
            if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
            {
                if ( gc->modes.depthBits == 32 )
                {
                    gc->polygon.shader.zbuf =
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                        0, bIY);
                }
                else
                {
                    gc->polygon.shader.zbuf = (__GLzValue *)
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                        0, bIY);
                }
            }

            __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                    gc->polygon.shader.dyBC,
                                    &dxdyBC);
        }

	if (bIY != cIY)
        {
	    dy = (bIY + __glHalf) - b->window.y;

            __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyBC);

	    GenSnapXLeft(gc, b->window.x + dy*dxdyBC, dxdyBC);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, b, dx, dy);
	    GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }

    CHOP_ROUND_OFF();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\gendirty.c ===
/****************************************************************************\
*
* Dirty region calculation
*
* 14-Feb-1995 mikeke    Created
*
* Copyright (c) 1994 Microsoft Corporation
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/****************************************************************************/

PXLIST XLISTAlloc(
    __GLGENbuffers *buffers)
{
    PXLIST pxlist;

    if (buffers->pxlist != NULL) {
        pxlist = buffers->pxlist;
        buffers->pxlist = pxlist->pnext;
    } else {
        pxlist = (PXLIST)ALLOC(sizeof(XLIST));
        if (pxlist == NULL) return NULL;
    }

    pxlist->pnext = NULL;
    return pxlist;
}

/****************************************************************************/

void XLISTFree(
    __GLGENbuffers *buffers,
    PXLIST pxlist)
{
    pxlist->pnext = buffers->pxlist;
    buffers->pxlist = pxlist;
}

/****************************************************************************/

PXLIST XLISTCopy(
    __GLGENbuffers *buffers,
    PXLIST pxlist)
{
    PXLIST pxlistNew = XLISTAlloc(buffers);

    if (pxlistNew != NULL) {
        pxlistNew->s = pxlist->s;
        pxlistNew->e = pxlist->e;
    }

    return pxlistNew;
}

/****************************************************************************/

BOOL YLISTAddSpan(
    __GLGENbuffers *buffers,
    PYLIST pylist,
    int xs,
    int xe)
{
    PXLIST *ppxlist = &(pylist->pxlist);
    PXLIST pxlist = XLISTAlloc(buffers);

    if (pxlist == NULL) return FALSE;

    //
    // Create new x span
    //

    pxlist->s = xs;
    pxlist->e = xe;

    //
    // Insert it in sorted order
    //

    while (
              ((*ppxlist) != NULL)
           && ((*ppxlist)->s < xs)
          ) {
        ppxlist = &((*ppxlist)->pnext);
    }
    pxlist->pnext = *ppxlist;
    *ppxlist = pxlist;

    //
    // Combine any overlapping spans
    //

    pxlist = pylist->pxlist;
    while (TRUE) {
        PXLIST pxlistNext = pxlist->pnext;

        if (pxlistNext == NULL) return TRUE;

        if (pxlist->e >= pxlistNext->s) {
            if (pxlistNext->e > pxlist->e) {
                pxlist->e = pxlistNext->e;
            }
            pxlist->pnext = pxlistNext->pnext;
            XLISTFree(buffers, pxlistNext);
        } else {
            pxlist = pxlist->pnext;
        }
    }

    return TRUE;
}

/****************************************************************************/

PYLIST YLISTAlloc(
    __GLGENbuffers *buffers)
{
    PYLIST pylist;

    if (buffers->pylist != NULL) {
        pylist = buffers->pylist;
        buffers->pylist = pylist->pnext;
    } else {
        pylist = (PYLIST)ALLOC(sizeof(YLIST));
        if (pylist == NULL) return NULL;
    }

    pylist->pxlist = NULL;
    pylist->pnext = NULL;
    return pylist;
}

/****************************************************************************/

void YLISTFree(
    __GLGENbuffers *buffers,
    PYLIST pylist)
{
    PXLIST pxlist = pylist->pxlist;
    PXLIST pxlistKill;

    while (pxlist != NULL) {
        pxlistKill = pxlist;
        pxlist = pxlist->pnext;
        XLISTFree(buffers, pxlistKill);
    }

    pylist->pnext = buffers->pylist;
    buffers->pylist = pylist;
}

/****************************************************************************/

PYLIST YLISTCopy(
    __GLGENbuffers *buffers,
    PYLIST pylist)
{
    PXLIST pxlist = pylist->pxlist;
    PXLIST *ppxlist;
    PYLIST pylistNew = YLISTAlloc(buffers);

    if (pylistNew != NULL) {
        pylistNew->s = pylist->s;
        pylistNew->e = pylist->e;

        ppxlist = &(pylistNew->pxlist);
        while (pxlist != NULL) {
            *ppxlist = XLISTCopy(buffers, pxlist);
            if (*ppxlist == NULL) {
                YLISTFree(buffers, pylistNew);
                return NULL;
            }
            ppxlist = &((*ppxlist)->pnext);
            pxlist = pxlist->pnext;
        }
        *ppxlist = NULL;
    }

    return pylistNew;
}

/****************************************************************************/

void RECTLISTAddRect(
    PRECTLIST prl,
    int xs,
    int ys,
    int xe,
    int ye)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl->buffers);
    PYLIST* ppylist;
    PYLIST pylistNew;

    ppylist = &(prl->pylist);
    while ((*ppylist) != NULL) {
        if (ys < (*ppylist)->e) break;
        ppylist  = &((*ppylist)->pnext);
    }

    while ((*ppylist) != NULL) {
        if (ys < (*ppylist)->s) {
            PYLIST pylistNew = YLISTAlloc(buffers);
            if (pylistNew == NULL) {
              OutOfMemory:
                RECTLISTSetEmpty(prl);
                return;
            }

            pylistNew->s = ys;
            pylistNew->e = ye;
            if (!YLISTAddSpan(buffers, pylistNew, xs, xe)) {
                goto OutOfMemory;
            }

            pylistNew->pnext = *ppylist;
            *ppylist = pylistNew;
            ppylist = &((*ppylist)->pnext);

            if (ye <= (*ppylist)->s) {
                return;
            }

            pylistNew->e = (*ppylist)->s;
            ys = (*ppylist)->s;
        } else if (ys == (*ppylist)->s) {
            if (ye >= (*ppylist)->e) {
                if (!YLISTAddSpan(buffers, *ppylist, xs, xe)) {
                    goto OutOfMemory;
                }

                ys = (*ppylist)->e;
                if (ys == ye) return;
                ppylist = &((*ppylist)->pnext);
            } else {
                PYLIST pylistNew = YLISTCopy(buffers, *ppylist);
                if (pylistNew == NULL) {
                    goto OutOfMemory;
                }

                pylistNew->e = ye;
                if (!YLISTAddSpan(buffers, pylistNew, xs, xe)) {
                    goto OutOfMemory;
                }

                (*ppylist)->s = ye;

                pylistNew->pnext = *ppylist;
                *ppylist = pylistNew;

                return;
            }
        } else {
            PYLIST pylistNew = YLISTCopy(buffers, *ppylist);
            if (pylistNew == NULL) {
                goto OutOfMemory;
            }

            pylistNew->e = ys;
            (*ppylist)->s = ys;

            pylistNew->pnext = *ppylist;
            *ppylist = pylistNew;
            ppylist = &((*ppylist)->pnext);
        }
    }

    pylistNew = YLISTAlloc(buffers);
    if (pylistNew == NULL) {
        goto OutOfMemory;
    }

    pylistNew->s = ys;
    pylistNew->e = ye;
    if (!YLISTAddSpan(buffers, pylistNew, xs, xe)) {
        goto OutOfMemory;
    }

    pylistNew->pnext = *ppylist;
    *ppylist = pylistNew;
}

/****************************************************************************/

#ifdef LATER
// these functions are not required in the server implementation

#define MAXRECTS 1024

HRGN RECTLISTCreateRegion(
    PRECTLIST prl)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl->buffers);
    PYLIST pylist = prl->pylist;
    int irect = 0;
    PRGNDATA prgndata;
    PRECT prc;
    HRGN hrgn;

    prgndata = (PRGNDATA)ALLOC(sizeof(RGNDATAHEADER) + MAXRECTS * sizeof(RECT));
    if (prgndata == NULL) return NULL;

    prc = (PRECT)(prgndata->Buffer);

    while (pylist != NULL) {
        PXLIST pxlist = pylist->pxlist;
        while (pxlist != NULL) {
            prc->left   = pxlist->s;
            prc->right  = pxlist->e;
            prc->top    = pylist->s;
            prc->bottom = pylist->e;
            prc++;
            irect++;
            if (irect == MAXRECTS) {
                //Error("maxrect");
                goto done;
            }

            pxlist = pxlist->pnext;
        }
        pylist = pylist->pnext;
    }

  done:
    prgndata->rdh.dwSize = sizeof(RGNDATAHEADER);
    prgndata->rdh.iType = RDH_RECTANGLES;
    prgndata->rdh.nCount = irect;
    prgndata->rdh.nRgnSize = 0;
    prgndata->rdh.rcBound.left = 0;
    prgndata->rdh.rcBound.right = 4096;
    prgndata->rdh.rcBound.top = 0;
    prgndata->rdh.rcBound.bottom = 4096;

    hrgn = GreExtCreateRegion(NULL, irect * sizeof(RECT) + sizeof(RGNDATAHEADER), prgndata);

    #ifdef LATER
    if (hrgn == NULL) {
        Error1("ExtCreateRegion() Error %d\n", GetLastError());
        Error1("%d rects\n", irect);
        prc = (PRECT)(prgndata->Buffer);
        for (;irect>0; irect--) {
            //printf("(%5d, %5d, %5d, %5d)\n", prc->left, prc->right, prc->top, prc->bottom);
            prc++;
        }
    }
    #endif

    FREE(prgndata);

    return hrgn;
}

/****************************************************************************/

//
// !!! make this do everything in one pass
//

void RECTLISTOr(
    PRECTLIST prl1,
    PRECTLIST prl2)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl1->buffers);
    PYLIST pylist = prl2->pylist;

    while (pylist != NULL) {
        PXLIST pxlist = pylist->pxlist;

        while (pxlist != NULL) {
            RECTLISTAddRect(prl1, pxlist->s, pylist->s, pxlist->e, pylist->e);
            pxlist = pxlist->pnext;
        }
        pylist = pylist->pnext;
    }
}


/****************************************************************************/

void RECTLISTOrAndClear(
    PRECTLIST prl1,
    PRECTLIST prl2)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl1->buffers);

    if (RECTLISTIsMax(prl2)) {
        RECTLISTSetMax(prl1);
        RECTLISTSetEmpty(prl2);
    } else {
        if (RECTLISTIsEmpty(prl1)) {
            //
            // If the clear region is empty just swap them
            //
            RECTLISTSwap(prl1, prl2);
        } else {
            //
            // The clear region isn't empty so maximize it.
            //
            RECTLISTSetMax(prl1);
            RECTLISTSetEmpty(prl2);
        }
    }
}

/****************************************************************************/

void RECTLISTSwap(
    PRECTLIST prl1,
    PRECTLIST prl2)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl1->buffers);
    RECTLIST rlTemp = *prl1;

    *prl1 = *prl2;
    *prl2 = rlTemp;
}
#endif

/****************************************************************************/

void RECTLISTSetEmpty(
    PRECTLIST prl)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl->buffers);
    PYLIST pylist = prl->pylist;
    PYLIST pylistKill;

    while (pylist != NULL) {
        pylistKill = pylist;
        pylist = pylist->pnext;
        YLISTFree(buffers, pylistKill);
    }

    prl->pylist = NULL;
}

/****************************************************************************/

BOOL RECTLISTIsEmpty(
    PRECTLIST prl)
{
    return (prl->pylist == NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\server\generic\gencx.c ===
#include "precomp.h"
#pragma hdrstop

#include <imfuncs.h>
#include "genci.h"
#include "genrgb.h"
#include "devlock.h"
#include "imports.h"

//
// CJ_ALIGNDWORD computes the minimum size (in bytes) of a DWORD array that
// contains at least cj bytes.
//
#define CJ_ALIGNDWORD(cj)   ( ((cj) + (sizeof(DWORD)-1)) & (-((signed)sizeof(DWORD))) )

//
// BITS_ALIGNDWORD computes the minimum size (in bits) of a DWORD array that
// contains at least c bits.
//
// We assume that there will always be 8 bits in a byte and that sizeof()
// always returns size in bytes.  The rest is independent of the definition
// of DWORD.
//
#define BITS_ALIGNDWORD(c)  ( ((c) + ((sizeof(DWORD)*8)-1)) & (-((signed)(sizeof(DWORD)*8))) )

// change to "static" after debugging
#define STATIC

#if DBG
// not multithreaded safe, but only for testing
#define RANDOMDISABLE                           \
    {                                           \
        long saveRandom = glRandomMallocFail;   \
        glRandomMallocFail = 0;

#define RANDOMREENABLE                          \
        if (saveRandom)                         \
            glRandomMallocFail = saveRandom;    \
    }
#else
#define RANDOMDISABLE
#define RANDOMREENABLE
#endif /* DBG */

#define INITIAL_TIMESTAMP   ((ULONG)-1)

/*
 *  Function Prototypes
 */

BOOL APIENTRY ValidateLayerIndex(int iLayer, PIXELFORMATDESCRIPTOR *ppfd);


/*
 *  Private functions
 */

void FASTCALL GetContextModes(__GLGENcontext *gengc);
STATIC void FASTCALL ApplyViewport(__GLcontext *gc);
GLboolean ResizeAncillaryBuffer(__GLGENbuffers *, __GLbuffer *, GLint, GLint);
GLboolean ResizeHardwareBackBuffer(__GLGENbuffers *, __GLcolorBuffer *, GLint, GLint);
GLboolean ResizeUnownedDepthBuffer(__GLGENbuffers *, __GLbuffer *, GLint, GLint);

/******************************Public*Routine******************************\
*
* EmptyFillStrokeCache
*
* Cleans up any objects in the fill and stroke cache
*
* History:
*  Tue Aug 15 15:37:30 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL EmptyFillStrokeCache(__GLGENcontext *gengc)
{
    if (gengc->hbrFill != NULL)
    {
        DeleteObject(gengc->hbrFill);
        gengc->hbrFill = NULL;
        gengc->crFill = COLORREF_UNUSED;
        gengc->hdcFill = NULL;
    }
#if DBG
    else
    {
        ASSERTOPENGL(gengc->crFill == COLORREF_UNUSED,
                     "crFill inconsistent\n");
    }
#endif
    if (gengc->hpenStroke != NULL)
    {
        // Deselect the pen before deletion if necessary
        if (gengc->hdcStroke != NULL)
        {
            SelectObject(gengc->hdcStroke, GetStockObject(BLACK_PEN));
            gengc->hdcStroke = NULL;
        }

        DeleteObject(gengc->hpenStroke);
        gengc->hpenStroke = NULL;
        gengc->cStroke.r = -1.0f;
        gengc->fStrokeInvalid = TRUE;
    }
#if DBG
    else
    {
        ASSERTOPENGL(gengc->cStroke.r < 0.0f &&
                     gengc->fStrokeInvalid,
                     "rStroke inconsistent\n");
    }
#endif
}

/******************************Public*Routine******************************\
* glsrvDeleteContext
*
* Deletes the generic context.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
\*********