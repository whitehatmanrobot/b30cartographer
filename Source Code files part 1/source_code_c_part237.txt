else

#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"need non-x86 code");
            break;

#endif // TGT_x86

        case GT_EQ:
        case GT_NE:
        case GT_LT:
        case GT_LE:
        case GT_GE:
        case GT_GT:

            // Longs and float comparisons are converted to "?:"
            assert(genActualType(op1->gtType) == TYP_INT ||
                                 op1->gtType  == TYP_REF);

#if TGT_x86

            // Check if we can use the currently set flags. Else set them

            emitJumpKind jumpKind;
            jumpKind = genCondSetFlags(tree);

            // Grab a register to materialize the bool value into

            // assuming the predictor did the right job
            assert(rsRegMaskCanGrab() & RBM_BYTE_REGS);

            reg  = rsGrabReg(RBM_BYTE_REGS);

            // @TODO : Assert that no instructions were generated while
            // grabbing the register which would set the flags

            regs = genRegMask(reg);
            assert(regs & RBM_BYTE_REGS);

            // Set (lower byte of) reg according to the flags

            inst_SET(jumpKind, reg);

            rsTrackRegTrash(reg);

            // Set the higher bytes to 0

            inst_RV_IV(INS_and, reg, 0x01);

#else
            assert(!"need RISC code");
#endif

            goto DONE;


        case GT_VIRT_FTN:

            assert(op2->gtOper == GT_CNS_INT);
            METHOD_HANDLE   methHnd;
            methHnd = (METHOD_HANDLE)op2->gtIntCon.gtIconVal;

            // op1 is the vptr
            assert(op1->gtOper == GT_IND && op1->gtType == TYP_I_IMPL);
            assert(op1->gtOp.gtOp1->gtType == TYP_REF);

            if (!(tree->gtFlags & GTF_CALL_INTF))
            {
                /* Load the vptr into a register */

                genCodeForTree(op1, needReg);
                reg  = op1->gtRegNum;
            }
            else
            {
                if (getNewCallInterface())
                {
                    EEInfo          info;
                    CLASS_HANDLE cls = eeGetMethodClass(methHnd);

                    assert(eeGetClassAttribs(cls) & FLG_INTERFACE);

                    genCodeForTree(op1, needReg);
                    reg = op1->gtRegNum;

                    /* @TODO: add that to DLLMain and make info a DLL global */

                    eeGetEEInfo(&info);

                    /* Load the vptr into a register */

                    genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                             (emitRegs)reg, (emitRegs)reg,
                                             info.offsetOfInterfaceTable);

                    // Access the correct slot in the vtable for the interface

                    unsigned interfaceID, *pInterfaceID;
                    interfaceID = eeGetInterfaceID(cls, &pInterfaceID);
                    assert(!pInterfaceID || !interfaceID);

                    // Can we directly access the interfaceID ?

                    if (!pInterfaceID)
                    {
                        genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                                 (emitRegs)reg, (emitRegs)reg,
                                                 interfaceID * 4);
                    }
                    else
                    {
                        genEmitter->emitIns_R_AR(INS_add, EA_4BYTE_DSP_RELOC, (emitRegs)reg,
                                                 SR_NA, (int)pInterfaceID);
                        genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                                 (emitRegs)reg, (emitRegs)reg, 0);
                    }
                }
                else
                {

#if !USE_FASTCALL || !NEW_CALLINTERFACE
                    assert(!"ldvirtftn NYI without USE_FASTCALL && NEW_CALLINTERFACE");
#endif
                    genComputeReg(op1, RBM_ECX, true, false);
                    rsLockUsedReg(RBM_ECX);

                    reg = rsGrabReg(RBM_EAX);

                    rsUnlockUsedReg(RBM_ECX);
                    genReleaseReg(op1);

                    assert(reg == REG_EAX);

                    void * hint, **pHint;
                    hint = eeGetHintPtr(methHnd, &pHint);

                    /* mov eax, address_of_hint_ptr */

                    if (pHint)
                    {
                        genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE_DSP_RELOC,
                                                 (emitRegs)reg, (emitRegs)reg, 0);
                        rsTrackRegTrash(reg);
                    }
                    else
                    {
                        genSetRegToIcon(reg, (unsigned)hint, TYP_INT);
                    }

#if NEW_CALLINTERFACE_WITH_PUSH

                    unsigned    saveStackLvl = genStackLevel;

                    inst_RV(INS_push, reg, TYP_INT);

                    /* Keep track of ESP for EBP-less frames */

                    genSinglePush(false);

#endif

                    /* now call indirect through eax (call dword ptr[eax]) */

                    genEmitter->emitIns_Call(emitter::EC_INDIR_ARD,
                                             NULL,          /* Will be ignored */
#if NEW_CALLINTERFACE_WITH_PUSH
                                             sizeof(int),   /* argSize */
#else
                                             0,             /* argSize */
#endif
                                             0,             /* retSize */
                                             gcVarPtrSetCur,
                                             gcRegGCrefSetCur,
                                             gcRegByrefSetCur,
                                             SR_EAX         /* ireg */
                                            );

#if NEW_CALLINTERFACE_WITH_PUSH
                    /* Restore the stack level */

                    genStackLevel = saveStackLvl;
                    genOnStackLevelChanged();
#endif

                    /* The vtable address is now in EAX */

                    reg = REG_INTRET;
                }
            }

            /* Get hold of the vtable offset (note: this might be expensive) */

            val = (unsigned)eeGetMethodVTableOffset(methHnd);

            /* Grab the function pointer out of the vtable */

            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                     (emitRegs)reg, (emitRegs)reg, val);

            regs = genRegMask(reg);
            goto DONE;

        case GT_ADDR:

            // We should get here for ldloca, ldarga, ldslfda, and ldelema,
            // but not ldflda. We cant assert this as the GTF_IND_RNGCHK
            // flag may be removed from ldelema by rng-chk elimination
            //
            // assert(op1->gtOper == GT_LCL_VAR || op1->gtOper == GT_CLS_VAR ||
            //        (op1->gtOper == GT_IND && (op1->gtFlags & GTF_IND_RNGCHK)));

#if     TGT_x86

            // Note that this code does not allow use to use
            // the register needed in the addressing mode as
            // a destination register.  If we want to optimize
            // this case we need to do it on a case-by-case basis.
            addrReg = genMakeAddressable(op1, 0, true, false, true); // needreg = 0, keepReg=true, takeAll=false, smallOK=true

            // We dont have to track addresses of lcl vars as TYP_BYREFs,
            // as GC doesnt care about things on the stack.
            assert( treeType == TYP_BYREF ||
                   (treeType == TYP_I_IMPL && (tree->gtFlags & GTF_ADDR_ONSTACK)));

            reg = rsPickReg(needReg, bestReg, treeType);

            // should not have spilled the regs need in op1
            assert(genStillAddressable(op1));

            // Slight hack, force the inst routine to think that
            // value being loaded is an int (since that is what what
            // LEA will return)  otherwise it would try to allocate
            // two registers for a long etc.
            assert(treeType == TYP_I_IMPL || treeType == TYP_BYREF);
            op1->gtType = treeType;

            inst_RV_TT(INS_lea, reg, op1, 0, (treeType == TYP_BYREF) ? EA_BYREF : EA_4BYTE);

            // The Lea instruction above better not have tried to put the
            // 'value' pointed to by 'op1' in a register, LEA will not work.
            assert(!(op1->gtFlags & GTF_REG_VAL));

            genDoneAddressable(op1, addrReg);

            rsTrackRegTrash(reg);       // reg does have foldable value in it

            gcMarkRegPtrVal (reg, treeType);

            regs = genRegMask(reg);

#else

            if  (op1->gtOper == GT_LCL_VAR)
            {
                bool            FPbased;

                // ISSUE:   The following assumes that it's OK to ask for
                //          the frame offset of a variable at this point;
                //          depending on when the layout of the frame is
                //          finalized, this may or may not be legal.

                emitRegs        base;
                unsigned        offs;

                /* Get info about the variable */

                offs = lvaFrameAddress(op1->gtLclVar.gtLclNum, &FPbased);

                base = FPbased ? (emitRegs)REG_FPBASE
                               : (emitRegs)REG_SPBASE;

                /* Pick a register for the value */

                reg = rsPickReg(needReg, bestReg, treeType);

                /* Compute "basereg+frameoffs" into the chosen register */

                if  (offs)
                {
                    genSetRegToIcon(reg, offs, treeType);

                    genEmitter->emitIns_R_R(INS_add, EA_4BYTE, (emitRegs)reg,
                                                                    (emitRegs)base);
                }
                else
                {
                    genEmitter->emitIns_R_R(INS_mov, EA_4BYTE, (emitRegs)reg,
                                                                    (emitRegs)base);
                }
            }
            else
            {
                assert(!"need RISC code to take addr of general expression");
            }

            /* Mark the register contents appropriately */

            rsTrackRegTrash(reg);
            gcMarkRegPtrVal(reg, treeType);

            regs = genRegMask(reg);

#endif //TGT_x86

            goto DONE;

#ifdef  DEBUG
        default:
            gtDispTree(tree);
            assert(!"unexpected unary/binary operator");
#endif
        }
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
        unsigned        useCall;

    case GT_CALL:

        reg = (regNumber)genCodeForCall(tree, true, &useCall);

        /* If the result is in a register, make sure it ends up in the right place */

        if  (reg != REG_NA)
        {
            tree->gtFlags |= GTF_REG_VAL;
            tree->gtRegNum = reg;
        }

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
        tree->gtUsedRegs = regs | useCall;
#endif
        genUpdateLife(tree);
        return;

#if TGT_x86
        case GT_LDOBJ:

            /* Should only happen when we evaluate the side-effects of ldobj */
            /* In case the base address points to one of our locals, we are  */
            /* sure that there aren't any, i.e. we don't generate any code   */

            /* CONSIDER: can we ensure that ldobj isn't really being used?   */

            GenTreePtr      op1;

            assert(tree->TypeGet() == TYP_STRUCT);
            op1 = tree->gtLdObj.gtOp1;
            if (op1->gtOper != GT_ADDR || op1->gtOp.gtOp1->gtOper != GT_LCL_VAR)
            {
                genCodeForTree(op1, 0);
                assert(op1->gtFlags & GTF_REG_VAL);
                reg = op1->gtRegNum;

                genEmitter->emitIns_AR_R(INS_test, EA_4BYTE,
                                          SR_EAX, (emitRegs)reg, 0);

                rsTrackRegTrash(reg);

                gcMarkRegSetNpt(genRegMask(reg));
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                tree->gtUsedRegs = genRegMask(reg);
#endif
                genUpdateLife(tree);
            }
            return;

#endif // TGT_x86

    case GT_JMPI:
        /* Compute the function pointer in EAX */

        assert(tree->gtOp.gtOp1);
        genCodeForTree(tree->gtOp.gtOp1, REG_EAX);

        /* fall through */

    case GT_JMP:
        assert(compCurBB->bbFlags & BBF_HAS_JMP);

#if USE_FASTCALL
        /* Make sure register arguments are in their initial registers */

        if  (rsCalleeRegArgNum)
        {
            assert(rsCalleeRegArgMaskLiveIn);

            unsigned        varNum;
            LclVarDsc   *   varDsc;

            for (varNum = 0, varDsc = lvaTable;
                 varNum < info.compArgsCount;
                 varNum++  , varDsc++)
            {
                assert(varDsc->lvIsParam);

                /* Is this variable a register arg? */

                if  (!varDsc->lvIsRegArg)
                    continue;
                else
                {
                    /* Register argument */

                    assert(isRegParamType(genActualType(varDsc->TypeGet())));

                    if  (varDsc->lvRegister)
                    {
                        /* Check if it remained in the same register */

                        if  (!(varDsc->lvRegNum == varDsc->lvArgReg))
                        {
                            /* Move it back to the arg register */

                            inst_RV_RV(INS_mov, (regNumber)varDsc->lvArgReg,
                                                (regNumber)varDsc->lvRegNum, varDsc->TypeGet());
                        }
                    }
                    else
                    {
                        /* Argument was passed in register, but ended up on the stack
                         * Reload it from the stack */

                        emitAttr size = emitTypeSize(varDsc->TypeGet());

                        genEmitter->emitIns_R_S(INS_mov,
                                                size,
                                                (emitRegs)(regNumber)varDsc->lvArgReg,
                                                varNum,
                                                0);
                    }
                }
            }
        }
#endif

        return;

    case GT_FIELD:
        assert(!"should not see this operator in this phase");
        break;

#if CSELENGTH

    case GT_ARR_RNGCHK:

        /* This must be an array length CSE def hoisted out of a loop */

        assert(tree->gtFlags & GTF_ALN_CSEVAL);

        {
            unsigned        regs;
            GenTreePtr      addr = tree->gtArrLen.gtArrLenAdr; assert(addr);

            regs = genMakeAddressable(tree, RBM_ALL & ~genCSEevalRegs(tree), true, false, false);

            /* Generate code for the CSE definition */

            genEvalCSELength(tree, addr, NULL);

            /* We can now free up the address */

            genDoneAddressable(tree, regs);
        }

        reg  = REG_COUNT;
        regs = 0;
        break;

#endif

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected operator");
    }

DONE:

    /* Check whether this subtree has freed up any variables */

    genUpdateLife(tree);

DONE_LIFE:

    /* We've computed the value of 'tree' into 'reg' */

    assert(reg  != 0xFEEFFAAF);
    assert(regs != 0xFEEFFAAF);

    tree->gtFlags   |= GTF_REG_VAL;
    tree->gtRegNum   = reg;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    tree->gtUsedRegs = regs;
#endif
}

/*****************************************************************************
 *
 *  Generate code for all the basic blocks in the function.
 */

void                Compiler::genCodeForBBlist()
{
    BasicBlock *    block;
    BasicBlock *    lblk;

    unsigned        varNum;
    LclVarDsc   *   varDsc;

    unsigned        savedStkLvl;

#ifdef  DEBUG
    genIntrptibleUse = true;
#endif

#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)
    /* The last IL-offset noted for IP-mapping. We have not generated
       any IP-mapping records yet, so initilize to invalid */

    IL_OFFSET       lastILofs   = BAD_IL_OFFSET;
#endif

    /* Initialize the spill tracking logic */

    rsSpillBeg();

    /* Initialize the line# tracking logic */

#ifdef DEBUGGING_SUPPORT
    if (opts.compScopeInfo && info.compLocalVarsCount>0)
    {
        siInit();

        compResetScopeLists();
    }
#endif

    /* We need to keep track of the number of temp-refs */

#if TGT_x86
    genTmpAccessCnt = 0;
#endif

    /* If we have any try blocks, we might potentially trash everything */

#if INLINE_NDIRECT
    if  (info.compXcptnsCount || info.compCallUnmanaged)
#else
    if  (info.compXcptnsCount)
#endif
        rsMaskModf = RBM_ALL;

    /* Initialize the pointer tracking code */

    gcRegPtrSetInit();
    gcVarPtrSetInit();

    /* If any arguments live in registers, mark those regs as such */

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        /* Is this variable a parameter assigned to a register? */

        if  (!varDsc->lvIsParam || !varDsc->lvRegister)
            continue;

        /* Is the argument live on entry to the method? */

        if  (!(genVarIndexToBit(varDsc->lvVarIndex) & fgFirstBB->bbLiveIn))
            continue;

        /* Is this a floating-point argument? */

#if CPU_HAS_FP_SUPPORT

        assert(varDsc->lvType != TYP_FLOAT);

        if  (varDsc->lvType == TYP_DOUBLE)
            continue;

#endif

        /* Mark the register as holding the variable */

        if  (isRegPairType(varDsc->lvType))
        {
            rsTrackRegLclVarLng(varDsc->lvRegNum, varNum, true);

            if  (varDsc->lvOtherReg != REG_STK)
                rsTrackRegLclVarLng(varDsc->lvOtherReg, varNum, false);
        }
        else
        {
            rsTrackRegLclVar(varDsc->lvRegNum, varNum);
        }
    }

#if defined(DEBUG) && !defined(NOT_JITC)

    if  (info.compLineNumCount)
    {
        unsigned        lnum;
        srcLineDsc  *   ldsc;

        /* Tell the emitter about the approx. line# range for the method */

        int             lmin = +0xFFFF;
        int             lmax = -0xFFFF;

        for (lnum = 0, ldsc = info.compLineNumTab;
             lnum < info.compLineNumCount;
             lnum++  , ldsc++)
        {
            int             line = ldsc->sldLineNum;

            if  (lmin > line) lmin = line;
            if  (lmax < line) lmax = line;
        }

        lmin = compFindNearestLine(lmin);
        if  (lmin == 0)
            lmin = 1;

        genEmitter->emitRecordLineNo(-lmin);
        genEmitter->emitRecordLineNo(-lmax);
    }

#endif

    /* UNDONE: This should be done elsewhere! */

    for (lblk =     0, block = fgFirstBB;
                       block;
         lblk = block, block = block->bbNext)
    {
        if  (lblk == NULL)
        {
            /* Treat the initial block as a jump target */

            block->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
        }
        else if (fgBlockHasPred(block, lblk, fgFirstBB, fgLastBB))
        {
            /* Someone other than the previous block jumps to this block */

            block->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
        }
        else if (block->bbCatchTyp)
        {
            /* Catch handlers have implicit jumps to them */

            block->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
        }
        else if (block->bbJumpKind == BBJ_THROW && (block->bbFlags & BBF_INTERNAL))
        {
            /* This must be a "range check failed" or "overflow" block */

            block->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
        }

        switch (block->bbJumpKind)
        {
            GenTreePtr      test;

            BasicBlock * *  jmpTab;
            unsigned        jmpCnt;

        case BBJ_COND:

            /* Special case: long/FP compares generate two jumps */

            test = block->bbTreeList; assert(test);
            test = test->gtPrev;

            /* "test" should be the condition */

            assert(test);
            assert(test->gtNext == 0);
            assert(test->gtOper == GT_STMT);
            test = test->gtStmt.gtStmtExpr;
            assert(test->gtOper == GT_JTRUE);
            test = test->gtOp.gtOp1;
#if !   CPU_HAS_FP_SUPPORT
            if  (test->OperIsCompare())
#endif
            {
                assert(test->OperIsCompare());
                test = test->gtOp.gtOp1;
            }

            switch (test->gtType)
            {
            case TYP_LONG:
            case TYP_FLOAT:
            case TYP_DOUBLE:

                block->bbNext->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
                break;
            }

            // Fall through ...

        case BBJ_ALWAYS:
            block->bbJumpDest->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
            break;

        case BBJ_SWITCH:

            jmpCnt = block->bbJumpSwt->bbsCount;
            jmpTab = block->bbJumpSwt->bbsDstTab;

            do
            {
                (*jmpTab)->bbFlags |= BBF_JMP_TARGET|BBF_HAS_LABEL;
            }
            while (++jmpTab, --jmpCnt);

            break;
        }
    }

    if  (info.compXcptnsCount)
    {
        unsigned        XTnum;
        EHblkDsc *      HBtab;

        for (XTnum = 0, HBtab = compHndBBtab;
             XTnum < info.compXcptnsCount;
             XTnum++  , HBtab++)
        {
            assert(HBtab->ebdTryBeg); HBtab->ebdTryBeg->bbFlags |= BBF_HAS_LABEL;
            if    (HBtab->ebdTryEnd)  HBtab->ebdTryEnd->bbFlags |= BBF_HAS_LABEL;

            assert(HBtab->ebdHndBeg); HBtab->ebdHndBeg->bbFlags |= BBF_HAS_LABEL;
            if    (HBtab->ebdHndEnd)  HBtab->ebdHndEnd->bbFlags |= BBF_HAS_LABEL;

            if    (HBtab->ebdFlags & JIT_EH_CLAUSE_FILTER)
            { assert(HBtab->ebdFilter); HBtab->ebdFilter->bbFlags |= BBF_HAS_LABEL; }
        }
    }

    unsigned finallyNesting = 0;

    /*-------------------------------------------------------------------------
     *
     *  Walk the basic blocks and generate code for each one
     *
     */

    for (lblk =     0, block = fgFirstBB;
                       block;
         lblk = block, block = block->bbNext)
    {
        VARSET_TP       liveSet;

        unsigned        gcrefRegs = 0;
        unsigned        byrefRegs = 0;

        GenTreePtr      tree;

#ifdef  DEBUG
//      printf("Block #%2u [%08X] jumpKind = %u in '%s.%s'\n", block->bbNum, block, block->bbJumpKind, info.compFullName);
        if  (dspCode) printf("\n      L_%02u_%02u:\n", Compiler::s_compMethodsCount, block->bbNum);
#endif

        /* Does any other block jump to this point ? */

        if  (block->bbFlags & BBF_JMP_TARGET)
        {
            /* Someone may jump here, so trash all regs */

            rsTrackRegClr();

            genFlagsEqualToNone();
        }
#if GEN_COMPATIBLE_CODE
        else
        {
            /* No jump, but pointers always need to get trashed for proper GC tracking */

            rsTrackRegClrPtr();
        }
#endif

        /* No registers are used or locked on entry to a basic block */

        rsMaskUsed  =
        rsMaskMult  =
        rsMaskLock  = 0;

        /* Figure out which registers hold variables on entry to this block */

        rsMaskVars     = DOUBLE_ALIGN_NEED_EBPFRAME ? RBM_SPBASE|RBM_FPBASE
                                                    : RBM_SPBASE;

        genCodeCurLife = 0;
#if TGT_x86
        genFPregVars   = block->bbLiveIn & optAllFPregVars;
        genFPregCnt    = genCountBits(genFPregVars);
#endif

        gcRegGCrefSetCur = 0;
        gcRegByrefSetCur = 0;
        gcVarPtrSetCur   = 0;

#if 0
        printf("Block #%2u: used regs = %04X , free regs = %04X\n", block->bbNum,
                                                                    rsMaskUsed,
                                                                    rsRegMaskFree());
#endif

        liveSet = block->bbLiveIn & optAllNonFPvars; genUpdateLife(liveSet);

        /* Figure out which registers hold pointer variables */

        for (varNum = 0, varDsc = lvaTable;
             varNum < lvaCount;
             varNum++  , varDsc++)
        {
            unsigned        varIndex;
            VARSET_TP       varBit;

            /* Ignore the variable if it's not tracked or not in a reg */

            if  (!varDsc->lvTracked)
                continue;
            if  (!varDsc->lvRegister)
                continue;
            if  ( varDsc->lvType == TYP_DOUBLE)
                continue;

            /* Get hold of the index and the bitmask for the variable */

            varIndex = varDsc->lvVarIndex;
            varBit   = genVarIndexToBit(varIndex);

//          printf("Check var#%2u [%08X] against LiveIn of %08X\n", varIndex, varBit, liveSet);

            /* Is this variable live on entry? */

            if  (liveSet & varBit)
            {
                regNumber   regNum  = varDsc->lvRegNum;
                unsigned    regMask = genRegMask(regNum);

                if       (varDsc->lvType == TYP_REF)
                    gcrefRegs |= regMask;
                else if  (varDsc->lvType == TYP_BYREF)
                    byrefRegs |= regMask;

//              printf("var#%2u[%2u] starts life in reg %s [%08X]\n", varNum, varIndex, compRegVarName(varDsc->lvRegNum), genRegMask(varDsc->lvRegNum));

                /* Mark the register holding the variable as such */

                if  (isRegPairType(varDsc->lvType))
                {
                    rsTrackRegLclVarLng(regNum, varNum, true);
                    if  (varDsc->lvOtherReg != REG_STK)
                    {
                        rsTrackRegLclVarLng(varDsc->lvOtherReg, varNum, false);
                        regMask |= genRegMask(varDsc->lvOtherReg);
                    }
                }
                else
                {
                    rsTrackRegLclVar(regNum, varNum);
                }

                assert(rsMaskVars & regMask);
            }
        }

        gcPtrArgCnt  = 0;

        /* Make sure we keep track of what pointers are live */

        assert((gcrefRegs & byrefRegs) == 0);
        gcRegGCrefSetCur = gcrefRegs;
        gcRegByrefSetCur = byrefRegs;

        /* The return register is live on entry to catch handlers and
            at the start of "the" return basic block.
         */

        if  (block == genReturnBB && info.compRetType == TYP_REF)
            gcRegGCrefSetCur |= RBM_INTRET;

        if (block->bbCatchTyp && handlerGetsXcptnObj(block->bbCatchTyp))
            gcRegGCrefSetCur |= RBM_EXCEPTION_OBJECT;

        /* Start a new code output block */

        genEmitter->emitSetHasHandler((block->bbFlags & BBF_HAS_HANDLER) != 0);

        block->bbEmitCookie = NULL;

        if  (block->bbFlags & (BBF_JMP_TARGET|BBF_HAS_LABEL))
        {
            /* Mark a label and update the current set of live GC refs */

//          printf("Add[1] label for block #%2u: [%08X;%03u]\n",
//              block->bbNum, genEmitter->emitIGlast, genEmitter->emitCurIGfreeNext - genEmitter->emitIGbuffer);

            genEmitter->emitAddLabel(&block->bbEmitCookie,
                                       gcVarPtrSetCur,
                                     gcRegGCrefSetCur,
                                     gcRegByrefSetCur);
        }

#ifdef DEBUGGING_SUPPORT
#ifdef DEBUG
//      if  (dspCode && opts.compScopeInfo && verbose)
//          printf("      (PC=@%d)\n", genEmitter->emitCodeOffset(genEmitter.emitCodeCurBlock()));
#endif
#endif

#if     TGT_x86

        /* Both stacks are always empty on entry to a basic block */

        genStackLevel = 0;
        genFPstkLevel = 0;

#endif

#if TGT_x86

        /* Check for inserted throw blocks and adjust genStackLevel */

        if  ((block->bbFlags & BBF_INTERNAL) &&
             block->bbJumpKind == BBJ_THROW  &&
             !genFPused                      &&
             fgIsCodeAdded())
        {
            assert(block->bbFlags & BBF_JMP_TARGET);

            genStackLevel = fgGetRngFailStackLevel(block)*sizeof(int);
            genOnStackLevelChanged();

            if  (genStackLevel)
            {
                genEmitter->emitMarkStackLvl(genStackLevel);
                inst_RV_IV(INS_add, REG_ESP, genStackLevel);
                genStackLevel = 0;
                genOnStackLevelChanged();
            }
        }

        savedStkLvl = genStackLevel;

#endif

        /* Tell everyone which basic block we're working on */

        compCurBB = block;

#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0)
            siBeginBlock();

        // Blocks added for ACK_RNGCHK_FAIL, etc, dont correspond to any
        // single IL instruction.

        if (opts.compDbgInfo && (block->bbFlags & BBF_INTERNAL) &&
                                (block->bbJumpKind == BBJ_THROW))
        {
            genIPmappingAdd(ICorDebugInfo::MappingTypes::NO_MAPPING);
        }
#endif

        /*---------------------------------------------------------------------
         *
         *  Generate code for each statement-tree in the block
         *
         */

        for (tree = block->bbTreeList; tree; tree = tree->gtNext)
        {
            GenTreePtr      stmt;

            assert(tree->gtOper == GT_STMT);

#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)

            /* Do we have a new IL-offset ? */

            assert(tree->gtStmtILoffs <= info.compCodeSize ||
                   tree->gtStmtILoffs == BAD_IL_OFFSET);

            if  (tree->gtStmtILoffs != BAD_IL_OFFSET &&
                 tree->gtStmtILoffs != lastILofs)
            {
                lastILofs = tree->gtStmtILoffs;

                /* Create and append a new IP-mapping entry */

#ifdef DEBUGGING_SUPPORT
                if (opts.compDbgInfo)
                    genIPmappingAdd(lastILofs);
#endif

                /* Display the source lines and IL opcodes */
#ifdef DEBUG
                genEmitter->emitRecordLineNo(compLineNumForILoffs(lastILofs));

                if  (dspCode && dspLines)
                    compDspSrcLinesByILoffs(lastILofs);

#endif
            }

#endif // DEBUGGING_SUPPORT || DEBUG

#ifdef DEBUG
            assert(tree->gtStmt.gtStmtLastILoffs <= info.compCodeSize ||
                   tree->gtStmt.gtStmtLastILoffs == BAD_IL_OFFSET);

            if (dspCode && dspILopcodes &&
                tree->gtStmt.gtStmtLastILoffs != BAD_IL_OFFSET)
            {
                while (genCurDispOffset <= tree->gtStmt.gtStmtLastILoffs)
                {
                    genCurDispOffset +=
                        dumpSingleILopcode ((unsigned char*)info.compCode,
                                            genCurDispOffset, ">    ");
                }
            }
#endif

            /* Get hold of the statement tree */

            stmt = tree->gtStmt.gtStmtExpr;

#ifdef  DEBUG
            if  (verbose) { printf("\nBB stmt:\n"); gtDispTree(stmt); printf("\n"); }
#endif
            switch (stmt->gtOper)
            {
                unsigned        useCall;

            case GT_CALL:
                genCodeForCall (stmt, false, &useCall);
                genUpdateLife  (stmt);
                gcMarkRegSetNpt(RBM_INTRET);
                break;

            case GT_IND:

                if  ((stmt->gtFlags & GTF_IND_RNGCHK ) &&
                     (tree->gtFlags & GTF_STMT_CMPADD))
                {
                    unsigned    addrReg;

                    /* A range-checked array expression whose value isn't used */

                    if  (genMakeIndAddrMode(stmt->gtInd.gtIndOp1,
                                            stmt,
                                            false,
                                            RBM_ALL,
                                            false,
                                            false,
                                            &addrReg))
                    {
                        genUpdateLife(stmt);
                        gcMarkRegSetNpt(addrReg);
                        break;
                    }
                }

                // Fall through ....

            default:

                /* Generate code for the tree */

                rsSpillChk();
                genCodeForTree(stmt, 0);
                rsSpillChk();
            }

            /* The value of the tree isn't used, unless it's a return stmt */

            if  (stmt->gtOper != GT_RETURN)
                gcMarkRegPtrVal(stmt);

#if     TGT_x86

            /* Did the expression leave a value on the FP stack? */

            if  (genFPstkLevel)
            {
                assert(genFPstkLevel == 1);
                inst_FS(INS_fstp, 0);
                genFPstkLevel = 0;
            }

#endif

            /* Make sure we didn't mess up pointer register tracking */

#ifndef NDEBUG
#if     TRACK_GC_REFS

            unsigned ptrRegs       = (gcRegGCrefSetCur|gcRegByrefSetCur);
            unsigned nonVarPtrRegs = ptrRegs & ~rsMaskVars;

            if  (stmt->gtOper == GT_RETURN && varTypeIsGC(info.compRetType))
                nonVarPtrRegs &= ~RBM_INTRET;

            if  (nonVarPtrRegs)
            {
                printf("Regset after  stmt=%08X BB=%08X gcr=[", stmt, block);
                gcRegPtrSetDisp(gcRegGCrefSetCur & ~rsMaskVars, false);
                printf("], byr=[");
                gcRegPtrSetDisp(gcRegByrefSetCur & ~rsMaskVars, false);
                printf("], regVars = [");
                gcRegPtrSetDisp(rsMaskVars, false);
                printf("]\n");
            }

            assert(nonVarPtrRegs == 0);

#endif
#endif

#if     TGT_x86

            assert(tree->gtOper == GT_STMT);
            if  (!opts.compMinOptim && tree->gtStmtFPrvcOut != genFPregCnt)
            {

#ifdef  DEBUG
                /* The pops better apply to all paths from this spot */

                if  (tree->gtNext == NULL)
                {
                    switch (block->bbJumpKind)
                    {
                    case BBJ_RET:
                    case BBJ_COND:
                    case BBJ_THROW:
                    case BBJ_SWITCH:
                        assert(!"FP regvar left unpopped on stack on path from block");
                    }
                }
#endif

                // At the end of a isBBF_BB_COLON() block, we may need to
                // pop off any enregistered floating-point variables that
                // are dying due to having their last use in this block.
                //
                // However we have already computed a result for the GT_BB_QMARK
                // that we must leave on the top of the FP stack.
                // Thus we must take care to leave the top of the floating point
                // stack undisturbed, while we pop the dying enregistered
                // floating point variables.

                bool saveTOS = false;

                if (stmt->gtOper == GT_BB_COLON  &&
                    varTypeIsFloating(stmt->TypeGet()))
                {
                    assert(isBBF_BB_COLON(block->bbFlags));
                    // We expect that GT_BB_COLON is the last statement
                    assert(stmt->gtNext == 0);
                    saveTOS = true;
                }

                genChkFPregVarDeath(tree, saveTOS);

                assert(tree->gtStmtFPrvcOut == genFPregCnt);
            }

#endif  // end TGT_x86

        } //-------- END-FOR each statement-tree of the current block ---------

#ifdef  DEBUGGING_SUPPORT

        if (opts.compScopeInfo && info.compLocalVarsCount>0)
        {
            siEndBlock();

            /* Is this the last block, and are there any open scopes left ? */

            if (block->bbNext == NULL && siOpenScopeList.scNext)
            {
                /* Removal of unreachable last block may cause this */

                assert(block->bbCodeOffs + block->bbCodeSize != info.compCodeSize);

                siCloseAllOpenScopes();
            }
        }

#endif

#if     TGT_x86
        genStackLevel -= savedStkLvl;
        genOnStackLevelChanged();
#endif

        gcMarkRegSetNpt(gcrefRegs|byrefRegs);

        if  (genCodeCurLife != block->bbLiveOut)
            genChangeLife(block->bbLiveOut DEBUGARG(NULL));

        /* Both stacks should always be empty on exit from a basic block */

#if     TGT_x86
        assert(genStackLevel == 0);
        assert(genFPstkLevel == 0);
#endif

        assert(genFullPtrRegMap == false || gcPtrArgCnt == 0);

        /* Do we need to generate a jump or return? */

        switch (block->bbJumpKind)
        {
        case BBJ_COND:
            break;

        case BBJ_ALWAYS:
#if TGT_x86
            inst_JMP(EJ_jmp, block->bbJumpDest);
#else
            genEmitter->emitIns_J(INS_bra, false, false, block->bbJumpDest);
#endif
            break;

        case BBJ_RETURN:
#if TGT_RISC
            genFnEpilog();
#endif
            genExitCode(block->bbNext == 0);
            break;

        case BBJ_SWITCH:
            break;

        case BBJ_THROW:

            /*
                If the subsequent block is a range-check fail block insert
                a NOP in order to separate both blocks by an instruction.
             */

            if  (!genFPused &&  block->bbNext
                            && (block->bbNext->bbFlags & BBF_INTERNAL) != 0
                            &&  block->bbNext->bbJumpKind == BBJ_THROW)
            {
#if TGT_x86
                instGen(INS_int3); // This should never get executed
#else
                genEmitter->emitIns(INS_nop);
#endif
            }

            break;

        case BBJ_CALL:

            // @TODO : Not safe for async exceptions

            /* If we are about to invoke a finally locally from a try block,
               we have to set the hidden slot corresponding to the finally's
               nesting level. When invoked in response to an exception, the
               EE usually does it.
               For n finallys, we have n+1 blocks created by fgFindBasicBlocks()
               as shown. '*' indicates BBF_INTERNAL blocks.
               --> BBJ_CALL(1), BBJ_CALL*(2), ... BBJ_CALL*(n), BBJ_ALWAYS*
               This code depends on this order not being messed up.
             */

            assert(genFPused);

            if (!(block->bbFlags & BBF_INTERNAL))
            {
                fgHandlerNesting(block, &finallyNesting);
            }
            else
            {
                /* If the CEE_LEAVE also jumps out of catches, it would reduce
                   the nesting level. Find how many CPX_ENDCATCHes are called
                   and adjust the nesting level accordingly. */

                GenTreePtr endCatch = block->bbTreeList;
                assert(!endCatch || endCatch->gtOper == GT_STMT);
                if (endCatch)
                    endCatch = endCatch->gtStmt.gtStmtExpr;

                for(/**/; endCatch; finallyNesting--)
                {
                    assert(finallyNesting > 0);

                    /* The CPX_ENDCATCHes will be joint using GT_COMMAs. */

                    if (endCatch->gtOper == GT_CALL)
                    {
                        assert(endCatch->gtCall.gtCallType    == CT_HELPER &&
                               endCatch->gtCall.gtCallMethHnd == eeFindHelper(CPX_ENDCATCH));
                        endCatch = NULL;
                    }
                    else
                    {
                        assert(endCatch->gtOper == GT_COMMA);
                        assert(endCatch->gtOp.gtOp2->gtOper               == GT_CALL &&
                               endCatch->gtOp.gtOp2->gtCall.gtCallType    == CT_HELPER &&
                               endCatch->gtOp.gtOp2->gtCall.gtCallMethHnd == eeFindHelper(CPX_ENDCATCH));
                        endCatch = endCatch->gtOp.gtOp1;
                    }
                }
            }

            unsigned shadowSPoffs;
            shadowSPoffs = lvaShadowSPfirstOffs + compLocallocUsed * sizeof(void*);
            shadowSPoffs += finallyNesting * sizeof(void*);

#if TGT_x86
            /* We write 0xFC ("Fnally Call") to the corresponding slot. This
               indicates to the EE that the finally has been locally invoked
               and it is appropriately handled
                    mov [ebp-(n+1)],0
                    mov [ebp-  n  ],0xFC
                    call @finallyBlock
                    mov [ebp-  n  ],0
            */

            genEmitter->emitIns_I_ARR(INS_mov, EA_4BYTE, 0, SR_EBP,
                                      SR_NA, -(shadowSPoffs+sizeof(void*)));
            // The ordering has to be maintained for fully-intr code
            // as the list of shadow slots has to be 0 terminated.
            if (genInterruptible && opts.compSchedCode)
                genEmitter->emitIns_SchedBoundary();
            genEmitter->emitIns_I_ARR(INS_mov, EA_4BYTE, 0xFC, SR_EBP,
                                      SR_NA, -shadowSPoffs);

            // Call the finally BB
            inst_JMP(EJ_call, block->bbJumpDest);

            // Zero back the slot now
            genEmitter->emitIns_I_ARR(INS_mov, EA_4BYTE, 0, SR_EBP,
                                      SR_NA, -shadowSPoffs);
            if (genInterruptible && opts.compSchedCode)
                genEmitter->emitIns_SchedBoundary();
#else
            assert(!"NYI for risc");
            genEmitter->emitIns_J(INS_bsr, false, false, block->bbJumpDest);
#endif
            break;

        default:
            break;
        }

#ifdef  DEBUG
        compCurBB = 0;
#endif

    } //------------------ END-FOR each block of the method -------------------

    /* Epilog block follows and is not inside a try region */
    genEmitter->emitSetHasHandler(false);

    /* Nothing is live at this point */

    genUpdateLife((VARSET_TP)0);

    /* Finalize the spill  tracking logic */

    rsSpillEnd();

    /* Finalize the temp   tracking logic */

    tmpEnd();
}

/*****************************************************************************
 *
 *  Generate code for a long operation.
 *  needReg is a recommendation of which registers to use for the tree
 */

void                Compiler::genCodeForTreeLng(GenTreePtr tree, unsigned needReg)
{
    genTreeOps      oper;
    unsigned        kind;

    regPairNo       regPair;
    unsigned        regMask = rsMaskUsed;

#ifndef NDEBUG
    regPair = (regPairNo)0xFEEFFAAF;               // to detect uninitialized use
#endif

    assert(tree);
    assert(tree->gtOper != GT_STMT);
    assert(genActualType(tree->gtType) == TYP_LONG);

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

    if  (tree->gtFlags & GTF_REG_VAL)
    {
REG_VAR_LONG:
        regPair   = tree->gtRegPair;
        regMask  |= genRegPairMask(regPair);

        gcMarkRegSetNpt(genRegPairMask(regPair));

        goto DONE;
    }

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
    {
        __int64         lval;

        /* Pick a register pair for the value */

        regPair  = rsPickRegPair(needReg);
        regMask |= genRegPairMask(regPair);

        /* Load the value into the registers */

#if !   CPU_HAS_FP_SUPPORT
        if  (oper == GT_CNS_DBL)
        {
            assert(sizeof(__int64) == sizeof(double));

            assert(sizeof(tree->gtLngCon.gtLconVal) ==
                   sizeof(tree->gtDblCon.gtDconVal));

            lval = *(__int64*)(&tree->gtDblCon.gtDconVal);
        }
        else
#endif
        {
            assert(oper == GT_CNS_LNG);

            lval = tree->gtLngCon.gtLconVal;
        }

        genSetRegToIcon(genRegPairLo(regPair), (long)(lval      ));
        genSetRegToIcon(genRegPairHi(regPair), (long)(lval >> 32));
        goto DONE;
    }

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        switch (oper)
        {
        case GT_LCL_VAR:

#if REDUNDANT_LOAD

            /* Is local variable already in registers? if so use this
             * register
             */
            regPair = rsLclIsInRegPair(tree->gtLclVar.gtLclNum);

            if (regPair != REG_PAIR_NONE)
            {
                regMask |= genRegPairMask(regPair);

                goto DONE;
            }

            /* Does the variable live in a register? */

            if  (genMarkLclVar(tree))
                goto REG_VAR_LONG;

            // Fall through ....

#endif

        case GT_CLS_VAR:

            /* Pick a register pair for the value */

            regPair  = rsPickRegPair(needReg);
            regMask |= genRegPairMask(regPair);

            /* Load the value into the registers */

            rsTrackRegTrash(genRegPairLo(regPair));
            rsTrackRegTrash(genRegPairHi(regPair));

            inst_RV_TT(INS_mov, genRegPairLo(regPair), tree, 0);
            inst_RV_TT(INS_mov, genRegPairHi(regPair), tree, 4);

            goto DONE;

#if OPTIMIZE_QMARK
#if TGT_x86

        case GT_BB_QMARK:

            /* The "_?" value is always in EDX:EAX */

            regPair = REG_PAIR_EAXEDX;
            regMask = RBM_PAIR_EAXEDX;

            /* CONSIDER: Don't always load the value into EDX:EAX! */

            goto DONE;
#endif
#endif

        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"unexpected leaf");
        }
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        unsigned        addrReg;

        instruction     insLo;
        instruction     insHi;

        regNumber       reg1;
        regNumber       reg2;

        int             helper;

        GenTreePtr      op1  = tree->gtOp.gtOp1;
        GenTreePtr      op2  = tree->gtOp.gtOp2;

        switch (oper)
        {
            bool            doLo;
            bool            doHi;

        case GT_ASG:

            /* Is the target a local ? */

            if  (op1->gtOper == GT_LCL_VAR)
            {
                unsigned    varNum      = op1->gtLclVar.gtLclNum;
                unsigned    varOffset   = op1->gtLclVar.gtLclOffs;
                LclVarDsc * varDsc;
                regNumber   rLo;
                regNumber   rHi;

                assert(varNum < lvaCount);
                varDsc = lvaTable + varNum;

                /* Has the variable been assigned to a register (pair) ? */

                if  (genMarkLclVar(op1))
                {
                    assert(op1->gtFlags & GTF_REG_VAL);
                    regPair = op1->gtRegPair;
                    rLo     = genRegPairLo(regPair);
                    rHi     = genRegPairHi(regPair);

                    if  (!(tree->gtLiveSet & genVarIndexToBit(varDsc->lvVarIndex)))
                    {
#ifdef DEBUG
                        if  (verbose)
                            printf("Eliminating dead store into pair '%s%s'\n",
                                   compRegVarName(genRegPairLo(regPair)),
                                   compRegVarName(genRegPairHi(regPair)) );
#endif
                        genEvalSideEffects(op2, 0);
                        regMask = genRegPairMask(regPair);
                        goto DONE;
                    }

#ifdef DEBUGGING_SUPPORT

                    /* For non-debuggable code, every definition of a lcl-var has
                     * to be checked to see if we need to open a new scope for it.
                     */
                    if (opts.compScopeInfo && !opts.compDbgCode && info.compLocalVarsCount>0)
                        siCheckVarScope (varNum, varOffset);

#endif

#if     TGT_x86

                    /* Is the value being assigned a constant? */

                    if  (op2->gtOper == GT_CNS_LNG)
                    {
                        /* Move the value into the target */

                        inst_TT_IV(INS_mov, op1, (long)(op2->gtLngCon.gtLconVal      ), 0);
                        inst_TT_IV(INS_mov, op1, (long)(op2->gtLngCon.gtLconVal >> 32), 4);

                        regMask = genRegPairMask(regPair);
                        goto DONE_ASSG_REGS;
                    }

                    /* Is the value being assigned actually a 'pop' ? */

                    if  (op2->gtOper == GT_POP)
                    {
                        assert(op1->gtOper == GT_LCL_VAR);

                        /* Generate 'pop [lclVar+0] ; pop [lclVar+4]' */

                        genStackLevel -= sizeof(void*);
                        inst_TT(INS_pop, op1, 0);
                        genStackLevel += sizeof(void*);

                        genSinglePop();

                        rsTrackRegTrash(rLo);

                        genStackLevel -= sizeof(void*);
                        inst_TT(INS_pop, op1, 4);
                        genStackLevel += sizeof(void*);

                        genSinglePop();

                        if  (rHi != REG_STK)
                            rsTrackRegTrash(rHi);

                        regMask = genRegPairMask(regPair);
                        goto DONE_ASSG_REGS;
                    }

#endif

                    /* Compute the RHS into desired register pair */

                    if  (rHi != REG_STK)
                    {
                        genComputeRegPair(op2, genRegPairMask(regPair), regPair, false);
                        assert(op2->gtFlags & GTF_REG_VAL);
                        assert(op2->gtRegPair == regPair);
                    }
                    else
                    {
                        regPairNo curPair;
                        regNumber curLo;
                        regNumber curHi;

                        genComputeRegPair(op2, genRegPairMask(regPair)|rsRegMaskFree(), REG_PAIR_NONE, false);

                        assert(op2->gtFlags & GTF_REG_VAL);

                        curPair = op2->gtRegPair;
                        curLo   = genRegPairLo(curPair);
                        curHi   = genRegPairHi(curPair);

                        /* move high first, target is on stack */

#if     TGT_x86

                        inst_TT_RV(INS_mov, op1, curHi, 4);

                        if  (rLo != curLo)
                        {
                            inst_RV_RV(INS_mov, rLo, curLo, TYP_LONG);
                            rsTrackRegCopy(rLo, curLo);
                        }

#elif   TGT_SH3

                        assert(!"need SH-3 code");

#else
#error  Unexpected target
#endif

                    }

                    genReleaseRegPair(op2);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regMask = op2->gtUsedRegs | genRegPairMask(regPair);
#endif
                    goto DONE_ASSG_REGS;
                }
                else
                {

                    /* Is this a dead store? */

                    if  ((varDsc->lvTracked) &&
                         (!(tree->gtLiveSet & genVarIndexToBit(varDsc->lvVarIndex))))
                    {
                        /* Make sure the variable is not volatile */

                        if  (!varDsc->lvVolatile)
                        {
#ifdef DEBUG
                            if  (verbose)
                                printf("Eliminating dead store into #%u\n", varNum);
#endif
                            genEvalSideEffects(op2, 0);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                            regMask = op2->gtUsedRegs;
#endif
                            regPair = REG_PAIR_NONE;
                            goto DONE;
                        }
                    }

#ifdef DEBUGGING_SUPPORT

                    /* For non-debuggable code, every definition of a lcl-var has
                     * to be checked to see if we need to open a new scope for it.
                     */
                    if (opts.compScopeInfo && !opts.compDbgCode && info.compLocalVarsCount>0)
                        siCheckVarScope (varNum, varOffset);

#endif
                }
            }

#if     TGT_x86

            /* Is the value being assigned a constant? */

            if  (op2->gtOper == GT_CNS_LNG)
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, needReg, false);

                /* Move the value into the target */

                inst_TT_IV(INS_mov, op1, (long)(op2->gtLngCon.gtLconVal      ), 0);
                inst_TT_IV(INS_mov, op1, (long)(op2->gtLngCon.gtLconVal >> 32), 4);

                gcMarkRegSetNpt(addrReg);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                tree->gtUsedRegs = op1->gtUsedRegs;
#endif
                return;
            }

            /* Is the value being assigned actually a 'pop' ? */

            if  (op2->gtOper == GT_POP)
            {
                assert(op1->gtOper == GT_LCL_VAR);

                /* Generate 'pop [lclVar+0] ; pop [lclVar+4]' */

                genStackLevel -= sizeof(void*);
                inst_TT(INS_pop, op1, 0);
                genStackLevel += sizeof(void*);

                genSinglePop();

                genStackLevel -= sizeof(void*);
                inst_TT(INS_pop, op1, 4);
                genStackLevel += sizeof(void*);

                genSinglePop();

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                tree->gtUsedRegs = 0;
#endif
                return;
            }

#endif

            /* Eliminate worthless assignment "lcl = lcl" */

            if  (op2->gtOper == GT_LCL_VAR &&
                 op1->gtOper == GT_LCL_VAR && op2->gtLclVar.gtLclNum ==
                                              op1->gtLclVar.gtLclNum)
            {
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                tree->gtUsedRegs = 0;
#endif
                return;
            }

#if     TGT_x86

            if (op2->gtOper  == GT_CAST
                && TYP_ULONG == (var_types)op2->gtOp.gtOp2->gtIntCon.gtIconVal
                && op2->gtOp.gtOp1->gtType <= TYP_INT)
            {
                op2 = op2->gtOp.gtOp1;

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, true, false, true);

                /* Generate the RHS into a register pair */

                genComputeReg(op2, 0, false, false);

                /* Make sure the target is still addressable */

                assert(op2->gtFlags & GTF_REG_VAL);
                reg1    = op2->gtRegNum;
                addrReg = genLockAddressable(op1, genRegMask(reg1), addrReg);

                /* Move the value into the target */

                inst_TT_RV(INS_mov, op1, reg1, 0);
                inst_TT_IV(INS_mov, op1, 0,    4); // Store 0 in hi-word

                /* Free up anything that was tied up by either side */

                genDoneAddressable(op1, addrReg);
                genReleaseReg     (op2);

#if REDUNDANT_LOAD
                if (op1->gtOper == GT_LCL_VAR)
                {
                    /* clear this local from reg table */
                    rsTrashLclLong(op1->gtLclVar.gtLclNum);

                    /* mark RHS registers as containing the local var */
                    rsTrackRegLclVarLng(reg1, op1->gtLclVar.gtLclNum, true);
                }
#endif

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                tree->gtUsedRegs = op1->gtUsedRegs | op2->gtUsedRegs;
#endif
                return;
            }

#endif

            /* Is the LHS more complex than the RHS? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* Generate the RHS into a register pair */

                genComputeRegPair(op2, 0, REG_PAIR_NONE, false);
                assert(op2->gtFlags & GTF_REG_VAL);

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, true);

                /* Make sure the RHS register hasn't been spilled */

                genRecoverRegPair(op2, REG_PAIR_NONE, true);
                assert(op2->gtFlags & GTF_REG_VAL);

                regPair = op2->gtRegPair;

                /* Lock 'op2' and make sure 'op1' is still addressable */

                addrReg = genLockAddressable(op1, genRegPairMask(regPair), addrReg);

                /* Move the value into the target */

                inst_TT_RV(INS_mov, op1, genRegPairLo(regPair), 0);
                inst_TT_RV(INS_mov, op1, genRegPairHi(regPair), 4);

                /* Free up anything that was tied up by either operand */

                genDoneAddressable   (op1, addrReg);
                genReleaseRegPair(op2);
            }
            else
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, true, false, true);

                /* Generate the RHS into a register pair */

                genComputeRegPair(op2, 0, REG_PAIR_NONE, false, false);

                /* Make sure the target is still addressable */

                assert(op2->gtFlags & GTF_REG_VAL);
                regPair = op2->gtRegPair;
                addrReg = genLockAddressable(op1, genRegPairMask(regPair), addrReg);

                /* Move the value into the target */

                inst_TT_RV(INS_mov, op1, genRegPairLo(regPair), 0);
                inst_TT_RV(INS_mov, op1, genRegPairHi(regPair), 4);

                /* Free up anything that was tied up by either side */

                genDoneAddressable   (op1, addrReg);
                genReleaseRegPair(op2);
            }

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regMask = op1->gtUsedRegs | op2->gtUsedRegs;
#endif

        DONE_ASSG_REGS:

#if REDUNDANT_LOAD

            if (op1->gtOper == GT_LCL_VAR)
            {
                /* Clear this local from reg table */

                rsTrashLclLong(op1->gtLclVar.gtLclNum);

                if ((op2->gtFlags & GTF_REG_VAL) &&
                    /* constant has precedence over local */
//                    rsRegValues[op2->gtRegNum].rvdKind != RV_INT_CNS &&
                    tree->gtOper == GT_ASG)
                {
                    regNumber regNo;

                    /* mark RHS registers as containing the local var */

                    if  ((regNo = genRegPairLo(op2->gtRegPair)) != REG_STK)
                        rsTrackRegLclVarLng(regNo, op1->gtLclVar.gtLclNum, true);

                    if  ((regNo = genRegPairHi(op2->gtRegPair)) != REG_STK)
                        rsTrackRegLclVarLng(regNo, op1->gtLclVar.gtLclNum, false);
                }
            }

#endif

            genUpdateLife(tree);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = regMask;
#endif

            return;

#if     TGT_x86

        case GT_SUB: insLo = INS_sub; insHi = INS_sbb; goto BINOP_OVF;
        case GT_ADD: insLo = INS_add; insHi = INS_adc; goto BINOP_OVF;

            bool ovfl;

        BINOP_OVF:
            ovfl = tree->gtOverflow();
            goto _BINOP;

        case GT_AND: insLo =          insHi = INS_and; goto BINOP;
        case GT_OR : insLo =          insHi = INS_or ; goto BINOP;
        case GT_XOR: insLo =          insHi = INS_xor; goto BINOP;

        BINOP: ovfl = false; goto _BINOP;

       _BINOP:

            /* Catch a case where can avoid generating op reg, mem. Better pairing
             * from
             *     mov reg2, mem
             *     op  reg2, reg
             * To avoid problems with order of evaluation, only do this if op2 is
             * a local variable.
             */

            if (GenTree::OperIsCommutative(oper) &&
                op1->gtOper == GT_LCL_VAR &&
                op2->gtOper == GT_LCL_VAR &&
                op1->gtLclVar.gtLclNum != op2->gtLclVar.gtLclNum)
            {
                regPair = rsLclIsInRegPair(op1->gtLclVar.gtLclNum);

                if (regPair != REG_PAIR_NONE)
                {
                    GenTreePtr op = op1;
                    op1 = op2;
                    op2 = op;
                }
            }

            /* The following makes an assumption about gtSetEvalOrder(this) */

            assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

            /* Special case: check for "((long)intval << 32) | longval" */

            if  (oper == GT_OR && op1->gtOper == GT_LSH)
            {
                GenTreePtr      shLHS = op1->gtOp.gtOp1;
                GenTreePtr      shRHS = op1->gtOp.gtOp2;

                if  (shLHS->gtOper == GT_CAST    && genTypeSize(shLHS->gtOp.gtOp1->gtType) == genTypeSize(TYP_INT) &&
                     shRHS->gtOper == GT_CNS_INT && shRHS->gtIntCon.gtIconVal == 32)
                {
                    unsigned        tempReg;

                    /*
                        Generate the following sequence:

                            prepare op1
                            compute op2 into some regpair
                            or regpairhi, op1

                        First we throw away the cast of the first operand.
                     */

                    op1 = shLHS->gtOp.gtOp1;

                    /* Make the first operand addressable */

                    tempReg = needReg;
                    if  (!(tempReg & ~op2->gtRsvdRegs))
                        tempReg = RBM_ALL;

                    addrReg = genMakeAddressable(op1, tempReg & ~op2->gtRsvdRegs, true);

                    /* Generate the second operand into some register pair */

                    genCompIntoFreeRegPair(op2, needReg, false);

                    assert(op2->gtFlags & GTF_REG_VAL);
                    regPair  = op2->gtRegPair;
                    regMask |= genRegPairMask(regPair);
                    reg2     = genRegPairHi(regPair);

                    /* The operand might have interfered with the address */

                    addrReg = genLockAddressable(op1, genRegPairMask(regPair), addrReg);

                    /* The value in the high register is about to be trashed */

                    rsTrackRegTrash(reg2);

                    /* Now compute the result */

                    inst_RV_TT(insHi, reg2, op1, 0);

                    /* Keep track of what registers we've used */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regMask |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif

                    /* Free up anything that was tied up by the LHS */

                    genDoneAddressable(op1, addrReg);

                    /* The result is where the second operand is sitting */

                    genRecoverRegPair(op2, REG_PAIR_NONE, false);

                    regPair = op2->gtRegPair;
                    goto DONE;
                }
            }

            /* Generate the first operand into some register */

            genCompIntoFreeRegPair(op1, needReg, false);
            assert(op1->gtFlags & GTF_REG_VAL);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regMask |= op1->gtUsedRegs;
#endif

            /* Special case: check for "longval | ((long)intval << 32)" */

            if  (oper == GT_OR && op2->gtOper == GT_LSH)
            {
                GenTreePtr      shLHS = op2->gtOp.gtOp1;
                GenTreePtr      shRHS = op2->gtOp.gtOp2;

                if  (shLHS->gtOper == GT_CAST    && genTypeSize(shLHS->gtOp.gtOp1->gtType) == 4 &&
                     shRHS->gtOper == GT_CNS_INT && shRHS->gtIntCon.gtIconVal == 32)
                {
                    /*
                        Generate the following sequence:

                            compute op1 into some regpair (already done)
                            make op2 addressable
                            or regpairhi, op2

                        First we throw away the cast of the shift operand.
                     */

                    op2 = shLHS->gtOp.gtOp1;

                    /* Make the second operand addressable */

                    addrReg = genMakeAddressable(op2, needReg, true);

                    /* Make sure the result is in a free register pair */

                    genRecoverRegPair(op1, REG_PAIR_NONE, true);
                    regPair  = op1->gtRegPair;
                    regMask |= genRegPairMask(regPair);
                    reg2     = genRegPairHi(regPair);

                    /* The operand might have interfered with the address */

                    addrReg = genLockAddressable(op2, genRegPairMask(regPair), addrReg);

                    /* Compute the new value */

                    inst_RV_TT(insHi, reg2, op2, 0);

                    /* The value in the high register has been trashed */

                    rsTrackRegTrash(reg2);

                    goto DONE_OR;
                }
            }

            /* Make the second operand addressable */

            addrReg = genMakeAddressable(op2, needReg, true);

            // UNDONE: If 'op1' got spilled and 'add' happens to be
            // UNDONE: in a register and we have add/mul/and/or/xor,
            // UNDONE: reverse the operands since we can perform the
            // UNDONE: operation directly with the spill temp, e.g.
            // UNDONE: 'add reg2, [temp]'.

            /* Make sure the result is in a free register pair */

            genRecoverRegPair(op1, REG_PAIR_NONE, true);
            regPair  = op1->gtRegPair;
            regMask |= genRegPairMask(regPair);

            reg1     = genRegPairLo(regPair);
            reg2     = genRegPairHi(regPair);

            /* The operand might have interfered with the address */

            addrReg = genLockAddressable(op2, genRegPairMask(regPair), addrReg);

            /* The value in the register pair is about to be trashed */

            rsTrackRegTrash(reg1);
            rsTrackRegTrash(reg2);

            /* Compute the new value */

            doLo =
            doHi = true;

            if  (op2->gtOper == GT_CNS_LNG)
            {
                __int64     icon = op2->gtLngCon.gtLconVal;

                /* Check for "(op1 AND -1)" and "(op1 [X]OR 0)" */

                switch (oper)
                {
                case GT_AND:
                    if  ((int)(icon      ) == -1) doLo = false;
                    if  ((int)(icon >> 32) == -1) doHi = false;

                    if  (!(icon & 0x00000000FFFFFFFF))
                    {
                        genSetRegToIcon(reg1, 0);
                        doLo = false;
                    }

                    if  (!(icon & 0xFFFFFFFF00000000))
                    {
                        /* Just to always set low first*/

                        if  (doLo)
                        {
                            inst_RV_TT(insLo, reg1, op2, 0);
                            doLo = false;
                        }
                        genSetRegToIcon(reg2, 0);
                        doHi = false;
                    }

                    break;

                case GT_OR:
                case GT_XOR:
                    if  (!(icon & 0x00000000FFFFFFFF)) doLo = false;
                    if  (!(icon & 0xFFFFFFFF00000000)) doHi = false;
                    break;
                }
            }

            if (doLo) inst_RV_TT(insLo, reg1, op2, 0);
            if (doHi) inst_RV_TT(insHi, reg2, op2, 4);

        DONE_OR:

            /* Keep track of what registers we've used */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regMask |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif

            /* Free up anything that was tied up by the LHS */

            genDoneAddressable(op2, addrReg);

            /* The result is where the first operand is sitting */

            genRecoverRegPair(op1, REG_PAIR_NONE, false);

            regPair = op1->gtRegPair;

            if (ovfl)
                genCheckOverflow(tree);

            goto DONE;

#if LONG_MATH_REGPARAM

        case GT_MUL:    if (tree->gtOverflow())
                        {
                            if (tree->gtFlags & GTF_UNSIGNED)
                                helper = CPX_ULONG_MUL_OVF; goto MATH;
                            else
                                helper = CPX_LONG_MUL_OVF;  goto MATH;
                        }
                        else
                        {
                            helper = CPX_LONG_MUL;          goto MATH;
                        }

        case GT_DIV:    helper = CPX_LONG_DIV;          goto MATH;
        case GT_UDIV:   helper = CPX_LONG_UDIV;         goto MATH;

        case GT_MOD:    helper = CPX_LONG_MOD;          goto MATH;
        case GT_UMOD:   helper = CPX_LONG_UMOD;         goto MATH;

        MATH:

            // UNDONE: Be smarter about the choice of register pairs

            /* Which operand are we supposed to compute first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* Compute the second operand into ECX:EBX */

                genComputeRegPair(op2, RBM_PAIR_ECXEBX, REG_PAIR_ECXEBX, false, false);
                assert(op2->gtFlags & GTF_REG_VAL);
                assert(op2->gtRegNum == REG_PAIR_ECXEBX);

                /* Compute the first  operand into EAX:EDX */

                genComputeRegPair(op1, RBM_PAIR_EAXEDX, REG_PAIR_EAXEDX, false, false);
                assert(op1->gtFlags & GTF_REG_VAL);
                assert(op1->gtRegNum == REG_PAIR_EAXEDX);

                /* Lock EDX:EAX so that it doesn't get trashed */

                assert((rsMaskLock &  RBM_EDX) == 0);
                        rsMaskLock |= RBM_EDX;
                assert((rsMaskLock &  RBM_EAX) == 0);
                        rsMaskLock |= RBM_EAX;

                /* Make sure the second operand hasn't been displaced */

                genRecoverRegPair(op2, REG_PAIR_ECXEBX, true);

                /* We can unlock EDX:EAX now */

                assert((rsMaskLock &  RBM_EDX) != 0);
                        rsMaskLock -= RBM_EDX;
                assert((rsMaskLock &  RBM_EAX) != 0);
                        rsMaskLock -= RBM_EAX;
            }
            else
            {
                // Special case: both operands promoted from int
                // i.e. (long)i1 * (long)i2.

                if (oper == GT_MUL
                    && op1->gtOper             == GT_CAST
                    && op2->gtOper             == GT_CAST
                    && op1->gtOp.gtOp1->gtType == TYP_INT
                    && op2->gtOp.gtOp1->gtType == TYP_INT)
                {
                    /* Bash to an integer multiply temporarily */

                    tree->gtOp.gtOp1 = op1->gtOp.gtOp1;
                    tree->gtOp.gtOp2 = op2->gtOp.gtOp1;
                    tree->gtType     = TYP_INT;
                    genCodeForTree(tree, 0);
                    tree->gtType     = TYP_LONG;

                    /* The result is now in EDX:EAX */

                    regPair  = REG_PAIR_EAXEDX;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regMask |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif

                    goto DONE;
                }
                else
                {
                    /* Compute the first  operand into EAX:EDX */

                    genComputeRegPair(op1, RBM_PAIR_EAXEDX, REG_PAIR_EAXEDX, false, false);
                    assert(op1->gtFlags & GTF_REG_VAL);
                    assert(op1->gtRegNum == REG_PAIR_EAXEDX);

                    /* Compute the second operand into ECX:EBX */

                    genComputeRegPair(op2, RBM_PAIR_ECXEBX, REG_PAIR_ECXEBX, false, false);
                    assert(op2->gtRegNum == REG_PAIR_ECXEBX);
                    assert(op2->gtFlags & GTF_REG_VAL);

                    /* Lock ECX:EBX so that it doesn't get trashed */

                    assert((rsMaskLock &  RBM_EBX) == 0);
                            rsMaskLock |= RBM_EBX;
                    assert((rsMaskLock &  RBM_ECX) == 0);
                            rsMaskLock |= RBM_ECX;

                    /* Make sure the first operand hasn't been displaced */

                    genRecoverRegPair(op1, REG_PAIR_EAXEDX, true);

                    /* We can unlock ECX:EBX now */

                    assert((rsMaskLock &  RBM_EBX) != 0);
                            rsMaskLock -= RBM_EBX;
                    assert((rsMaskLock &  RBM_ECX) != 0);
                            rsMaskLock -= RBM_ECX;
                }
            }

            /* Perform the math by calling a helper function */

            assert(op1->gtRegNum == REG_PAIR_EAXEDX);
            assert(op2->gtRegNum == REG_PAIR_ECXEBX);

#if TGT_RISC
            assert(genNonLeaf);
#endif

            genEmitHelperCall(CPX,
                             2*sizeof(__int64), // argSize
                             sizeof(void*));    // retSize

            /* The values in both register pairs now trashed */

            rsTrackRegTrash(REG_EAX);
            rsTrackRegTrash(REG_EDX);
            rsTrackRegTrash(REG_EBX);
            rsTrackRegTrash(REG_ECX);

            /* Release both operands */

            genReleaseRegPair(op1);
            genReleaseRegPair(op2);

            assert(op1->gtFlags & GTF_REG_VAL);
            regPair  = op1->gtRegPair;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regMask |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif
            goto DONE;

#else

        case GT_MUL:

            /* Special case: both operands promoted from int */

            assert(op1->gtOper             == GT_CAST);
            assert(op1->gtOp.gtOp1->gtType == TYP_INT);

            assert(!tree->gtOverflow()); // Overflow-bit cleared by morpher

            if (op2->gtOper == GT_CAST)
            {
                assert(op2->gtOp.gtOp1->gtType == TYP_INT);
                tree->gtOp.gtOp2 = op2->gtOp.gtOp1;
            }
            else
            {
                assert(op2->gtOper == GT_CNS_LNG &&
                       (long)((int)op2->gtLngCon.gtLconVal) == op2->gtLngCon.gtLconVal);

                /* bash it to an intCon node */

                op2->gtOper = GT_CNS_INT;
                op2->gtIntCon.gtIconVal = (long)op2->gtLngCon.gtLconVal;
                op2->gtType = TYP_INT;
            }

            /* Bash to an integer multiply temporarily */

            tree->gtType     = TYP_INT;
            tree->gtOp.gtOp1 = op1->gtOp.gtOp1;

            tree->gtFlags |= GTF_MUL_64RSLT;
            genCodeForTree(tree, 0);

            assert(tree->gtFlags & GTF_REG_VAL);
            assert(tree->gtRegNum == REG_EAX);

            tree->gtType     = TYP_LONG;
            tree->gtOp.gtOp1 = op1;
            tree->gtOp.gtOp2 = op2;

            /* The result is now in EDX:EAX */

            regPair  = REG_PAIR_EAXEDX;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regMask |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif

            goto DONE;

#endif
        case GT_LSH: helper = CPX_LONG_LSH; goto SHIFT;
        case GT_RSH: helper = CPX_LONG_RSH; goto SHIFT;
        case GT_RSZ: helper = CPX_LONG_RSZ; goto SHIFT;

        SHIFT:

            assert(op1->gtType == TYP_LONG);
            assert(genActualType(op2->gtType) == TYP_INT);

            /* Is the second operand a small constant? */

            if  (op2->gtOper == GT_CNS_INT && op2->gtIntCon.gtIconVal >= 0
                                           && op2->gtIntCon.gtIconVal <= 32)
            {
                long        count = op2->gtIntCon.gtIconVal;

                /* Compute the left operand into a free register pair */

                genCompIntoFreeRegPair(op1, needReg, true);
                assert(op1->gtFlags & GTF_REG_VAL);
                regPair = op1->gtRegPair;
                reg1    = genRegPairLo(regPair);
                reg2    = genRegPairHi(regPair);

                /* Generate the appropriate shift instructions */

                if (count == 32)
                {
                   switch (oper)
                   {
                   case GT_LSH:
                       inst_RV_RV     (INS_mov , reg2, reg1);
                       genSetRegToIcon(reg1, 0);
                       break;

                   case GT_RSH:
                       inst_RV_RV     (INS_mov , reg1, reg2);

                       /* Propagate sign bit in high dword */

                       inst_RV_SH     (INS_sar , reg2, 31);
                       break;

                   case GT_RSZ:
                       inst_RV_RV     (INS_mov , reg1, reg2);
                       genSetRegToIcon(reg2, 0);
                       break;
                   }
                }
                else
                {
                   switch (oper)
                   {
                   case GT_LSH:
                       inst_RV_RV_IV(INS_shld, reg2, reg1, count);
                       inst_RV_SH   (INS_shl , reg1,       count);
                       break;

                   case GT_RSH:
                       inst_RV_RV_IV(INS_shrd, reg1, reg2, count);
                       inst_RV_SH   (INS_sar , reg2,       count);
                       break;

                   case GT_RSZ:
                       inst_RV_RV_IV(INS_shrd, reg1, reg2, count);
                       inst_RV_SH   (INS_shr , reg2,       count);
                       break;
                   }
                }

                /* The value in the register pair is trashed */

                rsTrackRegTrash(reg1);
                rsTrackRegTrash(reg2);

                goto DONE_SHF;
            }

            /* Which operand are we supposed to compute first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* The second operand can't be a constant */

                assert(op2->gtOper != GT_CNS_INT);

                /* Compute the shift count into ECX */

                genComputeReg(op2, RBM_ECX, true, false);

                /* Compute the left operand into EAX:EDX */

                genComputeRegPair(op1, RBM_PAIR_EAXEDX, REG_PAIR_EAXEDX, false, false);
                assert(op1->gtFlags & GTF_REG_VAL);

                /* Lock EAX:EDX so that it doesn't get trashed */

                assert((rsMaskLock &  (RBM_EAX|RBM_EDX)) == 0);
                        rsMaskLock |= (RBM_EAX|RBM_EDX);

                /* Make sure the shift count wasn't displaced */

                genRecoverReg(op2, RBM_ECX, true);

                /* We can now unlock EAX:EDX */

                assert((rsMaskLock &  (RBM_EAX|RBM_EDX)) == (RBM_EAX|RBM_EDX));
                        rsMaskLock -= (RBM_EAX|RBM_EDX);
            }
            else
            {
                /* Compute the left operand into EAX:EDX */

                genComputeRegPair(op1, RBM_PAIR_EAXEDX, REG_PAIR_EAXEDX, false, false);
                assert(op1->gtFlags & GTF_REG_VAL);

                /* Compute the shift count into ECX */

                genComputeReg(op2, RBM_ECX, true, false);

                /* Lock ECX so that it doesn't get trashed */

                assert((rsMaskLock &  RBM_ECX) == 0);
                        rsMaskLock |= RBM_ECX;

                /* Make sure the value hasn't been displaced */

                genRecoverRegPair(op1, REG_PAIR_EAXEDX, true);

                /* We can unlock ECX now */

                assert((rsMaskLock &  RBM_ECX) != 0);
                        rsMaskLock -= RBM_ECX;
            }

            /* Perform the shift by calling a helper function */

            assert(op1->gtRegNum == REG_PAIR_EAXEDX);
            assert(op2->gtRegNum == REG_ECX);

#if TGT_RISC
            assert(genNonLeaf);
#endif

            genEmitHelperCall(helper,
                             0,             // argSize
                             sizeof(void*));// retSize

            /* The value in the register pair is trashed */

            rsTrackRegTrash(REG_EAX);
            rsTrackRegTrash(REG_EDX);

            /* Release both operands */

            genReleaseRegPair(op1);
            genReleaseReg    (op2);

        DONE_SHF:

            assert(op1->gtFlags & GTF_REG_VAL);
            regPair  = op1->gtRegPair;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regMask |= op1->gtUsedRegs | op2->gtUsedRegs;
#endif
            goto DONE;

        case GT_NEG:
        case GT_NOT:

            /* Generate the operand into some register pair */

            genCompIntoFreeRegPair(op1, needReg, true);
            assert(op1->gtFlags & GTF_REG_VAL);

            regPair  = op1->gtRegPair;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regMask |= op1->gtUsedRegs;
#endif

            /* Figure out which registers the value is in */

            reg1 = genRegPairLo(regPair);
            reg2 = genRegPairHi(regPair);

            /* The value in the register pair is about to be trashed */

            rsTrackRegTrash(reg1);
            rsTrackRegTrash(reg2);

            if  (oper == GT_NEG)
            {
                /* Unary "neg": negate the value  in the register pair */

                inst_RV   (INS_neg, reg1, TYP_LONG);
                inst_RV_IV(INS_adc, reg2, 0);
                inst_RV   (INS_neg, reg2, TYP_LONG);
            }
            else
            {
                /* Unary "not": flip all the bits in the register pair */

                inst_RV   (INS_not, reg1, TYP_LONG);
                inst_RV   (INS_not, reg2, TYP_LONG);
            }

            goto DONE;

#if LONG_ASG_OPS

        case GT_ASG_OR : insLo =          insHi = INS_or ; goto ASG_OPR;
        case GT_ASG_XOR: insLo =          insHi = INS_xor; goto ASG_OPR;
        case GT_ASG_AND: insLo =          insHi = INS_and; goto ASG_OPR;
        case GT_ASG_SUB: insLo = INS_sub; insHi = INS_sbb; goto ASG_OPR;
        case GT_ASG_ADD: insLo = INS_add; insHi = INS_adc; goto ASG_OPR;

        ASG_OPR:

            if  (op2->gtOper == GT_CNS_LNG)
            {
                __int64     lval = op2->gtLngCon.gtLconVal;

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, needReg, false);

                /* Optimize some special cases */

                doLo =
                doHi = true;

                /* Check for "(op1 AND -1)" and "(op1 [X]OR 0)" */

                switch (oper)
                {
                case GT_AND:
                    if  ((int)(lval      ) == -1) doLo = false;
                    if  ((int)(lval >> 32) == -1) doHi = false;
                    break;

                case GT_OR:
                case GT_XOR:
                    if  (!(lval & 0x00000000FFFFFFFF)) doLo = false;
                    if  (!(lval & 0xFFFFFFFF00000000)) doHi = false;
                    break;
                }

                if (doLo) inst_TT_IV(insLo, op1, (long)(lval      )   );
                if (doHi) inst_TT_IV(insHi, op1, (long)(lval >> 32), 4);

                op1->gtFlags |= GTF_CC_SET;

                gcMarkRegSetNpt(addrReg);
                goto DONE_ASSG_REGS;
            }

            /* UNDONE: allow non-const long assignment operators */

            assert(!"non-const long asgop NYI");

#endif

        case GT_IND:

//            assert(op1->gtType == TYP_REF   ||
//                   op1->gtType == TYP_BYREF || (op1->gtFlags & GTF_NON_GC_ADDR));

            {
                unsigned    tmpMask;
                int         hiFirst;

                unsigned    regMask = RBM_ALL & ~needReg;

                /* Make sure the operand is addressable */

                addrReg = genMakeAddressable(tree, regMask, false);

                /* Pick a register for the value */

                regPair = rsPickRegPair(needReg);
                tmpMask = genRegPairMask(regPair);

                /* Is there any overlap between the register pair and the address? */

                hiFirst = FALSE;

                if  (tmpMask & addrReg)
                {
                    /* Does one or both of the target registers overlap? */

                    if  ((tmpMask & addrReg) != tmpMask)
                    {
                        /* Only one register overlaps */

                        assert(genOneBitOnly(tmpMask & addrReg) == TRUE);

                        /* If the low register overlaps, load the upper half first */

                        if  (addrReg & genRegMask(genRegPairLo(regPair)))
                            hiFirst = TRUE;
                    }
                    else
                    {
                        unsigned    regFree;

                        /* The register completely overlaps with the address */

                        assert(genOneBitOnly(tmpMask & addrReg) == FALSE);

                        /* Can we pick another pair easily? */

                        regFree = rsRegMaskFree() & ~addrReg;
                        if  (needReg)
                            regFree &= needReg;

                        /* More than one free register available? */

                        if  (regFree && !genOneBitOnly(regFree))
                        {
                            regPair = rsPickRegPair(regFree);
                            tmpMask = genRegPairMask(regPair);
                        }
                        else
                        {
//                          printf("Overlap: needReg = %08X\n", needReg);

                            // Reg-prediction wont allow this
                            assert((rsMaskVars & addrReg) == 0);

                            // Grab one fresh reg, and use any one of addrReg

                            regNumber reg1, reg2;

                            if (regFree)    // Try to follow 'needReg'
                                reg1 = rsGrabReg(regFree);
                            else            // Pick any reg besides addrReg
                                reg1 = rsGrabReg(RBM_ALL & ~addrReg);

                            unsigned regMask = 0x1;
                            for (unsigned regNo = 0; regNo < REG_COUNT; regNo++, regMask <<= 1)
                            {
                                if (regMask & addrReg)
                                {
                                    // Found one of addrReg. Use it.
                                    reg2 = (regNumber)regNo;
                                    break;
                                }
                            }
                            assert(genIsValidReg((regNumber)regNo)); // Should have found reg2

                            regPair = gen2regs2pair(reg1, reg2);
                            tmpMask = genRegPairMask(regPair);
                        }
                    }
                }

                /* Make sure the value is still addressable */

                assert(genStillAddressable(tree));

                /* Figure out which registers the value is in */

                reg1 = genRegPairLo(regPair);
                reg2 = genRegPairHi(regPair);

                /* The value in the register pair is about to be trashed */

                rsTrackRegTrash(reg1);
                rsTrackRegTrash(reg2);

                /* Load the target registers from where the value is */

                if  (hiFirst)
                {
                    inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, reg2, op1, 4);
                    inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, reg1, op1, 0);
                }
                else
                {
                    inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, reg1, op1, 0);
                    inst_RV_AT(INS_mov, EA_4BYTE, TYP_INT, reg2, op1, 4);
                }

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regMask |= tmpMask | tree->gtUsedRegs;
#endif

                genUpdateLife(tree);
                gcMarkRegSetNpt(addrReg);

            }
            goto DONE;

        case GT_CAST:

            /* What are we casting from? */

            switch (op1->gtType)
            {
            case TYP_BYTE:
            case TYP_CHAR:
            case TYP_SHORT:
            case TYP_INT:
            case TYP_UBYTE:

                // For ULong, we dont need to sign-extend the 32 bit value

                if (tree->gtFlags & GTF_UNSIGNED)
                {
                    genComputeReg(op1, needReg, false, false);
                    assert(op1->gtFlags & GTF_REG_VAL);

                    reg2 = op1->gtRegNum;

                    unsigned hiRegMask = (needReg!=0) ? needReg

                                                      : rsRegMaskFree();
                    rsLockUsedReg  (genRegMask(reg2));
                    reg1 = rsPickReg(hiRegMask);
                    rsUnlockUsedReg(genRegMask(reg2));

                    // Move 0 to the higher word of the ULong
                    genSetRegToIcon(reg1, 0, TYP_INT);

                    /* We can now free up the operand */

                    genReleaseReg(op1);

                    regPair = gen2regs2pair(reg2, reg1);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                    regMask |= genRegPairMask(regPair) | op1->gtUsedRegs;
#endif
                    goto DONE;
                }

                /* Cast of 'int' to 'long' --> Use cdq if EAX,EDX are available and
                   we need the result to be in those registers. cdq has a smaller
                   encoding but is slightly slower than sar */

                if  (!opts.compFastCode &&
                     (needReg & (RBM_EAX|RBM_EDX)) == (RBM_EAX|RBM_EDX))
                {
                    genComputeReg(op1, RBM_EAX, true, false, true);

                    /* Can we use EAX,EDX for the cdq. */

                    if (op1->gtRegNum != REG_EAX)
                        goto USE_SAR_FOR_CAST;

                    /* If we have to spill EDX, might as well use the faster
                       sar as the spill will increase code size anyway */

                    if ((rsRegMaskFree() & RBM_EDX) == 0)
                    {
                        if (rsRegMaskFree() || !(rsRegMaskCanGrab() & RBM_EDX))
                            goto USE_SAR_FOR_CAST;
                    }

                    rsGrabReg      (RBM_EDX);
                    rsTrackRegTrash(REG_EDX);

                    /* Convert the int in EAX into a long in EDX:EAX */

                    instGen(INS_cdq);

                    /* The result is in EDX:EAX */

                    regPair  = REG_PAIR_EAXEDX;
                    regMask |= RBM_PAIR_EAXEDX;
                }
                else
                {
                    genComputeReg(op1, needReg, false, false);

                USE_SAR_FOR_CAST:

                    assert(op1->gtFlags & GTF_REG_VAL);
                    reg1 = op1->gtRegNum;

                    /* Pick a register for the upper half result */

                    rsLockUsedReg(genRegMask(reg1));
                    reg2    = rsPickReg(needReg);
                    rsUnlockUsedReg(genRegMask(reg1));

                    regPair = gen2regs2pair(reg1, reg2);

                    /* Copy reg1 to reg2 and promote it */

                    inst_RV_RV(INS_mov, reg2, reg1, TYP_INT);
                    inst_RV_SH(INS_sar, reg2, 31);

                    /* The value in the upper register is trashed */

                    rsTrackRegTrash(reg2);
                }

                /* We can now free up the operand */
                genReleaseReg(op1);

                // conv.ovf.u8 could overflow if the original number was negative
                if (tree->gtOverflow() && TYP_ULONG == (var_types)op2->gtIntCon.gtIconVal)
                {
                    AddCodeDsc * add = fgFindExcptnTarget(ACK_OVERFLOW, compCurBB->bbTryIndex);
                    assert(add && add->acdDstBlk);
                    BasicBlock * throwBlock = add->acdDstBlk;

                    regNumber hiReg = genRegPairHi(regPair);
                    inst_RV_RV(INS_test, hiReg, hiReg);         // set flags
                    inst_JMP(EJ_jl, throwBlock, true, true, true);
                }
                goto DONE;

            case TYP_FLOAT:
            case TYP_DOUBLE:

#if 0
                /* Load the FP value onto the coprocessor stack */

                genCodeForTreeFlt(op1, false);

                /* Allocate a temp for the long value */

                temp = tmpGetTemp(TYP_LONG);

                /* Store the FP value into the temp */

                inst_FS_ST(INS_fistpl, sizeof(long), temp, 0);
                genTmpAccessCnt++;
                genFPstkLevel--;

                /* Pick a register pair for the value */

                regPair  = rsPickRegPair(needReg);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                regMask |= genRegPairMask(regPair) | op1->gtUsedRegs;
#endif

                /* Figure out which registers the value is in */

                reg1 = genRegPairLo(regPair);
                reg2 = genRegPairHi(regPair);

                /* The value in the register pair is about to be trashed */

                rsTrackRegTrash(reg1);
                rsTrackRegTrash(reg2);

                /* Load the converted value into the registers */

                inst_RV_ST(INS_mov, EA_4BYTE, reg1, temp, 0);
                inst_RV_ST(INS_mov, EA_4BYTE, reg2, temp, 4);
                genTmpAccessCnt += 2;

                /* We no longer need the temp */

                tmpRlsTemp(temp);
                goto DONE;
#else
                assert(!"this cast supposed to be done via a helper call");
#endif
            case TYP_LONG:
            case TYP_ULONG:

                if (tree->gtOverflow()) // conv.ovf.u8 or conv.ovf.i8
                {
                    /* Find the block which throws the overflow exception */
                    AddCodeDsc * add = fgFindExcptnTarget(ACK_OVERFLOW, compCurBB->bbTryIndex);
                    assert(add && add->acdDstBlk);
                    BasicBlock * throwBlock = add->acdDstBlk;

                    genCodeForTreeLng(op1, needReg);
                    regPair = op1->gtRegPair;

                    // Do we need to set the sign-flag, or can be check if it
                    // set, and not do this "test" if so.

                    if (op1->gtFlags & GTF_REG_VAL)
                    {
                        regNumber hiReg = genRegPairHi(op1->gtRegPair);
                        inst_RV_RV(INS_test, hiReg, hiReg);
                    }
                    else
                    {
                        inst_TT_IV(INS_cmp, op1, 0, sizeof(int));
                    }

                    inst_JMP(EJ_jl, throwBlock, true, true, true); // SHRI
                    goto DONE;
                }

            default:
#ifdef  DEBUG
                gtDispTree(tree);
#endif
                assert(!"unexpected cast to long");
            }

#endif//TGT_x86

        case GT_RETURN:

            /* There must be a long return value */

            assert(op1);

            /* Evaluate the return value into EDX:EAX */

            genEvalIntoFreeRegPair(op1, REG_LNGRET);

            assert(op1->gtFlags & GTF_REG_VAL);
            assert(op1->gtRegNum == REG_LNGRET);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = op1->gtUsedRegs;
#endif

            return;

#if     TGT_x86
#if OPTIMIZE_QMARK

#if INLINING
        case GT_QMARK:
            assert(!"inliner-generated ?: for longs NYI");
            goto DONE;
#endif

        case GT_BB_COLON:

            /* CONSIDER: Don't always load the value into EDX:EAX! */

            genEvalIntoFreeRegPair(op1, REG_LNGRET);

            /* The result must now be in EDX:EAX */

            assert(op1->gtFlags & GTF_REG_VAL);
            assert(op1->gtRegNum == REG_LNGRET);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = op1->gtUsedRegs;
#endif
            return;

#endif //OPTIMIZE_QMARK
#endif //TGT_x86

        case GT_COMMA:

            assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

            /* Generate side effects of the first operand */

            genEvalSideEffects(op1, 0);
            genUpdateLife (op1);

            /* Now generate the second operand, i.e. the 'real' value */

            genCodeForTreeLng(op2, needReg);

            /* The result of 'op2' is also the final result */

            regPair = op2->gtRegPair;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            regMask = op1->gtUsedRegs | op2->gtUsedRegs;
#endif

            goto DONE;
        }

#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected 64-bit operator");
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
        unsigned        useCall;

    case GT_CALL:
        regPair = (regPairNo)genCodeForCall(tree, true, &useCall); regMask |= useCall;
        break;

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected long operator");
    }

DONE:

    genUpdateLife(tree);

    /* Here we've computed the value of 'tree' into 'regPair' */

    assert(regPair != 0xFEEFFAAF);
    assert(regMask != 0xFEEFFAAF);

    tree->gtFlags   |= GTF_REG_VAL;
    tree->gtRegPair  = regPair;
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    tree->gtUsedRegs = regMask;
#endif
}

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  A register FP variable is being evaluated and this is the final reference
 *  to it (i.e. it's dead after this node and needs to be popped off the x87
 *  stack). We try to remove the variable from the stack now, but in some
 *  cases we can't do it and it has to be postponed.
 */

void                Compiler::genFPregVarLoadLast(GenTreePtr tree)
{
    assert(tree->gtOper   == GT_REG_VAR);
    assert(tree->gtRegNum == 0);
    assert(tree->gtFlags & GTF_REG_DEATH);


    /* Is the variable dying at the bottom of the FP stack? */

    if  (genFPstkLevel == 0)
    {
        /* Just leave the last copy of the variable on the stack */
    }
    else
    {
        if  (genFPstkLevel == 1)
        {
            /* Swap the variable's value into place */

            inst_FN(INS_fxch, 1);
        }
        else
        {
            /* We'll have to kill the variable later ... */

            inst_FN(INS_fld, tree->gtRegNum + genFPstkLevel);
            genFPstkLevel++;
            return;
        }
    }

    /* Record the fact that 'tree' is now dead */

    genFPregVarDeath(tree);

    genFPstkLevel++;
    return;
}

/*****************************************************************************
 *
 *  One or more FP register variables have died without us noticing, so we
 *  need to pop them now before it's too late. The argument gives the final
 *  desired FP regvar count (i.e. we must have more than 'newCnt' currently
 *  and will pop enough to reach that value).
 */

void                Compiler::genFPregVarKill(unsigned newCnt, bool saveTOS)
{
    int         popCnt = genFPregCnt - newCnt; assert(popCnt > 0);

#ifdef DEBUG
    // So that compFPregVarName() will work
    int oldStkLvl  = genFPstkLevel;
    genFPstkLevel += (genFPregCnt - newCnt);
#endif

    if (saveTOS)
    {
        do
        {
            inst_FS(INS_fstp ,  1);
            popCnt      -= 1;
            genFPregCnt -= 1;
        }
        while (popCnt);
    }
    else
    {
        do
        {
            if  (popCnt > 1)
            {
                inst_FS(INS_fcompp,  1);
                popCnt      -= 2;
                genFPregCnt -= 2;
            }
            else
            {
                inst_FS(INS_fstp ,  0);
                popCnt      -= 1;
                genFPregCnt -= 1;
            }
        }
        while (popCnt);
    }

#ifdef DEBUG
    genFPstkLevel = oldStkLvl;
#endif
}

/*****************************************************************************
 *
 *  Called whenever we see a tree node which is an enregistered FP var
 *  going live.
 */

void                Compiler::genFPregVarBirth(GenTreePtr   tree)
{
    unsigned        varNum  = tree->gtRegVar.gtRegVar;
    VARSET_TP       varBit  = raBitOfRegVar(tree);

    assert((tree->gtOper == GT_REG_VAR) && (tree->gtFlags & GTF_REG_BIRTH));
    assert(tree->gtRegVar.gtRegNum == 0);
    assert(varBit & optAllFPregVars);

    assert(lvaTable[varNum].lvType == TYP_DOUBLE);
    assert(lvaTable[varNum].lvRegister);

#ifdef  DEBUG
    if  (verbose) printf("[%08X]: FP regvar #%u born\n", tree, varNum);
#endif

    /* Mark the target variable as live */

    genFPregVars |= ~varBit;

    /* The first assert is more correct but doesnt always work as we dont
     * always kill vars immediately. Sometimes we do it in genChkFPregVarDeath()
     */
//  assert(genFPregCnt == (unsigned)lvaTable[varNum].lvRegNum);

    genFPregCnt++;

#if defined(DEBUGGING_SUPPORT) || defined(LATE_DISASM)

    /* For optimized code, open a new scope */

    if (opts.compDbgInfo && !opts.compDbgCode)
    {
        siNewScopeNear(varNum, compCurBB->bbCodeOffs);
    }

#endif

}

/*****************************************************************************
 * Called whenever we see a tree node which is an enregistered FP var
 * going dead
 */

void            Compiler::genFPregVarDeath(GenTreePtr   tree)
{
    unsigned        varNum = tree->gtRegVar.gtRegVar;
    VARSET_TP       varBit = raBitOfRegVar(tree);

    assert((tree->gtOper == GT_REG_VAR) && (tree->gtFlags & GTF_REG_DEATH));
    assert(varBit & optAllFPregVars);

    assert(lvaTable[varNum].lvType == TYP_DOUBLE);
    assert(lvaTable[varNum].lvRegister);

#ifdef DEBUG
    if  (verbose)
        printf("[%08X]: FP regvar #%u dies at stklvl %u\n", tree, varNum, genFPstkLevel);
#endif

    /* Record the fact that 'varNum' is now dead */

    genFPregVars &= ~varBit;
    genFPregCnt--;

    /* The first assert is more correct but doesnt always work as we dont
     * always kill vars immediately. Sometimes we do it in genChkFPregVarDeath()
     */
//  assert(genFPregCnt >= (unsigned)lvaTable[varNum].lvRegNum);

#if defined(DEBUGGING_SUPPORT) || defined(LATE_DISASM)

    /* For optimized code, close existing open scope */

    if (opts.compDbgInfo && !opts.compDbgCode)
    {
        siEndScope(varNum);
    }

#endif

}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#if     CPU_HAS_FP_SUPPORT
/*****************************************************************************
 *
 *  Generate code for a floating-point operation.
 */

void                Compiler::genCodeForTreeFlt(GenTreePtr  tree,
                                                bool        roundResult)
{
    genTreeOps      oper;
    unsigned        kind;

    assert(tree);
    assert(tree->gtOper != GT_STMT);
    assert(tree->gtType == TYP_FLOAT || tree->gtType == TYP_DOUBLE);

    /* Assume we won't use any GP registers */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    tree->gtUsedRegs = 0;
#endif

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

#if     TGT_x86

    /* There better not be any calls if the FP stack is non-empty */

    assert(genFPstkLevel == 0 || !(tree->gtFlags & GTF_CALL));

    /* We must not overflow the stack */

    assert(genFPstkLevel + genFPregCnt < FP_STK_SIZE);

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
    {
        GenTreePtr      fval;

        switch (oper)
        {
        case GT_CNS_FLT:

            /* Special case: the constants 0 and 1 */

            if  (*((long *)&(tree->gtFltCon.gtFconVal)) == 0x3f800000)
            {
                instGen(INS_fld1);
                genFPstkLevel++;
                return;
            }

            if  (*((long *)&(tree->gtFltCon.gtFconVal)) == 0)
            {
                instGen(INS_fldz);
                genFPstkLevel++;
                return;
            }

            fval = genMakeConst(&tree->gtFltCon.gtFconVal, sizeof(float ), tree->gtType, tree, true);
            break;

        case GT_CNS_DBL:

            /* Special case: the constants 0 and 1 */

            if  (*((__int64 *)&(tree->gtDblCon.gtDconVal)) == 0x3ff0000000000000)
            {
                instGen(INS_fld1);
                genFPstkLevel++;
                return;
            }

            if  (*((__int64 *)&(tree->gtDblCon.gtDconVal)) == 0)
            {
                instGen(INS_fldz);
                genFPstkLevel++;
                return;
            }

            fval = genMakeConst(&tree->gtDblCon.gtDconVal, sizeof(double), tree->gtType, tree, true);
            break;

        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"bogus float const");
        }

        inst_FS_TT(INS_fld, fval);
        genFPstkLevel++;
        return;
    }

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        switch (oper)
        {
        case GT_LCL_VAR:
            inst_FS_TT(INS_fld, tree);
            genFPstkLevel++;
            return;

        case GT_REG_VAR:
            genFPregVarLoad(tree);
            return;

        case GT_CLS_VAR:
            inst_FS_TT(INS_fld, tree);
            genFPstkLevel++;
            return;

#if OPTIMIZE_QMARK
        case GT_BB_QMARK:
            /* Simply pretend the value is already pushed on the FP stack */
            genFPstkLevel++;
            return;
#endif

        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"unexpected leaf");
        }
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        TempDsc  *      temp;

        GenTreePtr      top;
        GenTreePtr      opr;

        unsigned        addrReg;

        int             size;
        int             offs;

#if ROUND_FLOAT
        bool            roundTop;
#endif

        GenTreePtr      op1 = tree->gtOp.gtOp1;
        GenTreePtr      op2 = tree->gtOp.gtOp2;

static  BYTE            FPmathNN[] = { INS_fadd , INS_fsub  , INS_fmul , INS_fdiv   };
static  BYTE            FPmathNP[] = { INS_faddp, INS_fsubp , INS_fmulp, INS_fdivp  };
static  BYTE            FPmathRN[] = { INS_fadd , INS_fsubr , INS_fmul , INS_fdivr  };
static  BYTE            FPmathRP[] = { INS_faddp, INS_fsubrp, INS_fmulp, INS_fdivrp };

#ifdef  DEBUG
        addrReg = 0xDDDD;
#endif

        switch (oper)
        {
            instruction     ins_NN;
            instruction     ins_RN;
            instruction     ins_RP;
            instruction     ins_NP;

        case GT_ADD:
        case GT_SUB:
        case GT_MUL:
        case GT_DIV:

#ifdef DEBUG
            /* For risc code there better be two slots available */
            if (riscCode)
                assert(genFPstkLevel + genFPregCnt < FP_STK_SIZE - 1);
#endif

            /* Make sure the instruction tables look correctly ordered */

            assert(FPmathNN[GT_ADD - GT_ADD] == INS_fadd  );
            assert(FPmathNN[GT_SUB - GT_ADD] == INS_fsub  );
            assert(FPmathNN[GT_MUL - GT_ADD] == INS_fmul  );
            assert(FPmathNN[GT_DIV - GT_ADD] == INS_fdiv  );

            assert(FPmathNP[GT_ADD - GT_ADD] == INS_faddp );
            assert(FPmathNP[GT_SUB - GT_ADD] == INS_fsubp );
            assert(FPmathNP[GT_MUL - GT_ADD] == INS_fmulp );
            assert(FPmathNP[GT_DIV - GT_ADD] == INS_fdivp );

            assert(FPmathRN[GT_ADD - GT_ADD] == INS_fadd  );
            assert(FPmathRN[GT_SUB - GT_ADD] == INS_fsubr );
            assert(FPmathRN[GT_MUL - GT_ADD] == INS_fmul  );
            assert(FPmathRN[GT_DIV - GT_ADD] == INS_fdivr );

            assert(FPmathRP[GT_ADD - GT_ADD] == INS_faddp );
            assert(FPmathRP[GT_SUB - GT_ADD] == INS_fsubrp);
            assert(FPmathRP[GT_MUL - GT_ADD] == INS_fmulp );
            assert(FPmathRP[GT_DIV - GT_ADD] == INS_fdivrp);

            /* Are we supposed to generate operand 2 first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                top    = op2;
                opr    = op1;

                ins_NN = (instruction)FPmathRN[oper - GT_ADD];
                ins_NP = (instruction)FPmathRP[oper - GT_ADD];
                ins_RN = (instruction)FPmathNN[oper - GT_ADD];
                ins_RP = (instruction)FPmathNP[oper - GT_ADD];
            }
            else
            {
                top    = op1;
                opr    = op2;

                ins_NN = (instruction)FPmathNN[oper - GT_ADD];
                ins_NP = (instruction)FPmathNP[oper - GT_ADD];
                ins_RN = (instruction)FPmathRN[oper - GT_ADD];
                ins_RP = (instruction)FPmathRP[oper - GT_ADD];
            }

#if ROUND_FLOAT

            /* if we're going to spill due to call, no need to round the
             * result of computation of top
             */

            roundTop = (opr->gtFlags & GTF_CALL) ? false
                                                 : genShouldRoundFP();


#endif

            /* Is either of the operands a register variable? */

            if  (top->gtOper == GT_REG_VAR)
            {
                if  (opr->gtOper == GT_REG_VAR)
                {
                    /* Both operands are register variables
                     * Special case: 'top' and 'opr' are the same variable */

                    if (top->gtLclVar.gtLclNum == opr->gtLclVar.gtLclNum)
                    {
                        assert(opr->gtRegNum == top->gtRegNum);
                        assert(opr->gtLclVar.gtLclNum == opr->gtRegVar.gtRegVar);

                        /* This is an "a op a" operation - only 'opr' can go dead */

                        assert(!(top->gtFlags & GTF_REG_DEATH));

                        if (opr->gtFlags & GTF_REG_DEATH)
                        {
                            /* The variable goes dead here */

                            assert(top->gtRegNum == 0);
                            assert(opr->gtRegNum == 0);

                            /* Record the fact that 'opr' is dead */

                            genFPregVarDeath(opr);
                            genFPstkLevel++;

                            /* If there are no temps on the stack things are great,
                             * we just over-write 'opr' with the result, otherwise shift 'opr' up */

                            genFPmovRegTop();
                        }
                        else
                        {
                            /* The variable remains live - make a copy of it on TOS */

                            genCodeForTreeFlt(top, roundTop);
                        }

                        /* Simply generate "ins ST(0)" */

                        inst_FS(ins_NN);

                        goto DONE_FP_BINOP;
                    }

                    /* 'top' and 'opr' are different variables - check if anyone of them goes dead */

                    if  (top->gtFlags & GTF_REG_DEATH)
                    {
                        /* 'top' dies here - check if 'opr' also dies */

                        if  (opr->gtFlags & GTF_REG_DEATH)
                        {
                            /* Both are going dead at this operation!
                             * In the evaluation order 'top' dies first so we must
                             * have the lifetime of 'top' nested into the lifetime
                             * of 'opr' - thus 'top' is right above 'opr' */

                            assert(top->gtRegNum == 0);
                            assert(opr->gtRegNum == 0);

                            /* Record the fact that 'top' is dead  - top becomes a temp */

                            genFPregVarDeath(top);
                            genFPstkLevel++;

                            /* If there are temps above 'top' we have to bubble it up */

                            genFPmovRegTop();

                            /* Compute the result replacing 'opr' and pop 'top' */

                            inst_FS(ins_RP, genFPstkLevel);    // @MIHAI this should be ins_RP ???

                            /* Record the fact that 'opr' is dead */

                            genFPregVarDeath(opr);

                            /* If there are temps move the result up */

                            genFPmovRegTop();
                        }
                        else
                        {
                            /* 'top' dies, 'opr' stays alive */
                            assert(top->gtRegNum == 0);

                            /* Record the fact that 'top' is dead */

                            genFPregVarDeath(top);
                            genFPstkLevel++;

                            /* If there are no temps on the stack things are great,
                             * we just over-write 'top' with the result, otherwise shift top up */

                            genFPmovRegTop();

                            /* Compute the result over 'top' */

                            inst_FN(ins_NN, opr->gtRegNum + genFPstkLevel);
                        }
                    }
                    else if  (opr->gtFlags & GTF_REG_DEATH)
                    {
                        /* Only 'opr' dies here */

                        assert(opr->gtRegNum == 0);
                        assert(top->gtRegNum  > 0);

                        /* Record the fact that 'opr' is dead */

                        genFPregVarDeath(opr);
                        genFPstkLevel++;

                        /* If there are no temps on the stack things are great,
                         * we just over-write 'opr' with the result, otherwise shift 'opr' up */

                        genFPmovRegTop();

                        /* Perform the operation with the other register, over-write 'opr' */

                        inst_FN(ins_RN, top->gtRegNum + genFPstkLevel);
                    }
                    else
                    {
                        /* None of the operands goes dead */

                        assert(opr->gtRegNum != top->gtRegNum);

                        /* Make a copy of 'top' on TOS */

                        genCodeForTreeFlt(top, roundTop);

                        /* Perform the operation with the other operand */

                        inst_FN(ins_NN, opr->gtRegNum + genFPstkLevel);
                    }

                    goto DONE_FP_BINOP;
                }
                else
                {
                    /* 'top' is in a register, 'opr' is not */

                    if  (top->gtFlags & GTF_REG_DEATH)
                    {
                        assert(top->gtRegNum == 0);

                        /* Mark top as dead, i.e becomes a temp, and bubble it to the TOS */

                        genFPstkLevel++;
                        genFPregVarDeath(top);

                        genFPmovRegTop();

                        goto DONE_FP_OP1;
                    }
                    else
                    {
                        genCodeForTreeFlt(opr, genShouldRoundFP());

                        inst_FN(ins_RN, top->gtRegNum + genFPstkLevel);
                    }

                    goto DONE_FP_BINOP;
                }
            }
            else if (opr->gtOper == GT_REG_VAR)
            {
                /* 'opr' is in a register, 'top' is not - need to compute 'top' first */

                genCodeForTreeFlt(top, roundTop);

                if  (opr->gtFlags & GTF_REG_DEATH)
                {
                    /* 'opr' dies here - Compute the result over-writting 'opr' and popping 'top' */

                    assert(opr->gtRegNum == 0);
                    assert(genFPstkLevel >= 1);

                    inst_FS(ins_RP, genFPstkLevel);

                    /* Record the fact that 'opr' is now dead */

                    genFPregVarDeath(opr);

                    /* If there are temps above the result we have to bubble it to the top */

                    genFPmovRegTop();
                }
                else
                {
                    inst_FN(ins_NN, opr->gtRegNum + genFPstkLevel);
                }

                goto DONE_FP_BINOP;
            }

            /* Compute the value of the initial operand onto the FP stack */

            genCodeForTreeFlt(top, roundTop);

            /* Special case: "x+x" or "x*x" */

            if  (op1->OperIsLeaf() &&
                 op2->OperIsLeaf() && GenTree::Compare(op1, op2))
            {
                /* Simply generate "ins ST(0)" */

                inst_FS(ins_NN);

                goto DONE_FP_BINOP;
            }

DONE_FP_OP1:

            /* Spill the stack (first operand) if the other operand contains a call
             * or we are in danger of overflowing the stack (i.e. we must make room for the second
             * operand by leaving at least one slot free - for Risc code we must leave
             * two slots free
             */

            temp = 0;

            if  (opr->gtFlags & GTF_CALL)
            {
                /* We must spill the first operand */
                temp = genSpillFPtos(top);
            }
            else if (genFPstkLevel + genFPregCnt >= FP_STK_SIZE - 1)
            {
                /* One or no slot left on the FPU stack - check if we need to spill */
                if (riscCode)
                {
                    assert(genFPstkLevel + genFPregCnt == FP_STK_SIZE - 1);

                    /* If second operand is not a leaf node we better spill */
                    if(!(opr->OperKind() & (GTK_LEAF | GTK_CONST)))
                        temp = genSpillFPtos(top);
                }
                else if (genFPstkLevel + genFPregCnt == FP_STK_SIZE)
                    temp = genSpillFPtos(top);
            }

            if  (riscCode)
            {
                genCodeForTreeFlt(opr, genShouldRoundFP()); addrReg = 0;

                opr = 0;
            }
            else
                opr = genMakeAddrOrFPstk(opr, &addrReg, genShouldRoundFP());

            /* Did we have to spill the first operand? */

            if  (temp)
            {
                instruction     ldi;

                /* Reverse the sense of the operation */

                ldi    = (tree->gtFlags & GTF_REVERSE_OPS) ? ins_NN : ins_RN;
                ins_NP = ins_RP;

                /*  Either reload the temp back onto the FP stack (if the other
                    operand is not itself on the FP stack), or just compute the
                    result directly from the temp (if the operand is on the FP
                    stack).
                 */

                if  (opr || riscCode)
                {
                    ldi = INS_fld;
                    genFPstkLevel++;
                }

                genReloadFPtos(temp, ldi);
            }

            if  (opr)
            {
                /* We have the address of the other operand */

                inst_FS_TT(ins_NN, opr);
            }
            else
            {
                /* The other operand is on the FP stack */

                if  (!temp || riscCode)
                {
                    inst_FS(ins_NP, 1);
                    genFPstkLevel--;
                }
            }

            gcMarkRegSetNpt(addrReg); assert(addrReg != 0xDDDD);

        DONE_FP_BINOP:

#if ROUND_FLOAT
            if  (roundResult && tree->gtType == TYP_FLOAT)

                genRoundFpExpression(tree);
#endif

            return;

#ifndef NDEBUG

        case GT_MOD:
            assert(!"float modulo should have been converted into a helper call");

#endif

        case GT_ASG:

            size = genTypeSize(op2->gtType);
            offs = 0;

#ifdef DEBUGGING_SUPPORT

            if  (op1->gtOper == GT_LCL_VAR)
            {
                /* For non-debuggable code, every definition of a lcl-var has
                 * to be checked to see if we need to open a new scope for it.
                 */

                if  ( opts.compScopeInfo &&
                     !opts.compDbgCode   && info.compLocalVarsCount > 0)
                {
                    siCheckVarScope(op1->gtLclVar.gtLclNum,
                                    op1->gtLclVar.gtLclOffs);
                }
            }

#endif

            /* Is the value being assigned a variable, constant, or indirection? */

            switch (op2->gtOper)
            {
                long    *   addr;

            case GT_CNS_FLT: addr = (long *)&op2->gtFltCon.gtFconVal; goto ASG_CNS;
            case GT_CNS_DBL: addr = (long *)&op2->gtDblCon.gtDconVal; goto ASG_CNS;

            ASG_CNS:

                if  (op1->gtOper == GT_REG_VAR)
                    break;

                addrReg = genMakeAddressable(op1, 0, false);

                do
                {
                    inst_TT_IV(INS_mov, op1, *addr++, offs);
                    offs += sizeof(long);
                }
                while (offs < size);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                tree->gtUsedRegs = op1->gtUsedRegs;
#endif

                gcMarkRegSetNpt(addrReg);
                return;

#if SPECIAL_DOUBLE_ASG

            case GT_IND:

                if  (op1->gtOper == GT_REG_VAR)
                    break;

                /* Process float indirections in the usual way */
                if (tree->gtType == TYP_FLOAT)
                    break;

                /* This needs too many registers, especially when op1
                 * is an two register address mode */
                if (op1->gtOper == GT_IND)
                    break;

                /* If there are enough registers, process double mem->mem assignments
                 * with a register pair, to get pairing.
                 * CONSIDER: - check for Processor here???
                 */
                if (rsFreeNeededRegCount(RBM_ALL) > 3)
                {
                    genCodeForTreeLng(tree, RBM_ALL);
                    return;
                }

                /* Otherwise evaluate RHS to fp stack */
                break;

#endif

            case GT_REG_VAR:

                if  (op1->gtOper != GT_REG_VAR)
                    break;

                /* stack -> stack assignment; does the source die here? */

                if  (op2->gtFlags & GTF_REG_DEATH)
                {
                    /* Get the variable marked as dead */

                    genFPregVarLoadLast(op2);

                    if  (op1->gtFlags & GTF_REG_BIRTH)
                    {
                        /* How convenient - the target is born right here */

                        /* Mark the target variable as live */

                        genFPregVarBirth(op1);
                    }
                    else
                    {
                        /* Store it into the right place and pop it */

                        inst_FS(INS_fstp, op1->gtRegNum + 1);
                    }

                    genFPstkLevel--;

                    genUpdateLife(tree);
                    return;
                }

                if  (op2->gtRegNum || genFPstkLevel)
                {
                    /* The source is somewhere on the stack */

                    inst_FN(INS_fld , op2->gtRegNum + genFPstkLevel);
                    genFPstkLevel++;
                    inst_FS(INS_fstp, op1->gtRegNum + genFPstkLevel);
                    genFPstkLevel--;
                }
                else
                {
                    /* The source is at the bottom of the stack */

                    if  (op1->gtFlags & GTF_REG_BIRTH)
                    {
                        /* The target is, in fact, born here */

                        inst_FN(INS_fld , op2->gtRegNum + genFPstkLevel);

                        /* Mark the target variable as live */

                        genFPregVarBirth(op1);
                    }
                    else
                    {
                        assert(!"can this ever happen?");

                        inst_FS(INS_fst , op1->gtRegNum);
                    }
                }

                genUpdateLife(tree);
                return;

            case GT_LCL_VAR:
            case GT_CLS_VAR:

                if  (op1->gtOper == GT_REG_VAR)
                    break;

#if SPECIAL_DOUBLE_ASG

                /* If there are enough registers, process double mem->mem assignments
                 * with a register pair, to get pairing.
                 * CONSIDER: - check for Processor here???
                 */

                if  (tree->gtType == TYP_DOUBLE && rsFreeNeededRegCount(RBM_ALL) > 1)
                {
                    genCodeForTreeLng(tree, RBM_ALL);
                    return;
                }

                /* Otherwise use only one register for the copy */

#endif
                {
                    regNumber   regNo;

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, 0, true);

                    /* Lock the address temporarily */

                    assert((rsMaskLock &  addrReg) == 0);
                            rsMaskLock |= addrReg;

                    /* Is there a register to move the value through ? */

                    if  (rsRegMaskFree())
                    {
                        /* Yes, grab one */

                        regNo = rsPickReg(0);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                        tree->gtUsedRegs = op1->gtUsedRegs | genRegMask(regNo);
#endif

                        /* Move the value through the register */

                        do
                        {
                            rsTrackRegTrash(regNo);    // not very smart, but ....

                            inst_RV_TT(INS_mov, regNo, op2, offs);
                            inst_TT_RV(INS_mov, op1, regNo, offs);

                            offs += sizeof(long);
                        }
                        while (offs < size);
                    }
                    else
                    {
                        /* No register available, transfer through FPU */

                        inst_FS_TT(INS_fld,  op2);
                        inst_FS_TT(INS_fstp, op1);
                    }

                    /* Unlock the register(s) holding the address */

                    assert((rsMaskLock &  addrReg) == addrReg);
                            rsMaskLock -= addrReg;

                    /* Free up anything that was tied up by the LHS */

                    genDoneAddressable(op1, addrReg);
                }
                return;

            case GT_POP:

                assert(op1->gtOper == GT_LCL_VAR);

                /* Generate 'pop [lclVar]' and 'pop [lclVar+4]' (if double) */

                genStackLevel -= sizeof(void*);
                inst_TT(INS_pop, op1, 0);
                genStackLevel += sizeof(void*);
                genSinglePop();

                if  (tree->gtType == TYP_DOUBLE)
                {
                    genStackLevel -= sizeof(void*);
                    inst_TT(INS_pop, op1, 4);
                    genStackLevel += sizeof(void*);
                    genSinglePop();
                }

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
                tree->gtUsedRegs = 0;
#endif
                return;

            }

            /* Is the LHS more complex than the RHS? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {

                /* Is the RHS a surviving register variable at TOS? */

                if  ((op2->gtOper  == GT_REG_VAR  )      &&
                     (op2->gtFlags & GTF_REG_DEATH) == 0 &&
                     (op2->gtRegNum               ) == 0 &&
                     genFPstkLevel                  == 0)
                {
                    /* The LHS better not contain a call */

                    assert((op1->gtFlags & GTF_CALL) == 0);

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, 0, false);

                    /* Store a copy of the register value into the target */

                    inst_FS_TT(INS_fst, op1);

                    /* We no longer need the target address */

                    gcMarkRegSetNpt(addrReg);

                    genUpdateLife(tree);
                    return;
                }

                /* Evaluate the RHS onto the FP stack */

                genCodeForTreeFlt(op2, false);

                /* Does the target address contain a function call? */

                if  (op1->gtFlags & GTF_CALL)
                {
                    /* We must spill the new value - grab a temp */

                    temp = tmpGetTemp(op2->TypeGet());

                    /* Pop the value from the FP stack into the temp */

                    assert(genFPstkLevel == 1);
                    inst_FS_ST(INS_fstp, EA_SIZE(genTypeSize(op2->gtType)), temp, 0);
                    genTmpAccessCnt++;

                    genFPstkLevel--;

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, 0, true);

                    /* UNDONE: Assign the value via simple moves through regs */

                    assert(genFPstkLevel == 0);

                    inst_FS_ST(INS_fld, EA_SIZE(genTypeSize(op2->gtType)), temp, 0);
                    genTmpAccessCnt++;

                    inst_FS_TT(INS_fstp, op1);

                    /* We no longer need the temp */

                    tmpRlsTemp(temp);

                    /* Free up anything that was tied up by the target address */

                    genDoneAddressable(op1, addrReg);
                }
                else
                {
                    assert(genFPstkLevel);

                    /* Has the target been enregistered on the FP stack? */

                    if  (op1->gtOper == GT_REG_VAR)
                    {
                        /* This better be marked as a birth */

                        assert(op1->gtFlags & GTF_REG_BIRTH);

                        /* Is the new value already in the right place (i.e top of stack)?
                         * If not buble it to the bottom */

                        genFPmovRegBottom();

                        /* Mark the variable as live */

                        genFPregVarBirth(op1);

                        /* We've effectively consumed the FP value, i.e. genFPstkLevel only
                         * counts temps on the stack not enregistered variables */

                        genFPstkLevel--;

                        genUpdateLife(tree);
                        return;
                    }

                    /* Make the target addressable */

                    addrReg = genMakeAddressable(op1, 0, false);

                    /* Pop and store the new value into the target */

                    inst_FS_TT(INS_fstp, op1);

                    /* We no longer need the target address */

                    gcMarkRegSetNpt(addrReg);
                }
            }
            else
            {
                assert(op1->gtOper != GT_REG_VAR);

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, true);

                /* Is the RHS a register variable at the bottom of the stack? */

                if  (op2->gtOper == GT_REG_VAR &&
                     op2->gtRegNum + genFPstkLevel == 0)
                {
                    /* Store a copy of the RHS into the target */

                    ins_NN = INS_fst;

                    if  (op2->gtFlags & GTF_REG_DEATH)
                    {
                        /* The variable dies right here */

                        ins_NN = INS_fstp;

                        /* Record the fact that we're killing this var */

                        genFPregVarDeath(op2);
                    }

                    inst_FS_TT(ins_NN, op1);

                    /* This merely compensates for the decrement below */

                    genFPstkLevel++;
                }
                else
                {
                    /* Evaluate the RHS onto the FP stack */

                    genCodeForTreeFlt(op2, false);

                    /* Make sure the target is still addressable */

                    addrReg = genKeepAddressable(op1, addrReg);

                    /* Pop and store the new value into the target */

                    inst_FS_TT(INS_fstp, op1);
                }

                /* Free up anything that was tied up by the target address */

                genDoneAddressable(op1, addrReg);
            }

            genFPstkLevel--;

            genUpdateLife(tree);
            return;

        case GT_ASG_ADD:
        case GT_ASG_SUB:
        case GT_ASG_MUL:
        case GT_ASG_DIV:

            /* Make sure the instruction tables look correctly ordered */

            assert(FPmathRN[GT_ASG_ADD - GT_ASG_ADD] == INS_fadd  );
            assert(FPmathRN[GT_ASG_SUB - GT_ASG_ADD] == INS_fsubr );
            assert(FPmathRN[GT_ASG_MUL - GT_ASG_ADD] == INS_fmul  );
            assert(FPmathRN[GT_ASG_DIV - GT_ASG_ADD] == INS_fdivr );

            assert(FPmathRP[GT_ASG_ADD - GT_ASG_ADD] == INS_faddp );
            assert(FPmathRP[GT_ASG_SUB - GT_ASG_ADD] == INS_fsubrp);
            assert(FPmathRP[GT_ASG_MUL - GT_ASG_ADD] == INS_fmulp );
            assert(FPmathRP[GT_ASG_DIV - GT_ASG_ADD] == INS_fdivrp);

            ins_NN = (instruction)FPmathNN[oper - GT_ASG_ADD];
            ins_NP = (instruction)FPmathRP[oper - GT_ASG_ADD];

            ins_RN = (instruction)FPmathRN[oper - GT_ASG_ADD];
            ins_RP = (instruction)FPmathNP[oper - GT_ASG_ADD];

            /* Is the value or the address to be computed first? */

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                /* Is the target a register variable? */

                if  (op1->gtOper == GT_REG_VAR)
                {
                    /* Is the RHS also a register variable? */

                    if  (op2->gtOper == GT_REG_VAR)
                    {
                        if  (op2->gtRegNum + genFPstkLevel == 0)
                        {
                            unsigned    lvl;

                            /* The RHS is at the bottom of the stack */

                            lvl = op1->gtRegNum + genFPstkLevel;

                            /* Is the RHS a dying register variable? */

                            if  (op2->gtFlags & GTF_REG_DEATH)
                            {
                                /* We'll pop the dead value off the FP stack */

                                inst_FS(ins_RP, lvl+1);

                                /* Record the fact that 'op2' is now dead */

                                genFPregVarDeath(op2);
                            }
                            else
                            {
                                inst_FS(ins_NN, lvl);
                            }

                            genUpdateLife(tree);
                            return;
                        }

                        /* Is the destination at the bottom of the stack? */

                        if  (op1->gtRegNum + genFPstkLevel == 0)
                        {
                            unsigned    lvl = op2->gtRegNum + genFPstkLevel;

                            /* Simply compute the new value into the target */

                            if  ((op2->gtFlags & GTF_REG_DEATH) && lvl == 1)
                            {
                                /* Compute the new value into the target, popping the source */

                                inst_FN(ins_NP, lvl);

                                /* Record the fact that 'op2' is now dead */

                                genFPregVarDeath(op2);
                            }
                            else
                            {
                                /* Compute the new value into the target */

                                inst_FN(ins_NN, lvl);
                            }

                            genUpdateLife(tree);
                            return;
                        }
                    }

                    /* Compute the second operand onto the FP stack */

                    genCodeForTreeFlt(op2, genShouldRoundFP());

                    switch (oper)
                    {
                    case GT_ASG_ADD: ins_NN = INS_faddp; break;
                    case GT_ASG_SUB: ins_NN = INS_fsubp; break;
                    case GT_ASG_MUL: ins_NN = INS_fmulp; break;
                    case GT_ASG_DIV: ins_NN = INS_fdivp; break;
                    }

                    inst_FS(ins_NN, op1->gtRegNum + genFPstkLevel);

                    genFPstkLevel--;
                    genUpdateLife(tree);
                    return;
                }

                /* Compute the second operand onto the FP stack */

                genCodeForTreeFlt(op2, genShouldRoundFP());

                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, true);
            }
            else
            {
                /* Make the target addressable */

                addrReg = genMakeAddressable(op1, 0, true);

                /* For "lcl = ...." we always expect GTF_REVERSE to be set */

                assert(op1->gtOper != GT_REG_VAR);

                /* Is the RHS a register variable? */

                if  (op2->gtOper == GT_REG_VAR)
                {
                    /* The RHS is a register variable */

                    inst_FS_TT(INS_fld, op1);
                    genFPstkLevel++;

                    /* Does the regvar die here? */

                    if  (op2->gtFlags & GTF_REG_DEATH)
                    {
                        assert(op2->gtRegNum == 0);
                        assert(genFPstkLevel >= 1);

                        /* Can we pop the dead variable now? */

                        if  (genFPstkLevel == 1)
                        {
                            /* Compute&pop and store the result */

                            inst_FS   (ins_NP  ,   1);
                            inst_FS_TT(INS_fstp, op1);

                            /* Record the fact that 'op2' is now dead */

                            genFPregVarDeath(op2);

                            goto DONE_ASGOP;
                        }

                        /* The dead variable will need to be popped later */
                    }

                    inst_FN   (ins_NN     , op2->gtRegNum + genFPstkLevel);
                    inst_FS_TT(INS_fstp, op1);

                    goto DONE_ASGOP;
                }

                /* Compute the second operand onto the FP stack */

                genCodeForTreeFlt(op2, genShouldRoundFP());

                /* Make sure the target is still addressable */

                addrReg = genKeepAddressable(op1, addrReg);
            }

            /* Perform the operation on the old value and store the new value */

            if  (op1->gtOper == GT_REG_VAR)
            {
                inst_FS(ins_NP, op1->gtRegNum + genFPstkLevel);
            }
            else
            {
                if  (riscCode)
                {
                    inst_FS_TT(INS_fld , op1);
                    genFPstkLevel++;
                    inst_FS   (ins_NP    , 1);
                    genFPstkLevel--;
                    inst_FS_TT(INS_fstp, op1);
                }
                else
                {
                    inst_FS_TT(ins_RN  , op1);
                    inst_FS_TT(INS_fstp, op1);
                }
            }

        DONE_ASGOP:

            genFPstkLevel--;

            /* Free up anything that is tied up by the address */

            genDoneAddressable(op1, addrReg);

            genUpdateLife(tree);
            return;

        case GT_IND:

//            assert(op1->gtType == TYP_REF   ||
//                   op1->gtType == TYP_BYREF || (op1->gtFlags & GTF_NON_GC_ADDR));

            /* Make sure the address value is 'addressable' */

            addrReg = genMakeAddressable(tree, 0, false);

            /* Load the value onto the FP stack */

            inst_FS_TT(INS_fld, tree);
            genFPstkLevel++;
//          genDoneAddressable(tree, addrReg);   // @ToDo: BUG???

            gcMarkRegSetNpt(addrReg);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = op1->gtUsedRegs;
#endif
            return;

        case GT_NEG:

            /* can't fneg in place, since it might be used in the expression tree */
            if ((op1->gtOper == GT_REG_VAR) &&
                (op1->gtFlags & GTF_REG_DEATH))
            {
                inst_FN(INS_fld, op1->gtRegNum + genFPstkLevel);
                genFPstkLevel++;
                /* Someone later will clean up this extra push */
            }
            else
                genCodeForTreeFlt(op1, roundResult);

            instGen(INS_fchs);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = op1->gtUsedRegs;
#endif
            return;

        case GT_NOP:

            if  (tree->gtFlags & GTF_NOP_DEATH)
            {
                /* The operand must be a dying register variable */

                assert(op1->gtOper   == GT_REG_VAR);
                assert(op1->gtRegNum == 0);
                assert(genFPstkLevel == 0);

                /* Toss the variable by popping it away */

                inst_FS(INS_fstp, 0);

                /* Record that we're killing this var */

                genFPregVarDeath(op1);
            }
            else
            {
                genCodeForTreeFlt(tree, roundResult);
            }

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = tree->gtUsedRegs;
#endif
            return;

#if INLINE_MATH

        case GT_MATH:

            switch (tree->gtMath.gtMathFN)
            {
                GenTreePtr      tmp;
                bool            rev;

            case MATH_FN_EXP:

                tmp = genMakeAddrOrFPstk(op1, &addrReg, false);

                instGen(INS_fldl2e);

                /* Mutliply by the operand */

                if  (tmp)
                    inst_FS_TT(INS_fmul , tmp);
                else
                    inst_FS   (INS_fmulp, 1);

                inst_FN(INS_fld  , 0);
                instGen(INS_frndint );
                inst_FN(INS_fxch , 1);
                inst_FN(INS_fsub , 1);
                instGen(INS_f2xm1   );
                instGen(INS_fld1    );
                inst_FS(INS_faddp, 1);
                instGen(INS_fscale  );
                inst_FS(INS_fstp,  1);

                /* If operand hasn't been already on the stack, adjust FP stack level */

                if  (tmp)
                    genFPstkLevel++;

                gcMarkRegSetNpt(addrReg);
                return;

#if 1

            case MATH_FN_POW:

                /* Are we supposed to generate operand 2 first? */

                if  (tree->gtFlags & GTF_REVERSE_OPS)
                {
                    top = op2;
                    opr = op1;
                    rev = true;
                }
                else
                {
                    top = op1;
                    opr = op2;
                    rev = false;
                }

                /* Compute the first operand */

                genCodeForTreeFlt(top, false);

                /* Does the other operand contain a call? */

                temp = 0;

                if  (opr->gtFlags & GTF_CALL)
                {
                    /* We must spill the first operand */

                    temp = genSpillFPtos(top);
                }

                genCodeForTreeFlt(opr, roundResult);

                /* Did we have to spill the first operand? */

                if  (temp)
                    genReloadFPtos(temp, INS_fld);

                /* Swap the operands if we loaded in reverse order */

                if  (rev)
                    inst_FN(INS_fxch, 1);

#if TGT_RISC
                assert(genNonLeaf);
#endif

                genEmitHelperCall(CPX_MATH_POW,
                                 0,             // argSize. Use 2*sizeof(double) if args on stack!!!
                                 sizeof(void*));// retSize

                genFPstkLevel--;
                return;
            }

#endif

            genCodeForTreeFlt(op1, roundResult);

            {
            static
            BYTE        mathIns[] =
            {
                INS_fabs,
                INS_none,
                INS_fsin,
                INS_fcos,
                INS_fsqrt,
            };

            assert(mathIns[MATH_FN_ABS ] == INS_fabs );
            assert(mathIns[MATH_FN_EXP ] == INS_none );
            assert(mathIns[MATH_FN_SIN ] == INS_fsin );
            assert(mathIns[MATH_FN_COS ] == INS_fcos );
            assert(mathIns[MATH_FN_SQRT] == INS_fsqrt);

            assert(tree->gtMath.gtMathFN < sizeof(mathIns)/sizeof(mathIns[0]));
//          assert(mathIns[tree->gtMath.gtMathFN] != INS_none);

            if (tree->gtMath.gtMathFN != MATH_FN_EXP)
                instGen((instruction)mathIns[tree->gtMath.gtMathFN]);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = op1->gtUsedRegs;
#endif
            return;

            }
#endif

        case GT_CAST:

            /* What are we casting from? */

            switch (op1->gtType)
            {
            case TYP_BOOL:
            case TYP_BYTE:
            case TYP_UBYTE:
            case TYP_CHAR:
            case TYP_SHORT:

                /* Operand too small for 'fild', load it into a register */

                genCodeForTree(op1, 0);

#if ROUND_FLOAT
                /* no need to round, can't overflow float or dbl */
                roundResult = false;
#endif

                // Fall through, now the operand is in a register ...

            //
            // UNSIGNED_ISSUE : Implement casting
            //
            case TYP_INT:
            case TYP_LONG:

                /* Can't 'fild' a constant, it has to be loaded from memory */

                switch (op1->gtOper)
                {
                case GT_CNS_INT:
                    op1 = genMakeConst(&op1->gtIntCon.gtIconVal, sizeof(int ), TYP_INT , tree, true);
                    break;

                case GT_CNS_LNG:
                    op1 = genMakeConst(&op1->gtLngCon.gtLconVal, sizeof(long), TYP_LONG, tree, true);
                    break;
                }

                addrReg = genMakeAddressable(op1, 0, false);

                /* Is the value now sitting in a register? */

                if  (op1->gtFlags & GTF_REG_VAL)
                {
                    /* We'll have to store the value into the stack */

                    size = roundUp(genTypeSize(op1->gtType));
                    temp = tmpGetTemp(op1->TypeGet());

                    /* Move the value into the temp */

                    if  (op1->gtType == TYP_LONG)
                    {
                        regPairNo  reg = op1->gtRegPair;

                        //ISSUE: This code is pretty ugly, but straightforward
                        //CONSIDER: As long as we always reserve both dwords
                        //          of a partially enregistered long,
                        //          just "spill" the enregistered half!

                        if  (genRegPairLo(reg) == REG_STK)
                        {
                            regNumber rg1 = genRegPairHi(reg);

                            assert(rg1 != REG_STK);

                            /* Move enregistered half to temp */

                            inst_ST_RV(INS_mov, temp, 4, rg1, TYP_LONG);

                            /* Move lower half to temp via "high register" */

                            inst_RV_TT(INS_mov, rg1, op1, 0);
                            inst_ST_RV(INS_mov, temp, 0, rg1, TYP_LONG);

                            /* Reload transfer register */

                            inst_RV_ST(INS_mov, rg1, temp, 4, TYP_LONG);

                            genTmpAccessCnt += 4;
                        }
                        else if  (genRegPairHi(reg) == REG_STK)
                        {

                            regNumber rg1 = genRegPairLo(reg);

                            assert(rg1 != REG_STK);

                            /* Move enregistered half to temp */

                            inst_ST_RV(INS_mov, temp, 0, rg1, TYP_LONG);

                            /* Move high half to temp via "low register" */

                            inst_RV_TT(INS_mov, rg1, op1, 4);
                            inst_ST_RV(INS_mov, temp, 4, rg1, TYP_LONG);

                            /* Reload transfer register */

                            inst_RV_ST(INS_mov, rg1, temp, 0, TYP_LONG);

                            genTmpAccessCnt += 4;
                        }
                        else
                        {
                            /* Move the value into the temp */

                            inst_ST_RV(INS_mov, temp, 0, genRegPairLo(reg), TYP_LONG);
                            inst_ST_RV(INS_mov, temp, 4, genRegPairHi(reg), TYP_LONG);
                            genTmpAccessCnt += 2;

                        }
                        gcMarkRegSetNpt(addrReg);

                        /* Load the long from the temp */

                        inst_FS_ST(INS_fildl, EA_SIZE(size), temp, 0);
                        genTmpAccessCnt++;
                    }
                    else
                    {
                        /* Move the value into the temp */

                        inst_ST_RV(INS_mov  ,       temp, 0, op1->gtRegNum, TYP_INT);
                        genTmpAccessCnt++;

                        gcMarkRegSetNpt(addrReg);

                        /* Load the integer from the temp */

                        inst_FS_ST(INS_fild , EA_SIZE(size), temp, 0);
                        genTmpAccessCnt++;
                    }

                    /* We no longer need the temp */

                    tmpRlsTemp(temp);
                }
                else
                {
                    /* Load the value from its address */

                    if  (op1->gtType == TYP_LONG)
                        inst_TT(INS_fildl, op1);
                    else
                        inst_TT(INS_fild , op1);

                    gcMarkRegSetNpt(addrReg);
                }

                genFPstkLevel++;

#if ROUND_FLOAT
                /* integer to fp conversions can overflow. roundResult
                 * is cleared above in cases where it can't
                 */
                if (roundResult && tree->gtType == TYP_FLOAT)
                    genRoundFpExpression(tree);
#endif

                break;

            case TYP_FLOAT:
                /* This is a cast from float to double */

                genCodeForTreeFlt(op1, true);         // Trucate its precision
                break;

            case TYP_DOUBLE:

                /* This is a cast from double to float or double */
                /* Load the value, store as float, load back */

                /* TODO: we should check to see if the soruce is aready in
                   memory, in which case we don't need to do this */

                genCodeForTreeFlt(op1, false);

                /* Allocate a temp for the float value */

                temp = tmpGetTemp(tree->TypeGet());

                /* Store the FP value into the temp */

                inst_FS_ST(INS_fstp, EA_SIZE(genTypeSize(tree->TypeGet())), temp, 0);
                genTmpAccessCnt++;

                // UNDONE: Call this code from makeAddressable, as spilling
                // UNDONE: the value into a temp makes the value addressable.

                /* Load the value back onto the FP stack */

                inst_FS_ST(INS_fld, EA_SIZE(genTypeSize(tree->TypeGet())), temp, 0);
                genTmpAccessCnt++;

                /* We no longer need the temp */

                tmpRlsTemp(temp);
                break;

            default:
                assert(!"unsupported cast to float");
            }

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = op1->gtUsedRegs;
#endif

            genUpdateLife(tree);
            return;

        case GT_RETURN:

            assert(op1);

            /* Compute the result onto the FP stack */

            if (op1->gtType == TYP_FLOAT)
            {
#if ROUND_FLOAT
                bool   roundOp1 = false;

                switch (getRoundFloatLevel())
                {
                default:

                    /* No rounding at all */

                    break;

                case 1:
                    break;

                case 2:

                    /* Round all comparands and return values*/

                    roundOp1 = true;
                    break;


                case 3:
                    /* Round everything */

                    roundOp1 = true;
                    break;
                }

#endif

                genCodeForTreeFlt(op1, roundOp1);
            }
            else
            {
                assert(op1->gtType == TYP_DOUBLE);
                genCodeForTreeFlt(op1, false);

#if ROUND_FLOAT
                if ((op1->gtOper == GT_CAST) && (op1->gtOp.gtOp1->gtType == TYP_LONG))
                    genRoundFpExpression(op1);
#endif

            }
            /* Make sure we pop off any dead FP regvars */

            if  (genFPregCnt)
                genFPregVarKill(0, true);

            /* The return effectively pops the value */

            genFPstkLevel--;
            return;

#if OPTIMIZE_QMARK

#if INLINING
        case GT_QMARK:
            assert(!"inliner-generated ?: for floats/doubles NYI");
            return;
#endif

        case GT_BB_COLON:

            /* Compute the result onto the FP stack */

            genCodeForTreeFlt(op1, roundResult);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = op1->gtUsedRegs;
#endif

            /* Decrement the FP stk level here so that we don't end up popping the result */
            /* the GT_BB_QMARK will increment the stack to rematerialize the result */
            genFPstkLevel--;

            return;

#endif // OPTIMIZE_QMARK

        case GT_COMMA:

            assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

            /* Check for special case: "lcl = val , lcl" */

            if  (op1->gtOper == GT_ASG     &&
                 op1->gtType == TYP_DOUBLE && op2->            gtOper == GT_LCL_VAR
                                           && op1->gtOp.gtOp1->gtOper == GT_LCL_VAR)
            {
                if  (op2            ->gtLclVar.gtLclNum ==
                     op1->gtOp.gtOp1->gtLclVar.gtLclNum)
                {
                    /* Evaluate the RHS onto the FP stack */

                    genCodeForTreeFlt(op1->gtOp.gtOp2, false);

                    /* Store the new value into the target */

                    if  (op2->gtOper == GT_REG_VAR)
                    {
                        inst_FS   (INS_fst, op2->gtRegNum + genFPstkLevel);
                    }
                    else
                    {
                        inst_FS_TT(INS_fst, op2);
                    }

                    /* We're leaving the new value on the FP stack */

                    genUpdateLife(tree);
                    return;
                }
            }

            /* Generate side effects of the first operand */

            genEvalSideEffects(op1, 0);
            genUpdateLife (op1);

            /* Now generate the second operand, i.e. the 'real' value */

            genCodeForTreeFlt(op2, roundResult);

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
            tree->gtUsedRegs = op1->gtUsedRegs | op2->gtUsedRegs;
#endif

            genUpdateLife(tree);
            return;

        regNumber   reg;

        case GT_CKFINITE:

            /* We use the fact that the exponent for both the Infinities
             * and any NaN is all 1's
             */

            // Make it addressable if we can

            op2 = genMakeAddrOrFPstk(op1, &addrReg, roundResult);

            reg = rsGrabReg(RBM_ALL);

            // Offset of the DWord containing the exponent

            offs = (op1->gtType == TYP_FLOAT) ? 0 : sizeof(int);

            if (op2)
            {
                /* If it is addressable, we dont have to spill it to memory
                 * to load it into a general-purpose register. But we do
                 * have to load it onto the FP-stk
                 */

                genCodeForTreeFlt(op2, roundResult);

                // Load the DWord containing the exponent into a register

                inst_RV_TT(INS_mov, reg, op2, offs, EA_4BYTE);

                gcMarkRegSetNpt(addrReg);

                op2 = 0;
            }
            else
            {
                temp          = tmpGetTemp (op1->TypeGet());
                emitAttr size = EA_ATTR(genTypeSize(op1->TypeGet()));

                /* Store the value from the FP stack into the temp */

                genEmitter->emitIns_S(INS_fst, size, temp->tdTempNum(), 0);

                genTmpAccessCnt++;

                // Load the DWord containing the exponent into a general reg.

                inst_RV_ST(INS_mov, reg, temp, offs, op1->TypeGet(), EA_4BYTE);

                tmpRlsTemp(temp);
            }

            // 'reg' now contains the DWord containing the exponent

            rsTrackRegTrash(reg);

            // Mask of exponent with all 1's - appropriate for given type

            int expMask;
            expMask = (op1->gtType == TYP_FLOAT) ? 0x7F800000   // TYP_FLOAT
                                                 : 0x7FF00000;  // TYP_DOUBLE

            // Check if the exponent is all 1's

            inst_RV_IV(INS_and, reg, expMask);
            inst_RV_IV(INS_cmp, reg, expMask);

            // Find the block which will throw the ArithmeticException

            AddCodeDsc * add;
            add = fgFindExcptnTarget(ACK_ARITH_EXCPN, compCurBB->bbTryIndex);
            assert(add && add->acdDstBlk);

            // If exponent was all 1's, we need to throw ArithExcep

            inst_JMP(EJ_je, add->acdDstBlk, false, false, false);

            genUpdateLife(tree);
            return;

#ifdef DEBUG
        default:
            gtDispTree(tree); assert(!"unexpected/unsupported float operator");
#endif
        }
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
        unsigned        regMask;

    case GT_CALL:
        genCodeForCall(tree, true, &regMask);
#ifdef  SET_USED_REG_SET_DURING_CODEGEN
        tree->gtUsedRegs = regMask | rsMaskUsed;
#endif
        break;

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected/unsupported float operator");
    }

#else//TGT_x86

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
    {
        assert(!"fp const");
    }

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        switch (oper)
        {
        case GT_LCL_VAR:

            /* Has this local been enregistered? */

#if!CPU_HAS_FP_SUPPORT
            if (!genMarkLclVar(tree))
#endif
            {
#ifdef  DEBUG
                gtDispTree(tree);
#endif
                assert(!"fp lclvar");
                return;
            }

#if!CPU_HAS_FP_SUPPORT

            assert(tree->gtOper == GT_REG_VAR);

            // Fall through ....

        case GT_REG_VAR:
            return;
#endif

        case GT_CLS_VAR:
        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"unexpected FP leaf");
        }
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        GenTreePtr      op1 = tree->gtOp.gtOp1;
        GenTreePtr      op2 = tree->gtOp.gtOp2;

        switch (oper)
        {
        case GT_RETURN:

            /* Generate the return value into the return register */

            genComputeReg(op1, RBM_INTRET, true, true);

            /* The result must now be in the return register */

            assert(op1->gtFlags & GTF_REG_VAL);
            assert(op1->gtRegNum == REG_INTRET);

            return;

        default:
#ifdef  DEBUG
            gtDispTree(tree);
#endif
            assert(!"gen SH-3 code");
        }
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_CALL:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"gen FP call");

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"gen RISC FP code");
    }

#endif

}

/*****************************************************************************/
#endif//CPU_HAS_FP_SUPPORT
/*****************************************************************************
 *
 *  Generate a table switch - the switch value (0-based) is in register 'reg'.
 */

void            Compiler::genTableSwitch(regNumber      reg,
                                         unsigned       jumpCnt,
                                         BasicBlock **  jumpTab,
                                         bool           chkHi,
                                         int            prefCnt,
                                         BasicBlock *   prefLab,
                                         int            offset)
{
    void    *   zeroAddr = NULL;

    unsigned    jmpTabOffs;
    unsigned    jmpTabBase;

    assert(jumpCnt > 1);

    assert(chkHi);

#if 0

    /* Is the number of cases right for a test and jump switch? */

    if  (jumpCnt > 2 &&
         jumpCnt < 5 && (rsRegMaskFree() & genRegMask(reg)))
    {
        /* Does the first case label follow? */

        if  (compCurBB->bbNext == *jumpTab)
        {
            /* Check for the default case */

            inst_RV_IV(INS_cmp, reg, jumpCnt - 1);
            inst_JMP  (EJ_jae, jumpTab[jumpCnt-1], false, false, true);

            /* No need to jump to the first case */

            jumpCnt -= 2;
            jumpTab += 1;

            /* Generate a series of "dec reg; jmp label" */

            assert(jumpCnt);

            for (;;)
            {
                inst_RV (INS_dec, reg, TYP_INT);

                if (--jumpCnt == 0)
                    break;

                inst_JMP(EJ_je, *jumpTab++, false, false, true);
            }

            inst_JMP(EJ_je, *jumpTab, false, false, false);
        }
        else
        {
            bool        jmpDef;

            /* Check for case0 first */

            inst_RV_RV(INS_test, reg, reg);
            inst_JMP  (EJ_je, *jumpTab, false, false, true);

            /* No need to jump to the first case or the default */

            jumpCnt -= 2;
            jumpTab += 1;

            /* Are we going to need to jump to the defualt? */

            jmpDef = true;

            if  (compCurBB->bbNext == jumpTab[jumpCnt])
                jmpDef = false;

            /* Generate a series of "dec reg; jmp label" */

            assert(jumpCnt);

            for (;;)
            {
                inst_RV (INS_dec, reg, TYP_INT);

                if  (--jumpCnt == 0)
                    break;

                inst_JMP(EJ_je, *jumpTab++, false, false, true);
            }

            if (jmpDef)
            {
                inst_JMP(EJ_je,  *jumpTab++, false, false,  true);
                inst_JMP(EJ_jmp, *jumpTab  , false, false, false);
            }
            else
            {
                inst_JMP(EJ_je,  *jumpTab  , false, false, false);
            }
        }

        return;
    }

#endif

    /* First take care of the default case */

    if  (chkHi)
    {
#if TGT_x86
        inst_RV_IV(INS_cmp, reg, jumpCnt - 1);
        inst_JMP  (EJ_jae, jumpTab[jumpCnt-1], false, false, true);
#else
        genCompareRegIcon(reg, jumpCnt-2, true, GT_GT);
        genEmitter->emitIns_J(INS_bt, false, false, jumpTab[jumpCnt-1]);
#endif
    }

    /* Include the 'prefix' count in the label count */

    jumpCnt += prefCnt;

#if TGT_x86

    /* Generate the jump table contents */

    jmpTabBase = genEmitter->emitDataGenBeg(sizeof(void *)*(jumpCnt - 1), true, true);
    jmpTabOffs = 0;

#ifdef  DEBUG

    static  unsigned    jtabNum; ++jtabNum;

    if  (dspCode)
        printf("\n      J_%u_%u LABEL   DWORD\n", Compiler::s_compMethodsCount, jtabNum);

#endif

    while (--jumpCnt)
    {
        BasicBlock *    target = (prefCnt > 0) ? prefLab : *jumpTab++;

        assert(target->bbFlags & BBF_JMP_TARGET);

#ifdef  DEBUG
        if  (dspCode)
            printf("            DD      L_%02u_%02u\n", Compiler::s_compMethodsCount, target->bbNum);
#endif

        genEmitter->emitDataGenData(jmpTabOffs, target);

        jmpTabOffs += sizeof(void *);

        prefCnt--;
    };

    genEmitter->emitDataGenEnd();
    genEmitter->emitIns_IJ(EA_4BYTE_DSP_RELOC, (emitRegs)reg, jmpTabBase, offset);

#elif   TGT_SH3

    /* The emitter does all the hard work of generating the table jump */

    genEmitter->emitIns_JmpTab((emitRegs)reg, jumpCnt-1, jumpTab);

#else
#error  Unexpected target
#endif

}

/*****************************************************************************
 *
 *  Generate code for a switch statement.
 */

void                Compiler::genCodeForSwitch(GenTreePtr tree)
{
    unsigned        jumpCnt;
    BasicBlock * *  jumpTab;

    GenTreePtr      oper;
    regNumber       reg;

    assert(tree->gtOper == GT_SWITCH);
    oper = tree->gtOp.gtOp1;
    assert(oper->gtType <= TYP_INT);

    /* Get hold of the jump table */

    assert(compCurBB->bbJumpKind == BBJ_SWITCH);

    jumpCnt = compCurBB->bbJumpSwt->bbsCount;
    jumpTab = compCurBB->bbJumpSwt->bbsDstTab;

    /* Compute the switch value into some register */

#if TGT_SH3
    genComputeReg (oper, RBM_ALL & ~RBM_r00, true, true);
#else
    genCodeForTree(oper, 0);
#endif

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    tree->gtUsedRegs = oper->gtUsedRegs;
#endif

    /* Get hold of the register the value is in */

    assert(oper->gtFlags & GTF_REG_VAL);
    reg = oper->gtRegNum;

    genTableSwitch(reg, jumpCnt, jumpTab, true);
}

/*****************************************************************************/
#if     TGT_RISC
/*****************************************************************************
 *
 *  Generate a call - this is accomplished by loading the target address
 *  into some temp register and calling through it.
 */

void                Compiler::genCallInst(gtCallTypes callType,
                                          void   *    callHand,
                                          size_t      argSize,
                                          int         retSize)
{
    assert(genNonLeaf);
    assert(callType != CT_INDIRECT);

    /* Grab a temp register for the address */

    regNumber       areg = rsGrabReg(RBM_ALL);

    /* Load the method address into the register */

    genEmitter->emitIns_R_LP_M((emitRegs)areg,
                                callType,
                                callHand);

    // UNDONE: Track method addresses to reuse them!!!!

    rsTrackRegTrash(areg);

    /* Call through the address */

    genEmitter->emitIns_Call(argSize,
                             retSize,
#if     TRACK_GC_REFS
                             gcVarPtrSetCur,
                             gcRegGCrefSetCur,
                             gcRegByrefSetCur,
#endif
                             false,
                             (emitRegs)areg);
}

/*****************************************************************************/
#endif//TGT_RISC
/*****************************************************************************
 *
 *  A little helper to trash the given set of registers - this is only used
 *  after a call has been generated.
 */

#if     TGT_x86
inline
#endif
void                Compiler::genTrashRegSet(regMaskTP regMask)
{

#if     TGT_x86

    assert((regMask & ~(RBM_EAX|RBM_ECX|RBM_EDX)) == 0);

    if  (regMask & RBM_EAX) rsTrackRegTrash(REG_EAX);
    if  (regMask & RBM_ECX) rsTrackRegTrash(REG_ECX);
    if  (regMask & RBM_EDX) rsTrackRegTrash(REG_EDX);

#else

    while (regMask)
    {
        regMaskTP   regTemp;

        /* Get the next bit in the mask */

        regTemp  = genFindLowestBit(regMask);

        /* Trash the corresponding register */

        rsTrackRegTrash(genRegNumFromMask(regTemp));

        /* Clear the bit and continue if any more left */

        regMask -= regTemp;
    }

#endif

}

/*****************************************************************************
 *  Emit a call to a helper function.
 */

inline
void        Compiler::genEmitHelperCall(unsigned    helper,
                                        int         argSize,
                                        int         retSize)
{
    // Can we call the helper function directly

    emitter::EmitCallType emitCallType;

#ifdef NOT_JITC
    void * ftnAddr, **pFtnAddr;
    ftnAddr = eeGetHelperFtn(info.compCompHnd, (JIT_HELP_FUNCS)helper, &pFtnAddr);
    assert((!ftnAddr) != (!pFtnAddr));

    emitCallType = ftnAddr ? emitter::EC_FUNC_TOKEN
                           : emitter::EC_FUNC_TOKEN_INDIR;
#else
    emitCallType = emitter::EC_FUNC_TOKEN;
#endif

    genEmitter->emitIns_Call(emitCallType,
                             eeFindHelper(helper),
                             argSize,
                             retSize,
                             gcVarPtrSetCur,
                             gcRegGCrefSetCur,
                             gcRegByrefSetCur);
}

/*****************************************************************************
 *
 *  Push the given argument list, right to left; returns the total amount of
 *  stuff pushed.
 */

size_t              Compiler::genPushArgList(GenTreePtr args,
                                             GenTreePtr regArgs,
                                             unsigned   encodeMask,
                                             unsigned * regsPtr)
{
    size_t          size = 0;

    unsigned        addrReg;

    size_t          opsz;
    var_types       type;
    GenTreePtr      list = args;

#if STK_FASTCALL
    size_t          argBytes  = 0;
#endif

AGAIN:

#ifndef NDEBUG
    addrReg = 0xBEEFCAFE;   // to detect uninitialized use
#endif

    /* Get hold of the next argument value */

    args = list;
    if  (args->gtOper == GT_LIST)
    {
        args = list->gtOp.gtOp1;
        list = list->gtOp.gtOp2;
    }
    else
    {
        list = 0;
    }

#if USE_FASTCALL && STK_FASTCALL
//  printf("Passing argument at SP+%u:\n", rsCurArgStkOffs); gtDispTree(args);
#endif

    /* See what type of a value we're passing */

    type = args->TypeGet();

    opsz = genTypeSize(genActualType(type));

#if USE_FASTCALL && STK_FASTCALL

    argBytes = opsz;

    /* Register arguments are typed as "void" */

    if  (!argBytes)
    {

#if!OPTIMIZE_TAIL_REC
        assert(gtIsaNothingNode(args));
#else
        if    (gtIsaNothingNode(args))
#endif
        {
            assert(args->gtFlags & GTF_REG_ARG);

            // ISSUE: What about 64-bit register args? There appears to be
            // ISSUE: no obvious way of getting hold of the argument type.

            argBytes = sizeof(int);
        }
    }

#endif

    switch (type)
    {
    case TYP_BOOL:
    case TYP_BYTE:
    case TYP_SHORT:
    case TYP_CHAR:
    case TYP_UBYTE:

        /* Don't want to push a small value, make it a full word */

        genCodeForTree(args, 0);

        // Fall through, now the value should be in a register ...

    case TYP_INT:
    case TYP_REF:
    case TYP_BYREF:
#if !   CPU_HAS_FP_SUPPORT
    case TYP_FLOAT:
#endif

#if USE_FASTCALL
        if (args->gtFlags & GTF_REG_ARG)
        {
            /* one more argument is passed in a register */
            assert(rsCurRegArg < MAX_REG_ARG);

            /* arg is passed in the register, nothing on the stack */

            opsz = 0;
        }

#endif

#ifndef NOT_JITC
#ifdef  DEBUG

        /* Special case (hack): string constant address */

        if  (args->gtOper == GT_CNS_INT &&
             ((args->gtFlags & GTF_ICON_HDL_MASK) == GTF_ICON_STR_HDL))
        {
            static  unsigned    strCnsCnt = 0x10000000;

            if  (dspCode)
            {
                size_t          strCnsLen;
                const   char *  strCnsPtr;

                strCnsPtr = "UNDONE: get hold of string constant value";
                strCnsLen = strlen(strCnsPtr);

                /* Display the string in a readable way */

                printf("_S_%08X db      ", strCnsCnt);
                genDispStringLit(strCnsPtr);
                printf("\n");
            }
        }

#endif
#endif

        /* Is this value a handle? */

        if  (args->gtOper == GT_CNS_INT &&
             (args->gtFlags & GTF_ICON_HDL_MASK))
        {

#if     SMALL_TREE_NODES
            // GTF_ICON_HDL_MASK implies GFT_NODE_LARGE,
            //   unless we have a GTF_ICON_FTN_ADDR
            assert( args->gtFlags & GTF_NODE_LARGE     ||
                   (args->gtFlags & GTF_ICON_HDL_MASK) == GTF_ICON_FTN_ADDR);
#endif
#if !   INLINING
            assert(args->gtIntCon.gtIconCls == info.compScopeHnd);
#endif

            /* Emit a fixup for the push instruction */

            inst_IV_handle(INS_push, args->gtIntCon.gtIconVal, args->gtFlags,
#if defined(JIT_AS_COMPILER) || defined (LATE_DISASM)
                           args->gtIntCon.gtIconCPX, args->gtIntCon.gtIconCls);
#else
                           0, 0);
#endif
            genSinglePush(false);

            addrReg = 0;
            break;
        }

#if     TGT_x86

        /* Is the value a constant? */

        if  (args->gtOper == GT_CNS_INT)
        {

#if     REDUNDANT_LOAD
            regNumber       reg = rsIconIsInReg(args->gtIntCon.gtIconVal);

            if  (reg != REG_NA)
            {
                inst_RV(INS_push, reg, TYP_INT);
            }
            else
#endif
            {
                inst_IV(INS_push, args->gtIntCon.gtIconVal);
            }

            /* If the type is TYP_REF, then this must be a "null". So we can
               treat it as a TYP_INT as we dont need to report it as a GC ptr */

            assert(args->TypeGet() == TYP_INT ||
                   (varTypeIsGC(args->TypeGet()) && args->gtIntCon.gtIconVal == 0));

            genSinglePush(false);

            addrReg = 0;
            break;
        }

#endif

#if     USE_FASTCALL
        if (args->gtFlags & GTF_REG_ARG)
        {
            /* This must be a register arg temp assignment */

            assert(args->gtOper == GT_ASG);

            /* Evaluate it to the temp */

            genCodeForTree(args, 0);

            /* Increment the current argument register counter */

            rsCurRegArg++;

            addrReg = 0;
        }
        else
#endif
#if     TGT_x86
        if  (0)
        {
            // CONSIDER: Use "mov reg, [mem] ; push reg" when compiling for
            // CONSIDER: speed (not size) and if the value isn't already in
            // CONSIDER: a register and if a register is available (is this
            // CONSIDER: true on the P6 as well, though?).

            genCompIntoFreeReg(args, RBM_ALL);
            assert(args->gtFlags & GTF_REG_VAL);
            addrReg = genRegMask(args->gtRegNum);
            inst_RV(INS_push, args->gtRegNum, args->TypeGet());
            genSinglePush((type == TYP_REF ? true : false));
            rsMarkRegFree(addrReg);
        }
        else
#endif
        {
            /* This is a 32-bit integer non-register argument */

#if     STK_FASTCALL

            /* Pass this argument on the stack */

            genCompIntoFreeReg(args, RBM_ALL);
            assert(args->gtFlags & GTF_REG_VAL);
            addrReg = genRegMask(args->gtRegNum);

#if     TGT_RISC
            // UNDONE: Need to handle large stack offsets!!!!!
            assert(rsCurArgStkOffs <= MAX_SPBASE_OFFS);
            genEmitter->emitIns_A_R((emitRegs)args->gtRegNum, rsCurArgStkOffs);
#else
#error  Unexpected target
#endif

            rsMarkRegFree(addrReg);

#else

            addrReg = genMakeRvalueAddressable(args, 0, true);
#if     TGT_x86
            inst_TT(INS_push, args);
#else
#error  Unexpected target
#endif
            genSinglePush((type == TYP_REF ? true : false));
            genDoneAddressable(args, addrReg);

#endif

        }
        break;

    case TYP_LONG:
#if !   CPU_HAS_FP_SUPPORT
    case TYP_DOUBLE:
#endif

#if     TGT_x86

        /* Is the value a constant? */

        if  (args->gtOper == GT_CNS_LNG)
        {
            inst_IV(INS_push, (long)(args->gtLngCon.gtLconVal >> 32));
            genSinglePush(false);
            inst_IV(INS_push, (long)(args->gtLngCon.gtLconVal      ));
            genSinglePush(false);

            addrReg = 0;
        }
        else
        {
            addrReg = genMakeAddressable(args, 0, false);

            inst_TT(INS_push, args, sizeof(int));
            genSinglePush(false);
            inst_TT(INS_push, args);
            genSinglePush(false);
        }

#else

        regPairNo       regPair;

        /* Generate the argument into some register pair */

        genComputeRegPair(args, RBM_ALL, REG_PAIR_NONE, false, false);
        assert(args->gtFlags & GTF_REG_VAL);
        regPair = args->gtRegPair;
        addrReg = genRegPairMask(regPair);

        // UNDONE: Need to handle large stack offsets!!!!!

        assert(rsCurArgStkOffs+4 <= MAX_SPBASE_OFFS);

        genEmitter->emitIns_A_R((emitRegs)genRegPairLo(regPair), rsCurArgStkOffs);
        genEmitter->emitIns_A_R((emitRegs)genRegPairHi(regPair), rsCurArgStkOffs+4);

        genReleaseRegPair(args);

#endif

        break;

#if     CPU_HAS_FP_SUPPORT
    case TYP_FLOAT:
    case TYP_DOUBLE:
#endif

#if     TGT_x86

        /* Is the value a constant? */

        switch (args->gtOper)
        {
            GenTreePtr      temp;

        case GT_CNS_FLT:
            assert(opsz == 1*sizeof(long));
            inst_IV(INS_push, ((long *)&args->gtFltCon.gtFconVal)[0]);
            genSinglePush(false);
            addrReg = 0;
            break;

        case GT_CNS_DBL:
            assert(opsz == 2*sizeof(long));
            inst_IV(INS_push, ((long *)&args->gtDblCon.gtDconVal)[1]);
            genSinglePush(false);
            inst_IV(INS_push, ((long *)&args->gtDblCon.gtDconVal)[0]);
            genSinglePush(false);
            addrReg = 0;
            break;

        case GT_CAST:

            /* Is the value a cast from double/float ? */

            if  (args->gtOper == GT_CAST)
            {
                GenTreePtr      oper = args->gtOp.gtOp1;

                if  (oper->gtType == TYP_DOUBLE ||
                     oper->gtType == TYP_FLOAT)
                {
                    /* Load the value onto the FP stack */

                    genCodeForTreeFlt(oper, false);

                    /* Go push the value as a float/double */

                    addrReg = 0;
                    goto PUSH_FLT;
                }
            }

            // Fall through ....

        default:

            temp = genMakeAddrOrFPstk(args, &addrReg, false);
            if  (temp)
            {
                unsigned        offs;

                /* We have the address of the float operand, push its bytes */

                offs = opsz; assert(offs % sizeof(long) == 0);
                do
                {
                    offs -= sizeof(int);
                    inst_TT(INS_push, temp, offs);
                    genSinglePush(false);
                }
                while (offs);
            }
            else
            {
                /* The argument is on the FP stack -- pop it into [ESP-4/8] */

            PUSH_FLT:

                inst_RV_IV(INS_sub, REG_ESP, opsz);

                genSinglePush(false);
                if  (opsz == 2*sizeof(unsigned))
                    genSinglePush(false);

                genEmitter->emitIns_AR_R(INS_fstp, EA_ATTR(opsz), SR_NA, SR_ESP, 0);

                genFPstkLevel--;
            }

            gcMarkRegSetNpt(addrReg);
            break;
        }

#else

        assert(!"need non-x86 code to pass FP argument");

#endif

        break;

    case TYP_VOID:

#if USE_FASTCALL
        /* Is this a nothing node, defered register argument? */

        if (args->gtFlags & GTF_REG_ARG)
        {
            /* increment the register count and continue with the next argument */
            assert(gtIsaNothingNode(args));
            rsCurRegArg++;

            assert(opsz == 0);

            addrReg = 0;
            break;
        }

        // fall through...

#endif

#if OPTIMIZE_TAIL_REC

        /* This is the last argument for a tail-recursive call */

        if  (args->gtOper == GT_ASG)
            args->gtType = args->gtOp.gtOp1->gtType;

        genCodeForTree(args, 0);

        if  (args->gtOper == GT_ASG)
            args->gtType = TYP_VOID;

        /* The call above actually popped any preceding arguments, BTW */

        opsz    = 0;
        addrReg = 0;
        break;

#endif

    case TYP_STRUCT:
    {
        genCodeForTree(args->gtLdObj.gtOp1, 0);

        assert(args->gtLdObj.gtOp1->gtFlags & GTF_REG_VAL);
        regNumber reg = args->gtLdObj.gtOp1->gtRegNum;

        if (args->gtOper == GT_MKREFANY)
        {
            // create a new REFANY, class handle on top, then data
            genEmitter->emitIns_I(INS_push, EA_4BYTE, (int) args->gtLdObj.gtClass);
            genEmitter->emitIns_R(INS_push, EA_BYREF, (emitRegs)reg);
            opsz = 2 * sizeof(void*);
        }
        else
        {
            assert(args->gtOper == GT_LDOBJ);

            if (args->gtLdObj.gtClass == REFANY_CLASS_HANDLE)
            {
                // This is any REFANY.  The top item is non-gc (a class pointer)
                // the bottom is a byref (the data),
                genEmitter->emitIns_AR_R(INS_push, EA_4BYTE, SR_NA, (emitRegs)reg, sizeof(void*));
                genEmitter->emitIns_AR_R(INS_push, EA_BYREF, SR_NA, (emitRegs)reg, 0);
                opsz = 2 * sizeof(void*);
            }
            else
            {
                    // Get the number of DWORDS to copy to the stack
                opsz = eeGetClassSize(args->gtLdObj.gtClass);
                opsz = roundUp(opsz, sizeof(void*));
                unsigned slots = opsz / sizeof(void*);

                bool* gcLayout = (bool*) _alloca(slots*sizeof(bool));
                eeGetClassGClayout(args->gtLdObj.gtClass, gcLayout);
                for (int i = slots-1; i >= 0; --i)
                {
                    // size of EA_GCREF is a GC references to the scheduler
                    emitAttr size = gcLayout[i] ? EA_GCREF : EA_4BYTE;
                    genEmitter->emitIns_AR_R(INS_push, size, SR_NA, (emitRegs)reg, i*sizeof(void*));
                }
            }
        }
        gcMarkRegSetNpt(genRegMask(reg));    // Kill the pointer in op1
        addrReg = 0;
        break;
    }

    default:
        assert(!"unhandled/unexpected arg type");
        break;
    }

    /* Remember which registers we've used for the argument(s) */

#ifdef  SET_USED_REG_SET_DURING_CODEGEN
    *regsPtr |= args->gtUsedRegs;
#endif

    /* Update the current set of live variables */

    genUpdateLife(args);

    /* Update the current set of register pointers */

    assert(addrReg != 0xBEEFCAFE); gcMarkRegSetNpt(addrReg);

    /* Remember how much stuff we've pushed on the stack */

    size            += opsz;

    /* Update the current argument stack offset */

#if USE_FASTCALL && STK_FASTCALL
    rsCurArgStkOffs += argBytes;
#endif

    /* Continue with the next argument, if any more are present */

    if  (list) goto AGAIN;

#if USE_FASTCALL

    if (regArgs)
    {
        unsigned        i, j;

        struct
        {
            GenTreePtr  node;
            regNumber   regNum;
        }
                        regArgTab[MAX_REG_ARG];

        /* Move the deferred arguments to registers */

        assert(rsCurRegArg);
        assert(rsCurRegArg <= MAX_REG_ARG);

#ifdef  DEBUG
        for(i = 0; i < rsCurRegArg; i++)
            assert((rsMaskLock & genRegMask(genRegArgNum(i))) == 0);
#endif

        /* Construct the register argument table */

        for (list = regArgs, i = 0; list; i++)
        {
            args = list;
            if  (args->gtOper == GT_LIST)
            {
                args = list->gtOp.gtOp1;
                list = list->gtOp.gtOp2;
            }
            else
            {
                list = 0;
            }

            regArgTab[i].node   = args;
            regArgTab[i].regNum = (regNumber)((encodeMask >> (4*i)) & 0x000F);
        }

        assert(i == rsCurRegArg);

        /* Generate code to move the arguments to registers */

        for(i = 0; i < rsCurRegArg; i++)
        {
            regNumber   regNum;

            regNum = regArgTab[i].regNum;
            args   = regArgTab[i].node;

            assert(isRegParamType(args->TypeGet()));
            assert(args->gtType != TYP_VOID);

            /* Evaluate the argument to a register [pair] */

            if  (genTypeSize(genActualType(args->TypeGet())) == sizeof(int))
            {
                /* Check if this is the guess area for the resolve interface call
                 * Pass a size of EA_OFFSET*/
                if  (args->gtOper == GT_CLS_VAR && eeGetJitDataOffs(args->gtClsVar.gtClsVarHnd) >= 0)
                {
#if TGT_x86
                    genEmitter->emitIns_R_C(INS_mov,
                                            EA_OFFSET,
                                            (emitRegs)regNum,
                                            args->gtClsVar.gtClsVarHnd,
                                            0);

#else

                    assert(!"whoever added the above, please fill this in");

#endif

                    /* The value is now in the appropriate register */

                    args->gtFlags |= GTF_REG_VAL;
                    args->gtRegNum = regNum;

                    /* Mark the register as 'used' */

                    rsMarkRegUsed(args);
                }
                else
                {
                    genComputeReg(args, genRegMask(regNum), true, false, false);
                }

                assert(args->gtRegNum == regNum);
            }
            else
            {
#ifdef  DEBUG
                gtDispTree(args);
#endif
                assert(!"UNDONE: how do we know which reg pair to use?");
//              genComputeRegPair(args, 0, (regPairNo)regNum, false, false);
                assert(args->gtRegNum == regNum);
            }

            /* If any of the previously loaded arguments was spilled - reload it */

            for(j = 0; j < i; j++)
            {
                if (regArgTab[j].node->gtFlags & GTF_SPILLED)
                    rsUnspillReg(regArgTab[j].node, genRegMask(regArgTab[j].regNum), true);
            }
        }

#ifdef  DEBUG
        for (list = regArgs, i = 0; list;
             list = list->gtOp.gtOp2, i++)
        {
            assert(i < rsCurRegArg);
            assert(rsMaskUsed & genRegMask(genRegArgNum(i)));
            assert(list->gtOp.gtOp1->gtRegNum == regArgTab[i].regNum);
        }
#endif

    }

#endif

    /* Return the total size pushed */

    return size;
}

/*****************************************************************************/
#if GEN_COUNT_CALLS

unsigned            callCount[10];
const   char *      callNames[10] =
{
    "VM helper",    // 0
    "virtual",      // 1
    "interface",    // 2
    "recursive",    // 3
    "unknown",      // 4
    " 1 ..  4",     // 5
    " 5 ..  8",     // 6
    " 9 .. 16",     // 7
    "17 .. 32",     // 8
    "   >= 33",     // 9
};
unsigned            callHelper[JIT_HELP_LASTVAL+1];

#endif

/*****************************************************************************
 *  genCodeForCall() moves the target address of the tailcall into this
 *  register, before pushing it on the stack
 */

#define REG_TAILCALL_ADDR   REG_EAX

/*****************************************************************************
 *
 *  Generate code for a call. If the call returns a value in register(s), the
 *  register mask that describes where the result will be found is returned;
 *  otherwise, 0 is returned. The '*regsPtr' value will be set to the set of
 *  registers trashed by the call.
 */

unsigned            Compiler::genCodeForCall(GenTreePtr call,
                                             bool       valUsed,
                                             unsigned * regsPtr)
{
    int             retSize;

    unsigned        calleeTrashedRegs = 0, calleeTrashedRegsToSpill;
    size_t          argSize, args;
    unsigned        retVal;

#if     TGT_x86
    unsigned        saveStackLvl;
#if     INLINE_NDIRECT
    regNumbers      reg = REG_NA;
    LclVarDsc   *   varDsc = NULL;
#endif
#endif

#if     USE_FASTCALL

#if     NST_FASTCALL
    unsigned        savCurArgReg;
#else
#ifdef  DEBUG
    assert(genCallInProgress == false); genCallInProgress = true;
#endif
#endif

    unsigned        areg;

#endif

    unsigned        fptrRegs;

#if     TGT_x86
#ifdef  DEBUG

    unsigned        stackLvl = genEmitter->emitCurStackLvl;

    if (verbose) printf("Beg call [%08X] stack %02u [E=%02u]\n", call, genStackLevel, stackLvl);

#endif
#endif

    gtCallTypes     callType = call->gtCall.gtCallType;

    /* Make some sanity checks on the call node */

    // This is a call
    assert(call->gtOper == GT_CALL);
    // "vptr" and "this" only make sense for user functions
    assert((call->gtCall.gtCallObjp == 0 && call->gtCall.gtCallVptr == 0) ||
            callType == CT_USER_FUNC);
    // If there is vptr (virtual call), then there has to be a "this" pointer
    assert(call->gtCall.gtCallVptr == 0 || call->gtCall.gtCallObjp != 0);
    // "vptr" only makes sense if GTF_CALL_VIRT or GTF_CALL_VIRT_RES is set
    assert(call->gtCall.gtCallVptr == 0 || (call->gtFlags & (GTF_CALL_VIRT|GTF_CALL_VIRT_RES)));
    // tailcalls wont be done for helpers, caller-pop args, and check that
    // the global flag is set
    assert(!(call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL) ||
           (callType != CT_HELPER && !(call->gtFlags & GTF_CALL_POP_ARGS) &&
            compTailCallUsed));

#if TGT_x86

    unsigned pseudoStackLvl = 0;

    /* HACK: throw-range-check-failure BBs might start with a non-empty stack ! */
    /* We need to let the emitter know this so it can update the GC info        */

    if ((call->gtCall.gtCallMethHnd == eeFindHelper(CPX_RNGCHK_FAIL)  ||
         call->gtCall.gtCallMethHnd == eeFindHelper(CPX_ARITH_EXCPN)) &&
         !genFPused && genStackLevel != 0)
    {
        pseudoStackLvl = genStackLevel;
        assert(!"Blocks with non-empty stack on entry are NYI in the emitter");
    }

    /* All float temps must be spilled around function calls */

    assert(genFPstkLevel == 0);

    /* Mark the current stack level and list of pointer arguments */

    saveStackLvl = genStackLevel;

#else

    assert(genNonLeaf);

#endif

    /*-------------------------------------------------------------------------
     *  Set up the registers and arguments
     */

    /* Make sure the register mask is properly initialized */

    *regsPtr = 0;

    /* We'll keep track of how much we've pushed on the stack */

    argSize = 0;

#if USE_FASTCALL

#if TGT_x86

    /* If this is a resolve interface helper call
     * we have to allocate the guess area */

    if  (call->gtCall.gtCallMethHnd == eeFindHelper(CPX_RES_IFC))
    {
        /* HACK: This will only work for 2 registers because I have
         * to know where the guesss area is - remember the arguments
         * are shuffled */

        GenTreePtr      guessx;
        unsigned        zero = 0;

        assert(call->gtCall.gtCallRegArgs);

        /* Because of shufling the guess area will be the last
         * in the register argument list */

        guessx = call->gtCall.gtCallRegArgs;
        for(int i = 0; i < MAX_REG_ARG - 1; i++)
        {
            assert(guessx->gtOper == GT_LIST);
            guessx = guessx->gtOp.gtOp2;
        }

        assert(guessx); assert(guessx->gtOp.gtOp2 == 0);
        assert(guessx->gtOp.gtOp1->gtOper == GT_CNS_INT);
        assert(guessx->gtOp.gtOp1->gtIntCon.gtIconVal == 24);

        guessx->gtOp.gtOp1 = genMakeConst(&zero,
                                          sizeof(zero),
                                          TYP_INT,
                                          0,
                                          false);
    }

#endif

#if STK_FASTCALL

    /* Keep track of the argument stack offset */

    rsCurArgStkOffs = 0;

#else

    /*
        Make sure to save the current argument register status
        in case we have nested calls.
     */

    assert(rsCurRegArg <= MAX_REG_ARG);

    savCurArgReg = rsCurRegArg;

#endif

    rsCurRegArg = 0;

#endif

    /* Pass object pointer first */

    if  (call->gtCall.gtCallObjp)
    {
        if  (call->gtCall.gtCallArgs)
        {
            argSize += genPushArgList(call->gtCall.gtCallObjp,
                                      0,
                                      0,
                                      regsPtr);
        }
        else
        {
            argSize += genPushArgList(call->gtCall.gtCallObjp,
                                      call->gtCall.gtCallRegArgs,
                                      call->gtCall.regArgEncode,
                                      regsPtr);
        }
    }

    /* Then pass the arguments */

    if  (call->gtCall.gtCallArgs)
    {
        argSize += genPushArgList(call->gtCall.gtCallArgs,
                                  call->gtCall.gtCallRegArgs,
                                  call->gtCall.regArgEncode,
                                  regsPtr);
    }

    /* Record the register(s) used for the indirect call func ptr */

    fptrRegs = 0;

    if (callType == CT_INDIRECT)
    {
//      GTF_NON_GC_ADDR not preserved during constand folding. So we cant use the assert()
//      assert(call->gtCall.gtCallAddr->gtFlags & GTF_NON_GC_ADDR);

        fptrRegs  = genMakeRvalueAddressable(call->gtCall.gtCallAddr,
                                             0,
                                             true);
        *regsPtr |= fptrRegs;
    }

#if OPTIMIZE_TAIL_REC

    /* Check for a tail-recursive call */

    if  (call->gtFlags & GTF_CALL_TAILREC)
        goto DONE;

#endif

    /* Make sure any callee-trashed registers are saved */

#if GTF_CALL_REGSAVE
    if  (call->gtFlags & GTF_CALL_REGSAVE)
    {
        /* The return value reg(s) will definitely be trashed */

        switch (call->gtType)
        {
        case TYP_INT:
        case TYP_REF:
        case TYP_BYREF:
#if!CPU_HAS_FP_SUPPORT
        case TYP_FLOAT:
#endif
            calleeTrashedRegs = RBM_INTRET;
            break;

        case TYP_LONG:
#if!CPU_HAS_FP_SUPPORT
        case TYP_DOUBLE:
#endif
            calleeTrashedRegs = RBM_LNGRET;
            break;

        case TYP_VOID:
#if CPU_HAS_FP_SUPPORT
        case TYP_FLOAT:
        case TYP_DOUBLE:
#endif
            calleeTrashedRegs = 0;
            break;

        default:
            assert(!"unhandled/unexpected type");
        }
    }
    else
#endif
    {
        calleeTrashedRegs = RBM_CALLEE_TRASH;
    }

    *regsPtr |= calleeTrashedRegs;

    /* Spill any callee-saved registers which are being used */

    calleeTrashedRegsToSpill = calleeTrashedRegs & rsMaskUsed;

    // Ignore fptrRegs as it is needed only to perform the indirect call

    calleeTrashedRegsToSpill &= ~fptrRegs;

#if USE_FASTCALL

    /* do not spill the argument registers */
    calleeTrashedRegsToSpill &= ~genRegArgMask(rsCurRegArg);

#endif

    if (calleeTrashedRegsToSpill)
        rsSpillRegs(calleeTrashedRegsToSpill);

    /* If the method returns a GC ref, set size to EA_GCREF or EA_BYREF */

    retSize = sizeof(void *);

#if TRACK_GC_REFS

    if  (valUsed)
    {
        if      (call->gtType == TYP_REF ||
                 call->gtType == TYP_ARRAY)
        {
            retSize = EA_GCREF;
        }
        else if (call->gtType == TYP_BYREF)
        {
            retSize = EA_BYREF;
        }
    }

#endif

    /*-------------------------------------------------------------------------
     *  Generate the call
     */

    /* For caller-pop calls, the GC info will report the arguments as pending
       arguments as the caller explicitly pops them. Also should be
       reported as non-GC arguments as they effectively go dead at the
       call site (callee owns them)
     */

    args = (call->gtFlags & GTF_CALL_POP_ARGS) ? -argSize
                                               :  argSize;

    /* Treat special cases first */

#ifdef PROFILER_SUPPORT
#if     TGT_x86

    if (opts.compCallEventCB)
    {
        /* fire the event at the call site */
        /* alas, right now I can only handle calls via a method handle */
        if (call->gtCall.gtCallType == CT_USER_FUNC)
        {
            unsigned         saveStackLvl2 = genStackLevel;
            BOOL             bHookFunction;
            PROFILING_HANDLE handleTo, *pHandleTo;
            PROFILING_HANDLE handleFrom, *pHandleFrom;

            handleTo = eeGetProfilingHandle(call->gtCall.gtCallMethHnd, &bHookFunction, &pHandleTo);
            assert((!handleTo) != (!pHandleTo));

            // Give profiler a chance to back out of hooking this method
            if (bHookFunction)
            {
                handleFrom = eeGetProfilingHandle(info.compMethodHnd, &bHookFunction, &pHandleFrom);
                assert((!handleFrom) != (!pHandleFrom));

                // Give profiler a chance to back out of hooking this method
                if (bHookFunction)
                {
                    if (handleTo)
                        inst_IV(INS_push, (unsigned) handleTo);
                    else
                        genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC,
                                                 SR_NA, SR_NA, (int)pHandleTo);

                    genSinglePush(false);

                    if (handleFrom)
                        inst_IV(INS_push, (unsigned) handleFrom);
                    else
                        genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC,
                                                 SR_NA, SR_NA, (int)pHandleFrom);

                    genSinglePush(false);

                    genEmitHelperCall(CPX_PROFILER_CALLING,
                                      2*sizeof(int), // argSize
                                      0);            // retSize

                    /* Restore the stack level */

                    genStackLevel = saveStackLvl2;
                    genOnStackLevelChanged();
                }
            }
        }
    }

#endif // TGT_x86
#endif // PROFILER_SUPPORT

    /* Check for Delegate.Invoke. If so, we inline it. We get the
       target-object and target-function from the delegate-object, and do
       an indirect call.
     */

    if  (call->gtFlags & GTF_DELEGATE_INVOKE)
    {
        assert(call->gtCall.gtCallType == CT_USER_FUNC);
        assert(eeGetMethodAttribs(call->gtCall.gtCallMethHnd) & FLG_DELEGATE_INVOKE);
        assert(eeGetMethodAttribs(call->gtCall.gtCallMethHnd) & FLG_FINAL);

        /* Find the offsets of the 'this' pointer and new target */

        EEInfo          info;
        unsigned    instOffs;           // offset of new 'this' pointer
        unsigned    firstTgtOffs;       // offset of first target to invoke

        /* @TODO: The offsets returned by the following helper are off by 4 - should be fixed
         * QUESTION: In the final version will the offsets be statically known? */

        eeGetEEInfo(&info);
        instOffs = info.offsetOfDelegateInstance;
        firstTgtOffs = info.offsetOfDelegateFirstTarget;

#if !TGT_x86
        assert(!"Delegates NYI for non-x86");
#else
        /* Save the invoke-target-function in EAX (in ECX we have the pointer
         * to our delegate object) 'mov EAX, dword ptr [ECX + firstTgtOffs]' */

        genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE, (emitRegs)REG_EAX, (emitRegs)REG_ECX, firstTgtOffs);

        /* Set new 'this' in ECX - 'mov ECX, dword ptr [ECX + instOffs]' */

        genEmitter->emitIns_R_AR(INS_mov, EA_GCREF, (emitRegs)REG_ECX, (emitRegs)REG_ECX, instOffs);

        /* Call through EAX */

        genEmitter->emitIns_Call(emitter::EC_INDIR_R,
                                 NULL,      // Will be ignored
                                 args,
                                 retSize,
                                 gcVarPtrSetCur,
                                 gcRegGCrefSetCur,
                                 gcRegByrefSetCur,
                                 (emitRegs)REG_EAX);
#endif // !TGT_x86

    }
    else

    /*-------------------------------------------------------------------------
     *  Virtual calls
     */

    if  (call->gtFlags & GTF_CALL_VIRT)
    {
        GenTreePtr      vptrVal;
        regNumber       vptrReg;
        unsigned        vptrMask;

        unsigned        vtabOffs;
        regMaskTP       vptrRegs;

        assert(callType == CT_USER_FUNC);

        /* For     interface methods, vptrVal = obj-ref.
           For non-interface methods, vptrVal = vptr    */

        vptrVal  = call->gtCall.gtCallVptr; assert(vptrVal);

        /* Make sure the vtable ptr doesn't spill any register arguments */

#if USE_FASTCALL
        vptrRegs = RBM_ALL ^ genRegArgMask(rsCurRegArg);
#else
        vptrRegs = 0;
#endif

        /* Load the vtable val into a register */

        genCodeForTree(vptrVal, vptrRegs, vptrRegs);

        assert(vptrVal->gtFlags & GTF_REG_VAL);
        vptrReg  = vptrVal->gtRegNum;
        vptrMask = genRegMask(vptrReg);

#if USE_FASTCALL
        assert((call->gtFlags & GTF_CALL_INTF) || (vptrMask & ~genRegArgMask(rsCurRegArg)));
#endif

        /* Remember that we used an additional register */

        *regsPtr |= vptrMask;

        /* Get hold of the vtable offset (note: this might be expensive) */

        vtabOffs = eeGetMethodVTableOffset(call->gtCall.gtCallMethHnd);

        /* Is this an interface call? */

        if  (call->gtFlags & GTF_CALL_INTF)
        {
            if (getNewCallInterface())
            {
                EEInfo          info;

                CLASS_HANDLE cls = eeGetMethodClass(call->gtCall.gtCallMethHnd);

                assert(eeGetClassAttribs(cls) & FLG_INTERFACE);

                /* @TODO: add that to DLLMain and make info a DLL global */

                eeGetEEInfo(&info);

                /* Load the vptr into a register */

                genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                         (emitRegs)vptrReg, (emitRegs)vptrReg,
                                         info.offsetOfInterfaceTable);

                unsigned interfaceID, *pInterfaceID;
                interfaceID = eeGetInterfaceID(cls, &pInterfaceID);
                assert(!pInterfaceID || !interfaceID);

                // Can we directly use the interfaceID?

                if (!pInterfaceID)
                {
                    genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                             (emitRegs)vptrReg, (emitRegs)vptrReg,
                                             interfaceID * 4);
                }
                else
                {
                    genEmitter->emitIns_R_AR(INS_add, EA_4BYTE_DSP_RELOC,
                                             (emitRegs)vptrReg, SR_NA, (int)pInterfaceID);
                    genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE,
                                             (emitRegs)vptrReg, (emitRegs)vptrReg, 0);
                }
            }
            else
            {
#if !USE_FASTCALL // Interface calls are now morphed earlier ------------------

                int             IHX;
                unsigned        intfID;
                GenTreePtr      guessx;

                unsigned        zero = 0;

                size_t          helperArgs = 0;

#if     USE_FASTCALL && !TGT_x86
                regNumber       areg;
                size_t          aoff;
#endif

#if     TGT_x86
                unsigned        saveStackLvl2 = genStackLevel;
#endif

                BOOL            trustedClass = TRUE;

#ifdef  NOT_JITC
                trustedClass = info.compCompHnd->getScopeAttribs(info.compScopeHnd) & FLG_TRUSTED;
#endif

                /* If using fastcall, pass args on the stack */

#if     USE_FASTCALL && !TGT_x86

                areg = rsGrabReg(RBM_ALL);
                aoff = 0;

#endif

                /* Get the interface ID */

                intfID = eeGetInterfaceID(call->gtCall.gtCallMethHnd);

                /* Allocate the 'guess' area */

                guessx = genMakeConst(&zero, sizeof(zero), TYP_INT, 0, false);

                /* Pass the address of the 'guess' area */

#if     USE_FASTCALL && !TGT_x86

                inst_RV_TT(INS_mov, areg, guessx, 0);
                rsTrackRegTrash(areg);
                genEmitter->emitIns_A_R((emitRegs)areg, aoff);
                aoff += sizeof(void*);

#else

                inst_AV(INS_push, guessx);

                /* Keep track of ESP for EBP-less frames */

                genSinglePush(false);

#endif

                helperArgs += sizeof(int);

                /* Pass the interface ID */

#if     USE_FASTCALL && !TGT_x86

                genSetRegToIcon(areg, intfID, TYP_INT);
                genEmitter->emitIns_A_R((emitRegs)areg, aoff);
                aoff += sizeof(void*);

#else

                inst_IV_handle(INS_push, intfID, GTF_ICON_IID_HLD, 0, 0);

                /* Keep track of ESP for EBP-less frames */

                genSinglePush(false);

#endif

                helperArgs += sizeof(int);

                /* Pass the address of the object */

#if     USE_FASTCALL && !TGT_x86

                genEmitter->emitIns_A_R((emitRegs)vptrReg, aoff);
                aoff += sizeof(void*);

#else

                inst_RV(INS_push, vptrReg, TYP_REF);

                /* Keep track of ESP for EBP-less frames */

                genSinglePush(true);

#endif

                helperArgs += sizeof(int);

                /* The register no longer holds a live pointer value */

                gcMarkRegSetNpt(vptrMask);

                /* Figure out the appropriate 'resolve interface' helper */

                if  (trustedClass)
                {
                    if  (!vmSdk3_0)
                        IHX = CPX_RES_IFC_TRUSTED;
                    else
                        IHX = CPX_RES_IFC_TRUSTED2;
                }
                else
                {
                    IHX = CPX_RES_IFC;
                }

                /* Now issue the call to the helper */

#if     TGT_x86

                genEmitHelperCall(IHX, helperArgs, retSize);

                /* Restore the stack level */

                genStackLevel = saveStackLvl2;
                genOnStackLevelChanged();

#else

                assert(genNonLeaf);

                genCallInst             (CT_HELPER,
                                         IHX,
                                         NULL,
                                         helperArgs,
                                         retSize);

#endif

                /* Mark all callee trashed registers as trashed */

                genTrashRegSet(RBM_CALLEE_TRASH);

                /* The vtable address is now in EAX */

                vptrReg = REG_INTRET;

#else //USE_FASTCALL for interface calls --------------------------------------

#if   NEW_CALLINTERFACE
#if     TGT_x86

                regNumber   reg;

#if NEW_CALLINTERFACE_WITH_PUSH
                unsigned        saveStackLvl2 = genStackLevel;
#endif

                /* The register no longer holds a live pointer value */

                gcMarkRegSetNpt(vptrMask);

                /* emit */

                reg = rsGrabReg(RBM_EAX);

                assert(reg == REG_EAX);

                void * hint, **pHint;
                hint = eeGetHintPtr(call->gtCall.gtCallMethHnd, &pHint);

                /* mov eax, address of hint ptr */

                if (pHint)
                {
                    genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE_DSP_RELOC,
                                             (emitRegs)reg, SR_NA, (int)pHint);
                    rsTrackRegTrash(reg);
                }
                else
                {
                    genSetRegToIcon(reg, (long)hint, TYP_INT);
                }

#if NEW_CALLINTERFACE_WITH_PUSH

                inst_RV(INS_push, reg, TYP_INT);

                /* Keep track of ESP for EBP-less frames */

                genSinglePush(false);

#endif

                /* now call indirect through eax (call dword ptr[eax]) */

                genEmitter->emitIns_Call(emitter::EC_INDIR_ARD,
                                         NULL,          /* Will be ignored */
#if NEW_CALLINTERFACE_WITH_PUSH
                                         sizeof(int),   /* argSize */
#else
                                         0,             /* argSize */
#endif
                                         0,             /* retSize */
                                         gcVarPtrSetCur,
                                         gcRegGCrefSetCur,
                                         gcRegByrefSetCur,
                                         SR_EAX         /* ireg */
                                        );

#if NEW_CALLINTERFACE_WITH_PUSH
                /* Restore the stack level */

                genStackLevel = saveStackLvl2;
                genOnStackLevelChanged();
#endif

                /* The vtable address is now in EAX */

                vptrReg = REG_INTRET;

#endif  //TGT_x86
#endif  //NEW_CALLINTERFACE
#endif  //USE_FASCALL for interface calls -------------------------------------
            }

        } //------------------ END if(GTF_CALL_INTF) --------------------------

        /* Call through the appropriate vtable slot */

#ifdef  NOT_JITC
#if     GEN_COUNT_CALLS
        genEmitter.emitCodeGenByte(0xFF);
        genEmitter.emitCodeGenByte(0x05);
        genEmitter.emitCodeGenLong((int)&callCount[(call->gtFlags & GTF_CALL_INTF) ? 2 : 1]);
#endif
#endif

        if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
        {
            /* Load the function address: "[vptrReg+vtabOffs] -> reg_intret" */

#if     TGT_x86
            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE, (emitRegs)REG_TAILCALL_ADDR,
                                     (emitRegs)vptrReg, vtabOffs);
#else
            if  (vtabOffs)
                genEmitter->emitIns_R_RD((emitRegs)vptrReg,
                                         (emitRegs)vptrReg,
                                         vtabOffs,
                                         sizeof(void*));
            else
                genEmitter->emitIns_R_IR((emitRegs)vptrReg,
                                         (emitRegs)vptrReg,
                                         false,
                                         sizeof(void*));
#endif
        }
        else
        {
#if     TGT_x86

            genEmitter->emitIns_Call(emitter::EC_FUNC_VIRTUAL,
                                     call->gtCall.gtCallMethHnd,
                                     args,
                                     retSize,
                                     gcVarPtrSetCur,
                                     gcRegGCrefSetCur,
                                     gcRegByrefSetCur,
                                     (emitRegs)vptrReg,     // ireg
                                     SR_NA,                 // xreg
                                     0,                     // xmul
                                     vtabOffs);             // disp

#else //TGT_x86

            /* Load the function address: "[vptrReg+vtabOffs] -> vptrReg" */

            if  (vtabOffs)
                genEmitter->emitIns_R_RD((emitRegs)vptrReg,
                                         (emitRegs)vptrReg,
                                         vtabOffs,
                                         sizeof(void*));
            else
                genEmitter->emitIns_R_IR((emitRegs)vptrReg,
                                         (emitRegs)vptrReg,
                                         false,
                                         sizeof(void*));

            /* Call through the address */

            genEmitter->emitIns_Call(args,
                                     retSize,
#if     TRACK_GC_REFS
                                     gcVarPtrSetCur,
                                     gcRegGCrefSetCur,
                                     gcRegByrefSetCur,
#endif
                                     false,
                                     (emitRegs)vptrReg);
#endif//TGT_x86

        }

    }
    else //------------------------ Non-virtual calls -------------------------
    {
        gtCallTypes     callType = call->gtCall.gtCallType;
        METHOD_HANDLE   methHnd  = call->gtCall.gtCallMethHnd;

#ifdef  NOT_JITC
#if     GEN_COUNT_CALLS

        genEmitter.emitCodeGenByte(0xFF);
        genEmitter.emitCodeGenByte(0x05);

        if      (callType == CT_HELPER)
        {
            int         index = CPX;

            genEmitter.emitCodeGenLong((int)&callCount[0]);

            assert(index >= 0 && index < sizeof(callHelper)/sizeof(callHelper[0]));

            genEmitter.emitCodeGenByte(0xFF);
            genEmitter.emitCodeGenByte(0x05);
            genEmitter.emitCodeGenLong((int)(callHelper+index));
        }
        else if (eeIsOurMethod(callType, CPX, CLS))
        {
            genEmitter.emitCodeGenLong((int)&callCount[3]);
        }
        else
        {
            unsigned            codeSize;
            BYTE    *           codeAddr;

            JITGetMethodCode(JITgetMethod(CLS, CPX), &codeAddr,
                                                     &codeSize);

            genEmitter.emitCodeGenLong((int)&callCount[0]);

            assert(index >= 0 && index < sizeof(callHelper)/sizeof(callHelper[0]));

            genEmitter.emitCodeGenByte(0xFF);
            genEmitter.emitCodeGenByte(0x05);
            genEmitter.emitCodeGenLong((int)(callHelper+index));
        }
        else if (eeIsOurMethod(callType, CPX, CLS))
        {
            genEmitter.emitCodeGenLong((int)&callCount[3]);
        }
        else
            genEmitter.emitCodeGenLong((int)&callCount[9]);

#endif
#endif

        /*
            For (final and private) functions which were called with
            invokevirtual, but which we call directly, we need to
            dereference the object pointer to make sure it's not NULL.
         */

        if (call->gtFlags & GTF_CALL_VIRT_RES)
        {
            GenTreePtr vptr = call->gtCall.gtCallVptr;

            if (vptr) // This will be null for a call on "this"
            {
                /* Load the vtable address into a register */

                genCodeForTree(vptr, 0);
                assert(vptr->gtFlags & GTF_REG_VAL);

                /* Remember that we used an additional register */

                *regsPtr |= genRegMask(vptr->gtRegNum);
            }
        }

#if     INDIRECT_CALLS


        bool    callDirect = false;

        // Check is we can directly call the function, or if we need to
        // use an (single/double) indirection.

        void *  ftnAddr = NULL, **pFtnAddr = NULL, ***ppFtnAddr = NULL;

        if (callType == CT_HELPER)
        {
            ftnAddr = eeGetHelperFtn(info.compCompHnd,
                                     eeGetHelperNum(methHnd),
                                     &pFtnAddr);
            assert((!ftnAddr) != (!pFtnAddr));

            if (ftnAddr)
                callDirect = true;
        }
        else if (!opts.compDbgEnC && eeIsOurMethod(methHnd))
        {
            callDirect = true;
        }
        else if (callType == CT_USER_FUNC)
        {
            // direct access or single or double indirection

            InfoAccessType accessType;
            void * addr = eeGetMethodEntryPoint(methHnd, &accessType);
            switch(accessType)
            {
            case IAT_VALUE  :   ftnAddr = (void *  )addr; callDirect = true; break;
            case IAT_PVALUE :  pFtnAddr = (void ** )addr;                    break;
            case IAT_PPVALUE: ppFtnAddr = (void ***)addr;                    break;
            default: assert(!"Bad accessType");
            }
        }

        if  (!callDirect)
        {
            if  (callType == CT_INDIRECT)
            {
                assert(genStillAddressable(call->gtCall.gtCallAddr));

                if (call->gtCall.gtCallCookie)
                {
                    /* load eax with the real target */

                    inst_RV_TT(INS_mov, REG_EAX, call->gtCall.gtCallAddr);

                    inst_IV(INS_push, call->gtCall.gtCallCookie);

                    /* Keep track of ESP for EBP-less frames */

                    genSinglePush(false);

                    args += sizeof(void *);

#if 0
                    /*NOTE: This needs to be enabled as soon as we call the
                            real unmanaged target (as opposed to calling a stub)!
                     */

                    /* Are we supposed to pop the arguments? */

                    if  (call->gtFlags & GTF_CALL_POP_ARGS)
                        argSize -= sizeof(void *);
                    else
                        argSize += sizeof(void *);
#endif

                    genEmitter->emitIns_Call(emitter::EC_FUNC_ADDR,
                                             (void *) *((unsigned *)eeGetPInvokeStub()),
                                             args,
                                             retSize,
                                             gcVarPtrSetCur,
                                             gcRegGCrefSetCur,
                                             gcRegByrefSetCur);
                }
                else
                {
#if     TGT_x86
                    if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
                        inst_RV_TT(INS_mov, REG_TAILCALL_ADDR, call->gtCall.gtCallAddr);
                    else
                        instEmit_indCall(call, args, retSize);
#else
                    assert(!"non-x86 indirect call");
#endif
                }

                genDoneAddressable(call->gtCall.gtCallAddr, fptrRegs);
            }
            else // callType != CT_INDIRECT
            {
                assert(callType == CT_USER_FUNC || callType == CT_HELPER);

#if     TGT_x86
#if     INLINE_NDIRECT

                if (call->gtFlags & GTF_CALL_UNMANAGED)
                {
                    assert(callType == CT_USER_FUNC);
                    assert(info.compCallUnmanaged != 0);

                    /* We are about to call unmanaged code directly.
                       Before we can do that we have to emit the following sequence:

                       mov  reg, dword ptr [tcb_address]
                       mov  dword ptr [frame.callTarget], MethodToken
                       mov  dword ptr [frame.callSiteTracker], esp
                       mov  byte  ptr [tcb+offsetOfGcState], 0
                       call "nativeFunction"

                     */

                    unsigned    baseOffset  = lvaTable[lvaScratchMemVar].lvStkOffs +
                                                  info.compNDFrameOffset;

                    reg     = REG_EAX;
                    varDsc  = &lvaTable[info.compLvFrameListRoot];

                    if (varDsc->lvRegister)
                    {
                        reg = (regNumbers)varDsc->lvRegNum;
                    }
                    else
                    {
                        /* mov eax, dword ptr [tcb address]    */

                        genEmitter->emitIns_R_AR (INS_mov,
                                                  EA_4BYTE,
                                                  SR_EAX,
                                                  SR_EBP,
                                                  varDsc->lvStkOffs);
                        reg = REG_EAX;
                    }

                    *regsPtr |= genRegMask(reg);

                    /* mov   dword ptr [frame.callSiteTarget], "MethodDesc" */

                    genEmitter->emitIns_I_AR (INS_mov,
                                              EA_4BYTE,
                                              (int)call->gtCall.gtCallMethHnd,
                                              SR_EBP,
                                              baseOffset
                                  + info.compEEInfo.offsetOfInlinedCallFrameCallTarget,
                                              0,
                                              NULL);

                    /* mov   dword ptr [frame.callSiteTracker], esp */

                    genEmitter->emitIns_AR_R (INS_mov,
                                              EA_4BYTE,
                                              SR_ESP,
                                              SR_EBP,
                                              baseOffset
                                  + info.compEEInfo.offsetOfInlinedCallFrameCallSiteTracker);

                    /* mov   byte  ptr [tcb+offsetOfGcState], 0 */

                    genEmitter->emitIns_I_AR (INS_mov,
                                              EA_1BYTE,
                                              0,
                                              (emitRegs)reg,
                                              info.compEEInfo.offsetOfGCState);

                    genEmitter->emitIns_Call( emitter::EC_FUNC_TOKEN_INDIR,
                                              eeMarkNativeTarget(call->gtCall.gtCallMethHnd),
                                              args,
                                              retSize,
                                              gcVarPtrSetCur,
                                              gcRegGCrefSetCur,
                                              gcRegByrefSetCur);

                    /* */
                }
                else
#endif  //INLINE_NDIRECT
                {
                    if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
                    {
                        assert(callType == CT_USER_FUNC);
                        assert(pFtnAddr && !ppFtnAddr); // @TODO: Tailcall and installojit
                        genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE, (emitRegs)REG_TAILCALL_ADDR,
                                                 (emitRegs)REG_NA, (int)pFtnAddr);
                    }
                    else
                    {
                        if (pFtnAddr)
                        {
                            genEmitter->emitIns_Call( emitter::EC_FUNC_TOKEN_INDIR,
                                                      methHnd,
                                                      args,
                                                      retSize,
                                                      gcVarPtrSetCur,
                                                      gcRegGCrefSetCur,
                                                      gcRegByrefSetCur);
                        }
                        else
                        {
                            // Double-indirection. Load the address into a register
                            // and call indirectly through the register

                            assert(ppFtnAddr);
                            genEmitter->emitIns_R_AR(INS_mov,
                                                     EA_4BYTE_DSP_RELOC,
                                                     SR_EAX,
                                                     SR_NA, (int)ppFtnAddr);
                            genEmitter->emitIns_Call(emitter::EC_INDIR_ARD,
                                                     NULL, // will be ignored
                                                     args,
                                                     retSize,
                                                     gcVarPtrSetCur,
                                                     gcRegGCrefSetCur,
                                                     gcRegByrefSetCur,
                                                     SR_EAX);
                        }
                    }
                }
#else
                assert(!"non-x86 indirect call");
#if INLINE_NDIRECT
#error hoisting of NDirect stub NYI for RISC platforms
#endif
#endif
            }
        }
        else

#endif // INDIRECT_CALLS

        {
            if (callType == CT_INDIRECT)
            {
                assert(genStillAddressable(call->gtCall.gtCallAddr));

#if     TGT_x86
                if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
                    inst_RV_TT(INS_mov, REG_TAILCALL_ADDR, call->gtCall.gtCallAddr);
                else
                    instEmit_indCall(call, args, retSize);
#else
                assert(!"non-x86 indirect call");
#endif

                genDoneAddressable(call->gtCall.gtCallAddr, fptrRegs);
            }
            else
            {
                assert(callType == CT_USER_FUNC || callType == CT_HELPER);

                if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
                {
                    assert(callType == CT_USER_FUNC);
                    void * addr = eeGetMethodPointer(call->gtCall.gtCallMethHnd, NULL);
                    genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE, (emitRegs)REG_TAILCALL_ADDR,
                                             (emitRegs)REG_NA, (int)addr);
                }
                else
                {
#if     TGT_x86
                    genEmitter->emitIns_Call(emitter::EC_FUNC_TOKEN,
                                             methHnd,
                                             args,
                                             retSize,
                                             gcVarPtrSetCur,
                                             gcRegGCrefSetCur,
                                             gcRegByrefSetCur);
#else
                                 genCallInst(callType,
                                             methHnd,
                                             args,
                                             retSize);
#endif
                }
            }
        }
    }

    /*-------------------------------------------------------------------------
     *  For tailcalls, REG_INTRET contains the address of the target function,
     *  enregistered args are in the correct registers, and the stack arguments
     *  have been pushed on the stack. Now call the stub-sliding helper
     */

    if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
    {
        assert(0 <= (int)args); // caller-pop args not supported for tailcall

#if TGT_x86

        // Push the count of the incoming stack arguments

        int nOldStkArgs = (compArgSize - (rsCalleeRegArgNum * sizeof(void *))) / sizeof(void*);
        genEmitter->emitIns_I(INS_push, EA_4BYTE, nOldStkArgs);
        genSinglePush(false); // Keep track of ESP for EBP-less frames
        args += sizeof(void*);

        // Push the count of the outgoing stack arguments

        genEmitter->emitIns_I(INS_push, EA_4BYTE, argSize/sizeof(void*));
        genSinglePush(false); // Keep track of ESP for EBP-less frames
        args += sizeof(void*);

        // Push info about the callee-saved registers to be restored
        // For now, we always spill all registers if compTailCallUsed

        DWORD calleeSavedRegInfo = (0x7 << 29) | // mask of EDI, ESI, EBX
                                   (0x0 << 28) | // accessed relative to esp
                                            0;   // offset of first saved reg
        genEmitter->emitIns_I(INS_push, EA_4BYTE, calleeSavedRegInfo);
        genSinglePush(false); // Keep track of ESP for EBP-less frames
        args += sizeof(void*);

        // Push the address of the target function

        genEmitter->emitIns_R(INS_push, EA_4BYTE, (emitRegs)REG_TAILCALL_ADDR);
        genSinglePush(false); // Keep track of ESP for EBP-less frames
        args += sizeof(void*);

        // Now call the helper

        genEmitHelperCall(CPX_TAILCALL, args, retSize);

#endif // TG_x86

    }

    /*-------------------------------------------------------------------------
     *  Done with call.
     *  Trash registers, pop arguments if needed, etc
     */

#if USE_FASTCALL

    /* Mark the argument registers as free */

    assert(rsCurRegArg <= MAX_REG_ARG);

    for(areg = 0; areg < rsCurRegArg; areg++)
        rsMarkRegFree(genRegMask(genRegArgNum(areg)));

    /* restore the old argument register status */

#if NST_FASTCALL
    rsCurRegArg = savCurArgReg; assert(rsCurRegArg <= MAX_REG_ARG);
#endif

#endif

    /* Mark all trashed registers as such */

    if  (calleeTrashedRegs)
        genTrashRegSet(calleeTrashedRegs);

#if OPTIMIZE_TAIL_REC
DONE:
#endif

#if     TGT_x86

#ifdef  DEBUG

    if  (!(call->gtFlags & GTF_CALL_POP_ARGS))
    {
        if (verbose) printf("End call [%08X] stack %02u [E=%02u] argSize=%u\n", call, saveStackLvl, genEmitter->emitCurStackLvl, argSize);

        assert(stackLvl == genEmitter->emitCurStackLvl);
    }

#endif

    /* All float temps must be spilled around function calls */

    assert(genFPstkLevel == 0);

    /* The function will pop all arguments before returning */

    genStackLevel = saveStackLvl;
    genOnStackLevelChanged();

#endif

    /* No trashed registers may possibly hold a pointer at this point */

#ifdef  DEBUG
#if     TRACK_GC_REFS
    unsigned ptrRegs = (gcRegGCrefSetCur|gcRegByrefSetCur);
    if  (ptrRegs & calleeTrashedRegs & ~rsMaskVars)
        printf("Bad call handling for %08X\n", call);
    assert((ptrRegs & calleeTrashedRegs & ~rsMaskVars) == 0);
#endif
#endif

#if TGT_x86

    /* Are we supposed to pop the arguments? */

    if  (call->gtFlags & GTF_CALL_POP_ARGS)
    {
        assert(args == -argSize);

        if (argSize)
        {
            genAdjustSP(argSize);

            /*HACK don't schedule the stack adjustment away from the call instruction */
            /* We ran into problems with displacement sizes, so for now we take the   */
            /* sledge hammer. The real fix would be in the instruction scheduler to   */
            /* take the instructions accessing a local into account */

            if (!genFPused && opts.compSchedCode)
                genEmitter->emitIns_SchedBoundary();
        }
    }

    /* HACK (Part II): If we emitted the range check failed helper call
       on a non-empty stack, we now have to separate the argument pop from
       popping the temps. Otherwise the stack crawler would not know about
       the temps. */

    if  (pseudoStackLvl)
    {
        assert(call->gtType == TYP_VOID);

        /* Generate NOP */

        instGen(INS_nop);
    }

#endif

#if USE_FASTCALL && !NST_FASTCALL && defined(DEBUG)
    assert(genCallInProgress == true); genCallInProgress = false;
#endif

    /* What does the function return? */

    retVal    = REG_NA;

    switch (call->gtType)
    {
    case TYP_REF:
    case TYP_ARRAY:
    case TYP_BYREF:
        gcMarkRegPtrVal(REG_INTRET, call->TypeGet());

        // Fall through ...

    case TYP_INT:
#if!CPU_HAS_FP_SUPPORT
    case TYP_FLOAT:
#endif
        *regsPtr |= RBM_INTRET;
        retVal    = REG_INTRET;
        break;

    case TYP_LONG:
#if!CPU_HAS_FP_SUPPORT
    case TYP_DOUBLE:
#endif
        *regsPtr |= RBM_LNGRET;
        retVal    = REG_LNGRET;
        break;

#if CPU_HAS_FP_SUPPORT
    case TYP_FLOAT:
    case TYP_DOUBLE:

#if TGT_x86

        /* Tail-recursive calls leave nothing on the FP stack */

#if OPTIMIZE_TAIL_REC
        if  (call->gtFlags & GTF_CALL_TAILREC)
            break;
#endif

        genFPstkLevel++;
#else
#error  Unexpected target
#endif

        break;
#endif

    case TYP_VOID:
        break;

    default:
        assert(!"unexpected/unhandled fn return type");
    }

#if INLINE_NDIRECT
    /* We now have to generate the "call epilog" (if it was a call to unmanaged code).

       First we have to mark in the hoisted NDirect stub that we are back
       in managed code. Then we have to check (a global flag) whether GC is
       pending or not. If so, we just call into a jit-helper.
       Right now we have this call always inlined, i.e. we always skip around
       the jit-helper call.
       Note:
       The tcb address is a regular local (initialized in the prolog), so it is either
       enregistered or in the frame:

            [mov ecx, tcb_address] OR tcb_address is already in a reg
            mov  byte ptr[reg+offsetOfGcState], 1
            cmp  "global GC pending flag', 0
            je   @f
            push reg         ; the would like to get the tcb
            call @callGC
        @@:
     */

    if (varDsc)
    {
        BasicBlock  *   clab_nostop;

        if (varDsc->lvRegister)
        {
            /* make sure that register live across the call */

            assert(reg == varDsc->lvRegNum);
            assert(genRegMask(reg) & RBM_CALLEE_SAVED);

            *regsPtr |= genRegMask(reg);
        }
        else
        {
            /* mov   ecx, dword ptr [tcb address]    */

            genEmitter->emitIns_R_AR (INS_mov,
                                      EA_4BYTE,
                                      SR_ECX,
                                      SR_EBP,
                                      varDsc->lvStkOffs);
            reg = REG_ECX;
            *regsPtr |= RBM_ECX;
        }

        /* mov   byte ptr [tcb+offsetOfGcState], 1 */

        genEmitter->emitIns_I_AR (INS_mov,
                                  EA_1BYTE,
                                  1,
                                  (emitRegs)reg,
                                  info.compEEInfo.offsetOfGCState);

#if 0
        //CONSIDER: maybe we need to reset the track field on return */
        /* reset track field in frame */

        genEmitter->emitIns_I_AR (INS_mov,
                                  EA_4BYTE,
                                  0,
                                  SR_EBP,
                                  lvaTable[lvaScratchMemVar].lvStkOffs
                                  + info.compNDFrameOffset
                                  + info.compEEInfo.offsetOfInlinedCallFrameCallSiteTracker);
#endif

        /* test global flag (we return to managed code) */

        LONG * addrOfCaptureThreadGlobal, **pAddrOfCaptureThreadGlobal;

        addrOfCaptureThreadGlobal = eeGetAddrOfCaptureThreadGlobal(&pAddrOfCaptureThreadGlobal);
        assert((!addrOfCaptureThreadGlobal) != (!pAddrOfCaptureThreadGlobal));

        // Can we directly use addrOfCaptureThreadGlobal?

        if (addrOfCaptureThreadGlobal)
        {
            genEmitter->emitIns_C_I  (INS_cmp,
                                      EA_1BYTE,
                                      FLD_GLOBAL_DS,
                                      (int) addrOfCaptureThreadGlobal,
                                      0);
        }
        else
        {
            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE_DSP_RELOC, SR_ECX,
                                     SR_NA, (int)pAddrOfCaptureThreadGlobal);
            genEmitter->emitIns_C_R  (INS_cmp,
                                      EA_1BYTE,
                                      FLD_GLOBAL_DS,
                                      SR_ECX,
                                      0);
        }

        /* */
        clab_nostop = genCreateTempLabel();

        /* Generate the conditional jump */

        inst_JMP(genJumpKindForOper(GT_EQ,true), clab_nostop);

#if 0
        /* Mark the current stack level and list of pointer arguments */

        saveStackLvl = genStackLevel;

        /* push tcb */

        genEmitter->emitIns_R(INS_push, EA_4BYTE, (emitRegs)reg);

        genSinglePush(false);

        genEmitHelperCall(CPX_CALL_GC,
                         sizeof(int),   /* argSize */
                         0);            /* retSize */

        /* The function will pop all arguments before returning */

        genStackLevel = saveStackLvl;
        genOnStackLevelChanged();
#else
#if 1
        /* save return value (if necessary) */
        if  (retVal != REG_NA)
        {
            /*@TODO: what about float/double returns? */
            /*       right now we just leave the result on the FPU stack */
            /*       in the hope that the jit-helper will leave it there. */

            if (retVal == REG_INTRET || retVal == REG_LNGRET)
            {
                /* mov [frame.callSiteTracker], esp */

                genEmitter->emitIns_AR_R (INS_mov,
                                          EA_4BYTE,
                                          SR_EAX,
                                          SR_EBP,
                                          lvaTable[lvaScratchMemVar].lvStkOffs
                                          + info.compNDFrameOffset
                                          + info.compEEInfo.sizeOfFrame);
            }

            if (retVal == REG_LNGRET)
            {
                /* mov [frame.callSiteTracker], esp */

                genEmitter->emitIns_AR_R (INS_mov,
                                          EA_4BYTE,
                                          SR_EDX,
                                          SR_EBP,
                                          lvaTable[lvaScratchMemVar].lvStkOffs
                                          + info.compNDFrameOffset
                                          + info.compEEInfo.sizeOfFrame
                                          + sizeof(int));
            }
        }
#endif
        /* calling helper with internal convention */
        if (reg != REG_ECX)
            genEmitter->emitIns_R_R(INS_mov, EA_4BYTE, SR_ECX, (emitRegs)reg);

        /* emit the call to the EE-helper that stops for GC (or other reasons) */

        genEmitHelperCall(CPX_CALL_GC,
                         0,             /* argSize */
                         0);            /* retSize */

#if 1
        /* restore return value (if necessary) */

        if  (retVal != REG_NA)
        {
            /*@TODO: what about float/double returns? */
            /*       right now we just leave the result on the FPU stack */
            /*       in the hope that the jit-helper will leave it there. */
            if (retVal == REG_INTRET || retVal == REG_LNGRET)
            {
                /* mov [frame.callSiteTracker], esp */

                genEmitter->emitIns_R_AR (INS_mov,
                                          EA_4BYTE,
                                          SR_EAX,
                                          SR_EBP,
                                          lvaTable[lvaScratchMemVar].lvStkOffs
                                          + info.compNDFrameOffset
                                          + info.compEEInfo.sizeOfFrame);
            }

            if (retVal == REG_LNGRET)
            {
                /* mov [frame.callSiteTracker], esp */

                genEmitter->emitIns_R_AR (INS_mov,
                                          EA_4BYTE,
                                          SR_EDX,
                                          SR_EBP,
                                          lvaTable[lvaScratchMemVar].lvStkOffs
                                          + info.compNDFrameOffset
                                          + info.compEEInfo.sizeOfFrame
                                          + sizeof(int));
            }

        }
#endif
#endif

        /* genCondJump() closes the current emitter block */

        genDefineTempLabel(clab_nostop, true);

    }
#endif

#ifdef PROFILER_SUPPORT
#if     TGT_x86

    if (opts.compCallEventCB)
    {
        /* fire the event at the call site */
        /* alas, right now I can only handle calls via a method handle */
        if (call->gtCall.gtCallType == CT_USER_FUNC)
        {
            unsigned        saveStackLvl2 = genStackLevel;
            BOOL            bHookFunction;
            PROFILING_HANDLE handle, *pHandle;

            handle = eeGetProfilingHandle(call->gtCall.gtCallMethHnd, &bHookFunction, &pHandle);

            if (bHookFunction)
            {
                handle = eeGetProfilingHandle(info.compMethodHnd, &bHookFunction, &pHandle);
                assert((!handle) != (!pHandle));

                if (pHandle)
                    genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC, SR_NA,
                                             SR_NA, (int)pHandle);
                else
                    inst_IV(INS_push, (unsigned) handle);

                genSinglePush(false);

                genEmitHelperCall(CPX_PROFILER_RETURNED,
                                 sizeof(int),   // argSize
                                 0);            // retSize

                /* Restore the stack level */
                genStackLevel = saveStackLvl2;
                genOnStackLevelChanged();

            }
        }
    }

#endif
#endif

    return retVal;
}

/*****************************************************************************/
#if ROUND_FLOAT
/*****************************************************************************
 *
 *  Force floating point expression results to memory, to get rid of the extra
 *  80 byte "temp-real" precision. Assumes the tree operand has been computed
 *  to the top of the stack.
 */

void                Compiler::genRoundFpExpression(GenTreePtr op)
{
    TempDsc *       temp;
    var_types       typ;

    // do nothing with memory resident opcodes - these are the right precision
    // (even if genMakeAddrOrFPstk loads them to the FP stack)

    switch (op->gtOper)
    {
    case GT_LCL_VAR:
    case GT_CLS_VAR:
    case GT_CNS_FLT:
    case GT_CNS_DBL:
    case GT_IND:
        return;
    }

    typ = op->TypeGet();

    /* Allocate a temp for the expression */

    temp = tmpGetTemp(typ);

    /* Store the FP value into the temp */

    inst_FS_ST(INS_fstp, EA_SIZE(genTypeSize(typ)), temp, 0);

    /* Load the value back onto the FP stack */

    inst_FS_ST(INS_fld , EA_SIZE(genTypeSize(typ)), temp, 0);

    /* We no longer need the temp */

    tmpRlsTemp(temp);
}

/*****************************************************************************/
#endif
/*****************************************************************************/
#ifdef  DEBUG

static
void                hexDump(FILE *dmpf, const char *name, BYTE *addr, size_t size)
{
    if  (!size)
        return;

    assert(addr);

    fprintf(dmpf, "Hex dump of %s:\n\n", name);

    for (unsigned i = 0; i < size; i++)
    {
        if  (!(i % 16))
            fprintf(dmpf, "\n    %04X: ", i);

        fprintf(dmpf, "%02X ", *addr++);
    }

    fprintf(dmpf, "\n\n");
}

#endif
/*****************************************************************************
 *
 *  Generate code for the function.
 */

void                Compiler::genGenerateCode(void * * codePtr,
                                              void * * consPtr,
                                              void * * dataPtr,
                                              void * * infoPtr,
                                              SIZE_T *nativeSizeOfCode)
{
    size_t          codeSize;
    unsigned        prologSize;
    unsigned        prologToss;
    unsigned        epilogSize;
    BYTE            temp[64];
    InfoHdr         header;
    size_t          ptrMapSize;

#ifdef  DEBUG
    size_t          headerSize;
    genIntrptibleUse = true;

    fgDebugCheckBBlist();
#endif

//  if  (testMask & 2) assert(genInterruptible == false);

    /* This is the real thing */

    genPrepForCompiler();

    /* Prepare the emitter/scheduler */

    /* Estimate the offsets of locals/arguments and size of frame */

    size_t      lclSize = lvaFrameSize();

    /* Guess-timate the amount of temp space we might need */
    // CONSIDER: better heuristic????

    size_t      tmpSize = roundUp(info.compCodeSize / 32);

    compFrameSizeEst = lclSize + tmpSize;

    genEmitter->emitBegFN(genFPused, lclSize, tmpSize);

    /* Now generate code for the function */

    genCodeForBBlist();

    /* We can now generate the function prolog and epilog */

    prologSize = genFnProlog();
#if!TGT_RISC
                 genFnEpilog();
#endif

#if VERBOSE_SIZES || DISPLAY_SIZES

    size_t          dataSize =  genEmitter->emitDataSize(false) +
                                genEmitter->emitDataSize( true);

#endif

    /* We're done generating code for this function */

    codeSize = genEmitter->emitEndCodeGen( this,
                                           !opts.compDbgEnC, // are tracked stk-ptrs contiguous ?
                                           genInterruptible,
                                           genFullPtrRegMap,
                                           (info.compRetType == TYP_REF),
                                           &prologToss,
                                           &epilogSize,
                                           codePtr,
                                           consPtr,
                                           dataPtr);

    *nativeSizeOfCode = (SIZE_T)codeSize;
//  printf("%6u bytes of code generated for %s.%s\n", codeSize, info.compFullName);

#ifdef DEBUGGING_SUPPORT

    /* Finalize the line # tracking logic after we know the exact block sizes/offsets */

    if (opts.compDbgInfo)
        genIPmappingGen();

    /* Finalize the Local Var info in terms of generated code */

    if (opts.compScopeInfo)
        genSetScopeInfo();

#endif

#ifdef LATE_DISASM
    if (opts.compLateDisAsm)
        genDisAsm.disAsmCode((BYTE*)*codePtr, codeSize);
#endif

    /* Are there any exception handlers? */

    if  (info.compXcptnsCount)
    {
        unsigned        XTnum;
        EHblkDsc *      HBtab;

#ifdef NOT_JITC
        eeSetEHcount(info.compCompHnd, info.compXcptnsCount);
#endif

        for (XTnum = 0, HBtab = compHndBBtab;
             XTnum < info.compXcptnsCount;
             XTnum++  , HBtab++)
        {
            DWORD       flags = HBtab->ebdFlags;

            NATIVE_IP   tryBeg, tryEnd, hndBeg, hndEnd, hndTyp;

            assert(HBtab->ebdTryBeg);
            assert(HBtab->ebdHndBeg);
            tryBeg = genEmitter->emitCodeOffset(HBtab->ebdTryBeg->bbEmitCookie, 0);
            hndBeg = genEmitter->emitCodeOffset(HBtab->ebdHndBeg->bbEmitCookie, 0);

            // If HBtab->ebdTryEnd or HBtab->ebdHndEnd are NULL,
            // it means use the end of the method
            tryEnd = (HBtab->ebdTryEnd == 0) ? codeSize
                    : genEmitter->emitCodeOffset(HBtab->ebdTryEnd->bbEmitCookie, 0);
            hndEnd = (HBtab->ebdHndEnd == 0) ? codeSize
                    : genEmitter->emitCodeOffset(HBtab->ebdHndEnd->bbEmitCookie, 0);

            if (HBtab->ebdFlags & JIT_EH_CLAUSE_FILTER)
            {
                assert(HBtab->ebdFilter);
                hndTyp = genEmitter->emitCodeOffset(HBtab->ebdFilter->bbEmitCookie, 0);
            }
            else
            {
                hndTyp = HBtab->ebdTyp;
            }

#ifdef NOT_JITC
            JIT_EH_CLAUSE clause;
            clause.ClassToken    = hndTyp;
            clause.Flags         = (CORINFO_EH_CLAUSE_FLAGS)flags;
            clause.TryOffset     = tryBeg;
            clause.TryLength     = tryEnd;
            clause.HandlerOffset = hndBeg;
            clause.HandlerLength = hndEnd;
            eeSetEHinfo(info.compCompHnd, XTnum, &clause);
#else
#ifdef  DEBUG
            if  (verbose) printf("try [%04X..%04X] handled by [%04X..%04X] (class: %004X)\n",
                                 tryBeg, tryEnd, hndBeg, hndEnd, hndTyp);
#endif
#endif // NOT_JITC

        }
    }

#if TRACK_GC_REFS
    int s_cached;
#ifdef  DEBUG
    headerSize      =
#endif
    compInfoBlkSize = gcInfoBlockHdrSave(temp,
                                         0,
                                         codeSize,
                                         prologSize,
                                         epilogSize,
                                         &header,
                                         &s_cached);

    ptrMapSize      = gcPtrTableSize(header, codeSize);

#if DISPLAY_SIZES

    if (genInterruptible)
    {
        gcHeaderISize += compInfoBlkSize;
        gcPtrMapISize += ptrMapSize;
    }
    else
    {
        gcHeaderNSize += compInfoBlkSize;
        gcPtrMapNSize += ptrMapSize;
    }

#endif

    compInfoBlkSize += ptrMapSize;

    /* Allocate the info block for the method */

#ifdef  NOT_JITC
    compInfoBlkAddr = (BYTE *)eeAllocGCInfo(info.compCompHnd, compInfoBlkSize);
#else
    compInfoBlkAddr = (BYTE *)compGetMem(roundUp(compInfoBlkSize));
#endif

    if  (!compInfoBlkAddr)
    {
        /* No need to deallocate the other VM blocks, VM will clean up on failure */

        NOMEM();
    }

#if VERBOSE_SIZES

//  if  (compInfoBlkSize > codeSize && compInfoBlkSize > 100)
    {
        printf("[%7u VM, %7u+%7u/%7u x86 %03u/%03u%%] %s.%s\n", info.compCodeSize,
                                                             compInfoBlkSize,
                                                             codeSize + dataSize,
                                                             codeSize + dataSize - prologSize - epilogSize,
                                                             100*(codeSize+dataSize)/info.compCodeSize,
                                                             100*(codeSize+dataSize+compInfoBlkSize)/info.compCodeSize,
                                                             info.compClassName, info.compMethodName);
    }

#endif

    /* Fill in the info block and return it to the caller */

    *infoPtr = compInfoBlkAddr;

    /* Create the method info block: header followed by GC tracking tables */

    compInfoBlkAddr += gcInfoBlockHdrSave(compInfoBlkAddr, -1,
                                          codeSize,
                                          prologSize,
                                          epilogSize,
                                          &header,
                                          &s_cached);

    assert(compInfoBlkAddr == (BYTE*)*infoPtr + headerSize);
    compInfoBlkAddr  =     gcPtrTableSave(compInfoBlkAddr,      header, codeSize);
    assert(compInfoBlkAddr == (BYTE*)*infoPtr + headerSize + ptrMapSize);

#ifdef  DEBUG

    if  (0)
    {
        BYTE    *   temp = (BYTE *)*infoPtr;
        unsigned    size = compInfoBlkAddr - temp;
        BYTE    *   ptab = temp + headerSize;
        unsigned    offs = 0;

        assert(size == headerSize + ptrMapSize);

        printf("Method info block - header [%u bytes]:", headerSize);

        for (unsigned i = 0; i < size; i++)
        {
            if  (temp == ptab)
            {
                printf("\nMethod info block - ptrtab [%u bytes]:", ptrMapSize);
                printf("\n    %04X: %*c", i & ~0xF, 3*(i&0xF), ' ');
            }
            else
            {
                if  (!(i % 16))
                    printf("\n    %04X: ", i);
            }

            printf("%02X ", *temp++);
        }

        printf("\n");
    }

#endif

#if TGT_x86
#if DUMP_GC_TABLES

    if  ((dspInfoHdr || dspGCtbls) && savCode)
    {
        const BYTE *base = (BYTE *)*infoPtr;
        unsigned    size;
        unsigned    methodSize;
        InfoHdr     header;

        size = gcInfoBlockHdrDump(base, &header, &methodSize);
//      printf("size of header encoding is %3u\n", size);
        printf("\n");

        if  (dspGCtbls)
        {
            base   += size;
            size    = gcDumpPtrTable(base, header, methodSize);
//          printf("size of pointer table is %3u\n", size);
            printf("\n");
            assert(compInfoBlkAddr == (base+size));
        }

    }

    if  (testMask & 128)
    {
        for (unsigned offs = 0; offs < codeSize; offs++)
        {
            gcFindPtrsInFrame(*infoPtr, *codePtr, offs);
        }
    }

#endif
#endif

    /* Make sure we ended up generating the expected number of bytes */

    assert(compInfoBlkAddr == (BYTE *)*infoPtr + compInfoBlkSize);

#ifdef  DEBUG

    FILE    *   dmpf = stdout;

#ifdef NOT_JITC
    dmpHex = false;
    if  (!strcmp(info.compMethodName, "<name of method you want the hex dump for"))
    {
        FILE    *   codf = fopen("C:\\JIT.COD", "at");  // NOTE: file append mode

        if  (codf)
        {
            dmpf   = codf;
            dmpHex = true;
        }
    }
#else
    if  (savCode)
#endif
    if  (dmpHex)
    {
        size_t          dataSize = genEmitter->emitDataSize(false);

        size_t          consSize = genEmitter->emitDataSize(true);

        size_t          infoSize = compInfoBlkSize;


#ifdef  NOT_JITC
        fprintf(dmpf, "Generated code for %s.%s:\n", info.compFullName);
#else
        fprintf(dmpf, "Generated code for    %s:\n",                     info.compMethodName);
#endif
        fprintf(dmpf, "\n");

        if (codeSize) fprintf(dmpf, "    Code  at %08X [%04X bytes]\n", *codePtr, codeSize);
        if (consSize) fprintf(dmpf, "    Const at %08X [%04X bytes]\n", *consPtr, consSize);
        if (dataSize) fprintf(dmpf, "    Data  at %08X [%04X bytes]\n", *dataPtr, dataSize);
        if (infoSize) fprintf(dmpf, "    Info  at %08X [%04X bytes]\n", *infoPtr, infoSize);

        fprintf(dmpf, "\n");

        if (codeSize) hexDump(dmpf, "Code" , (BYTE*)*codePtr, codeSize);
        if (consSize) hexDump(dmpf, "Const", (BYTE*)*consPtr, consSize);
        if (dataSize) hexDump(dmpf, "Data" , (BYTE*)*dataPtr, dataSize);
        if (infoSize) hexDump(dmpf, "Info" , (BYTE*)*infoPtr, infoSize);

        fflush (dmpf);
    }

#endif

#endif // TRACK_GC_REFS

    /* Tell the emitter/scheduler that we're done with this function */

    genEmitter->emitEndFN();

    /* Shut down the spill logic */

    rsSpillDone();

    /* Shut down the temp logic */

    tmpDone();

#if DISPLAY_SIZES

    grossVMsize += info.compCodeSize;
    totalNCsize += codeSize + dataSize + compInfoBlkSize;
    grossNCsize += codeSize + dataSize;

#endif

}

/*****************************************************************************
 *
 *  Generates code for moving incoming register arguments to their
 *  assigned location, in the function prolog.
 */

#if USE_FASTCALL

void            Compiler::genFnPrologCalleeRegArgs()
{
    assert(rsCalleeRegArgMaskLiveIn);
    assert(rsCalleeRegArgNum <= MAX_REG_ARG);

    unsigned    argNum         = 0;
    unsigned    regArgNum;
    unsigned    nonDepCount    = 0;
    unsigned    regArgMaskLive = rsCalleeRegArgMaskLiveIn;

    /* Construct a table with the register arguments
     * To make it easier to detect circular dependencies
     * the table is constructed in the order the arguments
     * are passed in registers (i.e. first reg arg in tab[0], etc.) */

    struct
    {
        unsigned    varNum;
        unsigned    trashBy;
        bool        stackArg;
        bool        processed;
        bool        circular;
    } regArgTab [MAX_REG_ARG];

    unsigned    varNum;
    LclVarDsc * varDsc;

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        /* Is this variable a register arg? */

        if  (!varDsc->lvIsParam)
            continue;

        if  (!varDsc->lvIsRegArg)
            continue;

        /* Bingo - add it to our table */

        assert(argNum < rsCalleeRegArgNum);
        argNum++;

        regArgNum = genRegArgIdx(varDsc->lvArgReg);
        assert(regArgNum < rsCalleeRegArgNum);

        regArgTab[regArgNum].varNum    = varNum;

        // Is the arg dead on entry to the method ?

        if ((regArgMaskLive & genRegMask(varDsc->lvArgReg)) == 0)
        {
            assert(varDsc->lvTracked &&
                   (genVarIndexToBit(varDsc->lvVarIndex) & fgFirstBB->bbLiveIn) == 0);

            // Mark it as processed and be done with it
            regArgTab[regArgNum].processed = true;
            goto NON_DEP;
        }

        assert(regArgMaskLive & genRegMask(varDsc->lvArgReg));

        regArgTab[regArgNum].processed = false;

        /* If it goes on the stack or in a register that doesn't hold
         * an argument anymore -> CANNOT form a circular dependency */

        if ( varDsc->lvRegister                              &&
            (genRegMask(varDsc->lvRegNum) & regArgMaskLive)   )
        {
            /* will trash another argument -> posible dependency
             * We may need several passes after the table is constructed
             * to decide on that */

            regArgTab[regArgNum].stackArg  = false;

            /* Maybe the argument stays in the register (IDEAL) */

            if (varDsc->lvRegNum == varDsc->lvArgReg)
                goto NON_DEP;
            else
                regArgTab[regArgNum].circular  = true;
        }
        else
        {
            /* either stack argument or goes to a free register */
            assert((!varDsc->lvRegister)                                                   ||
                    (varDsc->lvRegister && !(genRegMask(varDsc->lvRegNum) & regArgMaskLive)) );

            /* mark stack arguments since we will take care of those first */
            regArgTab[regArgNum].stackArg  = (varDsc->lvRegister) ? false : true;

        NON_DEP:

            regArgTab[regArgNum].circular  = false;
            nonDepCount++;

            /* mark the argument register as free */
            regArgMaskLive &= ~genRegMask(varDsc->lvArgReg);
        }
    }

    assert(argNum == rsCalleeRegArgNum);

    /* Find the circular dependencies for the argument registers if any
     * A circular dependency is a set of registers R1, R2, ..., Rn
     * such that R1->R2, R2->R3, ..., Rn->R1 */

    bool    change = true;

    if (nonDepCount < rsCalleeRegArgNum)
    {
        /* possible circular dependencies - the previous pass was not enough
         * to filter them out -> use a "sieve" strategy to find all circular
         * dependencies */

        assert(regArgMaskLive);

        while (change)
        {
            change = false;

            for (argNum = 0; argNum < rsCalleeRegArgNum; argNum++)
            {
                /* If we already marked the argument as non-circular continue */

                if (!regArgTab[argNum].circular)
                     continue;

                varNum = regArgTab[argNum].varNum; assert(varNum < lvaCount);
                varDsc = lvaTable + varNum;
                assert(varDsc->lvIsParam && varDsc->lvIsRegArg);

                /* cannot possibly have stack arguments */
                assert(varDsc->lvRegister);
                assert(!regArgTab[argNum].stackArg);

                assert(argNum == genRegArgIdx(varDsc->lvArgReg));

                if (genRegMask(varDsc->lvRegNum) & regArgMaskLive)
                {
                    /* we are trashing a live argument register - record it */
                    regArgNum = genRegArgIdx(varDsc->lvRegNum);
                    assert(regArgNum < rsCalleeRegArgNum);
                    regArgTab[regArgNum].trashBy  = argNum;
                }
                else
                {
                    /* argument goes to a free register */
                    regArgTab[argNum].circular  = false;
                    nonDepCount++;
                    change = true;

                    /* mark the argument register as free */
                    regArgMaskLive &= ~genRegMask(varDsc->lvArgReg);
                }
            }
        }
    }

    /* At this point, everything that has the "circular" flag
     * set to "true" forms a circular dependency */

#ifdef DEBUG
    if (nonDepCount < rsCalleeRegArgNum)
    {
        assert(rsCalleeRegArgNum - nonDepCount >= 2);
        assert(regArgMaskLive);

        // assert(!"Circular dependencies!");

        if (verbose)
        {
            printf("Circular dependencies found:\n");

        }
    }
#endif

    /* Now move the arguments to their locations
     * First consider ones that go on the stack since they may
     * free some registers */

    regArgMaskLive = rsCalleeRegArgMaskLiveIn;

    for (argNum = 0; argNum < rsCalleeRegArgNum; argNum++)
    {
        int             stkOfs;
        emitAttr        size;

        /* If the arg is dead on entry to the method, skip it */

        if (regArgTab[argNum].processed)
            continue;

        /* If not a stack arg go to the next one */

        if (!regArgTab[argNum].stackArg)
            continue;

        assert(regArgTab[argNum].circular  == false);

        varNum = regArgTab[argNum].varNum; assert(varNum < lvaCount);
        varDsc = lvaTable + varNum;

        assert(varDsc->lvIsParam);
        assert(varDsc->lvIsRegArg);
        assert(varDsc->lvRegister == false);
        assert(genTypeSize(genActualType(varDsc->TypeGet())) == sizeof(void *));

        size = emitActualTypeSize(genActualType(varDsc->TypeGet()));

        /* Stack argument - if the ref count is 0 don't care about it */

        if (!varDsc->lvOnFrame)
        {
            assert(varDsc->lvRefCnt == 0);
        }
        else
        {
            stkOfs = varDsc->lvStkOffs;
#if TGT_x86
            genEmitter->emitIns_S_R(INS_mov,
                                    size,
                                    (emitRegs)(regNumber)varDsc->lvArgReg,
                                    varNum,
                                    0);
#else
            assert(!"need RISC code");
#endif

#ifdef DEBUGGING_SUPPORT
            if (opts.compScopeInfo && info.compLocalVarsCount>0)
                psiMoveToStack(varNum);
#endif
        }

        /* mark the argument as processed */

        regArgTab[argNum].processed = true;
        regArgMaskLive &= ~genRegMask(varDsc->lvArgReg);
    }

    /* Process any circular dependencies */

    if (nonDepCount < rsCalleeRegArgNum)
    {
        unsigned        begReg, destReg, srcReg;
        unsigned        varNumDest, varNumSrc;
        LclVarDsc   *   varDscDest;
        LclVarDsc   *   varDscSrc;
        regNumber       xtraReg;

        assert(rsCalleeRegArgNum - nonDepCount >= 2);

        for (argNum = 0; argNum < rsCalleeRegArgNum; argNum++)
        {
            /* If not a circular dependency continue */

            if (!regArgTab[argNum].circular)
                continue;

            /* If already processed the dependency continue */

            if (regArgTab[argNum].processed)
                continue;

#if TGT_x86

            destReg = begReg = argNum;
            srcReg  = regArgTab[argNum].trashBy; assert(srcReg < rsCalleeRegArgNum);

            varNumDest = regArgTab[destReg].varNum; assert(varNumDest < lvaCount);
            varDscDest = lvaTable + varNumDest;
            assert(varDscDest->lvIsParam && varDscDest->lvIsRegArg);

            varNumSrc = regArgTab[srcReg].varNum; assert(varNumSrc < lvaCount);
            varDscSrc = lvaTable + varNumSrc;
            assert(varDscSrc->lvIsParam && varDscSrc->lvIsRegArg);

            emitAttr size = EA_4BYTE;

            if (destReg == regArgTab[srcReg].trashBy)
            {
                /* only 2 registers form the circular dependency - use "xchg" */

                varNum = regArgTab[argNum].varNum; assert(varNum < lvaCount);
                varDsc = lvaTable + varNum;
                assert(varDsc->lvIsParam && varDsc->lvIsRegArg);

                assert(genTypeSize((var_types)varDscSrc->lvType) == 4);

                /* Set "size" to indicate GC if one and only one of
                 * the operands is a pointer
                 * RATIONALE: If both are pointers, nothing changes in
                 * the GC pointer tracking. If only one is a pointer we
                 * have to "swap" the registers in the GC reg pointer mask
                 */

                if  (varTypeGCtype(varDscSrc->TypeGet()) !=
                     varTypeGCtype(varDscDest->TypeGet()))
                {
                    size = EA_GCREF;
                }

                assert(varDscDest->lvArgReg == varDscSrc->lvRegNum);

                genEmitter->emitIns_R_R(INS_xchg,
                                        size,
                                        (emitRegs)(regNumber)varDscSrc->lvRegNum,
                                        (emitRegs)(regNumber)varDscSrc->lvArgReg);

                /* mark both arguments as processed */
                regArgTab[destReg].processed = true;
                regArgTab[srcReg].processed  = true;

                regArgMaskLive &= ~genRegMask(varDscSrc->lvArgReg);
                regArgMaskLive &= ~genRegMask(varDscDest->lvArgReg);

#ifdef  DEBUGGING_SUPPORT
                if (opts.compScopeInfo && info.compLocalVarsCount>0)
                {
                    psiMoveToReg(varNumSrc );
                    psiMoveToReg(varNumDest);
                }
#endif
            }
            else
            {
                /* more than 2 registers in the dependency - need an
                 * additional register. Pick a callee saved,
                 * if none pick a callee thrashed that is not in
                 * regArgMaskLive (i.e. register arguments that end up on
                 * stack), otherwise push / pop one of the circular
                 * registers */

                xtraReg = REG_STK;

                if  (rsMaskModf & RBM_ESI)
                    xtraReg = REG_ESI;
                else if (rsMaskModf & RBM_EDI)
                    xtraReg = REG_EDI;
                else if (rsMaskModf & RBM_EBX)
                    xtraReg = REG_EBX;
                else if (!(regArgMaskLive & RBM_EDX))
                    xtraReg = REG_EDX;
                else if (!(regArgMaskLive & RBM_ECX))
                    xtraReg = REG_ECX;
                else if (!(regArgMaskLive & RBM_EAX))
                    xtraReg = REG_EAX;

                if (xtraReg == REG_STK)
                {
                    /* This can never happen for x86 - in the RISC case
                     * REG_STK will be the temp register */
                    assert(!"Couldn't find an extra register to solve circular dependency!");
                    NO_WAY("Cannot solve circular dependency!");
                }

                /* move the dest reg (begReg) in the extra reg */

                if  (varDscDest->lvType == TYP_REF)
                    size = EA_GCREF;

                genEmitter->emitIns_R_R (INS_mov,
                                         size,
                                         (emitRegs)(regNumber)xtraReg,
                                         (emitRegs)(regNumber)varDscDest->lvArgReg);

#ifdef  DEBUGGING_SUPPORT
                if (opts.compScopeInfo && info.compLocalVarsCount>0)
                    psiMoveToReg(varNumDest, xtraReg);
#endif

                /* start moving everything to its right place */

                while (srcReg != begReg)
                {
                    /* mov dest, src */

                    assert(varDscDest->lvArgReg == varDscSrc->lvRegNum);

                    size = (varDscSrc->lvType == TYP_REF) ? EA_GCREF
                                                          : EA_4BYTE;

                    genEmitter->emitIns_R_R(INS_mov,
                                             size,
                                             (emitRegs)(regNumber)varDscDest->lvArgReg,
                                             (emitRegs)(regNumber)varDscSrc->lvArgReg);

                    /* mark 'src' as processed */
                    regArgTab[srcReg].processed  = true;
                    regArgMaskLive &= ~genRegMask(varDscSrc->lvArgReg);

                    /* move to the next pair */
                    destReg = srcReg;
                    srcReg = regArgTab[srcReg].trashBy; assert(srcReg < rsCalleeRegArgNum);

                    varDscDest = varDscSrc;

                    varNumSrc = regArgTab[srcReg].varNum; assert(varNumSrc < lvaCount);
                    varDscSrc = lvaTable + varNumSrc;
                    assert(varDscSrc->lvIsParam && varDscSrc->lvIsRegArg);
                }

                /* take care of the beginning register */

                assert(srcReg == begReg);
                assert(varDscDest->lvArgReg == varDscSrc->lvRegNum);

                /* move the dest reg (begReg) in the extra reg */

                size = (varDscSrc->lvType == TYP_REF) ? EA_GCREF
                                                      : EA_4BYTE;

                genEmitter->emitIns_R_R(INS_mov,
                                        size,
                                        (emitRegs)(regNumber)varDscSrc->lvRegNum,
                                        (emitRegs)(regNumber)xtraReg);

#ifdef  DEBUGGING_SUPPORT
                if (opts.compScopeInfo && info.compLocalVarsCount>0)
                    psiMoveToReg(varNumSrc);
#endif
                /* mark the beginning register as processed */

                regArgTab[srcReg].processed  = true;
                regArgMaskLive &= ~genRegMask(varDscSrc->lvArgReg);
            }
#else
            assert(!"need RISC code");
#endif
        }
    }

    /* Finally take care of the remaining arguments that must be enregistered */

    while (regArgMaskLive)
    {
        for (argNum = 0; argNum < rsCalleeRegArgNum; argNum++)
        {
            emitAttr        size;

            /* If already processed go to the next one */
            if (regArgTab[argNum].processed)
                continue;

            varNum = regArgTab[argNum].varNum; assert(varNum < lvaCount);
            varDsc = lvaTable + varNum;
            assert(varDsc->lvIsParam && varDsc->lvIsRegArg);
            assert(genTypeSize(varDsc->TypeGet()) == sizeof (void *));

            size = emitActualTypeSize(varDsc->TypeGet());

            assert(varDsc->lvRegister && !regArgTab[argNum].circular);

            /* Register argument - hopefully it stays in the same register */

            if (varDsc->lvRegNum != varDsc->lvArgReg)
            {
                /* Cannot trash a currently live register argument
                 * Skip this one until its source will be free
                 * which is guaranteed to happen since we have no circular dependencies */

                if (genRegMask(varDsc->lvRegNum) & regArgMaskLive)
                    continue;

                /* Move it to the new register */

                genEmitter->emitIns_R_R(INS_mov,
                                         size,
                                         (emitRegs)(regNumber)varDsc->lvRegNum,
                                         (emitRegs)(regNumber)varDsc->lvArgReg);
#ifdef  DEBUGGING_SUPPORT
                if (opts.compScopeInfo && info.compLocalVarsCount>0)
                    psiMoveToReg(varNum);
#endif
            }

            /* mark the argument as processed */

            regArgTab[argNum].processed = true;
            regArgMaskLive &= ~genRegMask(varDsc->lvArgReg);
        }
    }
}

#endif // USE_FASTCALL

/*****************************************************************************
 *
 *  Generates code for a function prolog.
 */

size_t              Compiler::genFnProlog()
{
    size_t          size;

    unsigned        varNum;
    LclVarDsc   *   varDsc;

    TempDsc *       tempThis;

    unsigned        initStkLclCnt;

#ifdef  DEBUG
    genIntrptibleUse = true;
#endif

#if TGT_x86

    /*-------------------------------------------------------------------------
     *
     *  We have to decide whether we're going to use "REP STOS" in
     *  the prolog before we assign final stack offsets. Whether
     *  we push EDI in the prolog affects ESP offsets of locals,
     *  and the saving/restoring of EDI may depend on whether we
     *  use "REP STOS".
     *
     *  We'll count the number of locals we have to initialize,
     *  and if there are lots of them we'll use "REP STOS".
     *
     *  At the same time we set lvMustInit for locals (enregistred or on stack)
     *  that must be initialized (e.g. initiliaze memory (comInitMem),
     *  untracked pointers or disable DFA
     */

    bool            useRepStosd = false;

#endif

    initStkLclCnt = 0;

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        if  (varDsc->lvIsParam)
            continue;

        if (!varDsc->lvRegister && !varDsc->lvOnFrame)
        {
            assert(varDsc->lvRefCnt == 0);
            continue;
        }

        if (info.compInitMem || varTypeIsGC(varDsc->TypeGet()))
        {
            if (varDsc->lvTracked)
            {
                /* For uninitialized use of tracked variables, the liveness
                 * will bubble to the top (fgFirstBB) in fgGlobalDataFlow()
                 */

                VARSET_TP varBit = genVarIndexToBit(varDsc->lvVarIndex);

                if (varBit & fgFirstBB->bbLiveIn)
                {
                    /* This var must be initialized */

                    varDsc->lvMustInit = true;

                    /* See if the variable is on the stack will be initialized
                     * using rep stos - compute the total size to be zero-ed */

                    if (varDsc->lvOnFrame)
                    {
                        if (!varDsc->lvRegister)
                        {
                            // Var is completely on the stack
                            initStkLclCnt += genTypeStSz(varDsc->TypeGet());
                        }
                        else
                        {
                            // Var is paritally enregistered
                            assert(genTypeSize(varDsc->TypeGet()) > sizeof(int) &&
                                   varDsc->lvOtherReg == REG_STK);
                            initStkLclCnt += genTypeStSz(TYP_INT);
                        }
                    }
                }
            }
            else if (varDsc->lvOnFrame)
            {
                /* With compInitMem, all untracked vars will have to be init'ed */

                varDsc->lvMustInit = true;

                initStkLclCnt += roundUp(lvaLclSize(varNum)) / sizeof(int);
            }

            continue;
        }

        /* Ignore if not a pointer variable or value class */

        bool    mayHaveGC  = varTypeIsGC(varDsc->TypeGet())     ||
                             (varDsc->TypeGet() == TYP_STRUCT)   ;

        if    (!mayHaveGC)
                continue;

#if CAN_DISABLE_DFA

        /* If we don't know lifetimes of variables, must be conservative */

        if  (opts.compMinOptim)
        {
            varDsc->lvMustInit = true;
        }
        else
#endif
        {
            if (!varDsc->lvTracked)
                varDsc->lvMustInit = true;
        }

        /* Is this a 'must-init' stack pointer local? */

        if  (varDsc->lvMustInit && varDsc->lvOnFrame)
            initStkLclCnt++;
    }

    /* Don't forget about spill temps that hold pointers */

    if  (!TRACK_GC_TEMP_LIFETIMES)
    {
        for (tempThis = tmpListBeg();
             tempThis;
             tempThis = tmpListNxt(tempThis))
        {
            if  (varTypeIsGC(tempThis->tdTempType()))
                initStkLclCnt++;
        }
    }

#if TGT_x86

    /* If we have more than 4 untracked locals, use "rep stosd" */

    if  (initStkLclCnt > 4)
        useRepStosd = true;

    /* If we're going to use "REP STOS", remember that we will trash EDI */

    if  (useRepStosd)
    {
#if USE_FASTCALL
        /* For fastcall we will have to save ECX, EAX
         * so reserve two extra callee saved
         * This is better than pushing eax, ecx, because we in the later
         * we will mess up already computed offsets on the stack (for ESP frames)
         * CONSIDER: once the final calling convention is established
         * clean up this (i.e. will already have a callee trashed register handy
         */

        rsMaskModf |= RBM_EDI;

        if  (rsCalleeRegArgMaskLiveIn & RBM_ECX)
            rsMaskModf |= RBM_ESI;

        if  (rsCalleeRegArgMaskLiveIn & RBM_EAX)
            rsMaskModf |= RBM_EBX;
#else
        rsMaskModf |= (RBM_ECX|RBM_EDI);
#endif
    }

    if (compTailCallUsed)
        rsMaskModf = RBM_CALLEE_SAVED;

    /* Count how many callee-saved registers will actually be saved (pushed) */

    compCalleeRegsPushed = 0;

    if  (              rsMaskModf & RBM_EDI)    compCalleeRegsPushed++;
    if  (              rsMaskModf & RBM_ESI)    compCalleeRegsPushed++;
    if  (              rsMaskModf & RBM_EBX)    compCalleeRegsPushed++;
    if  (!genFPused && rsMaskModf & RBM_EBP)    compCalleeRegsPushed++;

    /* Assign offsets to things living on the stack frame */

    lvaAssignFrameOffsets(true);

#endif

    /* Ready to start on the prolog proper */

    genEmitter->emitBegProlog();

#ifdef DEBUGGING_SUPPORT
    if (opts.compDbgInfo)
    {
        // Do this so we can put the prolog instruction group ahead of
        // other instruction groups
        genIPmappingAddToFront( ICorDebugInfo::MappingTypes::PROLOG );
    }
#endif //DEBUGGING_SUPPORT

#ifdef  DEBUG
    if  (dspCode) printf("\n__prolog:\n");
#endif

#ifdef DEBUGGING_SUPPORT
    if (opts.compScopeInfo && info.compLocalVarsCount>0)
    {
        // Create new scopes for the method-parameters for the prolog-block.
        psiBegProlog();
    }
#endif

#if defined(NOT_JITC) && defined(DEBUG)

    /* Use the following to step into the generated native code */
    if (opts.eeFlags & CORJIT_FLG_HALT)
        instGen(INS_int3);

#endif // NOT_JITC

    /*-------------------------------------------------------------------------
     *
     *  Record the stack frame ranges that will cover all of the tracked
     *  and untracked pointer variables.
     *  Also find which registers will need to be zero-initialized
     */

    int             untrLclLo   =  +INT_MAX;
    int             untrLclHi   =  -INT_MAX;

    int             GCrefLo     =  +INT_MAX;
    int             GCrefHi     =  -INT_MAX;

    unsigned        initRegs    =  0;       // Registers which must be init'ed

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        if  (varDsc->lvIsParam)
#if USE_FASTCALL
            if  (!varDsc->lvIsRegArg)
#endif
                continue;

        if  (!varDsc->lvRegister && !varDsc->lvOnFrame)
        {
            assert(varDsc->lvRefCnt == 0);
            continue;
        }

        signed int loOffs =   varDsc->lvStkOffs;
        signed int hiOffs =   varDsc->lvStkOffs
                            + lvaLclSize(varNum)
                            - sizeof(int);

        /* We need to know the offset range of tracked stack GC refs */
        /* We assume that a GC reference can be anywhere in a TYP_STRUCT */

        bool        mayHaveGC  = varTypeIsGC(varDsc->TypeGet())   ||
                                 (varDsc->TypeGet() == TYP_STRUCT) ;

        if (mayHaveGC && varDsc->lvTracked && varDsc->lvOnFrame)
        {
            if (loOffs < GCrefLo)  GCrefLo = loOffs;
            if (hiOffs > GCrefHi)  GCrefHi = hiOffs;
        }

        /* For lvMustInit vars, gather pertinent info */

        if  (varDsc->lvMustInit == 0)
            continue;

        if (varDsc->lvRegister)
        {
            initRegs            |= genRegMask(varDsc->lvRegNum);

            if (varDsc->lvType == TYP_LONG)
            {
                if (varDsc->lvOtherReg != REG_STK)
                {
                    initRegs    |= genRegMask(varDsc->lvOtherReg);
                }
                else
                {
                    /* Upper DWORD is on the stack, and needs to be inited */

                    loOffs += sizeof(int);
                    goto INIT_STK;
                }
            }
        }
        else
        {
        INIT_STK:

            if  (loOffs < untrLclLo) untrLclLo = loOffs;
            if  (hiOffs > untrLclHi) untrLclHi = hiOffs;
        }
    }

    /* Don't forget about spill temps that hold pointers */

    if  (!TRACK_GC_TEMP_LIFETIMES)
    {
        for (tempThis = tmpListBeg();
             tempThis;
             tempThis = tmpListNxt(tempThis))
        {
            int             stkOffs;

            if  (!varTypeIsGC(tempThis->tdTempType()))
                continue;

            stkOffs = tempThis->tdTempOffs();

            assert((unsigned short)stkOffs != 0xDDDD);
            assert(!genFPused || stkOffs);

//          printf("    Untracked tmp at [EBP-%04X]\n", -stkOffs);

            if  (stkOffs < untrLclLo) untrLclLo = stkOffs;
            if  (stkOffs > untrLclHi) untrLclHi = stkOffs;
        }
    }

#ifdef DEBUG
    if  (verbose)
    {
        if  (initStkLclCnt)
        {
            printf("Found %u lvMustInit stk vars, frame offsets %d through %d\n",
                    initStkLclCnt,                      -untrLclLo, -untrLclHi - sizeof(void *));
        }
    }
#endif

    /*-------------------------------------------------------------------------
     *
     * Now start emitting the part of the prolog which sets up the frame
     */

#if     TGT_x86

    if  (DOUBLE_ALIGN_NEED_EBPFRAME)
    {
        inst_RV   (INS_push, REG_EBP, TYP_REF);

#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0) psiAdjustStackLevel(sizeof(int));
#endif

        inst_RV_RV(INS_mov , REG_EBP, REG_ESP);

#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0) psiMoveESPtoEBP();
#endif

    }

#if DOUBLE_ALIGN

    if  (genDoubleAlign)
    {
        assert(genFPused == false);
        assert(compLclFrameSize > 0);             /* Better have some locals */
        assert((rsMaskModf & RBM_EBP) == 0);      /* Trashing EBP is out.    */

        inst_RV_IV(INS_and, REG_ESP, -8);
    }

#endif

    if  (compLclFrameSize > 0)
    {
#if DOUBLE_ALIGN

        /* Need to keep ESP aligned if double aligning */

        if (genDoubleAlign && (compLclFrameSize & 4) != 0)
            compLclFrameSize += 4;
#endif

        if (compLclFrameSize == 4)
        {
            // Frame size is 4
            inst_RV(INS_push, REG_EAX, TYP_INT);
        }
        else if (compLclFrameSize < JIT_PAGE_SIZE)
        {
            // Frame size is (0x0008..0x1000)
            inst_RV_IV(INS_sub, REG_ESP, compLclFrameSize);
        }
        else if (compLclFrameSize < 3 * JIT_PAGE_SIZE)
        {
            // Frame size is (0x1000..0x3000)
            genEmitter->emitIns_AR_R(INS_test, EA_4BYTE,
                                      SR_EAX, SR_ESP, -JIT_PAGE_SIZE);
            if (compLclFrameSize >= 0x2000)
                genEmitter->emitIns_AR_R(INS_test, EA_4BYTE,
                                          SR_EAX, SR_ESP, -2 * JIT_PAGE_SIZE);
            inst_RV_IV(INS_sub, REG_ESP, compLclFrameSize);
        }
        else
        {
            // Frame size >= 0x3000
            inst_RV_RV(INS_mov,  REG_EAX, REG_ECX);         // save ECX
            inst_RV_IV(INS_mov,  REG_ECX, (compLclFrameSize / JIT_PAGE_SIZE));
            unsigned remaining = compLclFrameSize % JIT_PAGE_SIZE;

            // Start of Loop
            inst_RV_IV(INS_sub,  REG_ESP, JIT_PAGE_SIZE);
            genEmitter->emitIns_AR_R(INS_test, EA_4BYTE, SR_EAX, SR_ESP, 0);
            inst_IV   (INS_loop, -11);   // Branch backwards to Start of Loop

            inst_RV_RV(INS_mov,  REG_ECX, REG_EAX);         // restore ECX

            // assert that JIT_PAGE_SIZE is a power of 2.  (although we really dont have to)
            assert((JIT_PAGE_SIZE & (JIT_PAGE_SIZE - 1)) == 0);
            if  (remaining != 0)
                inst_RV_IV(INS_sub,  REG_ESP, remaining);

        }

#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0 && !DOUBLE_ALIGN_NEED_EBPFRAME)
            psiAdjustStackLevel(compLclFrameSize);
#endif

    }

    assert(RBM_CALLEE_SAVED == (RBM_EBX|RBM_ESI|RBM_EDI|RBM_EBP));

    if  (rsMaskModf & RBM_EDI)
    {
        inst_RV(INS_push, REG_EDI, TYP_REF);
#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0 && !DOUBLE_ALIGN_NEED_EBPFRAME)
            psiAdjustStackLevel(sizeof(int));
#endif
    }

    if  (rsMaskModf & RBM_ESI)
    {
        inst_RV(INS_push, REG_ESI, TYP_REF);
#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0 && !DOUBLE_ALIGN_NEED_EBPFRAME)
            psiAdjustStackLevel(sizeof(int));
#endif
    }

    if  (rsMaskModf & RBM_EBX)
    {
        inst_RV(INS_push, REG_EBX, TYP_REF);
#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0 && !DOUBLE_ALIGN_NEED_EBPFRAME)
            psiAdjustStackLevel(sizeof(int));
#endif
    }

    if  (!genFPused)
    if  (rsMaskModf & RBM_EBP)
    {
        inst_RV(INS_push, REG_EBP, TYP_REF);
#ifdef DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0 && !DOUBLE_ALIGN_NEED_EBPFRAME)
            psiAdjustStackLevel(sizeof(int));
#endif
    }

#ifdef PROFILER_SUPPORT

    if (opts.compEnterLeaveEventCB)
    {
        unsigned        saveStackLvl2 = genStackLevel;
        BOOL            bHookFunction;
        PROFILING_HANDLE handle, *pHandle;

        handle = eeGetProfilingHandle(info.compMethodHnd, &bHookFunction, &pHandle);

        // Give profiler a chance to back out of hooking this method
        if (bHookFunction)
        {
            assert((!handle) != (!pHandle));

            if (handle)
                inst_IV(INS_push, (unsigned) handle);
            else
                genEmitter->emitIns_AR_R(INS_push, EA_4BYTE_DSP_RELOC, SR_NA,
                                         SR_NA, (int)pHandle);

            /* HACK HACK: Inside the prolog we don't have proper stack depth tracking */
            /* Therefore we have to lie about it the fact that we are pushing an I4   */
            /* as the argument to the profiler event */

            /*          genSinglePush(false);   */

            genEmitHelperCall(CPX_PROFILER_ENTER,
                              0,    // argSize. Again, we have to lie about it
                              0);   // retSize

            /* Restore the stack level */

            genStackLevel = saveStackLvl2;

            genOnStackLevelChanged();
        }
    }

#endif

    genMethodCount();

    /*-------------------------------------------------------------------------
     *
     * Do we have any untracked pointer locals at all,
     * or do we need to initialize memory for locspace?
     */

    if  (useRepStosd)
    {
        /*
            Generate the following code:

                lea     edi, [ebp/esp-OFFS]
                mov     ecx, <size>
                xor     eax, eax
                rep     stosd
         */

#if USE_FASTCALL

        assert(rsMaskModf & RBM_EDI);

        /* For register arguments we have to save ECX, EAX */

        if  (rsCalleeRegArgMaskLiveIn & RBM_ECX)
        {
            assert(rsMaskModf & RBM_ESI);
            inst_RV_RV(INS_mov, REG_ESI, REG_ECX);
        }

        if  (rsCalleeRegArgMaskLiveIn & RBM_EAX)
        {
            assert(rsMaskModf & RBM_EBX);
            inst_RV_RV(INS_mov, REG_EBX, REG_EAX);
        }
#endif

        genEmitter->emitIns_R_AR(INS_lea,
                                 EA_4BYTE,
                                 SR_EDI,
                                 genFPused ? SR_EBP : SR_ESP,
                                 untrLclLo);

        inst_RV_IV(INS_mov, REG_ECX, (untrLclHi - untrLclLo)/sizeof(int) + 1);
        inst_RV_RV(INS_xor, REG_EAX, REG_EAX);
        instGen   (INS_r_stosd);

#if USE_FASTCALL

        /* Move back the argument registers */

        if  (rsCalleeRegArgMaskLiveIn & RBM_EAX)
            inst_RV_RV(INS_mov, REG_EAX, REG_EBX);

        if  (rsCalleeRegArgMaskLiveIn & RBM_ECX)
            inst_RV_RV(INS_mov, REG_ECX, REG_ESI);
#endif

    }
    else if (initStkLclCnt)
    {
        /* Chose the register to use for initialization */

        regNumber initReg = REG_ECX;

#if USE_FASTCALL

        /* If ECX is part of the calling convention pick a callee saved register */

        if  (rsCalleeRegArgMaskLiveIn & RBM_ECX)
        {
            if  (rsMaskModf & RBM_EDI)
            {
                initReg = REG_EDI;
            }
            else if  (rsMaskModf & RBM_ESI)
            {
                initReg = REG_ESI;
            }
            else if  (rsMaskModf & RBM_EBX)
            {
                initReg = REG_EBX;
            }
            else
            {
                assert(MAX_REG_ARG <= 2);               // we need a scratch reg
                assert((RBM_ARG_REGS & RBM_EAX) == 0);  // EAX is not a argument reg
                initReg = REG_EAX;
            }
        }

#endif

        inst_RV_RV(INS_xor, initReg, initReg);

        /* Initialize any lvMustInit vars on the stack */

        for (varNum = 0, varDsc = lvaTable;
             varNum < lvaCount;
             varNum++  , varDsc++)
        {
            if  (!varDsc->lvMustInit)
                continue;

            assert(varDsc->lvRegister || varDsc->lvOnFrame);

            /* lvMustInit is usually only set for GC (except if compInitMem) */

            assert(varTypeIsGC(varDsc->TypeGet())    ||
                   (varDsc->TypeGet() == TYP_STRUCT) || info.compInitMem);

            if (varDsc->lvRegister)
            {
                if (varDsc->lvOnFrame)
                {
                    /* This is a partially enregistered TYP_LONG var */
                    assert(varDsc->lvOtherReg == REG_STK);
                    assert(varDsc->lvType == TYP_LONG);

                    assert(info.compInitMem);

                    genEmitter->emitIns_S_R(INS_mov, EA_4BYTE, (emitRegs)initReg, varNum, sizeof(int));
                }

                continue;
            }

//          if (verbose) printf("initialize variable #%u\n", varNum);

            if ((varDsc->TypeGet() == TYP_STRUCT) && !info.compInitMem)
            {
                // We only have to initialize the GC variables in the TYP_STRUCT
                CLASS_HANDLE cls = lvaLclClass(varNum);
                assert(cls != 0);
                unsigned slots = 2;
                static bool refAnyPtr[] = { true, true };       // what the heck, zero both of them
                bool* gcPtrs = refAnyPtr;
                if (cls != REFANY_CLASS_HANDLE)
                {
                    slots = roundUp(eeGetClassSize(cls), sizeof(void*)) / sizeof(void*);
                    gcPtrs = (bool*) _alloca(slots*sizeof(bool));
                    eeGetClassGClayout(cls, gcPtrs);
                }
                for (unsigned i = 0; i < slots; i++)
                    if (gcPtrs[i])
                        genEmitter->emitIns_S_R(INS_mov, EA_4BYTE, (emitRegs)initReg, varNum, i*sizeof(void*));
            }
            else
            {
                // zero out the whole thing
                genEmitter->emitIns_S_R    (INS_mov, EA_4BYTE, (emitRegs)initReg, varNum, 0);

                unsigned lclSize = lvaLclSize(varNum);
                for(unsigned i=sizeof(void*); i < lclSize; i +=sizeof(void*))
                    genEmitter->emitIns_S_R(INS_mov, EA_4BYTE, (emitRegs)initReg, varNum, i);
            }
        }

        if  (!TRACK_GC_TEMP_LIFETIMES)
        {
            for (tempThis = tmpListBeg();
                 tempThis;
                 tempThis = tmpListNxt(tempThis))
            {
                if  (!varTypeIsGC(tempThis->tdTempType()))
                    continue;

//              printf("initialize untracked spillTmp [EBP-%04X]\n", stkOffs);

                inst_ST_RV(INS_mov, tempThis, 0, initReg, TYP_INT);

                genTmpAccessCnt++;
            }
        }
    }

#if INLINE_NDIRECT

    /*  Initialize the TCB local and the NDirect stub, afterwards "push"
        the hoisted NDirect stub.
     */

    if (info.compCallUnmanaged)
    {

        unsigned baseOffset = lvaTable[lvaScratchMemVar].lvStkOffs +
                              info.compNDFrameOffset;

        regNumbers      regNum;
        regNumbers      regNum2;

#ifdef DEBUG
        if (verbose && 0)
            printf(">>>>>>%s has unmanaged callee\n", info.compFullName);
#endif
        /* let's find out if compLvFrameListRoot is enregistered */

        varDsc = &lvaTable[info.compLvFrameListRoot];


        assert(!varDsc->lvIsParam);
        assert(varDsc->lvType == TYP_I_IMPL);

        regNum2    = REG_EDI;

        if (varDsc->lvRegister)
        {
            regNum = (regNumbers) varDsc->lvRegNum;
            if (regNum == regNum2)
                regNum2 = REG_EAX;
        }
        else
            regNum = REG_EAX;

        /* get TCB,  mov reg, FS:[info.compEEInfo.threadTlsIndex] */

        DWORD threadTlsIndex, *pThreadTlsIndex;
        threadTlsIndex = eeGetThreadTLSIndex(&pThreadTlsIndex);
        assert((!threadTlsIndex) != (!pThreadTlsIndex));

        #define WIN32_TLS_OFFSET (0xE10) // Offset from fs:[0] where the the slots start
//      assert(WIN32_TLS_OFFSET == offsetof(TEB,TlsSlots));
        // Only the first 64 DLLs are available at WIN32_TLS_OFFSET
        assert(threadTlsIndex  < TLS_MINIMUM_AVAILABLE);

        if (threadTlsIndex)
        {
            genEmitter->emitIns_R_C (INS_mov,
                                     EA_4BYTE,
                                     (emitRegs)regNum,
                                     FLD_GLOBAL_FS,
                                     WIN32_TLS_OFFSET + threadTlsIndex * sizeof(int));
        }
        else
        {
            // @ISSUE: This code is NT-specific. But if the persisted PE is run
            // on Win9X, this will not work. So need to use the generic API.
            assert(!"Use generic API");

            // lea reg, FS:[WIN32_TLS_OFFSET]
            // add reg, [pThreadTlsIndex]
            // mov reg, [reg]

            genEmitter->emitIns_R_C (INS_lea,
                                     EA_1BYTE,
                                     (emitRegs)regNum,
                                     FLD_GLOBAL_FS,
                                     WIN32_TLS_OFFSET);
            genEmitter->emitIns_R_AR(INS_add, EA_4BYTE_DSP_RELOC, (emitRegs)regNum,
                                     SR_NA, (int)pThreadTlsIndex);
            genEmitter->emitIns_R_AR(INS_mov, EA_4BYTE, (emitRegs)regNum,
                                     (emitRegs)regNum, 0);
        }

        /* save TCB in local var if not enregistered */

        if (!varDsc->lvRegister)
            genEmitter->emitIns_AR_R (INS_mov,
                                      EA_4BYTE,
                                      (emitRegs)regNum,
                                      SR_EBP,
                                      lvaTable[info.compLvFrameListRoot].lvStkOffs);

        /* set frame's vptr */

        const void * inlinedCallFrameVptr, **pInlinedCallFrameVptr;
        inlinedCallFrameVptr = eeGetInlinedCallFrameVptr(&pInlinedCallFrameVptr);
        assert((!inlinedCallFrameVptr) != (!pInlinedCallFrameVptr));

        if (inlinedCallFrameVptr)
        {
            genEmitter->emitIns_I_AR (INS_mov,
                                      EA_4BYTE,
                                      (int) inlinedCallFrameVptr,
                                      SR_EBP,
                                      baseOffset + info.compEEInfo.offsetOfFrameVptr);
        }
        else
        {
            genEmitter->emitIns_R_AR (INS_mov, EA_4BYTE_DSP_RELOC,
                                      (emitRegs)regNum2,
                                      SR_NA, (int)pInlinedCallFrameVptr);

            genEmitter->emitIns_AR_R (INS_mov,
                                      EA_4BYTE,
                                      (emitRegs)regNum2,
                                      SR_EBP,
                                      baseOffset + info.compEEInfo.offsetOfFrameVptr);
        }

        /* Get current frame root (mov reg2, [reg+offsetOfThreadFrame]) and
           set next field in frame */


        genEmitter->emitIns_R_AR (INS_mov,
                                  EA_4BYTE,
                                  (emitRegs)regNum2,
                                  (emitRegs)regNum,
                                  info.compEEInfo.offsetOfThreadFrame);

        genEmitter->emitIns_AR_R (INS_mov,
                                  EA_4BYTE,
                                  (emitRegs)regNum2,
                                  SR_EBP,
                                  baseOffset + info.compEEInfo.offsetOfFrameLink);

        /* set EBP value in frame */

        genEmitter->emitIns_AR_R (INS_mov,
                                  EA_4BYTE,
                                  SR_EBP,
                                  SR_EBP,
                                  baseOffset + 0xC +
                        info.compEEInfo.offsetOfInlinedCallFrameCalleeSavedRegisters);

        /* get address of our frame */

        genEmitter->emitIns_R_AR (INS_lea,
                                  EA_4BYTE,
                                  (emitRegs)regNum2,
                                  SR_EBP,
                                  baseOffset + info.compEEInfo.offsetOfFrameVptr);

        /* reset track field in frame */

        genEmitter->emitIns_I_AR (INS_mov,
                                  EA_4BYTE,
                                  0,
                                  SR_EBP,
                                  baseOffset
                                  + info.compEEInfo.offsetOfInlinedCallFrameCallSiteTracker);

        /* now "push" our N/direct frame */

        genEmitter->emitIns_AR_R (INS_mov,
                                  EA_4BYTE,
                                  (emitRegs)regNum2,
                                  (emitRegs)regNum,
                                  info.compEEInfo.offsetOfThreadFrame);

    }
#endif

    // @ToDo if initRegs is non-zero then use one of the zero registers to
    // init the frame locations (see initStkLclCnt above)
    if (initRegs)
    {
        /* With compMinOptim, all variables are marked as live everywhere
         * so enregistered (non-param) GC ptr vars need to be init'ed to NULL.
         * Also, with compInitMem, uninit'ed enregistered vars have to be init'ed
         */

        unsigned regMask = 0x1;

        for (unsigned reg = 0; reg < REG_COUNT; reg++, regMask<<=1)
        {
            if (regMask & initRegs)
                inst_RV_RV(INS_xor, (regNumber)reg, (regNumber)reg);
        }
    }

#if SECURITY_CHECK

    if  (opts.compNeedSecurityCheck)
    {

#if DOUBLE_ALIGN
        assert(genDoubleAlign == false);
#endif

        genEmitter->emitIns_I_AR(INS_mov,
                                  EA_4BYTE,
                                  0,
                                  SR_EBP,
                                  -4);
    }

#endif


#else  //TGT_x86

    regMaskTP       save;

    int             adjOffs = 0;

    // UNDONE: Zeroing out locals and frame for IL on RISC .....

    /* Save any callee-saved registers we use */

    save = rsMaskModf & RBM_CALLEE_SAVED & ~RBM_SPBASE;

    if  (save)
    {
        unsigned    rnum;

        for (rnum = 0; rnum < REG_COUNT; rnum++)
        {
            if  (save & genRegMask((regNumbers)rnum))
            {
                /* Generate "mov.l reg, @-sp" */

                genEmitter->emitIns_IR_R((emitRegs)REG_SPBASE,
                                          (emitRegs)rnum,
                                          true,
                                          sizeof(int));

                adjOffs += sizeof(int);
            }
        }
    }

#if TGT_SH3

    /* Save the return address register if non-leaf */

    if  (genNonLeaf)
    {
        genEmitter->emitIns_IR((emitRegs)REG_SPBASE,
                                INS_stspr,
                                true,
                                sizeof(int));

        adjOffs += sizeof(int);
    }

#endif

    /*
        Incoming arguments will be handled before the stack frame is
        set up (i.e. arguments that come on the stack but live in
        registers will be loaded, and those coming in in registers
        but not enregistered within the method will be homed on the
        stack).

        For this to work properly, we'll need to figure out what
        adjustment to apply to the arguments offsets in the code
        below that handles incoming args.
     */

    if  (genFixedArgBase)
        adjOffs = 0;

//  printf("ADJ=%d, FRM=%u\n", adjOffs, compLclFrameSize);

    adjOffs -= compLclFrameSize;

#endif//TGT_x86

    // Initialize any "hidden" slots/locals

#if TGT_x86

    if (compLocallocUsed)
    {
        genEmitter->emitIns_AR_R(INS_mov, EA_4BYTE, SR_ESP,
                                 SR_EBP, -lvaShadowSPfirstOffs);
    }
    if (info.compXcptnsCount)
    {
        unsigned    offs = lvaShadowSPfirstOffs +
                           compLocallocUsed * sizeof(void*);
        genEmitter->emitIns_I_ARR(INS_mov, EA_4BYTE, 0,
                                SR_EBP, SR_NA, -offs);
    }
#else
    assert(!compLocallocUsed && !info.compXcptnsCount);
#endif

    /*-------------------------------------------------------------------------
     *
     * The 'real' prolog ends here for non-interruptible methods
     */

    if  (!genInterruptible)
    {
        size = genEmitter->emitSetProlog();
    }

#if USE_FASTCALL

    /* Take care of register arguments first */

    if (rsCalleeRegArgMaskLiveIn)
        genFnPrologCalleeRegArgs();

#endif // USE_FASTCALL

    /* If any arguments live in registers, load them */

    for (varNum = 0, varDsc = lvaTable;
         varNum < lvaCount;
         varNum++  , varDsc++)
    {
        /* Is this variable a parameter? */

        if  (!varDsc->lvIsParam)
            continue;

#if USE_FASTCALL

        /* If a register argument it's already been taken care of */

        if  (varDsc->lvIsRegArg)
            continue;

#endif

        /* Has the parameter been assigned to a register? */

        if  (!varDsc->lvRegister)
            continue;

        var_types type = varDsc->TypeGet();

#if TGT_x86
        /* Floating point locals are loaded onto the x86-FPU in the next section */
        if (varTypeIsFloating(type))
            continue;
#endif

        /* Load the incoming parameter into the register */

        /* Figure out the home offset of the incoming argument */

        regNumbers regNum = (regNumbers)varDsc->lvRegNum;
        int        stkOfs =             varDsc->lvStkOffs;
#if     TGT_RISC
        stkOfs += adjOffs;
#endif

#if     TGT_x86

        assert(!varTypeIsFloating(type));

        if (type != TYP_LONG)
        {
            /* Not a long - this is the easy/common case */

            genEmitter->emitIns_R_S(INS_mov,
                                    emitTypeSize(type),
                                    (emitRegs)regNum,
                                    varNum,
                                    0);
        }
        else
        {
            /* long - at least the low half must be enregistered */


            genEmitter->emitIns_R_S(INS_mov,
                                    EA_4BYTE,
                                    (emitRegs)regNum,
                                    varNum,
                                    0);

            /* Is the upper half also enregistered? */

            if (varDsc->lvOtherReg != REG_STK)
            {
                genEmitter->emitIns_R_S(INS_mov,
                                        EA_4BYTE,
                                        (emitRegs)varDsc->lvOtherReg,
                                        varNum,
                                        sizeof(int));
            }
        }

#elif   TGT_SH3

        printf("WARNING:  Skipping code to load incoming register argument(s) into its reg\n");
        printf("          Argument %u needs to be loaded from sp+%u\n", varNum, stkOfs);

#else

        assert(!"unexpected target");

#endif

#ifdef  DEBUGGING_SUPPORT
        if (opts.compScopeInfo && info.compLocalVarsCount>0)
            psiMoveToReg(varNum);
#endif

    }

#if TGT_x86
    //
    // Here is where we load the enregistered floating point arguments
    //   and locals onto the x86-FPU.
    //
    // We load them in the order specified by lvaFPRegVarOrder[]
    //
    unsigned fpRegVarCnt = 0;
    varNum = lvaFPRegVarOrder[fpRegVarCnt];
    while (varNum != -1)
    {
        assert(varNum < lvaCount);

        varDsc = &lvaTable[varNum];
        var_types type = varDsc->TypeGet();

        assert(varDsc->lvRegister && varTypeIsFloating(type));

        regNumbers regNum = (regNumbers)varDsc->lvRegNum;
        int        stkOfs =             varDsc->lvStkOffs;

        if (varDsc->lvIsParam)
        {
            /* Enregistered argument */

            genEmitter->emitIns_S(INS_fld,
                                  EA_SIZE(genTypeSize(type)),
                                  varNum,
                                  0);
        }
        else
        {
            /* Enregistered local, with possible read before write */
            /* Load a floating-point zero: 0.0 */

            genEmitter->emitIns(INS_fldz);
        }

        fpRegVarCnt++;
        varNum = lvaFPRegVarOrder[fpRegVarCnt];
    }
#endif

//-----------------------------------------------------------------------------

#if !TGT_x86

    /* Do we need to allocate a stack frame? */

    if  (compLclFrameSize)
    {
        if  (genFPused)
        {

//          2fe6          mov.l       r14,@-sp
//          4f22          sts.l       pr,@-sp
//          7fe8          add.l       #-24,sp
//          6ef3          mov.l       sp,r14
//          7fc0          add.l       #-64,sp

            if  (genFPtoSP)
            {
                assert(!"add size [1] to fp -> sp");
            }
            else
            {
                assert(!"add size [2] to fp -> sp");
            }
        }
        else
        {
            /* Subtract the stack frame size from sp */

            genIncRegBy(NULL, REG_SPBASE, -compLclFrameSize, TYP_INT, false);
        }
    }

#endif // TGT_x86

    /* Increase the prolog size here only if fully interruptible */

    if  (genInterruptible)
    {
        size = genEmitter->emitSetProlog();
    }

#ifdef DEBUGGING_SUPPORT
    if (opts.compScopeInfo && info.compLocalVarsCount>0)
        psiEndProlog();
#endif

#ifdef  DEBUG
    if  (dspCode) printf("\n");
#endif

    if  (GCrefLo == +INT_MAX)
    {
        assert(GCrefHi ==  -INT_MAX);
    }
    else
    {
        genEmitter->emitSetFrameRangeGCRs(GCrefLo, GCrefHi);
    }

    // Load up the VARARG argument pointer register so it doesn't get clobbered.
    // only do this if we actually access any statically declared args (our
    // argument poitner register has a refcount > 0
    unsigned argsStartVar = info.compLocalsCount;   // This is always the first temp

    if (info.compIsVarArgs && lvaTable[argsStartVar].lvRefCnt > 0)
    {
        varDsc = &lvaTable[argsStartVar];

#if !TGT_x86
        NO_WAY("varargs NYI for RISC");
#else
            // MOV EAX, <VARARGS HANDLE>
        genEmitter->emitIns_R_S(INS_mov, EA_4BYTE, SR_EAX, info.compArgsCount-1, 0);
            // MOV EAX, [EAX]
        genEmitter->emitIns_R_AR (INS_mov, EA_4BYTE, SR_EAX, SR_EAX, 0);
            // LEA EDX, &<VARARGS HANDLE>
        genEmitter->emitIns_R_S(INS_lea, EA_4BYTE, SR_EDX, info.compArgsCount-1, 0);
            // ADD EDX, EAX
        genEmitter->emitIns_R_R(INS_add, EA_4BYTE, SR_EDX, SR_EAX);

        if  (varDsc->lvRegister)
        {
            if (varDsc->lvRegNum != REG_EDX)
                genEmitter->emitIns_R_R(INS_mov, EA_4BYTE, emitRegs(varDsc->lvRegNum), SR_EDX);
        }
        else
            genEmitter->emitIns_S_R(INS_mov, EA_4BYTE, SR_EDX, argsStartVar, 0);
#endif

    }
    genEmitter->emitEndProlog();

    return  size;
}


/*****************************************************************************
 *
 *  Generates code for a function epilog.
 */

void                Compiler::genFnEpilog()
{
    assert(!opts.compMinOptim || genFPused);    // FPO not allowed with minOpt

#ifdef  DEBUG
    genIntrptibleUse = true;
#endif

#if TGT_x86

    BYTE            epiCode[MAX_EPILOG_SIZE];   // buffer for epilog code
    BYTE    *       epiNext = epiCode;          // next byte in the buffer
    size_t          epiSize;                    // total epilog code size

    unsigned        popCount = 0;               // popped callee-saved reg #

#ifdef  DEBUG
    if  (dspCode) printf("\n__epilog:\n");
#endif

    /* Restore any callee-saved registers we have used */

    const unsigned  INS_pop_ebp = 0x5D;
    const unsigned  INS_pop_ebx = 0x5B;
    const unsigned  INS_pop_esi = 0x5E;
    const unsigned  INS_pop_edi = 0x5F;
    const unsigned  INS_pop_ecx = 0x59;

    /*
        NOTE:   The EBP-less frame code below depends on the fact that
                all of the pops are generated right at the start and
                each takes one byte of machine code.
     */

#ifdef  DEBUG
    if  (dspCode)
    {
        if  (!genFPused && (rsMaskModf & RBM_EBP))
            instDisp(INS_pop, false, "EBP");

        if  (compLocallocUsed && (rsMaskModf & (RBM_EBX|RBM_ESI|RBM_EDI)))
        {
            int offset = compCalleeRegsPushed*sizeof(int) + compLclFrameSize;
            instDisp(INS_lea, false, "ESP, [EBP-%d]", offset);
        }
        if  (rsMaskModf & RBM_EBX)
            instDisp(INS_pop, false, "EBX");
        if  (rsMaskModf & RBM_ESI)
            instDisp(INS_pop, false, "ESI");
        if  (rsMaskModf & RBM_EDI)
            instDisp(INS_pop, false, "EDI");
    }
#endif

    if  (!genFPused && (rsMaskModf & RBM_EBP))
    {
        popCount++;
        *epiNext++ = INS_pop_ebp;
    }

    if  (compLocallocUsed && (rsMaskModf & (RBM_EBX|RBM_ESI|RBM_EDI)))
    {
        int offset = compCalleeRegsPushed*sizeof(int) + compLclFrameSize;
        /* esp points might not point to the callee saved regs, we need to */
        /* reset it first via lea esp, [ebp-compCalleeRegsPushed*4-compLclFrameSize] */
        *epiNext++ = 0x8d;
        if (offset < 128)
        {
            *epiNext++ = 0x65;
            *epiNext++ = ((-offset)&0xFF);
        }
        else
        {
            *epiNext++ = 0xA5;
            *((int*)epiNext) = -offset;
            epiNext += sizeof(int);
        }
    }
    if  (rsMaskModf & RBM_EBX)
    {
        popCount++;
        *epiNext++ = INS_pop_ebx;
    }
    if  (rsMaskModf & RBM_ESI)
    {
        popCount++;
        *epiNext++ = INS_pop_esi;
    }
    if  (rsMaskModf & RBM_EDI)
    {
        popCount++;
        *epiNext++ = INS_pop_edi;
    }

    assert(compCalleeRegsPushed == popCount);

    /* Compute the size in bytes we've pushed/popped */

    int     popSize = popCount * sizeof(int);

    if  (!DOUBLE_ALIGN_NEED_EBPFRAME)
    {
        assert(compLocallocUsed == false); // Only used with frame-pointer

        /* Get rid of our local variables */

        if  (compLclFrameSize)
        {
            /* Need to add 'compLclFrameSize' to ESP
             * NOTE: If we have a CEE_JMP preserve the already computed args */

            if  (compLclFrameSize == sizeof (void *)  &&
                !(impParamsUsed && rsCalleeRegArgNum)  )
            {
#ifdef  DEBUG
                if  (dspCode) instDisp(INS_pop, false, "ECX");
#endif
                *epiNext++ = INS_pop_ecx;
            }
            else
            {
                /* Generate "add esp, <stack-size>" */

#ifdef  DEBUG
                if  (dspCode) instDisp(INS_add, false, "ESP, %d", compLclFrameSize);
#endif

                if  ((signed char)compLclFrameSize == (int)compLclFrameSize)
                {
                    /* The value fits in a signed byte */

                    *epiNext++ = 0x83;
                    *epiNext++ = 0xC4;
                    *epiNext++ = compLclFrameSize;
                }
                else
                {
                    /* Generate a full 32-bit value */

                    *epiNext++ = 0x81;
                    *epiNext++ = 0xC4;
                    *epiNext++ = (compLclFrameSize      );
                    *epiNext++ = (compLclFrameSize >>  8);
                    *epiNext++ = (compLclFrameSize >> 16);
                    *epiNext++ = (compLclFrameSize >> 24);
                }
            }
        }

//      printf("popped size = %d, final frame = %d\n", popSize, compLclFrameSize);
    }
    else
    {
        /* Tear down the stack frame */

        if  (compLclFrameSize || compLocallocUsed)
        {
            /* Generate "mov esp, ebp" */

#ifdef  DEBUG
            if  (dspCode) instDisp(INS_mov, false, "ESP, EBP");
#endif

            *epiNext++ = 0x8B;
            *epiNext++ = 0xE5;
        }

        /* Generate "pop ebp" */

#ifdef  DEBUG
        if  (dspCode) instDisp(INS_pop, false, "EBP");
#endif

        *epiNext++ = INS_pop_ebp;
    }

    epiSize = epiNext - epiCode; assert(epiSize <= MAX_EPILOG_SIZE);

    genEmitter->emitDefEpilog(epiCode, epiSize);

#elif   TGT_SH3

    regMaskTP       rest;

    /* Does the method call any others or need any stack space? */

    if  (genNonLeaf || compLclFrameSize)
    {
        if  (compLclFrameSize)
        {
            if  (genFPused)
            {

//              2fe6          mov.l       r14,@-sp
//              4f22          sts.l       pr,@-sp
//              7fe8          add.l       #-24,sp
//              6ef3          mov.l       sp,r14
//              7fc0          add.l       #-64,sp
//
//                            ...
//                            ...
//
//              ef18          mov.b       #24,sp
//              3fec          add.l       r14,sp
//              4f26          lds.l       @sp+,pr
//              6ef6          mov.l       @sp+,r14
//              000b          rts

                if  (genFPtoSP)
                {
                    assert(!"add size [1] to fp -> sp");
                }
                else
                {
                    assert(!"add size [2] to fp -> sp");
                }
            }
            else
            {
                /* Add the stack frame size to sp */

                genIncRegBy(NULL, REG_SPBASE, compLclFrameSize, TYP_INT, false);
            }
        }

        /* Restore the "PR" register if non-leaf */

        if  (genNonLeaf)
        {
            genEmitter->emitIns_IR((emitRegs)REG_SPBASE,
                                    INS_ldspr,
                                    true,
                                    sizeof(int));
        }
    }

    /* Restore any callee-saved registers we use */

    rest = rsMaskModf & RBM_CALLEE_SAVED & ~RBM_SPBASE;

    if  (rest)
    {
        unsigned    rnum;

        for (rnum = REG_COUNT - 1; rnum; rnum--)
        {
            if  (rest & genRegMask((regNumbers)rnum))
            {
                /* Generate "mov.l @sp+, reg" */

                genEmitter->emitIns_R_IR((emitRegs)rnum,
                                          (emitRegs)REG_SPBASE,
                                          true,
                                          sizeof(int));
            }
        }
    }

#else

    assert(!"unexpected target");

#endif

}

/*****************************************************************************/
/* decrement the stack pointer by the value in 'reg', touching pages as we go
   leaves the value  */

void Compiler::genAllocStack(regNumber reg)
{
#if !TGT_x86
    assert(!"NYI");
#else
    // Note that we go through a few hoops so that ESP never points to illegal
    // pages at any time during the ticking process

        //      neg REG
        //      add REG, ESP        // reg now holds ultimate ESP
        // loop:
        //      test EAX, [ESP]     // tickle the page
        //      sub REG, PAGE_SIZE
        //      cmp ESP, REG
        //      jae loop
        //      mov ESP, REG

    inst_RV(INS_neg, reg, TYP_INT);
    inst_RV_RV(INS_add, reg, REG_ESP);

    BasicBlock* loop = genCreateTempLabel();
    genDefineTempLabel(loop, true);

        // make believe we are in the prolog even if we are not,
        // otherwise we try to track ESP and we don't want that
    // unsigned saveCntStackDepth =  genEmitter->emitCntStackDepth;
    // genEmitter->emitCntStackDepth = 0;

    genEmitter->emitIns_AR_R(INS_test, EA_4BYTE, SR_EAX, SR_ESP, 0);

        // This is a hack, to avoid the emitter trying to track the decrement of the ESP
        // we do the subtraction in another reg
    inst_RV_RV(INS_xchg, REG_ESP, reg);         // Hack
    inst_RV_IV(INS_sub,  reg, JIT_PAGE_SIZE);
    inst_RV_RV(INS_xchg, REG_ESP, reg);         // Hack

    inst_RV_RV(INS_cmp,  REG_ESP, reg);
    inst_JMP(EJ_jae, loop, false, false, true);
    inst_RV_RV(INS_mov, REG_ESP, reg);

        // restore setting
    // genEmitter->emitCntStackDepth = saveCntStackDepth;
#endif
}

/*****************************************************************************
 *
 *  Record the constant (readOnly==true) or data section (readOnly==false) and
 *  return a tree node that yields its address.
 */

GenTreePtr          Compiler::genMakeConst(const void *   cnsAddr,
                                           size_t         cnsSize,
                                           varType_t      cnsType,
                                           GenTreePtr     cnsTree, bool readOnly)
{
    int             cnum;
    GenTreePtr      cval;

    /* Assign the constant an offset in the data section */

    cnum = genEmitter->emitDataGenBeg(cnsSize, readOnly, false);

    cval = gtNewOperNode(GT_CLS_VAR, cnsType);
    cval->gtClsVar.gtClsVarHnd = eeFindJitDataOffs(cnum);

#ifdef  DEBUG

    if  (dspCode)
    {
        printf("   @%s%02u   ", readOnly ? "CNS" : "RWD", cnum & ~1);

        switch (cnsType)
        {
        case TYP_INT   : printf("DD      %d \n", *(int     *)cnsAddr); break;
        case TYP_LONG  : printf("DQ      %D \n", *(__int64 *)cnsAddr); break;
        case TYP_FLOAT : printf("DF      %f \n", *(float   *)cnsAddr); break;
        case TYP_DOUBLE: printf("DQ      %lf\n", *(double  *)cnsAddr); break;

        default:
            assert(!"unexpected constant type");
        }
    }

#endif

    genEmitter->emitDataGenData(0, cnsAddr, cnsSize);
    genEmitter->emitDataGenEnd ();

    /* Transfer life info from the original tree node, if given */

    if  (cnsTree)
        cval->gtLiveSet = cnsTree->gtLiveSet;

    return cval;
}

/*****************************************************************************
 *
 *  Return non-zero if the given register is free after the given tree is
 *  evaluated (i.e. the register is either not used at all, or it holds a
 *  register variable which is not live after the given node).
 */

bool                Compiler::genRegTrashable(regNumber reg, GenTreePtr tree)
{
    unsigned        vars;
    unsigned        mask = genRegMask(reg);

    /* Is the register used for something else? */

    if  (rsMaskUsed & mask)
        return  false;

    /* Will the register hold a variable after the operation? */

//  genUpdateLife(tree);

    vars = rsMaskVars;

    if  (genCodeCurLife != tree->gtLiveSet)
    {
        VARSET_TP       aset;
        VARSET_TP       dset;
        VARSET_TP       bset;

        unsigned        varNum;
        LclVarDsc   *   varDsc;

        /* Life is changing at this node - figure out the changes */

        dset = ( genCodeCurLife & ~tree->gtLiveSet);
        bset = (~genCodeCurLife &  tree->gtLiveSet);

        aset = (dset | bset) & genCodeCurRvm;

        /* Visit all variables and update the register variable set */

        for (varNum = 0, varDsc = lvaTable;
             varNum < lvaCount && aset;
             varNum++  , varDsc++)
        {
            VARSET_TP       varBit;
            unsigned        regBit;

            /* Ignore the variable if not tracked or not in a register */

            if  (!varDsc->lvTracked)
                continue;
            if  (!varDsc->lvRegister)
                continue;

            /* Ignore the variable if it's not changing state here */

            varBit = genVarIndexToBit(varDsc->lvVarIndex);
            if  (!(aset & varBit))
                continue;

            /* Remove this variable from the 'interesting' bit set */

            aset &= ~varBit;

            /* Get hold of the appropriate register bit(s) */

            regBit = genRegMask(varDsc->lvRegNum);

            if  (isRegPairType(varDsc->lvType) && varDsc->lvOtherReg != REG_STK)
                regBit |= genRegMask(varDsc->lvOtherReg);

            /* Is the variable becoming live or dead? */

            if  (dset & varBit)
            {
                assert((vars &  regBit) != 0);
                        vars &=~regBit;
            }
            else
            {
                assert((vars &  regBit) == 0);
                        vars |= regBit;
            }
        }
    }

    if  (vars & mask)
        return  false;
    else
        return  true;
}

/*****************************************************************************/
#ifdef DEBUGGING_SUPPORT
/*****************************************************************************
 *                          genSetScopeInfo
 *
 * Called for every scope info piece to record by the main genSetScopeInfo()
 */

inline
void        Compiler::genSetScopeInfo  (unsigned which,
                                        unsigned        startOffs,
                                        unsigned        length,
                                        unsigned        varNum,
                                        unsigned        LVnum,
                                        bool            avail,
                                        const siVarLoc& varLoc)
{
    /* If there is a hidden argument, it should not be included while
       reporting the scope info. Note that this code works because if the
       retBuf is not present, compRetBuffArg will be negative, which when
       treated as an unsigned will make it a larger than any varNum */

    if (varNum > (unsigned) info.compRetBuffArg)
        varNum--;

    lvdNAME name = 0;

#ifdef DEBUG

    for (unsigned lvd=0; lvd<info.compLocalVarsCount; lvd++)
    {
        if (LVnum == info.compLocalVars[lvd].lvdLVnum)
        {
            name = info.compLocalVars[lvd].lvdName;
        }
    }

    // Hang on to this info.

    TrnslLocalVarInfo &tlvi = genTrnslLocalVarInfo[which];

    tlvi.tlviVarNum         = varNum;
    tlvi.tlviLVnum          = LVnum;
    tlvi.tlviName           = name;
    tlvi.tlviStartPC        = startOffs;
    tlvi.tlviLength         = length;
    tlvi.tlviAvailable      = avail;
    tlvi.tlviVarLoc         = varLoc;

#endif // DEBUG

    eeSetLVinfo(which, startOffs, length, varNum, LVnum, name, avail, varLoc);
}

/*****************************************************************************
 *                          genSetScopeInfo
 *
 * This function should be called only after the sizes of the emitter blocks
 * have been finalized.
 */

void                Compiler::genSetScopeInfo()
{
    if (!(opts.compScopeInfo && info.compLocalVarsCount>0))
    {
        eeSetLVcount(0);
        eeSetLVdone();
        return;
    }

    assert(opts.compScopeInfo && info.compLocalVarsCount>0);
    assert(psiOpenScopeList.scNext == NULL);

    unsigned    i;
    unsigned    scopeCnt = siScopeCnt + psiScopeCnt;

    eeSetLVcount(scopeCnt);

#ifdef DEBUG
    genTrnslLocalVarCount = scopeCnt;
    genTrnslLocalVarInfo  = (TrnslLocalVarInfo*)compGetMem(scopeCnt*sizeof(*genTrnslLocalVarInfo));
#endif

    // Record the scopes found for the parameters over the prolog.
    // The prolog needs to be treated differently as a variable may not
    // have the same info in the prolog block as is given by lvaTable.
    // eg. A register parameter is actually on the stack, before it is loaded to reg

    Compiler::psiScope *  scopeP;

    for (i=0, scopeP = psiScopeList.scNext;
         i < psiScopeCnt;
         i++, scopeP = scopeP->scNext)
    {
        assert(scopeP);
        assert(scopeP->scStartBlock);
        assert(scopeP->scEndBlock);

        NATIVE_IP   startOffs = genEmitter->emitCodeOffset(scopeP->scStartBlock,
                                                           scopeP->scStartBlkOffs);
        NATIVE_IP   endOffs   = genEmitter->emitCodeOffset(scopeP->scEndBlock,
                                                           scopeP->scEndBlkOffs);
        assert(startOffs < endOffs);

        siVarLoc        varLoc;

        // @TODO : Doesnt handle the big types correctly

        if (scopeP->scRegister)
        {
            varLoc.vlType           = VLT_REG;
            varLoc.vlReg.vlrReg     = scopeP->scRegNum;
        }
        else
        {
            varLoc.vlType           = VLT_STK;
            varLoc.vlStk.vlsBaseReg = scopeP->scBaseReg;
            varLoc.vlStk.vlsOffset  = scopeP->scOffset;
        }

        genSetScopeInfo(i,
            startOffs, endOffs-startOffs, scopeP->scSlotNum, scopeP->scLVnum,
            true, varLoc);
    }

    // Record the scopes for the rest of the method.

    // Check that the LocalVarInfo scopes look OK
    assert(siOpenScopeList.scNext == NULL);

    Compiler::siScope *  scopeL;

    for (i=0, scopeL = siScopeList.scNext;
         i < siScopeCnt;
         i++, scopeL = scopeL->scNext)
    {
        assert(scopeL);
        assert(scopeL->scStartBlock);
        assert(scopeL->scEndBlock);

        // Find the start and end IP

        NATIVE_IP   startOffs = genEmitter->emitCodeOffset(scopeL->scStartBlock,
                                                           scopeL->scStartBlkOffs);
        NATIVE_IP   endOffs   = genEmitter->emitCodeOffset(scopeL->scEndBlock,
                                                           scopeL->scEndBlkOffs);

        assert(scopeL->scStartBlock   != scopeL->scEndBlock ||
               scopeL->scStartBlkOffs != scopeL->scEndBlkOffs);

        // For stack vars, find the base register, and offset

        regNumber   baseReg;
        signed      offset = lvaTable[scopeL->scVarNum].lvStkOffs;

        if (!lvaTable[scopeL->scVarNum].lvFPbased)
        {
            baseReg     = REG_SPBASE;
#if TGT_x86
            offset     += scopeL->scStackLevel;
#endif
        }
        else
        {
            baseReg     = REG_FPBASE;
        }

        // Now fill in the varLoc

        siVarLoc        varLoc;

        if (lvaTable[scopeL->scVarNum].lvRegister)
        {
            switch(genActualType((var_types)lvaTable[scopeL->scVarNum].lvType))
            {
            case TYP_INT:
            case TYP_REF:
            case TYP_BYREF:

                varLoc.vlType               = VLT_REG;
                varLoc.vlReg.vlrReg         = lvaTable[scopeL->scVarNum].lvRegNum;
                break;

            case TYP_LONG:
#if!CPU_HAS_FP_SUPPORT
            case TYP_DOUBLE:
#endif

                if (lvaTable[scopeL->scVarNum].lvOtherReg != REG_STK)
                {
                    varLoc.vlType            = VLT_REG_REG;
                    varLoc.vlRegReg.vlrrReg1 = lvaTable[scopeL->scVarNum].lvRegNum;
                    varLoc.vlRegReg.vlrrReg2 = lvaTable[scopeL->scVarNum].lvOtherReg;
                }
                else
                {
                    varLoc.vlType                        = VLT_REG_STK;
                    varLoc.vlRegStk.vlrsReg              = lvaTable[scopeL->scVarNum].lvRegNum;
                    varLoc.vlRegStk.vlrsStk.vlrssBaseReg = baseReg;
                    varLoc.vlRegStk.vlrsStk.vlrssOffset  = offset + sizeof(int);
                }
                break;

#if CPU_HAS_FP_SUPPORT
            case TYP_DOUBLE:

                varLoc.vlType               = VLT_FPSTK;
                varLoc.vlFPstk.vlfReg       = lvaTable[scopeL->scVarNum].lvRegNum;
                break;
#endif

            default:
                assert(!"Invalid type");
            }
        }
        else
        {
            switch(genActualType((var_types)lvaTable[scopeL->scVarNum].lvType))
            {
            case TYP_INT:
            case TYP_REF:
            case TYP_BYREF:
            case TYP_FLOAT:
            case TYP_STRUCT:

                varLoc.vlType               = VLT_STK;
                varLoc.vlStk.vlsBaseReg     = baseReg;
                varLoc.vlStk.vlsOffset      = offset;
                break;

            case TYP_LONG:
            case TYP_DOUBLE:

                varLoc.vlType               = VLT_STK2;
                varLoc.vlStk2.vls2BaseReg   = baseReg;
                varLoc.vlStk2.vls2Offset    = offset;
                break;

            default:
                assert(!"Invalid type");
            }
        }

        genSetScopeInfo(psiScopeCnt + i,
            startOffs, endOffs-startOffs, scopeL->scVarNum, scopeL->scLVnum,
            scopeL->scAvailable, varLoc);
    }

    eeSetLVdone();
}

/*****************************************************************************/
#ifdef LATE_DISASM
/*****************************************************************************
 *                          CompilerRegName
 *
 * Can be called only after lviSetLocalVarInfo() has been called
 */

const char *        Compiler::siRegVarName (unsigned offs, unsigned size,
                                            unsigned reg)
{
    if (! (opts.compScopeInfo && info.compLocalVarsCount>0))
        return NULL;

    assert(genTrnslLocalVarCount==0 || genTrnslLocalVarInfo);

    for (unsigned i=0; i<genTrnslLocalVarCount; i++)
    {
        unsigned endPC =   genTrnslLocalVarInfo[i].tlviStartPC
                         + genTrnslLocalVarInfo[i].tlviLength;

        if (   (genTrnslLocalVarInfo[i].tlviVarLoc.vlIsInReg((regNumber)reg))
            && (genTrnslLocalVarInfo[i].tlviAvailable == true)
            && (genTrnslLocalVarInfo[i].tlviStartPC   <= offs+size)
            && (genTrnslLocalVarInfo[i].tlviStartPC
                 + genTrnslLocalVarInfo[i].tlviLength > offs)
           )
        {
            return genTrnslLocalVarInfo[i].tlviName ?
                   lvdNAMEstr(genTrnslLocalVarInfo[i].tlviName) : NULL;
        }

    }

    return NULL;
}

/*****************************************************************************
 *                          CompilerStkName
 *
 * Can be called only after lviSetLocalVarInfo() has been called
 */

const char *        Compiler::siStackVarName (unsigned offs, unsigned size,
                                              unsigned reg,  unsigned stkOffs)
{
    if (!(opts.compScopeInfo && info.compLocalVarsCount>0))
        return NULL;

    assert(genTrnslLocalVarCount==0 || genTrnslLocalVarInfo);

    for (unsigned i=0; i<genTrnslLocalVarCount; i++)
    {
        if (   (genTrnslLocalVarInfo[i].tlviVarLoc.vlIsOnStk((regNumber)reg, stkOffs))
            && (genTrnslLocalVarInfo[i].tlviAvailable == true)
            && (genTrnslLocalVarInfo[i].tlviStartPC   <= offs+size)
            && (genTrnslLocalVarInfo[i].tlviStartPC
                 + genTrnslLocalVarInfo[i].tlviLength >  offs)
           )
        {
            return genTrnslLocalVarInfo[i].tlviName ?
                   lvdNAMEstr(genTrnslLocalVarInfo[i].tlviName) : NULL;
        }
    }

    return NULL;
}

/*****************************************************************************/
#endif // LATE_DISASM
/*****************************************************************************
 *
 *  Append an IPmappingDsc struct to the list that we're maintaining
 *  for the debugger.
 *  Record the IL offset as being at the current code gen position.
 */

void                Compiler::genIPmappingAdd(IL_OFFSET offset)
{
    IPmappingDsc *  addMapping;

    /* Create a mapping entry and append it to the list */

    addMapping = (IPmappingDsc *)compGetMem(sizeof(*addMapping));

    addMapping->ipmdBlock       = genEmitter->emitCurBlock();
    addMapping->ipmdBlockOffs   = genEmitter->emitCurOffset();
    addMapping->ipmdILoffset    = offset;
    addMapping->ipmdNext        = 0;

    if  (genIPmappingList)
        genIPmappingLast->ipmdNext  = addMapping;
    else
        genIPmappingList            = addMapping;

    genIPmappingLast                = addMapping;
}


/*****************************************************************************
 *
 *  Prepend an IPmappingDsc struct to the list that we're maintaining
 *  for the debugger.
 *  Record the IL offset as being at the current code gen position.
 */
void                Compiler::genIPmappingAddToFront(IL_OFFSET offset)
{
    IPmappingDsc *  addMapping;

    /* Create a mapping entry and append it to the list */

    addMapping = (IPmappingDsc *)compGetMem(sizeof(*addMapping));

    addMapping->ipmdBlock       = genEmitter->emitCurBlock();
    addMapping->ipmdBlockOffs   = genEmitter->emitCurOffset();
    addMapping->ipmdILoffset    = offset;
    addMapping->ipmdNext        = 0;

    //prepend to list
    addMapping->ipmdNext = genIPmappingList;

    genIPmappingList = addMapping;

    if  (genIPmappingLast == NULL)
        genIPmappingLast            = addMapping;
}

/*****************************************************************************
 *
 *  Shut down the IP-mapping logic, report the info to the EE.
 */

void                Compiler::genIPmappingGen()
{
    IPmappingDsc *  tmpMapping;
    unsigned        mappingCnt;
    NATIVE_IP       lastNativeOfs;
    unsigned        srcIP;

    if  (!genIPmappingList)
    {
        eeSetLIcount(0);
        eeSetLIdone();
        return;
    }

    /* First count the number of distinct mapping records */

    mappingCnt      = 0;
    lastNativeOfs   = (NATIVE_IP)-1;

    for (tmpMapping = genIPmappingList; tmpMapping;
         tmpMapping = tmpMapping->ipmdNext)
    {
        NATIVE_IP   nextNativeOfs;
        nextNativeOfs = genEmitter->emitCodeOffset(tmpMapping->ipmdBlock,
                                                   tmpMapping->ipmdBlockOffs);

        srcIP   = tmpMapping->ipmdILoffset;

        if  (nextNativeOfs != lastNativeOfs)
        {
            mappingCnt++;
            lastNativeOfs = nextNativeOfs;
        }
        else if (srcIP == ICorDebugInfo::MappingTypes::EPILOG ||
                 srcIP == 0)
        {   //counting for special cases: see below
            mappingCnt++;
        }
    }

    /* Tell them how many mapping record's we've got */

    eeSetLIcount(mappingCnt);

    /* Now tell them about the mappings */

    mappingCnt      = 0;
    lastNativeOfs   = (NATIVE_IP)-1;

    for (tmpMapping = genIPmappingList; tmpMapping;
         tmpMapping = tmpMapping->ipmdNext)
    {
        NATIVE_IP nextNativeOfs;
        nextNativeOfs = genEmitter->emitCodeOffset(tmpMapping->ipmdBlock,
                                                   tmpMapping->ipmdBlockOffs);
        srcIP   = tmpMapping->ipmdILoffset;

        if  (nextNativeOfs != lastNativeOfs)
        {
            eeSetLIinfo(mappingCnt++, nextNativeOfs, srcIP);

            lastNativeOfs = nextNativeOfs;
        }
        else if (srcIP == ICorDebugInfo::MappingTypes::EPILOG ||
                 srcIP == 0)
        {
            // For the special case of an IL instruction with no body
            // followed by the epilog (say ret void immediately preceeding
            // the method end), we put two entries in, so that we'll stop
            // at the (empty) ret statement if the user tries to put a
            // breakpoint there, and then have the option of seeing the
            // epilog or not based on SetUnmappedStopMask for the stepper.
            // @todo
            // Likewise, we can (sometimes) put in a prolog that has
            // the same  nativeoffset as it's following IL instruction,
            // so we have to account for that here as well.
            eeSetLIinfo(mappingCnt++, nextNativeOfs, srcIP );
        }
    }

    eeSetLIdone();
}

/*****************************************************************************/
#endif  // DEBUGGING_SUPPORT
/*****************************************************************************/


/*============================================================================
 *
 *   These are empty stubs to help the late dis-assembler to compile
 *   if DEBUGGING_SUPPORT is not enabled
 *
 *============================================================================
 */

#if defined(LATE_DISASM) && !defined(DEBUGGING_SUPPORT)

const char * siRegVarName(unsigned offs, unsigned size, int reg)
{    return NULL;   }

const char * siStackVarName(unsigned offs, unsigned size, unsigned disp)
{    return NULL;   }

/*****************************************************************************/
#endif//DEBUGGING_SUPPORT
/*****************************************************************************/
#endif//TGT_IA64
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\delayload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "jitpch.h"
#pragma hdrstop
#include "ShimLoad.h"

ExternC PfnDliHook __pfnDliNotifyHook = ShimDelayLoadHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\compiler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          Compiler                                         XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#include "jitpch.h"
#pragma hdrstop
#include "emit.h"

#ifdef  UNDER_CE_GUI
#include "test.h"
#else
#include <time.h>
#endif

#if defined(ZIP_SUPPORT) || defined(JGZ_SUPPORT)
#include <fcntl.h>
#include <sys\stat.h>
#ifdef  JGZ_SUPPORT
extern "C"
{
#include "gzipAPI.h"
#include "gzipJIT.h"
}
#endif
#endif

/*****************************************************************************/

#ifdef  DEBUG
#ifdef  NOT_JITC
static  double      CGknob = 0.1;
#endif
#endif

/*****************************************************************************/

#if TOTAL_CYCLES
static
unsigned            jitTotalCycles;
#endif

/*****************************************************************************/

inline
unsigned            getCurTime()
{
    SYSTEMTIME      tim;

    GetSystemTime(&tim);

    return  (((tim.wHour*60) + tim.wMinute)*60 + tim.wSecond)*1000 + tim.wMilliseconds;
}

/*****************************************************************************/
#ifdef DEBUG
/*****************************************************************************/

const   char *      jitExeFileName;

const   char *      jitSrcFileName;

static
FILE    *           jitSrcFilePtr;

static
unsigned            jitCurSrcLine;

const char*         Compiler::compGetSrcFileName()
{
    return  jitSrcFileName;
}

void                Compiler::compDspSrcLinesByLineNum(unsigned line, bool seek)
{
    if  (!jitSrcFilePtr)
        return;

    if  (jitCurSrcLine == line)
        return;

    if  (jitCurSrcLine >  line)
    {
        if  (!seek)
            return;

        fseek(jitSrcFilePtr, 0, SEEK_SET);
        jitCurSrcLine = 0;
    }

    if  (!seek)
        printf(";\n");

    do
    {
        char            temp[128];
        size_t          llen;

        if  (!fgets(temp, sizeof(temp), jitSrcFilePtr))
            return;

        if  (seek)
            continue;

        llen = strlen(temp);
        if  (llen && temp[llen-1] == '\n')
            temp[llen-1] = 0;

        printf(";   %s\n", temp);
    }
    while (++jitCurSrcLine < line);

    if  (!seek)
        printf(";\n");
}


/*****************************************************************************
 *
 * Given the starting line number of a method, this tries to back up a bit
 * to the end of the previous method
 */

unsigned            Compiler::compFindNearestLine(unsigned lineNo)
{
    if (lineNo < 6 )
        return 0;
    else
        return lineNo - 6;
}

/*****************************************************************************/

void                Compiler::compDspSrcLinesByNativeIP(NATIVE_IP curIP)
{
#ifdef DEBUGGING_SUPPORT

    static IPmappingDsc *   nextMappingDsc;
    static unsigned         lastLine;

    if (!dspLines)
        return;

#if TGT_IA64

    UNIMPL("compDspSrcLinesByNativeIP");

#else

    if (curIP==0)
    {
        if (genIPmappingList)
        {
            nextMappingDsc          = genIPmappingList;
            lastLine                = nextMappingDsc->ipmdILoffset;

            unsigned firstLine      = nextMappingDsc->ipmdILoffset;

            unsigned earlierLine    = (firstLine < 5) ? 0 : firstLine - 5;

            compDspSrcLinesByLineNum(earlierLine,  true); // display previous 5 lines
            compDspSrcLinesByLineNum(  firstLine, false);
        }
        else
        {
            nextMappingDsc = NULL;
        }

        return;
    }

    if (nextMappingDsc)
    {
        NATIVE_IP   offset = genEmitter->emitCodeOffset(nextMappingDsc->ipmdBlock,
                                                        nextMappingDsc->ipmdBlockOffs);

        if (offset <= curIP)
        {
            if (lastLine < nextMappingDsc->ipmdILoffset)
            {
                compDspSrcLinesByLineNum(nextMappingDsc->ipmdILoffset);
            }
            else
            {
                // This offset corresponds to a previous line. Rewind to that line

                compDspSrcLinesByLineNum(nextMappingDsc->ipmdILoffset - 2, true);
                compDspSrcLinesByLineNum(nextMappingDsc->ipmdILoffset);
            }

            lastLine        = nextMappingDsc->ipmdILoffset;
            nextMappingDsc  = nextMappingDsc->ipmdNext;
        }
    }

#endif

#endif
}

/*****************************************************************************/

void                Compiler::compDspSrcLinesByILoffs(IL_OFFSET curOffs)
{
    unsigned lineNum = BAD_LINE_NUMBER;

    if (info.compLineNumCount)
        lineNum = compLineNumForILoffs(curOffs);

    if (lineNum != BAD_LINE_NUMBER)
        compDspSrcLinesByLineNum(lineNum);
}


/*****************************************************************************/
#endif//DEBUG
/*****************************************************************************
 * Finds the nearest line for the given IL offset. 0 if invalid
 */

unsigned            Compiler::compLineNumForILoffs(IL_OFFSET offset)
{
    if (info.compLineNumCount == 0 || offset == BAD_IL_OFFSET)
        return BAD_LINE_NUMBER;

    unsigned i = info.compLineNumCount * offset / info.compCodeSize;

    while(info.compLineNumTab[i].sldLineOfs > offset)
        i--;

    while((i+1) < info.compLineNumCount &&
          info.compLineNumTab[i+1].sldLineOfs <= offset)
        i++;

    return info.compLineNumTab[i].sldLineNum;
}

/*****************************************************************************/
#if defined(DEBUG) || MEASURE_MEM_ALLOC || MEASURE_NODE_SIZE || MEASURE_BLOCK_SIZE || DISPLAY_SIZES
static unsigned   genClassCnt;
static unsigned  genMethodCnt;
       unsigned genMethodICnt;
       unsigned genMethodNCnt;
#if TGT_IA64
       unsigned genAllInsCnt;
       unsigned genNopInsCnt;
#endif
#endif
/*****************************************************************************
 *
 *  Variables to keep track of total code amounts.
 */

#if DISPLAY_SIZES

unsigned    grossVMsize;
unsigned    grossNCsize;
unsigned    totalNCsize;
unsigned  gcHeaderISize;
unsigned  gcPtrMapISize;
unsigned  gcHeaderNSize;
unsigned  gcPtrMapNSize;

#endif

/*****************************************************************************
 *
 *  Variables to keep track of argument counts.
 */

#if CALL_ARG_STATS

unsigned    argTotalCalls;
unsigned    argHelperCalls;
unsigned    argStaticCalls;
unsigned    argNonVirtualCalls;
unsigned    argVirtualCalls;

unsigned    argTotalArgs; // total number of args for all calls (including objectPtr)
unsigned    argTotalDWordArgs;
unsigned    argTotalLongArgs;
unsigned    argTotalFloatArgs;
unsigned    argTotalDoubleArgs;

unsigned    argTotalRegArgs;
unsigned    argTotalTemps;
unsigned    argTotalLclVar;
unsigned    argTotalDeffered;
unsigned    argTotalConst;

unsigned    argTotalObjPtr;
unsigned    argTotalGTF_ASGinArgs;

unsigned    argMaxTempsPerMethod;

unsigned    argCntBuckets[] = { 0, 1, 2, 3, 4, 5, 6, 10, 0 };
histo       argCntTable(argCntBuckets);

unsigned    argDWordCntBuckets[] = { 0, 1, 2, 3, 4, 5, 6, 10, 0 };
histo       argDWordCntTable(argDWordCntBuckets);

unsigned    argDWordLngCntBuckets[] = { 0, 1, 2, 3, 4, 5, 6, 10, 0 };
histo       argDWordLngCntTable(argDWordLngCntBuckets);

unsigned    argTempsCntBuckets[] = { 0, 1, 2, 3, 4, 5, 6, 10, 0 };
histo       argTempsCntTable(argTempsCntBuckets);

#endif

/*****************************************************************************
 *
 *  Variables to keep track of basic block counts.
 */

#if COUNT_BASIC_BLOCKS

//          --------------------------------------------------
//          Basic block count frequency table:
//          --------------------------------------------------
//              <=         1 ===>  26872 count ( 56% of total)
//               2 ..      2 ===>    669 count ( 58% of total)
//               3 ..      3 ===>   4687 count ( 68% of total)
//               4 ..      5 ===>   5101 count ( 78% of total)
//               6 ..     10 ===>   5575 count ( 90% of total)
//              11 ..     20 ===>   3028 count ( 97% of total)
//              21 ..     50 ===>   1108 count ( 99% of total)
//              51 ..    100 ===>    182 count ( 99% of total)
//             101 ..   1000 ===>     34 count (100% of total)
//            1001 ..  10000 ===>      0 count (100% of total)
//          --------------------------------------------------

unsigned    bbCntBuckets[] = { 1, 2, 3, 5, 10, 20, 50, 100, 1000, 10000, 0 };
histo       bbCntTable(bbCntBuckets);

/* Histogram for the opcode size of 1 BB methods */

unsigned    bbSizeBuckets[] = { 1, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 0 };
histo       bbOneBBSizeTable(bbSizeBuckets);

#endif

/*****************************************************************************
 *
 *  Variables to get inliner eligibility stats
 */

#if INLINER_STATS
unsigned    bbInlineBuckets[] = { 1, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 0 };
histo       bbInlineTable(bbInlineBuckets);

unsigned    bbInitBuckets[] = { 1, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 0 };
histo       bbInitTable(bbInitBuckets);

unsigned    bbStaticBuckets[] = { 1, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 0 };
histo       bbStaticTable(bbStaticBuckets);

unsigned    synchMethCnt;
unsigned    clinitMethCnt;

#endif

/*****************************************************************************
 *
 *  Used by optFindNaturalLoops to gather statistical information such as
 *   - total number of natural loops
 *   - number of loops with 1, 2, ... exit conditions
 *   - number of loops that have an iterator (for like)
 *   - number of loops that have a constant iterator
 */

#if COUNT_LOOPS

unsigned    totalLoopMethods;      // counts the total number of methods that have natural loops
unsigned    maxLoopsPerMethod;     // counts the maximum number of loops a method has
unsigned    totalLoopCount;        // counts the total number of natural loops
unsigned    exitLoopCond[8];       // counts the # of loops with 0,1,2,..6 or more than 6 exit conditions
unsigned    iterLoopCount;         // counts the # of loops with an iterator (for like)
unsigned    simpleTestLoopCount;   // counts the # of loops with an iterator and a simple loop condition (iter < const)
unsigned    constIterLoopCount;    // counts the # of loops with a constant iterator (for like)

bool        hasMethodLoops;        // flag to keep track if we already counted a method as having loops
unsigned    loopsThisMethod;       // counts the number of loops in the current method

#endif

/*****************************************************************************
 *
 *  Used in the new DFA to catch dead assignments which are not removed
 *  because they contain calls
 */

#if COUNT_DEAD_CALLS

unsigned    deadHelperCount;           // counts the # of dead helper calls
unsigned    deadCallCount;             // counts the # of dead standard calls (like i=f(); where i is dead)
unsigned    removedCallCount;          // counts the # of dead standard calls that we removed

#endif

/*****************************************************************************
 * variables to keep track of how many iterations we go in a dataflow pass
 */

#if DATAFLOW_ITER

unsigned    CSEiterCount;           // counts the # of iteration for the CSE dataflow
unsigned    CFiterCount;            // counts the # of iteration for the Const Folding dataflow

#endif


#if     MEASURE_BLOCK_SIZE
size_t              genFlowNodeSize;
size_t              genFlowNodeCnt;
#endif


/*****************************************************************************/
// We keep track of methods we've already compiled.

#ifndef NOT_JITC
#ifdef  DEBUG

MethodList  *       genMethodList;

#endif
#endif

/*****************************************************************************
 *  Declare the statics
 */

#ifdef DEBUG
/* static */
unsigned            Compiler::s_compMethodsCount = 0; // to produce unique label names
#endif

#ifndef DEBUGGING_SUPPORT
/* static */
const bool          Compiler::Options::compDbgCode = false;
#endif

#ifndef PROFILER_SUPPORT
const bool          Compiler::Options::compEnterLeaveEventCB = false;
const bool          Compiler::Options::compCallEventCB       = false;
#endif

#if  !ALLOW_MIN_OPT
/* static */
const bool          Compiler::Options::compMinOptim = false;
#endif

/* static */
unsigned            Compiler::Info::compNStructIndirOffset;

/*****************************************************************************
 *
 *  One time initialization code
 */

/* static */
void                Compiler::compStartup()
{
#if DISPLAY_SIZES
    grossVMsize =
    grossNCsize =
    totalNCsize = 0;
#endif

    /* Initialize the single instance of the norls_allocator (with a page
     * preallocated) which we try to reuse for all non-simulataneous
     * uses (which is always, for the standalone)
     */

    nraInitTheAllocator();

    /* Initialize the table of tree node sizes */

    GenTree::InitNodeSize();

    /* Initialize the emitter */

#if TGT_IA64
    genStartup();
#else
    emitter::emitInit();
#endif

#ifndef NOT_JITC
    Compiler::Info::compNStructIndirOffset = 0; // dummy value
#else
    // Done in EE_Jit.cpp
#endif

}

/*****************************************************************************
 *
 *  One time finalization code
 */

/* static */
void                Compiler::compShutdown()
{
    nraTheAllocatorDone();

    /* Shut down the emitter/scheduler */

#if TGT_IA64
    genShutdown("J64.exe");
#else
    emitter::emitDone();
#endif

#if COUNT_RANGECHECKS
    if  (Compiler::optRangeChkAll)
        printf("Removed %u of %u range checks\n", Compiler::optRangeChkRmv,
                                                  Compiler::optRangeChkAll);
#endif

#if GEN_COUNT_PTRASG
    printf("Total number of pointer assignments: %u\n", ptrAsgCount);
#endif

#if COUNT_OPCODES

    unsigned            opcodeNum;

    for (opcodeNum = 0; opcodeNum < OP_Count; opcodeNum++)
        genOpcodeCnt[opcodeNum].ocNum = opcodeNum;

    printf("\nOpcode counts sorted by opcode number:\n\n");

    for (opcodeNum = 0; opcodeNum < OP_first_unused_index; opcodeNum++)
    {
        if  (genOpcodeCnt[opcodeNum].ocCnt)
        {
            printf("  %6u [%03u] %s\n", genOpcodeCnt[opcodeNum].ocCnt,
                                        genOpcodeCnt[opcodeNum].ocNum,
                                        opcodeNames[genOpcodeCnt[opcodeNum].ocNum]);
        }
    }

    printf("\nOpcode counts sorted by frequency:\n\n");

    qsort(genOpcodeCnt, OP_Count, sizeof(*genOpcodeCnt), genOpcCntCmp);

    for (opcodeNum = 0; opcodeNum < OP_first_unused_index; opcodeNum++)
    {
//      if  (genOpcodeCnt[opcodeNum].ocCnt)
        {
            printf("  %6u [%03u] %s\n", genOpcodeCnt[opcodeNum].ocCnt,
                                        genOpcodeCnt[opcodeNum].ocNum,
                                        opcodeNames[genOpcodeCnt[opcodeNum].ocNum]);
        }
    }

    printf("\n");

#endif

#ifdef  DEBUG
    if  (!genMethodCnt) return;
#endif

#if TOTAL_CYCLES
    printf("C-gen cycles: %8.3f mil (%5.2f sec/P133, %4.2f P200, %4.2f P233, %4.2f P266)\n",
                (float)jitTotalCycles/  1000000,
                (float)jitTotalCycles/133000000,
                (float)jitTotalCycles/200000000,
                (float)jitTotalCycles/233000000,
                (float)jitTotalCycles/266000000);
#endif

#if     DISPLAY_SIZES

    if    (grossVMsize && grossNCsize)
    {
        printf("--------------------------------------\n");

        printf("[%7u VM, %8u "CPU_NAME" %4u%%] %s\n",
                grossVMsize,
                grossNCsize,
                100*grossNCsize/grossVMsize,
                "Total (excluding GC info)");

#if TRACK_GC_REFS

        printf("[%7u VM, %8u "CPU_NAME" %4u%%] %s\n",
                grossVMsize,
                totalNCsize,
                100*totalNCsize/grossVMsize,
                "Total (including GC info)");

        if  (gcHeaderISize || gcHeaderNSize)
        {
            printf("\n");

            printf("GC tables   : [%7uI,%7uN] %7u byt  (%u%% of IL, %u%% of "CPU_NAME").\n",
                    gcHeaderISize+gcPtrMapISize,
                    gcHeaderNSize+gcPtrMapNSize,
                    totalNCsize - grossNCsize,
                    100*(totalNCsize - grossNCsize)/grossVMsize,
                    100*(totalNCsize - grossNCsize)/grossNCsize);

            printf("GC headers  : [%7uI,%7uN] %7u byt,"
                    " [%4.1fI,%4.1fN] %4.1f byt/meth\n",
                    gcHeaderISize, gcHeaderNSize, (gcHeaderISize+gcHeaderNSize),
                    (float)gcHeaderISize/(genMethodICnt+0.001),
                    (float)gcHeaderNSize/(genMethodNCnt+0.001),
                    (float)(gcHeaderISize+gcHeaderNSize)/genMethodCnt);
            printf("GC ptr maps : [%7uI,%7uN] %7u byt,"
                    " [%4.1fI,%4.1fN] %4.1f byt/meth\n",
                    gcPtrMapISize, gcPtrMapNSize, (gcPtrMapISize+gcPtrMapNSize),
                    (float)gcPtrMapISize/(genMethodICnt+0.001),
                    (float)gcPtrMapNSize/(genMethodNCnt+0.001),
                    (float)(gcPtrMapISize+gcPtrMapNSize)/genMethodCnt);
        }
        else
        {
            printf("\n");

            printf("GC tables   take up %u bytes (%u%% of IL, %u%% of "CPU_NAME" code).\n",
                    totalNCsize - grossNCsize,
                    100*(totalNCsize - grossNCsize)/grossVMsize,
                    100*(totalNCsize - grossNCsize)/grossNCsize);
        }

#endif

#ifdef  DEBUG
#if     DOUBLE_ALIGN
#if     0
        printf("%d out of %d methods generated with double-aligned stack\n",
                Compiler::s_lvaDoubleAlignedProcsCount, genMethodCnt);
#endif
#endif
#endif

    }

#endif

#if CALL_ARG_STATS
    Compiler::compDispCallArgStats();
#endif

#if COUNT_BASIC_BLOCKS
    printf("--------------------------------------------------\n");
    printf("Basic block count frequency table:\n");
    printf("--------------------------------------------------\n");
    bbCntTable.histoDsp();
    printf("--------------------------------------------------\n");

    printf("\n");

    printf("--------------------------------------------------\n");
    printf("One BB method size frequency table:\n");
    printf("--------------------------------------------------\n");
    bbOneBBSizeTable.histoDsp();
    printf("--------------------------------------------------\n");
#endif


#if INLINER_STATS
    printf("--------------------------------------------------\n");
    printf("One BB syncronized methods: %u\n", synchMethCnt);
    printf("--------------------------------------------------\n");
    printf("One BB clinit methods: %u\n", clinitMethCnt);

    printf("--------------------------------------------------\n");
    printf("Inlinable method size frequency table:\n");
    printf("--------------------------------------------------\n");
    bbInlineTable.histoDsp();
    printf("--------------------------------------------------\n");

    printf("--------------------------------------------------\n");
    printf("Init method size frequency table:\n");
    printf("--------------------------------------------------\n");
    bbInitTable.histoDsp();
    printf("--------------------------------------------------\n");

    printf("--------------------------------------------------\n");
    printf("Static method size frequency table:\n");
    printf("--------------------------------------------------\n");
    bbStaticTable.histoDsp();
    printf("--------------------------------------------------\n");

#endif


#if COUNT_LOOPS

    printf("---------------------------------------------------\n");
    printf("Total number of methods with loops is %5u\n", totalLoopMethods);
    printf("Total number of              loops is %5u\n", totalLoopCount);
    printf("Maximum number of loops per method is %5u\n", maxLoopsPerMethod);

    printf("\nTotal number of infinite loops is   %5u\n",              exitLoopCond[0]);
    for (int exitL = 1; exitL <= 6; exitL++)
    {
        printf("Total number of loops with %u exits is %5u\n", exitL,  exitLoopCond[exitL]);
    }
    printf("Total number of loops with more than 6 exits is %5u\n\n",  exitLoopCond[7]);

    printf("Total number of loops with an iterator is %5u\n",         iterLoopCount);
    printf("Total number of loops with a simple iterator is %5u\n",   simpleTestLoopCount);
    printf("Total number of loops with a constant iterator is %5u\n", constIterLoopCount);

#endif

#if DATAFLOW_ITER

    printf("---------------------------------------------------\n");
    printf("Total number of iterations in the CSE datatflow loop is %5u\n", CSEiterCount);
    printf("Total number of iterations in the  CF datatflow loop is %5u\n", CFiterCount);

#endif

#if COUNT_DEAD_CALLS

    printf("---------------------------------------------------\n");
    printf("Total number of dead helper   calls is %5u\n", deadHelperCount);
    printf("Total number of dead standard calls is %5u\n", deadCallCount);
    printf("Total number of removed standard calls is %5u\n", removedCallCount);

#endif

    /*
        IMPORTANT:  Use the following code to check the alignment of
                    GenTree members (in a retail build, of course).
     */

#if 0 //1
    printf("\n");
    printf("Offset of gtOper     = %2u\n", offsetof(GenTree, gtOper        ));
    printf("Offset of gtType     = %2u\n", offsetof(GenTree, gtType        ));
#if TGT_x86
    printf("Offset of gtFPlvl    = %2u\n", offsetof(GenTree, gtFPlvl       ));
#else
    printf("Offset of gtIntfRegs = %2u\n", offsetof(GenTree, gtIntfRegs    ));
#endif
#if CSE
    printf("Offset of gtCost     = %2u\n", offsetof(GenTree, gtCost        ));
    printf("Offset of gtCSEnum   = %2u\n", offsetof(GenTree, gtCSEnum      ));
    printf("Offset of gtConstNum = %2u\n", offsetof(GenTree, gtConstAsgNum ));
    printf("Offset of gtCopyNum  = %2u\n", offsetof(GenTree, gtCopyAsgNum  ));
    printf("Offset of gtFPrvcOut = %2u\n", offsetof(GenTree, gtStmtFPrvcOut));
#endif
#if !TGT_x86
    printf("Offset of gtLiveSet  = %2u\n", offsetof(GenTree, gtLiveSet     ));
#endif
    printf("Offset of gtRegNum   = %2u\n", offsetof(GenTree, gtRegNum      ));
#if TGT_x86
    printf("Offset of gtUsedRegs = %2u\n", offsetof(GenTree, gtUsedRegs    ));
#endif
#if TGT_x86
    printf("Offset of gtLiveSet  = %2u\n", offsetof(GenTree, gtLiveSet     ));
    printf("Offset ofgtStmtILoffs= %2u\n", offsetof(GenTree, gtStmtILoffs  ));
    printf("Offset of gtFPregVar = %2u\n", offsetof(GenTree, gtFPregVars   ));
#else
    printf("Offset of gtTempRegs = %2u\n", offsetof(GenTree, gtTempRegs    ));
#endif
    printf("Offset of gtRsvdRegs = %2u\n", offsetof(GenTree, gtRsvdRegs    ));
    printf("Offset of gtFlags    = %2u\n", offsetof(GenTree, gtFlags       ));
    printf("Offset of gtNext     = %2u\n", offsetof(GenTree, gtNext        ));
    printf("Offset of gtPrev     = %2u\n", offsetof(GenTree, gtPrev        ));
    printf("Offset of gtOp       = %2u\n", offsetof(GenTree, gtOp          ));
    printf("\n");
    printf("Size   of gtOp       = %2u\n", sizeof(((GenTreePtr)0)->gtOp    ));
    printf("Size   of gtIntCon   = %2u\n", sizeof(((GenTreePtr)0)->gtIntCon));
    printf("Size   of gtField    = %2u\n", sizeof(((GenTreePtr)0)->gtField));
    printf("Size   of gtLclVar   = %2u\n", sizeof(((GenTreePtr)0)->gtLclVar));
    printf("Size   of gtRegVar   = %2u\n", sizeof(((GenTreePtr)0)->gtRegVar));
    printf("Size   of gtCall     = %2u\n", sizeof(((GenTreePtr)0)->gtCall  ));
    printf("Size   of gtInd      = %2u\n", sizeof(((GenTreePtr)0)->gtInd  ));
    printf("Size   of gtStmt     = %2u\n", sizeof(((GenTreePtr)0)->gtStmt  ));
    printf("\n");
    printf("Size   of GenTree    = %2u\n", sizeof(GenTree));

#endif

#if     MEASURE_NODE_HIST

    printf("\nDistribution of GenTree node counts:\n");
    genTreeNcntHist.histoDsp();

    printf("\nDistribution of GenTree node  sizes:\n");
    genTreeNsizHist.histoDsp();

    printf("\n");

#elif   MEASURE_NODE_SIZE

    printf("\n");

    printf("Allocated %6u tree nodes (%7u bytes total, avg %4u per method)\n",
            genNodeSizeStats.genTreeNodeCnt, genNodeSizeStats.genTreeNodeSize,
            genNodeSizeStats.genTreeNodeSize / genMethodCnt);
#if     SMALL_TREE_NODES
    printf("OLD SIZE: %6u tree nodes (%7u bytes total, avg %4u per method)\n",
            genNodeSizeStats.genTreeNodeCnt, genNodeSizeStats.genTreeNodeCnt * sizeof(GenTree),
            genNodeSizeStats.genTreeNodeCnt * sizeof(GenTree) / genMethodCnt);

    printf("\n");
    printf("Small tree node size = %u\n", TREE_NODE_SZ_SMALL);
    printf("Large tree node size = %u\n", TREE_NODE_SZ_LARGE);
#endif

#endif

#if     MEASURE_BLOCK_SIZE

    printf("\n");
    printf("Offset of bbNext     = %2u\n", offsetof(BasicBlock, bbNext    ));
    printf("Offset of bbNum      = %2u\n", offsetof(BasicBlock, bbNum     ));
    printf("Offset of bbRefs     = %2u\n", offsetof(BasicBlock, bbRefs    ));
    printf("Offset of bbFlags    = %2u\n", offsetof(BasicBlock, bbFlags   ));
    printf("Offset of bbCodeOffs = %2u\n", offsetof(BasicBlock, bbCodeOffs));
    printf("Offset of bbCodeSize = %2u\n", offsetof(BasicBlock, bbCodeSize));
    printf("Offset of bbCatchTyp = %2u\n", offsetof(BasicBlock, bbCatchTyp));
    printf("Offset of bbJumpKind = %2u\n", offsetof(BasicBlock, bbJumpKind));

    printf("Offset of bbTreeList = %2u\n", offsetof(BasicBlock, bbTreeList));
    printf("Offset of bbStkDepth = %2u\n", offsetof(BasicBlock, bbStkDepth));
    printf("Offset of bbStkTemps = %2u\n", offsetof(BasicBlock, bbStkTemps));
    printf("Offset of bbTryIndex = %2u\n", offsetof(BasicBlock, bbTryIndex));
    printf("Offset of bbWeight   = %2u\n", offsetof(BasicBlock, bbWeight  ));
    printf("Offset of bbVarUse   = %2u\n", offsetof(BasicBlock, bbVarUse  ));
    printf("Offset of bbVarDef   = %2u\n", offsetof(BasicBlock, bbVarDef  ));
    printf("Offset of bbLiveIn   = %2u\n", offsetof(BasicBlock, bbLiveIn  ));
    printf("Offset of bbLiveOut  = %2u\n", offsetof(BasicBlock, bbLiveOut ));
    printf("Offset of bbScope    = %2u\n", offsetof(BasicBlock, bbScope   ));

#if RNGCHK_OPT || CSE

    printf("Offset of bbExpGen   = %2u\n", offsetof(BasicBlock, bbExpGen  ));
    printf("Offset of bbExpKill  = %2u\n", offsetof(BasicBlock, bbExpKill ));
    printf("Offset of bbExpIn    = %2u\n", offsetof(BasicBlock, bbExpIn   ));
    printf("Offset of bbExpOut   = %2u\n", offsetof(BasicBlock, bbExpOut  ));

#endif

#if RNGCHK_OPT

    printf("Offset of bbDom      = %2u\n", offsetof(BasicBlock, bbDom     ));
    printf("Offset of bbPreds    = %2u\n", offsetof(BasicBlock, bbPreds   ));

#endif

    printf("Offset of bbEmitCook = %2u\n", offsetof(BasicBlock, bbEmitCookie));
    printf("Offset of bbLoopNum  = %2u\n", offsetof(BasicBlock, bbLoopNum ));
//    printf("Offset of bbLoopMask = %2u\n", offsetof(BasicBlock, bbLoopMask));

    printf("Offset of bbJumpOffs = %2u\n", offsetof(BasicBlock, bbJumpOffs));
    printf("Offset of bbJumpDest = %2u\n", offsetof(BasicBlock, bbJumpDest));
    printf("Offset of bbJumpSwt  = %2u\n", offsetof(BasicBlock, bbJumpSwt ));

    printf("\n");
    printf("Size   of BasicBlock = %2u\n", sizeof(BasicBlock));

    printf("\n");
    printf("Allocated %6u basic blocks (%7u bytes total, avg %4u per method)\n",
           BasicBlock::s_Count, BasicBlock::s_Size, BasicBlock::s_Size / genMethodCnt);
    printf("Allocated %6u flow nodes (%7u bytes total, avg %4u per method)\n",
           genFlowNodeCnt, genFlowNodeSize, genFlowNodeSize / genMethodCnt);
#endif

#if MEASURE_MEM_ALLOC
    printf("\n");
    printf("Total allocation count: %9u (avg %5u per method)\n",
            genMemStats.allocCnt  , genMemStats.allocCnt   / genMethodCnt);
    printf("Total allocation size : %9u (avg %5u per method)\n",
            genMemStats.allocSiz  , genMemStats.allocSiz   / genMethodCnt);

    printf("\n");
    printf("Low-level used   size : %9u (avg %5u per method)\n",
            genMemStats.loLvlUsed , genMemStats.loLvlUsed  / genMethodCnt);
    printf("Low-level alloc  size : %9u (avg %5u per method)\n",
            genMemStats.loLvlAlloc, genMemStats.loLvlAlloc / genMethodCnt);

    printf("\n");
    printf("Largest method   alloc: %9u %s\n",
            genMemStats.loLvlBigSz, genMemStats.loLvlBigNm);

    printf("\nDistribution of alloc sizes:\n");
    genMemLoLvlHist.histoDsp();
#endif

#if SCHED_MEMSTATS
    SchedMemStats(genMethodCnt);
#endif

#if MEASURE_PTRTAB_SIZE
    printf("Reg pointer descriptor size (internal): %8u (avg %4u per method)\n",
            s_gcRegPtrDscSize, s_gcRegPtrDscSize / genMethodCnt);

    printf("Total pointer table size: %8u (avg %4u per method)\n",
            s_gcTotalPtrTabSize, s_gcTotalPtrTabSize / genMethodCnt);

#endif

#if MEASURE_MEM_ALLOC || MEASURE_NODE_SIZE || MEASURE_BLOCK_SIZE || MEASURE_BLOCK_SIZE || DISPLAY_SIZES

    if  (genMethodCnt)
    {
        printf("\n");
        printf("// A total of %6u classes compiled.\n",  genClassCnt);
        printf("// A total of %6u methods compiled"   , genMethodCnt);
        if  (genMethodICnt||genMethodNCnt)
            printf(" (%uI,%uN)", genMethodICnt, genMethodNCnt);
        printf(".\n");

#if TGT_IA64
        if  (genAllInsCnt && genNopInsCnt)
            printf("// A total of %6u instructions (%u nop's / %u%%) generated\n", genAllInsCnt, genNopInsCnt, 100*genNopInsCnt/genAllInsCnt);
#endif
    }

#endif

#if EMITTER_STATS
    emitterStats();
#endif

}

/*****************************************************************************
 *
 *  Constructor
 */

void                Compiler::compInit(norls_allocator * pAlloc)
{
    assert(pAlloc);
    compAllocator = pAlloc;

     fgInit();
    lvaInit();
     raInit();
    genInit();
    optInit();
     eeInit();

#if ALLOW_MIN_OPT
    opts.compMinOptim = false;
#endif

    compLocallocUsed    = false;
    compTailCallUsed    = false;
}

/*****************************************************************************
 *
 *  Destructor
 */

void                Compiler::compDone()
{
}

/******************************************************************************
 *
 *  The Emitter uses this callback function to allocate its memory
 */

/* static */
void  *  FASTCALL       Compiler::compGetMemCallback(void *p, size_t size)
{
    ASSert(p);

    return ((Compiler *)p)->compGetMem(size);
}

/*****************************************************************************
 *
 *  The central memory allocation routine used by the compiler. Normally this
 *  is a simple inline method defined in compiler.hpp, but for debugging it's
 *  often convenient to keep it non-inline.
 */

#ifndef  FAST

void  *  FASTCALL       Compiler::compGetMem(size_t sz)
{
#if 0
#if SMALL_TREE_NODES
    if  (sz != TREE_NODE_SZ_SMALL &&
         sz != TREE_NODE_SZ_LARGE && sz > 32)
    {
        printf("Alloc %3u bytes\n", sz);
    }
#else
    if  (sz != sizeof(GenTree)    && sz > 32)
    {
        printf("Alloc %3u bytes\n", sz);
    }
#endif
#endif

#if MEASURE_MEM_ALLOC
    genMemStats.allocCnt += 1;
    genMemStats.allocSiz += sz;
#endif

    void * ptr = compAllocator->nraAlloc(sz);

//  if ((int)ptr == 0x010e0ab0) debugStop(0);

    // Verify that the current block is aligned. Only then will the next
    // block allocated be on an aligned boundary.
    assert ((int(ptr) & (sizeof(int)- 1)) == 0);

    return ptr;
}

#endif

/*****************************************************************************
 *
 *  Make a writeable copy of the IL. As an option, a NULL-terminated list
 *  of pointer variables may be passed in; these must all point into the
 *  old IL of the method, and will be updated to point into the new copy.
 */

void    __cdecl     Compiler::compMakeBCWriteable(void *ptr, ...)
{
    BYTE    *       newAddr;
    int             adjAddr;

    BYTE    *   **  ptrAddr;

    assert(info.compBCreadOnly); info.compBCreadOnly = false;

    /* Allocate a new block to hold the IL opcodes */

    newAddr = (BYTE *)compGetMemA(info.compCodeSize);

    /* Copy the IL block */

    memcpy(newAddr, info.compCode, info.compCodeSize);

    /* Compute the adjustment value */

    adjAddr = newAddr - info.compCode;

    /* Update any pointers passed by the caller */

    for ( ptrAddr = (BYTE ***)&ptr;
         *ptrAddr;
          ptrAddr++)
    {
        /* Make sure the pointer really points into the IL opcodes */

        assert(**ptrAddr >= info.compCode);
        assert(**ptrAddr <= info.compCode + info.compCodeSize);

        /* Update the pointer to point into the new copy */

        **ptrAddr += adjAddr;
    };

    /* Finally, update the global IL address */

    info.compCode = newAddr;
}

/*****************************************************************************/
#ifdef DEBUG
/*****************************************************************************/

Compiler::lvdNAME       Compiler::compRegVarNAME(regNumber reg, bool fpReg)
{

#if TGT_x86
    if (fpReg)
        assert(reg < FP_STK_SIZE);
    else
#endif
        assert(genIsValidReg(reg));

    if  (info.compLocalVarsCount>0 && compCurBB && varNames)
    {
        unsigned        lclNum;
        LclVarDsc   *   varDsc;

        /* Look for the matching register */
        for (lclNum = 0, varDsc = lvaTable;
             lclNum < lvaCount;
             lclNum++  , varDsc++)
        {
            /* if variable not in a register or not the register we're looking for quit */
            /* also if a compiler generated variable (i.e. slot# > info.compLocalVarsCount) don't bother */
            if  ((varDsc->lvRegister != 0)                      &&
                 (varDsc->lvRegNum   == reg)                    &&
                 (varDsc->lvType     == TYP_DOUBLE || !fpReg)   &&
                 (varDsc->lvSlotNum  < info.compLocalVarsCount))
            {
                /* check if variable in that register is live */
                if (genCodeCurLife & genVarIndexToBit(varDsc->lvVarIndex))
                {
                    /* variable is live - find the corresponding slot */
                    unsigned        blkBeg = compCurBB->bbCodeOffs;
                    unsigned        blkEnd = compCurBB->bbCodeSize + blkBeg;
                    LocalVarDsc *   lvd    = compFindLocalVar(varDsc->lvSlotNum,
                                                              blkBeg, blkEnd);
                    if (lvd)
                        return lvd->lvdName;
                }
            }
        }

        // maybe var is marked dead, but still used (last use)
        if (!fpReg && rsUsedTree[reg] != NULL)
        {
            GenTreePtr  nodePtr;

            if (GenTree::OperIsUnary(rsUsedTree[reg]->OperGet()))
            {
                assert(rsUsedTree[reg]->gtOp.gtOp1 != NULL);
                nodePtr = rsUsedTree[reg]->gtOp.gtOp1;
            }
            else
            {
                nodePtr = rsUsedTree[reg];
            }

            if ((nodePtr->gtOper == GT_REG_VAR) &&
                (nodePtr->gtRegVar.gtRegNum == (regNumber)reg) &&
                (nodePtr->gtRegVar.gtRegVar < info.compLocalVarsCount))
            {
                unsigned        blkBeg = compCurBB->bbCodeOffs;
                unsigned        blkEnd = compCurBB->bbCodeSize + blkBeg;
                unsigned        varNum = nodePtr->gtRegVar.gtRegVar;
                LocalVarDsc *   lvd    = compFindLocalVar(varNum,
                                                          blkBeg, blkEnd);

                if (lvd)
                    return lvd->lvdName;
            }
        }
    }
    return 0;
}

const   char *      Compiler::compRegVarName(regNumber reg, bool displayVar)
{
    assert(genIsValidReg(reg));

    if (displayVar)
    {
        lvdNAME varName = compRegVarNAME(reg);

        if (varName)
        {
            static char nameVarReg[2][4 + 256 + 1]; // to avoid overwriting the buffer wehn have 2 consecutive calls before printing
            static int  index = 0;                  // for circular index into the name array

            index = (index+1)%2;                    // circular reuse of index
            sprintf(nameVarReg[index], "%s'%s'",
                    getRegName(reg), lvdNAMEstr(varName));

            return nameVarReg[index];
        }
    }

    /* no debug info required or no variable in that register
       -> return standard name */

    return getRegName(reg);
}

#if TGT_x86

#define MAX_REG_PAIR_NAME_LENGTH 10

const   char *      Compiler::compRegPairName(regPairNo regPair)
{
    static char regNameLong[MAX_REG_PAIR_NAME_LENGTH];

    assert(regPair >= REG_PAIR_FIRST &&
           regPair <= REG_PAIR_LAST);

    strcpy(regNameLong, compRegVarName(genRegPairLo(regPair)));
    strcat(regNameLong, "|");
    strcpy(regNameLong, compRegVarName(genRegPairHi(regPair)));
    return regNameLong;
}


const   char *      Compiler::compRegNameForSize(regNumber reg, size_t size)
{
    if (size == 0 || size >= 4)
        return compRegVarName(reg, true);

    static
    const char  *   sizeNames[][2] =
    {
        { "AL", "AX" },
        { "CL", "CX" },
        { "DL", "DX" },
        { "BL", "BX" },
    };

    assert(isByteReg (reg));
    assert(genRegMask(reg) & RBM_BYTE_REGS);
    assert(size == 1 || size == 2);

    return sizeNames[reg][size-1];
}

const   char *      Compiler::compFPregVarName(unsigned fpReg, bool displayVar)
{
    /* 'reg' is the distance from the bottom of the stack, ie.
     * it is independant of the current FP stack level
     */

    assert(fpReg < FP_STK_SIZE);

    static char nameVarReg[2][4 + 256 + 1]; // to avoid overwriting the buffer wehn have 2 consecutive calls before printing
    static int  index = 0;                  // for circular index into the name array

    index = (index+1)%2;                    // circular reuse of index

    if (displayVar && genFPregCnt)
    {
        assert(fpReg <= (genFPregCnt + genFPstkLevel)-1);

        unsigned    pos     = genFPregCnt - (fpReg+1 -  genFPstkLevel);
        lvdNAME     varName = compRegVarNAME((regNumber)pos, true);

        if (varName)
        {
            sprintf(nameVarReg[index], "ST(%d)'%s'", fpReg, lvdNAMEstr(varName));

            return nameVarReg[index];
        }
    }

    /* no debug info required or no variable in that register
       -> return standard name */

    sprintf(nameVarReg[index], "ST(%d)", fpReg);
    return nameVarReg[index];
}

#endif

Compiler::LocalVarDsc *     Compiler::compFindLocalVar( unsigned    varNum,
                                                        unsigned    lifeBeg,
                                                        unsigned    lifeEnd)
{
    LocalVarDsc *   t;
    unsigned        i;

if  ((int)info.compLocalVars == 0xDDDDDDDD) return NULL;    // why is this needed?????

    for (i = 0, t = info.compLocalVars;
        i < info.compLocalVarsCount;
        i++  , t++)
    {
        if  (t->lvdVarNum  != varNum)   continue;
        if  (t->lvdLifeBeg >  lifeEnd)  continue;
        if  (t->lvdLifeEnd <= lifeBeg)  continue;

        return t;
    }

    return NULL;
}

const   char *      Compiler::compLocalVarName(unsigned varNum, unsigned offs)
{
    unsigned        i;
    LocalVarDsc *   t;

    for (i = 0, t = info.compLocalVars;
         i < info.compLocalVarsCount;
         i++  , t++)
    {
        if  (t->lvdVarNum != varNum)
            continue;

        if  (offs >= t->lvdLifeBeg &&
             offs <  t->lvdLifeEnd)
        {
            return lvdNAMEstr(t->lvdName);
        }
    }

    return  0;
}


/*****************************************************************************/
#endif //DEBUG
/*****************************************************************************/

// @todo - The following statics were moved to file globals to avoid the VC7
//         compiler problem with statics in functions containing trys.
//         When the next VC7 LKG comes out, these can be returned to the function
#ifdef  DEBUG
#if     ALLOW_MIN_OPT
static const char * minOpts = getenv("JITminOpts");
#endif
#endif

#ifdef  NOT_JITC
static bool noSchedOverride = getNoSchedOverride();
#endif

#ifndef _WIN32_WCE
#ifdef  DEBUG
static  const   char *  nameList = getenv("NORNGCHK");
#endif
#endif

void                Compiler::compInitOptions(unsigned compileFlags)
{
    opts.eeFlags      = compileFlags;

#ifdef NOT_JITC
#ifdef DEBUG

    /* In the DLL, this matches the command line options in the EXE */

    #define SET_OPTS(b) { dspCode = b; dspGCtbls = b; dspGCoffs = b; \
                          disAsm2 = b; if (1) verbose = b; }

    SET_OPTS(false);

/**
    if (opts.eeFlags & CORJIT_FLG_DUMP)
        SET_OPTS(true);
***/

#endif
#endif

#ifdef DEBUG
/**
    if (opts.eeFlags & CORJIT_FLG_GCDUMP)
        dspGCtbls = true;

    if (opts.eeFlags & CORJIT_FLG_DISASM)
        disAsm = true;
***/
#endif

#ifdef  NOT_JITC
    if  ((opts.eeFlags & CORJIT_FLG_DEBUG_OPT))
#else
    if  ((opts.eeFlags & CORJIT_FLG_DEBUG_OPT) || !maxOpts)
#endif
        opts.compFlags = CLFLG_MINOPT;
    else
        opts.compFlags = CLFLG_MAXOPT;

    opts.compFastCode   = (opts.compFlags & CLFLG_CODESPEED)  ?  true : false;

    //-------------------------------------------------------------------------

#ifdef  DEBUGGING_SUPPORT
#ifdef  NOT_JITC
    opts.compDbgCode    = (opts.eeFlags & CORJIT_FLG_DEBUG_OPT)  ?  true : false;
    opts.compDbgInfo    = (opts.eeFlags & CORJIT_FLG_DEBUG_INFO) ?  true : false;
    opts.compDbgEnC     = (opts.eeFlags & CORJIT_FLG_DEBUG_EnC)  ?  true : false;
#else
    opts.compDbgCode    = debuggableCode;
    opts.compDbgInfo    = debugInfo;
    opts.compDbgEnC     = debugEnC;
#if     TGT_IA64
    if  (tempAlloc) opts.compFlags |= CLFLG_TEMP_ALLOC;
#endif
#endif

#ifdef PROFILER_SUPPORT
#ifdef NOT_JITC
    opts.compEnterLeaveEventCB = (opts.eeFlags & CORJIT_FLG_PROF_ENTERLEAVE)? true : false;
    opts.compCallEventCB     =   (opts.eeFlags & CORJIT_FLG_PROF_CALLRET)   ? true : false;
#else
    opts.compEnterLeaveEventCB = false;
    opts.compCallEventCB     =   false;
#endif
#endif

    opts.compScopeInfo  = opts.compDbgInfo;
#ifdef LATE_DISASM
    // For the late disassembly, we need the scope information
    opts.compDisAsm     = disAsm;
    opts.compLateDisAsm = disAsm2;
#ifndef NOT_JITC
    opts.compScopeInfo |= disAsm2;  // disasm needs scope-info for better display
#endif
#endif

#endif // DEBUGGING_SUPPORT

    /* Calling the late disassembler means we need to call the emitter. */

#ifdef  LATE_DISASM
    if  (opts.compLateDisAsm)
        savCode = true;
#endif

    //-------------------------------------------------------------------------

#if     SECURITY_CHECK
    opts.compNeedSecurityCheck = false;
#endif

#if     RELOC_SUPPORT
    opts.compReloc = (opts.eeFlags & CORJIT_FLG_RELOC) ? true : false;
#endif

#ifdef  DEBUG
#if     ALLOW_MIN_OPT

    // static minOpts made file global for vc7 bug

    if  (minOpts)
        opts.compMinOptim = true;

#endif
#endif

    /* Control the optimizations */

    if (opts.compMinOptim || opts.compDbgCode)
    {
        opts.compFastCode = false;
        opts.compFlags &= ~CLFLG_MAXOPT;
        opts.compFlags |=  CLFLG_MINOPT;
    }

#if     TGT_x86
    genFPreqd  = opts.compMinOptim;
#ifdef  DEBUG
    if (opts.eeFlags & CORJIT_FLG_FRAMED)
        genFPreqd  = true;
#endif
#endif
#if     DOUBLE_ALIGN
    opts.compDoubleAlignDisabled = opts.compMinOptim;
#endif

    /* Are we supposed to do inlining? */

#ifdef  NOT_JITC
    if (getNoInlineOverride())
        genInline = false;
    else
        genInlineSize = getInlineSize();
#endif

    //-------------------------------------------------------------------------
    //
    //                  Resolve some interrelated flags for scheduling.
    //

#if     SCHEDULER

#ifndef  NOT_JITC

    extern bool schedCode;
    opts.compSchedCode = schedCode;

    // In JVC we need to save the generated code to do scheduling
    if  (opts.compSchedCode) savCode   = true;

#else //NOT_JITC

    // Default value

#if TGT_x86 || TGT_IA64
    opts.compSchedCode = true;
#else
    opts.compSchedCode = false;
#endif

    //  Turn off scheduling if the registry says to do so,

    // static noSchedOverride made file global for VC7 bug
    if  (noSchedOverride)
        opts.compSchedCode = false;

    // Turn off scheduling if we are not optimizing

    if (opts.compMinOptim || opts.compDbgCode)
        opts.compSchedCode = false;

    // Turn off scheduling if we're not generating code for a Pentium.
    // Under DEBUG, schedule methods with an even code-size

#ifdef DEBUG
    if  (info.compCodeSize%2)
#else
    if  (genCPU != 5)
#endif
        opts.compSchedCode = false;

#endif // NOT_JITC

    /* RISCify the generated code only if we're scheduling */

    riscCode = opts.compSchedCode;

#endif // SCHEDULER

#if     TGT_RISC
     riscCode = false;
#if     SCHEDULER
//  opts.compSchedCode = false;
#endif
#endif

    //-------------------------------------------------------------------------

#ifndef _WIN32_WCE
#ifdef  DEBUG

     // static nameList made file global for VC7 bug

    if  (nameList)
    {
        assert(info.compMethodName);
        const   char *  nameLst = nameList;
        int             nameLen = strlen(info.compMethodName);

        rngCheck = true;

        while (*nameLst)
        {
            const   char *  nameBeg;

            while (*nameLst == ' ')
                nameLst++;

            nameBeg = nameLst;

            while (*nameLst && *nameLst != ' ')
                nameLst++;

            if  (nameLst - nameBeg == nameLen)
            {
                if  (!memcmp(nameBeg, info.compMethodName, nameLen))
                {
                    rngCheck = false;
                    break;
                }
            }
        }
    }

#endif
#endif

}

/*****************************************************************************
 *
 *  Compare function passed to qsort() to sort line number records by offset.
 */

static
int __cdecl         genLineNumCmp(const void *op1, const void *op2)
{
    return  ((Compiler::srcLineDsc *)op2)->sldLineOfs -
            ((Compiler::srcLineDsc *)op1)->sldLineOfs;
}

/*****************************************************************************
 *
 *  Compare function passed to qsort() to sort line number records by offset.
 */

void            Compiler::compInitDebuggingInfo()
{
    /*-------------------------------------------------------------------------
     *
     * Get hold of the local variable records, if there are any
     */

#ifndef DEBUG
#ifdef  DEBUGGING_SUPPORT
    if (opts.compScopeInfo || opts.compDbgCode)
#endif
#endif
    {
        info.compLocalVarsCount = 0;

        eeGetVars();

#ifdef DEBUG
        if  (verbose)
        {
            printf("info.compLocalVarsCount = %d\n", info.compLocalVarsCount);

            if (info.compLocalVarsCount)
                printf("    \tVarNum \t      Name \tBeg \tEnd\n");

            for (unsigned i = 0; i < info.compLocalVarsCount; i++)
            {
                LocalVarDsc * lvd = &info.compLocalVars[i];
                printf("%2d) \t%02Xh \t%10s \t%03Xh   \t%03Xh  \n",
                       i, lvd->lvdVarNum, lvdNAMEstr(lvd->lvdName), lvd->lvdLifeBeg, lvd->lvdLifeEnd);
            }
        }
#endif

    }

#ifdef DEBUGGING_SUPPORT
    if ((opts.compScopeInfo || opts.compDbgCode) && info.compLocalVarsCount>0)
    {
        compInitScopeLists();
    }
#endif

    /*-------------------------------------------------------------------------
     *
     * Read the stmt-offsets table and the line-number table
     */

    info.compStmtOffsetsImplicit = (ImplicitStmtOffsets)0;

#ifndef DEBUG
#ifdef  DEBUGGING_SUPPORT
    if (!opts.compDbgInfo)
    {
        info.compLineNumCount = 0;
    }
    else
#endif
#endif
    {
        /* Get hold of the line# records, if there are any */

        eeGetStmtOffsets();

#ifdef DEBUG
        if (verbose)
        {
            printf("info.compStmtOffsetsCount = %d, info.compStmtOffsetsImplicit = %04Xh\n",
                    info.compStmtOffsetsCount,      info.compStmtOffsetsImplicit);
            IL_OFFSET * pOffs = info.compStmtOffsets;
            for(unsigned i = 0; i < info.compStmtOffsetsCount; i++, pOffs++)
                printf("%02d) IL_%04Xh\n", i, *pOffs);
        }
#endif
    }


    /*-------------------------------------------------------------------------
     * Open the source file and seek within the file to close to
     * the start of the method without displaying anything yet
     */

#if defined(DEBUG) && !defined(NOT_JITC)

    if  (info.compLineNumCount)
    {
        /* See if we can get to the source file
         * @TODO : In IL, one method could map to different source files,
         * so we may potentially have to open more than one source file.
         * Here we assume that the method will have only one source file
         */

        HRESULT hr = 0;
        const char * srcFileName = NULL;

        CompInfo * sym =  info.compCompHnd;

        //
        // @todo: this is gonna need to be ported to the
        // ISymUnmanagedReader API.
        //
#if 0
        mdSourceFile srcFileTok = sym->symLineInfo->GetLineSourceFile(0);

        if (srcFileTok != mdSourceFileNil)
            hr = sym->symDebugMeta->GetPropsOfSourceFile( srcFileTok,
                                                          &srcFileName);
#else
        hr = E_NOTIMPL;
#endif

        if (SUCCEEDED(hr))
        {
            jitSrcFileName = srcFileName;
            jitSrcFilePtr  = fopen(srcFileName, "r");
        }
        else
            jitSrcFileName = NULL;

        unsigned firstLine   = info.compLineNumTab[0].sldLineNum;
        unsigned nearestLine = compFindNearestLine(firstLine);

        // Advance (seek) file cursor to "nearestLine"

        compDspSrcLinesByLineNum(nearestLine, true);
    }

#endif
}

/*****************************************************************************/

void                 Compiler::compCompile(void * * methodCodePtr,
                                           void * * methodConsPtr,
                                           void * * methodDataPtr,
                                           void * * methodInfoPtr,
                                           SIZE_T * nativeSizeOfCode)
{
    /* Convert the IL opcodes in each basic block to a tree based intermediate representation */

    fgImport();

    // @TODO : We can allow ESP frames. Just need to reserve space for
    // pushing EBP if the method becomes an EBP-frame after an edit.

    if (opts.compDbgEnC)
    {
#if TGT_x86
        genFPreqd                       = true;
        opts.compDoubleAlignDisabled    = true;
#endif
    }

    /* We haven't allocated stack variables yet */

    lvaDoneFrameLayout = false;

    /* We have not encountered any "nested" calls */

#if TGT_RISC
    genNonLeaf         = false;
    genMaxCallArgs     = 0;
#endif

    /* Assume that we not fully interruptible and that
       we won't need a full-blown pointer register map */

    genInterruptible   = false;
    genFullPtrRegMap   = false;
#ifdef  DEBUG
    genIntrptibleUse   = false;
#endif

    if  (!opts.compMinOptim)
    {
        /* Hoist i++ / i-- operators out of expressions */

        fgHoistPostfixOps();
    }

    if  (!opts.compMinOptim && !opts.compDbgCode)
    {
#if OPTIMIZE_RECURSION
        optOptimizeRecursion();
#endif

        optOptimizeIncRng();
    }

    /* Massage the trees so that we can generate code out of them */

    fgMorph();

    /* Compute bbNums, bbRefs and bbPreds */

    fgAssignBBnums(true, true, true);

    if  (!opts.compMinOptim && !opts.compDbgCode)
    {
        /* Mainly compact any blocks that were introduced by the morpher
         * UNDONE - the morpher shouln't introduce unnecessary blocks */

        fgUpdateFlowGraph();
    }

    /* From this point on the flowgraph information such as bbNums,
     * bbRefs or bbPreds has to be kept updated */

    if  (!opts.compMinOptim && !opts.compDbgCode && opts.compFastCode)
    {
        /* Perform loop inversion (i.e. transform "while" loops into "repeat" loops)
         * and discover and classify natural loops (e.g. mark iterative loops as such) */

        optOptimizeLoops();

        /* Unroll loops */

        optUnrollLoops();

        /* Hoist invariant code out of loops */

        optHoistLoopCode();
    }
#ifdef  TGT_IA64
    else
    {
        optOptimizeLoops();
    }
#endif

    /* Create the variable table (and compute variable ref counts) */

    lvaMarkLocalVars();

    if  (!opts.compMinOptim && !opts.compDbgCode)
    {
        /* Optimize boolean conditions */

        optOptimizeBools();

        /* Optimize range checks based on loop info */

        optRemoveRangeChecks();
    }

    /* Figure out the order in which operators are to be evaluated */

    fgFindOperOrder();

    /* Compute temporary register needs, introduce any needed spills */

#if TGT_RISC && !TGT_IA64
    raPredictRegUse();
#endif

    /* Weave the tree lists */

    fgSetBlockOrder();

    /* At this point we know if we are fully interruptible or not */

#ifdef DEBUG
    fgDebugCheckLinks();
#endif

    if  (!opts.compMinOptim && !opts.compDbgCode)
    {
        /* Optimize array index range checks */

        optOptimizeIndexChecks();

        /* Remove common sub-expressions */
#if CSE
        optOptimizeCSEs();

        /* Copy and constant propagation */

        optCopyConstProp();

        /* update the flowgraph if we folded conditionals or empty basic blocks */

        if  (optConditionFolded || fgEmptyBlocks)
            fgUpdateFlowGraph();
#endif

    }

    // TODO: This is a hack to get around a GC tracking bug. for
    // tacked variables with finally clauses  This should definately
    // be removed after 2/1/00
    if (genInterruptible && info.compXcptnsCount > 0)
    {
        unsigned lclNum;
        for (lclNum = 0; lclNum < lvaCount; lclNum++)
        {
            LclVarDsc   * varDsc = &lvaTable[lclNum];
            if (varTypeIsGC(varDsc->TypeGet()))
                varDsc->lvTracked = 0;
        }
    }   // END HACK

    /* Figure out use/def info for all basic blocks */

    fgPerBlockDataFlow();

    /* Data flow: live variable analysis and range check availability */

    fgGlobalDataFlow();

#ifdef DEBUG
    fgDebugCheckBBlist();
    fgDebugCheckLinks();
#endif

    if  (!opts.compMinOptim && !opts.compDbgCode)
    {
        /* Perform loop code motion / worthless code removal */

#if CODE_MOTION
        optLoopCodeMotion();
#endif

        /* Adjust ref counts based on interference levels */

        lvaAdjustRefCnts();

        /* Are there are any potential array initializers? */

        optOptimizeArrayInits();
    }

#ifdef DEBUG
    fgDebugCheckBBlist();
#endif

    /* Enable this to gather statistical data such as
     * call and register argument info, flowgraph and loop info, etc. */

    //compJitStats();

    /* Assign registers to variables, etc. */

#if !   TGT_IA64
    raAssignVars();
#endif

#ifdef DEBUG
    fgDebugCheckLinks();
#endif

    /* Generate code */

    genGenerateCode(methodCodePtr,
                    methodConsPtr,
                    methodDataPtr,
                    methodInfoPtr,
                    nativeSizeOfCode);
}

/*****************************************************************************/

#if     REGVAR_CYCLES || TOTAL_CYCLES
#define CCNT_OVERHEAD32 13
unsigned GetCycleCount32 ();
#endif

/*****************************************************************************/

int FASTCALL  Compiler::compCompile(METHOD_HANDLE     methodHnd,
                                    SCOPE_HANDLE      classPtr,
                                    COMP_HANDLE       compHnd,
                                    const  BYTE *     bodyAddr,
                                    size_t            bodySize,
                                    SIZE_T *          nativeSizeOfCode,
                                    unsigned          lclCount,     // FIX remove
                                    unsigned          maxStack,
                                    JIT_METHOD_INFO*  methodInfo,
#ifndef NOT_JITC
                                    unsigned          EHcount,
                                    excepTable      * EHtable,
#endif
                                    BasicBlock      * BBlist,
                                    unsigned          BBcount,
                                    BasicBlock *    * hndBBtab,
                                    unsigned          hndBBcnt,
                                    void *          * methodCodePtr,
                                    void *          * methodConsPtr,
                                    void *          * methodDataPtr,
                                    void *          * methodInfoPtr,
                                    unsigned          compileFlags)
{
    int             result = ERRinternal;

//  if (s_compMethodsCount==0) setvbuf(stdout, NULL, _IONBF, 0);

#if TOTAL_CYCLES
    unsigned        cycleStart = GetCycleCount32();
#endif

    info.compMethodHnd   = methodHnd;
    info.compCompHnd     = compHnd;
    info.compMethodInfo  = methodInfo;

#ifdef  DEBUG
    info.compMethodName =eeGetMethodName(methodHnd, &info.compClassName);
    info.compFullName = eeGetMethodFullName(methodHnd);

    jitCurSource         = info.compFullName;

#if    !VERBOSE_SIZES
#if     JVC_COMPILING_MSG
#ifndef NOT_JITC
    printf("// Compiling method %s\n", info.compFullName);
#endif
#endif
#endif

#ifdef  UNDER_CE_GUI
    UpdateCompDlg(NULL, info.compMethodName);
#endif

#endif//DEBUG

    /* Setup an error trap */

#ifdef NOT_JITC
#ifdef DEBUG
    bool saveVerbose = verbose;
    bool saveDisAsm = disAsm;
#endif
#endif
/**
    if (compileFlags & CORJIT_FLG_BREAK)
    {
        assert(!"JitBreak reached");
//      BreakIfDebuggerPresent();
    }
***/

    setErrorTrap()  // ERROR TRAP: Start normal block
    {
        info.compCode        = bodyAddr;
        info.compCodeSize    = bodySize;

        compInitOptions(compileFlags);

        /* Initialize set a bunch of global values */

#if defined(LATE_DISASM) && defined(NOT_JITC)
        opts.compLateDisAsm  = (opts.eeFlags & CORJIT_FLG_LATE_DISASM) != 0;
        if (opts.compLateDisAsm)
            disOpenForLateDisAsm(info.compClassName, info.compMethodName);
#endif

#ifndef NOT_JITC
        info.compXcptnsCount = EHcount;

        static  unsigned classCnt = 0x10000000;
        info.compScopeHnd    = (SCOPE_HANDLE) classCnt++;

#else
        info.compScopeHnd    = classPtr;

        info.compXcptnsCount = methodInfo->EHcount;

#if GC_WRITE_BARRIER

        //ISSUE: initialize that only once (not for every method) !
        Compiler::s_gcWriteBarrierPtr = JITgetAdrOfGcPtrCur();
#endif

#endif // NOT_JITC

        info.compMaxStack       = maxStack;

#ifdef  DEBUG
        compCurBB               = 0;
        lvaTable                = 0;
#endif

        /* Initialize emitter */

#if!TGT_IA64
        genEmitter = (emitter*)compGetMem(roundUp(sizeof(*genEmitter)));
        genEmitter->emitBegCG(this, compHnd);
#endif

        info.compFlags          = eeGetMethodAttribs(info.compMethodHnd);

        info.compIsStatic       = (info.compFlags & FLG_STATIC) != 0;

        info.compIsVarArgs      = methodInfo->args.isVarArg();

        /* get the arg count and our declared return type */

        info.compRetType        = JITtype2varType(methodInfo->args.retType);
        info.compArgsCount      = methodInfo->args.numArgs;

        if (!info.compIsStatic)     // count the 'this' poitner in the arg count
            info.compArgsCount++;

        info.compRetBuffArg = -1;       // indicates not present

        if (methodInfo->args.hasRetBuffArg())
        {
            info.compRetBuffArg = info.compIsStatic?0:1;
            info.compArgsCount++;
        }

        /* there is a 'hidden' cookie pushed last when the calling convention is varargs */

        if (info.compIsVarArgs)
            info.compArgsCount++;

        lvaCount                =
        info.compLocalsCount    = info.compArgsCount + methodInfo->locals.numArgs;

#if INLINE_NDIRECT
        info.compCallUnmanaged  = 0;
#endif

        lvaScratchMem           = 0;
        info.compInitMem        = (methodInfo->options & JIT_OPT_INIT_LOCALS) != 0;

        info.compStrictExceptions = true; /* @ToDo: This is always true for now */

#if!TGT_IA64    // crashes for some reason
        compInitDebuggingInfo();
#else
        info.compStmtOffsetsCount = 0;
#endif

        /* Allocate the local variable table */

        lvaInitTypeRef();

        if  (BBlist)
        {
            fgFirstBB   = BBlist;
            fgLastBB    = 0;
            fgBBcount   = BBcount;

            assert(!"need to convert EH table to new format");

//          compHndBBtab = hndBBtab;
            info.compXcptnsCount = hndBBcnt;
        }
        else
        {
            fgFindBasicBlocks();
        }

        /* Give the function a unique number */

#ifdef  DEBUG
        s_compMethodsCount++;
#endif

#if COUNT_BASIC_BLOCKS
    bbCntTable.histoRec(fgBBcount, 1);

    if (fgBBcount == 1)
        bbOneBBSizeTable.histoRec(bodySize, 1);
#endif

#if INLINER_STATS
    /* Check to see if the method is eligible for inlining */

    if (fgBBcount == 1)
    {
        assert(!info.compXcptnsCount);

        if (info.compFlags & FLG_SYNCH)
            synchMethCnt++;
        else if (!strcmp(info.compMethodName, COR_CCTOR_METHOD_NAME))
            clinitMethCnt++;
        else
        {
            if (!strcmp(info.compMethodName, COR_CTOR_METHOD_NAME))
            {
                bbInitTable.histoRec(bodySize, 1);
                bbInlineTable.histoRec(bodySize, 1);
            }
            else if (info.compIsStatic)
            {
                if (strcmp(info.compMethodName, "main"))
                {
                    bbStaticTable.histoRec(bodySize, 1);
                    bbInlineTable.histoRec(bodySize, 1);
                }
            }
        }
    }
#endif



#ifdef  DEBUG
        if  (verbose)
        {
            printf("Basic block list for '%s'\n", info.compFullName);
            fgDispBasicBlocks();
        }
#endif

        compCompile(methodCodePtr,
                    methodConsPtr,
                    methodDataPtr,
                    methodInfoPtr,
                    nativeSizeOfCode);

        /* Success! */

        result = 0;
    }
    finallyErrorTrap()  // ERROR TRAP: The following block handles errors
    {
        /* Cleanup  */

        /* Tell the emitter/scheduler that we're done with this function */

#if!TGT_IA64
        genEmitter->emitEndCG();
#endif

#if MEASURE_MEM_ALLOC
        if  (genMemStats.loLvlBigSz < allocator.nraTotalSizeUsed())
        {
            genMemStats.loLvlBigSz = allocator.nraTotalSizeUsed();
            strcpy(genMemStats.loLvlBigNm, info.compClassName);
            strcat(genMemStats.loLvlBigNm, ".");
            strcat(genMemStats.loLvlBigNm, info.compMethodName);

            //       printf("Largest method   alloc: %9u %s\n", genMemStats.loLvlBigSz, genMemStats.loLvlBigNm);
        }

        size_t  genMemLLendUsed  = allocator.nraTotalSizeUsed();
        size_t  genMemLLendAlloc = allocator.nraTotalSizeAlloc();

        //  assert(genMemLLendAlloc >= genMemLLendUsed);

        genMemStats.loLvlUsed  += genMemLLendUsed;
        genMemStats.loLvlAlloc += genMemLLendAlloc;
        genMemStats.loLvlAllh  += genMemLLendAlloc;
#endif

#if defined(DEBUG) || MEASURE_MEM_ALLOC || MEASURE_NODE_SIZE || MEASURE_BLOCK_SIZE || DISPLAY_SIZES
        genMethodCnt++;
#endif

#if TOTAL_CYCLES
        jitTotalCycles += GetCycleCount32() - cycleStart - CCNT_OVERHEAD32;
#endif

#ifdef NOT_JITC
#ifdef DEBUG
        SET_OPTS(saveVerbose);
        disAsm = saveDisAsm;
#endif
#endif
        compDone();
    }
    endErrorTrap()  // ERROR TRAP: End

    return  result;
}



#if defined(LATE_DISASM)

void            ProcInitDisAsm(void * ptr, unsigned codeSize)
{
    assert(ptr);
    Compiler * _this = (Compiler *) ptr;

    /* We have to allocate the jump target vector
     * because the scheduler might call DisasmBuffer */

    _this->genDisAsm.disJumpTarget =
                                (BYTE *)_this->compGetMem(roundUp(codeSize));
    memset(_this->genDisAsm.disJumpTarget, 0, roundUp(codeSize));

}

#endif

/*****************************************************************************/
#ifdef DEBUGGING_SUPPORT
/*****************************************************************************/


static
int __cdecl         genCmpLocalVarLifeBeg(const void * elem1, const void * elem2)
{
    return (*((Compiler::LocalVarDsc**) elem1))->lvdLifeBeg -
           (*((Compiler::LocalVarDsc**) elem2))->lvdLifeBeg;
}

static
int __cdecl         genCmpLocalVarLifeEnd(const void * elem1, const void * elem2)
{
    return (*((Compiler::LocalVarDsc**) elem1))->lvdLifeEnd -
           (*((Compiler::LocalVarDsc**) elem2))->lvdLifeEnd;
}

inline
void            Compiler::compInitScopeLists()
{
    assert (info.compLocalVarsCount);

    unsigned i;

    // Populate the 'compEnterScopeList' and 'compExitScopeList' lists

    compEnterScopeList =
        (LocalVarDsc**)
        compGetMem(info.compLocalVarsCount*sizeof(*compEnterScopeList));
    compExitScopeList =
        (LocalVarDsc**)
        compGetMem(info.compLocalVarsCount*sizeof(*compEnterScopeList));

    for (i=0; i<info.compLocalVarsCount; i++)
    {
        compEnterScopeList[i] = compExitScopeList[i] = & info.compLocalVars[i];
    }

    qsort(compEnterScopeList, info.compLocalVarsCount, sizeof(*compEnterScopeList), genCmpLocalVarLifeBeg);
    qsort(compExitScopeList,  info.compLocalVarsCount, sizeof(*compExitScopeList),  genCmpLocalVarLifeEnd);

}

void            Compiler::compResetScopeLists()
{
    assert (compEnterScopeList && compExitScopeList);

    compNextEnterScope = compNextExitScope =0;
}


Compiler::LocalVarDsc *   Compiler::compGetNextEnterScope(unsigned  offs,
                                                          bool      scan)
{
    assert (info.compLocalVarsCount);
    assert (compEnterScopeList && compExitScopeList);

    if (compNextEnterScope < info.compLocalVarsCount)
    {
        assert (compEnterScopeList[compNextEnterScope]);
        unsigned nextEnterOff = compEnterScopeList[compNextEnterScope]->lvdLifeBeg;
        assert (scan || (offs <= nextEnterOff));

        if (!scan)
        {
            if (offs == nextEnterOff)
            {
                return compEnterScopeList[compNextEnterScope++];
            }
        }
        else
        {
            if (nextEnterOff <= offs)
            {
                return compEnterScopeList[compNextEnterScope++];
            }
        }
    }

    return NULL;
}


Compiler::LocalVarDsc *   Compiler::compGetNextExitScope(unsigned   offs,
                                                         bool       scan)
{
    assert (info.compLocalVarsCount);
    assert (compEnterScopeList && compExitScopeList);

    if (compNextExitScope < info.compLocalVarsCount)
    {
        assert (compExitScopeList[compNextExitScope]);
        unsigned nextExitOffs = compExitScopeList[compNextExitScope]->lvdLifeEnd;

        assert (scan || (offs <= nextExitOffs));

        if (!scan)
        {
            if (offs == nextExitOffs)
            {
                return compExitScopeList[compNextExitScope++];
            }
        }
        else
        {
            if (nextExitOffs <= offs)
            {
                return compExitScopeList[compNextExitScope++];
            }
        }
    }

    return NULL;
}


// The function will call the callback functions for scopes with boundaries
// at IL opcodes from the current status of the scope lists to 'offset',
// ordered by IL offsets.

void        Compiler::compProcessScopesUntil (unsigned     offset,
                                   void (*enterScopeFn)(LocalVarDsc *, unsigned),
                                   void (*exitScopeFn) (LocalVarDsc *, unsigned),
                                   unsigned     clientData)
{
    bool            foundExit = false, foundEnter = true;
    LocalVarDsc *   scope;
    LocalVarDsc *   nextExitScope = NULL, * nextEnterScope = NULL;
    unsigned        offs = offset, curEnterOffs = 0;

    goto START_FINDING_SCOPES;

    // We need to determine the scopes which are open for the current block.
    // This loop walks over the missing blocks between the current and the
    // previous block, keeping the enter and exit offsets in lockstep.

    do
    {
        foundExit = foundEnter = false;

        if (nextExitScope)
        {
            exitScopeFn (nextExitScope, clientData);
            nextExitScope   = NULL;
            foundExit       = true;
        }

        offs = nextEnterScope ? nextEnterScope->lvdLifeBeg : offset;

        while (scope = compGetNextExitScope(offs, true))
        {
            foundExit = true;

            if (!nextEnterScope || scope->lvdLifeEnd > nextEnterScope->lvdLifeBeg)
            {
                // We overshot the last found Enter scope. Save the scope for later
                // and find an entering scope

                nextExitScope = scope;
                break;
            }

            exitScopeFn (scope, clientData);
        }


        if (nextEnterScope)
        {
            enterScopeFn (nextEnterScope, clientData);
            curEnterOffs    = nextEnterScope->lvdLifeBeg;
            nextEnterScope  = NULL;
            foundEnter      = true;
        }

        offs = nextExitScope ? nextExitScope->lvdLifeEnd : offset;

START_FINDING_SCOPES :

        while (scope = compGetNextEnterScope(offs, true))
        {
            foundEnter = true;

            if (  (nextExitScope  && scope->lvdLifeBeg >= nextExitScope->lvdLifeEnd)
               || (scope->lvdLifeBeg > curEnterOffs) )
            {
                // We overshot the last found exit scope. Save the scope for later
                // and find an exiting scope

                nextEnterScope = scope;
                break;
            }

            enterScopeFn (scope, clientData);

            if (!nextExitScope)
            {
                curEnterOffs = scope->lvdLifeBeg;
            }
        }
    }
    while (foundExit || foundEnter);
}



/*****************************************************************************/
#endif // DEBUGGING_SUPPORT
/*****************************************************************************/
#ifdef NOT_JITC
/*****************************************************************************/

// Compile a single method

int FASTCALL  jitNativeCode ( METHOD_HANDLE     methodHnd,
                              SCOPE_HANDLE      classPtr,
                              COMP_HANDLE       compHnd,
                              const  BYTE *     bodyAddr,
                              size_t            bodySize,
                              unsigned          lclCount,
                              unsigned          maxStack,
                              JIT_METHOD_INFO*  methodInfo,
                              void *          * methodCodePtr,
                              SIZE_T *          nativeSizeOfCode,
                              void *          * methodConsPtr,
                              void *          * methodDataPtr,
                              void *          * methodInfoPtr,
                              unsigned          compileFlags
                              )
{
    int                 result = ERRinternal;

    norls_allocator *   pAlloc;
    norls_allocator *   pTheAllocator = nraGetTheAllocator();
    norls_allocator     alloc;

    // Can we use the pre-inited allocator ?

    if (pTheAllocator)
    {
        pAlloc = pTheAllocator;
    }
    else
    {
        bool res = alloc.nraInit();
        if  (res) return JIT_REFUSED;

        pAlloc = &alloc;
    }

    setErrorTrap()
    {

        setErrorTrap()
        {
            // Allocate an instance of Compiler and initialize it

            Compiler * pComp = (Compiler *)pAlloc->nraAlloc(roundUp(sizeof(*pComp)));
            pComp->compInit(pAlloc);

            // Now generate the code

            result = pComp->compCompile(methodHnd,
                                        classPtr,
                                        compHnd,
                                        bodyAddr,
                                        bodySize,
                                        nativeSizeOfCode,
                                        lclCount,
                                        maxStack,
                                        methodInfo,
                                        0,
                                        0,
                                        0,
                                        0,
                                        methodCodePtr,
                                        methodConsPtr,
                                        methodDataPtr,
                                        methodInfoPtr,
                                        compileFlags);

        }
        finallyErrorTrap()
        {
            // Now free up whichever allocator we were using
            if (pTheAllocator)
            {
                nraFreeTheAllocator();
            }
            else
            {
                alloc.nraFree();
            }
        }
        endErrorTrap()
    }
    impJitErrorTrap()
    {
        result = __errc;
    }

    endErrorTrap()
    return result;
}

/*****************************************************************************/
#endif // NOT_JITC
/*****************************************************************************/


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          jvc                                              XX
XX                                                                           XX
XX  Functions for the stand-alone version of the JIT .                       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************/
#ifndef NOT_JITC
/*****************************************************************************/

var_types      ImageTypeToVarType(BYTE type)
{
    switch(type)
    {
    case IMAGE_CEE_CS_VOID:         return TYP_VOID;
    case IMAGE_CEE_CS_I4:           return TYP_INT;
    case IMAGE_CEE_CS_I8:           return TYP_LONG;
    case IMAGE_CEE_CS_R4:           return TYP_FLOAT;
    case IMAGE_CEE_CS_R8:           return TYP_DOUBLE;

     /* @TODO : assumes "i" is a byref ptr. Safe as long as VC uses i4's
        for pointers. Same assumption made for importing of ldarg.i
        */
    case IMAGE_CEE_CS_PTR:          return TYP_BYREF;

    case IMAGE_CEE_CS_OBJECT:       return TYP_REF;

    case IMAGE_CEE_CS_BYVALUE:
    case IMAGE_CEE_CS_STRUCT4:
    case IMAGE_CEE_CS_STRUCT32:     return TYP_STRUCT;

    case IMAGE_CEE_CS_END:
    default :                       assert(!"Unknown type"); return TYP_VOID;
    }
}

var_types   CorTypeToVarType(CorElementType type)
{
    switch(type)
    {
    case ELEMENT_TYPE_VOID:         return TYP_VOID;
    case ELEMENT_TYPE_BOOLEAN:      return TYP_BOOL;
    case ELEMENT_TYPE_CHAR:         return TYP_CHAR;
    case ELEMENT_TYPE_I1:           return TYP_BYTE;
    case ELEMENT_TYPE_U1:           return TYP_UBYTE;
    case ELEMENT_TYPE_I2:           return TYP_SHORT;
    case ELEMENT_TYPE_U2:           return TYP_CHAR;
    case ELEMENT_TYPE_I4:           return TYP_INT;
    case ELEMENT_TYPE_U4:           return TYP_UINT;
    case ELEMENT_TYPE_I8:           return TYP_LONG;
    case ELEMENT_TYPE_U8:           return TYP_ULONG;
    case ELEMENT_TYPE_R4:           return TYP_FLOAT;
    case ELEMENT_TYPE_R8:           return TYP_DOUBLE;
    case ELEMENT_TYPE_PTR:          return TYP_I_IMPL;
    case ELEMENT_TYPE_STRING:
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_SZARRAY:
    case ELEMENT_TYPE_ARRAY:        return TYP_REF;
    case ELEMENT_TYPE_BYREF:        return TYP_BYREF;
    case ELEMENT_TYPE_VALUETYPE:    return TYP_STRUCT;
    case ELEMENT_TYPE_TYPEDBYREF:       return TYP_STRUCT;
    case ELEMENT_TYPE_I:            return TYP_I_IMPL;
    case ELEMENT_TYPE_U:            return TYP_UINT; /* CONSIDER: do we need an u_impl?*/
    case ELEMENT_TYPE_R:            return TYP_DOUBLE;

    case ELEMENT_TYPE_END:

    case ELEMENT_TYPE_MAX:
    default: assert(!"Bad type");   return TYP_VOID;
    }
}

/*****************************************************************************/
#endif  // NOT_JITC
/*****************************************************************************/
void                codeGeneratorCodeSizeBeg(){}
/*****************************************************************************/
#if     REGVAR_CYCLES || TOTAL_CYCLES
#pragma warning( disable : 4035 )       // turn off "no return value" warning

__inline unsigned GetCycleCount32 ()    // enough for about 40 seconds
{
    __asm   push    EDX
    __asm   _emit   0x0F
    __asm   _emit   0x31    /* rdtsc */
    __asm   pop     EDX
    // return EAX       implied return causes annoying warning
};

#pragma warning( default : 4035 )
#endif

/*****************************************************************************
 *
 *  If any temporary tables are smaller than 'genMinSize2free' we won't bother
 *  freeing them.
 */

const
size_t              genMinSize2free = 64;

/*****************************************************************************/

#if COUNT_OPCODES

struct  opcCnt
{
    unsigned            ocNum;
    unsigned            ocCnt;
};

static
opcCnt              genOpcodeCnt[OP_Count];

static
int __cdecl         genOpcCntCmp(const void *op1, const void *op2)
{
    int             dif;

    dif = ((opcCnt *)op2)->ocCnt -
          ((opcCnt *)op1)->ocCnt;

    if  (dif) return dif;

    dif = ((opcCnt *)op1)->ocNum -
          ((opcCnt *)op2)->ocNum;

    return dif;
}

#endif



/*****************************************************************************
 *
 *  Used for counting pointer assignments.
 */

#if GEN_COUNT_PTRASG
unsigned            ptrAsgCount;
#endif

/*****************************************************************************/
#ifndef NOT_JITC
/*****************************************************************************
 *
 *  The following logic handles memory allocation.
 */

#if MEASURE_MEM_ALLOC

struct CMemAllocStats
{
    unsigned            allocCnt;
    size_t              allocSiz;
    size_t              loLvlUsed;
    size_t              loLvlAlloc;
    size_t              loLvlBigSz;
    char                loLvlBigNm[1024];

    size_t              loLvlAllh;
    static unsigned     s_loLvlStab[];
};

/* static */
unsigned            CMemAllocStats::CMemAllocStats::s_loLvlStab[] =
                            {   2000,  3000,  4000,  5000,  6000, 8000,
                               12000, 16000, 20000, 26000, 32000,    0
                            };

static CMemAllocStats   genMemStats;

static
histo                   genMemLoLvlHist(CMemAllocStats::s_loLvlStab);

#endif

/*****************************************************************************
 *
 *  Allocate and initialize a tree node.
 */

#if     MEASURE_NODE_SIZE

struct CNodeSizeStats
{
    size_t                  genTreeNodeSize;
    size_t                  genTreeNodeCnt;

#if     MEASURE_NODE_HIST
    static const unsigned   genTreeNodeNtab[];
    static const unsigned   genTreeNodeStab[];
#endif

};


#if     MEASURE_NODE_HIST

/* static */
const unsigned      CNodeSizeStats::genTreeNodeNtab[] =
                                { 1, 5, 10, 20, 50, 75, 100, 200, 0 };
/* static */
const unsigned      CNodeSizeStats::genTreeNodeStab[] =
                                { 200, 500, 1000, 2000, 3000, 4000, 10000, 0 };

static histo        genTreeNcntHist(CNodeSizeStats::genTreeNodeNtab);

static histo        genTreeNsizHist(CNodeSizeStats::genTreeNodeStab);

#endif


static CNodeSizeStats genNodeSizeStats;

#endif // MEASURE_NODE_SIZE

/*****************************************************************************/
#endif  // NOT_JITC
/*****************************************************************************/
void                codeGeneratorCodeSizeEnd(){}
/*****************************************************************************
 *
 *  The following structure describes a single global variable.
 */

struct JIT_CG_Global
{
    void *              addr;
    size_t              size;
};

/*****************************************************************************
 *
 *  Declaration of global variables.
 *
 */

#define DeclareGlobal(name) { &name, sizeof(name) }

/*****************************************************************************
 *
 *  Declare all global variables that need to be preserved across
 *
 */
struct JIT_CG_Global genGlobals[] =
{
    NULL, 0,

    // SHRI : These dont seem to be per method. So why are they here?

#if DISPLAY_SIZES
    DeclareGlobal(grossVMsize),
    DeclareGlobal(grossNCsize),
    DeclareGlobal(totalNCsize),
#endif

#ifndef NOT_JITC
#ifdef  DEBUG
    DeclareGlobal(genMethodList),
    DeclareGlobal(jitCurSrcLine),
    DeclareGlobal(jitSrcFileName),
    DeclareGlobal(jitSrcFilePtr),
#endif
#if     TOTAL_CYCLES
    DeclareGlobal(jitTotalCycles),
#endif
#endif
};


/*****************************************************************************
 *
 *  Gather statistics - mainly used for the standalone
 *  Enable various #ifdef's to get the information you need
 */

void            Compiler::compJitStats()
{
#if CALL_ARG_STATS

    /* Method types and argument statistics */
    compCallArgStats();
#endif
}

#if CALL_ARG_STATS

/*****************************************************************************
 *
 *  Gather statistics about method calls and arguments
 */

void            Compiler::compCallArgStats()
{
    GenTreePtr      args;
    GenTreePtr      argx;

    BasicBlock  *   block;
    GenTreePtr      stmt;
    GenTreePtr      call;

    unsigned        argNum;

    unsigned        argDWordNum;
    unsigned        argLngNum;
    unsigned        argFltNum;
    unsigned        argDblNum;

    unsigned        regArgNum;
    unsigned        regArgDeffered;
    unsigned        regArgTemp;

    unsigned        regArgLclVar;
    unsigned        regArgConst;

    unsigned        argTempsThisMethod = 0;

#if !USE_FASTCALL
    assert(!"Must enable fastcall!");
#endif

    assert(fgStmtListThreaded);

    for (block = fgFirstBB; block; block = block->bbNext)
    {
        for (stmt = block->bbTreeList; stmt; stmt = stmt->gtNext)
        {
            assert(stmt->gtOper == GT_STMT);

            for (call = stmt->gtStmt.gtStmtList; call; call = call->gtNext)
            {

                if  (call->gtOper != GT_CALL)
                    continue;

                argNum      =

                regArgNum   =
                regArgDeffered =
                regArgTemp  =

                regArgConst =
                regArgLclVar=

                argDWordNum =
                argLngNum   =
                argFltNum   =
                argDblNum   = 0;

                argTotalCalls++;

                if (!call->gtCall.gtCallObjp)
                {
                    if  (call->gtCall.gtCallType == CT_HELPER)
                        argHelperCalls++;
                    else
                        argStaticCalls++;
                }
                else
                {
                    /* We have a 'this' pointer */

                    argDWordNum++;
                    argNum++;
                    regArgNum++;
                    regArgDeffered++;
                    argTotalObjPtr++;

                    if (call->gtFlags & (GTF_CALL_VIRT|GTF_CALL_INTF|GTF_CALL_VIRT_RES))
                    {
                        /* virtual function */
                        argVirtualCalls++;
                    }
                    else
                    {
                        argNonVirtualCalls++;
                    }
                }

                /* Gather arguments information */

                for (args = call->gtCall.gtCallArgs; args; args = args->gtOp.gtOp2)
                {
                    argx = args->gtOp.gtOp1;

                    argNum++;

                    switch(genActualType(argx->TypeGet()))
                    {
                    case TYP_INT:
                    case TYP_REF:
                    case TYP_BYREF:
                        argDWordNum++;
                        break;

                    case TYP_LONG:
                        argLngNum++;
                        break;

                    case TYP_FLOAT:
                        argFltNum++;
                        break;

                    case TYP_DOUBLE:
                        argDblNum++;
                        break;
#if USE_FASTCALL
                    case TYP_VOID:
                        /* This is a deffered register argument */
                        assert(argx->gtOper == GT_NOP);
                        assert(argx->gtFlags & GTF_REG_ARG);
                        argDWordNum++;
                        break;
#endif
                    }

#if USE_FASTCALL
                    /* Is this argument a register argument? */

                    if  (argx->gtFlags & GTF_REG_ARG)
                    {
                        regArgNum++;

                        /* We either have a defered argument or a temp */

                        if  (argx->gtOper == GT_NOP)
                            regArgDeffered++;
                        else
                        {
                            assert(argx->gtOper == GT_ASG);
                            regArgTemp++;
                        }
                    }
#endif
                }

#if USE_FASTCALL
                /* Look at the register arguments and count how many constants, local vars */

                for (args = call->gtCall.gtCallRegArgs; args; args = args->gtOp.gtOp2)
                {
                    argx = args->gtOp.gtOp1;

                    switch(argx->gtOper)
                    {
                    case GT_CNS_INT:
                        regArgConst++;
                        break;

                    case GT_LCL_VAR:
                        regArgLclVar++;
                        break;
                    }
                }
#endif
                assert(argNum == argDWordNum + argLngNum + argFltNum + argDblNum);
                assert(regArgNum == regArgDeffered + regArgTemp);

                argTotalArgs      += argNum;
                argTotalRegArgs   += regArgNum;

                argTotalDWordArgs += argDWordNum;
                argTotalLongArgs  += argLngNum;
                argTotalFloatArgs += argFltNum;
                argTotalDoubleArgs+= argDblNum;

                argTotalDeffered  += regArgDeffered;
                argTotalTemps     += regArgTemp;
                argTotalConst     += regArgConst;
                argTotalLclVar    += regArgLclVar;

                argTempsThisMethod+= regArgTemp;

                argCntTable.histoRec(argNum, 1);
                argDWordCntTable.histoRec(argDWordNum, 1);
                argDWordLngCntTable.histoRec(argDWordNum + 2*argLngNum, 1);
            }
        }
    }

    argTempsCntTable.histoRec(argTempsThisMethod, 1);

    if (argMaxTempsPerMethod < argTempsThisMethod)
        argMaxTempsPerMethod = argTempsThisMethod;
    if (argTempsThisMethod > 10)
        printf("Function has %d temps\n", argTempsThisMethod);
}


void            Compiler::compDispCallArgStats()
{
    if (argTotalCalls == 0) return;

    printf("--------------------------------------------------\n");
    printf("Total # of calls = %d, calls / method = %.3f\n\n", argTotalCalls, (float) argTotalCalls / genMethodCnt);

    printf("Percentage of      helper calls = %4.2f %%\n", (float)(100 * argHelperCalls) / argTotalCalls);
    printf("Percentage of      static calls = %4.2f %%\n", (float)(100 * argStaticCalls) / argTotalCalls);
    printf("Percentage of     virtual calls = %4.2f %%\n", (float)(100 * argVirtualCalls) / argTotalCalls);
    printf("Percentage of non-virtual calls = %4.2f %%\n\n", (float)(100 * argNonVirtualCalls) / argTotalCalls);

    printf("Average # of arguments per call = %.2f%\n\n", (float) argTotalArgs / argTotalCalls);

    printf("Percentage of DWORD  arguments   = %.2f %%\n", (float)(100 * argTotalDWordArgs) / argTotalArgs);
    printf("Percentage of LONG   arguments   = %.2f %%\n", (float)(100 * argTotalLongArgs) / argTotalArgs);
    printf("Percentage of FLOAT  arguments   = %.2f %%\n", (float)(100 * argTotalFloatArgs) / argTotalArgs);
    printf("Percentage of DOUBLE arguments   = %.2f %%\n\n", (float)(100 * argTotalDoubleArgs) / argTotalArgs);

    if (argTotalRegArgs == 0) return;

/*
    printf("Total deffered arguments     = %d \n", argTotalDeffered);

    printf("Total temp arguments         = %d \n\n", argTotalTemps);

    printf("Total 'this' arguments       = %d \n", argTotalObjPtr);
    printf("Total local var arguments    = %d \n", argTotalLclVar);
    printf("Total constant arguments     = %d \n\n", argTotalConst);
*/

    printf("\nRegister Arguments:\n\n");

    printf("Percentage of defered arguments  = %.2f %%\n",   (float)(100 * argTotalDeffered) / argTotalRegArgs);
    printf("Percentage of temp arguments     = %.2f %%\n\n", (float)(100 * argTotalTemps)    / argTotalRegArgs);

    printf("Maximum # of temps per method    = %d\n\n", argMaxTempsPerMethod);

    printf("Percentage of ObjPtr arguments   = %.2f %%\n",   (float)(100 * argTotalObjPtr) / argTotalRegArgs);
    //printf("Percentage of global arguments   = %.2f %%\n", (float)(100 * argTotalDWordGlobEf) / argTotalRegArgs);
    printf("Percentage of constant arguments = %.2f %%\n",   (float)(100 * argTotalConst) / argTotalRegArgs);
    printf("Percentage of lcl var arguments  = %.2f %%\n\n", (float)(100 * argTotalLclVar) / argTotalRegArgs);

    printf("--------------------------------------------------\n");
    printf("Argument count frequency table (includes ObjPtr):\n");
    printf("--------------------------------------------------\n");
    argCntTable.histoDsp();
    printf("--------------------------------------------------\n");

    printf("--------------------------------------------------\n");
    printf("DWORD argument count frequency table (w/o LONG):\n");
    printf("--------------------------------------------------\n");
    argDWordCntTable.histoDsp();
    printf("--------------------------------------------------\n");

    printf("--------------------------------------------------\n");
    printf("Temps count frequency table (per method):\n");
    printf("--------------------------------------------------\n");
    argTempsCntTable.histoDsp();
    printf("--------------------------------------------------\n");

/*
    printf("--------------------------------------------------\n");
    printf("DWORD argument count frequency table (w/ LONG):\n");
    printf("--------------------------------------------------\n");
    argDWordLngCntTable.histoDsp();
    printf("--------------------------------------------------\n");
*/
}

#endif // CALL_ARG_STATS

/*****************************************************************************/
#ifndef NOT_JITC
/*****************************************************************************
 *
 *  Start up the code generator - called once before anything is compiled.
 */

void       FASTCALL jitStartup()
{
    // Initialize COM

    CoInitialize(NULL);

    Compiler::compStartup();
}

/*****************************************************************************
 *
 *  Shut down the code generator - called once just before exiting the process.
 */

void       FASTCALL jitShutdown()
{
    Compiler::compShutdown();

    CoUninitialize();
}

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\compiler.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                    Inline functions                                       XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#ifndef _COMPILER_HPP_
#define _COMPILER_HPP_

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX  Miscellaneous utility functions. Some of these are defined in Utils.cpp  XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************
 *
 *  getEERegistryValue - finds a value entry of type DWORD in the EE registry key.
 *  Return the value if entry exists, else return default value.
 *
 *        valueName  - Value to look up
 *        defaultVal - name says it all
 */

DWORD               getEERegistryDWORD  (const TCHAR *  valueName,
                                         DWORD          defaultVal);

/*****************************************************************************
 *  Puts the string value in buf[].
 *  Returns true on success, false on failure
 */

bool                getEERegistryString(const TCHAR *  valueName,
                                        TCHAR *        buf,        /* OUT */
                                        unsigned       bufSize);

bool                getEERegistryMethod(const TCHAR * valueName,
                                        TCHAR * methodBuf, size_t methodBufSize,
                                        TCHAR * classBuf,  size_t classBufSize);

bool                cmpEERegistryMethod(const TCHAR * regMethod, const TCHAR * regClass,
                                        const TCHAR * curMethod, const TCHAR * curClass);

/*****************************************************************************/
#ifdef NOT_JITC
/*****************************************************************************/

bool                IsNameInProfile    (const TCHAR *   methodName,
                                        const TCHAR *    className,
                                        const TCHAR *    regKeyName);

inline
bool                excludeInlineMethod(const TCHAR *   methodName,
                                        const TCHAR *    className)
{
    return IsNameInProfile(methodName, className, "JITexcludeInline");
}

inline
bool                includeInlineMethod(const TCHAR *   methodName,
                                        const TCHAR *    className)
{
    return IsNameInProfile(methodName, className, "JITincludeInline");
}

inline
bool                getNoInlineOverride()
{
    static bool     initialized = false;
    static bool     genNoInline;

    if  (!initialized)
    {
        genNoInline = ((getEERegistryDWORD(TEXT("JITnoInline"), 0) != 0) ? true : false);
        initialized = true;
    }

    return genNoInline;
}

inline
unsigned             getInlineSize()
{
    static bool         initialized = false;
    static unsigned     inlineSize;

    if  (!initialized)
    {
        inlineSize = getEERegistryDWORD(TEXT("JITInlineSize"), 0);

        if (!inlineSize)
            inlineSize = 32;
        else if (inlineSize > 256)
            inlineSize = 256;

        initialized = true;
    }

    return inlineSize;
}


inline
bool                getStringLiteralOverride()
{
    static bool     initialized = false;
    static bool     genNoStringObj;

    if  (!initialized)
    {
        genNoStringObj = ((getEERegistryDWORD(TEXT("JITnoStringObj"), 0) == 0) ? true : false);
        initialized = true;
    }

    return genNoStringObj;
}

inline
bool                getNoSchedOverride()
{
    static bool     initialized = false;
    static bool     genNoSched;

    if  (!initialized)
    {
        genNoSched = ((getEERegistryDWORD(TEXT("JITnoSched"), 0) != 0) ? true : false);
        initialized = true;
    }

    return genNoSched;
}

inline
bool                getInlineNDirectEnabled()
{
    static bool     initialized = false;
    static bool     genInlineNDir;

    if  (!initialized)
    {
        genInlineNDir = getEERegistryDWORD(TEXT("JITInlineNDirect"), 0) != 0;
        initialized = true;
    }

    return genInlineNDir;
}

inline
bool                getNewCallInterface()
{
/*** We are letting the old style bit rot,but leaving it around JUST in case
     we run into a snag with the new form (we ran into one already).
     Should be able to get rid of this by 11/99 - vancem

    static bool     initialized = false;
    static bool     genNewCallInterface;

    if  (!initialized)
    {
        // default to the new interface invoke
        genNewCallInterface = getEERegistryDWORD(TEXT("InterfaceInvoke"), 1) != 0;
        initialized = true;
    }

    return genNewCallInterface;
***/
    return true;
}


inline
DWORD               getRoundFloatLevel()
{
    static bool     initialized = false;
    static DWORD    genFloatLevel;

    if  (!initialized)
    {
        genFloatLevel = getEERegistryDWORD(TEXT("RoundFloat"), 2);
        initialized = true;
    }

    return genFloatLevel;
}

inline
bool                getContextEnabled()
{
    static bool     initialized = false;
    static bool     genContextEnabled;

    if  (!initialized)
    {
        genContextEnabled = getEERegistryDWORD(TEXT("JITContext"), 0) != 0;
        initialized = true;
    }

    return genContextEnabled;
}

/*****************************************************************************/
#else //NOT_JITC==0
/*****************************************************************************/

inline
DWORD               getRoundFloatLevel()
{
    static bool     initialized = false;
    static DWORD    genFloatLevel;

    if  (!initialized)
    {
#ifdef _WIN32_WCE
        genFloatLevel = 2;  // getenv() not available?????
#else
        genFloatLevel = getenv("ROUNDFLOAT") ? atoi(getenv("ROUNDFLOAT")) : 2;
#endif
        initialized   = true;
    }

    return genFloatLevel;
}

inline
bool                getInlineNDirectEnabled()
{
    return true;
}

inline
bool                getNewCallInterface()
{
    return true;
}

inline
bool                getContextEnabled()
{
    return true;
}

/*****************************************************************************/
#endif//NOT_JITC
/*****************************************************************************
 *
 *  Return the lowest bit that is set in the given 64-bit number.
 */

inline
unsigned __int64    genFindLowestBit(unsigned __int64 value)
{
    return (value & -value);
}

/*****************************************************************************
 *
 *  Return the lowest bit that is set in the given 32-bit number.
 */

inline
unsigned            genFindLowestBit(unsigned  value)
{
    return (value & -value);
}

/*****************************************************************************
 *
 *  Return true if the given 64-bit value has exactly zero or one bits set.
 */

inline
BOOL                genOneBitOnly(unsigned __int64 value)
{
    return  (genFindLowestBit(value) == value);
}

/*****************************************************************************
 *
 *  Return true if the given 32-bit value has exactly zero or one bits set.
 */

inline
BOOL                genOneBitOnly(unsigned value)
{
    return  (genFindLowestBit(value) == value);
}

/*****************************************************************************
 *
 *  Given a value that has exactly one bit set, return the position of that
 *  bit, in other words return the logarithm in base 2 of the given value.
 */

inline
unsigned            genLog2(unsigned __int64 value)
{
    assert(genOneBitOnly(value));

    if  ((int)value == 0)
        return  genLog2((unsigned)(value >> 32)) + 32;
    else
        return  genLog2((unsigned)(value      ))     ;
}

/*****************************************************************************
 *
 *  Return the lowest bit that is set in the given register mask.
 */

inline
unsigned            genFindLowestReg(unsigned value)
{
    return  (unsigned)genFindLowestBit(value);
}

/*****************************************************************************
 *
 *  A rather stupid routine that counts the number of bits in a given number.
 */

inline
unsigned            genCountBits(VARSET_TP set)
{
    unsigned        cnt = 0;

    while (set)
    {
        cnt++;
        set -= genFindLowestBit(set);
    }

    return  cnt;
}

/*****************************************************************************
 * Returns true is offs is between [start..end)
 */

inline
bool                jitIsBetween(IL_OFFSET offs, IL_OFFSET start, IL_OFFSET end)
{
     return (offs >= start && offs < end);
}

/*****************************************************************************
 *
 *  Map a register mask to a register number [WARNING: fairly expensive].
 */

#if TGT_IA64

inline
regNumber           genRegNumFromMask(regMaskTP mask)
{
    UNIMPL("genRegNumFromMask");
    return  REG_COUNT;
}

#else

inline
regNumber           genRegNumFromMask(regMaskTP mask)
{
    regNumber       regNum;

    /* Make sure the mask has exactly one bit set */

    assert(mask != 0 && genOneBitOnly(mask));

    /* Convert the mask to a register number */

    regNum = (regNumber)(genLog2(mask) - 1);

    /* Make sure we got it right */

    assert(genRegMask(regNum) == mask);

    return  regNum;
}

#endif

/*****************************************************************************
 *
 *  Return the size in bytes of the given type.
 */

extern const
BYTE                genTypeSizes[TYP_COUNT];

inline
size_t              genTypeSize(varType_t type)
{
    assert(type < sizeof(genTypeSizes)/sizeof(genTypeSizes[0]));

    return genTypeSizes[type];
}

/*****************************************************************************
 *
 *  Return the "stack slot count" of the given type (i.e. returns 1 for 32-bit
 *  types and 2 for 64-bit types).
 */

extern const
BYTE                genTypeStSzs[TYP_COUNT];

inline
size_t              genTypeStSz(varType_t type)
{
    assert(type < sizeof(genTypeStSzs)/sizeof(genTypeStSzs[0]));

    return genTypeStSzs[type];
}

/*****************************************************************************
 *
 *  Return the number of registers required to hold a value of the given type.
 */

#if TGT_RISC

#if TGT_IA64

inline
unsigned            genTypeRegs(varType_t type)
{
    return  1;
}

#else

extern
BYTE                genTypeRegst[TYP_COUNT];

inline
unsigned            genTypeRegs(varType_t type)
{
    assert(type < sizeof(genTypeRegst)/sizeof(genTypeRegst[0]));
    assert(genTypeRegst[type] <= 2);

    return  genTypeRegst[type];
}

#endif

#endif

/*****************************************************************************
 *
 *  The following function maps a 'precise' type to an actual type as seen
 *  by the VM (for example, 'byte' maps to 'int').
 */

extern const
BYTE                genActualTypes[TYP_COUNT];

inline
var_types           genActualType(varType_t type)
{
    /* Spot check to make certain the table is in synch with the enum */

    assert(genActualTypes[TYP_DOUBLE] == TYP_DOUBLE);
    assert(genActualTypes[TYP_FNC   ] == TYP_FNC);
    assert(genActualTypes[TYP_REF   ] == TYP_REF);

    assert(type < sizeof(genActualTypes));
    return (var_types)genActualTypes[type];
}


/*****************************************************************************/

#ifdef DEBUG

inline
const char *        varTypeGCstring(var_types type)
{
    switch(type)
    {
    case TYP_REF:   return "gcr";
    case TYP_BYREF: return "byr";
    default:        return "non";
    }
}

#endif

/*****************************************************************************/

const   char *      varTypeName(var_types);

/*****************************************************************************
 *
 *  Helpers to pull big-endian values out of a byte stream.
 */

inline  unsigned    genGetU1(const BYTE *addr)
{
    return  addr[0];
}

inline    signed    genGetI1(const BYTE *addr)
{
    return  (signed char)addr[0];
}

inline  unsigned    genGetU2(const BYTE *addr)
{
    return  (addr[0] << 8) | addr[1];
}

inline    signed    genGetI2(const BYTE *addr)
{
    return  (signed short)((addr[0] << 8) | addr[1]);
}

inline  unsigned    genGetU4(const BYTE *addr)
{
    return  (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3];
}

/*****************************************************************************/
//  Helpers to pull little-endian values out of a byte stream.

inline
unsigned __int8     getU1LittleEndian(const BYTE * ptr)
{ return *(unsigned __int8 *)ptr; }

inline
unsigned __int16    getU2LittleEndian(const BYTE * ptr)
{ return *(unsigned __int16 *)ptr; }

inline
unsigned __int32    getU4LittleEndian(const BYTE * ptr)
{ return *(unsigned __int32*)ptr; }

inline
  signed __int8     getI1LittleEndian(const BYTE * ptr)
{ return * (signed __int8 *)ptr; }

inline
  signed __int16    getI2LittleEndian(const BYTE * ptr)
{ return * (signed __int16 *)ptr; }

inline
  signed __int32    getI4LittleEndian(const BYTE * ptr)
{ return *(signed __int32*)ptr; }

inline
  signed __int64    getI8LittleEndian(const BYTE * ptr)
{ return *(signed __int64*)ptr; }

inline
float               getR4LittleEndian(const BYTE * ptr)
{ return *(float*)ptr; }

inline
double              getR8LittleEndian(const BYTE * ptr)
{ return *(double*)ptr; }


/*****************************************************************************/

#ifdef  DEBUG
const   char *      genVS2str(VARSET_TP set);
#endif





/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          GenTree                                          XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#ifdef  FAST

inline
GenTreePtr FASTCALL Compiler::gtNewNode(genTreeOps oper, varType_t  type)
{
#if     SMALL_TREE_NODES
    size_t          size = GenTree::s_gtNodeSizes[oper];
#else
    size_t          size = sizeof(*node);
#endif
    GenTreePtr      node = (GenTreePtr)compGetMem(size);

    node->gtOper     = (BYTE)oper;
    node->gtType     = (BYTE)type;
    node->gtFlags    = 0;
#if TGT_x86
    node->gtUsedRegs = 0;
#endif
    node->gtNext     = 0;

    return node;
}

#endif

/*****************************************************************************/

inline
GenTreePtr          Compiler::gtNewStmt(GenTreePtr expr, IL_OFFSET offset)
{
    /* NOTE - GT_STMT is now a small node in retail */

    GenTreePtr  node = gtNewNode(GT_STMT, TYP_VOID);

    node->gtStmt.gtStmtExpr         = expr;

#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)
    node->gtStmtILoffs              = offset;
#endif

#ifdef DEBUG
    node->gtStmt.gtStmtLastILoffs   = BAD_IL_OFFSET;
#endif

    return node;
}

/*****************************************************************************/

inline
GenTreePtr          Compiler::gtNewOperNode(genTreeOps oper)
{
    GenTreePtr      node = gtNewNode(oper, TYP_VOID);

    node->gtOp.gtOp1 =
    node->gtOp.gtOp2 = 0;

    return node;
}

/*****************************************************************************/

inline
GenTreePtr          Compiler::gtNewOperNode(genTreeOps oper, varType_t  type)
{
    GenTreePtr      node = gtNewNode(oper, type);

    node->gtOp.gtOp1 =
    node->gtOp.gtOp2 = 0;

    return node;
}

/*****************************************************************************/

inline
GenTreePtr          Compiler::gtNewOperNode(genTreeOps oper,
                                            varType_t  type,  GenTreePtr op1)
{
    GenTreePtr      node = gtNewNode(oper, type);

    node->gtOp.gtOp1 = op1;
    node->gtOp.gtOp2 = 0;

    if  (op1) node->gtFlags |= op1->gtFlags & GTF_GLOB_EFFECT;

    return node;
}

/******************************************************************************
 *
 * Use to create nodes which may later be morphed to another (big) operator
 */

inline
GenTreePtr FASTCALL Compiler::gtNewLargeOperNode(genTreeOps     oper,
                                                 varType_t      type,
                                                 GenTreePtr     op1,
                                                 GenTreePtr     op2)
{
    GenTreePtr  node;

#if     SMALL_TREE_NODES

    // Allocate a large node

    assert(GenTree::s_gtNodeSizes[oper   ] == TREE_NODE_SZ_SMALL);
    assert(GenTree::s_gtNodeSizes[GT_CALL] == TREE_NODE_SZ_LARGE);

    node = gtNewOperNode(GT_CALL, type, op1, op2);
    node->ChangeOper(oper);

#else

    node = gtNewOperNode(oper, type, op1, op2);

#endif

    return node;
}

/*****************************************************************************
 *
 *  allocates a integer constant entry that represents a handle (something
 *  that may need to be fixed up).
 */

inline
GenTreePtr          Compiler::gtNewIconHandleNode(long         value,
                                                  unsigned     flags,
                                                  unsigned     handle1,
                                                  void *       handle2)
{
    GenTreePtr      node;
    assert((flags & GTF_ICON_HDL_MASK) != 0);

#if defined(JIT_AS_COMPILER) || defined (LATE_DISASM)
    node = gtNewLargeOperNode(GT_CNS_INT, TYP_INT);
    node->gtIntCon.gtIconVal = value;

    node->gtIntCon.gtIconHdl.gtIconHdl1 = handle1;
    node->gtIntCon.gtIconHdl.gtIconHdl2 = handle2;
#else
    node = gtNewIconNode(value);
#endif
    node->gtFlags           |= flags;
    return node;
}


#if!INLINING
#define gtNewIconHandleNode(value,flags,CPnum, CLS) gtNewIconHandleNode(value,flags,CPnum,0)
#endif


/*****************************************************************************
 *
 *  It may not be allowed to embed HANDLEs directly into the JITed code (for eg,
 *  as arguments to JIT helpers). Get a corresponding value that can be embedded.
 *  These are versions for each specific type of HANDLE
 */

inline
GenTreePtr  Compiler::gtNewIconEmbScpHndNode (SCOPE_HANDLE    scpHnd, unsigned hnd1, void * hnd2)
{
    void * embedScpHnd, * pEmbedScpHnd;

#ifdef NOT_JITC
    embedScpHnd = (void*)info.compCompHnd->embedModuleHandle(scpHnd, &pEmbedScpHnd);
#else
    embedScpHnd  = (void *)scpHnd;
    pEmbedScpHnd = NULL;
#endif

    assert((!embedScpHnd) != (!pEmbedScpHnd));

    return gtNewIconEmbHndNode(embedScpHnd, pEmbedScpHnd, GTF_ICON_SCOPE_HDL, hnd1, hnd2);
}

//-----------------------------------------------------------------------------

inline
GenTreePtr  Compiler::gtNewIconEmbClsHndNode (CLASS_HANDLE    clsHnd, unsigned hnd1, void * hnd2)
{
    void * embedClsHnd, * pEmbedClsHnd;

#ifdef NOT_JITC
    embedClsHnd = (void*)info.compCompHnd->embedClassHandle(clsHnd, &pEmbedClsHnd);
#else
    embedClsHnd  = (void *)clsHnd;
    pEmbedClsHnd = NULL;
#endif

    assert((!embedClsHnd) != (!pEmbedClsHnd));

    return gtNewIconEmbHndNode(embedClsHnd, pEmbedClsHnd, GTF_ICON_CLASS_HDL, hnd1, hnd2);
}

//-----------------------------------------------------------------------------

inline
GenTreePtr  Compiler::gtNewIconEmbMethHndNode(METHOD_HANDLE  methHnd, unsigned hnd1, void * hnd2)
{
    void * embedMethHnd, * pEmbedMethHnd;

#ifdef NOT_JITC
    embedMethHnd = (void*)info.compCompHnd->embedMethodHandle(methHnd, &pEmbedMethHnd);
#else
    embedMethHnd  = (void *)methHnd;
    pEmbedMethHnd = NULL;
#endif

    assert((!embedMethHnd) != (!pEmbedMethHnd));

    return gtNewIconEmbHndNode(embedMethHnd, pEmbedMethHnd, GTF_ICON_METHOD_HDL, hnd1, hnd2);
}

//-----------------------------------------------------------------------------

inline
GenTreePtr  Compiler::gtNewIconEmbFldHndNode (FIELD_HANDLE    fldHnd, unsigned hnd1, void * hnd2)
{
    void * embedFldHnd, * pEmbedFldHnd;

#ifdef NOT_JITC
    embedFldHnd = (void*)info.compCompHnd->embedFieldHandle(fldHnd, &pEmbedFldHnd);
#else
    embedFldHnd  = (void *)fldHnd;
    pEmbedFldHnd = NULL;
#endif

    assert((!embedFldHnd) != (!pEmbedFldHnd));

    return gtNewIconEmbHndNode(embedFldHnd, pEmbedFldHnd, GTF_ICON_FIELD_HDL, hnd1, hnd2);
}


/*****************************************************************************/

inline
GenTreePtr          Compiler::gtNewHelperCallNode(unsigned       helper,
                                                  varType_t      type,
                                                  unsigned       flags,
                                                  GenTreePtr     args)
{
    return gtNewCallNode(   CT_HELPER,
                            eeFindHelper(helper),
                            type,
                            flags,
                            args);
}

/*****************************************************************************/

inline
GenTreePtr FASTCALL Compiler::gtNewClsvNode(FIELD_HANDLE hnd,
                                            varType_t      type)
{
    GenTreePtr      node = gtNewNode(GT_CLS_VAR, type);

    node->gtClsVar.gtClsVarHnd = hnd;
    return node;
}


#if!INLINING
#define gtNewClsvNode(cpx,cls,typ) gtNewClsvNode(cpx,info.compScopeHnd,typ)
#endif



/*****************************************************************************/

inline
GenTreePtr FASTCALL Compiler::gtNewCodeRef(BasicBlock *block)
{
    GenTreePtr      node = gtNewNode(GT_LABEL, TYP_VOID);

    node->gtLabel.gtLabBB = block;
#if TGT_x86
    node->gtFPlvl         = 0;
#endif
    return node;
}

/*****************************************************************************
 *
 *  A little helper to create a data member reference node.
 */

inline
GenTreePtr          Compiler::gtNewFieldRef(var_types     typ,
                                            FIELD_HANDLE  fldHnd,
                                            GenTreePtr    obj)
{
    GenTreePtr      tree;

#if SMALL_TREE_NODES && RNGCHK_OPT

    /* 'GT_FIELD' nodes may later get transformed into 'GT_IND' */

    assert(GenTree::s_gtNodeSizes[GT_IND] >= GenTree::s_gtNodeSizes[GT_FIELD]);

    tree = gtNewNode(GT_IND  , typ);
    tree->ChangeOper(GT_FIELD);
#else
    tree = gtNewNode(GT_FIELD, typ);
#endif
    tree->gtField.gtFldObj = obj;
    tree->gtField.gtFldHnd = fldHnd;
#if HOIST_THIS_FLDS
    tree->gtField.gtFldHTX = 0;
#endif
    tree->gtFlags         |= GTF_GLOB_REF;

    return  tree;
}

/*****************************************************************************
 *
 *  A little helper to create an array index node.
 */

inline
GenTreePtr          Compiler::gtNewIndexRef(var_types     typ,
                                            GenTreePtr    adr,
                                            GenTreePtr    ind)
{
    GenTreePtr      tree;

#if SMALL_TREE_NODES && (RNGCHK_OPT || CSELENGTH)

    /* 'GT_INDEX' nodes may later get transformed into 'GT_IND' */

    assert(GenTree::s_gtNodeSizes[GT_IND] >= GenTree::s_gtNodeSizes[GT_INDEX]);

    tree = gtNewOperNode(GT_IND  , typ, adr, ind);
    tree->ChangeOper(GT_INDEX);
#else
    tree = gtNewOperNode(GT_INDEX, typ, adr, ind);
#endif

    tree->gtFlags |= GTF_EXCEPT|GTF_INX_RNGCHK;
        tree->gtIndex.elemSize = genTypeSize(typ);
    return  tree;
}


/*****************************************************************************
 *
 *  Create (and check for) a "nothing" node, i.e. a node that doesn't produce
 *  any code. We currently use a "nop" node of type void for this purpose.
 */

#if INLINING || OPT_BOOL_OPS || USE_FASTCALL

inline
GenTreePtr          Compiler::gtNewNothingNode()
{
    return  gtNewOperNode(GT_NOP, TYP_VOID);
}

inline
bool                Compiler::gtIsaNothingNode(GenTreePtr tree)
{
    return  tree->gtOper == GT_NOP && tree->gtType == TYP_VOID;
}

/*****************************************************************************/

inline
bool                GenTree::IsNothingNode()
{
    if  (gtOper == GT_NOP && gtType == TYP_VOID)
        return  true;
    else
        return  false;
}

#endif

/*****************************************************************************
 *
 *  Bash the given node to a NOP - May be later bashed to a GT_COMMA
 *
 *****************************************************************************/

inline
void                GenTree::gtBashToNOP()
{
    ChangeOper(GT_NOP);

    gtType     = TYP_VOID;
    gtOp.gtOp1 = gtOp.gtOp2 = 0;

    gtFlags &= ~(GTF_GLOB_EFFECT | GTF_REVERSE_OPS);
}

/*****************************************************************************/

inline
GenTreePtr          Compiler::gtUnusedValNode(GenTreePtr expr)
{
    return gtNewOperNode(GT_COMMA, TYP_VOID, expr, gtNewNothingNode());
}

/*****************************************************************************
 *
 * A wrapper for gtSetEvalOrder and fgComputeFPlvls
 * Necessary because the FP levels may need to be re-computed if we reverse
 * operands
 */

inline
void               Compiler::gtSetStmtInfo(GenTree * stmt)
{
    GenTreePtr      expr;

    assert(stmt->gtOper == GT_STMT);
    expr = stmt->gtStmt.gtStmtExpr;

#if TGT_x86

    /* We will try to compute the FP stack level at each node */
    genFPstkLevel = 0;

    /* Sometimes we need to redo the FP level computation */
    fgFPstLvlRedo = false;
#endif

    /* Recursively process the expression */

    gtSetEvalOrder(expr);

#if TGT_x86

    /* Unused float values leave one operand on the stack */
    assert(genFPstkLevel == 0 || genFPstkLevel == 1);

    /* Do we need to recompute FP stack levels? */

    if  (fgFPstLvlRedo)
    {
        genFPstkLevel = 0;
        fgComputeFPlvls(expr);
        assert(genFPstkLevel == 0 || genFPstkLevel == 1);
    }
#endif
}

/*****************************************************************************/
#if SMALL_TREE_NODES
/*****************************************************************************/

inline
void                GenTree::ChangeOper(int oper)
{
    assert(((gtFlags & GTF_NODE_SMALL) != 0) !=
           ((gtFlags & GTF_NODE_LARGE) != 0));

    /* Make sure the node isn't too small for the new operator */

    assert(GenTree::s_gtNodeSizes[gtOper] == TREE_NODE_SZ_SMALL ||
           GenTree::s_gtNodeSizes[gtOper] == TREE_NODE_SZ_LARGE);
    assert(GenTree::s_gtNodeSizes[  oper] == TREE_NODE_SZ_SMALL ||
           GenTree::s_gtNodeSizes[  oper] == TREE_NODE_SZ_LARGE);

    assert(GenTree::s_gtNodeSizes[  oper] == TREE_NODE_SZ_SMALL || (gtFlags & GTF_NODE_LARGE));

    gtOper = (genTreeOps)oper;
}

inline
void                GenTree::CopyFrom(GenTreePtr src)
{
    /* The source may be big only if the target is also a big node */

    assert((gtFlags & GTF_NODE_LARGE) || GenTree::s_gtNodeSizes[src->gtOper] == TREE_NODE_SZ_SMALL);
    memcpy(this, src, GenTree::s_gtNodeSizes[src->gtOper]);
}

inline
GenTreePtr          Compiler::gtNewCastNode(varType_t typ, GenTreePtr op1,
                                                           GenTreePtr op2)
{

    /* Some casts get transformed into 'GT_CALL' or 'GT_IND' nodes */

    assert(GenTree::s_gtNodeSizes[GT_CALL] >  GenTree::s_gtNodeSizes[GT_CAST]);
    assert(GenTree::s_gtNodeSizes[GT_CALL] >= GenTree::s_gtNodeSizes[GT_IND ]);

    /* Make a big node first and then bash it to be GT_CAST */

    op1 = gtNewOperNode(GT_CALL, typ, op1, op2);
    op1->ChangeOper(GT_CAST);

    return  op1;
}

/*****************************************************************************/
#else // SMALL_TREE_NODES
/*****************************************************************************/


inline
void                GenTree::InitNodeSize(){}

inline
void                GenTree::ChangeOper(int oper)
{
    gtOper = (genTreeOps)oper;
}

inline
void                GenTree::CopyFrom(GenTreePtr src)
{
    *this = *src;
}

inline
GenTreePtr          Compiler::gtNewCastNode(varType_t typ, GenTreePtr op1,
                                                           GenTreePtr op2)
{
    return  gtNewOperNode(GT_CAST, typ, op1, op2);
}

/*****************************************************************************/
#endif // SMALL_TREE_NODES
/*****************************************************************************
 *
 *  Returns true if the given operator may cause an exception.
 */

inline
bool                GenTree::OperMayThrow()
{
    GenTreePtr  op2;

    // ISSUE: Could any other operations cause an exception to be thrown?

    switch (gtOper)
    {
    case GT_MOD:
    case GT_DIV:

    case GT_UMOD:
    case GT_UDIV:

        /* Division with a non-zero constant does not throw an exception */

        op2 = gtOp.gtOp2;

        if ((op2->gtOper == GT_CNS_INT && op2->gtIntCon.gtIconVal) ||
            (op2->gtOper == GT_CNS_LNG && op2->gtLngCon.gtLconVal)  )
            return false;

        /* Fall through */

    case GT_IND:
    case GT_CATCH_ARG:
    case GT_ARR_LENGTH:

    case GT_LDOBJ:
    case GT_INITBLK:
    case GT_COPYBLK:
    case GT_LCLHEAP:
    case GT_CKFINITE:

        return  true;
    }

    /* Overflow arithmetic operations also throw exceptions */

    if (gtOverflowEx())
        return true;

    return  false;
}

/*****************************************************************************
 * Returns true if the node is &var (created by ldarga and ldloca)
 */

inline
bool                GenTree::IsVarAddr()
{
    if (gtOper == GT_ADDR && (gtFlags & GTF_ADDR_ONSTACK))
    {
        assert((gtType == TYP_BYREF) || (gtType == TYP_I_IMPL));
        return true;
    }
    else
        return false;
}

/*****************************************************************************
 *
 * Returns true if the node is of the "ovf" variety, ie. add.ovf.i1
 * + gtOverflow() can only be called for valid operators (ie. we know it is one
 *   of the operators which may have GTF_OVERFLOW set).
 * + gtOverflowEx() is more expensive, and should be called only gtOper may be
 *   an operator for which GTF_OVERFLOW is invalid
 */

inline
bool                GenTree::gtOverflow()
{
    assert(gtOper == GT_ADD      || gtOper == GT_SUB      || gtOper == GT_MUL ||
           gtOper == GT_ASG_ADD  || gtOper == GT_ASG_SUB  ||
           gtOper == GT_POST_INC || gtOper == GT_POST_DEC ||
           gtOper == GT_CAST);

    if (gtFlags & GTF_OVERFLOW)
    {
        assert(varTypeIsIntegral(TypeGet()));
        assert(gtFlags & GTF_EXCEPT);

        return true;
    }
    else
    {
        return false;
    }
}

inline
bool                GenTree::gtOverflowEx()
{
    if    (gtOper == GT_ADD      || gtOper == GT_SUB      || gtOper == GT_MUL ||
           gtOper == GT_ASG_ADD  || gtOper == GT_ASG_SUB  ||
           gtOper == GT_POST_INC || gtOper == GT_POST_DEC ||
           gtOper == GT_CAST)
    {
        return gtOverflow();
    }
    else
    {
        return false;
    }
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          LclVarsInfo                                      XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************
 *
 *  Allocate a temporary variable or a set of temp variables.
 */

inline
unsigned            Compiler::lvaGrabTemp()
{
    /* Check if the lvaTable has to be grown */
    if (lvaCount + 1 > lvaTableCnt)
    {
        lvaTableCnt = lvaCount + lvaCount / 2 + 1;

        size_t      lvaTableSize = lvaTableCnt * sizeof(*lvaTable);
        LclVarDsc * newLvaTable  = (LclVarDsc*)compGetMem(lvaTableSize);

        memset(newLvaTable, 0, lvaTableSize);
        memcpy(newLvaTable, lvaTable, lvaCount * sizeof(*lvaTable));

        lvaTable = newLvaTable;
    }

    /* Reset type, could have been set by unsuccessful inlining */

    lvaTable[lvaCount].lvType = TYP_UNDEF;
    return lvaCount++;
}

inline
unsigned            Compiler::lvaGrabTemps(unsigned cnt)
{
    /* Check if the lvaTable has to be grown */
    if (lvaCount + cnt > lvaTableCnt)
    {
        lvaTableCnt = lvaCount + lvaCount / 2 + cnt;

        size_t      lvaTableSize = lvaTableCnt * sizeof(*lvaTable);
        LclVarDsc * newLvaTable  = (LclVarDsc*)compGetMem(lvaTableSize);

        memset(newLvaTable, 0, lvaTableSize);
        memcpy(newLvaTable, lvaTable, lvaCount * sizeof(*lvaTable));

        lvaTable = newLvaTable;
    }

    unsigned  tempNum = lvaCount;

    /* Reset type, could have been set by unsuccessful inlining */

    while (cnt--)
        lvaTable[lvaCount++].lvType = TYP_UNDEF;

    return tempNum;
}

/*****************************************************************************/

inline
VARSET_TP           genVarIndexToBit(unsigned num)
{
    static const
    VARSET_TP       bitMask[] =
    {
        0x0000000000000001,
        0x0000000000000002,
        0x0000000000000004,
        0x0000000000000008,
        0x0000000000000010,
        0x0000000000000020,
        0x0000000000000040,
        0x0000000000000080,
        0x0000000000000100,
        0x0000000000000200,
        0x0000000000000400,
        0x0000000000000800,
        0x0000000000001000,
        0x0000000000002000,
        0x0000000000004000,
        0x0000000000008000,
        0x0000000000010000,
        0x0000000000020000,
        0x0000000000040000,
        0x0000000000080000,
        0x0000000000100000,
        0x0000000000200000,
        0x0000000000400000,
        0x0000000000800000,
        0x0000000001000000,
        0x0000000002000000,
        0x0000000004000000,
        0x0000000008000000,
        0x0000000010000000,
        0x0000000020000000,
        0x0000000040000000,
        0x0000000080000000,
#if VARSET_SZ > 32
        0x0000000100000000,
        0x0000000200000000,
        0x0000000400000000,
        0x0000000800000000,
        0x0000001000000000,
        0x0000002000000000,
        0x0000004000000000,
        0x0000008000000000,
        0x0000010000000000,
        0x0000020000000000,
        0x0000040000000000,
        0x0000080000000000,
        0x0000100000000000,
        0x0000200000000000,
        0x0000400000000000,
        0x0000800000000000,
        0x0001000000000000,
        0x0002000000000000,
        0x0004000000000000,
        0x0008000000000000,
        0x0010000000000000,
        0x0020000000000000,
        0x0040000000000000,
        0x0080000000000000,
        0x0100000000000000,
        0x0200000000000000,
        0x0400000000000000,
        0x0800000000000000,
        0x1000000000000000,
        0x2000000000000000,
        0x4000000000000000,
        0x8000000000000000,
#endif

    };

    assert(num < sizeof(bitMask)/sizeof(bitMask[0]));

    return bitMask[num];
}

/*****************************************************************************
 *
 *  The following returns the mask of all tracked locals
 *  referenced in a statement.
 */

inline
VARSET_TP           Compiler::lvaStmtLclMask(GenTreePtr stmt)
{
    GenTreePtr      tree;
    unsigned        varNum;
    LclVarDsc   *   varDsc;
    VARSET_TP       lclMask = 0;

    assert(stmt->gtOper == GT_STMT);
    assert(fgStmtListThreaded);

    for (tree = stmt->gtStmt.gtStmtList; tree; tree = tree->gtNext)
    {
        if  (tree->gtOper != GT_LCL_VAR)
            continue;

        varNum = tree->gtLclVar.gtLclNum;
        assert(varNum < lvaCount);
        varDsc = lvaTable + varNum;

        if  (!varDsc->lvTracked)
            continue;

        lclMask |= genVarIndexToBit(varDsc->lvVarIndex);
    }

    return lclMask;
}

/*****************************************************************************
 *
 *  Return the stack framed offset of the given variable; set *FPbased to
 *  true if the variable is addressed off of FP, false if it's addressed
 *  off of SP. Note that 'varNum' can be a negated temporary var index.
 */

#if TGT_IA64

inline
NatUns              Compiler::lvaFrameAddress(int varNum)
{
    LclVarDsc   *   varDsc;

    assert(lvaDoneFrameLayout);
    assert(varNum >= 0);

    assert((unsigned)varNum < lvaCount);
    varDsc = lvaTable + varNum;

    return  varDsc->lvStkOffs;
}

#else

inline
int                 Compiler::lvaFrameAddress(int varNum, bool *FPbased)
{
    assert(lvaDoneFrameLayout);

    if  (varNum >= 0)
    {
        LclVarDsc   *   varDsc;

        assert((unsigned)varNum < lvaCount);
        varDsc = lvaTable + varNum;

        *FPbased = varDsc->lvFPbased;

#ifdef  DEBUG
#if     TGT_x86
#if     DOUBLE_ALIGN
        assert(*FPbased == (genFPused || (genDoubleAlign && varDsc->lvIsParam)));
#else
        assert(*FPbased ==  genFPused);
#endif
#endif
#endif

        return  varDsc->lvStkOffs;
    }
    else
    {
        TempDsc *       tmpDsc = tmpFindNum(varNum); assert(tmpDsc);

        // UNDONE: The following is not always a safe assumption for RISC

        *FPbased = genFPused;

        return  tmpDsc->tdTempOffs();
    }
}

inline
bool                Compiler::lvaIsEBPbased(int varNum)
{

#if DOUBLE_ALIGN

    if  (varNum >= 0)
    {
        LclVarDsc   *   varDsc;

        assert((unsigned)varNum < lvaCount);
        varDsc = lvaTable + varNum;

#ifdef  DEBUG
#if     TGT_x86
#if     DOUBLE_ALIGN
        assert(varDsc->lvFPbased == (genFPused || (genDoubleAlign && varDsc->lvIsParam)));
#else
        assert(varDsc->lvFPbased ==  genFPused);
#endif
#endif
#endif

        return  varDsc->lvFPbased;
    }

#endif

    return  genFPused;
}

#endif

inline
bool                Compiler::lvaIsParameter(int varNum)
{
    LclVarDsc   *   varDsc;

    assert(varNum >= 0);

    assert((unsigned)varNum < lvaCount);
    varDsc = lvaTable + varNum;

    return  varDsc->lvIsParam;
}

#if USE_FASTCALL

inline
bool                Compiler::lvaIsRegArgument(int varNum)
{
    LclVarDsc   *   varDsc;

    assert(varNum >= 0);

    assert((unsigned)varNum < lvaCount);
    varDsc = lvaTable + varNum;

    return  varDsc->lvIsRegArg;
}
#endif

inline
bool                Compiler::lvaIsThisArg(int varNum)
{
    LclVarDsc   *   varDsc;

    assert(varNum >= 0);

    assert((unsigned)varNum < lvaCount);
    varDsc = lvaTable + varNum;

    return  varDsc->lvIsThis;
}

/*****************************************************************************
 *
 *  The following is used to detect the cases where the same local variable#
 *  is used both as a long/double value and a 32-bit value and/or both as an
 *  integer/address and a float value.
 */

/* static */ inline
unsigned            Compiler::lvaTypeRefMask(varType_t type)
{
    const static
    BYTE                lvaTypeRefMasks[] =
    {
        #define DEF_TP(tn,nm,jitType,sz,sze,asze,st,al,tf,howUsed) howUsed,
        #include "typelist.h"
        #undef  DEF_TP
    };

    ASSert(type < sizeof(lvaTypeRefMasks));
    ASSert(lvaTypeRefMasks[type] != 0);

    return lvaTypeRefMasks[type];
}

/*****************************************************************************
 *
 *  The following is used to detect the cases where the same local variable#
 *  is used both as a long/double value and a 32-bit value and/or both as an
 *  integer/address and a float value.
 */

inline
var_types          Compiler::lvaGetType(unsigned lclNum)
{
    return genActualType(lvaGetRealType(lclNum));
}

inline
var_types          Compiler::lvaGetRealType(unsigned lclNum)
{
    return (var_types)lvaTable[lclNum].lvType;
}

inline
bool               Compiler::lvaIsContextFul(unsigned lclNum)
{
    return lvaTable[lclNum].lvContextFul;
}

/*****************************************************************************/

inline void         Compiler::lvaAdjustRefCnts() {}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          Importer                                         XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

inline
unsigned Compiler::impArgNum(unsigned ILnum)
{
        // Note that this works because if compRetBuffArg is not present
        // it will be negative, which when treated as an unsigned will
        // make it a larger than any varable.
    if (ILnum >= (unsigned) info.compRetBuffArg)
    {
        ILnum++;
        assert(ILnum < info.compLocalsCount);   // compLocals count already adjusted.
    }
    return(ILnum);
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                     Register Allocator                                    XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/



/*****************************************************************************
 *
 *  Given a register variable node, return the variable's liveset bit.
 */

inline
VARSET_TP           Compiler::raBitOfRegVar(GenTreePtr tree)
{
    unsigned        lclNum;
    LclVarDsc   *   varDsc;

    assert(tree->gtOper == GT_REG_VAR);

    lclNum = tree->gtRegVar.gtRegVar;
    assert(lclNum < lvaCount);
    varDsc = lvaTable + lclNum;
    assert(varDsc->lvTracked);

    return  genVarIndexToBit(varDsc->lvVarIndex);
}

inline
bool                isRegPairType(int /* s/b "var_types" */ type)
{
#if CPU_HAS_FP_SUPPORT
    return  (type == TYP_LONG);
#else
    return  (type == TYP_LONG || type == TYP_DOUBLE);
#endif
}


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                       FlowGraph                                           XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************
 *
 *  Call the given function pointer for all nodes in the tree. The 'visit' fn
 *  should return one of the following values:
 *
 *     -1       stop walking and return immediately
 *      0       continue walking
 *     +1       don't walk any subtrees of the node just visited
 */

inline
int             Compiler::fgWalkTree     (GenTreePtr    tree,
                                          int         (*visitor)(GenTreePtr, void *),
                                          void *        callBackData,
                                          bool          lclVarsOnly)
{
    fgWalkVisitorFn    = visitor;
    fgWalkCallbackData = callBackData;
    fgWalkLclsOnly     = lclVarsOnly;

    return fgWalkTreeRec(tree);
}

/*****************************************************************************
 *
 *  Same as above, except the tree walk is performed in a depth-first fashion,
 *  and obviously returning +1 doesn't make any sense (since the children are
 *  visited first).
 */

inline
int             Compiler::fgWalkTreeDepth(GenTreePtr    tree,
                                          int         (*visitor)(GenTreePtr, void *, bool),
                                          void *        callBackData,
                                          genTreeOps    prefixNode)
{
    fgWalkVisitorDF    = visitor;
    fgWalkCallbackData = callBackData;
    fgWalkPrefixNode   = prefixNode;

    return fgWalkTreeDepRec(tree);
}

/*****************************************************************************
 *
 *  Return the stackLevel of the inserted block that throws the range-check
 *  exception (by calling the VM helper).
 */

#if TGT_x86
inline
unsigned            Compiler::fgGetRngFailStackLevel(BasicBlock *block)
{
    AddCodeDsc  *   add;

    /* Stack level is used iff ESP frames */

    assert(!genFPused);

    for  (add = fgAddCodeList; add; add = add->acdNext)
    {
        if  (block == add->acdDstBlk)
        {
            assert(add->acdKind == ACK_RNGCHK_FAIL || add->acdKind == ACK_OVERFLOW);
            return add->acdStkLvl;
        }
    }

    /* We couldn't find the basic block ?? */

    return 0;
}
#endif

/*****************************************************************************
 *
 *  Return true if we've added any new basic blocks.
 */

inline
bool                Compiler::fgIsCodeAdded()
{
    return  fgAddCodeModf;
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          TempsInfo                                        XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************/

/* static */ inline
unsigned            Compiler::tmpFreeSlot(size_t size)
{
    ASSert((size % sizeof(int)) == 0 && size <= TEMP_MAX_SIZE);

    return size / sizeof(int) - 1;
}

/*****************************************************************************
 *
 *  Finish allocating temps - should be called each time after a pass is made
 *  over a function body.
 */

inline
void                Compiler::tmpEnd()
{
#ifdef DEBUG
    if (verbose && tmpCount) printf("%d tmps used\n", tmpCount);
#endif
}

/*****************************************************************************
 *
 *  Shuts down the temp-tracking code. Should be called once per function
 *  compiled.
 */

inline
void                Compiler::tmpDone()
{
#ifdef DEBUG
    size_t      size = 0;
    unsigned    count;
    TempDsc   * temp;

    for (temp = tmpListBeg(    ), count  = temp ? 1 : 0;
         temp;
         temp = tmpListNxt(temp), count += temp ? 1 : 0)
    {
        assert(temp->tdOffs != 0xDDDD);

        size += temp->tdSize;
    }

    // Make sure that all the temps were released
    assert(count == tmpCount);

#endif
}

/*****************************************************************************
 *
 *  A helper function is used to iterate over all the temps;
 *  this function may only be called at the end of codegen and *after* calling
 *  tmpEnd().
 */

inline
Compiler::TempDsc *    Compiler::tmpListBeg()
{
    // Return the first temp in the slot for the smallest size
    TempDsc * temp = tmpFree[0];

    if (!temp)
    {
        // If we have more slots, need to use "while" instead of "if" above
        assert(tmpFreeSlot(TEMP_MAX_SIZE) == 1);

        temp = tmpFree[1];
    }

    assert(temp == 0 || temp->tdTempOffs() != 0xDDDD);

    return temp;
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          RegSet                                           XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#if!TGT_IA64
/*****************************************************************************
 *
 *  The following returns a mask that excludes 'rmvMask' from 'regMask' (in
 *  the case where 'rmvMask' includes all of 'regMask' it returns 'regMask').
 */

inline
regMaskTP           Compiler::rsRegExclMask(regMaskTP regMask,
                                            regMaskTP rmvMask)
{
    if  (rmvMask)
    {
        regMaskTP       delMask = ~rmvMask;

        if  (regMask &  delMask)
             regMask &= delMask;
    }

    return  regMask;
}

/*****************************************************************************
 *
 *  The following returns a mask that yields all free registers.
 */

inline
regMaskTP           Compiler::rsRegMaskFree()
{
    /* Any register that is locked must also be marked as 'used' */

    assert((rsMaskUsed & rsMaskLock) == rsMaskLock);

    /* Any register that isn't used and doesn't hold a variable is free */

    return  (RBM_ALL & ~(rsMaskUsed|rsMaskVars));
}

/*****************************************************************************
 *
 *  The following returns a mask of registers that may be grabbed.
 */

inline
regMaskTP           Compiler::rsRegMaskCanGrab()
{
    /* Any register that is locked must also be marked as 'used' */

    assert((rsMaskUsed & rsMaskLock) == rsMaskLock);

    /* Any register that isn't locked and doesn't hold a var can be grabbed */

    return  (RBM_ALL & ~(rsMaskLock|rsMaskVars));
}

/*****************************************************************************
 *
 *  Mark the given set of registers as used and locked.
 */

inline
void                Compiler::rsLockReg(regMaskTP regMask)
{
    /* Must not be already marked as either used or locked */

    assert((rsMaskUsed &  regMask) == 0);
            rsMaskUsed |= regMask;
    assert((rsMaskLock &  regMask) == 0);
            rsMaskLock |= regMask;
}

/*****************************************************************************
 *
 *  Mark an already used set of registers as locked.
 */

inline
void                Compiler::rsLockUsedReg(regMaskTP regMask)
{
    /* Must not be already marked as locked. Must be already marked as used. */

    assert((rsMaskLock &  regMask) == 0);
    assert((rsMaskUsed &  regMask) == regMask);

            rsMaskLock |= regMask;
}

/*****************************************************************************
 *
 *  Mark the given set of registers as no longer used/locked.
 */

inline
void                Compiler::rsUnlockReg(regMaskTP regMask)
{
    /* Must be currently marked as both used and locked */

    assert((rsMaskUsed &  regMask) == regMask);
            rsMaskUsed -= regMask;
    assert((rsMaskLock &  regMask) == regMask);
            rsMaskLock -= regMask;
}

/*****************************************************************************
 *
 *  Mark the given set of registers as no longer locked.
 */

inline
void                Compiler::rsUnlockUsedReg(regMaskTP regMask)
{
    /* Must be currently marked as both used and locked */

    assert((rsMaskUsed &  regMask) == regMask);
    assert((rsMaskLock &  regMask) == regMask);
            rsMaskLock -= regMask;
}

/*****************************************************************************
 *
 *  Mark the given set of registers as used and locked. It may already have
 *  been marked as used.
 */

inline
void                Compiler::rsLockReg(regMaskTP regMask, regMaskTP * usedMask)
{
    /* Is it already marked as used? */

    regMaskTP         used = (rsMaskUsed & regMask);
    regMaskTP       unused = (     ~used & regMask);

    if (  used)
        rsLockUsedReg(used);

    if (unused)
        rsLockReg(unused);

    *usedMask = used;
}

/*****************************************************************************
 *
 *  Mark the given set of registers as no longer
 */

inline
void                Compiler::rsUnlockReg(regMaskTP regMask, regMaskTP usedMask)
{
    regMaskTP       unused = (regMask & ~usedMask);

    if (usedMask)
        rsUnlockUsedReg(usedMask);

    if (unused)
        rsUnlockReg(unused);
}

/*****************************************************************************
 *
 *  Assume all registers contain garbage (called at start of codegen and when
 *  we encounter a code label).
 */

inline
void                Compiler::rsTrackRegClr()
{
    assert(RV_TRASH == 0); memset(rsRegValues, 0, sizeof(rsRegValues));
}

/*****************************************************************************
 *
 *  Record the fact that the given register now contains the given value.
 */

inline
void                Compiler::rsTrackRegTrash(regNumber reg)
{
    /* Keep track of which registers we ever touch */

    rsMaskModf |= genRegMask(reg);

    /* Record the new value for the register */

    rsRegValues[reg].rvdKind = RV_TRASH;
}

/*****************************************************************************/

inline
void                Compiler::rsTrackRegIntCns(regNumber reg, long val)
{
    /* Keep track of which registers we ever touch */

    rsMaskModf |= genRegMask(reg);

    /* Record the new value for the register */

    rsRegValues[reg].rvdKind      = RV_INT_CNS;
    rsRegValues[reg].rvdIntCnsVal = val;
}


/*****************************************************************************/

#if USE_SET_FOR_LOGOPS

inline
void                Compiler::rsTrackRegOneBit(regNumber reg)
{
    /* Record the new value for the register */

#ifdef  DEBUG
    if  (verbose) printf("The register %s now holds a bit value\n", compRegVarName(reg));
#endif

    rsRegValues[reg].rvdKind = RV_BIT;
}

#endif

/*****************************************************************************/

#if!TGT_IA64

inline
void                Compiler::rsTrackRegLclVarLng(regNumber reg, unsigned var, bool low)
{
    assert(reg != REG_STK);

    /* Don't track aliased variables
     * CONSIDER - can be smarter and trash the registers at call sites or indirections */

    if (lvaTable[var].lvAddrTaken || lvaTable[var].lvVolatile)
        return;

    /* Keep track of which registers we ever touch */

    rsMaskModf |= genRegMask(reg);

    /* Record the new value for the register */

    rsRegValues[reg].rvdKind      = (low ? RV_LCL_VAR_LNG_LO : RV_LCL_VAR_LNG_HI);
    rsRegValues[reg].rvdLclVarNum = var;
}

#endif

/*****************************************************************************/

inline
bool                Compiler::rsTrackIsLclVarLng(regValKind rvKind)
{
    if  (opts.compMinOptim || opts.compDbgCode)
        return  false;

    if  (rvKind == RV_LCL_VAR_LNG_LO ||
         rvKind == RV_LCL_VAR_LNG_HI)
        return  true;
    else
        return  false;
}

/*****************************************************************************/

inline
void                Compiler::rsTrackRegClsVar(regNumber reg, FIELD_HANDLE fldHnd)
{

#if 1

    // CONSIDER: To enable load suppression of static data members we'd
    // CONSIDER: need to clear all of them from the table upon calls and
    // CONSIDER: static data member assignments.

    rsTrackRegTrash(reg);

#else

    /* Keep track of which registers we ever touch */

    rsMaskModf |= genRegMask(reg);

    /* Record the new value for the register */

    rsRegValues[reg].rvdKind      = RV_CLS_VAR;
    rsRegValues[reg].rvdClsVarHnd = fldHnd;

#endif

}

/*****************************************************************************/

#if 0
inline
void                Compiler::rsTrackRegCopy(regNumber reg1, regNumber reg2)
{
    /* Keep track of which registers we ever touch */

    rsMaskModf |= genRegMask(reg1);

    rsRegValues[reg1] = rsRegValues[reg2];
}
#endif

/*****************************************************************************/
#if SCHEDULER
/*****************************************************************************
 *
 *  Determine whether we should "riscify" by loading a local variable to
 *  a register instead of addressing it in memory.
 *
 *  Called from genMakeRvalueAddressable() and rsPickReg (to determine if
 *  round-robin register allocation should be used.
 */

#if TGT_RISC

inline
bool                Compiler::rsRiscify(var_types type, unsigned needReg)
{
    return  false;
}

#else

inline
bool                Compiler::rsRiscify(var_types type, unsigned needReg)
{
    if (!riscCode)
        return false;

//  if (!opts.compSchedCode)
//      return false;

    if (compCurBB->bbWeight <= 1)
        return false;

    if (needReg == 0)
        needReg = RBM_ALL;

    // require enough free registers for the value because no benefit to
    // riscification otherwise.
    if (rsFreeNeededRegCount(needReg) < genTypeStSz(type))
        return false;

#if 0
    // heuristic: if only one tree in block, don't riscify
    // since there's not much to schedule
    if (type != TYP_LONG && compCurBB->bbTreeList->gtNext == NULL)
        return false;
#endif

    return true;
}

#endif

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************
 *
 *  Make sure no spills are currently active - used for debugging of the code
 *  generator.
 */

#ifndef NDEBUG

inline
void                Compiler::rsSpillChk()
{
    unsigned        reg;

    for (reg = 0; reg < REG_COUNT; reg++)
    {
        assert(rsSpillDesc[reg] == 0);
        assert(rsUsedTree [reg] == 0);
        assert(rsMultiDesc[reg] == 0);
    }
}

#else

inline
void                Compiler::rsSpillChk(){}

#endif

/*****************************************************************************
 *
 *  Initializes the spill code. Should be called once per function compiled.
 */

inline
void                Compiler::rsSpillInit()
{
    /* Clear out the spill and multi-use tables */

    memset(rsSpillDesc, 0, sizeof(rsSpillDesc));
    memset(rsUsedTree,  0, sizeof(rsUsedTree) );
    memset(rsUsedAddr,  0, sizeof(rsUsedAddr) );
    memset(rsMultiDesc, 0, sizeof(rsMultiDesc));

    /* We don't have any descriptors allocated */

    rsSpillFree = 0;
}

/*****************************************************************************
 *
 *  Shuts down the spill code. Should be called once per function compiled.
 */

inline
void                Compiler::rsSpillDone()
{
    rsSpillChk();
}

/*****************************************************************************
 *
 *  Begin tracking spills - should be called each time before a pass is made
 *  over a function body.
 */

inline
void                Compiler::rsSpillBeg()
{
    rsSpillChk();
}

/*****************************************************************************
 *
 *  Finish tracking spills - should be called each time after a pass is made
 *  over a function body.
 */

inline
void                Compiler::rsSpillEnd()
{
    rsSpillChk();
}

/*****************************************************************************/
#if REDUNDANT_LOAD
/*****************************************************************************
 *
 *  Search for a register which contains the given constant value.
 * Return success/failure and set the register if success.
 */

inline
regNumber           Compiler::rsIconIsInReg(long val)
{
    unsigned        reg;

    if  (opts.compMinOptim || opts.compDbgCode)
        return REG_NA;

    for (reg = 0; reg < REG_COUNT; reg++)
    {
        if (rsRegValues[reg].rvdKind == RV_INT_CNS &&
            rsRegValues[reg].rvdIntCnsVal == val)
        {
#if SCHEDULER
            rsUpdateRegOrderIndex((regNumber)reg);
#endif
            return  (regNumber)reg;
        }
    }

    return REG_NA;
}

inline
bool                Compiler::rsIconIsInReg(long val, regNumber reg)
{
    if  (opts.compMinOptim || opts.compDbgCode)
        return false;

    if (rsRegValues[reg].rvdKind == RV_INT_CNS &&
        rsRegValues[reg].rvdIntCnsVal == val)
    {
#if SCHEDULER
        rsUpdateRegOrderIndex(reg);
#endif
        return  true;
    }
    else
    {
        return false;
    }
}

#if USE_SET_FOR_LOGOPS

/*****************************************************************************
 *
 * Search for a register which has at least the upper 3 bytes cleared.
 * The caller can restrict the search to byte addressable registers and/or
 * free registers, only.
 * Return success/failure and set the register if success.
 */
inline
regNumber           Compiler::rsFindRegWithBit(bool free, bool byteReg)
{
    unsigned        reg;

    if  (opts.compMinOptim || opts.compDbgCode)
        return REG_NA;

    for (reg = 0; reg < REG_COUNT; reg++)
    {

#if TGT_x86
        if (byteReg && !isByteReg((regNumbers)reg))
            continue;
#endif

        if ((rsRegValues[reg].rvdKind == RV_BIT) ||
            (rsRegValues[reg].rvdKind == RV_INT_CNS &&
             rsRegValues[reg].rvdIntCnsVal == 0))
        {
            if (!free || (genRegMask((regNumbers)reg)& rsRegMaskFree()))
                goto RET;
        }
    }

    return REG_NA;

RET:

#if SCHEDULER
    rsUpdateRegOrderIndex((regNumber)reg);
#endif

    return (regNumber)reg;
}

#endif

/*****************************************************************************/
#endif // REDUNDANT_LOAD
/*****************************************************************************/
#endif // !GT_IA64
/*****************************************************************************/




/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                       Instruction                                         XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#if !   TGT_IA64
/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction is a floating-point ins.
 */

/* static */ inline
bool                Compiler::instIsFP(instruction ins)
{
    ASSert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_FP) != 0;
}

/*****************************************************************************/
#else //TGT_x86
/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction is a branch-delayed ins.
 */

/* static */ inline
bool                Compiler::instBranchDelay(instruction ins)
{
    ASSert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_BD) != 0;
}

/*****************************************************************************
 *
 *  Returns the number of branch-delay slots for the given instruction (or 0).
 */

/* static */ inline
unsigned            Compiler::instBranchDelayL(instruction ins)
{
    ASSert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

#if     MAX_BRANCH_DELAY_LEN > 1
#error  You\'ll need to add more bits to support more than 1 branch delay slot!
#endif

    return  (unsigned)((instInfo[ins] & INST_BD) != 0);
}

/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction is a branch/call/ret.
 */

/* static */ inline
bool                Compiler::instIsBranch(instruction ins)
{
    ASSert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_BR) != 0;
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#if SCHEDULER
/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction sets the flags.
 */

inline
bool                Compiler::instDefFlags(instruction ins)
{
    ASSert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_DEF_FL) != 0;
}

/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction uses the flags.
 */

inline
bool                Compiler::instUseFlags(instruction ins)
{
    ASSert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_USE_FL) != 0;
}

/*****************************************************************************
 *
 *  Returns non-zero if the given CPU instruction uses the flags.
 */

inline
bool                Compiler::instSpecialSched(instruction ins)
{
    ASSert(ins < sizeof(instInfo)/sizeof(instInfo[0]));

    return  (instInfo[ins] & INST_SPSCHD) != 0;
}

/*****************************************************************************/
#else //SCHEDULER
/*****************************************************************************/

#if     TGT_x86

inline
void                Compiler::inst_JMP(emitJumpKind   jmp,
                                       BasicBlock *   block,
                                       bool           except,
                                       bool           moveable,
                                       bool           newBlock)
{
    inst_JMP(jmp, block);
}

#endif

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/
#endif//TGT_IA64
/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Return the register which is defined by the IMUL_REG instruction
 */

inline
regNumber           Compiler::instImulReg(instruction ins)
{
    regNumber       reg  = ((regNumber) (ins - INS_imul_AX));

    ASSert(reg >= REG_EAX);
    ASSert(reg <= REG_EDI);

    /* Make sure we return the appropriate register */

    ASSert(INS_imul_BX - INS_imul_AX == REG_EBX);
    ASSert(INS_imul_CX - INS_imul_AX == REG_ECX);
    ASSert(INS_imul_DX - INS_imul_AX == REG_EDX);

    ASSert(INS_imul_BP - INS_imul_AX == REG_EBP);
    ASSert(INS_imul_SI - INS_imul_AX == REG_ESI);
    ASSert(INS_imul_DI - INS_imul_AX == REG_EDI);

    return reg;
}

/*****************************************************************************
 *
 *  Generate a floating-point instruction that has one operand given by
 *  a tree (which has been made addressable).
 */

inline
void                Compiler::inst_FS_TT(instruction ins, GenTreePtr tree)
{
    assert(instIsFP(ins));

    assert(tree->gtType == TYP_FLOAT ||
           tree->gtType == TYP_DOUBLE);

    inst_TT(ins, tree, 0);
}

/*****************************************************************************
 *
 *  Generate a "shift reg, CL" instruction.
 */

inline
void                Compiler::inst_RV_CL(instruction ins, regNumber reg)
{
    inst_RV(ins, reg, TYP_INT);
}

/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************
 *
 *  Macros to include/exclude arguments depending on whether inlining
 *  is enabled.
 */

#if!INLINING
#define inst_CALL(ctype,val,cls) inst_CALL(ctype,val,0)
#endif

#if!INLINING
#define inst_IV_handle(ins,val,flags,cpx,cls) inst_IV_handle(ins,val,flags,cpx,0)
#endif

#if!INLINING
#define instEmitDataFixup(cpx,cls) instEmitDataFixup(cpx,0)
#endif

#if!INLINING
#define inst_CV(ins,siz,cpx,cls,ofs) inst_CV(ins,siz,cpx,0,ofs)
#endif

#if INDIRECT_CALLS
#if!INLINING
#define inst_SM(ins,siz,cpx,cls,ofs) inst_SM(ins,siz,cpx,0,ofs)
#endif
#endif

#if!INLINING
#define inst_CV_RV(ins,siz,cpx,cls,reg,ofs) inst_CV_RV(ins,siz,cpx,0,reg,ofs)
#endif

#if!INLINING
#define inst_CV_IV(ins,siz,cpx,cls,val,ofs) inst_CV_IV(ins,siz,cpx,0,val,ofs)
#endif

#if!INLINING
#define inst_RV_CV(ins,siz,reg,cpx,cls,ofs) inst_RV_CV(ins,siz,reg,cpx,0,ofs)
#endif

#if!INLINING
#define instEmit_vfnCall(reg,disp,cpx,cls) instEmit_vfnCall(reg,disp,cpx,0)
#endif

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          ScopeInfo                                        XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#ifdef DEBUGGING_SUPPORT

inline
void        Compiler::siBeginBlockSkipSome()
{
    assert(opts.compScopeInfo && info.compLocalVarsCount > 0);
    assert(siLastEndOffs < compCurBB->bbCodeOffs);

    compProcessScopesUntil(compCurBB->bbCodeOffs,
                           siNewScopeCallback, siEndScopeCallback,
                           (unsigned)this);
}

#endif

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          GCInfo                                           XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#if TRACK_GC_REFS
/*****************************************************************************
 *
 *  Mark the set of registers given by the specified mask as holding
 *  GCref pointer values.
 */

inline
void                Compiler::gcMarkRegSetGCref(regMaskTP regMask)
{
    gcRegGCrefSetCur |= regMask;

    assert((gcRegGCrefSetCur & gcRegByrefSetCur) == 0);
}

/*****************************************************************************
 *
 *  Mark the set of registers given by the specified mask as holding
 *  Byref pointer values.
 */

inline
void                Compiler::gcMarkRegSetByref(regMaskTP regMask)
{
    gcRegByrefSetCur |= regMask;

    assert((gcRegGCrefSetCur & gcRegByrefSetCur) == 0);
}

/*****************************************************************************
 *
 *  Mark the set of registers given by the specified mask as holding
 *  non-pointer values.
 */

inline
void                Compiler::gcMarkRegSetNpt(regMaskTP regMask)
{
    /* NOTE: don't unmark any live register variables */

    gcRegGCrefSetCur &= ~(regMask & ~rsMaskVars);
    gcRegByrefSetCur &= ~(regMask & ~rsMaskVars);
}

/*****************************************************************************
 *
 *  Mark the specified register as now holding a value of the given type.
 */

inline
void                Compiler::gcMarkRegPtrVal(regNumber reg, var_types type)
{
    unsigned        regMask = genRegMask(reg);

    switch(type)
    {
    case TYP_REF:   gcMarkRegSetGCref(regMask); break;
    case TYP_BYREF: gcMarkRegSetByref(regMask); break;
    default:        gcMarkRegSetNpt  (regMask); break;
    }
}

/*****************************************************************************/

#if GC_WRITE_BARRIER

/* static */ inline
bool                Compiler::gcIsWriteBarrierCandidate(GenTreePtr tgt)
{
    /* Generate it only when asked to do so */

    if  (!Compiler::s_gcWriteBarrierPtr)
        return  false;

    /* Are we storing a GC ptr? */

    if  (!varTypeIsGC(tgt->TypeGet()))
        return  false;

    /* What are we storing into */

    switch(tgt->gtOper)
    {
    case GT_IND:
        if  (varTypeIsGC(tgt->gtOp.gtOp1->TypeGet()))
            return true;
        break;

    case GT_CLS_VAR:
        return true;
    }

    return false;
}

/* static */ inline
bool                Compiler::gcIsWriteBarrierAsgNode(GenTreePtr op)
{
    if (op->gtOper == GT_ASG)
        return gcIsWriteBarrierCandidate(op->gtOp.gtOp1);
    else
        return false;
}

#else

#if GC_WRITE_BARRIER_CALL

/* static */ inline
bool                Compiler::gcIsWriteBarrierCandidate(GenTreePtr tgt)
{
    /* Generate it only when asked to do so */

    if  (!JITGcBarrierCall)
        return false;

    /* Are we storing a GC ptr? */

    if  (!varTypeIsGC(tgt->TypeGet()))
        return false;

    /* What are we storing into */

    switch(tgt->gtOper)
    {
    case GT_IND:
        if  (varTypeIsGC(tgt->gtOp.gtOp1->TypeGet()))
            return true;
        break;

    case GT_CLS_VAR:
        return true;
    }

    return false;
}

/* static */ inline
bool                Compiler::gcIsWriteBarrierAsgNode(GenTreePtr op)
{
    if (op->gtOper == GT_ASG)
        return gcIsWriteBarrierCandidate(op->gtOp.gtOp1);
    else
        return false;
}

#else // No GC_WRITE_BARRIER support at all

/* static */ inline
unsigned            Compiler::gcIsWriteBarrierCandidate(GenTreePtr tree) { return false; }

/* static */ inline
bool                Compiler::gcIsWriteBarrierAsgNode(GenTreePtr op) { return false; }

#endif
#endif

inline
size_t              encodeUnsigned(BYTE *dest, unsigned value)
{
    size_t size = 1;
    if (value >= (1 << 28)) {
        if (dest)
            *dest++ =  (value >> 28)         | 0x80;
        size++;
    }
    if (value >= (1 << 21)) {
        if (dest)
            *dest++ = ((value >> 21) & 0x7f) | 0x80;
        size++;
    }
    if (value >= (1 << 14)) {
        if (dest)
            *dest++ = ((value >> 14) & 0x7f) | 0x80;
        size++;
    }
    if (value >= (1 <<  7)) {
        if (dest)
            *dest++ = ((value >>  7) & 0x7f) | 0x80;
        size++;
    }
    if (dest)
        *dest++ = value & 0x7f;
    return size;
}

inline
size_t              encodeUDelta(BYTE *dest, unsigned value, unsigned lastValue)
{
    assert(value >= lastValue);
    return encodeUnsigned(dest, value - lastValue);
}

inline
size_t              encodeSigned(BYTE *dest, int val)
{
    size_t   size  = 1;
    bool     neg   = (val < 0);
    unsigned value = (neg) ? -val : val;
    unsigned max   = 0x3f;
    while ((value > max) && ((max>>25) == 0)) {
        size++;
        max <<= 7;
    }
    if (dest) {
        // write the bytes starting at the end of dest in LSB to MSB order
        BYTE* p    = dest + size;
        bool  cont = false;      // The last byte has no continuation flag
        while (--p != dest) {
            *p  = (cont << 7) | (value & 0x7f);
            value >>= 7;
            cont = true;        // Non last bytes have a continuation flag
        }
        assert(p == dest);      // Now write the first byte
        *dest++ = (cont << 7) | (neg << 6) | (value& 0x3f);
    }
    return size;
}

inline void Compiler::saveLiveness(genLivenessSet * ls)
{

    ls->liveSet   = genCodeCurLife;
    ls->varPtrSet = gcVarPtrSetCur;
    ls->maskVars  = rsMaskVars;
    ls->gcRefRegs = gcRegGCrefSetCur;
    ls->byRefRegs = gcRegByrefSetCur;
}

inline void Compiler::restoreLiveness(genLivenessSet * ls)
{
    genCodeCurLife   = ls->liveSet;
    gcVarPtrSetCur   = ls->varPtrSet;
    rsMaskVars       = ls->maskVars;
    gcRegGCrefSetCur = ls->gcRefRegs;
    gcRegByrefSetCur = ls->byRefRegs;
}

inline void Compiler::checkLiveness(genLivenessSet * ls)
{
    assert(genCodeCurLife   == ls->liveSet);
    assert(gcVarPtrSetCur   == ls->varPtrSet);
    assert(rsMaskVars       == ls->maskVars);
    assert(gcRegGCrefSetCur == ls->gcRefRegs);
    assert(gcRegByrefSetCur == ls->byRefRegs);
}

#else //TRACK_GC_REFS

inline
void                Compiler::gcVarPtrSetInit  (){}

inline
void                Compiler::gcMarkRegSetGCref(regMaskTP   regMask){}
inline
void                Compiler::gcMarkRegSetByref(regMaskTP   regMask){}
inline
void                Compiler::gcMarkRegSetNpt  (regMaskTP  regMask){}
inline
void                Compiler::gcMarkRegPtrVal  (regNumber   reg,
                                                var_types   type){}

inline
void                Compiler::gcMarkRegPtrVal  (GenTreePtr  tree){}

#ifdef  DEBUG
inline
void                Compiler::gcRegPtrSetDisp  (unsigned    regMask,
                                                bool        fixed){}
#endif

inline
void                Compiler::gcRegPtrSetInit  (){}

#endif//TRACK_GC_REFS

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          CodeGenerator                                    XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************
 *
 *  Update the current set of live variables based on the life set recorded
 *  in the given expression tree node.
 */

inline
void                Compiler::genUpdateLife(GenTreePtr tree)
{
    if  (genCodeCurLife != tree->gtLiveSet)
        genChangeLife(tree->gtLiveSet DEBUGARG(tree));
}

inline
void                Compiler::genUpdateLife(VARSET_TP newLife)
{
    if  (genCodeCurLife != newLife)
        genChangeLife(newLife DEBUGARG(NULL));
}

inline
GenTreePtr          Compiler::genMarkLclVar(GenTreePtr tree)
{
    unsigned        varNum;
    LclVarDsc   *   varDsc;

    assert(tree->gtOper == GT_LCL_VAR);

    /* Does the variable live in a register? */

    varNum = tree->gtLclVar.gtLclNum;
    assert(varNum < lvaCount);
    varDsc = lvaTable + varNum;

    if  (varDsc->lvRegister)
        genBashLclVar(tree, varNum, varDsc);
    else
        tree = 0;

    return tree;
}

inline
void                Compiler::genFlagsEqualToNone()
{
    genFlagsEqReg = REG_NA;
    genFlagsEqVar = -1;
}

inline
GenTreePtr          Compiler::genIsAddrMode(GenTreePtr tree, GenTreePtr *indxPtr)
{
    bool            rev;
    unsigned        mul;
    unsigned        cns;
    GenTreePtr      adr;

    if  (genCreateAddrMode(tree,        // address
                           0,           // mode
                           false,       // fold
                           0,           // reg mask
#if!LEA_AVAILABLE
                           TYP_UNDEF,   // operand type
#endif
                           &rev,        // reverse ops
                           &adr,        // base addr
                           indxPtr,     // index val
#if SCALED_ADDR_MODES
                           &mul,        // scaling
#endif
                           &cns,        // displacement
                           true))       // don't generate code
        return  adr;
    else
        return  NULL;
}

/*****************************************************************************/

#if !TGT_x86

inline
void                Compiler::genChkFPregVarDeath(GenTreePtr stmt, bool saveTOS) {}

#else

inline
void                Compiler::genChkFPregVarDeath(GenTreePtr stmt, bool saveTOS)
{
    assert(stmt->gtOper == GT_STMT);

    if  (stmt->gtStmtFPrvcOut != genFPregCnt)
        genFPregVarKill(stmt->gtStmtFPrvcOut, saveTOS);

    assert(stmt->gtStmtFPrvcOut == genFPregCnt);
}

inline
void                Compiler::genFPregVarLoad(GenTreePtr tree)
{
    assert(tree->gtOper == GT_REG_VAR);

    /* Is the variable dying right here? */

    if  (tree->gtFlags & GTF_REG_DEATH)
    {
        /* The last living reference needs extra care */

        genFPregVarLoadLast(tree);
    }
    else
    {
        /* Simply push a copy of the variable on the FP stack */

        inst_FN(INS_fld, tree->gtRegNum + genFPstkLevel);
        genFPstkLevel++;
    }
}

/* Small helper to shift an FP stack register from the bottom of the stack to the top
 * genFPstkLevel specifies the number of values pushed on the stack */
inline
void                Compiler::genFPmovRegTop()
{
    unsigned        fpTmpLevel;

    assert(genFPstkLevel);

    /* If there are temps above our register (i.e bottom of stack) we have to bubble it up */

    if  (genFPstkLevel > 1)
    {
        /* Shift the result on top above 'genFPstkLevel-1' temps  - we never expect
         * to have more than two temps that's why the assert below, nevertheless
         * it works in the general case */

        assert(genFPstkLevel <= 3);

        for (fpTmpLevel = 1; fpTmpLevel < genFPstkLevel; fpTmpLevel++)
            inst_FN(INS_fxch, fpTmpLevel);
    }
}


/* Small helper to shift an FP stack register from the TOP of the stack to the BOTTOM
 * genFPstkLevel specifies the number of values pushed on the stack */
inline
void                Compiler::genFPmovRegBottom()
{
    int             fpTmpLevel;

    assert(genFPstkLevel);

    /* If the stack has more than one value bubble the top down */

    if  (genFPstkLevel > 1)
    {
        /* We will have to move the value from the top down 'genFPstkLevel-1'
         * positions which is equivalent to shift the 'genFPstkLevel-1' temps up */

        /* The loop below works for the general case but we don't expect to
         * ever have more than two temp + our variable on the stack */

        assert(genFPstkLevel <= 3);

        /* Shift the temps up and move the new value into the right place */

        for (fpTmpLevel = genFPstkLevel - 1; fpTmpLevel > 0; fpTmpLevel--)
            inst_FN(INS_fxch, fpTmpLevel);
    }
}

#endif

/*****************************************************************************
 *
 *  We stash cookies in basic blocks for the code emitter; this call retrieves
 *  the cookie associated with the given basic block.
 */

inline
void *  FASTCALL    emitCodeGetCookie(BasicBlock *block)
{
    assert(block);
    return block->bbEmitCookie;
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          Optimizer                                        XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************
 *
 *  The following determines whether the tree represents a copy assignment
 */

inline
bool                Compiler::optIsCopyAsg(GenTreePtr tree)
{
    if  (tree->gtOper == GT_ASG)
    {
        GenTreePtr op1 = tree->gtOp.gtOp1;
        GenTreePtr op2 = tree->gtOp.gtOp2;

        if  ((op1->gtOper == GT_LCL_VAR) &&
             (op2->gtOper == GT_LCL_VAR))
        {
            LclVarDsc * lv1 = &lvaTable[op1->gtLclVar.gtLclNum];
            LclVarDsc * lv2 = &lvaTable[op2->gtLclVar.gtLclNum];

             if ((lv1->lvType == lv2->lvType) &&
                 !lv1->lvAddrTaken            &&
                 !lv2->lvAddrTaken            &&
                 !lv1->lvVolatile             &&
                 !lv2->lvVolatile)
             {
                 return true;
             }
        }
    }
    return false;
}

/*****************************************************************************
 *
 *  The following determines whether the tree represents a constant
 *  assignment to a local variable (x = const)
 *  We only consider local variables of "actual" types
 *  INT, LONG, FLOAT and DOUBLE (i.e no REF, FNC, VOID, UNDEF, ...)
 */

inline
bool                Compiler::optIsConstAsg(GenTreePtr tree)
{
    if  (tree->gtOper == GT_ASG)
    {
        GenTreePtr op1 = tree->gtOp.gtOp1;
        GenTreePtr op2 = tree->gtOp.gtOp2;

        if  ((op1->gtOper == GT_LCL_VAR) &&
              op2->OperIsConst())
        {
            LclVarDsc * lv1 = &lvaTable[op1->gtLclVar.gtLclNum];
            size_t      sz  = genTypeSize((var_types)lv1->lvType);

             if ((op1->gtType == op2->gtType) &&
                 ((sz == 4) || (sz == 8))     &&  // ints, floats or doubles
                 !lv1->lvAddrTaken            &&
                 !lv1->lvVolatile             &&
                 (op2->gtOper != GT_CNS_STR))
             {
                 /* we have a constant assignment to a local var */

                 switch (genActualType(op1->gtType))
                 {
                 case TYP_INT:
                 case TYP_LONG:
                 case TYP_FLOAT:
                 case TYP_DOUBLE:
                     return true;
                 }

                 /* unsuported type - return false */
                 return false;
             }
        }
    }
    return false;
}

/*****************************************************************************/
#if HOIST_THIS_FLDS
/*****************************************************************************/

inline
void                Compiler::optHoistTFRrecDef(FIELD_HANDLE hnd, GenTreePtr tree)
{
    thisFldPtr      fld;
    var_types       typ;

    assert(tree->gtOper == GT_FIELD);

    if  (optThisFldDont)
        return;

#if INLINING
    // FIX NOW if  (eeGetFieldClass(tree->gtField.gtFldHnd) != eeGetMethodClass(info.compMethodHnd))
        return;
#endif

    /* Get the type of the value */

    typ = tree->TypeGet();

    /* Don't bother if this is not an integer or pointer */

    if  (typ != TYP_INT && typ != TYP_REF)
        return;

    /* Find/create an entry for this field */

    fld = optHoistTFRlookup(hnd);
    fld->tfrTree = tree;
    fld->tfrDef  = true;
}

inline
void                Compiler::optHoistTFRrecRef(FIELD_HANDLE hnd, GenTreePtr tree)
{
    thisFldPtr      fld;
    var_types       typ;

    assert(tree->gtOper == GT_FIELD);

    if  (optThisFldDont)
        return;

#if INLINING
    // FIX NOW if  (eeGetFieldClass(tree->gtField.gtFldHnd) != eeGetMethodClass(info.compMethodHnd))
        return;
#endif

    /* Get the type of the value */

    typ = tree->TypeGet();

    /* Don't bother if this is not an integer or pointer */

    if  (typ != TYP_INT && typ != TYP_REF)
        return;

    /* Find/create an entry for this field */

    fld = optHoistTFRlookup(hnd);
    fld->tfrTree = tree;
    fld->tfrUseCnt++;

    /* Mark the reference */

    tree->gtField.gtFldHTX = fld->tfrIndex;
}

inline
void                Compiler::optHoistTFRhasLoop()
{
    // UNDONE: Perform analysis after we've identified loops, so that
    // UNDONE: we can properly weight references inside loops.

    optThisFldLoop = true;
}

inline
GenTreePtr          Compiler::optHoistTFRreplace(GenTreePtr tree)
{
    thisFldPtr      fld;

    assert(tree->gtOper == GT_FIELD);
    assert(optThisFldDont == false);

    /* If the object is not "this", return */

    GenTreePtr      obj = tree->gtOp.gtOp1;
    if  (info.compIsStatic || obj->OperGet() != GT_LCL_VAR || obj->gtLclVar.gtLclNum != 0)
        return tree;

    /* Find an entry for this field */

    for (fld = optThisFldLst; fld; fld = fld->tfrNext)
    {
        if  (fld->tfrIndex == tree->gtField.gtFldHTX)
        {
            if  (!fld->tfrDef && fld->tfrTree != tree)
            {
                assert(fld->optTFRHoisted);
                assert(fld->tfrTempNum);

                /* Replace with a reference to the appropriate temp */

                tree = gtNewLclvNode(fld->tfrTempNum, tree->gtType);
            }

            break;
        }
    }

    return  tree;
}

inline
GenTreePtr          Compiler::optHoistTFRupdate(GenTreePtr tree)
{
    assert(tree->gtOper == GT_FIELD);

    return  optThisFldDont ? tree : optHoistTFRreplace(tree);
}

/*****************************************************************************/
#endif//HOIST_THIS_FLDS

inline
void                Compiler::LoopDsc::VERIFY_lpIterTree()
{
#ifdef DEBUG
    ASSert(lpFlags & LPFLG_ITER);

    //iterTree should be "lcl <op>= const"

    ASSert(lpIterTree);

    BYTE   operKind = GenTree::gtOperKindTable[lpIterTree->OperGet()];
    ASSert(operKind & GTK_ASGOP); // +=, -=, etc

    ASSert(lpIterTree->gtOp.gtOp1->OperGet() == GT_LCL_VAR);
    ASSert(lpIterTree->gtOp.gtOp2->OperGet() == GT_CNS_INT);
#endif
}

//-----------------------------------------------------------------------------

inline
unsigned            Compiler::LoopDsc::lpIterVar()
{
    VERIFY_lpIterTree();
    return lpIterTree->gtOp.gtOp1->gtLclVar.gtLclNum;
}

//-----------------------------------------------------------------------------

inline
long                Compiler::LoopDsc::lpIterConst()
{
    VERIFY_lpIterTree();
    return lpIterTree->gtOp.gtOp2->gtIntCon.gtIconVal;
}

//-----------------------------------------------------------------------------

inline
genTreeOps          Compiler::LoopDsc::lpIterOper()
{
    VERIFY_lpIterTree();
    return lpIterTree->OperGet();
}


inline
var_types           Compiler::LoopDsc::lpIterOperType()
{
    VERIFY_lpIterTree();

    var_types type = lpIterTree->TypeGet();
    ASSert(genActualType(type) == TYP_INT);

    if ((lpIterTree->gtFlags & GTF_UNSIGNED) && type == TYP_INT)
        type = TYP_UINT;

    return type;
}


inline
void                Compiler::LoopDsc::VERIFY_lpTestTree()
{
#ifdef DEBUG
    ASSert(lpFlags & LPFLG_SIMPLE_TEST);
    ASSert(lpTestTree);

    genTreeOps  oper = lpTestTree->OperGet();
    ASSert(GenTree::OperIsCompare(oper));

    ASSert(lpTestTree->gtOp.gtOp1->OperGet() == GT_LCL_VAR);
    if      (lpFlags & LPFLG_CONST_LIMIT)
        ASSert(lpTestTree->gtOp.gtOp2->OperIsConst());
    else if (lpFlags & LPFLG_VAR_LIMIT)
        ASSert(lpTestTree->gtOp.gtOp2->OperGet() == GT_LCL_VAR);
#endif
}

inline
genTreeOps          Compiler::LoopDsc::lpTestOper()
{
    VERIFY_lpTestTree();
    return lpTestTree->OperGet();
}

//-----------------------------------------------------------------------------

inline
long                Compiler::LoopDsc::lpConstLimit()
{
    VERIFY_lpTestTree();
    ASSert(lpFlags & LPFLG_CONST_LIMIT);

    ASSert(lpTestTree->gtOp.gtOp2->OperIsConst());
    return lpTestTree->gtOp.gtOp2->gtIntCon.gtIconVal;
}

//-----------------------------------------------------------------------------

inline
unsigned            Compiler::LoopDsc::lpVarLimit()
{
    VERIFY_lpTestTree();
    ASSert(lpFlags & LPFLG_VAR_LIMIT);

    ASSert(lpTestTree->gtOp.gtOp2->OperGet() == GT_LCL_VAR);
    return lpTestTree->gtOp.gtOp2->gtLclVar.gtLclNum;
}

/*****************************************************************************/

inline
bool                Compiler::optIsVarAssgLoop(unsigned lnum, long var)
{
    assert(lnum < optLoopCount);

    if  (var < VARSET_SZ)
        return  optIsSetAssgLoop(lnum, genVarIndexToBit(var)) != 0;
    else
        return  optIsVarAssigned(optLoopTable[lnum].lpHead->bbNext,
                                 optLoopTable[lnum].lpEnd,
                                 0,
                                 var);
}

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          EEInterface                                      XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

extern  var_types   JITtype2varType(JIT_types type);

#ifdef NOT_JITC
#include "ee_il_dll.hpp"
#else
// #include "ee_il_exe.hpp"     for now we don't care about perf, so they all go in .cpp
#endif

inline
METHOD_HANDLE       Compiler::eeFindHelper        (unsigned helper)
{
#ifdef NOT_JITC
    ASSert(helper < JIT_HELP_COUNT);

    /* Helpers are marked by the fact that they are odd numbers
     * force this to be an odd number (will shift it back to extract */

    return((METHOD_HANDLE) ((helper << 2) + 1));
#else
    return((METHOD_HANDLE) (-helper));
#endif
}

inline
JIT_HELP_FUNCS      Compiler::eeGetHelperNum      (METHOD_HANDLE  method)
{
#ifdef NOT_JITC
            // Helpers are marked by the fact that they are odd numbers
    if (!(((int) method) & 1))
        return(JIT_HELP_UNDEF);
    return((JIT_HELP_FUNCS) (((int) method) >> 2));
#else
    if ((((int) method) >= 0))  // must be negative to be a helper
        return(JIT_HELP_UNDEF);
    return((JIT_HELP_FUNCS) (-((int) method)));
#endif
}

//
// Note that we want to have two special FIELD_HANDLES that will both
// be consider non-Data Offset handles for both NOT_JITC and non NOT_JITC
//
// The special values that we use are -2 for FLD_GLOBAL_DS
//   and -4 for FLD_GLOBAL_FS
//
inline
FIELD_HANDLE       Compiler::eeFindJitDataOffs        (unsigned dataOffs)
{
#ifdef NOT_JITC
        // Data offsets are marked by the fact that they are odd numbers
        // force this to be an odd number (will shift it back to extract)
    return((FIELD_HANDLE) ((dataOffs << 1) + 1));
#else
        // Data offsets are marked by the fact that they are negative numbers
        // that are smaller than -7
        // The values -2 and -4 are reserved for
        // FLD_GLOBAL_DS and FLD_GLOBAL_FS
    return((FIELD_HANDLE) (-dataOffs - 8));
#endif
}

inline
int         Compiler::eeGetJitDataOffs        (FIELD_HANDLE  field)
{
#ifdef NOT_JITC
        // Data offsets are marked by the fact that they are odd numbers
        // and we must shift it back to extract
    if (!(((int) field) & 1))
        return(-1);
    return((((int) field) >> 1));
#else
        // Data offsets are marked by the fact that they are negative numbers
        // that are smaller than -7
        // The values -2 and -4 are reserved for
        // FLD_GLOBAL_DS and FLD_GLOBAL_FS
    if ((((int) field) > -8))
        return(-1);
    return((-((int) field) - 8));
#endif
}

inline
bool        jitStaticFldIsGlobAddr(FIELD_HANDLE fldHnd)
{
    return (fldHnd == FLD_GLOBAL_DS || fldHnd == FLD_GLOBAL_FS);
}

inline
bool                Compiler::eeIsNativeMethod      (METHOD_HANDLE method)
{
    return ((((int)method) & 0x2) == 0x2);
}

inline
METHOD_HANDLE       Compiler::eeMarkNativeTarget    (METHOD_HANDLE method)
{
    assert ((((int)method)& 0x3) == 0);
    return (METHOD_HANDLE)(((int)method)| 0x2);
}

inline
METHOD_HANDLE       Compiler::eeGetMethodHandleForNative (METHOD_HANDLE method)
{
    assert ((((int)method)& 0x3) == 0x2);
    return (METHOD_HANDLE)(((int)method)& ~0x3);
}

#if !INLINING

// When inlining, the class-handle passed in may be different than the
// currnent procedure's. It is oftern GenTree::gtCall.gtCallCLS. However
// this field is defined in GenTree only when INLINING. So to get this to
// compile, we make the preprocessor strip off any gtCall.gtCallCLS.

#define eeIsOurMethod(ctype,val,cls)        eeIsOurMethod(ctype,val,0)
#define eeGetCPfncinfo(cpx,cls,cpk,typ,opc) eeGetCPfncinfo(cpx,0,cpk,typ,opc)
#define eeGetMethodVTableOffset(cpx,cls)             eeGetMethodVTableOffset(cpx,0)
#define eeFindField(cpx,cls)           eeFindField(cpx)
#define eeGetInterfaceID(cpx,cls)             eeGetInterfaceID(cpx,0)
#define eeGetMethodName(ctype,val,cls,nam)     eeGetMethodName(ctype,val,0,nam)
#endif




/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                          Compiler                                         XX
XX                      Inline functions                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************
 *
 *  Allocate memory from the no-release allocator. All such memory will be
 *  freed up simulataneously at the end of the procedure
 */

#ifdef  FAST

inline
void  *  FASTCALL       Compiler::compGetMem(size_t sz)
{
    return  compAllocator->nraAlloc(sz);
}

#endif

/******************************************************************************
 *
 *  Roundup the allocated size so that if this memory block is aligned,
 *  then the next block allocated too will be aligned.
 *  The JIT will always try to keep all the blocks aligned.
 */

inline
void  *  FASTCALL       Compiler::compGetMemA(size_t sz)
{
    void * ptr = compAllocator->nraAlloc(roundUp(sz, sizeof(int)));

    // Verify that the current block is aligned. Only then will the next
    // block allocated be on an aligned boundary.
    assert((int(ptr) & (sizeof(int) - 1)) == 0);

    return ptr;
}

inline
void                    Compiler::compFreeMem(void * ptr)
{}

#define compFreeMem(ptr)   compFreeMem((void *)ptr)

/*****************************************************************************/
#endif //_COMPILER_HPP_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\compiler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           Compiler                                        XX
XX                                                                           XX
XX  Represents the method data we are currently JIT-compiling                XX
XX  An instance of this class is created for every method we JIT.            XX
XX  This contains all the info needed for the method. So allocating a        XX
XX  a new instance per method makes it thread-safe.                          XX
XX  It should be used to do all the memory management for the compiler run.  XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#ifndef _COMPILER_H_
#define _COMPILER_H_
/*****************************************************************************/

#include "opcode.h"
#include "block.h"
#include "instr.h"

#ifdef    LATE_DISASM
#include "DisAsm.h"
#endif

/* This is included here and not earlier as it needs the definition of "CSE"
 * which is defined in the section above */

#include "GenTree.h"

/*****************************************************************************/

#ifdef  DEBUG
#define DEBUGARG(x)         , x
#else
#define DEBUGARG(x)
#endif

/*****************************************************************************/

#if     TGT_IA64
struct  bitVectVars;
#define FLG_GLOBVAR 0x80000000
#endif

/*****************************************************************************/

const CLASS_HANDLE  REFANY_CLASS_HANDLE = (CLASS_HANDLE) -1;
const CLASS_HANDLE  BAD_CLASS_HANDLE    = (CLASS_HANDLE) -2;

/*****************************************************************************/

unsigned short      genVarBitToIndex(VARSET_TP bit);
VARSET_TP           genVarIndexToBit(unsigned  num);

unsigned            genLog2(unsigned           value);
unsigned            genLog2(unsigned __int64   value);

var_types           genActualType(varType_t    type);

/*****************************************************************************/

const unsigned      lclMAX_TRACKED  = VARSET_SZ;  // The # of vars we can track

const size_t        TEMP_MAX_SIZE   = sizeof(double);

/*****************************************************************************
 *                  Forward declarations
 */

struct  InfoHdr;        // defined in GCInfo.h

enum    GCtype;         // defined in emit.h
class   emitter;        // defined in emit.h

#if NEW_EMIT_ATTR
  enum emitAttr;        // defined in emit.h
#else
# define emitAttr          int
#endif
#define EA_UNKNOWN         ((emitAttr) 0)

#if TGT_IA64

class   Compiler;

struct  bvInfoBlk
{
    size_t          bvInfoSize;     // number of elements
    size_t          bvInfoBtSz;     // size of bitvector in bytes
    size_t          bvInfoInts;     // size of bitvector in NatUns units
    void        *   bvInfoFree;     // free bitvectors that can be reused
    Compiler    *   bvInfoComp;     // pointer to Compiler
};

typedef
struct regPrefDesc *regPrefList;

struct regPrefDesc
{
    regPrefList     rplNext;
    unsigned short  rplRegNum;
    unsigned short  rplBenefit;
};

#endif

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX   The big guy. The sections are currently organized as :                  XX
XX                                                                           XX
XX    o  GenTree and BasicBlock                                              XX
XX    o  LclVarsInfo                                                         XX
XX    o  Importer                                                            XX
XX    o  FlowGraph                                                           XX
XX    o  Optimizer                                                           XX
XX    o  RegAlloc                                                            XX
XX    o  EEInterface                                                         XX
XX    o  TempsInfo                                                           XX
XX    o  RegSet                                                              XX
XX    o  GCInfo                                                              XX
XX    o  Instruction                                                         XX
XX    o  ScopeInfo                                                           XX
XX    o  PrologScopeInfo                                                     XX
XX    o  CodeGenerator                                                       XX
XX    o  Compiler                                                            XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


class   Compiler
{
    friend  emitter;
    emitter       *         genEmitter;

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX  Misc structs definitions                                                 XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

public :

    typedef const char *    lvdNAME;        // Actual ASCII string

#ifdef DEBUG
    const char *            lvdNAMEstr(lvdNAME name) { return name; }
#endif

    // The following holds the Local var info (scope information)

    struct  LocalVarDsc
    {
        IL_OFFSET           lvdLifeBeg;     // IL offset of beg of life
        IL_OFFSET           lvdLifeEnd;     // IL offset of end of life
        unsigned            lvdVarNum;      // (remapped) LclVarDsc number

#ifdef DEBUG
        lvdNAME             lvdName;        // name of the var
#endif

        // @TODO : Remove for IL
        unsigned            lvdLVnum;       // 'which' in eeGetLVinfo()

    };

#ifdef  DEBUG
    const   char *      findVarName(unsigned varnum, BasicBlock * block);
#endif

    enum    ImplicitStmtOffsets
    {
        STACK_EMPTY_BOUNDARIES  = 0x01,
        CALL_SITE_BOUNDARIES    = 0x02,
        ALL_BOUNDARIES          = 0x04
    };

    struct  srcLineDsc
    {
        unsigned short      sldLineNum;
        IL_OFFSET           sldLineOfs;
    };

    // The following holds the table of exception handlers.

    struct  EHblkDsc
    {
        JIT_EH_CLAUSE_FLAGS ebdFlags;
        BasicBlock *        ebdTryBeg;  // First block of "try"
        BasicBlock *        ebdTryEnd;  // Block past the last block in "try"
        BasicBlock *        ebdHndBeg;  // First block of handler
        BasicBlock *        ebdHndEnd;  // Block past the last block of handler
        union {
            BasicBlock *    ebdFilter;  // First block of filter, if (ebdFlags & JIT_EH_CLAUSE_FILTER)
            unsigned        ebdTyp;     // Exception type,        otherwise
        };
    };

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                        GenTree and BasicBlock                             XX
XX                                                                           XX
XX  Functions to allocate and display the GenTrees and BasicBlocks           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


    // Functions to create nodes

    GenTreePtr FASTCALL     gtNewNode       (genTreeOps     oper,
                                             varType_t      type);

    GenTreePtr              gtNewStmt       (GenTreePtr     expr = NULL,
                                             IL_OFFSET      offset = BAD_IL_OFFSET);

    GenTreePtr              gtNewOperNode   (genTreeOps     oper);

    GenTreePtr              gtNewOperNode   (genTreeOps     oper,
                                             varType_t      type);

    GenTreePtr              gtNewOperNode   (genTreeOps     oper,
                                             varType_t      type,
                                             GenTreePtr     op1);

    GenTreePtr FASTCALL     gtNewOperNode   (genTreeOps     oper,
                                             varType_t      type,
                                             GenTreePtr     op1,
                                             GenTreePtr     op2);

    GenTreePtr FASTCALL     gtNewLargeOperNode(genTreeOps   oper,
                                             varType_t      type = TYP_INT,
                                             GenTreePtr     op1  = NULL,
                                             GenTreePtr     op2  = NULL);

    GenTreePtr FASTCALL     gtNewIconNode   (long           value,
                                             varType_t      type = TYP_INT);

    GenTreePtr              gtNewIconHandleNode(long        value,
                                             unsigned       flags,
                                             unsigned       handle1 = 0,
                                             void *         handle2 = 0);

    GenTreePtr              gtNewIconEmbHndNode(void *      value,
                                             void *         pValue,
                                             unsigned       flags,
                                             unsigned       handle1 = 0,
                                             void *         handle2 = 0);

    GenTreePtr              gtNewIconEmbScpHndNode (SCOPE_HANDLE    scpHnd, unsigned hnd1 = 0, void * hnd2 = 0);
    GenTreePtr              gtNewIconEmbClsHndNode (CLASS_HANDLE    clsHnd, unsigned hnd1 = 0, void * hnd2 = 0);
    GenTreePtr              gtNewIconEmbMethHndNode(METHOD_HANDLE  methHnd, unsigned hnd1 = 0, void * hnd2 = 0);
    GenTreePtr              gtNewIconEmbFldHndNode (FIELD_HANDLE    fldHnd, unsigned hnd1 = 0, void * hnd2 = 0);

    GenTreePtr FASTCALL     gtNewFconNode   (float          value);

    GenTreePtr FASTCALL     gtNewLconNode   (__int64 *      value);

    GenTreePtr FASTCALL     gtNewDconNode   (double *       value);

    GenTreePtr              gtNewSconNode   (int            CPX,
                                             SCOPE_HANDLE   scpHandle);

    GenTreePtr              gtNewZeroConNode(var_types      type);

    GenTreePtr              gtNewCallNode   (gtCallTypes    callType,
                                             METHOD_HANDLE  handle,
                                             varType_t      type,
                                             unsigned       flags,
                                             GenTreePtr     args);

    GenTreePtr              gtNewHelperCallNode(unsigned    helper,
                                             varType_t      type,
                                             unsigned       flags = 0,
                                             GenTreePtr     args = NULL);

    GenTreePtr FASTCALL     gtNewLclvNode   (unsigned       lnum,
                                             varType_t      type,
                                             unsigned       offs = BAD_IL_OFFSET);
#if INLINING
    GenTreePtr FASTCALL     gtNewLclLNode   (unsigned       lnum,
                                             varType_t      type,
                                             unsigned       offs = BAD_IL_OFFSET);
#endif
    GenTreePtr FASTCALL     gtNewClsvNode   (FIELD_HANDLE   fldHnd,
                                             varType_t      type);

    GenTreePtr FASTCALL     gtNewCodeRef    (BasicBlock *   block);

    GenTreePtr              gtNewFieldRef   (var_types      typ,
                                             FIELD_HANDLE   fldHnd,
                                             GenTreePtr     obj = NULL);

    GenTreePtr              gtNewIndexRef   (var_types      typ,
                                             GenTreePtr     adr,
                                             GenTreePtr     ind);

    GenTreePtr              gtNewArgList    (GenTreePtr     op);

    GenTreePtr              gtNewArgList    (GenTreePtr     op1,
                                             GenTreePtr     op2);

    GenTreePtr FASTCALL     gtNewAssignNode (GenTreePtr     dst,
                                             GenTreePtr     src);

    GenTreePtr              gtNewTempAssign (unsigned       tmp,
                                             GenTreePtr     val);

    GenTreePtr              gtNewDirectNStructField
                                            (GenTreePtr     objPtr,
                                             unsigned       fldIndex,
                                             var_types      lclTyp,
                                             GenTreePtr     assg);

    GenTreePtr              gtNewRefCOMfield(GenTreePtr     objPtr,
                                             unsigned       fldIndex,
                                             var_types      lclTyp,
                                             GenTreePtr     assg);
#if     OPTIMIZE_RECURSION
    GenTreePtr              gtNewArithSeries(unsigned       argNum,
                                             var_types      argTyp);
#endif
#if INLINING || OPT_BOOL_OPS || USE_FASTCALL
    GenTreePtr              gtNewNothingNode();
    bool                    gtIsaNothingNode(GenTreePtr     tree);
#endif

    GenTreePtr              gtUnusedValNode (GenTreePtr     expr);

    GenTreePtr              gtNewCastNode   (varType_t      typ,
                                             GenTreePtr     op1,
                                             GenTreePtr     op2);

    GenTreePtr              gtNewRngChkNode (GenTreePtr     tree,
                                             GenTreePtr     addr,
                                             GenTreePtr     indx,
                                             var_types      type,
                                             unsigned       elemSize);

    GenTreePtr              gtNewCpblkNode  (GenTreePtr     dest,
                                             GenTreePtr     src,
                                             GenTreePtr     blkShape);

     //------------------------------------------------------------------------
     // Other GenTree functions

    GenTreePtr              gtClone         (GenTree *      tree,
                                             bool           complexOK = false);

    GenTreePtr              gtCloneExpr     (GenTree *      tree,
                                             unsigned       addFlags = 0,
                                             unsigned       varNum   = (unsigned)-1,
                                             long           varVal   = 0);

    GenTreePtr FASTCALL     gtReverseCond   (GenTree *      tree);

    bool                    gtHasRef        (GenTree *      tree,
                                             int            lclNum,
                                             bool           defOnly);
#if RNGCHK_OPT || CSE
    unsigned                gtHashValue     (GenTree *      tree);
#endif

#if TGT_RISC
    unsigned                gtSetRArgOrder  (GenTree *      list,
                                             unsigned       regs);
#endif
    unsigned                gtSetListOrder  (GenTree *      list);
    unsigned                gtSetEvalOrder  (GenTree *      tree);

    void                    gtSetStmtInfo   (GenTree *      stmt);


    bool                    gtHasSideEffects(GenTreePtr     tree);

    void                    gtExtractSideEffList(GenTreePtr expr,
                                                 GenTreePtr * list);


    GenTreePtr              gtCrackIndexExpr(GenTreePtr     tree,
                                             GenTreePtr   * indxPtr,
                                             long         * indvPtr,
                                             long         * basvPtr,
                                             bool         * mvarPtr,
                                             long         * offsPtr,
                                             unsigned     * multPtr);

    //-------------------------------------------------------------------------

    GenTreePtr              gtFoldExpr      (GenTreePtr     tree);
    GenTreePtr              gtFoldExprConst (GenTreePtr     tree);
    GenTreePtr              gtFoldExprSpecial(GenTreePtr    tree);

    //-------------------------------------------------------------------------
    // Functions to display the trees

#ifdef DEBUG
    void                    gtDispNode      (GenTree *      tree,
                                             unsigned       indent  = 0,
                                             const char *   name    = NULL,
                                             bool           terse   = false);
    void                    gtDispTree      (GenTree *      tree,
                                             unsigned       indent  = 0,
                                             bool           topOnly = false);
    void                    gtDispTreeList  (GenTree *      tree);
#endif


    //=========================================================================
    // BasicBlock functions

    BasicBlock *            bbNewBasicBlock (BBjumpKinds     jumpKind);



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           LclVarsInfo                                     XX
XX                                                                           XX
XX   The variables to be used by the code generator.                         XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


    static int __cdecl      RefCntCmp(const void *op1, const void *op2);

/*****************************************************************************
 *
 *  The following holds the local variable counts and the descriptor table.
 */

    struct  LclVarDsc
    {
        unsigned short      lvVarIndex;     // variable tracking index

        int                 lvStkOffs;      // stack offset of home

        regNumberSmall      lvRegNum;       // used if lvRegister non-zero
        regNumberSmall      lvOtherReg;     // used for "other half" of long var

        unsigned            lvRefCntWtd;    //   weighted        reference count
//      unsigned            lvIntCnt;       // measure of interference
        unsigned short      lvRefCnt;       // unweighted (real) reference count

#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)
        unsigned short      lvSlotNum;      // original slot # (if remapped)
#endif

#if RNGCHK_OPT
        RNGSET_TP           lvRngDep;       // range checks that depend on us
#endif
#if CSE
        EXPSET_TP           lvExpDep;       // expressions  that depend on us
        EXPSET_TP           lvConstAsgDep;  // constant assignments that depend on us (i.e to this var)
        EXPSET_TP           lvCopyAsgDep;   // copy assignments that depend on us
#endif

#if USE_FASTCALL
        regNumberSmall      lvArgReg;       // the register in which this argument is passed
#endif

        unsigned char       lvType      :5; // TYP_INT/LONG/FLOAT/DOUBLE/REF
        unsigned char       lvIsParam   :1; // is this a parameter?
#if USE_FASTCALL
        unsigned char       lvIsRegArg  :1; // is this a register argument?
#endif
        unsigned char       lvIsThis    :1; // is it the 'this' parameter?
        unsigned char       lvFPbased   :1; // 0 = off of SP, 1 = off of FP
        unsigned char       lvOnFrame   :1; // (part of) variables live on frame
//      unsigned char       lvSmallRef  :1; // was there a byte/short ref?
        unsigned char       lvRegister  :1; // assigned to live in a register?
        unsigned char       lvTracked   :1; // is this a tracked variable?
        unsigned char       lvPinned    :1; // is this a pinned variable?
        unsigned char       lvMustInit  :1; // must be initialized
        unsigned char       lvVolatile  :1; // don't enregister
#if TGT_IA64
//      unsigned char       lvIsFlt     :1; // float/double variable
#endif
#if CSE
        unsigned char       lvRngOptDone:1; // considered for range check opt?
        unsigned char       lvLoopInc   :1; // incremented in the loop?
        unsigned char       lvLoopAsg   :1; // reassigned  in the loop?
        unsigned char       lvIndex     :1; // used as an array index?
        unsigned char       lvIndexOff  :1; // used as an array index with an offset?
        unsigned char       lvIndexDom  :1; // index dominates loop exit
#endif
#if GC_WRITE_BARRIER_CALL
        unsigned char       lvRefAssign :1; // involved in pointer assignment
#endif
#if FANCY_ARRAY_OPT
        unsigned char       lvAssignOne :1; // assigned at least  once?
        unsigned char       lvAssignTwo :1; // assigned at least twice?
#endif

        unsigned char       lvAddrTaken :1; // variable has its address taken?

#if OPT_BOOL_OPS
        unsigned char       lvNotBoolean:1; // set if variable is not boolean
#endif
        unsigned char       lvContextFul:1; // set if variable is contextful type

#if     TGT_IA64
        regNumberSmall      lvPrefReg;      // num of reg  it prefers to live in
        regPrefList         lvPrefLst;
#elif   TARG_REG_ASSIGN
        regMaskSmall        lvPrefReg;      // set of regs it prefers to live in
#endif

#if FANCY_ARRAY_OPT
        GenTreePtr          lvKnownDim;     // array size if known
#endif

#if TGT_IA64

        bitset128           lvRegForbidden; // regs the variable can't live in
        bitset128           lvRegInterfere; // regs the variable can't live in

        unsigned short      lvDefCount;     // weighted store count
        unsigned short      lvUseCount;     // weighted  use  count

#endif

        var_types           TypeGet()       { return (var_types) lvType; }
    };

/*****************************************************************************/


public :

    unsigned            lvaCount;           // total number of locals
    LclVarDsc   *       lvaTable;           // variable descriptor table
    unsigned            lvaTableCnt;        // lvaTable size (>= lvaCount)

    /* Info about the aggregate types (TYP_STRUCT and TYP_BLK) */

    struct  LclVarAggrInfo
    {
        union
        {
            unsigned        lvaiBlkSize;        // TYP_BLK
            CLASS_HANDLE    lvaiClassHandle;    // TYP_STRUCT
        };
    };

    LclVarAggrInfo  *   lvaAggrTableArgs;
    LclVarAggrInfo  *   lvaAggrTableLcls;
    LclVarAggrInfo  *   lvaAggrTableTemps;
    unsigned            lvaAggrTableTempsCount;
    void                lvaAggrTableTempsSet(unsigned temp, var_types type, SIZE_T val);
    LclVarAggrInfo  *   lvaAggrTableGet     (unsigned varNum);

    LclVarDsc   *   *   lvaRefSorted;       // table sorted by refcount

    unsigned            lvaTrackedCount;    // actual # of locals being tracked
    VARSET_TP           lvaTrackedVars;     // set of tracked variables

#ifdef DEBUGGING_SUPPORT
                        // table of only the tracked LclVarDsc's
    unsigned            lvaTrackedVarNums[lclMAX_TRACKED];
#endif

    VARSET_TP           lvaVarIntf[lclMAX_TRACKED];

#if TGT_x86
    unsigned            lvaFPRegVarOrder[FP_STK_SIZE];
#endif

#if DOUBLE_ALIGN
    unsigned            lvaDblRefsWeight; // ref count total of doubles
    unsigned            lvaLclRefsWeight;    // ref count total of all lclVars

#if defined(DEBUG) && !defined(NOT_JITC)
                        // # of procs compiled a with double-aligned stack
    static unsigned     s_lvaDoubleAlignedProcsCount;
#endif

#endif

    bool                lvaVarAddrTaken     (unsigned       varNum);

    unsigned            lvaScratchMemVar;               // dummy TYP_LCLBLK var for scratch space
    unsigned            lvaScratchMem;                  // amount of scratch frame memory for Ndirect calls

    /* These are used for the callable handlers */

    unsigned            lvaShadowSPfirstOffs;   // First slot to store base SP

    size_t              lvaFrameSize();

    //------------------------ For splitting types ----------------------------

    void                lvaInitTypeRef      ();

    static unsigned     lvaTypeRefMask      (varType_t      type);

    var_types           lvaGetType          (unsigned lclNum);
    var_types           lvaGetRealType      (unsigned lclNum);

    bool                lvaIsContextFul     (unsigned lclNum);
    //-------------------------------------------------------------------------

    void                lvaInit             ();

    size_t              lvaArgSize          (const void *   argTok);
    size_t              lvaLclSize          (unsigned       varNum);
        // If the class is a TYP_STRUCT, get a class handle describing it
    CLASS_HANDLE        lvaLclClass         (unsigned       varNum);

#if RNGCHK_OPT || CSE   // lclVars referenced by the 'tree'.
    VARSET_TP           lvaLclVarRefs       (GenTreePtr     tree,
                                             GenTreePtr  *  findPtr,
                                             unsigned    *  refsPtr);
#endif

    unsigned            lvaGrabTemp         ();

    unsigned            lvaGrabTemps        (unsigned cnt);

    void                lvaSortByRefCount   ();

    void                lvaMarkLocalVars    (); // Local variable ref-counting

    void                lvaMarkIntf         (VARSET_TP life, VARSET_TP varBit);

    VARSET_TP           lvaStmtLclMask      (GenTreePtr stmt);

    int                 lvaIncRefCnts       (GenTreePtr tree);
    static int          lvaIncRefCntsCB     (GenTreePtr tree, void *p);

    int                 lvaDecRefCnts       (GenTreePtr tree);
    static int          lvaDecRefCntsCB     (GenTreePtr tree, void *p);

    void                lvaAdjustRefCnts    ();

#ifdef  DEBUG
    void                lvaDispVarSet       (VARSET_TP set, int col);
#endif

#if TGT_IA64
    NatUns              lvaFrameAddress     (int varNum);
#else
    int                 lvaFrameAddress     (int varNum, bool *EBPbased);
#endif
    bool                lvaIsEBPbased       (int varNum);
    bool                lvaIsParameter      (int varNum);
#if USE_FASTCALL
    bool                lvaIsRegArgument    (int varNum);
#endif

    bool                lvaIsThisArg        (int varNum);

#if TGT_IA64
    void                lvaAddPrefReg       (LclVarDsc *dsc, regNumber reg, NatUns cost);
#endif

    //=========================================================================
    //                          PROTECTED
    //=========================================================================

    void                lvaAssignFrameOffsets(bool final);

protected:

#if TGT_IA64
public: // hack
#endif
    int                 lvaDoneFrameLayout;

protected :

    //---------------- Local variable ref-counting ----------------------------

    unsigned            lvaMarkRefsBBN;
    unsigned            lvaMarkRefsWeight;

    void                lvaMarkLclRefs          (GenTreePtr tree);
    static int          lvaMarkLclRefsCallback  (GenTreePtr tree,
                                                 void *     pCallBackData);




/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           Importer                                        XX
XX                                                                           XX
XX   Imports the given method and converts it to semantic trees              XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

public :

    void                impInit          ();

    void                impImport        (BasicBlock *    method);

#if INLINING
    GenTreePtr          impExpandInline  (GenTreePtr      tree,
                                          METHOD_HANDLE   fncHandle);
#endif


    //=========================================================================
    //                          PROTECTED
    //=========================================================================

protected :

    //-------------------- Stack manipulation ---------------------------------

    struct StackEntry
    {
        GenTreePtr      val;
        CLASS_HANDLE    structType;     // If its a TYP_STRUCT, additional type info
    };

    StackEntry       *  impStack;       // The stack
    unsigned            impStackSize;   // Size of the full stack
    unsigned            impStkDepth;    // current stack depth while importing
    StackEntry          impSmallStack[16];  // Use this array is possible


    struct SavedStack                   // used to save/restore stack contents.
    {
        unsigned        ssDepth;        // number of values on stack
        StackEntry  *   ssTrees;        // saved tree values
    };

    void                impPushOnStack      (GenTreePtr     tree);
    void                impPushOnStack      (GenTreePtr     tree,
                                             CLASS_HANDLE   structType);
    GenTreePtr          impPopStack         ();
    GenTreePtr          impPopStack         (CLASS_HANDLE&  structTypeRet);
    GenTreePtr          impStackTop         (unsigned       n = 0);
    void                impSaveStackState   (SavedStack *   savePtr,
                                             bool           copy);
    void                impRestoreStackState(SavedStack *   savePtr);

    var_types           impImportCall       (OPCODE         opcode,
                                             int            memberRef,
                                             GenTreePtr     newobjThis,
                                             bool           tailCall,
                                             unsigned     * pVcallTemp);

    // Must preserve the incoming arguments even though we are not using them directly
    // This is because of CEE_JMP which need them
    bool                impParamsUsed;

    //----------------- Manipulating the trees and stmts ----------------------

    GenTreePtr          impTreeList;        // Trees for the BB being imported
    GenTreePtr          impTreeLast;        // The last tree for the current BB

    void FASTCALL       impBeginTreeList    ();
    void                impEndTreeList      (BasicBlock *   block,
                                             GenTreePtr     stmt,
                                             GenTreePtr     lastStmt);
    void FASTCALL       impEndTreeList      (BasicBlock  *  block);
    void FASTCALL       impAppendStmt       (GenTreePtr     stmt);
    void FASTCALL       impInsertStmt       (GenTreePtr     stmt);
    void FASTCALL       impAppendTree       (GenTreePtr     tree,
                                             IL_OFFSET      offset);
    void FASTCALL       impInsertTree       (GenTreePtr     tree,
                                             IL_OFFSET      offset);
    GenTreePtr          impAssignTempGen    (unsigned       tmp,
                                             GenTreePtr     val);
    GenTreePtr          impAssignTempGen    (unsigned       tmpNum,
                                             GenTreePtr     val,
                                             CLASS_HANDLE structType);
    void                impAssignTempGenTop (unsigned       tmp,
                                             GenTreePtr     val);
    unsigned            impCloneStackValue  (GenTreePtr     tree);

    GenTreePtr          impAssignStruct     (GenTreePtr     dest,
                                             GenTreePtr     src,
                                             CLASS_HANDLE   clsHnd);
    GenTreePtr          impAssignStructPtr  (GenTreePtr     destAddr,
                                             GenTreePtr     src,
                                             CLASS_HANDLE   clsHnd);

    GenTreePtr          impGetStructAddr    (GenTreePtr     structVal,
                                             CLASS_HANDLE   clsHnd);
    GenTreePtr          impNormStructVal    (GenTreePtr     structVal,
                                             CLASS_HANDLE   clsHnd);
    void                impAddEndCatches    (BasicBlock *   callBlock,
                                             GenTreePtr     endCatches);


    //----------------- Importing the method ----------------------------------

#ifdef DEBUG
    unsigned            impCurOpcOffs;
    unsigned            impCurStkDepth;
    const char  *       impCurOpcName;

    // For displaying IL opcodes with generated native code (-n:B)
    GenTreePtr          impLastILoffsStmt;  // oldest stmt added for which we didnt not gtStmtLastILoffs
    void                impNoteLastILoffs       ();
#endif
    // IL offset of the stmt currently being imported. It gets updated
    // at IL offsets for which we have to report mapping info.
    IL_OFFSET           impCurStmtOffs;

    GenTreePtr          impCheckForNullPointer  (GenTreePtr     arr);

    GenTreePtr          impPopList              (unsigned       count,
                                                 unsigned *     flagsPtr,
                                                 GenTreePtr     treeList=0);

    GenTreePtr          impPopRevList           (unsigned       count,
                                                 unsigned *     flagsPtr);

    //---------------- Spilling the importer stack ----------------------------

    struct PendingDsc
    {
        PendingDsc *    pdNext;
        BasicBlock *    pdBB;
        SavedStack      pdSavedStack;
    };

    PendingDsc *        impPendingList; // list of BBs currently waiting to be imported.
    PendingDsc *        impPendingFree; // Freed up dscs that can be reused

    unsigned            impSpillLevel;

    void                impSpillStackEntry      (unsigned       level,
                                                 unsigned       varNum = BAD_VAR_NUM);
    void                impEvalSideEffects      ();
    void                impSpillGlobEffects     ();
    void                impSpillSpecialSideEff  ();
    void                impSpillSideEffects     (bool           spillGlobEffects = false);
    void                impSpillLclRefs         (int            lclNum);
#ifdef DEBUGGING_SUPPORT
    void                impSpillStmtBoundary    ();
#endif

    BasicBlock *        impMoveTemps            (BasicBlock *   block,
                                                 unsigned       baseTmp);

#if     OPTIMIZE_QMARK
    var_types           impBBisPush             (BasicBlock *   block,
                                                 int        *   boolVal,
                                                 bool       *   pHasFloat);

    bool                impCheckForQmarkColon   (BasicBlock *   block,
                                                 BasicBlock * * trueBlkPtr,
                                                 BasicBlock * * falseBlkPtr,
                                                 BasicBlock * * rsltBlkPtr,
                                                 var_types    * rsltTypPtr,
                                                 int          * isLogical,
                                                 bool         * pHasFloat);
    bool                impCheckForQmarkColon   (BasicBlock *   block);
#endif //OPTIMIZE_QMARK

    GenTreePtr          impGetCpobjHandle       (CLASS_HANDLE   clsHnd);

    GenTreePtr          impGetVarArg            (unsigned       lclNum,
                                                 CLASS_HANDLE   clsHnd);
    GenTreePtr          impGetVarArgAddr        (unsigned       lclNum);
    unsigned            impArgNum               (unsigned       ILnum); // map accounting for hidden args

    void                impImportBlockCode      (BasicBlock *   block);

    void                impImportBlockPending   (BasicBlock *   block,
                                                 bool           copyStkState);

    void                impImportBlock          (BasicBlock *   block);

    //--------------------------- Inlining-------------------------------------

#if INLINING
    unsigned            genInlineSize;          // max size for inlining

    unsigned            impInlineTemps;          // number of temps allocated when inlining
    GenTreePtr          impInitExpr;             // list of "statements" in a GT_COMMA chain

    void                impInlineSpillStackEntry  (unsigned     level);
    void                impInlineSpillSideEffects ();
    void                impInlineSpillLclRefs     (int          lclNum);

    GenTreePtr          impConcatExprs          (GenTreePtr     exp1,
                                                 GenTreePtr     exp2);
    GenTreePtr          impExtractSideEffect    (GenTreePtr     val,
                                                 GenTreePtr *   lstPtr);
#endif


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           FlowGraph                                       XX
XX                                                                           XX
XX   Info about the basic-blocks, their contents and the flow analysis       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    BasicBlock *        fgFirstBB;      // Beginning of the basic block list
    BasicBlock *        fgLastBB;       // End of the basic block list
    unsigned            fgBBcount;      // # of BBs in the procedure

    BasicBlock *        fgNewBasicBlock   (BBjumpKinds jumpKind);
    BasicBlock  *       fgPrependBB       (GenTreePtr tree);


#if     OPT_BOOL_OPS    // Used to detect multiple logical "not" assignments.
    bool                fgMultipleNots;
#endif

    bool                fgHasPostfix;   // any postfix ++/-- found?
    unsigned            fgIncrCount;    // number of increment nodes found

    bool                fgEmptyBlocks;  // true if some block become empty (due to statement removal)

#if RNGCHK_OPT
    bool                fgComputedDoms; // have we computed dominator sets?
#endif

#if RET_64BIT_AS_STRUCTS
    unsigned            fgRetArgNum;    // index of "retval addr" argument
    bool                fgRetArgUse;
#endif

    bool                fgStmtRemoved;  // true if we remove statements -> need new DFA

    // The following are boolean flags that keep track of the state of internal data structures
    // CONSIDER: make them DEBUG only if sure about the consistency of those structures

    bool                fgStmtListThreaded;

    bool                fgGlobalMorph;  // indicates if we are during the global morphing phase
                                        // since fgMorphTree can be called from several places

    //-------------------------------------------------------------------------

    void                fgInit            ();

    void                fgImport          ();

    bool                fgAddInternal     ();

    void                fgMorphStmts      (BasicBlock * block, GenTreePtr * pLast, GenTreePtr * pPrev,
                                           bool * mult, bool * lnot, bool * loadw);
    bool                fgMorphBlocks     ();

    void                fgSetOptions      ();

    void                fgMorph           ();

    void                fgPerBlockDataFlow();

    void                fgLiveVarAnalisys ();

    VARSET_TP           fgComputeLife     (VARSET_TP   life,
                                           GenTreePtr  startNode,
                                           GenTreePtr    endNode,
                                           VARSET_TP   notVolatile);

    void                fgGlobalDataFlow  ();

    int                 fgWalkTree        (GenTreePtr tree,
                                           int  (*  visitor)(GenTreePtr, void *),
                                           void  *  pCallBackData = NULL,
                                           bool     lclVarsOnly   = false);

    int                 fgWalkAllTrees    (int   (* visitor)(GenTreePtr, void*),
                                           void  *  pCallBackData);

    int                 fgWalkTreeDepth   (GenTreePtr tree,
                                           int  (*    visitor)(GenTreePtr, void *, bool),
                                           void  *    pCallBackData = NULL,
                                           genTreeOps prefixNode = GT_NONE);

    void                fgAssignBBnums    (bool updateNums  = false,
                                           bool updateRefs  = false,
                                           bool updatePreds = false,
                                           bool updateDoms  = false);

    bool                fgIsPredForBlock  (BasicBlock * block,
                                           BasicBlock * blockPred);

    void                fgRemovePred      (BasicBlock * block,
                                           BasicBlock * blockPred);

    void                fgReplacePred     (BasicBlock * block,
                                           BasicBlock * oldPred,
                                           BasicBlock * newPred);

    void                fgAddRefPred      (BasicBlock * block,
                                           BasicBlock * blockPred,
                                           bool updateRefs,
                                           bool updatePreds);

    int                 fgFindBasicBlocks ();

    unsigned            fgHandlerNesting  (BasicBlock * curBlock,
                                           unsigned   * pFinallyNesting = NULL);

    void                fgRemoveEmptyBlocks();

    void                fgRemoveStmt      (BasicBlock * block,
                                           GenTreePtr   stmt,
                                           bool updateRefCnt = false);

    void                fgCreateLoopPreHeader(unsigned  lnum);

    void                fgRemoveBlock     (BasicBlock * block,
                                           BasicBlock * bPrev,
                                           bool         updateNums = false);

    void                fgCompactBlocks   (BasicBlock * block,
                                           bool         updateNums = false);

    void                fgUpdateFlowGraph ();

    bool                fgIsCodeAdded     ();

    void                fgFindOperOrder   ();

    void                fgSetBlockOrder   ();

    unsigned            fgGetRngFailStackLevel(BasicBlock *block);

    /* The following check for loops that don't execute calls */

#if RNGCHK_OPT

    bool                fgLoopCallMarked;

    void                fgLoopCallTest    (BasicBlock *srcBB,
                                           BasicBlock *dstBB);
    void                fgLoopCallMark    ();

#endif

    void                fgMarkLoopHead    (BasicBlock *   block);

#ifdef DEBUG
    void                fgDispPreds       (BasicBlock * block);
    void                fgDispDoms        ();
    void                fgDispBasicBlocks (bool dumpTrees = false);
    void                fgDebugCheckBBlist();
    void                fgDebugCheckLinks ();
    void                fgDebugCheckFlags (GenTreePtr   tree);
#endif

    bool                fgBlockHasPred    (BasicBlock * block,
                                           BasicBlock * ignore,
                                           BasicBlock * beg,
                                           BasicBlock * end);

    static void         fgOrderBlockOps   (GenTreePtr   tree,
                                           unsigned     reg0,
                                           unsigned     reg1,
                                           unsigned     reg2,
                                           GenTreePtr   opsPtr [],  // OUT
                                           unsigned     regsPtr[]); // OUT

    /**************************************************************************
     *                          PROTECTED
     *************************************************************************/

protected :

    //-------------  Used for hoisting of ++/-- operators ---------------------

    GenTreePtr          fgMorphStmt;

    void                fgHoistPostfixOps ();

    static
    int                 fgHoistPostfixCB  (GenTreePtr     tree,
                                           void *         p,
                                           bool           prefix);

    bool                fgHoistPostfixOp  (GenTreePtr     stmt,
                                           GenTreePtr     expr);

    //--------------------- Detect the basic blocks ---------------------------

    BasicBlock *    *   fgBBs;      // Table of pointers to the BBs

    void                fgInitBBLookup    ();
    BasicBlock *        fgLookupBB        (unsigned       addr);

    void                fgMarkJumpTarget  (BYTE *         jumpTarget,
                                           unsigned       offs);
    void                fgMarkJumpTarget  (BasicBlock *   srcBB,
                                           BasicBlock *   dstBB);
    void                irFindJumpTargets (const BYTE *   codeAddr,
                                           size_t         codeSize,
                                           BYTE *         jumpTarget);

    void                fgFindBasicBlocks (const BYTE *   codeAddr,
                                           size_t         codeSize,
                                           BYTE *         jumpTarget);
    static BasicBlock * fgSkipRmvdBlocks  (BasicBlock *   block);


    //-------- Insert a statement at the start or end of a basic block --------

    void                fgInsertStmtAtEnd (BasicBlock   * block,
                                           GenTreePtr     stmt);
    void                fgInsertStmtNearEnd(BasicBlock *  block,
                                           GenTreePtr     stmt);
    void                fgInsertStmtAtBeg (BasicBlock   * block,
                                           GenTreePtr     stmt);

    //-------- Determine the order in which the trees will be evaluated -------

    unsigned            fgTreeSeqNum;
    GenTree *           fgTreeSeqLst;
    GenTree *           fgTreeSeqBeg;

    void                fgSetTreeSeq      (GenTree    *   tree);
    void                fgSetStmtSeq      (GenTree    *   tree);
    void                fgSetBlockOrder   (BasicBlock *   block);

#if TGT_x86

    bool                fgFPstLvlRedo;
    void                fgComputeFPlvls   (GenTreePtr     tree);

#endif

    //------------------------- Morphing --------------------------------------

    unsigned            fgPtrArgCntCur;
    unsigned            fgPtrArgCntMax;

#if CSELENGTH
    bool                fgHasRangeChks;
#endif

    GenTreePtr          fgStoreFirstTree    (BasicBlock *   block,
                                             GenTree    *   tree);
#if RNGCHK_OPT
    BasicBlock *        fgRngChkTarget      (BasicBlock *   block,
                                             unsigned       stkDepth);
#else
    BasicBlock *        fgRngChkTarget      (BasicBlock *   block);
#endif

#if OPTIMIZE_TAIL_REC
    void                fgCnvTailRecArgList (GenTreePtr *   argsPtr);
#endif

#if REARRANGE_ADDS
    void                fgMoveOpsLeft       (GenTreePtr     tree);
#endif

#if TGT_IA64
    GenTreePtr          fgMorphFltBinop     (GenTreePtr     tree,
                                             int            helper);
#endif

    GenTreePtr          fgMorphIntoHelperCall(GenTreePtr    tree,
                                             int            helper,
                                             GenTreePtr     args);
    GenTreePtr          fgMorphCast         (GenTreePtr     tree);
    GenTreePtr          fgMorphLongBinop    (GenTreePtr     tree,
                                             int            helper);
    GenTreePtr          fgMorphArgs         (GenTreePtr     call);
    GenTreePtr          fgMorphLocalVar     (GenTreePtr tree,
                                             bool checkLoads);

    GenTreePtr          fgMorphField        (GenTreePtr     tree);
    GenTreePtr          fgMorphCall         (GenTreePtr     call);
    GenTreePtr          fgMorphLeaf         (GenTreePtr     tree);
    GenTreePtr          fgMorphSmpOp        (GenTreePtr     tree);
    GenTreePtr          fgMorphConst        (GenTreePtr     tree);

    GenTreePtr          fgMorphTree         (GenTreePtr     tree);


#if CSELENGTH
    static
    int                 fgRemoveExprCB      (GenTreePtr     tree,
                                             void         * p);
    void                fgRemoveSubTree     (GenTreePtr     tree,
                                             GenTreePtr     list,
                                             bool           dead = false);
#endif

    //----------------------- Liveness analysis -------------------------------

    VARSET_TP           fgCurUseSet;
    VARSET_TP           fgCurDefSet;

    void                fgMarkUseDef(GenTreePtr tree, bool asgLclVar = false, GenTreePtr op1 = 0);

#ifdef DEBUGGING_SUPPORT
    VARSET_TP           fgLiveCb;

    static void         fgBeginScopeLife(LocalVarDsc * var, unsigned clientData);
    static void         fgEndScopeLife  (LocalVarDsc * var, unsigned clientData);

    void                fgExtendDbgLifetimes();
#endif

    //-------------------------------------------------------------------------
    //
    //  The following keeps track of any code we've added for things like array
    //  range checking or explicit calls to enable GC, and so on.
    //

    enum        addCodeKind
    {
        ACK_NONE,
        ACK_RNGCHK_FAIL,                // target when range check fails
        ACK_PAUSE_EXEC,                 // target to stop (e.g. to allow GC)
        ACK_ARITH_EXCPN,                // target on arithmetic exception
        ACK_OVERFLOW = ACK_ARITH_EXCPN, // target on overflow
        ACK_COUNT
    };

    struct      AddCodeDsc
    {
        AddCodeDsc  *   acdNext;
        BasicBlock  *   acdDstBlk;      // block  to  which we jump
        unsigned        acdData;
        addCodeKind     acdKind;        // what kind of a label is this?
#if TGT_x86
        unsigned short  acdStkLvl;
#endif
    };

    AddCodeDsc  *       fgAddCodeList;
    bool                fgAddCodeModf;
    AddCodeDsc  *       fgExcptnTargetCache[ACK_COUNT];

    BasicBlock *        fgAddCodeRef    (BasicBlock *   srcBlk,
                                         unsigned       refData,
                                         addCodeKind    kind,
                                         unsigned       stkDepth = 0);
    AddCodeDsc  *       fgFindExcptnTarget(addCodeKind  kind,
                                         unsigned       refData);


    //--------------------- Walking the trees in the IR -----------------------

    int              (* fgWalkVisitorFn)(GenTreePtr,    void *);
    void *              fgWalkCallbackData;
    bool                fgWalkLclsOnly;

    int              (* fgWalkVisitorDF)(GenTreePtr,    void *, bool);
    genTreeOps          fgWalkPrefixNode;

    int                 fgWalkTreeRec   (GenTreePtr     tree);
    int                 fgWalkTreeDepRec(GenTreePtr     tree);

    //------ The following must be used for recursive calls to fgWalkTree -----

    #define fgWalkTreeReEnter()                                     \
                                                                    \
    int    (*saveCF)(GenTreePtr, void *) = fgWalkVisitorFn;         \
    void    *saveCD                      = fgWalkCallbackData;      \
    bool     saveCL                      = fgWalkLclsOnly;

    #define fgWalkTreeRestore()                                     \
                                                                    \
    fgWalkVisitorFn    = saveCF;                                    \
    fgWalkCallbackData = saveCD;                                    \
    fgWalkLclsOnly     = saveCL;

    //--------------- The following are used when copying trees ---------------

#if CSELENGTH
    GenTreePtr          gtCopyAddrVal;
    GenTreePtr          gtCopyAddrNew;
#endif

    //-----------------------------------------------------------------------------
    //
    //  The following keeps track of the currently expanded inline functions.
    //  Any method currently on the list should not be inlined since that
    //  implies that it's being called recursively.
    //

#if INLINING

    typedef
    struct      inlExpLst
    {
        inlExpLst *     ixlNext;
        METHOD_HANDLE   ixlMeth;
    }
              * inlExpPtr;

    inlExpPtr           fgInlineExpList;

#endif//INLINING



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           Optimizer                                       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#if TGT_IA64
public:
    bvInfoBlk           bvInfoBlks;
    bvInfoBlk           bvInfoVars;
#endif

public :

    void            optInit            ();

protected :

    LclVarDsc    *  optIsTrackedLocal  (GenTreePtr tree);

    void            optRemoveRangeCheck(GenTreePtr tree, GenTreePtr stmt);



    /**************************************************************************
     *                          optHoist "this"
     *************************************************************************/

#if HOIST_THIS_FLDS

public :

    void                optHoistTFRinit    ();
    void                optHoistTFRprep    ();
    void                optHoistTFRhasCall () {  optThisFldDont = true; }
    void                optHoistTFRasgThis () {  optThisFldDont = true; }
    void                optHoistTFRhasLoop ();
    void                optHoistTFRrecRef  (FIELD_HANDLE hnd, GenTreePtr tree);
    void                optHoistTFRrecDef  (FIELD_HANDLE hnd, GenTreePtr tree);
    GenTreePtr          optHoistTFRupdate  (GenTreePtr tree);

protected :

    typedef struct  thisFldRef
    {
        thisFldRef *    tfrNext;
        FIELD_HANDLE    tfrField;
        GenTreePtr      tfrTree;

#ifndef NDEBUG
        bool            optTFRHoisted;
#endif
        unsigned short  tfrUseCnt   :8;
        unsigned short  tfrIndex    :7;
        unsigned short  tfrDef      :1;
        unsigned short  tfrTempNum  :16;
    }
      * thisFldPtr;

    thisFldPtr          optThisFldLst;
    unsigned            optThisFldCnt;
    bool                optThisFldDont;
    bool                optThisFldLoop;

    thisFldPtr          optHoistTFRlookup  (FIELD_HANDLE hnd);
    GenTreePtr          optHoistTFRreplace (GenTreePtr tree);

#endif // HOIST_THIS_FLDS

    /* The following set if the 'this' pointer is modified in the method */

    bool                optThisPtrModified;

    /**************************************************************************
     *
     *************************************************************************/

protected:

    void                optHoistLoopCode();

    bool                optIsTreeLoopInvariant(unsigned        lnum,
                                               BasicBlock  *   top,
                                               BasicBlock  *   bottom,
                                               GenTreePtr      tree);

private:

    static
    int                 optHoistLoopCodeCB   (GenTreePtr    tree,
                                              void *        p,
                                              bool          prefix);

    int                 optFindHoistCandidate(unsigned      lnum,
                                              unsigned      lbeg,
                                              unsigned      lend,
                                              BasicBlock *  block,
                                              GenTreePtr *  hoistxPtr);

protected:
    void                optOptimizeIncRng();
private:
    static
    int                 optIncRngCB(GenTreePtr tree, void *p);

public:
    void                optOptimizeBools();
private:
    GenTree *           optIsBoolCond(GenTree *   cond,
                                      GenTree * * compPtr,
                                      bool      * valPtr);

public :

    void                optOptimizeLoops ();    // for "while-do" loops duplicates simple loop conditions and transforms
                                                // the loop into a "do-while" loop
                                                // Also finds all natural loops and records them in the loop table

    void                optUnrollLoops   ();    // Unrolls loops (needs to have cost info)

protected :

    struct  LoopDsc
    {
        BasicBlock *        lpHead;     // HEAD of the loop (block before loop TOP)
        BasicBlock *        lpEnd;      // loop BOTTOM (from here we have the back edge to the TOP)
        BasicBlock *        lpEntry;    // the ENTRY in the loop (in most cases TOP or BOTTOM)
        BasicBlock *        lpExit;     // if a single exit loop this is the EXIT (in most cases BOTTOM)

        unsigned char       lpExitCnt;  // number of exits from the loop

        unsigned char       lpAsgCall;  // "callIntf" for calls in the loop
        VARSET_TP           lpAsgVars;  // set of vars assigned within the loop
        unsigned char       lpAsgInds;  // set of inds modified within the loop

        unsigned short      lpFlags;

#define LPFLG_DO_WHILE      0x0001      // it's a do-while loop (i.e ENTRY is at the TOP)
#define LPFLG_ONE_EXIT      0x0002      // the loop has only one exit

#define LPFLG_ITER          0x0004      // for (i = icon or lclVar;xxxxxx ; i++) - the test condition is a single comaprisson
#define LPFLG_SIMPLE_TEST   0x0008      // Iterative loop (as above), but the test condition is a simple comparisson
                                        // between the iterator and something simple (e.g. i < icon or lclVar or instanceVar)
#define LPFLG_CONST         0x0010      // for (i=icon;i<icon;i++){ ... } - constant loop

#define LPFLG_VAR_INIT      0x0020      // iterator is initialized with a local var (var # found in lpVarInit)
#define LPFLG_CONST_INIT    0x0040      // iterator is initialized with a constant (found in lpConstInit)

#define LPFLG_VAR_LIMIT     0x0080      // for a simple test loop (LPFLG_SIMPLE_TEST) iterator is compared
                                        // with a local var (var # found in lpVarLimit)
#define LPFLG_CONST_LIMIT   0x0100      // for a simple test loop (LPFLG_SIMPLE_TEST) iterator is compared
                                        // with a constant (found in lpConstLimit)

#define LPFLG_HAS_PREHEAD   0x0800      // the loop has a pre-header (HEAD is a BBJ_NONE)
#define LPFLG_REMOVED       0x1000      // has been removed from the loop table (unrolled or optimized away)
#define LPFLG_DONT_UNROLL   0x2000      // do not unroll this loop

#define LPFLG_ASGVARS_YES   0x4000      // "lpAsgVars" has been  computed
#define LPFLG_ASGVARS_BAD   0x8000      // "lpAsgVars" cannot be computed

        /* The following values are set only for iterator loops, i.e. has the flag LPFLG_ITER set */

        GenTreePtr          lpIterTree;     // The "i <op>= const" tree
        unsigned            lpIterVar  ();  // iterator variable #
        long                lpIterConst();  // the constant with which the iterator is incremented
        genTreeOps          lpIterOper ();  // the type of the operation on the iterator (ASG_ADD, ASG_SUB, etc.)
        void                VERIFY_lpIterTree();

        var_types           lpIterOperType();// For overflow instructions

        union
        {
            long            lpConstInit;  // initial constant value of iterator                           : Valid if LPFLG_CONST_INIT
            unsigned short  lpVarInit;    // initial local var number to which we initialize the iterator : Valid if LPFLG_VAR_INIT
        };

        /* The following is for LPFLG_SIMPLE_TEST loops only (i.e. the loop condition is "i RELOP const or var" */

        GenTreePtr          lpTestTree;   // pointer to the node containing the loop test
        genTreeOps          lpTestOper(); // the type of the comparisson between the iterator and the limit (GT_LE, GT_GE, etc.)
        void                VERIFY_lpTestTree();

        long                lpConstLimit(); // limit   constant value of iterator - loop condition is "i RELOP const" : Valid if LPFLG_CONST_LIMIT
        unsigned            lpVarLimit();   // the lclVar # in the loop condition ( "i RELOP lclVar" )                : Valid if LPFLG_VAR_LIMIT

    };

    struct  LoopDsc     optLoopTable[MAX_LOOP_NUM]; // loop descriptor table
    unsigned            optLoopCount;               // number of tracked loops

#ifdef DEBUG
    void                optCheckPreds      ();
#endif

    void                optRecordLoop      (BasicBlock * head,
                                            BasicBlock * tail,
                                            BasicBlock * entry,
                                            BasicBlock * exit,
                                            unsigned char exitCnt);

    void                optFindNaturalLoops();

    unsigned            optComputeLoopRep  (long        constInit,
                                            long        constLimit,
                                            long        iterInc,
                                            genTreeOps  iterOper,
                                            var_types   iterType,
                                            genTreeOps  testOper,
                                            bool        unsignedTest);

    VARSET_TP           optAllFloatVars;// mask of all tracked      FP variables
    VARSET_TP           optAllFPregVars;// mask of all enregistered FP variables
    VARSET_TP           optAllNonFPvars;// mask of all tracked  non-FP variables

private:
    static
    int                 optIsVarAssgCB  (GenTreePtr tree, void *p);
protected:
    bool                optIsVarAssigned(BasicBlock *   beg,
                                         BasicBlock *   end,
                                         GenTreePtr     skip,
                                         long           var);

    bool                optIsVarAssgLoop(unsigned       lnum,
                                         long           var);

    int                 optIsSetAssgLoop(unsigned       lnum,
                                         VARSET_TP      vars,
                                         unsigned       inds = 0);

    bool                optNarrowTree   (GenTreePtr     tree,
                                         var_types      srct,
                                         var_types      dstt,
                                         bool           doit);

    /**************************************************************************
     *                          Code Motion
     *************************************************************************/

#ifdef CODE_MOTION

public :

    void                optLoopCodeMotion();

protected :

    // Holds the set of variables live on exit (during loop code motion).

    VARSET_TP           optLoopLiveExit;

    // Holds the set of variables that current part of the loop depends on.

#if !RMV_ENTIRE_LOOPS_ONLY
    VARSET_TP           optLoopCondTest;
#endif

    // Holds the set of variables assigned within the current loop.

    VARSET_TP           optLoopAssign;

#if RMV_ENTIRE_LOOPS_ONLY
    #define             optFindLiveRefs(tree, used, cond) optFindLiveRefs(tree)
#endif
    bool                optFindLiveRefs(GenTreePtr tree, bool used, bool cond);

#endif


    /**************************************************************************
     *                          CSE
     *************************************************************************/

#if CSE

public :

    void                optOptimizeCSEs();

protected :

    unsigned            optCSEweight;

    // The following holds the set of expressions that contain indirections.

    EXPSET_TP           optCSEindPtr;       // CSEs which use an indirect pointer
    EXPSET_TP           optCSEindScl;       // CSEs which use an indirect scalar
    EXPSET_TP           optCSEglbRef;       // CSEs which use a  global   pointer
    EXPSET_TP           optCSEaddrTakenVar; // CSEs which use an aliased variable

    // The following logic keeps track of expressions via a simple hash table.

    struct  CSEdsc
    {
        CSEdsc *        csdNextInBucket;    // used by the hash table

        unsigned        csdHashValue;       // to make matching faster

        unsigned short  csdIndex;           // 1..optCSEcount
        unsigned short  csdVarNum;          // assigned temp number or 0xFFFF

        unsigned short  csdDefCount;        // definition   count
        unsigned short  csdUseCount;        // use          count

        unsigned        csdDefWtCnt;        // weighted def count
        unsigned        csdUseWtCnt;        // weighted use count

//      unsigned short  csdNewCount;        // 'updated' use count
//      unsigned short  csdNstCount;        //  'nested' use count

        GenTreePtr      csdTree;            // the array index tree
        GenTreePtr      csdStmt;            // stmt containing the 1st occurance
        BasicBlock  *   csdBlock;           // block containing the 1st occurance

        treeStmtLstPtr  csdTreeList;        // list of matching tree nodes: head
        treeStmtLstPtr  csdTreeLast;        // list of matching tree nodes: tail
    };

    // This enumeration describes what is killed by a call.

    enum    callInterf
    {
        CALLINT_NONE,                       // no interference (most helpers)
        CALLINT_INDIRS,                     // kills indirections (array addr store)
        CALLINT_ALL,                        // kills everything (method call)
    };

    static const size_t s_optCSEhashSize;
    CSEdsc   *   *      optCSEhash;
    CSEdsc   *   *      optCSEtab;
    unsigned            optCSEcount;

    bool                optIsCSEcandidate(GenTreePtr tree);
    void                optCSEinit     ();
    void                optCSEstop     ();
    CSEdsc   *          optCSEfindDsc  (unsigned index);
    int                 optCSEindex    (GenTreePtr tree, GenTreePtr stmt);
    static int          optUnmarkCSEs  (GenTreePtr tree, void * pCallBackData);
    static int __cdecl  optCSEcostCmp  (const void *op1, const void *op2);
    void                optCSEDecRefCnt(GenTreePtr tree, BasicBlock *block);
    static callInterf   optCallInterf  (GenTreePtr call);

#endif


    /**************************************************************************
     *               Constant propagation (currently is #ifdef CSE)
     *************************************************************************/

#if CSE

public :
    void                optCopyConstProp();

    bool                optConditionFolded;   // set to true if we folded any conditional
                                              // indicates that flow graph changed

    bool                optConstPropagated;   // set to true if we propagated any constant
                                              // indicates that the initial assignment is dead (need new DFA)

    void                optRemoveRangeChecks();
private:
    static
    int                 optFindRangeOpsCB(GenTreePtr tree, void *p);

protected :
    unsigned            optConstAsgCount;     // total number of constant assignments

    // data structures for constant assignments x = const, where x is a local variable

    struct constExpDsc
    {
        unsigned        constLclNum;        // local var number
        union
        {
            long        constIval;          // integer
            __int64     constLval;          // long
            float       constFval;          // float
            double      constDval;          // double
        };
    };

    constExpDsc         optConstAsgTab[EXPSET_SZ];      // table that holds info about constant assignments

    void                optCopyConstAsgInit();

    bool                optIsConstAsg(GenTreePtr tree);
    int                 optConstAsgIndex(GenTreePtr tree);
    bool                optPropagateConst(EXPSET_TP exp, GenTreePtr tree);

    /**************************************************************************
     *                         Copy Propagation
     *************************************************************************/

public :
    bool                optCopyPropagated;    // set to true if we propagated a copy
                                              // variable refCnt has changed - need new DFA
protected :
    unsigned            optCopyAsgCount;      // total number of copy assignments

    // data structures for copy assignments x = y, where x and y are local variables

    struct copyAsgDsc
    {
        unsigned        leftLclNum;           // left  side local var number (x)
        unsigned        rightLclNum;          // right side local var number (y)
    };

    copyAsgDsc          optCopyAsgTab[EXPSET_SZ];      // table that holds info about copy assignments

#define MAX_COPY_PROP_TAB   EXPSET_SZ

    bool                optIsCopyAsg(GenTreePtr tree);
    int                 optCopyAsgIndex(GenTreePtr tree);
    bool                optPropagateCopy(EXPSET_TP exp, GenTreePtr tree); // propagates a copy of a local variable

#endif


    /**************************************************************************
     *                          Range checks
     *************************************************************************/

#if RNGCHK_OPT

public :

    void                optOptimizeIndexChecks();

#if COUNT_RANGECHECKS
    static unsigned     optRangeChkRmv;
    static unsigned     optRangeChkAll;
#endif

protected :

    struct  RngChkDsc
    {
        RngChkDsc *     rcdNextInBucket;    // used by the hash table

        unsigned        rcdHashValue;       // to make matching faster
        unsigned        rcdIndex;           // 0..optRngChkCount-1

        GenTreePtr      rcdTree;            // the array index tree
    };

    unsigned            optRngChkCount;
    static const size_t optRngChkHashSize;

    RNGSET_TP           optRngIndPtr;       // RngChecks which use an indirect pointer
    RNGSET_TP           optRngIndScl;       // RngChecks which use an indirect scalar
    RNGSET_TP           optRngGlbRef;       // RngChecks which use a  global   pointer
    RNGSET_TP           optRngAddrTakenVar; // RngChecks which use an aliased variable

    RngChkDsc   *   *   optRngChkHash;

    void                optRngChkInit      ();
    int                 optRngChkIndex     (GenTreePtr tree);
    GenTreePtr    *     optParseArrayRef   (GenTreePtr tree,
                                            GenTreePtr *pmul,
                                            GenTreePtr *parrayAddr);
    GenTreePtr          optFindLocalInit   (BasicBlock *block,
                                            GenTreePtr local);
#if FANCY_ARRAY_OPT
    bool                optIsNoMore        (GenTreePtr op1, GenTreePtr op2,
                                            int add1 = 0,   int add2 = 0);
#endif
    void                optOptimizeInducIndexChecks(BasicBlock *head,
                                            BasicBlock *end);

    bool                optReachWithoutCall(BasicBlock * srcBB,
                                            BasicBlock * dstBB);

#endif // RNGCHK_OPT


    /**************************************************************************
     *                          Recursion
     *************************************************************************/

#if     OPTIMIZE_RECURSION

public :

    void                optOptimizeRecursion();

#endif


    /**************************************************************************
     *                     Optimize array initializers
     *************************************************************************/

public :

    void                optOptimizeArrayInits();

protected :

    bool                optArrayInits;


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           RegAlloc                                        XX
XX                                                                           XX
XX  Does the register allocation and puts the remaining lclVars on the stack XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    void                raInit      ();
    void                raAssignVars(); // register allocation

protected:

    //------------------ Things used for register-allocation ------------------

#if ALLOW_MIN_OPT
    regMaskTP           raMinOptLclVarRegs;
#endif

    regMaskTP           raVarIntfMask;
    VARSET_TP           raLclRegIntf[REG_COUNT];

    static int          raMarkVarIntf       (GenTreePtr     tree, void *);
    void                raMarkRegIntf       (GenTreePtr     tree,
                                             regNumber      regNum,
                                             bool           isFirst = false);
    void                raMarkRegIntf       (VARSET_TP   *  FPlvlLife,
                                             VARSET_TP      trkGCvars);
    void                raAdjustVarIntf     ();

#if TGT_x86

    unsigned            raPredictRegPick    (var_types      type,
                                             unsigned       lockedRegs);
    unsigned            raPredictGrabReg    (var_types      type,
                                             unsigned       lockedRegs,
                                             unsigned       mustReg);

    unsigned            raPredictGetLoRegMask(unsigned      regPairMask);
    unsigned            raPredictAddressMode(GenTreePtr     tree,
                                             unsigned       lockedRegs);
    unsigned            raPredictComputeReg (GenTreePtr     tree,
                                             unsigned       awayFromMask,
                                             unsigned       lockedRegs);
    unsigned            raPredictTreeRegUse (GenTreePtr     tree,
                                             bool           mustReg,
                                             unsigned       lockedRegs);
#else
    unsigned            raPredictTreeRegUse (GenTreePtr     tree);
    unsigned            raPredictListRegUse (GenTreePtr     list);
#endif

    void                raPredictRegUse     ();

    regMaskTP           raAssignRegVar      (LclVarDsc   *  varDsc,
                                             regMaskTP      regAvail,
                                             regMaskTP      prefReg);

    void                raMarkStkVars       ();

    int                 raAssignRegVars     (regMaskTP      regAvail);

#if TGT_x86

    void                raInsertFPregVarPop (BasicBlock *   srcBlk,
                                             BasicBlock * * dstPtr,
                                             unsigned       varNum);

    bool                raMarkFPblock       (BasicBlock *   srcBlk,
                                             BasicBlock *   dstBlk,
                                             unsigned       icnt,
                                             VARSET_TP      life,
                                             VARSET_TP      lifeOuter,
                                             VARSET_TP      varBit,
                                             VARSET_TP      intVars,
                                             bool    *       deathPtr,
                                             bool    *      repeatPtr);

    bool                raEnregisterFPvar   (unsigned       varNum,
                                             bool           convert);
    bool                raEnregisterFPvar   (LclVarDsc   *  varDsc,
                                             unsigned    *  pFPRegVarLiveInCnt,
                                             VARSET_TP   *  FPlvlLife);

#else

    void                raMarkRegSetIntf    (VARSET_TP      vars,
                                             regMaskTP      regs);

#endif

    VARSET_TP           raBitOfRegVar       (GenTreePtr     tree);

#ifdef  DEBUG
    void                raDispFPlifeInfo    ();
#endif


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           EEInterface                                     XX
XX                                                                           XX
XX   Get to the class and method info from the Execution Engine given        XX
XX   tokens for the class and method                                         XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

public :

    /* These are the differnet addressing modes used to access a local var.
     * The JIT has to report the location of the locals back to the EE
     * for debugging purposes
     */

    enum siVarLocType
    {
        VLT_REG,
        VLT_STK,
        VLT_REG_REG,
        VLT_REG_STK,
        VLT_STK_REG,
        VLT_STK2,
        VLT_FPSTK,
        VLT_MEMORY, // used for varargs' sigcookie

        VLT_COUNT,
        VLT_INVALID = 0xFF,
    };

    struct siVarLoc
    {
        siVarLocType    vlType;

        union
        {
            // VLT_REG -- Any 32 bit enregistered value (TYP_INT, TYP_REF, etc)
            // eg. EAX

            struct
            {
                regNumber   vlrReg;
            }
                        vlReg;

            // VLT_STK -- Any 32 bit value which is on the stack
            // eg. [ESP+0x20], or [EBP-0x28]

            struct
            {
                regNumber       vlsBaseReg;
                NATIVE_OFFSET   vlsOffset;
            }
                        vlStk;

            // VLT_REG_REG -- TYP_LONG/TYP_DOUBLE with both DWords enregistred
            // eg. RBM_EAXEDX

            struct
            {
                regNumber       vlrrReg1;
                regNumber       vlrrReg2;
            }
                        vlRegReg;

            // VLT_REG_STK -- Partly enregistered TYP_LONG/TYP_DOUBLE
            // eg { LowerDWord=EAX UpperDWord=[ESP+0x8] }

            struct
            {
                regNumber       vlrsReg;

                struct
                {
                    regNumber       vlrssBaseReg;
                    NATIVE_OFFSET   vlrssOffset;
                }
                            vlrsStk;
            }
                        vlRegStk;

            // VLT_STK_REG -- Partly enregistered TYP_LONG/TYP_DOUBLE
            // eg { LowerDWord=[ESP+0x8] UpperDWord=EAX }

            struct
            {
                struct
                {
                    regNumber       vlsrsBaseReg;
                    NATIVE_OFFSET   vlsrsOffset;
                }
                            vlsrStk;

                regNumber   vlsrReg;
            }
                        vlStkReg;

            // VLT_STK2 -- Any 64 bit value which is on the stack, in 2 successsive DWords
            // eg 2 DWords at [ESP+0x10]

            struct
            {
                regNumber       vls2BaseReg;
                NATIVE_OFFSET   vls2Offset;
            }
                        vlStk2;

            // VLT_FPSTK -- enregisterd TYP_DOUBLE (on the FP stack)
            // eg. ST(3). Actually it is ST("FPstkHeigth - vpFpStk")

            struct
            {
                unsigned        vlfReg;
            }
                        vlFPstk;

            struct
            {
                void            *rpValue;
                // pointer to the in-process location of the value.
            }           vlMemory;
        };

        // Helper functions

        bool        vlIsInReg(regNumber reg);
        bool        vlIsOnStk(regNumber reg, signed offset);
    };

    /*************************************************************************/

public :

    void                        eeInit              ();

    // Get handles

    CLASS_HANDLE                eeFindClass         (unsigned       metaTok,
                                                     SCOPE_HANDLE   scope,
                                                     METHOD_HANDLE  context,
                                                     bool           giveUp = true);

    CLASS_HANDLE                eeGetMethodClass    (METHOD_HANDLE  hnd);

    CLASS_HANDLE                eeGetFieldClass     (FIELD_HANDLE   hnd);

    size_t                      eeGetFieldAddress   (FIELD_HANDLE   hnd);

    METHOD_HANDLE               eeFindMethod        (unsigned       metaTok,
                                                     SCOPE_HANDLE   scope,
                                                     METHOD_HANDLE  context,
                                                     bool           giveUp = true);

    FIELD_HANDLE                eeFindField         (unsigned       metaTok,
                                                     SCOPE_HANDLE   scope,
                                                     METHOD_HANDLE  context,
                                                     bool           giveUp = true);

    unsigned                    eeGetStaticBlkHnd   (FIELD_HANDLE   handle);

    unsigned                    eeGetStringHandle   (unsigned       strTok,
                                                     SCOPE_HANDLE   scope,
                                                     unsigned *    *ppIndir);

    void *                      eeFindPointer       (SCOPE_HANDLE   cls,
                                                     unsigned       ptrTok,
                                                     bool           giveUp = true);

    void *                      embedGenericHandle  (unsigned       metaTok,
                                                     SCOPE_HANDLE   scope,
                                                     METHOD_HANDLE  context,
                                                     void         **ppIndir,
                                                     bool           giveUp = true);

#ifdef DEBUG
    void                        eeUnresolvedMDToken (SCOPE_HANDLE   cls,
                                                     unsigned       token,
                                                     const char *   errMsg);
#endif


    // Get the flags

    unsigned                    eeGetClassAttribs   (CLASS_HANDLE   hnd);
    unsigned                    eeGetClassSize      (CLASS_HANDLE   hnd);
    void                        eeGetClassGClayout  (CLASS_HANDLE   hnd, bool* gcPtrs);

    unsigned                    eeGetMethodAttribs  (METHOD_HANDLE  hnd);
    void                        eeSetMethodAttribs  (METHOD_HANDLE  hnd, unsigned attr);

    void    *                   eeGetMethodSync     (METHOD_HANDLE  hnd,
                                                     void **       *ppIndir);
    unsigned                    eeGetFieldAttribs   (FIELD_HANDLE   hnd);
    bool                        eeIsClassMethod     (METHOD_HANDLE  hnd);

    const char*                 eeGetMethodName     (METHOD_HANDLE  hnd, const char** className);
#ifdef DEBUG
    const char*                 eeGetMethodFullName (METHOD_HANDLE  hnd);
#endif
    SCOPE_HANDLE                eeGetMethodScope    (METHOD_HANDLE  hnd);

    ARG_LIST_HANDLE             eeGetArgNext        (ARG_LIST_HANDLE list);
    varType_t                   eeGetArgType        (ARG_LIST_HANDLE list, JIT_SIG_INFO* sig);
    varType_t                   eeGetArgType        (ARG_LIST_HANDLE list, JIT_SIG_INFO* sig, bool* isPinned);
    CLASS_HANDLE                eeGetArgClass       (ARG_LIST_HANDLE list, JIT_SIG_INFO * sig);
    unsigned                    eeGetArgSize        (ARG_LIST_HANDLE list, JIT_SIG_INFO* sig);


    // VOM permissions
    BOOL                        eeIsOurMethod       (METHOD_HANDLE  hnd);
    BOOL                        eeCheckCalleeFlags  (unsigned       flags,
                                                     unsigned       opCode);
    bool                        eeCheckPutFieldFinal(FIELD_HANDLE   CPfield,
                                                     unsigned       flags,
                                                     CLASS_HANDLE   cls,
                                                     METHOD_HANDLE  method);
    bool                        eeCanPutField       (FIELD_HANDLE   CPfield,
                                                     unsigned       flags,
                                                     CLASS_HANDLE   cls,
                                                     METHOD_HANDLE  method);

    // VOM info, method sigs

    void                        eeGetSig            (unsigned       sigTok,
                                                     SCOPE_HANDLE   scope,
                                                     JIT_SIG_INFO*  retSig);

    void                        eeGetCallSiteSig    (unsigned       sigTok,
                                                     SCOPE_HANDLE   scope,
                                                     JIT_SIG_INFO*  retSig);

    void                        eeGetMethodSig      (METHOD_HANDLE  methHnd,
                                                     JIT_SIG_INFO*  retSig);

    unsigned                    eeGetMethodVTableOffset(METHOD_HANDLE methHnd);

    unsigned                    eeGetInterfaceID    (CLASS_HANDLE   methHnd,
                                                     unsigned *    *ppIndir);

    var_types                   eeGetFieldType      (FIELD_HANDLE   handle,
                                                     CLASS_HANDLE * structType=0);

    int                         eeGetNewHelper      (CLASS_HANDLE   newCls,
                                                     METHOD_HANDLE  context);

    int                         eeGetIsTypeHelper   (CLASS_HANDLE   newCls);

    int                         eeGetChkCastHelper  (CLASS_HANDLE   newCls);

    // Method entry-points, IL

    void    *                   eeGetMethodPointer  (METHOD_HANDLE  methHnd,
                                                     InfoAccessType *pAccessType);

    void    *                   eeGetMethodEntryPoint(METHOD_HANDLE methHnd,
                                                     InfoAccessType *pAccessType);

    bool                        eeGetMethodInfo     (METHOD_HANDLE  method,
                                                     JIT_METHOD_INFO* methodInfo);

    bool                        eeCanInline         (METHOD_HANDLE  callerHnd,
                                                     METHOD_HANDLE  calleeHnd);

    bool                        eeCanTailCall       (METHOD_HANDLE  callerHnd,
                                                     METHOD_HANDLE  calleeHnd);

    void    *                   eeGetHintPtr        (METHOD_HANDLE  methHnd,
                                                     void **       *ppIndir);

    void    *                   eeGetFieldAddress   (FIELD_HANDLE   handle,
                                                     void **       *ppIndir);

    unsigned                    eeGetFieldThreadLocalStoreID (
                                                     FIELD_HANDLE   handle,
                                                     void **       *ppIndir);

    unsigned                    eeGetFieldOffset    (FIELD_HANDLE   handle);

     // Native Direct Optimizations

        // return the unmanaged calling convention for a PInvoke

    UNMANAGED_CALL_CONV         eeGetUnmanagedCallConv(METHOD_HANDLE method);

        // return if any marshaling is required for PInvoke methods

    BOOL                        eeNDMarshalingRequired(METHOD_HANDLE method);

    bool                        eeIsNativeMethod(METHOD_HANDLE method);

    METHOD_HANDLE               eeMarkNativeTarget(METHOD_HANDLE method);

    METHOD_HANDLE               eeGetMethodHandleForNative(METHOD_HANDLE method);

    void                        eeGetEEInfo(EEInfo *pEEInfoOut);

    DWORD                       eeGetThreadTLSIndex(DWORD * *ppIndir);

    const void  *               eeGetInlinedCallFrameVptr(const void ** *ppIndir);

    LONG        *               eeGetAddrOfCaptureThreadGlobal(LONG ** *ppIndir);

    unsigned                    eeGetPInvokeCookie(CORINFO_SIG_INFO *szMetaSig);

    const void  *               eeGetPInvokeStub();

#ifdef PROFILER_SUPPORT
    PROFILING_HANDLE            eeGetProfilingHandle(METHOD_HANDLE      method,
                                                     BOOL                               *pbHookMethod,
                                                     PROFILING_HANDLE **ppIndir);
#endif

    // Exceptions

    unsigned                    eeGetEHcount        (METHOD_HANDLE handle);
    void                        eeGetEHinfo         (unsigned       EHnum,
                                                     JIT_EH_CLAUSE* EHclause);

    // Debugging support - Line number info

    void                        eeGetStmtOffsets();

    unsigned                    eeBoundariesCount;

    struct      boundariesDsc
    {
        NATIVE_IP       nativeIP;
        IL_OFFSET       ilOffset;
    }
                              * eeBoundaries;   // Boundaries to report to EE
    void        FASTCALL        eeSetLIcount        (unsigned       count);
    void        FASTCALL        eeSetLIinfo         (unsigned       which,
                                                     NATIVE_IP      offs,
                                                     unsigned       srcIP);
    void                        eeSetLIdone         ();


    // Debugging support - Local var info

    void                        eeGetVars           ();

    unsigned                    eeVarsCount;

    struct VarResultInfo
    {
        DWORD           startOffset;
        DWORD           endOffset;
        DWORD           varNumber;
        siVarLoc        loc;
    }
                              * eeVars;
    void FASTCALL               eeSetLVcount        (unsigned       count);
    void                        eeSetLVinfo         (unsigned       which,
                                                     unsigned       startOffs,
                                                     unsigned       length,
                                                     unsigned       varNum,
                                                     unsigned       LVnum,
                                                     lvdNAME        namex,
                                                     bool           avail,
                                                     const siVarLoc &loc);
    void                        eeSetLVdone         ();

    // Utility functions

#if defined(DEBUG) || !defined(NOT_JITC)
    const char * FASTCALL       eeGetCPString       (unsigned       cpx);
    const char * FASTCALL       eeGetCPAsciiz       (unsigned       cpx);
#endif

#if defined(DEBUG) || INLINE_MATH
    static const char *         eeHelperMethodName  (int            helper);
    const char *                eeGetFieldName      (FIELD_HANDLE   fieldHnd,
                                                     const char **  classNamePtr = NULL);
#endif
    static METHOD_HANDLE        eeFindHelper        (unsigned       helper);
    static JIT_HELP_FUNCS       eeGetHelperNum      (METHOD_HANDLE  method);

    static FIELD_HANDLE         eeFindJitDataOffs   (unsigned       jitDataOffs);
        // returns a number < 0 if not a Jit Data offset
    static int                  eeGetJitDataOffs    (FIELD_HANDLE   field);
protected :

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           TempsInfo                                       XX
XX                                                                           XX
XX  The temporary lclVars allocated by the compiler for code generation      XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************
 *
 *  The following keeps track of temporaries allocated by the compiler in
 *  the stack frame.
 */

    struct  TempDsc
    {
        TempDsc  *          tdNext;

        BYTE                tdSize;
#ifdef  FAST
        BYTE                tdType;
#else
        var_types           tdType;
#endif
        short               tdOffs;
        short               tdNum;

        size_t              tdTempSize() {  return            tdSize;  }
        var_types           tdTempType() {  return (var_types)tdType;  }
        int                 tdTempNum () {  return            tdNum ;  }
        int                 tdTempOffs() {  ASSert(tdOffs != 0xDDDD);
                                            return            tdOffs;  }
    };

/*****************************************************************************/

public :

    void                tmpInit     ();

    static unsigned     tmpFreeSlot (size_t      size); // which slot in tmpFree[] to use
    TempDsc  *          tmpGetTemp  (var_types   type); // get temp for the given type
    void                tmpRlsTemp  (TempDsc *   temp);
    TempDsc *           tmpFindNum  (int         temp);

    void                tmpEnd      ();
    TempDsc *           tmpListBeg  ();
    TempDsc *           tmpListNxt  (TempDsc * curTemp);
    void                tmpDone     ();

protected :

    unsigned            tmpCount;   // Number of temps

    TempDsc  *          tmpFree[TEMP_MAX_SIZE / sizeof(int)];

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           RegSet                                          XX
XX                                                                           XX
XX  Represents the register set, and their states during code generation     XX
XX  Can select an unused register, keeps track of the contents of the        XX
XX  registers, and can spill registers                                       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/



/*****************************************************************************
 *
 *  Keep track of the current state of each register. This is intended to be
 *  used for things like register reload suppression, but for now the only
 *  thing it does is note which registers we use in each method.
 */

enum    regValKind
{
    RV_TRASH,           // random unclassified garbage
    RV_INT_CNS,         // integer constant
    RV_LCL_VAR,         // local variable value
    RV_CLS_VAR,         // instance variable value (danger: aliasing!)
    RV_LCL_VAR_LNG_LO,  // lower half of long local variable
    RV_LCL_VAR_LNG_HI,
#if USE_SET_FOR_LOGOPS
    RV_BIT,             // low bit unknown, the rest is cleared
#endif
};

/*****************************************************************************/


public :

    void                rsInit();


    // The same descriptor is also used for 'multi-use' register tracking, BTW.

    struct  SpillDsc
    {
        SpillDsc   *        spillNext;    // next spilled value of same reg
        GenTreePtr          spillTree;    // the value that was spilled
        GenTreePtr          spillAddr;    // owning complex address mode or 0
        TempDsc    *        spillTemp;    // the temp holding the spilled value
        bool                spillMoreMultis;
    };

    SpillDsc   *        rsSpillFree;      // list of unused spill descriptors

    //-------------------------------------------------------------------------
    //
    //  Track the status of the registers
    //

    // trees currently sitting in the registers
    GenTreePtr          rsUsedTree[REG_COUNT];

    // addr for which rsUsedTree[reg] is a part of the addressing mode
    GenTreePtr          rsUsedAddr[REG_COUNT];

    // keeps track of 'multiple-use' registers.
    SpillDsc   *        rsMultiDesc[REG_COUNT];

    regMaskTP           rsMaskUsed;   // currently 'used' registers mask
    regMaskTP           rsMaskVars;   // mask of registers currently allocated to variables
    regMaskTP           rsMaskLock;   // currently 'locked' registers mask
    regMaskTP           rsMaskModf;   // mask of the registers modified by the current function.
    regMaskTP           rsMaskMult;   // currently 'multiply used' registers mask

    regMaskTP           rsRegMaskFree     ();
    regMaskTP           rsRegMaskCanGrab  ();
    void                rsMarkRegUsed     (GenTreePtr tree, GenTreePtr addr = 0);
    void                rsMarkRegPairUsed (GenTreePtr tree);
    bool                rsIsTreeInReg     (regNumber  reg, GenTreePtr tree);
    void                rsMarkRegFree     (regMaskTP  regMask);
    void                rsMultRegFree     (regMaskTP  regMask);
    unsigned            rsFreeNeededRegCount(regMaskTP needReg);

    void                rsLockReg         (regMaskTP  regMask);
    void                rsUnlockReg       (regMaskTP  regMask);
    void                rsLockUsedReg     (regMaskTP  regMask);
    void                rsUnlockUsedReg   (regMaskTP  regMask);
    void                rsLockReg         (regMaskTP  regMask, regMaskTP *usedMask);
    void                rsUnlockReg       (regMaskTP  regMask, regMaskTP  usedMask);

    regMaskTP           rsRegExclMask     (regMaskTP  regMask, regMaskTP   rmvMask);

    //-------------------- Register selection ---------------------------------

#if USE_FASTCALL

    unsigned            rsCurRegArg;            // current argument register (for caller)

#if TGT_IA64
    unsigned            rsCalleeIntArgNum;      // # of incoming int register arguments
    unsigned            rsCalleeFltArgNum;      // # of incoming flt register arguments
#else
    unsigned            rsCalleeRegArgNum;      // total number of incoming register arguments
    regMaskTP           rsCalleeRegArgMaskLiveIn;   // mask of register arguments (live on entry to method)
#endif

#if STK_FASTCALL
    size_t              rsCurArgStkOffs;        // stack offset of current arg
#endif

#if defined(DEBUG) && !NST_FASTCALL
    bool                genCallInProgress;
#endif

#endif

#if SCHEDULER || USE_SET_FOR_LOGOPS
                        // Remembers the table index where we start
                        // the round robin register selection.
    unsigned            rsNextPickRegIndex;

    unsigned            rsREGORDER_SIZE();
#endif

#if SCHEDULER
    bool                rsRiscify         (var_types type, regMaskTP needReg);
#endif

    regNumber           rsGrabReg         (regMaskTP    regMask);
    void                rsUpdateRegOrderIndex(regNumber reg);
    regNumber           rsPickReg         (regMaskTP    regMask = regMaskNULL,
                                           regMaskTP    regBest = regMaskNULL,
                                           var_types    regType = TYP_INT);

#if!TGT_IA64
    regPairNo           rsGrabRegPair     (regMaskTP    regMask);
    regPairNo           rsPickRegPair     (regMaskTP    regMask);
#endif

    void                rsRmvMultiReg     (regNumber    reg);
    void                rsRecMultiReg     (regNumber    reg);

    //-------------------------------------------------------------------------
    //
    //  The following tables keep track of spilled register values.
    //

    // When a register gets spilled, the old information is stored here
    SpillDsc   *        rsSpillDesc[REG_COUNT];

    void                rsSpillChk      ();
    void                rsSpillInit     ();
    void                rsSpillDone     ();
    void                rsSpillBeg      ();
    void                rsSpillEnd      ();

    void                rsSpillReg      (regNumber      reg);
    void                rsSpillRegs     (regMaskTP      regMask);

    TempDsc     *       rsGetSpillTempWord(regNumber    oldReg);
    regNumber           rsUnspillOneReg (regNumber      oldReg, bool   willKeepOldReg,
                                         regMaskTP      needReg);
    void                rsUnspillInPlace(GenTreePtr     tree);
    void                rsUnspillReg    (GenTreePtr     tree, regMaskTP needReg,
                                                              bool      keepReg);

#if!TGT_IA64
    void                rsUnspillRegPair(GenTreePtr     tree, regMaskTP needReg,
                                                              bool      keepReg);
#endif

    //-------------------------------------------------------------------------
    //
    //  These are used to track the contents of the registers during
    //  code generation.
    //

    struct      RegValDsc
    {
        regValKind          rvdKind;
        union
        {
            long            rvdIntCnsVal;
            unsigned        rvdLclVarNum;
            FIELD_HANDLE    rvdClsVarHnd;
        };
    };

    RegValDsc           rsRegValues[REG_COUNT];


    void                rsTrackRegClr     ();
    void                rsTrackRegClrPtr  ();
    void                rsTrackRegTrash   (regNumber reg);
    void                rsTrackRegIntCns  (regNumber reg, long val);
    void                rsTrackRegLclVar  (regNumber reg, unsigned var);
#if USE_SET_FOR_LOGOPS
    void                rsTrackRegOneBit  (regNumber reg);
#endif
    void                rsTrackRegLclVarLng(regNumber reg, unsigned var,
                                                           bool low);
    bool                rsTrackIsLclVarLng(regValKind rvKind);
    void                rsTrackRegClsVar  (regNumber reg, FIELD_HANDLE fldHnd);
    void                rsTrackRegCopy    (regNumber reg1, regNumber reg2);
    void                rsTrackRegSwap    (regNumber reg1, regNumber reg2);


    //---------------------- Load suppression ---------------------------------

#if REDUNDANT_LOAD

#if USE_SET_FOR_LOGOPS
    regNumber           rsFindRegWithBit  (bool     free    = true,
                                           bool     byteReg = true);
#endif
    regNumber           rsIconIsInReg     (long     val);
    bool                rsIconIsInReg     (long     val,    regNumber reg);
    regNumber           rsLclIsInReg      (unsigned var);
#if!TGT_IA64
    regPairNo           rsLclIsInRegPair  (unsigned var);
#endif
    void                rsTrashLclLong    (unsigned var);
    void                rsTrashLcl        (unsigned var);
    regMaskTP           rsUselessRegs     ();

#endif // REDUNDANT_LOAD


    //-------------------------------------------------------------------------

protected :


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           GCInfo                                          XX
XX                                                                           XX
XX  Garbage-collector information                                            XX
XX  Keeps track of which variables hold pointers.                            XX
XX  Generates the GC-tables                                                  XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    void                gcInit              ();

    void                gcMarkRegSetGCref   (regMaskTP  regMask);
    void                gcMarkRegSetByref   (regMaskTP  regMask);
    void                gcMarkRegSetNpt     (regMaskTP  regMask);
    void                gcMarkRegPtrVal     (regNumber  reg, var_types type);
    void                gcMarkRegPtrVal     (GenTreePtr tree);

/*****************************************************************************/


    //-------------------------------------------------------------------------
    //
    //  The following keeps track of which registers currently hold pointer
    //  values.
    //

    unsigned            gcRegGCrefSetCur;   // current regs holding GCrefs
    unsigned            gcRegByrefSetCur;   // current regs holding Byrefs

    VARSET_TP           gcTrkStkPtrLcls;    // set of tracked stack ptr lcls (GCref and Byref) - no args
    VARSET_TP           gcVarPtrSetCur;     // currently live part of "gcTrkStkPtrLcls"

#ifdef  DEBUG
    void                gcRegPtrSetDisp(unsigned regMask, bool fixed);
#endif

    //-------------------------------------------------------------------------
    //
    //  The following keeps track of the lifetimes of non-register variables that
    //  hold pointers.
    //

    struct varPtrDsc
    {
        varPtrDsc   *   vpdNext;
        varPtrDsc   *   vpdPrev;

        unsigned        vpdVarNum;         // which variable is this about?

        unsigned        vpdBegOfs ;        // the offset where life starts
        unsigned        vpdEndOfs;         // the offset where life starts
    };

    varPtrDsc   *       gcVarPtrList;
    varPtrDsc   *       gcVarPtrLast;

    void                gcVarPtrSetInit();

/*****************************************************************************/

    //  'pointer value' register tracking and argument pushes/pops tracking.

    enum    rpdArgType_t    { rpdARG_POP, rpdARG_PUSH, rpdARG_KILL };

    struct  regPtrDsc
    {
        regPtrDsc  *          rpdNext;            // next entry in the list
        unsigned              rpdOffs;            // the offset of the instruction

        union                                     // two byte union
        {
            struct                                // two byte structure
            {
                regMaskSmall  rpdAdd;             // regptr bitset being added
                regMaskSmall  rpdDel;             // regptr bitset being removed
            }
                              rpdCompiler;

            unsigned short    rpdPtrArg;          // arg offset or popped arg count
        };

        unsigned short        rpdArg          :1;  // is this an argument descriptor?
        unsigned short        rpdArgType      :2;  // is this an argument push,pop, or kill?
        rpdArgType_t          rpdArgTypeGet() { return (rpdArgType_t) rpdArgType; }
        unsigned short        rpdEpilog       :1;  // is this part of an epilog?
        unsigned short        rpdGCtype       :2;  // is this a pointer, after all?
        GCtype                rpdGCtypeGet()  { return (GCtype) rpdGCtype; }

        unsigned short        rpdIsThis       :1;  // is it the 'this' pointer
        unsigned short        rpdCall         :1;  // is this a true call site?
        unsigned short        rpdCallGCrefRegs:4; // Are EBX,EBP,ESI,EDI live?
        unsigned short        rpdCallByrefRegs:4; // Are EBX,EBP,ESI,EDI live?
    };

    regPtrDsc  *        gcRegPtrList;
    regPtrDsc  *        gcRegPtrLast;
    unsigned            gcPtrArgCnt;

#if MEASURE_PTRTAB_SIZE
    static unsigned     s_gcRegPtrDscSize;
    static unsigned     s_gcTotalPtrTabSize;
#endif

    regPtrDsc  *        gcRegPtrAllocDsc      ();

/*****************************************************************************/


    //-------------------------------------------------------------------------
    //
    //  If we're not generating fully interruptible code, we create a simple
    //  linked list of call descriptors.
    //

    struct  CallDsc
    {
        CallDsc     *       cdNext;
        void        *       cdBlock;        // the code block of the call
        unsigned            cdOffs;         // the offset     of the call

        unsigned short      cdArgCnt;
        unsigned short      cdArgBaseOffset;

        union
        {
            struct                          // used if cdArgCnt == 0
            {
                unsigned        cdArgMask;      // ptr arg bitfield
                unsigned        cdByrefArgMask; // byref qualifier for cdArgMask
            };

            unsigned    *       cdArgTable; // used if cdArgCnt != 0
        };

        // How big does it have to be for RISC ?

        unsigned            cdGCrefRegs :16;
        unsigned            cdByrefRegs :16;
    };

    CallDsc    *        gcCallDescList;
    CallDsc    *        gcCallDescLast;

    //-------------------------------------------------------------------------

    void                gcCountForHeader  (unsigned short* untrackedCount,
                                           unsigned short* varPtrTableSize);
    size_t              gcMakeRegPtrTable (BYTE *         dest,
                                           int            mask,
                                           const InfoHdr& header,
                                           unsigned       codeSize);
    size_t              gcPtrTableSize    (const InfoHdr& header,
                                           unsigned       codeSize);
    BYTE    *           gcPtrTableSave    (BYTE *         destPtr,
                                           const InfoHdr& header,
                                           unsigned       codeSize);
    void                gcRegPtrSetInit   ();


    struct genLivenessSet
    {
        VARSET_TP   liveSet;
        VARSET_TP   varPtrSet;
        regMaskTP   maskVars;
        unsigned    gcRefRegs;
        unsigned    byRefRegs;
    };

    void saveLiveness    (genLivenessSet * ls);
    void restoreLiveness (genLivenessSet * ls);
    void checkLiveness   (genLivenessSet * ls);

/*****************************************************************************/

    //-------------------------------------------------------------------------
    //
    //   The following variable keeps track of address of the curPtr into the
    //   GC write barrier table (obtained from the VM). A value of 0 means the
    //   jit must not generate the additional instructions.
    //

#if GC_WRITE_BARRIER_CALL && defined(NOT_JITC)
    static void *       s_gcWriteBarrierPtr;
#else
    static const void * s_GCptrTable[128];
    static void       * s_gcWriteBarrierPtr;
#endif

    static bool         gcIsWriteBarrierCandidate(GenTreePtr tgt);
    static bool         gcIsWriteBarrierAsgNode  (GenTreePtr op);

protected :



    //-------------------------------------------------------------------------
    //
    //  These record the info about the procedure in the info-block
    //

    BYTE    *           gcEpilogTable;

    unsigned            gcEpilogPrevOffset;

    size_t              gcInfoBlockHdrSave(BYTE *     dest,
                                          int         mask,
                                          unsigned    methodSize,
                                          unsigned    prologSize,
                                          unsigned    epilogSize,
                                          InfoHdr*    header,
                                          int*        s_cached);

    static size_t       gcRecordEpilog(void *         pCallBackData,
                                       unsigned       offset);

#if DUMP_GC_TABLES

    void                gcFindPtrsInFrame(const void *infoBlock,
                                          const void *codeBlock,
                                          unsigned    offs);

    unsigned            gcInfoBlockHdrDump(const BYTE *table,
                                           InfoHdr  * header,       /* OUT */
                                           unsigned * methodSize);  /* OUT */

    unsigned            gcDumpPtrTable    (const BYTE *   table,
                                           const InfoHdr& header,
                                           unsigned       methodSize);
#endif



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           Instruction                                     XX
XX                                                                           XX
XX  The interface to generate a machine-instruction.                         XX
XX  Currently specific to x86                                                XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/* Double alignment macros for passing extra information to the inst_SV routines. */

/*****************************************************************************/
#if     DOUBLE_ALIGN
/*****************************************************************************/


#define DOUBLE_ALIGN_PARAM         , bool isEBPRelative
#define DOUBLE_ALIGN_ARG           , isEBPRelative

// this replaces the tests genFPused

#define DOUBLE_ALIGN_FPUSED         (genFPused || isEBPRelative)
#define DOUBLE_ALIGN_NEED_EBPFRAME  (genFPused || genDoubleAlign)


/*****************************************************************************/
#else // DOUBLE_ALIGN
/*****************************************************************************/

/* Without double alignment, the arg/param macros go away, and ebp-rel <==> genFPused */

#define DOUBLE_ALIGN_PARAM
#define DOUBLE_ALIGN_ARG
#define DOUBLE_ALIGN_FPUSED         (genFPused)
#define DOUBLE_ALIGN_NEED_EBPFRAME  (genFPused)


/*****************************************************************************/
#endif // DOUBLE_ALIGN
/*****************************************************************************/


public :

    void                instInit();

#if!TGT_IA64

    static
    BYTE                instInfo[INS_count];

#if TGT_x86
    #define INST_FP     0x01                // is it a FP instruction?
    static
    bool                instIsFP        (instruction    ins);
#else
    #define INST_BD     0x01                // is it a branch-delayed ins?
    static
    bool                instBranchDelay (instruction    ins);
    #define INST_BD_C   0x02                // is it a conditionally BD ins?
    static
    bool                instBranchDelayC(instruction    ins);
    static
    unsigned            instBranchDelayL(instruction    ins);
    #define INST_BR     0x04                // is it a branch/call/ret ins?
    static
    bool                instIsBranch    (instruction    ins);
#endif

    #define INST_DEF_FL 0x20                // does the instruction set flags?
    #define INST_USE_FL 0x40                // does the instruction use flags?
    #define INST_SPSCHD 0x80                // "special" scheduler handling

#endif

#if SCHEDULER

    static
    bool                instDefFlags    (instruction    ins);
    static
    bool                instUseFlags    (instruction    ins);
    static
    bool                instSpecialSched(instruction    ins);

#endif

#if TGT_x86

    void                instGen         (instruction    ins);

    void                inst_JMP        (emitJumpKind   jmp,
                                         BasicBlock *   block,
                                         bool           except   = false,
                                         bool           moveable = false,
                                         bool           newBlock = false);

    void                inst_SET        (emitJumpKind   condition,
                                         regNumber      reg);

    static
    regNumber           instImulReg     (instruction    ins);

    void                inst_RV         (instruction    ins,
                                         regNumber      reg,
                                         var_types      type,
                                         emitAttr       size = EA_UNKNOWN);
    void                inst_RV_RV      (instruction    ins,
                                         regNumber      reg1,
                                         regNumber      reg2,
                                         var_types      type = TYP_INT,
                                         emitAttr       size = EA_UNKNOWN);
    void                inst_IV         (instruction    ins,
                                         long           val);
    void                inst_IV_handle  (instruction    ins,
                                         long           val,
                                         unsigned       flags,
                                         unsigned       metaTok,
                                         CLASS_HANDLE   CLS);
    void                inst_FS         (instruction    ins, unsigned stk = 0);
    void                inst_FN         (instruction    ins, unsigned stk);

    void                inst_RV_IV      (instruction    ins,
                                         regNumber      reg,
                                         long           val,
                                         var_types      type = TYP_INT);

    void                inst_ST_RV      (instruction    ins,
                                         TempDsc    *   tmp,
                                         unsigned       ofs,
                                         regNumber      reg,
                                         var_types      type);
    void                inst_ST_IV      (instruction    ins,
                                         TempDsc    *   tmp,
                                         unsigned       ofs,
                                         long           val,
                                         var_types      type);
    void                inst_RV_ST      (instruction    ins,
                                         regNumber      reg,
                                         TempDsc    *   tmp,
                                         unsigned       ofs,
                                         var_types      type,
                                         emitAttr       size = EA_UNKNOWN);
    void                inst_FS_ST      (instruction    ins,
                                         emitAttr       size,
                                         TempDsc    *   tmp,
                                         unsigned       ofs);

    void                inst_AV         (instruction    ins,
                                         GenTreePtr     tree, unsigned offs = 0);

    void                instEmit_indCall(GenTreePtr     call,
                                         size_t         argSize,
                                         size_t         retSize);

    void                instEmit_RM     (instruction    ins,
                                         GenTreePtr     tree,
                                         GenTreePtr     addr,
                                         unsigned       offs);

    void                instEmit_RM_RV  (instruction    ins,
                                         emitAttr       size,
                                         GenTreePtr     tree,
                                         regNumber      reg,
                                         unsigned       offs);

    void                instEmit_RV_RM  (instruction    ins,
                                         emitAttr       size,
                                         regNumber      reg,
                                         GenTreePtr     tree,
                                         unsigned       offs);

    void                instEmit_RV_RIA (instruction    ins,
                                         regNumber      reg1,
                                         regNumber      reg2,
                                         unsigned       offs);

    void                inst_TT         (instruction    ins,
                                         GenTreePtr     tree,
                                         unsigned       offs = 0,
                                         int            shfv = 0,
                                         emitAttr       size = EA_UNKNOWN);

    void                inst_TT_RV      (instruction    ins,
                                         GenTreePtr     tree,
                                         regNumber      reg,
                                         unsigned       offs = 0);

    void                inst_TT_IV      (instruction    ins,
                                         GenTreePtr     tree,
                                         long           val,
                                         unsigned       offs = 0);

    void                inst_RV_AT      (instruction    ins,
                                         emitAttr       size,
                                         var_types      type,
                                         regNumber      reg,
                                         GenTreePtr     tree,
                                         unsigned       offs = 0);

    void                inst_AT_IV      (instruction    ins,
                                         emitAttr       size,
                                         GenTreePtr     tree,
                                         long           icon,
                                         unsigned       offs = 0);

    void                inst_RV_TT      (instruction    ins,
                                         regNumber      reg,
                                         GenTreePtr     tree,
                                         unsigned       offs = 0,
                                         emitAttr       size = EA_UNKNOWN);

    void                inst_RV_TT_IV   (instruction    ins,
                                         regNumber      reg,
                                         GenTreePtr     tree,
                                         long           val);

    void                inst_FS_TT      (instruction    ins,
                                         GenTreePtr tree);

    void                inst_RV_SH      (instruction    ins,
                                         regNumber reg, unsigned val);

    void                inst_TT_SH      (instruction    ins,
                                         GenTreePtr     tree,
                                         unsigned       val, unsigned offs = 0);

    void                inst_RV_CL      (instruction    ins, regNumber reg);

    void                inst_TT_CL      (instruction    ins,
                                         GenTreePtr     tree, unsigned offs = 0);

    void                inst_RV_RV_IV   (instruction    ins,
                                         regNumber      reg1,
                                         regNumber      reg2,
                                         unsigned       ival);

    void                inst_RV_RR      (instruction    ins,
                                         emitAttr       size,
                                         regNumber      reg1,
                                         regNumber      reg2);

    void                inst_RV_ST      (instruction    ins,
                                         emitAttr       size,
                                         regNumber      reg,
                                         GenTreePtr     tree);

    void                sched_AM        (instruction    ins,
                                         emitAttr       size,
                                         regNumber      ireg,
                                         bool           rdst,
                                         GenTreePtr     tree,
                                         unsigned       offs,
                                         bool           cons = false,
                                         int            cval = 0);

    void                inst_set_SV_var (GenTreePtr     tree);

#else

    void                sched_AM        (instruction    ins,
                                         var_types      type,
                                         regNumber      ireg,
                                         bool           rdst,
                                         GenTreePtr     tree,
                                         unsigned       offs);

    void                inst_TT_RV      (instruction    ins,
                                         GenTreePtr     tree,
                                         regNumber      reg,
                                         unsigned       offs = 0);

    void                inst_RV_TT      (instruction    ins,
                                         regNumber      reg,
                                         GenTreePtr     tree,
                                         unsigned       offs = 0,
                                         emitAttr       size = EA_UNKNOWN);
#endif

#ifdef  DEBUG
    void    __cdecl     instDisp(instruction ins, bool noNL, const char *fmt, ...);
#endif

protected :


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           ScopeInfo                                       XX
XX                                                                           XX
XX  Keeps track of the scopes during code-generation.                        XX
XX  This is used to translate the local-variable debuggin information        XX
XX  from IL offsets to offsets into the generated native code.         XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************/
#ifdef DEBUGGING_SUPPORT
/*****************************************************************************
 *                              ScopeInfo
 *
 * This class is called during code gen at block-boundaries, and when the
 * set of live variables changes. It keeps track of the scope of the variables
 * in terms of the native code PC.
 */


public:

    void                siInit          ();

    void                siBeginBlock    ();

    void                siEndBlock      ();

    void                siUpdate        ();

    void                siCheckVarScope (unsigned varNum, IL_OFFSET offs);

    void                siNewScopeNear  (unsigned varNum, NATIVE_IP offs);

    void                siStackLevelChanged();

    void                siCloseAllOpenScopes();

#ifdef DEBUG
    void                siDispOpenScopes();
#endif


    /**************************************************************************
     *                          PROTECTED
     *************************************************************************/

protected :

    struct siScope
    {
        void *          scStartBlock;   // emitter block at start of scope
        unsigned        scStartBlkOffs; // offset within the emitter block

        void *          scEndBlock;     // emitter block at end of scope
        unsigned        scEndBlkOffs;   // offset within the emitter block

        unsigned        scVarNum;       // index into lclVarTab
        unsigned        scLVnum;        // 'which' in eeGetLVinfo() - @TODO : Remove for IL

        unsigned        scStackLevel;   // Only for stk-vars
        bool            scAvailable :1; // It has a home / Home recycled

        siScope *       scPrev;
        siScope *       scNext;
    };

    siScope             siOpenScopeList,   siScopeList,
                      * siOpenScopeLast, * siScopeLast;

    unsigned            siScopeCnt;

    unsigned            siLastStackLevel;

    VARSET_TP           siLastLife;     // Life at last call to Update()

    // Tracks the last entry for each tracked register variable

    siScope *           siLatestTrackedScopes[lclMAX_TRACKED];

    unsigned short      siLastEndOffs;  // BC offset of the last block

    // Functions

    siScope *           siNewScope          (unsigned short LVnum,
                                             unsigned       varNum,
                                             bool           avail = true);

    void                siRemoveFromOpenScopeList(siScope * scope);

    void                siEndTrackedScope   (unsigned       varIndex);

    void                siEndScope          (unsigned       varNum);

    void                siEndScope          (siScope *      scope);

    static bool         siIgnoreBlock       (BasicBlock *);

    static void         siNewScopeCallback  (LocalVarDsc *  var,
                                             unsigned       clientData);

    static void         siEndScopeCallback  (LocalVarDsc *  var,
                                             unsigned       clientData);

    void                siBeginBlockSkipSome();

#ifdef DEBUG
    bool                siVerifyLocalVarTab ();
#endif



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          PrologScopeInfo                                  XX
XX                                                                           XX
XX We need special handling in the prolog block, as a the parameter variablesXX
XX may not be in the same position described by genLclVarTable - they all    XX
XX start out on the stack                                                    XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    void                psiBegProlog    ();

    void                psiAdjustStackLevel(unsigned size);

    void                psiMoveESPtoEBP ();

    void                psiMoveToReg    (unsigned   varNum,
                                         regNumber  reg      = REG_NA,
                                         regNumber  otherReg = REG_NA);

#if USE_FASTCALL
    void                psiMoveToStack  (unsigned   varNum);
#endif

    void                psiEndProlog    ();


    /**************************************************************************
     *                          PROTECTED
     *************************************************************************/

protected :

    struct  psiScope
    {
        void *          scStartBlock;   // emitter block at start of scope
        unsigned        scStartBlkOffs; // offset within the emitter block

        void *          scEndBlock;     // emitter block at end of scope
        unsigned        scEndBlkOffs;   // offset within the emitter block

        unsigned        scSlotNum;      // index into lclVarTab
        unsigned short  scLVnum;        // 'which' in eeGetLVinfo() - @TODO : Remove for IL

        bool            scRegister;

        union
        {
            struct
            {
                regNumberSmall  scRegNum;
                regNumberSmall  scOtherReg; // used for "other half" of long var
            };

            struct
            {
                regNumberSmall  scBaseReg;
                NATIVE_OFFSET   scOffset;
            };
        };

        psiScope *      scPrev;
        psiScope *      scNext;
    };

    psiScope            psiOpenScopeList,   psiScopeList,
                      * psiOpenScopeLast, * psiScopeLast;

    unsigned            psiScopeCnt;

    // Implementation Functions

    psiScope *          psiNewPrologScope(unsigned          LVnum,
                                          unsigned          slotNum);

    void                psiEndPrologScope(psiScope *        scope);






/*****************************************************************************
 *                        TrnslLocalVarInfo
 *
 * This struct holds the LocalVarInfo in terms of the generated native code
 * after a call to genSetScopeInfo()
 */

#ifdef DEBUG


    struct TrnslLocalVarInfo
    {
        unsigned            tlviVarNum;
        unsigned            tlviLVnum;      // @TODO : Remove for IL
        lvdNAME             tlviName;
        NATIVE_IP           tlviStartPC;
        unsigned            tlviLength;
        bool                tlviAvailable;
        siVarLoc            tlviVarLoc;
    };


#endif // DEBUG


public :

#ifdef LATE_DISASM
    const char *        siRegVarName    (unsigned offs, unsigned size,
                                         unsigned reg);
    const char *        siStackVarName  (unsigned offs, unsigned size,
                                         unsigned reg,  unsigned stkOffs);
#endif

/*****************************************************************************/
#endif // DEBUGGING_SUPPORT
/*****************************************************************************/

#ifdef  DEBUG
    const char *        jitCurSource;       // file being compiled
#endif

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           CodeGenerator                                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


public :

    emitter *           getEmitter() { return genEmitter; }

#ifdef LATE_DISASM
    DisAssembler        genDisAsm;
#endif

    //-------------------------------------------------------------------------

    //  The following variable indicates whether the current method sets up
    //  an explicit stack frame or not. It is used by the scheduler if scheduling
    //  of pushes is enabled.
    bool                genFPused;

#if     TGT_RISC

    //  If we've assigned a variable to the FP register it won't be available
    //  for setting up a stack frame and the following will be set to true.
    bool                genFPcant;

    //  The following holds the distance between SP and FP if known - it is
    //  only meaningful when it's non-zero and 'genFPused' is true.
    unsigned            genFPtoSP;

#else

    //  The following variable indicates whether the current method is eligible
    //  to not set up an explicit stack frame.
    bool                genFPreqd;

#endif

    //-------------------------------------------------------------------------

#if TGT_RISC

    bool                genNonLeaf;         // routine makes calls

    size_t              genMaxCallArgs;     // max. arg bytes passed to callee

    regMaskTP           genEstRegUse;       // estimate of callee-saved reg use
    bool                genFixedArgBase;    // did we commit to an arg base?

#endif

    //-------------------------------------------------------------------------

    BasicBlock  *       genReturnBB;        // jumped to when not optimizing for speed.

#if TGT_RISC

    unsigned            genReturnCnt;       // number of returns in the method
    unsigned            genReturnLtm;       // number of returns not morphed

    GenTreePtr          genMonExitExp;      // monitorExit expression or NULL

#endif

#if TGT_x86
    unsigned            genTmpAccessCnt;    // # of access to temporary variables
#endif

#if DOUBLE_ALIGN
    bool                genDoubleAlign;
#endif

    //-------------------------------------------------------------------------

    VARSET_TP           genCodeCurLife;     // current  live non-FP variables
    VARSET_TP           genCodeCurRvm;      // current  live non-FP reg. vars

#if TGT_x86
    VARSET_TP           genFPregVars;       // current  live     FP reg. vars
    unsigned            genFPregCnt;        // count of live     FP reg. vars
#endif

#ifdef DEBUG
    VARSET_TP           genTempOldLife;
    bool                genTempLiveChg;
#endif

#if TGT_x86

    //  Keeps track of how many bytes we've pushed on the processor's stack.
    //
    unsigned            genStackLevel;

    //  Keeps track of the current level of the FP coprocessor stack.
    //
    unsigned            genFPstkLevel;

#endif

    //  The following will be set to true if we've determined that we need to
    //  generate a full-blown pointer register map for the current method.
    //  Currently it is equal to (genInterruptible || !genFPused)
    //  (i.e. We generate the full-blown map for EBP-less methods and
    //        for fully interruptible methods)
    //
    bool                genFullPtrRegMap;

    // The following is set to true if we've determined that the current method
    // is to be fully interruptible.
    //
    bool                genInterruptible;

#ifdef  DEBUG
    // The following is used to make sure the value of 'genInterruptible' isn't
    // changed after it's been used by any logic that depends on its value.
    bool                genIntrptibleUse;
#endif

    //-------------------------------------------------------------------------

                        // Changes lclVar nodes to refVar nodes if possible

    GenTreePtr          genMarkLclVar   (GenTreePtr     tree);

    bool                genCreateAddrMode(GenTreePtr    addr,
                                          int           mode,
                                          bool          fold,
                                          unsigned      regMask,
#if!LEA_AVAILABLE
                                          var_types     optp,
#endif
                                          bool        * revPtr,
                                          GenTreePtr  * rv1Ptr,
                                          GenTreePtr  * rv2Ptr,
#if SCALED_ADDR_MODES
                                          unsigned    * mulPtr,
#endif
                                          unsigned    * cnsPtr,
                                          bool          nogen = false);

    void                genGenerateCode  (void * *      codePtr,
                                          void * *      consPtr,
                                          void * *      dataPtr,
                                          void * *      infoPtr,
                                          SIZE_T *nativeSizeOfCode);


    void                genInit();

#if TGT_IA64

    void                genAddSourceData(const char *fileName);
    static
    void                genStartup();
    static
    void                genShutdown(const char *fileName);

    bool                genUsesArLc;

#endif

#ifdef DEBUGGING_SUPPORT

    //  The following holds information about IL offsets in terms of generated code.

    struct IPmappingDsc
    {
        IPmappingDsc *      ipmdNext;       // next line# record

        void         *      ipmdBlock;      // the block with the line
        unsigned            ipmdBlockOffs;  // the offset of  the line

        IL_OFFSET           ipmdILoffset;   // the IL offset
    };

    // Record the IL offset mapping to the genreated code

    IPmappingDsc *      genIPmappingList;
    IPmappingDsc *      genIPmappingLast;

#endif


    /**************************************************************************
     *                          PROTECTED
     *************************************************************************/

protected :

#ifdef DEBUG
    // Last IL we have displayed for dspILopcodes
    unsigned            genCurDispOffset;
#endif

#ifdef  DEBUG
    static  const char *genInsName(instruction ins);
#endif

    //-------------------------------------------------------------------------
    //
    //  If we know that the flags register is set to a value that corresponds
    //  to the current value of a register or variable, the following values
    //  record that information.
    //

    void    *           genFlagsEqBlk;
    unsigned            genFlagsEqOfs;
    bool                genFlagsEqAll;
    regNumber           genFlagsEqReg;
    unsigned            genFlagsEqVar;

    void                genFlagsEqualToNone ();
    void                genFlagsEqualToReg  (regNumber reg, bool allFlags);
    void                genFlagsEqualToVar  (unsigned  var, bool allFlags);
    int                 genFlagsAreReg      (regNumber reg);
    int                 genFlagsAreVar      (unsigned  var);

    //-------------------------------------------------------------------------

#ifdef  DEBUG

    static
    const   char *      genSizeStr          (emitAttr       size);

#endif

    //-------------------------------------------------------------------------

    void                genBashLclVar       (GenTreePtr     tree,
                                             unsigned       varNum,
                                             LclVarDsc *    varDsc);

    GenTreePtr          genMakeConst        (const void *   cnsAddr,
                                             size_t         cnsSize,
                                             varType_t      cnsType,
                                             GenTreePtr     cnsTree,
                                             bool           readOnly);

    bool                genRegTrashable     (regNumber      reg,
                                             GenTreePtr     tree);

    void                genSetRegToIcon     (regNumber      reg,
                                             long           val,
                                             var_types      type = TYP_INT);

    void                genIncRegBy         (GenTreePtr     tree,
                                             regNumber      reg,
                                             long           ival,
                                             var_types      dstType = TYP_INT,
                                             bool           ovfl    = false);

    void                genDecRegBy         (GenTreePtr     tree,
                                             regNumber      reg,
                                             long           ival);

    void                genMulRegBy         (GenTreePtr     tree,
                                             regNumber      reg,
                                             long           ival,
                                             var_types      dstType = TYP_INT);

    void                genAdjustSP         (int            delta);

    void                genPrepForCompiler  ();

#if USE_FASTCALL
    void                genFnPrologCalleeRegArgs();
#endif

    size_t              genFnProlog         ();

    void genAllocStack(regNumber count);

    void                genCodeForBBlist    ();

    BasicBlock *        genCreateTempLabel  ();

    void                genDefineTempLabel  (BasicBlock *   label,
                                             bool           inBlock);

    void                genOnStackLevelChanged();

    void                genSinglePush       (bool           isRef);

    void                genSinglePop        ();

    void                genChangeLife       (VARSET_TP      newLife
                                             DEBUGARG(GenTreePtr tree));
    void                genDyingVars        (VARSET_TP      commonMask,
                                             GenTreePtr    opNext);

    void                genUpdateLife       (GenTreePtr     tree);

    void                genUpdateLife       (VARSET_TP      newLife);

    void                genComputeReg       (GenTreePtr     tree,
                                             unsigned       needReg,
                                             bool           mustReg,
                                             bool           freeReg,
                                             bool           freeOnly = false);

    void                genCompIntoFreeReg  (GenTreePtr     tree,
                                             unsigned       needReg,
                                             bool           freeReg = false);

    void                genReleaseReg       (GenTreePtr     tree);

    void                genRecoverReg       (GenTreePtr     tree,
                                             unsigned       needReg,
                                             bool           keepReg);

#if TGT_IA64

public:

    void                genPatchGPref       (BYTE *         addr,
                                             NatUns         slot);

private:

#else

    void                genMoveRegPairHalf  (GenTreePtr     tree,
                                             regNumber      dst,
                                             regNumber      src,
                                             int            off = 0);

    void                genMoveRegPair      (GenTreePtr     tree,
                                             unsigned       needReg,
                                             regPairNo      newPair);

    void                genComputeRegPair   (GenTreePtr     tree,
                                             unsigned       needReg,
                                             regPairNo      needRegPair,
                                             bool           freeReg,
                                             bool           freeOnly = false);

    void                genCompIntoFreeRegPair(GenTreePtr   tree,
                                             unsigned       needReg,
                                             bool           freeReg = false);

    void                genReleaseRegPair   (GenTreePtr     tree);

    void                genRecoverRegPair   (GenTreePtr     tree,
                                             regPairNo      regPair,
                                             bool           keepReg);

    void                genEvalIntoFreeRegPair(GenTreePtr   tree,
                                             regPairNo      regPair);

#endif

    void                genRangeCheck       (GenTreePtr     oper,
                                             GenTreePtr     rv1,
                                             GenTreePtr     rv2,
                                             long           ixv,
                                             unsigned       regMask,
                                             bool           keepReg);

#if TGT_RISC

    /* The following is filled in by genMakeIndAddrMode/genMakeAddressable */

    addrModes           genAddressMode;

#endif

    bool                genMakeIndAddrMode  (GenTreePtr     addr,
                                             GenTreePtr     oper,
                                             bool           compute,
                                             unsigned       regMask,
                                             bool           keepReg,
                                             bool           takeAll,
                                             unsigned *     useMaskPtr,
                                             bool           deferOp = false);

    unsigned            genMakeRvalueAddressable(GenTreePtr tree,
                                             unsigned       needReg,
                                             bool           keepReg,
                                             bool           takeAll = false,
                                             bool           smallOK = false);

    unsigned            genMakeAddressable  (GenTreePtr     tree,
                                             unsigned       needReg,
                                             bool           keepReg,
                                             bool           takeAll = false,
                                             bool           smallOK = false,
                                             bool           deferOK = false);

    int                 genStillAddressable (GenTreePtr     tree);

#if TGT_RISC

    unsigned            genNeedAddressable  (GenTreePtr     tree,
                                             unsigned       addrReg,
                                             unsigned       needReg);

    bool                genDeferAddressable (GenTreePtr     tree);

#endif

    unsigned            genRestoreAddrMode  (GenTreePtr     addr,
                                             GenTreePtr     tree,
                                             bool           lockPhase);

    unsigned            genRestAddressable  (GenTreePtr     tree,
                                             unsigned       addrReg);

    unsigned            genLockAddressable  (GenTreePtr     tree,
                                             unsigned       lockMask,
                                             unsigned       addrReg);

    unsigned            genKeepAddressable  (GenTreePtr     tree,
                                             unsigned       addrReg);

    void                genDoneAddressable  (GenTreePtr     tree,
                                             unsigned       keptReg);

    GenTreePtr          genMakeAddrOrFPstk  (GenTreePtr     tree,
                                             unsigned *     regMaskPtr,
                                             bool           roundResult);

    void                genExitCode         (bool           endFN);

    void                genFnEpilog         ();

    void                genEvalSideEffects  (GenTreePtr     tree,
                                             unsigned       needReg);

#if TGT_x86

    TempDsc  *          genSpillFPtos       (var_types      type);

    TempDsc  *          genSpillFPtos       (GenTreePtr     oper);

    void                genReloadFPtos      (TempDsc *      temp,
                                             instruction    ins);

#endif

#if TGT_IA64

    insPtr              genCondJump         (GenTreePtr     cond,
                                             BasicBlock *   dest);

#else

    void                genCondJump         (GenTreePtr     cond,
                                             BasicBlock *   destTrue  = NULL,
                                             BasicBlock *   destFalse = NULL);

#endif

#if TGT_x86

    emitJumpKind        genCondSetFlags     (GenTreePtr     cond);

#else

    bool                genCondSetTflag     (GenTreePtr     cond,
                                             bool           trueOnly);

    void                genCompareRegIcon   (regNumber      reg,
                                             int            val,
                                             bool           uns,
                                             genTreeOps     cmp);

#endif

#if TGT_x86
    void                genFPregVarLoad     (GenTreePtr     tree);
    void                genFPregVarLoadLast (GenTreePtr     tree);
    void                genFPmovRegTop      ();
    void                genFPmovRegBottom   ();
#endif

    void                genFPregVarBirth    (GenTreePtr     tree);
    void                genFPregVarDeath    (GenTreePtr     tree);

    void                genChkFPregVarDeath (GenTreePtr     stmt,
                                             bool           saveTOS);

    void                genFPregVarKill     (unsigned       newCnt,
                                             bool           saveTOS = false);

    void                genJCC              (genTreeOps     cmp,
                                             BasicBlock *   block,
                                             var_types      type);

    void                genJccLongHi        (genTreeOps     cmp,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse,
                                             bool           unsOper = false);

    void                genJccLongLo        (genTreeOps     cmp,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse);

    void                genCondJumpLng      (GenTreePtr     cond,
                                             BasicBlock *   jumpTrue,
                                             BasicBlock *   jumpFalse);

    void                genCondJumpFlt      (GenTreePtr      cond,
                                             BasicBlock *    jumpTrue,
                                             BasicBlock *    jumpFalse);

    void                genTableSwitch      (regNumber      reg,
                                             unsigned       jumpCnt,
                                             BasicBlock **  jumpTab,
                                             bool           chkHi,
                                             int            prefCnt = 0,
                                             BasicBlock *   prefLab = NULL,
                                             int            offset  = 0);

    unsigned            WriteBarrier        (GenTreePtr tree, regNumber reg
#if !GC_WRITE_BARRIER && GC_WRITE_BARRIER_CALL
                                           , unsigned       addrReg
#endif
                                            );


    void                genCheckOverflow    (GenTreePtr     tree,
                                             regNumber      reg = REG_NA);

#if TGT_IA64

    void                genCopyBlock(insPtr tmp1,
                                     insPtr tmp2,
                                     bool  noAsg, GenTreePtr iexp,
                                                  __int64    ival);

    insPtr              genAssignNewTmpVar(insPtr val, var_types typ, NatUns refs, bool noAsg, NatUns *varPtr);

    insPtr              genRefTmpVar(NatUns vnum, var_types type);

public:
    bool                genWillCompileFunction(const char *name);
private:

    NatUns              genOutArgRegCnt;

    void                genAllocTmpRegs();
    void                genAllocVarRegs();

    void                genUnwindTable();
    void                genIssueCode();

    void                genAddSpillCost(bitVectVars & needLoad, NatUns curWeight);

    static
    int     __cdecl     genSpillCostCmp(const void *op1, const void *op2);

    void                genComputeLocalDF();
    void                genComputeGlobalDF();
    void                genComputeLifetimes();
    bool                genBuildIntfGraph();
    void                genColorIntfGraph();
    void                genVarCoalesce();
    void                genSpillAndSplitVars();

    void                genMarkBBlabels();  // temp hack

    insPtr              genCodeForTreeInt   (GenTreePtr tree, bool keep);
    insPtr              genCodeForTreeFlt   (GenTreePtr tree, bool keep);

    insPtr              genCodeForTree      (GenTreePtr tree, bool keep)
    {
        return  varTypeIsFloating(tree->TypeGet()) ? genCodeForTreeFlt(tree, keep)
                                                   : genCodeForTreeInt(tree, keep);
    }

    insPtr              genStaticDataMem(GenTreePtr tree, insPtr asgVal   = NULL,
                                                          bool   takeAddr = false);

#else

    void                genCodeForTree      (GenTreePtr tree, unsigned destReg,
                                                              unsigned bestReg=0);

    void                genCodeForTreeLng   (GenTreePtr tree, unsigned needReg);

#if CPU_HAS_FP_SUPPORT
#if ROUND_FLOAT
    void                genRoundFpExpression(GenTreePtr     op);

    void                genCodeForTreeFlt   (GenTreePtr     tree,
                                             bool           roundResult);
#else
    void                genCodeForTreeFlt   (GenTreePtr     tree);
#define                 genCodeForTreeFlt(tree, round)  genCodeForTreeFlt(tree)
#endif
#endif

#if TGT_RISC
    void                genCallInst         (gtCallTypes    callType,
                                             void   *       callHand,
                                             size_t         argSize,
                                             int            retSize);
#endif

#endif

    void                genCodeForSwitch    (GenTreePtr     tree);

    void                genTrashRegSet      (regMaskTP      regMask);

    void                genFltArgPass       (size_t     *   argSzPtr);

#if!USE_FASTCALL
#define genPushArgList(a,r,m,p) genPushArgList(a,p)
#endif

    size_t              genPushArgList      (GenTreePtr     args,
                                             GenTreePtr     regArgs,
                                             unsigned       encodeMask,
                                             unsigned *     regsPtr);

#if TGT_IA64
    insPtr              genCodeForCall      (GenTreePtr     call,
                                             bool           keep);
#else
    unsigned            genCodeForCall      (GenTreePtr     call,
                                             bool           valUsed,
                                             unsigned *     regsPtr);
#endif

    void                genEmitHelperCall   (unsigned       helper,
                                             int            argSize,
                                             int            retSize);


#if CSELENGTH

    regNumber           genEvalCSELength    (GenTreePtr     ind,
                                             GenTreePtr     adr,
                                             GenTreePtr     ixv);

    unsigned            genCSEevalRegs      (GenTreePtr     tree);

#endif

    GenTreePtr          genIsAddrMode       (GenTreePtr     tree,
                                             GenTreePtr *   indxPtr);

    //=========================================================================
    //  Debugging support
    //=========================================================================

#ifdef DEBUGGING_SUPPORT

    void                genIPmappingAdd (IL_OFFSET          offset);
    void                genIPmappingAddToFront(IL_OFFSET    offset);
    void                genIPmappingGen ();

    //-------------------------------------------------------------------------
    // scope info for the variables

    void                genSetScopeInfo (unsigned           which,
                                         unsigned           startOffs,
                                         unsigned           length,
                                         unsigned           varNum,
                                         unsigned           LVnum,
                                         bool               avail,
                                         const siVarLoc &   loc);

    void                genSetScopeInfo ();

    // Array of scopes of LocalVars in terms of native code

#ifdef DEBUG
    TrnslLocalVarInfo *     genTrnslLocalVarInfo;
    unsigned                genTrnslLocalVarCount;
#endif

#endif //DEBUGGING_SUPPORT



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           Compiler                                        XX
XX                                                                           XX
XX   Generic info about the compilation and the method being compiled.       XX
XX   It is resposible for driving the other phases.                          XX
XX   It is also responsible for all the memory management.                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

public :

    bool                compTailCallUsed;       // Does the method do a tailcall
    bool                compLocallocUsed;       // Does the method use localloc

    //---------------------------- JITing options -----------------------------

    struct Options
    {
        unsigned            eeFlags;            // flags passed from the EE
        unsigned            compFlags;

        bool                compFastCode;   // optimize for faster code

        // optimize maximally and/or favor speed over size?

#if   ALLOW_MIN_OPT
        bool                compMinOptim;
#else
        static const bool   compMinOptim;
#endif

#if     SCHEDULER
        bool                compSchedCode;
#endif

#if DOUBLE_ALIGN
        bool                compDoubleAlignDisabled;
#endif

#ifdef DEBUGGING_SUPPORT
        bool                compScopeInfo;  // Generate the LocalVar info ?
        bool                compDbgCode;    // Generate debugger-friendly code?
        bool                compDbgInfo;    // Gather debugging info?
        bool                compDbgEnC;
#else
        static const bool   compDbgCode;
#endif

#ifdef PROFILER_SUPPORT
        bool                compEnterLeaveEventCB;
        bool                compCallEventCB;
#else
        static const bool   compEnterLeaveEventCB;
        static const bool   compCallEventCB;
#endif

#ifdef LATE_DISASM
        bool                compDisAsm;
        bool                compLateDisAsm;
#endif

#if     SECURITY_CHECK
        bool                compNeedSecurityCheck; // need to allocate a "hidden" local of type ref.
#endif

#if     RELOC_SUPPORT
                bool                            compReloc;
#endif
    }
        opts;



    //--------------------- Info about the procedure --------------------------

    struct Info
    {
        COMP_HANDLE     compCompHnd;
        SCOPE_HANDLE    compScopeHnd;
        METHOD_HANDLE   compMethodHnd;
        JIT_METHOD_INFO*compMethodInfo;

#ifdef  DEBUG
        const   char *  compMethodName;
        const   char *  compClassName;
        const   char *  compFullName;
#endif

        // The following holds the FLG_xxxx flags for the method we're compiling.
        unsigned        compFlags;

        const BYTE *    compCode;
        size_t          compCodeSize;
        bool            compBCreadOnly       : 1;      // can we scribble on the IL
        bool            compIsStatic         : 1;
        bool            compIsVarArgs        : 1;
        bool            compInitMem          : 1;
        bool            compStrictExceptions : 1;      // JIT must enforce strict IL-ordering of exception

        var_types       compRetType;
        unsigned        compArgsCount;
        int             compRetBuffArg;                 // position of hidden return param var (0, 1) (neg means not present);
        unsigned        compLocalsCount;
        unsigned        compMaxStack;

        static unsigned compNStructIndirOffset; // offset of real ptr in NStruct proxy object

#if INLINE_NDIRECT
        unsigned        compCallUnmanaged;
        unsigned        compLvFrameListRoot;
        unsigned        compNDFrameOffset;
#endif
        EEInfo          compEEInfo;

        unsigned        compXcptnsCount;        // number of exceptions

#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)

        /*  The following holds information about local variables.
         */

        unsigned                compLocalVarsCount;
        LocalVarDsc *           compLocalVars;

        /* The following holds information about IL offsets for
         * which we need to report IP-mappings
         */

        IL_OFFSET   *           compStmtOffsets;        // sorted
        unsigned                compStmtOffsetsCount;
        ImplicitStmtOffsets     compStmtOffsetsImplicit;

        //  The following holds the line# tables, if present.
        srcLineDsc  *           compLineNumTab;         // sorted by offset
        unsigned                compLineNumCount;

#endif // DEBUGGING_SUPPORT || DEBUG

    }
        info;

#ifndef NOT_JITC

struct excepTable
{
    unsigned short  startPC;
    unsigned short  endPC;
    unsigned short  handlerPC;
    unsigned short  catchType;
};

#endif

    //-------------------------- Global Compiler Data ------------------------------------

#ifdef  DEBUG
    static unsigned     s_compMethodsCount;     // to produce unique label names
#endif

    BasicBlock  *       compCurBB;              // the current basic block in process
    BasicBlock  *       compFilterHandlerBB;    // used in the importer, usually NULL
                                                // while importing a filter, this points
                                                // to the corresponding catch handler
    GenTreePtr          compCurStmt;            // the current statement in process

    //  The following is used to create the 'method JIT info' block.
    size_t              compInfoBlkSize;
    BYTE    *           compInfoBlkAddr;

    EHblkDsc *          compHndBBtab;

    //-------------------------------------------------------------------------
    //  The following keeps track of how many bytes of local frame space we've
    //  grabbed so far in the current function, and how many argument bytes we
    //  need to pop when we return.
    //

    size_t              compFrameSizeEst;       // estimate of the frame size (compStkFrameSize+calleeSavedRegs)
    size_t              compLclFrameSize;       // secObject+lclBlk+locals+temps
    unsigned            compCalleeRegsPushed;   // count of callee-saved regs we pushed in the prolog
    size_t              compArgSize;

    //-------------------------------------------------------------------------

    static void         compStartup     ();     // One-time initialization
    static void         compShutdown    ();     // One-time finalization

    void                compInit        (norls_allocator *);
    void                compDone        ();

    int FASTCALL        compCompile     (METHOD_HANDLE     methodHnd,
                                         SCOPE_HANDLE      classPtr,
                                         COMP_HANDLE       compHnd,
                                         const  BYTE *     bodyAddr,
                                         size_t            bodySize,
                                         SIZE_T *          nativeSizeOfCode,
                                         unsigned          lvaCount,
                                         unsigned          maxStack,
                                         JIT_METHOD_INFO*  methodInfo,
#ifndef NOT_JITC
                                         unsigned          EHcount,
                                         excepTable      * EHtable,
#endif
                                         BasicBlock      * BBlist,
                                         unsigned          BBcount,
                                         BasicBlock *    * hndBBtab,
                                         unsigned          hndBBcnt,
                                         void *          * methodCodePtr,
                                         void *          * methodConsPtr,
                                         void *          * methodDataPtr,
                                         void *          * methodInfoPtr,
                                         unsigned          compileFlags);

    void  *  FASTCALL   compGetMem          (size_t     sz);
    void  *  FASTCALL   compGetMemA         (size_t     sz);
    static
    void  *  FASTCALL   compGetMemCallback  (void *,    size_t);
    void                compFreeMem         (void *);

    void    __cdecl     compMakeBCWriteable (void *     ptr, ...);

#ifdef DEBUG
    LocalVarDsc *       compFindLocalVar    (unsigned   varNum,
                                             unsigned   lifeBeg = 0,
                                             unsigned   lifeEnd = UINT_MAX);
    const   char *      compLocalVarName    (unsigned   varNum, unsigned offs);
    lvdNAME             compRegVarNAME      (regNumber  reg,
                                             bool       fpReg = false);
    const   char *      compRegVarName      (regNumber  reg,
                                             bool       displayVar = false);
#if TGT_x86
    const   char *      compRegPairName     (regPairNo  regPair);
    const   char *      compRegNameForSize  (regNumber  reg,
                                             size_t     size);
    const   char *      compFPregVarName    (unsigned   fpReg,
                                             bool       displayVar = false);
#endif

    void                compDspSrcLinesByNativeIP   (NATIVE_IP      curIP);
    void                compDspSrcLinesByILoffs     (IL_OFFSET      curOffs);
    void                compDspSrcLinesByLineNum    (unsigned       line,
                                                     bool           seek = false);

    unsigned            compFindNearestLine (unsigned lineNo);
    const char *        compGetSrcFileName  ();

#endif

    unsigned            compLineNumForILoffs(IL_OFFSET  offset);

    //-------------------------------------------------------------------------

#ifdef DEBUGGING_SUPPORT

    LocalVarDsc **      compEnterScopeList;  // List has the offsets where variables
                                            // enter scope, sorted by IL offset
    unsigned            compNextEnterScope;

    LocalVarDsc **      compExitScopeList;   // List has the offsets where variables
                                            // go out of scope, sorted by IL offset
    unsigned            compNextExitScope;


    void                compInitScopeLists      ();

    void                compResetScopeLists     ();

    LocalVarDsc *       compGetNextEnterScope   (unsigned offs, bool scan=false);

    LocalVarDsc *       compGetNextExitScope    (unsigned offs, bool scan=false);

    void                compProcessScopesUntil  (unsigned     offset,
                               void (*enterScopeFn)(LocalVarDsc *, unsigned),
                               void (*exitScopeFn) (LocalVarDsc *, unsigned),
                               unsigned     clientData);

#endif // DEBUGGING_SUPPORT


    //-------------------------------------------------------------------------
    /*               Statistical Data Gathering                               */

    void                compJitStats();             // call this function and enable
                                                    // various ifdef's below for statiscal data

#if CALL_ARG_STATS
    void                compCallArgStats();
    static void         compDispCallArgStats();
#endif


    //-------------------------------------------------------------------------

protected :

    norls_allocator *   compAllocator;

    void                compInitOptions (unsigned compileFlags);

    void                compInitDebuggingInfo();

    void                compCompile  (void * * methodCodePtr,
                                      void * * methodConsPtr,
                                      void * * methodDataPtr,
                                      void * * methodInfoPtr,
                                      SIZE_T * nativeSizeOfCode);

};


/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                   Miscellaneous Compiler stuff                            XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

// Values used to mark the types a stack slot is used for

const unsigned TYPE_REF_INT         = 0x01; // slot used as a 32-bit int
const unsigned TYPE_REF_LNG         = 0x02; // slot used as a 64-bit long
const unsigned TYPE_REF_FLT         = 0x04; // slot used as a 32-bit float
const unsigned TYPE_REF_DBL         = 0x08; // slot used as a 64-bit float
const unsigned TYPE_REF_PTR         = 0x10; // slot used as a 32-bit pointer
const unsigned TYPE_REF_BYR         = 0x20; // slot used as a byref pointer - @TODO
const unsigned TYPE_REF_STC         = 0x40; // slot used as a struct
const unsigned TYPE_REF_TYPEMASK    = 0x7F; // bits that represent the type

//const unsigned TYPE_REF_ADDR_TAKEN  = 0x80; // slots address was taken

/*****************************************************************************
 * C-style pointers are implemented as TYP_INT or TYP_LONG depending on the
 * platform
 */

#if defined(_WIN64) || defined(TGT_IA64)
#define TYP_I_IMPL          TYP_LONG
#define TYP_U_IMPL          TYP_LONG        // bizarre, eh?
#define TYPE_REF_IIM        TYPE_REF_LNG
#else
#define TYP_I_IMPL          TYP_INT
#define TYP_U_IMPL          TYP_UINT
#define TYPE_REF_IIM        TYPE_REF_INT
#endif

/*****************************************************************************/

extern int         JITGcBarrierCall;


/*****************************************************************************/

extern int         JITGcBarrierCall;

/*****************************************************************************
 *
 *  Variables to keep track of total code amounts.
 */

#if DISPLAY_SIZES

extern  unsigned    grossVMsize;
extern  unsigned    grossNCsize;
extern  unsigned    totalNCsize;

extern  unsigned    genMethodICnt;
extern  unsigned    genMethodNCnt;

#if TGT_IA64
extern  unsigned    genAllInsCnt;
extern  unsigned    genNopInsCnt;
#endif

extern  unsigned    gcHeaderISize;
extern  unsigned    gcPtrMapISize;
extern  unsigned    gcHeaderNSize;
extern  unsigned    gcPtrMapNSize;

#endif

/*****************************************************************************
 *
 *  Variables to keep track of basic block counts (more data on 1 BB methods)
 */

#if COUNT_BASIC_BLOCKS
extern  histo       bbCntTable;
extern  histo       bbOneBBSizeTable;
#endif

/*****************************************************************************
 *
 *  Variables to get inliner eligibility stats
 */

#if INLINER_STATS

extern  histo       bbStaticTable;
extern  histo       bbInitTable;
extern  histo       bbInlineTable;

extern  unsigned    synchMethCnt;
extern  unsigned    clinitMethCnt;

#endif

/*****************************************************************************
 *
 *  Used by optFindNaturalLoops to gather statistical information such as
 *   - total number of natural loops
 *   - number of loops with 1, 2, ... exit conditions
 *   - number of loops that have an iterator (for like)
 *   - number of loops that have a constant iterator
 */

#if COUNT_LOOPS

extern unsigned    totalLoopMethods;      // counts the total number of methods that have natural loops
extern unsigned    maxLoopsPerMethod;     // counts the maximum number of loops a method has
extern unsigned    totalLoopCount;        // counts the total number of natural loops
extern unsigned    exitLoopCond[8];       // counts the # of loops with 0,1,2,..6 or more than 6 exit conditions
extern unsigned    iterLoopCount;         // counts the # of loops with an iterator (for like)
extern unsigned    simpleTestLoopCount;   // counts the # of loops with an iterator and a simple loop condition (iter < const)
extern unsigned    constIterLoopCount;    // counts the # of loops with a constant iterator (for like)

extern bool        hasMethodLoops;        // flag to keep track if we already counted a method as having loops
extern unsigned    loopsThisMethod;       // counts the number of loops in the current method

#endif

/*****************************************************************************
 * variables to keep track of how many iterations we go in a dataflow pass
 */

#if DATAFLOW_ITER

extern unsigned    CSEiterCount;           // counts the # of iteration for the CSE dataflow
extern unsigned    CFiterCount;            // counts the # of iteration for the Const Folding dataflow

#endif

/*****************************************************************************
 *
 *  Used in the new DFA to catch dead assignments which are not removed
 *  because they contain calls
 */

#if COUNT_DEAD_CALLS

extern unsigned    deadHelperCount;           // counts the # of dead helper calls
extern unsigned    deadCallCount;             // counts the # of dead standard calls (like i=f(); where i is dead)
extern unsigned    removedCallCount;          // counts the # of dead standard calls that we removed

#endif

#if     MEASURE_BLOCK_SIZE
extern  size_t      genFlowNodeSize;
extern  size_t      genFlowNodeCnt;
#endif

/*****************************************************************************/
#ifndef NOT_JITC
/*****************************************************************************
 *
 *  We keep track of methods we've already compiled.
 */

#ifdef  DEBUG

struct  MethodList
{
    MethodList   *  mlNext;
    const   char *  mlName;
    const   char *  mlType;
    const   char *  mlClaz;
    void         *  mlAddr;
};

extern
MethodList  *       genMethodList;

#endif

/*****************************************************************************/
#endif // NOT_JITC
/*****************************************************************************/



/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                        get                                                XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/*****************************************************************************/
#ifndef NOT_JITC
/*****************************************************************************
 *
 *  A wrapper to create 'BIL' symbols to pass to the code generator.
 */

const   char *      genSkipTypeString(const char *str);
var_types           genVtypOfTypeString(const char *str);

#define __TODO_PORT_TO_WRAPPERS__
#include "peloader.h"           // For PELoader
#include "siginfo.hpp"          // For CallSig
#include "DbgMeta.h"            // For DebuggerLineBlock and DebuggerLexicalScope

#include "host.h"               // get back our assert, rudely stolen by DebugMacros.h

struct  CompInfo
{
    PEFile                  *  symPEFile;
    IMDInternalImport       *  symMetaData;
    COR_ILMETHOD_DECODER    *  symPEMethod;
    mdTypeDef                  symClass;
    mdMethodDef                symMember;
    DWORD                      symAttrs;
    LPCSTR                     symMemberName;
    LPCSTR                     symClassName;
    MetaSig                 *  symMetaSig;
    PCCOR_SIGNATURE            symSig;

    CompInfo(   PEFile            * peLoader,
                IMDInternalImport * metaData,
                COR_ILMETHOD_DECODER*peMethod,
                mdTypeDef           cls,
                mdMethodDef         member,
                DWORD               mdAttrs,
                DWORD               miAttrs,
                LPCSTR              name,
                LPCSTR              className,
                MetaSig        *    metaSig,
                PCCOR_SIGNATURE     sig)
    {
        symPEFile       = peLoader;
        symMetaData     = metaData;
        symClass        = cls;
        symMember       = member;
        symMemberName   = name;
        symClassName    = className;
        symPEMethod     = peMethod;
        symMetaSig      = metaSig;
        symSig          = sig;

        assert (symPEFile);
        assert (symMetaData);
        assert (symMemberName);
        assert (symPEMethod);

        symAttrs        = 0;
        if (IsMdStatic(mdAttrs))            symAttrs |= FLG_STATIC;
        if (IsMiSynchronized(miAttrs))      symAttrs |= FLG_SYNCH;
    }

    unsigned        getGetFlags() const
    {
        return  symAttrs;
    }

    const char    * getName    () const
    {
        return symMemberName;
    }


    bool            getIsMethod() const
    {
        return (symClass != COR_GLOBAL_PARENT_TOKEN);
    }
};

/*****************************************************************************/
#endif // NOT_JITC
/*****************************************************************************/


#include "Compiler.hpp"     // All the shared inline functions



/*****************************************************************************/
#endif //_COMPILER_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\disasm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***********************************************************************
*
* File: dis.cpp
*
* File Comments:
*
*  This file handles disassembly. It is adapted from the MS linker.
*
***********************************************************************/

#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/
#ifdef      LATE_DISASM
#if         TGT_x86
/*****************************************************************************/

#define _OLD_IOSTREAMS
#include "msdis.h"
#include "disx86.h"

/*****************************************************************************/

#undef  eeGetFieldName
#undef  eeGetMethodName
#undef  eeFindField
#define eeFindField             pDisAsm->disComp->eeFindField
#define eeGetFieldName          pDisAsm->disComp->eeGetFieldName
#define eeGetMethodName         pDisAsm->disComp->eeGetMethodName


#ifdef NOT_JITC
/* static */
FILE *              DisAssembler::s_disAsmFile = 0;
#endif

/*****************************************************************************/

void                DisAssembler::disInit(Compiler * pComp)
{
    assert(pComp);
    disComp         = pComp;
    disHasName      = 0;
    disJumpTarget   = NULL;
}

/*****************************************************************************/


static
size_t __stdcall    disCchAddr(const DIS * pdis,   DWORD addr, char * sz,
                                size_t cchMax,  DWORDLONG * pdwDisp);
static
size_t __stdcall    disCchFixup(const DIS * pdis,  DWORD addr, size_t callSize,
                                char * sz, size_t cchMax, DWORDLONG * pdwDisp);
static
size_t __stdcall    disCchRegRel(const DIS * pdis, DIS::REGA reg,
                                 DWORD disp, char * sz, size_t cchMax,
                                 DWORD * pdwDisp);
static
size_t __stdcall    disCchReg(const DIS * pdis, enum DIS::REGA reg,
                                          char * sz, size_t cchMax);

/*****************************************************************************
 * Given an absolute address from the beginning of the code
 * find the corresponding emitter block and the relative offset
 * of the current address in that block
 * Was used to get to the fixup list of each block. The new emitter has
 * no such fixups. Something needs to be added for this.
 */

// @TODO : Remove this. The real "newEmit" is deprecated.
const int newEmit = 1;

// These structs were defined in emit.h. Fake them here so DisAsm.cpp can compile

typedef struct codeFix
{   codeFix  * cfNext;
    unsigned cfFixup;
}
             * codeFixPtr;

typedef struct codeBlk
{   codeFix  * cbFixupLst;  }
             * codeBlkPtr;

DWORD               emitFindBlockOffs(DWORD addr, codeBlkPtr * emitBlock)
{
    fatal(ERRinternal,"Deprecated since the new emitter was added", "");
    return NULL;
}

/*****************************************************************************
 *
 * The following is the callback for jump label and direct function calls fixups
 * "addr" represents the address of jump that has to be
 * replaced with a label or function name
 */

size_t __stdcall disCchAddr(const DIS * pdis,   DIS::ADDR addr, char * sz,
                                                        size_t cchMax,  DWORDLONG * pdwDisp)
{
    DisAssembler * pDisAsm = (DisAssembler *) pdis->PvClient();
    assert(pDisAsm);

    codeBlkPtr  emitBlock = 0;
    DWORD       offs = 0;
    codeFixPtr  fix = 0;
    DIS::TRMTA terminationType;
    int disCallSize;

    /* First check the termination type of the instruction
     * because this might be a helper or static function call
     * check to see if we have a fixup for the current address */

    terminationType = pdis->Trmta();
    switch (terminationType)
    {
    case DISX86::trmtaJmpShort:
    case DISX86::trmtaJmpCcShort:

        /* here we have a short jump in the current code block - generate the label to which we jump */

        sprintf(sz, "short L_%02u", pDisAsm->disJumpTarget[pDisAsm->target]);
        break;

    case DISX86::trmtaJmpNear:
    case DISX86::trmtaJmpCcNear:

        /* here we have a near jump - check if is in the current code block
         * Otherwise is we have no target for it */

        if (pDisAsm->target <  pDisAsm->codeSize && pDisAsm->target >= 0)
        {
           sprintf(sz, "L_%02u", pDisAsm->disJumpTarget[pDisAsm->target]);
           break;
        }
        else
            return false;

    case DISX86::trmtaCallNear16:
    case DISX86::trmtaCallNear32:

        /* check for local calls (i.e. CALL label) */

        if (pDisAsm->target < pDisAsm->codeSize && pDisAsm->target >= 0)
        {
#if !defined(NOT_JITC)

            /* HACK to make JVC work - in JVC the call to helper functions are not "fixed"
             * and look like "call dword ptr ds:[0]" therefore confusing the dissasembler
             * which thinks this is a local call - we have to check if the target
             * of the call is the following instruction */

            if (pDisAsm->curOffset + pDisAsm->instSize != pDisAsm->target)
#endif
            {
                /* not a "call ds:[0000]" - go ahead */
                /* target within block boundary -> local call */

                sprintf(sz, "short L_%02u", pDisAsm->disJumpTarget[pDisAsm->target]);
                break;
            }
        }

        /* this is a near call - in our case usually VM helper functions */

        /* find the emitter block and the offset of the call fixup */
        /* for the fixup offset we have to add the opcode size for the call - in the case of a near call is 1 */

        disCallSize = 1;

        return false;

    default:

        printf("Termination type is %d\n", (int) terminationType);
        assert(!"treat this case\n");
        break;
    }

    /* no displacement */

    *pdwDisp = 0x0;

    return true;
}



/*****************************************************************************
 *
 * We annotate some instructions to get info needed to display the symbols
 * for that instruction
 */

size_t __stdcall disCchFixup(const DIS * pdis,  DIS::ADDR addr, size_t callSize,
                             char * sz, size_t cchMax, DWORDLONG * pdwDisp)
{
    DisAssembler * pDisAsm = (DisAssembler *) pdis->PvClient();
    assert(pDisAsm);

    codeBlkPtr  emitBlock = 0;
    DWORD       offs = 0;
    codeFixPtr  fix = 0;
    DIS::TRMTA terminationType;
    //DIS::ADDR disIndAddr;
    int disCallSize;

    terminationType = pdis->Trmta();
    switch (terminationType)
    {
    case DISX86::trmtaFallThrough:

        /* memory indirect case */

        assert(addr > pdis->Addr());

        /* find the emitter block and the offset for the fixup
         * "addr" is the address of the immediate */

        return false;

    case DISX86::trmtaJmpInd:

        /* pretty rare case - something like "jmp [eax*4]"
         * not a function call or anything worth annotating */

        return false;

        case DISX86::trmtaJmpShort:
        case DISX86::trmtaJmpCcShort:

        case DISX86::trmtaJmpNear:
        case DISX86::trmtaJmpCcNear:

        case DISX86::trmtaCallNear16:
        case DISX86::trmtaCallNear32:

        /* these are treated by the CchAddr callback - skip them */

        return false;

    case DISX86::trmtaCallInd:

        /* here we have an indirect call - find the indirect address */

        //BYTE * code = (BYTE *) (pDisAsm->codeBlock+addr);
        //disIndAddr = (DIS::ADDR) (code+0);

        /* find the size of the call opcode - less the immediate */
        /* for the fixup offset we have to add the opcode size for the call */
        /* addr is the address of the immediate, pdis->Addr() returns the address of the dissasembled instruction */

        assert(addr > pdis->Addr());
        disCallSize = addr - pdis->Addr();

        /* find the emitter block and the offset of the call fixup */

        return false;

    default:

        printf("Termination type is %d\n", (int) terminationType);
        assert(!"treat this case\n");
        break;
    }

    /* no displacement */

    *pdwDisp = 0x0;

    return true;
}



/*****************************************************************************
 *
 * This the callback for register-relative operands in an instruction.
 * If the register is ESP or EBP, the operand may be a local variable
 * or a parameter, else the operand may be an instance variable
 */

size_t __stdcall disCchRegRel(const DIS * pdis, DIS::REGA reg, DWORD disp,
               char * sz, size_t cchMax, DWORD * pdwDisp)
{
    DisAssembler * pDisAsm = (DisAssembler *) pdis->PvClient();
    assert(pDisAsm);

    codeBlkPtr  emitBlock = 0;
    DWORD       offs = 0;
    codeFixPtr  fix = 0;
    DIS::TRMTA terminationType;
    //DIS::ADDR disIndAddr;
    int disOpcodeSize;
    const char * var;


    terminationType = pdis->Trmta();
    switch (terminationType)
    {
    case DISX86::trmtaFallThrough:

        /* some instructions like division have a TRAP termination type - ignore it */

    case DISX86::trmtaTrap:
    case DISX86::trmtaTrapCc:

        var = pDisAsm->disComp->siStackVarName(
                                    pdis->Addr() - pDisAsm->startAddr,
                                    pdis->Cb(),
                                    reg,
                                    disp );
        if (var)
        {
            sprintf (sz, "%s+%Xh '%s'", getRegName(reg), disp, var);
            *pdwDisp = 0;

            return true;
        }

        /* This case consists of non-static members */

        /* find the emitter block and the offset for the fixup
         * fixup is emited after the coding of the instruction - size = word (2 bytes)
         * GRRRR!!! - for the 16 bit case we have to check for the address size prefix = 0x66
         */

        if (*((BYTE *)(pDisAsm->codeBlock + pDisAsm->curOffset)) == 0x66)
        {
            disOpcodeSize = 3;
        }
        else
        {
            disOpcodeSize = 2;
        }

        return false;

    case DISX86::trmtaCallNear16:
    case DISX86::trmtaCallNear32:
    case DISX86::trmtaJmpInd:

        break;

    case DISX86::trmtaCallInd:

        /* check if this is a one byte displacement */

        if  ((signed char)disp == (int)disp)
        {
            /* we have a one byte displacement -> there were no previous callbacks */

            /* find the size of the call opcode - less the immediate */
            /* this is a call R/M indirect -> opcode size is 2 */

            disOpcodeSize = 2;

            /* find the emitter block and the offset of the call fixup */

            return false;
        }
        else
        {
            /* check if we already have a symbol name as replacement */

            if (pDisAsm->disHasName)
            {
                /* CchFixup has been called before - we have a symbol name saved in global var pDisAsm->funcTempBuf */

                sprintf(sz, "%s+%u '%s'", getRegName(reg), disp, pDisAsm->funcTempBuf);
                *pdwDisp = 0;
                pDisAsm->disHasName = false;
                return true;
            }
            else
                return false;
        }

    default:

        printf("Termination type is %d\n", (int) terminationType);
        assert(!"treat this case\n");

        break;
    }

    /* save displacement */

    *pdwDisp = disp;

    return true;
}



/*****************************************************************************
 *
 * Callback for register operands. Most probably, this is a local variable or
 * a parameter
 */

size_t __stdcall disCchReg(const DIS * pdis, enum DIS::REGA reg,
               char * sz, size_t cchMax)
{
    DisAssembler * pDisAsm = (DisAssembler *) pdis->PvClient();
    assert(pDisAsm);

    const char * var = pDisAsm->disComp->siRegVarName(
                                            pdis->Addr() - pDisAsm->startAddr,
                                            pdis->Cb(),
                                            reg);

    if (var)
    {
        if(pDisAsm->disHasName)
        {
            /* CchRegRel has been called before - we have a symbol name saved in global var pDisAsm->funcTempBuf */

            sprintf(sz, "%s'%s.%s'", getRegName(reg), var, pDisAsm->funcTempBuf);
            pDisAsm->disHasName = false;
            return true;
        }
        else
        {
            sprintf(sz, "%s'%s'", getRegName(reg), var);
            return true;
        }
    }
    else
    {
        if(pDisAsm->disHasName)
        {
            /* this is the ugly case when a varible is incorrectly presumed dead */

            sprintf(sz, "%s'%s.%s'", getRegName(reg), "<InstVar>", pDisAsm->funcTempBuf);
            pDisAsm->disHasName = false;
            return true;

        }

        /* just to make sure I don't mess up if var returns NULL */
        pDisAsm->disHasName = false;
        return false;
    }
}



/*****************************************************************************
 *
 */

size_t CbDisassemble(DIS *          pdis,
                     unsigned       offs,
                     DIS::ADDR      addr,
                     const BYTE *   pb,
                     size_t         cbMax,
                     FILE       *   pfile,
                     int            findJumps,
                     int            printit         = 0,
                     int            dispOffs        = 0,
                     bool           dispCodeBytes   = false)
{
    assert(pdis);
    DisAssembler * pDisAsm = (DisAssembler *)pdis->PvClient();
    assert (pDisAsm);

    size_t cb = pdis->CbDisassemble(addr, pb, cbMax);

    if (cb == 0)
    {
        assert(!"can't disassemble instruction!!!");
        fprintf(pfile, "%02Xh\n", *pb);
        return(1);
    }

    /* remember current offset and instruction size */

    pDisAsm->curOffset = addr;
    pDisAsm->instSize = cb;

    /* Check if instruction is a jump or local call */

    pDisAsm->target = pdis->AddrTarget();

    if (findJumps)
    {
    if (pDisAsm->target)
    {

        /* check the termination type of the instruction */

        DIS::TRMTA terminationType = pdis->Trmta();

        switch (terminationType)
        {
        case DISX86::trmtaCallNear16:
        case DISX86::trmtaCallNear32:
#if !defined(NOT_JITC)

            /* HACK to make JVC work - in JVC the call to helper functions are not "fixed"
             * and look like "call dword ptr ds:[0]" therefore confusing the dissasembler
             * which thinks this is a local call - we have to check if the target
             * of the call is the following instruction - if so ignore it, it's not a label */

            if (pDisAsm->curOffset + pDisAsm->instSize == pDisAsm->target)
            {
                break;
            }
#endif

        /* fall through */

        case DISX86::trmtaJmpShort:
        case DISX86::trmtaJmpNear:
        case DISX86::trmtaJmpCcShort:
        case DISX86::trmtaJmpCcNear:

            /* a CALL is local iff the target is within the block boundary */

            /* mark the jump label in the target vector and return */

            if (pDisAsm->target <  pDisAsm->codeSize && pDisAsm->target >= 0)
            {
                /* we're OK, target within block boundary */

                pDisAsm->disJumpTarget[pDisAsm->target] = 1;
            }
            break;

        case DISX86::trmtaJmpInd:
        case DISX86::trmtaJmpFar:
        case DISX86::trmtaCallFar:
        default:

            /* jump is not in the current code block */
        break;
        }

    } // end if
    return cb;

    } // end for

    /* check if we have a label here */

    if (printit)
    {
        if (pDisAsm->disJumpTarget[addr])
        {
            /* print the label and the offset */

//          fprintf(pfile, "\n%08x", addr);
            fprintf(pfile, "L_%02u:\n", pDisAsm->disJumpTarget[addr]);
        }
    }

    char sz[256];
    pdis->CchFormatInstr(sz, sizeof(sz));

    if (printit)
    {
        if (dispOffs) fprintf(pfile, "%03X", offs);

        #define BYTES_OR_INDENT  24

        size_t cchIndent = BYTES_OR_INDENT;

        if (dispCodeBytes)
        {
            static size_t cchBytesMax = pdis->CchFormatBytesMax();

            char   szBytes[256];
            assert(cchBytesMax < 256);

            size_t cchBytes = pdis->CchFormatBytes(szBytes, sizeof(szBytes));

            if (cchBytes > BYTES_OR_INDENT)
            {
                // Truncate the bytes if they are too long

                static int elipses = *(int*)"...";

                *(int*)&szBytes[BYTES_OR_INDENT-sizeof(int)] = elipses;

                cchBytes = BYTES_OR_INDENT;
            }

            fprintf(pfile, "  %s", szBytes);

            cchIndent = BYTES_OR_INDENT - cchBytes;
        }

        // print the dis-assembled instruction

        fprintf(pfile, "%*c%s\n", cchIndent, ' ', sz);
    }

    return cb;
}



size_t CbDisassembleWithBytes(
                  DIS        * pdis,
                  DIS::ADDR    addr,
                  const BYTE * pb,
                  size_t       cbMax,
                  FILE       * pfile)
{
    assert(pdis);
    DisAssembler * pDisAsm = (DisAssembler *)pdis->PvClient();
    assert (pDisAsm);

    char sz[256];

    pdis->CchFormatAddr(addr, sz, sizeof(sz));
    size_t cchIndent = (size_t) fprintf(pfile, "  %s: ", sz);

    size_t cb = pdis->CbDisassemble(addr, pb, cbMax);

    if (cb == 0)
    {
        fprintf(pfile, "%02Xh\n", *pb);
        return(1);
    }

    size_t cchBytesMax = pdis->CchFormatBytesMax();

    if (cchBytesMax > 18)
    {
        // Limit bytes coded to 18 characters

        cchBytesMax = 18;
    }

    char szBytes[64];
    size_t cchBytes = pdis->CchFormatBytes(szBytes, sizeof(szBytes));

    char *pszBytes;
    char *pszNext;

    for (pszBytes = szBytes; pszBytes != NULL; pszBytes = pszNext)
    {
        BOOL fFirst = (pszBytes == szBytes);

        cchBytes = strlen(pszBytes);

        if (cchBytes <= cchBytesMax)
        {
            pszNext = NULL;
        }

        else
        {
            char ch = pszBytes[cchBytesMax];
            pszBytes[cchBytesMax] = '\0';

            if (ch == ' ')
            {
                pszNext = pszBytes + cchBytesMax + 1;
            }

            else
            {
                pszNext = strrchr(pszBytes, ' ');

                pszBytes[cchBytesMax] = ch;
                *pszNext++ = '\0';
            }
        }

        if (fFirst)
        {
            pdis->CchFormatInstr(sz, sizeof(sz));
            fprintf(pfile, "%-*s %s\n", cchBytesMax, pszBytes, sz);
        }

        else
        {
            fprintf(pfile, "%*c%s\n", cchIndent, ' ', pszBytes);
        }
    }

    return(cb);
}


void DisAssembler::DisasmBuffer(DWORD         addr,
                                const BYTE *  rgb,
                                DWORD         cbBuffer,
                                FILE  *       pfile,
                                int           printit)
{
    DIS *pdis;

    pdis = DIS::PdisNew(DIS::distX86);

    if (pdis == NULL)
    {
        assert(!"out of memory in disassembler?");
    }

    // Store a pointer to the DisAssembler so that the callback functions
    // can get to it.

    pdis->PvClientSet((void*)this);

    /* Calculate addresses */

    IL_OFFSET   ibCur   = 0;
    const BYTE *pb      = rgb;

    startAddr   = addr;
    codeBlock   = (DIS::ADDR) rgb;
    codeSize    = cbBuffer;

    /* First walk the code to find all jump targets */

    while (ibCur < cbBuffer)
    {
        size_t  cb;
        int     findJumps = 1;

        cb = CbDisassemble(pdis,
                           ibCur,
                           addr + ibCur,
                           pb,
                           (size_t) (cbBuffer-ibCur),
                           pfile,
                           findJumps,
                           0,
                           0);

        ibCur += cb;
        pb    += cb;
    }

    /* reset the label counter and start assigning consecutive number labels to the target locations */

    label = 0;
    for(int i = 0; i < codeSize; i++)
    {
        if (disJumpTarget[i] != 0)
        {
            disJumpTarget[i] = ++label;
        }
    }

    /* Re-initialize addresses for dissasemble phase */

    ibCur = 0;
    pb = rgb;

    // Set callbacks only if we are displaying it. Else, the scheduler has called it

    if (printit)
    {
        /* Set the callback functions for symbol lookup */

        pdis->PfncchaddrSet(disCchAddr);
        pdis->PfncchfixupSet(disCchFixup);
        pdis->PfncchregrelSet(disCchRegRel);
        pdis->PfncchregSet(disCchReg);
    }

    while (ibCur < cbBuffer)
    {
        size_t cb;

#ifndef NOT_JITC
        if (printit)
            disComp->compDspSrcLinesByNativeIP(ibCur);
#endif

        cb = CbDisassemble (pdis,
                            ibCur,
                            addr + ibCur,
                            pb,
                            (size_t) (cbBuffer-ibCur),
                            pfile,
                            0,
                            printit,
                            verbose||1,  // display relative offset
                            dspEmit);
        ibCur += cb;
        pb += cb;
    }

    delete pdis;
}


/*****************************************************************************
 *
 * Disassemble the code which has been generated
 */

void    DisAssembler::disAsmCode(BYTE * codePtr, unsigned size)
{
    // As this writes to a common file, this is not reentrant.

    FILE * pfile;

#ifndef NOT_JITC
    pfile = stdout;
    fprintf (pfile, "Dissasembled code (%d bytes) :\n", size);
#else
    pfile = s_disAsmFile;
    fprintf(pfile, "Base address : %08Xh\n", codePtr);
#endif

    if (disJumpTarget == NULL) // Done in ProcInitDisAsm() if !newEmit
    {
        disJumpTarget = (BYTE *)disComp->compGetMem(roundUp(size));
    }

    /* Re-initialize the jump target vector */
    memset(disJumpTarget, 0, roundUp(size));

    DisasmBuffer(0, codePtr, size, pfile, 1);
    fprintf (pfile, "\n");

#ifdef NOT_JITC
    if (pfile != stdout) fclose (pfile);
#endif

}



/*****************************************************************************
 *
 * Do we want to do late disassembly for the current method.
 * The registry value for "DisAsm" should be "class:method".
 * where
 *      class  = fully/qualified/pDisAsm->className, or *
 *      method = pDisAsm->methodName or *
 * eg: *:foo, com/my/myclass:foo, com/my/myclass:*, *:*.
 * The registry value for "DisAsm to" should be a file name where
 * the JITed code for the function will be written to.
 */

#ifdef NOT_JITC


static
char                disClassToDisAsm    [MAX_PATH],
                    disMethodToDisAsm   [MAX_PATH],
                    disFileName         [MAX_PATH];



// This function is called at startup. It looks up the registry for settings.

void                disInitForLateDisAsm()
{
    if (!getEERegistryString("JITLateDisasmTo", disFileName, sizeof(disFileName)))
        disFileName[0] = '\0';
}




// This function is called for every method. Checks if the method name
// matches the registry setting for dis-assembly

void                disOpenForLateDisAsm(const char * curClassName,
                                         const char * curMethodName)
{
    if (disFileName[0])         // Non-empty string
    {
        DisAssembler::s_disAsmFile = fopen (disFileName, "a+");
    }

    if (!DisAssembler::s_disAsmFile)
    {
        disFileName[0] = '\0';  // avoid future tries to fopen() above
        DisAssembler::s_disAsmFile  = stdout;
    }

    fprintf(DisAssembler::s_disAsmFile, "************************** %s.%s "
                                        "**************************\n\n",
                                        curClassName, curMethodName);
}

#endif // NOT_JITC



/*****************************************************************************/
#endif //LATE_DISASM
#endif //TGT_x86
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\disasm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          DisAsm                                           XX
XX                                                                           XX
XX  The dis-assembler to display the native code generated                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#ifndef _DIS_H_
#define _DIS_H_
/*****************************************************************************/
#ifdef LATE_DISASM
/*****************************************************************************/


#ifdef NOT_JITC
void                        disInitForLateDisAsm();
void                        disOpenForLateDisAsm(const char * curClassName,
                                                  const char * curMethodName);
#endif //NOT_JITC



class Compiler;


class DisAssembler
{
public :

    // Constructor
    void            disInit(Compiler * pComp);

    /* Address of the code block to dissasemble */
    DWORD           codeBlock;

    /* Address where the code block is to be loaded */
    DWORD           startAddr;

    /* Size of the code to dissasemble */
    DWORD           codeSize;

    /* Current offset in the code block */
    DWORD           curOffset;

    /* Size (in bytes) of current dissasembled instruction */
    size_t          instSize;

    /* Target address of a jump */
    DWORD           target;

    /* labeling counter */
    unsigned char   label;

    /* temporary buffer for function names */
    char            funcTempBuf[1024];

    /* flag that signals when replacing a symbol name has been deferred for following callbacks */
    int             disHasName;

    /* class, member, method name to be printed */
    const char *    methodName;
    const char *    memberName;
    const char *    className;


    BYTE *          disJumpTarget;

    void            DisasmBuffer ( DWORD         addr,
                                    const BYTE *  rgb,
                                    DWORD         cbBuffer,
                                    FILE  *       pfile,
                                    int           printit );

#ifdef NOT_JITC
    static FILE *   s_disAsmFile;
#endif

    void            disAsmCode(BYTE * codePtr, unsigned size);

    Compiler *      disComp;

};




/*****************************************************************************/
#endif  // LATE_DISASM
/*****************************************************************************/
#endif  // _DIS_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\eeinterface.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          EEInterface                                      XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

// ONLY FUNCTIONS common to all variants of the JIT (EXE, DLL) should go here)
// otherwise they belong in the corresponding directory.

#include "jitpch.h"
#pragma hdrstop

#if defined(DEBUG)

/*****************************************************************************/
const char* Compiler::eeGetMethodFullName (METHOD_HANDLE  hnd)
{
    char        fullName[1024];
    char* ptr = fullName;

    const char* className;
    const char* methodName = eeGetMethodName(hnd, &className);

    bool        hadVarArg  = false;

    /* Right now there is a race-condition in the EE, className can be NULL */

    if (className)
    {
        strcpy(fullName, className);
        strcat(fullName, ".");
    }
    else
        strcpy(fullName, "<NULL>.");
    strcat(fullName, methodName);

    ptr = &ptr[strlen(ptr)];

        // append the signature
    *ptr++ = '(';

        JIT_SIG_INFO sig;
        eeGetMethodSig(hnd, &sig);
        ARG_LIST_HANDLE argLst = sig.args;

    for(unsigned i = 0; i < sig.numArgs; i++)
    {
        varType_t type = eeGetArgType(argLst, &sig);

        if  (type == (varType_t)-1)
        {
            strcpy(ptr, " ... "); ptr += 5;
            hadVarArg = true;
            continue;
        }

        strcpy(ptr, varTypeName(type));
        ptr = &ptr[strlen(ptr)];

        argLst = eeGetArgNext(argLst);
                if (i + 1 < sig.numArgs)
                       *ptr++ = ',';
    }

    if  (sig.callConv == CORINFO_CALLCONV_VARARG && !hadVarArg)
    {
        strcpy(ptr, ", ..."); ptr += 5;
    }

    *ptr++ = ')';
    if (JITtype2varType(sig.retType) != TYP_VOID) {
        *ptr++ = ':';
        strcpy(ptr, varTypeName(JITtype2varType(sig.retType)));
        ptr = &ptr[strlen(ptr)];
        }
    *ptr = 0;

//  printf("Full name = '%s'\n", fullName);

    assert(ptr < &fullName[1024]);
    char* retName = (char *)compGetMemA(strlen(fullName) + 1);
        strcpy(retName, fullName);
    return(retName);
}

#endif // DEBUG

#if defined(DEBUG) || INLINE_MATH
/*****************************************************************************/

const char *        Compiler::eeHelperMethodName(int helper)
{
    ASSert(helper < CPX_HIGHEST);

    const   char *  name;

    switch (helper)
    {
    case CPX_ISTYPE                 : name = "@isType"              ; break;
    case CPX_ISTYPE_CLASS           : name = "@isTypeClass"         ; break;
    case CPX_CHKCAST_CLASS          : name = "@checkCastClass"      ; break;
    case CPX_CHKCAST                : name = "@checkCast"           ; break;
    case CPX_NEWCLS_FAST            : name = "@newClassFast"        ; break;
    case CPX_RNGCHK_FAIL            : name = "@indexFailed"         ; break;
    case CPX_THROW                  : name = "@throw"               ; break;
    case CPX_RETHROW                : name = "@rethrow"             ; break;
    case CPX_STRCNS                 : name = "@stringCns"           ; break;
    case CPX_MON_ENTER              : name = "@monitorEnter"        ; break;
    case CPX_MON_EXIT               : name = "@monitorExit"         ; break;
    case CPX_RES_IFC                : name = "@resolveIntfc"        ; break;
    case CPX_EnC_RES_VIRT           : name = "@encResolveVirt"      ; break;

    case CPX_GETFIELD32             : name = "@getCOMfld32"         ; break;
    case CPX_GETFIELD64             : name = "@getCOMfld64"         ; break;
    case CPX_PUTFIELD32             : name = "@putCOMfld32"         ; break;
    case CPX_PUTFIELD64             : name = "@putCOMfld64"         ; break;
    case CPX_GETFIELDOBJ            : name = "@getfldObj"           ; break;
    case CPX_PUTFIELDOBJ            : name = "@putfldObj"           ; break;
    case CPX_GETFIELDADDR           : name = "@getFldAddr"          ; break;
    case CPX_ARRADDR_ST             : name = "@addrArrStore"        ; break;
    case CPX_LDELEMA_REF            : name = "@ldelemaRef"          ; break;
    case CPX_MONENT_STAT            : name = "@monEnterStat"        ; break;
    case CPX_MONEXT_STAT            : name = "@monExitStat"         ; break;

    case CPX_LONG_LSH               : name = "@longLSH"             ; break;
    case CPX_LONG_RSH               : name = "@longRSH"             ; break;
    case CPX_LONG_RSZ               : name = "@longRSZ"             ; break;
    case CPX_LONG_MUL               : name = "@longMul"             ; break;
    case CPX_LONG_DIV               : name = "@longDiv"             ; break;
    case CPX_LONG_MOD               : name = "@longMod"             ; break;
    case CPX_FLT2INT                : name = "@floatToInt"          ; break;
    case CPX_FLT2LNG                : name = "@floatToLong"         ; break;
    case CPX_DBL2INT                : name = "@doubleToInt"         ; break;
    case CPX_DBL2UINT               : name = "@doubleToUInt"        ; break;
    case CPX_DBL2LNG                : name = "@doubleToLong"        ; break;
    case CPX_DBL2ULNG               : name = "@doubleToULong"       ; break;
#if!TGT_IA64
    case CPX_ULNG2DBL               : name = "@ulongTodouble"       ; break;
#endif
    case CPX_DBL_REM                : name = "@doubleRem"           ; break;
    case CPX_FLT_REM                : name = "@floatRem"            ; break;

    case CPX_NEWCLS_DIRECT          : name = "@newClassDirect"      ; break;
    case CPX_NEWARR_1_DIRECT        : name = "@newObjArrayDirect"   ; break;
    case CPX_NEWCLS_SPECIALDIRECT   : name = "@newClassDirectSpecial";break;
    case CORINFO_HELP_NEW_CROSSCONTEXT : name = "@newCrossContext"  ; break;

    case CPX_CALL_GC                : name = "@call_GC"             ; break;
    case CPX_GC_REF_ASGN_EAX        : name = "@GcRegAsgnEAX"        ; break;
    case CPX_GC_REF_ASGN_EBX        : name = "@GcRegAsgnEBX"        ; break;
    case CPX_GC_REF_ASGN_ECX        : name = "@GcRegAsgnECX"        ; break;
    case CPX_GC_REF_ASGN_ESI        : name = "@GcRegAsgnESI"        ; break;
    case CPX_GC_REF_ASGN_EDI        : name = "@GcRegAsgnEDI"        ; break;
    case CPX_GC_REF_ASGN_EBP        : name = "@GcRegAsgnEBP"        ; break;

    case CPX_MATH_POW               : name = "@mathPow"             ; break;

    case CPX_LONG_UDIV              : name = "@ulongDiv"            ; break;
    case CPX_LONG_UMOD              : name = "@ulongMod"            ; break;
    case CPX_LONG_MUL_OVF           : name = "@longMul.ovf"         ; break;
    case CPX_ULONG_MUL_OVF          : name = "@ulongMul.ovf"        ; break;
    case CPX_DBL2INT_OVF            : name = "@doubleToInt.ovf"     ; break;
    case CPX_DBL2UINT_OVF           : name = "@doubleToUInt.ovf"    ; break;
    case CPX_DBL2LNG_OVF            : name = "@doubleToLng.ovf"     ; break;
    case CPX_DBL2ULNG_OVF           : name = "@doubleToULng.ovf"    ; break;
    case CPX_INIT_CLASS             : name = "@initClass"           ; break;
    case CPX_USER_BREAKPOINT        : name = "@breakPoint"          ; break;
    case CPX_ARITH_EXCPN            : name = "@arithExcpn"          ; break;
    case CPX_NEWOBJ                 : name = "@newObj"              ; break;
    case CPX_BYREF_ASGN             : name = "@GcByRefAsgn"         ; break;

    case CPX_GC_REF_CHK_ASGN_EAX    : name = "@GcRegChkAsgnEAX"     ; break;
    case CPX_GC_REF_CHK_ASGN_EBX    : name = "@GcRegChkAsgnEBX"     ; break;
    case CPX_GC_REF_CHK_ASGN_ECX    : name = "@GcRegChkAsgnECX"     ; break;
    case CPX_GC_REF_CHK_ASGN_ESI    : name = "@GcRegChkAsgnESI"     ; break;
    case CPX_GC_REF_CHK_ASGN_EDI    : name = "@GcRegChkAsgnEDI"     ; break;
    case CPX_GC_REF_CHK_ASGN_EBP    : name = "@GcRegChkAsgnEBP"     ; break;

    case CPX_WRAP                   : name = "@Wrap"                ; break;
    case CPX_UNWRAP                 : name = "@Unwrap"              ; break;
    case CPX_BOX                    : name = "@Box"                 ; break;
    case CPX_UNBOX                  : name = "@Unbox"               ; break;
    case CPX_GETREFANY              : name = "@GetRefAny"           ; break;
    case CPX_NEWSFAST               : name = "@newClassSmall"       ; break;
    case CPX_ENDCATCH               : name = "@endcatch"            ; break;
#ifdef PROFILER_SUPPORT
    case CPX_PROFILER_CALLING       : name = "@ProfEvCall"          ; break;
    case CPX_PROFILER_RETURNED      : name = "@ProfEvReturned"      ; break;
    case CPX_PROFILER_ENTER         : name = "@ProfEvEnter"         ; break;
    case CPX_PROFILER_LEAVE         : name = "@ProfEvLeave"         ; break;
#endif

    case CPX_TAILCALL               : name = "@tailCall"            ; break;

#if     TGT_IA64

    case CPX_R4_DIV                 : name = "@fltDiv"              ; break;
    case CPX_R8_DIV                 : name = "@dblDiv"              ; break;

#endif

#if !   CPU_HAS_FP_SUPPORT

    case CPX_R4_NEG                 : name = "@fltNeg"              ; break;
    case CPX_R8_NEG                 : name = "@dblNeg"              ; break;

    case CPX_R4_ADD                 : name = "@fltAdd"              ; break;
    case CPX_R8_ADD                 : name = "@dblAdd"              ; break;
    case CPX_R4_SUB                 : name = "@fltSub"              ; break;
    case CPX_R8_SUB                 : name = "@dblSub"              ; break;
    case CPX_R4_MUL                 : name = "@fltMul"              ; break;
    case CPX_R8_MUL                 : name = "@dblMul"              ; break;
    case CPX_R4_DIV                 : name = "@fltDiv"              ; break;
    case CPX_R8_DIV                 : name = "@dblDiv"              ; break;

    case CPX_R4_EQ                  : name = "@fltEQ"               ; break;
    case CPX_R8_EQ                  : name = "@dblEQ"               ; break;
    case CPX_R4_NE                  : name = "@fltNE"               ; break;
    case CPX_R8_NE                  : name = "@dblNE"               ; break;
    case CPX_R4_LT                  : name = "@fltLT"               ; break;
    case CPX_R8_LT                  : name = "@dblLT"               ; break;
    case CPX_R4_LE                  : name = "@fltLE"               ; break;
    case CPX_R8_LE                  : name = "@dblLE"               ; break;
    case CPX_R4_GE                  : name = "@fltGE"               ; break;
    case CPX_R8_GE                  : name = "@dblGE"               ; break;
    case CPX_R4_GT                  : name = "@fltGT"               ; break;
    case CPX_R8_GT                  : name = "@dblGT"               ; break;

    case CPX_R8_TO_I4               : name = "@dbltoint"            ; break;
    case CPX_R8_TO_I8               : name = "@dbltolng"            ; break;
    case CPX_R8_TO_R4               : name = "@dbltoflt"            ; break;

    case CPX_R4_TO_I4               : name = "@flttoint"            ; break;
    case CPX_R4_TO_I8               : name = "@flttolng"            ; break;
    case CPX_R4_TO_R8               : name = "@flttodbl"            ; break;

    case CPX_I4_TO_R4               : name = "@inttoflt"            ; break;
    case CPX_I4_TO_R8               : name = "@inttodbl"            ; break;
    case CPX_I8_TO_R4               : name = "@lngtoflt"            ; break;
    case CPX_I8_TO_R8               : name = "@lngtodbl"            ; break;
    case CPX_U4_TO_R4               : name = "@unstoflt"            ; break;
    case CPX_U4_TO_R8               : name = "@unstodbl"            ; break;
    case CPX_U8_TO_R4               : name = "@ulntoflt"            ; break;
    case CPX_U8_TO_R8               : name = "@ulntodbl"            ; break;

#ifdef  USE_HELPERS_FOR_INT_DIV
    case CPX_I4_DIV                 : name = "@intdiv"              ; break;
    case CPX_I4_MOD                 : name = "@intmod"              ; break;
    case CPX_U4_DIV                 : name = "@unsdiv"              ; break;
    case CPX_U4_MOD                 : name = "@unsmod"              ; break;
#endif

#endif

    default:
        ASSert(!"weird Helper call value");
    }

    return  name;
}

/*****************************************************************************/
#endif // defined(DEBUG) || INLINE_MATH
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\ee_il_dll.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            ee_jit.cpp                                     XX
XX                                                                           XX
XX   The functionality needed for the JIT DLL. Includes the DLL entry point  XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#include "jitpch.h"
#pragma hdrstop
#include "emit.h"

/*****************************************************************************/

#include "target.h"
#include "error.h"


#if !INLINING

// These are defined for other .CPP files. We dont need it

#undef eeIsOurMethod
#undef eeGetCPfncinfo
#undef eeGetMethodVTableOffset
#undef eeGetInterfaceID
#undef eeFindField
#undef eeGetMethodName

#endif


/*****************************************************************************/

#define DUMP_PTR_REFS       0       // for testing

static CILJit* ILJitter = 0;        // The one and only JITTER I return

/*****************************************************************************/

extern  bool        native          =  true;
extern  bool        genCode         =  true;
extern  bool        savCode         =  true;
extern  bool        goSpeed         =  true;
extern  bool        optJumps        =  true;
extern  bool        rngCheck        =  true;
extern  bool        genOrder        =  true;
extern  bool        genFPopt        =  true;
extern  bool        callGcChk       = false;
extern  unsigned    genCPU          =     5;
extern  bool        riscCode        = false;
extern  bool        vmSdk3_0        = false;

#if     INLINING
bool                genInline       = true;
#endif

#if     TGT_x86
extern  bool        genStringObjects= true;
#else
extern  bool        genStringObjects= false;
#endif

#ifdef  DEBUG
extern  bool        quietMode       = false;
extern  bool        verbose         = false;
extern  bool        memChecks       = false;
extern  bool        dspCode         = false;
extern  bool        dspILopcodes    = false;
extern  bool        dspEmit         = false;
extern  bool        dspLines        = false;
extern  bool        varNames        = false;
extern  bool        dspGCtbls       = false;
extern  bool        dmpHex          = false;
extern  bool        dspGCoffs       = false;
extern  bool        dspInfoHdr      = false;

#ifdef  LATE_DISASM
extern  bool        disAsm          = false;
extern  bool        disAsm2         = false;
#endif
#endif

#ifdef  DEBUGGING_SUPPORT
extern  bool        debugInfo       = false;
extern  bool        debuggableCode  = false;
extern  bool        debugEnC        = false;
#endif

extern  unsigned    testMask        = 0;

/*****************************************************************************/

void            jitOnDllProcessAttach();
void            jitOnDllProcessDetach();

BOOL WINAPI     DllMain(HANDLE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls((HINSTANCE)hInstance);
        jitOnDllProcessAttach();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        jitOnDllProcessDetach();
    }

    return TRUE;
}

/*****************************************************************************/
#ifdef NDEBUG
/*****************************************************************************/

//  When floating-point types are used, the compiler emits a reference to
//  _fltused to initialize the CRT's floating-point package.  We're not
//  using any of that support and the OS is responsible for initializing
//  the FPU, so we'll link to the following _fltused instead to avoid CRT
//  bloat.

// @HACK: THIS SHOULD BE UNCOMMENTED ELSE WE WILL LINK IN MSVCRT.LIB and ALL THAT STUFF
// WE DONT NEED. COMMENTED OUT AS COR BUILD DOES NOT CURRENTLY WORK WITH IT.
//
// extern "C" int _fltused = 0;

/*****************************************************************************/

// None should use new() and delete() for NDEBUG as we will be using a
// Mark-release allocator

void* __cdecl operator new(size_t cbSize)
{
    printf("new() should not be called");
    return (void*) LocalAlloc(LPTR, cbSize);
}

void __cdecl operator delete(void* pvMemory)
{
    printf("new() should not be called");
    LocalFree((HLOCAL) pvMemory);
}

/*****************************************************************************/
#endif //NDEBUG
/*****************************************************************************/

/*****************************************************************************
 *
 *  Return the lowest bit that is set in the given number.
 */

#pragma warning(disable:4146)

inline unsigned __int64 findLowestBit(unsigned __int64 value)
{
    return (value & -value);
}

inline unsigned         findLowestBit(unsigned         value)
{
    return (value & -value);
}

#pragma warning(default:4146)

/*****************************************************************************
 *
 *  Allocation routines used by gen.cpp are defined below.
 */

PVOID __stdcall GetScratchMemory( size_t Size )
{
    return (void*) LocalAlloc(LPTR, Size);
}

void __stdcall ReleaseScratchMemory( PVOID block )
{
    LocalFree((HLOCAL) block);
}

void *  (__stdcall *JITgetmemFnc)(size_t size) = GetScratchMemory;
void    (__stdcall *JITrlsmemFnc)(void *block) = ReleaseScratchMemory;

void    *FASTCALL   JVCgetMem(size_t size)
{
    void    *   block = JITgetmemFnc(size);

    if  (!block)
        NOMEM();

    return  block;
}

void     FASTCALL   JVCrlsMem(void *block)
{
    JITrlsmemFnc(block);
}

/*****************************************************************************
 *
 *  Convert the type returned from the VM to a var_type.
 */

inline var_types           JITtype2varType(JIT_types type)
{

    static const unsigned char varTypeMap[JIT_TYP_COUNT] =
        {   TYP_UNDEF, TYP_VOID, TYP_BOOL, TYP_CHAR,
            TYP_BYTE, TYP_UBYTE, TYP_SHORT, TYP_CHAR,
            TYP_INT, TYP_INT, TYP_LONG, TYP_LONG,
            TYP_FLOAT, TYP_DOUBLE,
            TYP_REF,            // ELEMENT_TYPE_STRING
            TYP_INT,            // ELEMENT_TYPE_PTR
            TYP_BYREF,          // ELEMENT_TYPE_BYREF
            TYP_STRUCT,         // ELEMENT_TYPE_VALUECLASS
            TYP_REF,            // ELEMENT_TYPE_CLASS
            TYP_STRUCT,         // ELEMENT_TYPE_TYPEDBYREF
            };

    // spot check to make certain enumerations have not changed

    assert(varTypeMap[JIT_TYP_CLASS]    == TYP_REF);
    assert(varTypeMap[JIT_TYP_BYREF]    == TYP_BYREF);
    assert(varTypeMap[JIT_TYP_PTR]      == TYP_INT);
    assert(varTypeMap[JIT_TYP_INT]      == TYP_INT);
    assert(varTypeMap[JIT_TYP_UINT]     == TYP_INT);
    assert(varTypeMap[JIT_TYP_DOUBLE]   == TYP_DOUBLE);
    assert(varTypeMap[JIT_TYP_VOID]     == TYP_VOID);
    assert(varTypeMap[JIT_TYP_VALUECLASS] == TYP_STRUCT);
    assert(varTypeMap[JIT_TYP_REFANY]  == TYP_STRUCT);

    type = JIT_types(type & CORINFO_TYPE_MASK); // strip off modifiers
    assert(type < JIT_TYP_COUNT);
    assert(varTypeMap[type] != TYP_UNDEF);
    return((var_types) varTypeMap[type]);
};

/*****************************************************************************/

#if DUMP_PTR_REFS
static
void                dumpPtrs(void *methodAddr, void *methodInfo);
#else
inline
void                dumpPtrs(void *methodAddr, void *methodInfo){}
#endif

/*****************************************************************************/


static
bool                JITcsInited;

#if GC_WRITE_BARRIER_CALL
int                JITGcBarrierCall = -1;
#endif

/*****************************************************************************
 *  jitOnDllProcessAttach() called by DllMain() when jit.dll is loaded
 */

void jitOnDllProcessAttach()
{
    Compiler::compStartup();

#ifdef LATE_DISASM
    disInitForLateDisAsm();
#endif
}

/*****************************************************************************
 *  jitOnDllProcessDetach() called by DllMain() when jit.dll is unloaded
 */

void jitOnDllProcessDetach()
{
    Compiler::compShutdown();
}

/*****************************************************************************
 *  Called just before the function is JIT'ed
 */

#ifdef DEBUG
const char * jitClassName  = NULL;
const char * jitMethodName = NULL;
extern bool  stopAtMethod  = false;
#endif

inline
bool                jitBeforeCompiling (COMP_HANDLE    compHandle,
                                        SCOPE_HANDLE   scopeHandle,
                                        METHOD_HANDLE  methodHandle,
                                        void *         methodCodePtr)
{
#ifdef DEBUG

    jitMethodName = compHandle->getMethodName(methodHandle, &jitClassName);

    if (verbose) printf("Compiling %s.%s\n", jitClassName, jitMethodName);

#endif // DEBUG

    return true;
}


/*****************************************************************************
 *  Called after the function has been jit'ed
 */

inline
void                jitOnCompilingDone (COMP_HANDLE    compHandle,
                                        SCOPE_HANDLE   scopeHandle,
                                        METHOD_HANDLE  methodHandle,
                                        void *         methodCodePtr,
                                        int            result)
{
#ifdef DEBUG
    if  (0)
    {
        jitMethodName = compHandle->getMethodName(methodHandle, &jitClassName);
        printf("Generated code at %08X for %s.%s\n", methodCodePtr, jitClassName, jitMethodName);
    }

//  if  (methodCodePtr == (void *)0x023c060d) { __asm int 3 }

#endif
}

//**********************************************
void * operator new (size_t size, void* ptr){return ptr;}
/*****************************************************************************/
/* FIX, really the IJitCompiler should be done as a COM object, this is just
   something to get us going */

IJitCompiler* getJit()
{
    static char CILJitBuff[sizeof(CILJit)];
    if (ILJitter == 0)
        ILJitter = new(CILJitBuff) CILJit();
    return(ILJitter);
}

/*****************************************************************************
 *  The main JIT function
 */
JIT_RESULT __stdcall CILJit::compileMethod (
            IJitInfo*       compHnd,
            JIT_METHOD_INFO* methodInfo,
            unsigned        flags,
            BYTE **         entryAddress,
            SIZE_T  *       nativeSizeOfCode
                )
{
    int             result;
    void *          methodCodePtr = NULL;
    void *          methodDataPtr = NULL;
    void *          methodConsPtr = NULL;
    void *          methodInfoPtr = NULL;
    METHOD_HANDLE   methodHandle  = methodInfo->ftn;

    if  (!JITcsInited)
    {
        if  (flags & CORJIT_FLG_TARGET_PENTIUM)
            genCPU = 5;
        else if (flags & CORJIT_FLG_TARGET_PPRO)
            genCPU = 6;
        else if (flags & CORJIT_FLG_TARGET_P4)
            genCPU = 7;
        else
            genCPU = 4;

        /* Offset of the acutal mem ptr in the proxy NStruct object */

        Compiler::Info::compNStructIndirOffset = compHnd->getIndirectionOffset();


        genStringObjects = getStringLiteralOverride();

        JITcsInited = true;

    }

    assert((flags & (CORJIT_FLG_TARGET_PENTIUM|CORJIT_FLG_TARGET_PPRO|CORJIT_FLG_TARGET_P4))
                 != (CORJIT_FLG_TARGET_PENTIUM|CORJIT_FLG_TARGET_PPRO|CORJIT_FLG_TARGET_P4));

    assert(((genCPU == 5) && (flags&CORJIT_FLG_TARGET_PENTIUM)) ||
           ((genCPU == 6) && (flags&CORJIT_FLG_TARGET_PPRO)) ||
           ((genCPU == 7) && (flags&CORJIT_FLG_TARGET_P4)) ||
            (genCPU == 4) || true);
    
    assert(methodInfo->ILCode);

    if (!jitBeforeCompiling(compHnd, methodInfo->scope, methodHandle, methodInfo->ILCode))
        return JIT_REFUSED;


    unsigned locals = methodInfo->args.numArgs + methodInfo->locals.numArgs;

        // there is a 'hidden' cookie pushed when the calling convention is varargs
    if ((methodInfo->args.callConv & JIT_CALLCONV_MASK) == JIT_CALLCONV_VARARG)
        locals++;

    if  (!(compHnd->getMethodAttribs(methodHandle) & FLG_STATIC))
        locals++;


    result = jitNativeCode(methodHandle,
                           methodInfo->scope,
                           compHnd,
                           methodInfo->ILCode,
                           methodInfo->ILCodeSize,
                           0,       // should not be used
                           methodInfo->maxStack,
                           methodInfo,
                           &methodCodePtr,
                           nativeSizeOfCode,
                           &methodConsPtr,
                           &methodDataPtr,
                           &methodInfoPtr,
                           flags);

    jitOnCompilingDone(compHnd, methodInfo->scope, methodHandle, methodCodePtr, result);

    switch (result)
    {
    case 0:
        *entryAddress = (BYTE*)methodCodePtr;
        return  JIT_OK;

    case ERRnoMemory:
        return  JIT_OUTOFMEM;

    case ERRinternal:

#ifdef  DEBUG
        return  JIT_INTERNALERROR;
#endif

    case ERRbadCode:

    default:
        return  JIT_REFUSED;
    }
}

/*****************************************************************************
 * Returns the number of bytes required for the given type argument
 */

unsigned           Compiler::eeGetArgSize(ARG_LIST_HANDLE list, JIT_SIG_INFO* sig)
{

    JIT_types argTypeJit = info.compCompHnd->getArgType(sig, list);
    varType_t argType = JITtype2varType(argTypeJit);

    if (argType == TYP_STRUCT)
    {
        if (argTypeJit == JIT_TYP_REFANY)
            return(2*sizeof(void*));
        else
        {
            unsigned structSize = info.compCompHnd->getClassSize(info.compCompHnd->getArgClass(sig, list));
            return roundUp(structSize, sizeof(int));
        }
    }
    {
        size_t  argSize = sizeof(int) * genTypeStSz(argType);
        assert((argSize > 0) && (argSize <= sizeof(__int64))); // Sanity check
        return  argSize;
    }
}

/*****************************************************************************/

void                Compiler::eeGetStmtOffsets()
{
    SIZE_T                       offsetsCount;
    SIZE_T                  *    offsets;
    IJitDebugInfo::BoundaryTypes offsetsImplicit;

    info.compCompHnd->getBoundaries(info.compMethodHnd,
                                    &offsetsCount,
                                    &offsets,
                                    &offsetsImplicit);

    info.compStmtOffsets = (IL_OFFSET *)compGetMem(offsetsCount * sizeof(info.compStmtOffsets[0]));

    assert(Compiler::STACK_EMPTY_BOUNDARIES == IJitDebugInfo::STACK_EMPTY_BOUNDARIES);
    assert(Compiler::CALL_SITE_BOUNDARIES   == IJitDebugInfo::CALL_SITE_BOUNDARIES  );
    assert(Compiler::ALL_BOUNDARIES         == IJitDebugInfo::ALL_BOUNDARIES        );
    info.compStmtOffsetsImplicit = (ImplicitStmtOffsets)offsetsImplicit;

    info.compStmtOffsetsCount = 0;
    for(unsigned i = 0; i < offsetsCount; i++)
    {
        if (offsets[i] > info.compCodeSize)
            continue;

        info.compStmtOffsets[info.compStmtOffsetsCount] = offsets[i];
        info.compStmtOffsetsCount++;
    }

    if (offsetsCount)
        info.compCompHnd->freeArray(offsets);

    /* @TODO : If we dont need to do the above filtering, just use the return values
    info.compCompHnd->getBoundaries((SIZE_T*)&info.compStmtOffsetsCount,
                                    (SIZE_T**)&info.compStmtOffsets,
                                    (int *)&info.compStmtOffsetsImplicit);
    */

    info.compLineNumCount = 0;
}

/*****************************************************************************/

#include "malloc.h"     // for alloca

void            Compiler::eeGetVars()
{
    IJitDebugInfo::ILVarInfo *  varInfoTable;
    SIZE_T                      varInfoCount;
    bool                        extendOthers;

    info.compCompHnd->getVars(info.compMethodHnd,
                              &varInfoCount, &varInfoTable, &extendOthers);
    //printf("LVin count = %d\n", varInfoCount);

    // Over allocate in case extendOthers is set.
    SIZE_T extraCount = varInfoCount + (extendOthers?info.compLocalsCount:0);

    info.compLocalVars =
    (LocalVarDsc *)compGetMem(extraCount*sizeof(info.compLocalVars[0]));

    /* @TODO : Once LocalVarDsc exactly matches IJitDebugInfo::ILVarInfo,
       there is no need to do this copy operation. Get rid of it
     */

    LocalVarDsc * localVarPtr = info.compLocalVars;
    IJitDebugInfo::ILVarInfo *v = varInfoTable;

    for (unsigned i = 0; i < varInfoCount; i++, localVarPtr++, v++)
    {
#ifdef DEBUG
        if (verbose)
            printf("var:%d start:%d end:%d\n",
                   v->varNumber,
                   v->startOffset,
                   v->endOffset);
#endif

        //
        // @todo: assert here?
        //
        if (v->startOffset >= v->endOffset)
            continue;

        assert(v->startOffset <= info.compCodeSize);
        assert(v->endOffset   <= info.compCodeSize);

        assert(v->varNumber   < info.compLocalsCount);
        if (v->varNumber  >= info.compLocalsCount)
            continue;

        localVarPtr->lvdLifeBeg = v->startOffset;
        localVarPtr->lvdLifeEnd = v->endOffset;
        localVarPtr->lvdVarNum  = v->varNumber;
#ifdef DEBUG
        localVarPtr->lvdName    = NULL;
#endif
        localVarPtr->lvdLVnum   = i;

        info.compLocalVarsCount++;
    }

    /* If extendOthers is set, then assume the scope of unreported vars
       is the entire method. Note that this will cause fgExtendDbgLifetimes()
       to zero-initalize all of them. This will be expensive if its used
       for too many variables
     */
    if  (extendOthers)
    {
        // Allocate a bit-array for all the variables and initialize to false

        bool * varInfoProvided = (bool *)alloca(info.compLocalsCount *
                                                sizeof(varInfoProvided[0]));
        for (i = 0; i < info.compLocalsCount; i++)
            varInfoProvided[i] = false;

        // Find which vars have absolutely no varInfo provided

        for (i = 0; i < info.compLocalVarsCount; i++)
            varInfoProvided[info.compLocalVars[i].lvdVarNum] = true;

        for (i = 0; i < info.compLocalsCount; i++)
        {
            if (!varInfoProvided[i])
            {
                // Create a varInfo with scope over the entire method

                localVarPtr->lvdLifeBeg = 0;
                localVarPtr->lvdLifeEnd = info.compCodeSize;
                localVarPtr->lvdVarNum  = i;
#ifdef DEBUG
                localVarPtr->lvdName    = NULL;
#endif
                localVarPtr->lvdLVnum   = info.compLocalVarsCount;

                localVarPtr++;
                info.compLocalVarsCount++;
            }
        }

    }

    if (varInfoCount != 0)
        info.compCompHnd->freeArray(varInfoTable);
}

/*****************************************************************************
 *
 *                      Utility functions
 */

#if defined(DEBUG) || INLINE_MATH

/*****************************************************************************/
const char*         Compiler::eeGetMethodName(METHOD_HANDLE       method,
                                              const char** classNamePtr)
{
    static METHOD_HANDLE PInvokeStub = (METHOD_HANDLE) *((unsigned *)eeGetPInvokeStub());
    if  (eeGetHelperNum(method))
    {
        if (classNamePtr != 0)
            *classNamePtr = "HELPER";
        return eeHelperMethodName(eeGetHelperNum(method));
    }

    if (method == PInvokeStub)
    {
        if (classNamePtr != 0)
            *classNamePtr = "EEStub";
        return "PInvokeStub";
    }

    if (eeIsNativeMethod(method))
        method = eeGetMethodHandleForNative(method);

    return(info.compCompHnd->getMethodName(method, classNamePtr));
}

const char *        Compiler::eeGetFieldName  (FIELD_HANDLE field,
                                             const char * *     classNamePtr)
{
    return(info.compCompHnd->getFieldName(field, classNamePtr));
}

#endif


#ifdef DEBUG
void Compiler::eeUnresolvedMDToken (SCOPE_HANDLE   cls,
                                    unsigned       token,
                                    const char *   errMsg)
{
    char buff[1024];
    const char *name = info.compCompHnd->findNameOfToken(cls, token);
    wsprintf(buff, "%s: could not resolve meta data token (%s) (class not found?)", errMsg, name);
    NO_WAY(buff);
}


const char * FASTCALL   Compiler::eeGetCPString (unsigned       cpx)
{
    return "<UNKNOWN>";
}


const char * FASTCALL   Compiler::eeGetCPAsciiz (unsigned       cpx)
{
    return "<UNKNOWN>";
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\ee_il_exe.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          EEInterface                                      XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#include "jitpch.h"
#pragma hdrstop

#if !INLINING

// These are defined for other .CPP files. We dont need it

#undef eeIsOurMethod
#undef eeGetCPfncinfo
#undef eeGetMethodVTableOffset
#undef eeGetInterfaceID
#undef eeFindField
#undef eeGetMethodName

#endif

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          IL version of the EEInterface                    XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


void        Compiler::eeInit()
{}

/*****************************************************************************
 *
 *              Functions to get various handles
 */

CLASS_HANDLE         Compiler::eeFindClass      (unsigned       clsTok,
                                                 SCOPE_HANDLE   scope,
                                                                                                 METHOD_HANDLE   context,
                                                 bool           giveUp)
{
    return (CLASS_HANDLE)clsTok;
}

CLASS_HANDLE Compiler::eeGetMethodClass         (METHOD_HANDLE  methodHandle)
{
    return((CLASS_HANDLE) methodHandle);
}

METHOD_HANDLE        Compiler::eeFindMethod     (unsigned       CPnum,
                                                 SCOPE_HANDLE   scope,
                                                                                                 METHOD_HANDLE   context,
                                                 bool           giveUp)
{
    METHOD_HANDLE ret = (METHOD_HANDLE)CPnum;
    assert(eeGetHelperNum(ret) == JIT_HELP_UNDEF);
    return(ret);
}

FIELD_HANDLE         Compiler::eeFindField      (unsigned       memberRefId,
                                                 SCOPE_HANDLE   scope,
                                                                                                 METHOD_HANDLE   context,
                                                 bool           giveUp)
{
    if  (scope != info.compScopeHnd)
    {
        // ISSUE: The following call may cause a field to get resolved,
        // ISSUE: which could cause trouble. Need to make sure this will
        // ISSUE: never happen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        assert(0);
    }

    return (FIELD_HANDLE)memberRefId;
}

CLASS_HANDLE        Compiler::eeGetFieldClass (FIELD_HANDLE   hnd)
{
    mdTypeRef   classRef;

    CompInfo * sym = info.compCompHnd;

    if (TypeFromToken((mdToken)hnd) == mdtMemberRef)
        classRef = sym->symMetaData->GetParentOfMemberRef((mdMemberRef)hnd);
    else
        sym->symMetaData->GetParentToken((mdFieldDef)hnd,
                                         &classRef);

    return (CLASS_HANDLE)classRef;
}

size_t              Compiler::eeGetFieldAddress(FIELD_HANDLE   hnd)
{
    CompInfo *      sym = info.compCompHnd;
    ULONG           addr;

    assert(TypeFromToken((mdToken)hnd) == mdtFieldDef);

    sym->symMetaData->GetFieldRVA((mdFieldDef)hnd, &addr);

    return  addr;
}

void *              Compiler::embedGenericHandle(unsigned       metaTok,
                                                 SCOPE_HANDLE   scope,
                                                 METHOD_HANDLE  context,
                                                 void         **ppIndir,
                                                 bool           giveUp)
{
    if  (ppIndir)
        *ppIndir = NULL;
    return (void*)metaTok;
}

/*****************************************************************************
 *
 *                  Functions to get flags
 */

unsigned            Compiler::eeGetClassAttribs   (CLASS_HANDLE   hnd)
{
    CompInfo *      sym = info.compCompHnd;

    mdToken         parent;
        
    DWORD           dwClassAttrs;

    if  ((CLASS_HANDLE)sym == hnd)
    {
        if (sym->symClass == 0)
            return  0;

        sym->symMetaData->GetTypeDefProps(sym->symClass, &dwClassAttrs, &parent);
    }
    else
    {
        if  (hnd == 0)
            return  0;
        if (TypeFromToken((mdToken)hnd) != mdtTypeDef)
            return  0;

        sym->symMetaData->GetTypeDefProps( (mdToken)hnd, &dwClassAttrs, &parent);
    }

    if  (RidFromToken(parent) == 0)
    {
        // this is actually a global variable

        return  FLG_VALUECLASS|FLG_UNMANAGED|FLG_GLOBVAR;
    }

    unsigned flags = 0;

    //@todo: check base class for this info.
    //if (IsTdValueType(dwClassAttrs))
    //    flags |= FLG_VALUECLASS;

    return flags;
}

unsigned            Compiler::eeGetFieldAttribs (FIELD_HANDLE   hnd)
{
    return 0;  //hack
}


bool                Compiler::eeIsClassMethod   (METHOD_HANDLE  methodHandle)
{
    assert(methodHandle == info.compMethodHnd);
    CompInfo * sym = info.compCompHnd;
    return sym->getIsMethod();
}


/*****************************************************************************/

BOOL                Compiler::eeIsOurMethod    (METHOD_HANDLE meth)
{
    CompInfo * sym = info.compCompHnd;

        // FIX todo
    return false;
}

BOOL                Compiler::eeCheckCalleeFlags  (unsigned       flags,
                                                   unsigned       opCode)
{ assert(!"NYI"); return 0; }

bool                Compiler::eeCheckPutFieldFinal (FIELD_HANDLE   CPfield,
                                                    unsigned       flags,
                                                    CLASS_HANDLE   cls,
                                                    METHOD_HANDLE  method)
{ assert(!"NYI"); return 0; }

bool                Compiler::eeCanPutField(FIELD_HANDLE  CPfield,
                                                    unsigned      flags,
                                                    CLASS_HANDLE  cls,
                                                    METHOD_HANDLE method)
{
    return true;
}

/*****************************************************************************
 *
 *          VOS info, method sigs, etc
 */

void*               Compiler::eeFindPointer        (SCOPE_HANDLE   scope,
                                                    unsigned       ptrTOK,
                                                    bool           giveUp)
{
    return((void*) ptrTOK);
}

void                Compiler::eeGetSig          (unsigned       sigTok,
                                                 SCOPE_HANDLE   scope,
                                                                                                 JIT_SIG_INFO*  sigRet)
{
    CompInfo * sym  =   info.compCompHnd;
    PCCOR_SIGNATURE     sig;
    ULONG               cbSig;

    sig = sym->symMetaData->GetSigFromToken(sigTok, &cbSig);

    SigPointer ptr(sig);
    sigRet->callConv = (JIT_CALL_CONV)ptr.GetData(); // calling convention
        sigRet->numArgs = ptr.GetData();
    sigRet->retType = (JIT_types) ptr.GetData();
        sigRet->retTypeClass = BAD_CLASS_HANDLE;                // TODO fill in properly
        sigRet->sig = 0;
        sigRet->scope = 0;
}

void               Compiler::eeGetMethodSig      (METHOD_HANDLE  methHnd,
                                                                                                  JIT_SIG_INFO*  sigRet)

{
    CompInfo * sym = info.compCompHnd;
        if (methHnd == info.compMethodHnd) {
                SigPointer ptr(sym->symSig);
                sigRet->callConv = (JIT_CALL_CONV) ptr.GetData();
                sigRet->numArgs = ptr.GetData();
                sigRet->retType = (JIT_types) ptr.PeekData();ptr.Skip();
                sigRet->retTypeClass = BAD_CLASS_HANDLE;              // TODO fill in properly
                sigRet->scope = 0;
                sigRet->sig = 0;
                sigRet->args = *((ARG_LIST_HANDLE*) (&ptr));
                return;
        }
    LPCSTR      szName;
    PCCOR_SIGNATURE pvBlob = NULL;
    ULONG       cbBlob = 0;

    if (TypeFromToken((mdToken)methHnd) == mdtMemberRef)
    {
        szName = sym->symMetaData->GetNameAndSigOfMemberRef((mdMemberRef) methHnd,
                                                            &pvBlob, &cbBlob);
    }
    else
    {
        szName = sym->symMetaData->GetNameOfMethodDef((mdMethodDef) methHnd);
        pvBlob = sym->symMetaData->GetSigOfMethodDef ((mdMethodDef) methHnd,
                                                          &cbBlob);
    }

    SigPointer ptr(pvBlob);
    sigRet->callConv = (JIT_CALL_CONV)ptr.GetData(); // calling convention
    sigRet->numArgs = ptr.GetData();
    sigRet->retType = (JIT_types) ptr.PeekData();ptr.Skip();
    sigRet->retTypeClass = BAD_CLASS_HANDLE;                // TODO fill in properly
    sigRet->sig = 0;
    sigRet->scope = 0;
    sigRet->args = *((ARG_LIST_HANDLE*) (&ptr));
}

/**********************************************************************
 * For varargs we need the number of arguments at the call site
 * In the stan-alone case we simply call eeGetMethodSig
 */

void                Compiler::eeGetCallSiteSig     (unsigned       sigTok,
                                                                                                        SCOPE_HANDLE   scope,
                                                                                                    JIT_SIG_INFO*  sigRet)
{
    eeGetMethodSig((METHOD_HANDLE)sigTok, sigRet);
}

unsigned             Compiler::eeGetMethodVTableOffset   (METHOD_HANDLE methHnd)
{
    return (unsigned) methHnd;
}


unsigned             Compiler::eeGetInterfaceID(CLASS_HANDLE cls, unsigned* *ppIndir)
{
    if (ppIndir)
        *ppIndir = NULL;
    return 0;
}

unsigned            Compiler::eeGetPInvokeCookie(CORINFO_SIG_INFO *szMetaSig)
{
    return 0xC0000000 | ((unsigned) szMetaSig);
}

const void      *   Compiler::eeGetPInvokeStub()
{
    return (const void *) (0xCAACEEEE);
}

/*****************************************************************************/

var_types            Compiler::eeGetFieldType   (FIELD_HANDLE   handle, CLASS_HANDLE* structType)
{
    LPCSTR          szName;
    PCCOR_SIGNATURE pvBlob = NULL;
    ULONG           cbBlob = 0;

    CompInfo * sym = info.compCompHnd;

    if (TypeFromToken((mdToken)handle) == mdtMemberRef)
    {
        szName = sym->symMetaData->GetNameAndSigOfMemberRef((mdMemberRef)handle,
                                                            &pvBlob, &cbBlob);
    }
    else
    {
        szName = sym->symMetaData->GetNameOfFieldDef((mdFieldDef)handle);
        pvBlob = sym->symMetaData->GetSigOfFieldDef((mdFieldDef)handle,
                                                    &cbBlob);
    }

    FieldSig        fieldSig(pvBlob, NULL);
    JIT_types  type = (JIT_types) fieldSig.GetFieldType();

        // TODO fill structType properly when type == TYP_STRUCT
    if (structType != 0)
        *structType = BAD_CLASS_HANDLE;

    return (JITtype2varType(type));
}

int                  Compiler::eeGetNewHelper      (CLASS_HANDLE   newCls, METHOD_HANDLE context)
{
    return CPX_NEWCLS_DIRECT;
}

int                  Compiler::eeGetIsTypeHelper   (CLASS_HANDLE   newCls)
{
    return CPX_ISTYPE;
}

int                  Compiler::eeGetChkCastHelper  (CLASS_HANDLE   newCls)
{
    return CPX_CHKCAST;
}

/*****************************************************************************
 *
 *                  Method entry-points, IL
 */

void    *   Compiler::eeGetMethodPointer(METHOD_HANDLE   methHnd,
                                         InfoAccessType *pAccessType)
{
    *pAccessType = IAT_VALUE;
    return (void *)methHnd;
}

void    *   Compiler::eeGetMethodEntryPoint(METHOD_HANDLE    methHnd,
                                            InfoAccessType *pAccessType)
{
    *pAccessType = IAT_PVALUE;
    return (void *)methHnd;
}

bool                 Compiler::eeGetMethodInfo  (METHOD_HANDLE  method,
                                                 JIT_METHOD_INFO* methInfo)
{
    return false;
}

bool                 Compiler::eeCanInline (METHOD_HANDLE  callerHnd,
                                            METHOD_HANDLE  calleeHnd)
{
    return true;
}

bool                 Compiler::eeCanTailCall (METHOD_HANDLE  callerHnd,
                                              METHOD_HANDLE  calleeHnd)
{
    return true;
}

void    *            Compiler::eeGetHintPtr(METHOD_HANDLE methHnd, void** *ppIndir)
{
    if (ppIndir)
        *ppIndir = NULL;
    return (void *) methHnd;
}

void    *            Compiler::eeGetFieldAddress (FIELD_HANDLE handle, void** *ppIndir)
{
    if (ppIndir)
        *ppIndir = NULL;
    return (void*) handle;
}

unsigned             Compiler::eeGetFieldThreadLocalStoreID
                                                 (FIELD_HANDLE handle, void** *ppIndir)
{
    if (ppIndir)
        *ppIndir = NULL;
    return (unsigned) handle;
}

unsigned             Compiler::eeGetFieldOffset      (FIELD_HANDLE   handle)
{
    return  (unsigned)handle;
}


unsigned             Compiler::eeGetStringHandle(unsigned       strTok,
                                                 SCOPE_HANDLE   scope,
                                                 unsigned*     *ppIndir)
{
    if (ppIndir)
        *ppIndir = NULL;
    return 0xC0000000 + strTok;
}

/*****************************************************************************
 *
 *                  Native Direct Optimizations
 */

        // return the unmanaged calling convention for a PInvoke
UNMANAGED_CALL_CONV  Compiler::eeGetUnmanagedCallConv(METHOD_HANDLE method)
{
    return UNMANAGED_CALLCONV_STDCALL;  // temp IA64 hack!!!!!!!
}

        // return if any marshaling is required for PInvoke methods
BOOL                 Compiler::eeNDMarshalingRequired(METHOD_HANDLE method)
{
    return TRUE;
}

void            Compiler::eeGetEEInfo(EEInfo *pEEInfoOut)
{
    pEEInfoOut->sizeOfFrame = 0;
    pEEInfoOut->offsetOfFrameVptr = 0;
    pEEInfoOut->offsetOfFrameLink = sizeof(void *);
    pEEInfoOut->offsetOfDelegateInstance = 4;
    pEEInfoOut->offsetOfDelegateFirstTarget = 8;
    pEEInfoOut->offsetOfInterfaceTable = 0x40;
}

DWORD           Compiler::eeGetThreadTLSIndex(DWORD* *ppIndir)
{
    if (ppIndir)
        *ppIndir = NULL;
    return 0;
}

const void *    Compiler::eeGetInlinedCallFrameVptr(const void** *ppIndir)
{
    if (ppIndir)
        *ppIndir = NULL;
    return (void*) 0x0BADBAD0;
}

LONG *          Compiler::eeGetAddrOfCaptureThreadGlobal(LONG** *ppIndir)
{
    if (ppIndir)
        *ppIndir = NULL;
    return 0;
}

void            Compiler::eeGetEHinfo(unsigned       EHnum,
                                      JIT_EH_CLAUSE* clause)

{
    CompInfo * sym = info.compCompHnd;

    assert(info.compXcptnsCount == sym->symPEMethod->EH->EHCount());
    assert(info.compXcptnsCount > EHnum);

    assert(offsetof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT, TryLength) == offsetof(JIT_EH_CLAUSE, TryLength));
    assert(sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT) == sizeof(JIT_EH_CLAUSE));
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehClause = (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*) clause;

    const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehInfo;
    ehInfo = sym->symPEMethod->EH->EHClause(EHnum, ehClause);
    if (ehInfo != ehClause)
        *ehClause = *ehInfo;
}

unsigned            Compiler::eeGetClassSize(CLASS_HANDLE hnd)
{
    CompInfo *      sym  = info.compCompHnd;

    mdTypeDef       tdef = (mdTypeRef)hnd;

    IMetaDataImport*imdi;
    ULONG           size;

    if  (TypeFromToken(tdef) == mdtTypeRef)
    {

#if 0

        tdef = sym->symMetaData->ResolveTypeRef((mdTypeRef)hnd,
                                                &IID_IMetaDataImport,
                                     (IUnknown*)&imdi,
                                                &tdef);

#else

        const char *    nmsp;
        const char *    name;

        sym->symMetaData->GetNameOfTypeRef((mdTypeRef)hnd, &nmsp, &name);

        // Disgusting hack!!!!!!

        if  (!strcmp(nmsp, "System"))
        {
            if  (!strcmp(name, "ArgIterator")) return 8;
        }

        printf("Typeref class name = '%s::%s'\n", nmsp, name);

        assert(!"can't handle struct typerefs right now");

#endif

    }

    assert(TypeFromToken(tdef) == mdtTypeDef);

//  sym->symMetaData->GetClassLayout   (tdef, NULL, NULL, 0, NULL, &size);
    sym->symMetaData->GetClassTotalSize(tdef,                      &size);

#if 0

const char *    nmsp;
const char *    name;

sym->symMetaData->GetNameOfTypeDef(tdef, &nmsp, &name);

if  (name == NULL || *name == 0)
{
    name = nmsp;
    nmsp = "<Global>";
}

printf("Class size is %02u for '%s::%s'\n", size, nmsp, name);

#endif

    return size;
}

void                Compiler::eeGetClassGClayout (CLASS_HANDLE   hnd, bool* gcPtrs)
{
    memset(gcPtrs, 0, eeGetClassSize(hnd)/sizeof(int));   // no GC pointers
}

/*****************************************************************************/
const char*         Compiler::eeGetMethodName(METHOD_HANDLE       method,
                                              const char** classNamePtr)
{
    if  (eeGetHelperNum(method))
    {
        if (classNamePtr != 0)
            *classNamePtr = "";
        return eeHelperMethodName(eeGetHelperNum(method));
    }

    CompInfo *      sym = info.compCompHnd;

    if (method == info.compMethodHnd)
    {
        if (classNamePtr != 0)
            *classNamePtr = sym->symClassName;
        return(sym->symMemberName);
    }

    LPCSTR          szMemberName    = 0;
    PCCOR_SIGNATURE pvBlob          = NULL;
    ULONG           cbBlob          = 0;

    if (TypeFromToken((mdToken)method) == mdtMemberRef)
    {
        szMemberName = sym->symMetaData->GetNameAndSigOfMemberRef((mdMemberRef) method,
                                                                  &pvBlob, &cbBlob);
    }
    else
    {
        szMemberName = sym->symMetaData->GetNameOfMethodDef((mdMethodDef) method);
    }

    if (classNamePtr)
    {
        mdTypeRef cl;
        LPCSTR    szClassName, szNamespace;

        if (TypeFromToken((mdToken)method) == mdtMemberRef)
        {
            cl = sym->symMetaData->GetParentOfMemberRef((mdMemberRef) method);
        }
        else
        {
        MDEF:
            sym->symMetaData->GetParentToken((mdMethodDef) method,
                                             &cl);
        }

        if (TypeFromToken((mdToken)cl) == mdtTypeRef)
        {
            sym->symMetaData->GetNameOfTypeRef(cl, &szClassName, &szNamespace);
        }
        else if (TypeFromToken((mdToken)cl) == mdtMethodDef)
        {
            method = (METHOD_HANDLE)cl; goto MDEF;
//          szClassName = "<Global>";
        }
        else
        {
            sym->symMetaData->GetNameOfTypeDef(cl, &szClassName, &szNamespace);
        }

        *classNamePtr = szClassName;
    }

    return szMemberName;
}

/*****************************************************************************/
SCOPE_HANDLE Compiler::eeGetMethodScope (METHOD_HANDLE  hnd)
{
    return((SCOPE_HANDLE) info.compCompHnd);
}

/*****************************************************************************/
ARG_LIST_HANDLE     Compiler::eeGetArgNext        (ARG_LIST_HANDLE list)
{

    SigPointer ptr(((unsigned __int8*) list));
    ptr.Skip();
    return *((ARG_LIST_HANDLE*) (&ptr));
}

/*****************************************************************************/
varType_t           Compiler::eeGetArgType        (ARG_LIST_HANDLE list, JIT_SIG_INFO* sig)
{

    SigPointer ptr(((unsigned __int8*) list));
    JIT_types  type = (JIT_types) ptr.PeekData();

    if (type == ELEMENT_TYPE_SENTINEL)
        return  (varType_t)-1;

    return JITtype2varType(type);
}

/*****************************************************************************/
varType_t           Compiler::eeGetArgType        (ARG_LIST_HANDLE list, JIT_SIG_INFO* sig, bool* isPinned)
{
    SigPointer ptr(((unsigned __int8*) list));
//  JIT_types  type = (JIT_types) ptr.PeekData();
    CorElementType type = ptr.PeekElemType();

    *isPinned = false;

    if (type == ELEMENT_TYPE_VALUETYPE)
        type = ptr.Normalize((Module*)sig->scope);

    return JITtype2varType((CorInfoType)type);
}

CLASS_HANDLE        Compiler::eeGetArgClass       (ARG_LIST_HANDLE list, JIT_SIG_INFO * sig)
{
    SigPointer ptr(((unsigned __int8*) list));
    CorElementType type = ptr.GetElemType();

    // The following is obviously just a hack ....

    if  (type == ELEMENT_TYPE_VALUETYPE)
        return (CLASS_HANDLE)ptr.GetToken();
    else
        return  NULL;
}

/*****************************************************************************
 * Returns the number of bytes required for the given type argument
 */

unsigned           Compiler::eeGetArgSize(ARG_LIST_HANDLE list, JIT_SIG_INFO* sig)
{
    varType_t argType = eeGetArgType(list, sig);

    _ASSERTE(argType < JIT_TYP_COUNT);
    if (argType == TYP_STRUCT)
    {
        return 16;      // all structs are 16   FIX
    }
    else
    {
        size_t  argSize = sizeof(int) * genTypeStSz(argType);
        assert((argSize > 0) && (argSize <= sizeof(__int64))); // Sanity check
        return  argSize;
    }
}

/*************************************************************************/
#ifdef PROFILER_SUPPORT
PROFILING_HANDLE    Compiler::eeGetProfilingHandle(METHOD_HANDLE        method,
                                                   BOOL                                 *pbHookFunction,
                                                   PROFILING_HANDLE*   *ppIndir)
{
    if (ppIndir)
        *ppIndir = NULL;
    return (PROFILING_HANDLE) method;
}

#endif

/*************************************************************************/
void*           Compiler::eeGetMethodSync (METHOD_HANDLE    methodHandle,
                                           void**          *ppIndir)
{
    if (ppIndir)
        *ppIndir = NULL;
    return((void*) 0x123456);   // return something deterministic
}

/*************************************************************************/

#if TGT_IA64

// Horrible HACK: these variables are fetched in cgIA64.cpp ...

DWORD           pinvokeFlags;
LPCSTR          pinvokeName;
const   char *  pinvokeDLL;

#endif

unsigned            Compiler::eeGetMethodAttribs (METHOD_HANDLE  methodHandle)
{
    CompInfo *      sym = info.compCompHnd;

    if  (sym == (CompInfo *)methodHandle)
        return  info.compCompHnd->getGetFlags();

#if TGT_IA64

    mdToken         hnd = (mdToken)methodHandle;

    if  (TypeFromToken((mdToken)methodHandle) == mdtMemberRef)
    {
        JIT_SIG_INFO    sig;

        /* Is this a varargs function? */

        eeGetMethodSig(methodHandle, &sig);

        if  ((sig.callConv & JIT_CALLCONV_MASK) == JIT_CALLCONV_VARARG)
        {
            mdToken         tmp;

            if  (!FAILED(sym->symMetaData->GetParentToken(hnd, &tmp)))
            {
                hnd = tmp;
            }
        }
    }

    if  (TypeFromToken(hnd) == mdtMethodDef)
    {
        mdModuleRef     pinvokeMod = -1;

        if  (!sym->symMetaData->GetPinvokeMap(hnd,
                                              &pinvokeFlags,
                                              &pinvokeName,
                                              &pinvokeMod))
        {
            if  (pinvokeMod != -1)
            {
                sym->symMetaData->GetModuleRefProps(pinvokeMod,
                                                   &pinvokeDLL);

//              printf("PINVOKE info: %04X %ls:%s\n", pinvokeFlags, pinvokeDLL, pinvokeName);

                return  FLG_UNCHECKEDPINVOKE;
            }
        }
    }

#endif

    return(0);      // Hack
}

void     Compiler::eeSetMethodAttribs (METHOD_HANDLE    methodHandle,
                                       unsigned         attr)
{
    return;
}

/*****************************************************************************
 *
 *                  Debugging support - Line number info
 */

void               Compiler::eeGetStmtOffsets()
{
    CompInfo * sym = info.compCompHnd;

    if (sym->symMember == NULL) // Descr functions dont have meta-data
    {
        info.compStmtOffsetsCount =
        info.compLineNumCount     = 0;
    }

    HRESULT hr;

    //
    // @todo: this will have to be ported to the ISymUnmanagedReader
    // API to do pretty much what's done in Debugger::getBoundaries in
    // src\debug\ee\debugger.cpp.
    //
#if 0
    if (!sym->symLineInfo)
    {
        // Lazily initialize "symLineInfo"

        // @TODO: Check for out of memory
        sym->symLineInfo    = new DebuggerLineBlock();
        _ASSERTE(sym->symLineInfo != NULL);

        hr                  = sym->symLineInfo->Load(sym->symDebugMeta,
                                                     sym->symMember);

        if (FAILED(hr)) NO_WAY(!"Could not create a LineBlock");
    }

    _ASSERTE(sym->symLineInfo);

    info.compStmtOffsetsCount =
    info.compLineNumCount     = sym->symLineInfo->GetTotalLineCount();

    info.compStmtOffsets = (unsigned   *) compGetMem(sizeof(info.compStmtOffsets[0]) * info.compStmtOffsetsCount);
    info.compLineNumTab  = (srcLineDsc *) compGetMem(sizeof(info.compLineNumTab[0] ) * info.compLineNumCount    );

    for (unsigned i = 0; i < info.compStmtOffsetsCount; i++)
    {
        info.compStmtOffsets[i]           =
        info.compLineNumTab[i].sldLineOfs = sym->symLineInfo->GetLineIP    (i);

        info.compLineNumTab[i].sldLineNum = sym->symLineInfo->GetLineNumber(i);
    }

//  mdToken     source = sym->symLineInfo->GetLineSourceFile(0);
//  printf("Source file token = %08X\n", source);
#endif

#ifdef DEBUGGING_SUPPORT
    if (debuggableCode)
        info.compStmtOffsetsImplicit =
        (ImplicitStmtOffsets) (STACK_EMPTY_BOUNDARIES | CALL_SITE_BOUNDARIES);
#endif
}


void                Compiler::eeSetLIcount(unsigned count)
{
    eeBoundariesCount = count;

#ifdef DEBUG
    if (verbose)
        printf("IP mapping count : %d\n", count);
#endif
}

void FASTCALL       Compiler::eeSetLIinfo  (unsigned       which,
                                            NATIVE_IP      nativeOffset,
                                            IL_OFFSET      ilOffset)
{
    assert(eeBoundariesCount && which < eeBoundariesCount);

#ifdef DEBUG
    if (verbose)
        printf("IL offs %03Xh : %08Xh\n", ilOffset, nativeOffset);
#endif
}

void                Compiler::eeSetLIdone()
{}

/*****************************************************************************/

void                Compiler::eeGetVars ()
{
    HRESULT     hr;

    CompInfo *  sym = info.compCompHnd;

    //
    // @todo: this will have to be ported to the ISymUnmanagedReader
    // API to do pretty much what's done in Debugger::getVars in
    // src\debug\ee\debugger.cpp.
    //
#if 0
    if (!sym->symScopeInfo)
    {
        // @TODO: Check for out of memory
        sym->symScopeInfo = new DebuggerLexicalScopeTree();
        _ASSERTE(sym->symScopeInfo != NULL);
    }

    if (!sym->symLineInfo)
    {
        // Lazily initialize "symLineInfo"

        // @TODO: Check for out of memory
        sym->symLineInfo    = new DebuggerLineBlock();
        _ASSERTE(sym->symLineInfo != NULL);

        hr                  = sym->symLineInfo->Load(sym->symDebugMeta,
                                                     sym->symMember);
        if (FAILED(hr)) NO_WAY(!"Could not create a LineBlock");
    }


    hr = sym->symScopeInfo->Load( sym->symDebugMeta,
                                  sym->symMember);
    if (FAILED(hr)) NO_WAY(!"Could not load scopes");

    unsigned    varCount = sym->symScopeInfo->GetVarCount();

    /* We need the line info to map the source line info to IL. If we
       dont have that, we cant report any info for the vars */

    if (sym->symLineInfo->GetTotalLineCount() == 0)
        varCount = 0;

    /* DebuggerLexicalScopeTree::GetVarCount() does not include arguments.
       They are kept in a separate table. */

    info.compLocalVarsCount = info.compArgsCount + varCount;
    info.compLocalVars      = (LocalVarDsc *)compGetMem(info.compLocalVarsCount
                                                         * sizeof(LocalVarDsc));

    /* We cant get to the arguments via DebuggerVarInfo. They are kept in
     * a separate table. So we just fake var info for them
     */

    LocalVarDsc * localVarPtr = info.compLocalVars;
    for (unsigned i = 0; i < info.compArgsCount; i++, localVarPtr++)
    {
        localVarPtr->lvdLifeBeg  = 0;
        localVarPtr->lvdLifeEnd  = info.compCodeSize;
        localVarPtr->lvdVarNum   = i;

#ifdef DEBUG
        static const char * argNames[] =
            { "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "A10" };
        const int argNamesSize = sizeof(argNames)/sizeof(argNames[0]);

        localVarPtr->lvdName     = (i < argNamesSize) ? argNames[i] : NULL;
#endif
        localVarPtr->lvdLVnum    = i;
    }

    /*-------------------------------------------------------------------------
     * The local var info is stored in terms of source line numbers.
     * We need to change that to IL offsets
     */

    if (varCount == 0)
        return;

    if (!sym->symSourceFile)
    {
        // @TODO: Check for out of memory
        sym->symSourceFile = new DebuggerLineBlock();
        _ASSERTE(sym->symSourceFile != NULL);
    }

    hr = sym->symSourceFile->Load(  sym->symDebugMeta,
                                    sym->symLineInfo->GetLineSourceFile(0));
    if (FAILED(hr)) NO_WAY(!"Problem getting line numbers");

    /* Ask the debugger for the local var info */

    DebuggerVarInfo *           varInfo = sym->symScopeInfo->GetVarArray();

    for (i = info.compArgsCount, localVarPtr = info.compLocalVars + i;
         i < info.compLocalVarsCount;
         i++, varInfo++, localVarPtr++)
    {
        DebuggerLexicalScope *      varScope;
        unsigned                    startLine, endLine;
        DebuggerLineIPRangePair *   ipBegRange;
        DebuggerLineIPRangePair *   ipEndRange;
        unsigned int                begRangeCount, begOffs;
        unsigned int                endRangeCount, endOffs;
        BOOL                        b, e;

        varScope    = varInfo->scope;
        startLine   = varScope->GetStartLineNumber();
        endLine     = varScope->GetEndLineNumber();

        b           = sym->symSourceFile->FindIPRangesFromLine(startLine, &ipBegRange, &begRangeCount);
        e           = sym->symSourceFile->FindIPRangesFromLine(  endLine, &ipEndRange, &endRangeCount);

        if      (ipBegRange == NULL) // There was no exact match - assume entire method
        {
            begOffs = 0;
            endOffs = info.compCodeSize;
        }
        else if (ipEndRange == NULL) // No exact match for the end
        {
            begOffs = (unsigned short)  ipBegRange->rangeStart;
            endOffs = info.compCodeSize;
        }
        else if ((unsigned int)ipEndRange->rangeEnd == 0) // @TODO : Hack, rangeEnd not initialized for last line
        {
            begOffs = (unsigned short)  ipBegRange->rangeStart;
            endOffs = info.compCodeSize;
        }
        else
        {
            begOffs = (unsigned short)  ipBegRange->rangeStart;
            endOffs = (unsigned short) (ipEndRange->rangeEnd);
        }

        _ASSERTE(begOffs <= endOffs);

        /* Report the information back */

        localVarPtr->lvdLifeBeg = begOffs;
        localVarPtr->lvdLifeEnd = endOffs;
        localVarPtr->lvdVarNum  = varInfo->varNumber + info.compArgsCount;
        localVarPtr->lvdLVnum   = i;
#ifdef DEBUG
        localVarPtr->lvdName    = varInfo->name;
#endif
    }
#else
    info.compLocalVarsCount = 0;
    info.compLocalVars      = NULL;
#endif
}


void                Compiler::eeSetLVcount(unsigned count)
{
    eeVarsCount = count;

#ifdef DEBUG
    if (verbose)
        printf("Local var info count : %d\n", count);
#endif
}

void                Compiler::eeSetLVinfo(
                                    unsigned                which,
                                    unsigned                    startOffs,
                                    unsigned                    length,
                                    unsigned                    varNum,
                                    unsigned                    LVnum,
                                    lvdNAME                     namex,
                                    bool                        avail,
                                    const Compiler::siVarLoc &  varLoc)
{
    assert(eeVarsCount && which < eeVarsCount);

#ifdef DEBUG
    if (verbose)
    {
        printf("%3d(%10s) : From %08Xh to %08Xh, %s in ",varNum,
                                                    lvdNAMEstr(namex),
                                                    startOffs,
                                                    startOffs+length,
                                                    avail ? "  is" : "isnt");
        switch(varLoc.vlType)
        {
        case VLT_REG:       printf("%s",        getRegName(varLoc.vlReg.vlrReg));
                            break;
        case VLT_STK:       printf("%s[%d]",    getRegName(varLoc.vlStk.vlsBaseReg),
                                                varLoc.vlStk.vlsOffset);
                            break;
        case VLT_REG_REG:   printf("%s-%s",     getRegName(varLoc.vlRegReg.vlrrReg1),
                                                getRegName(varLoc.vlRegReg.vlrrReg2));
                            break;
        case VLT_REG_STK:   printf("%s-%s[%d]", getRegName(varLoc.vlRegStk.vlrsReg),
                                                getRegName(varLoc.vlRegStk.vlrsStk.vlrssBaseReg),
                                                varLoc.vlRegStk.vlrsStk.vlrssOffset);
                            break;
        case VLT_STK2:      printf("%s[%d-%d]", getRegName(varLoc.vlStk2.vls2BaseReg),
                                                varLoc.vlStk2.vls2Offset,
                                                varLoc.vlStk2.vls2Offset + sizeof(int));
                            break;
        case VLT_FPSTK:     printf("ST(L-%d)",  varLoc.vlFPstk.vlfReg);
                            break;
        }

        printf("\n");
    }
#endif
}


void                Compiler::eeSetLVdone()
{}

/*****************************************************************************
 *
 *                      Utility functions
 */

#if defined(DEBUG) || INLINE_MATH


const char *        Compiler::eeGetFieldName(FIELD_HANDLE fldHnd,
                                             const char ** classNamePtr)
{
    CompInfo *      sym     = info.compCompHnd;
    LPCSTR          szMemberName;
    PCCOR_SIGNATURE pvBlob  = NULL;
    ULONG           cbBlob  = 0;

    if (TypeFromToken((mdToken)fldHnd) == mdtMemberRef)
    {
        szMemberName = sym->symMetaData->GetNameAndSigOfMemberRef((mdMemberRef) fldHnd,
                                                                  &pvBlob, &cbBlob);
    }
    else
    {
        szMemberName = sym->symMetaData->GetNameOfFieldDef((mdFieldDef) fldHnd);
    }

    if (classNamePtr)
    {
        mdTypeRef cl;
        LPCSTR    szClassName, szNamespace;

        if (TypeFromToken((mdToken)fldHnd) == mdtMemberRef)
        {
            cl = sym->symMetaData->GetParentOfMemberRef((mdMemberRef) fldHnd);
        }
        else
        {
            sym->symMetaData->GetParentToken((mdFieldDef) fldHnd,
                                             &cl);
        }

        if (TypeFromToken((mdToken)cl) == mdtTypeRef)
        {
            sym->symMetaData->GetNameOfTypeRef(cl, &szClassName, &szNamespace);
        }
        else
        {
            sym->symMetaData->GetNameOfTypeDef(cl, &szClassName, &szNamespace);
        }

        *classNamePtr = szClassName;
    }

    return szMemberName;
}

#endif



/*****************************************************************************/

const char * FASTCALL   Compiler::eeGetCPString     (unsigned       strRVA)
{
    return "<UNKNOWN>";
}

const char * FASTCALL   Compiler::eeGetCPAsciiz     (unsigned       cpx)
{ assert(!"NYI"); return 0; }

var_types   JITtype2varType(JIT_types type)
{
    switch(type)
    {
    case ELEMENT_TYPE_VOID:         return TYP_VOID;
    case ELEMENT_TYPE_BOOLEAN:      return TYP_BOOL;
    case ELEMENT_TYPE_CHAR:         return TYP_CHAR;
    case ELEMENT_TYPE_I1:           return TYP_BYTE;
    case ELEMENT_TYPE_U1:           return TYP_UBYTE;
    case ELEMENT_TYPE_I2:           return TYP_SHORT;
    case ELEMENT_TYPE_U2:           return TYP_CHAR;
    case ELEMENT_TYPE_I4:           return TYP_INT;
    case ELEMENT_TYPE_U4:           return TYP_INT;
    case ELEMENT_TYPE_I:            return TYP_I_IMPL;
    case ELEMENT_TYPE_U:            return TYP_U_IMPL;
    case ELEMENT_TYPE_I8:           return TYP_LONG;
    case ELEMENT_TYPE_U8:           return TYP_LONG;
    case ELEMENT_TYPE_R4:           return TYP_FLOAT;
    case ELEMENT_TYPE_R8:           return TYP_DOUBLE;
    case ELEMENT_TYPE_R:            return TYP_DOUBLE;
    case ELEMENT_TYPE_PTR:          return TYP_I_IMPL;
    case ELEMENT_TYPE_BYREF:        return TYP_BYREF;
    case ELEMENT_TYPE_VALUETYPE:
    case ELEMENT_TYPE_TYPEDBYREF:   return TYP_STRUCT;
    case ELEMENT_TYPE_OBJECT:
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_STRING:
    case ELEMENT_TYPE_SZARRAY:
    case ELEMENT_TYPE_ARRAY:        return TYP_REF;

    case ELEMENT_TYPE_END:
    case ELEMENT_TYPE_MAX:
    default: assert(!"Bad type");   return TYP_VOID;
    }
}

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\ee_il_dll.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
class CILJit: public IJitCompiler

{
    JIT_RESULT __stdcall compileMethod (
            IJitInfo*       comp,                   /* IN */
            JIT_METHOD_INFO*methodInfo,             /* IN */
            unsigned        flags,                  /* IN */
            BYTE **         nativeEntry,            /* OUT */
            SIZE_T *        nativeSizeOfCode        /* OUT */
            );
};

inline void eeSetEHcount (
                    COMP_HANDLE   compHandle,
                    unsigned      cEH)
{
    HRESULT res = ((IJitInfo*) compHandle)->setEHcount(cEH);
    if (!SUCCEEDED(res))
        NOMEM()
}


inline void eeSetEHinfo (
                    COMP_HANDLE   compHandle,
                    unsigned EHnumber,
                    const JIT_EH_CLAUSE*  ehInfo)
{
    ((IJitInfo*) compHandle)->setEHinfo(EHnumber, ehInfo);
}

inline BOOL   eeAllocMem (
                    COMP_HANDLE   compHandle,
                    size_t        codeSize,
                    size_t        roDataSize,
                    size_t        rwDataSize,
                    const void ** codeBlock,
                    const void ** roDataBlock,
                    const void ** rwDataBlock)
{
    HRESULT res = ((IJitInfo*) compHandle)->allocMem(codeSize, roDataSize, rwDataSize,
                                             (void**) codeBlock, (void**) roDataBlock, (void**) rwDataBlock);

    return(SUCCEEDED(res));
}

inline void * eeAllocGCInfo (
                    COMP_HANDLE   compHandle,
                    size_t        blockSize)
{
    void* ret;
    HRESULT res = ((IJitInfo*) compHandle)->allocGCInfo(blockSize, &ret);
    if (!SUCCEEDED(res)) ret = 0;
    return(ret);
}

inline PVOID eeGetHelperFtn(
                    COMP_HANDLE                 compHandle,
                    JIT_HELP_FUNCS              hlpFunc,
                    PVOID *                    *ppIndir)
{
    return(((IJitInfo*) compHandle)->getHelperFtn(hlpFunc, (void**)ppIndir));
}


inline void Compiler::eeInit()
{
}

/*****************************************************************************
 *
 *              Functions to get various handles
 */

inline
CLASS_HANDLE        Compiler::eeFindClass    (unsigned       clsTok,
                                              SCOPE_HANDLE   scope,
                                              METHOD_HANDLE  context,
                                              bool           giveUp)
{
    CLASS_HANDLE cls = info.compCompHnd->findClass(scope, clsTok, context);

    if (cls == 0 && giveUp)
    {
#ifdef DEBUG
        eeUnresolvedMDToken (scope, clsTok, "eeFindClass");
#else
        NO_WAY("could not obtain class handle (class not found?)");
#endif
    }

    return(cls);
}

inline
METHOD_HANDLE       Compiler::eeFindMethod   (unsigned       methodTok,
                                              SCOPE_HANDLE   scope,
                                              METHOD_HANDLE  context,
                                              bool           giveUp)
{
    METHOD_HANDLE method = info.compCompHnd->findMethod(scope, methodTok, context);

    if (method == 0 && giveUp)
    {
#ifdef DEBUG
        eeUnresolvedMDToken (scope, methodTok, "eeFindMethod");
#else
        NO_WAY("could not obtain method handle (class not found?)");
#endif
    }

    /* insure there is no collision between helper functions and EE method tokens */
    assert(!method || eeGetHelperNum(method) == JIT_HELP_UNDEF);

    return(method);
}

inline
CLASS_HANDLE Compiler::eeGetMethodClass (
                    METHOD_HANDLE  methodHandle)
{
    CLASS_HANDLE cls = info.compCompHnd->getMethodClass(methodHandle);
    assert(cls != 0 || !eeIsClassMethod(methodHandle));
    return(cls);
}

inline
FIELD_HANDLE         Compiler::eeFindField(unsigned         fieldTok,
                                           SCOPE_HANDLE     scope,
                                           METHOD_HANDLE    context,
                                           bool             giveUp)
{
    FIELD_HANDLE field = info.compCompHnd->findField(scope, fieldTok, context);

    if (field == 0 && giveUp)
    {
#ifdef DEBUG
        eeUnresolvedMDToken (scope, fieldTok, "eeFindField");
#else
        NO_WAY("could not obtain field handle (class not found?)");
#endif
    }

    /* insure there is no collision between local jit data offsets and EE method tokens */
    assert(!field || eeGetJitDataOffs(field) < 0);

    return(field);
}

inline
CLASS_HANDLE        Compiler::eeGetFieldClass  (FIELD_HANDLE       hnd)
{
    CLASS_HANDLE cls = info.compCompHnd->getFieldClass(hnd);
    assert(cls != 0);
    return(cls);
}

inline
unsigned            Compiler::eeGetStringHandle(unsigned        strTok,
                                                SCOPE_HANDLE    scope,
                                                unsigned *     *ppIndir)
{
    return (unsigned) info.compCompHnd->constructStringLiteral(scope,strTok, (void**)ppIndir);
}

inline
void *              Compiler::embedGenericHandle(unsigned       metaTok,
                                                 SCOPE_HANDLE   scope,
                                                 METHOD_HANDLE  context,
                                                 void         **ppIndir,
                                                 bool           giveUp)
{
    void * hnd = (void*)info.compCompHnd->embedGenericHandle(scope, metaTok,
                                                            context, ppIndir);
    if (!hnd && !*ppIndir && giveUp)
        NO_WAY("Could not get generic handle");

    return hnd;
}

/*****************************************************************************
 *
 *                  Functions to get flags
 */
inline
unsigned            Compiler::eeGetClassAttribs   (CLASS_HANDLE   hnd)
{
    // all classes can use direct!
    return(info.compCompHnd->getClassAttribs(hnd));
}

inline
unsigned            Compiler::eeGetFieldAttribs  (FIELD_HANDLE       hnd)
{
    unsigned flags = info.compCompHnd->getFieldAttribs(hnd);

    return flags;
}

inline
unsigned Compiler::eeGetMethodAttribs (METHOD_HANDLE    methodHandle)
{
    return(info.compCompHnd->getMethodAttribs(methodHandle));
}

inline
void     Compiler::eeSetMethodAttribs (METHOD_HANDLE    methodHandle,
                                       unsigned         attr)
{
    info.compCompHnd->setMethodAttribs(methodHandle, attr);
}

inline
void* Compiler::eeGetMethodSync (METHOD_HANDLE  methodHandle,
                                 void **       *ppIndir)
{
    return(info.compCompHnd->getMethodSync(methodHandle, (void**)ppIndir));
}

inline
bool    Compiler::eeIsClassMethod   (METHOD_HANDLE  methodHandle)
{
    return (FLG_CLASS_METHOD & eeGetMethodAttribs(methodHandle)) ? true : false;
}

/*****************************************************************************
 *
 *          VOS info, method sigs, etc
 */

inline
bool                Compiler::eeCanPutField      (FIELD_HANDLE  fieldHnd,
                                                  unsigned      flags,
                                                  CLASS_HANDLE  cls,            // TODO remove this parameter
                                                  METHOD_HANDLE method)
{
    return(info.compCompHnd->canPutField(method, fieldHnd) != 0);
}


inline
void    *           Compiler::eeFindPointer      (SCOPE_HANDLE   scope,
                                                  unsigned       ptrTok,
                                                  bool           giveUp)
{
    void* ret = info.compCompHnd->findPtr(scope, ptrTok);

    if (ret == 0 && giveUp)
            NO_WAY("could not obtain string token");

    return(ret);
}

inline
void               Compiler::eeGetSig           (unsigned       sigTok,
                                                 SCOPE_HANDLE   scope,
                                                 JIT_SIG_INFO*  retSig)
{
    info.compCompHnd->findSig(scope, sigTok, retSig);
}

inline
void               Compiler::eeGetMethodSig      (METHOD_HANDLE  methHnd,
                                                  JIT_SIG_INFO*      sigRet)
{
    info.compCompHnd->getMethodSig(methHnd, sigRet);
}

/*****************************************************************************/
inline
SCOPE_HANDLE Compiler::eeGetMethodScope (METHOD_HANDLE  hnd)
{
    return(info.compCompHnd->getClassModule(info.compCompHnd->getMethodClass(hnd)));
}

/**********************************************************************
 * For varargs we need the number of arguments at the call site
 */

inline
void                Compiler::eeGetCallSiteSig     (unsigned       sigTok,
                                                    SCOPE_HANDLE   scope,
                                                    JIT_SIG_INFO*  sigRet)
{
    info.compCompHnd->findCallSiteSig(scope, sigTok, sigRet);
}

inline
unsigned            Compiler::eeGetMethodVTableOffset(METHOD_HANDLE methHnd)
{
    return(info.compCompHnd->getMethodVTableOffset(methHnd));
}


inline
unsigned            Compiler::eeGetInterfaceID   (CLASS_HANDLE clsHnd, unsigned * *ppIndir)
{
    if (getNewCallInterface())
        return((unsigned) info.compCompHnd->getInterfaceTableOffset(clsHnd, (void**)ppIndir));
    else
        return((unsigned) info.compCompHnd->getInterfaceID(clsHnd, (void**)ppIndir));
}

inline
void    *            Compiler::eeGetHintPtr     (METHOD_HANDLE  methHnd,
                                                 void **       *ppIndir)
{
    return(info.compCompHnd->AllocHintPointer(methHnd, (void**)ppIndir));
}

inline
BOOL                Compiler::eeIsOurMethod     (METHOD_HANDLE methHnd)
{
    return(0);  // to be safe, always answer NO
}

inline
unsigned            Compiler::eeGetPInvokeCookie(CORINFO_SIG_INFO *szMetaSig)
{
    return (unsigned) info.compCompHnd->GetCookieForPInvokeCalliSig(szMetaSig);
}

inline
const void      *   Compiler::eeGetPInvokeStub()
{
    return (const void *) info.compCompHnd->GetEntryPointForPInvokeCalliStub ();
}

inline
int                 Compiler::eeGetNewHelper(CLASS_HANDLE   newCls, METHOD_HANDLE context)
{
    return (info.compCompHnd->getNewHelper(newCls, context));
}

inline
int                  Compiler::eeGetIsTypeHelper   (CLASS_HANDLE   newCls)
{
    return (info.compCompHnd->getIsInstanceOfHelper(newCls));
}

inline
int                  Compiler::eeGetChkCastHelper  (CLASS_HANDLE   newCls)
{
    return (info.compCompHnd->getChkCastHelper(newCls));
}

inline
var_types            Compiler::eeGetFieldType (FIELD_HANDLE   handle, CLASS_HANDLE* structType)

{
        // FIX: can we get rid of the explicit conversion?
#ifdef DEBUG
    if (structType != 0)
        *structType = BAD_CLASS_HANDLE;
#endif
    return(JITtype2varType(info.compCompHnd->getFieldType(handle, structType)));
}

inline
unsigned             Compiler::eeGetFieldOffset   (FIELD_HANDLE   handle)
{
    return(info.compCompHnd->getFieldOffset(handle));
}

inline
unsigned            Compiler::eeGetClassSize   (CLASS_HANDLE   hnd)
{
    assert(hnd != BAD_CLASS_HANDLE);

    if (hnd == REFANY_CLASS_HANDLE)
        return 2 * sizeof(void*); // The byref and the typeinfo

    return(info.compCompHnd->getClassSize(hnd));
}

inline
void                Compiler::eeGetClassGClayout (CLASS_HANDLE   hnd, bool* gcPtrs)
{
    assert(hnd != BAD_CLASS_HANDLE);
    assert(hnd != REFANY_CLASS_HANDLE);

    info.compCompHnd->getClassGClayout(hnd, gcPtrs);
}

/*****************************************************************************/
inline
ARG_LIST_HANDLE     Compiler::eeGetArgNext        (ARG_LIST_HANDLE list)
{
    return(info.compCompHnd->getArgNext(list));
}

/*****************************************************************************/
inline
varType_t           Compiler::eeGetArgType        (ARG_LIST_HANDLE list, JIT_SIG_INFO* sig)
{
    return(JITtype2varType(info.compCompHnd->getArgType(sig, list)));

}

/*****************************************************************************/
inline
varType_t           Compiler::eeGetArgType        (ARG_LIST_HANDLE list, JIT_SIG_INFO* sig, bool* isPinned)
{
    CorInfoType type = info.compCompHnd->getArgType(sig, list);
    *isPinned = ((type & ~CORINFO_TYPE_MASK) != 0);
    return JITtype2varType(type);
}

inline
CLASS_HANDLE        Compiler::eeGetArgClass       (ARG_LIST_HANDLE list, JIT_SIG_INFO * sig)
{
    CLASS_HANDLE cls;
    cls = info.compCompHnd->getArgClass(sig, list);

    if (!cls)
        NO_WAY("Could not figure out Class specified in argument or local signature");

    return cls;
}

/*****************************************************************************
 *
 *                  Method entry-points, IL
 */

inline
void    *       Compiler::eeGetMethodPointer(METHOD_HANDLE   methHnd,
                                             InfoAccessType *pAccessType)
{
    if (!eeIsNativeMethod(methHnd))
    {
        return(info.compCompHnd->getFunctionPointer(methHnd, pAccessType));
    }
    else
    {
        void * addr, **pAddr;
        addr = info.compCompHnd->getPInvokeUnmanagedTarget(
                                    eeGetMethodHandleForNative(methHnd), (void**)&pAddr);
        assert((!addr) != (!pAddr));
        if (addr)
        {
            *pAccessType = IAT_VALUE;
            return addr;
        }
        else
        {
            *pAccessType = IAT_PVALUE;
            return (void*)pAddr;
        }
    }
}

inline
void    *           Compiler::eeGetMethodEntryPoint(METHOD_HANDLE   methHnd,
                                                    InfoAccessType *pAccessType)
{
    if (!eeIsNativeMethod(methHnd))
    {
        return(info.compCompHnd->getFunctionEntryPoint(methHnd, pAccessType));
    }
    else
    {
        void * addr, **pAddr;
        addr = info.compCompHnd->getAddressOfPInvokeFixup(
                                    eeGetMethodHandleForNative(methHnd), (void**)&pAddr);
        assert((!addr) != (!pAddr));
        if (addr)
        {
            *pAccessType = IAT_PVALUE;
            return addr;
        }
        else
        {
            *pAccessType = IAT_PPVALUE;
            return (void*)pAddr;
        }
    }
}

inline
bool                 Compiler::eeGetMethodInfo  (METHOD_HANDLE  method,
                                                 JIT_METHOD_INFO* methInfo)
{
    return(info.compCompHnd->getMethodInfo(method, methInfo));
}

inline
bool                 Compiler::eeCanInline (METHOD_HANDLE  callerHnd,
                                            METHOD_HANDLE  calleeHnd)
{
    return(info.compCompHnd->canInline(callerHnd, calleeHnd));
}

inline
bool                 Compiler::eeCanTailCall (METHOD_HANDLE  callerHnd,
                                              METHOD_HANDLE  calleeHnd)
{
    return(info.compCompHnd->canTailCall(callerHnd, calleeHnd));
}

inline
void    *            Compiler::eeGetFieldAddress (FIELD_HANDLE   handle,
                                                  void **       *ppIndir)
{
    return(info.compCompHnd->getFieldAddress(handle, (void**)ppIndir));
}

inline
unsigned             Compiler::eeGetFieldThreadLocalStoreID (
                                                  FIELD_HANDLE   handle,
                                                  void **       *ppIndir)
{
    return(info.compCompHnd->getFieldThreadLocalStoreID(handle, (void**)ppIndir));
}

inline
void                 Compiler::eeGetEHinfo      (unsigned       EHnum,
                                                 JIT_EH_CLAUSE* clause)

{
    info.compCompHnd->getEHinfo(info.compMethodHnd, EHnum, clause);
    return;
}

#ifdef PROFILER_SUPPORT
inline
PROFILING_HANDLE    Compiler::eeGetProfilingHandle(METHOD_HANDLE        method,
                                                   BOOL                                 *pbHookFunction,
                                                   PROFILING_HANDLE *  *ppIndir)
{
    return (info.compCompHnd->GetProfilingHandle(method, pbHookFunction, (void**)ppIndir));
}

#endif

/*****************************************************************************
 *
 *                  Native Direct Optimizations
 */

        // return the unmanaged calling convention for a PInvoke
inline
UNMANAGED_CALL_CONV  Compiler::eeGetUnmanagedCallConv(METHOD_HANDLE method)
{
    return info.compCompHnd->getUnmanagedCallConv(method);
}

        // return if any marshaling is required for PInvoke methods
inline
BOOL                 Compiler::eeNDMarshalingRequired(METHOD_HANDLE method)
{
    return info.compCompHnd->pInvokeMarshalingRequired(method);
}

inline
void                 Compiler::eeGetEEInfo(EEInfo *pEEInfoOut)
{
    info.compCompHnd->getEEInfo(pEEInfoOut);
}

inline
DWORD                 Compiler::eeGetThreadTLSIndex(DWORD * *ppIndir)
{
    return info.compCompHnd->getThreadTLSIndex((void**)ppIndir);
}

inline
const void *        Compiler::eeGetInlinedCallFrameVptr(const void ** *ppIndir)
{
    return info.compCompHnd->getInlinedCallFrameVptr((void**)ppIndir);
}

inline
LONG *              Compiler::eeGetAddrOfCaptureThreadGlobal(LONG ** *ppIndir)
{
    return info.compCompHnd->getAddrOfCaptureThreadGlobal((void**)ppIndir);
}

/*****************************************************************************
 *
 *                  Debugging support - Local var info
 */

inline
void FASTCALL       Compiler::eeSetLVcount  (unsigned      count)
{
    eeVarsCount = count;
    if (eeVarsCount)
        eeVars = (VarResultInfo *)info.compCompHnd->allocateArray(eeVarsCount * sizeof(eeVars[0]));
    else
        eeVars = NULL;
}

inline
void                Compiler::eeSetLVinfo
                                (unsigned               which,
                                 unsigned                   startOffs,
                                 unsigned                   length,
                                 unsigned                   varNum,
                                 unsigned                   LVnum,
                                 lvdNAME                    name,
                                 bool                       avail,
                                 const Compiler::siVarLoc & varLoc)
{
    // IJitDebugInfo::VarLoc and Compiler::siVarLoc have to overlap
    // This is checked in siInit()

    assert(eeVarsCount);
    assert(which < eeVarsCount);
    eeVars[which].startOffset   = startOffs;
    eeVars[which].endOffset     = startOffs + length;
    eeVars[which].varNumber     = varNum;
    eeVars[which].loc           = varLoc;
}

inline
void                Compiler::eeSetLVdone()
{
    // necessary but not sufficient condition that the 2 struct definitions overlap
    assert(sizeof(eeVars[0]) == sizeof(IJitDebugInfo::NativeVarInfo));

    info.compCompHnd->setVars(info.compMethodHnd,
                              eeVarsCount,
                              (IJitDebugInfo::NativeVarInfo *) eeVars);

    eeVars = NULL; // We give up ownership after setVars()
}

/*****************************************************************************
 *
 *                  Debugging support - Line number info
 */

inline
void FASTCALL       Compiler::eeSetLIcount   (unsigned       count)
{
    eeBoundariesCount = count;
    if (eeBoundariesCount)
        eeBoundaries = (boundariesDsc *) info.compCompHnd->allocateArray(eeBoundariesCount * sizeof(eeBoundaries[0]));
    else
        eeBoundaries = NULL;
}

inline
void FASTCALL       Compiler::eeSetLIinfo  (unsigned       which,
                                            NATIVE_IP      nativeOffset,
                                            IL_OFFSET      ilOffset)
{
    assert(eeBoundariesCount && which<eeBoundariesCount);
    eeBoundaries[which].nativeIP = nativeOffset;
    eeBoundaries[which].ilOffset = ilOffset;
}

inline
void                Compiler::eeSetLIdone()
{
    // necessary but not sufficient condition that the 2 struct definitions overlap
    assert(sizeof(eeBoundaries[0]) == sizeof(IJitDebugInfo::OffsetMapping));

    info.compCompHnd->setBoundaries(info.compMethodHnd,
                                    eeBoundariesCount,
                                    (IJitDebugInfo::OffsetMapping *) eeBoundaries);

#ifdef DEBUG
    if (verbose)
    {
        printf("IP mapping count : %d\n", eeBoundariesCount);
        for(unsigned i = 0; i < eeBoundariesCount; i++)
            printf("IL offs %03Xh : %08Xh\n", eeBoundaries[i].ilOffset, eeBoundaries[i].nativeIP);
        printf("\n");
    }
#endif
    eeBoundaries = NULL; // we give up ownership after setBoundaries();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitia64.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitdef.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EMITDEF_H_
#define _EMITDEF_H_
/*****************************************************************************/

#if     TGT_x86

#include "emitX86.h"

#else

#include "emitRISC.h"

#if     TGT_SH3
#include "emitSH3.h"
#elif     TGT_MIPS32
#include "emitMIPS.h"
#elif     TGT_ARM
#include "emitARM.h"
#elif     TGT_PPC
#include "emitPPC.h"
#elif     TGT_IA64
#include "emitIA64.h"
#else
#error Unexpected target
#endif

#endif

/*****************************************************************************/
#endif//_EMITDEF_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emit.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                              emit.cpp                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "alloc.h"
#include "instr.h"
#include "target.h"

#include "emit.h"

/*****************************************************************************/
#if !   TGT_IA64
/*****************************************************************************/

#if     0
#define VERBOSE 1
#else
#define VERBOSE verbose
#endif

#ifdef  NOT_JITC
#undef  VERBOSE
#define VERBOSE 0
#endif

/*****************************************************************************
 *
 *  Return the name of an instruction format.
 */

#ifdef  DEBUG

const char  *   emitter::emitIfName(unsigned f)
{
    static
    const char  *   ifNames[] =
    {
        #define IF_DEF(en, op1, op2) "IF_" #en,
        #include "emitfmts.h"
        #undef  IF_DEF
    };

    static
    char            errBuff[32];

    if  (f < sizeof(ifNames)/sizeof(*ifNames))
        return  ifNames[f];

    sprintf(errBuff, "??%u??", f);
    return  errBuff;
}

#endif

/*****************************************************************************
 *
 *  Local buffer - used first for memory allocation, when it's full we start
 *  allocating through the client-supplied allocator.
 *
 *  Note that we try to size the buffer so that it pads the data section of
 *  JIT DLL to be close to a multiple of OS pages.
 *
 *  MSCORJIT:
 *
 *      0002:00000000 00001560H .data                   DATA
 *      0002:00001560 0000150cH .bss                    DATA
 */

#if     USE_LCL_EMIT_BUFF

BYTE                emitter::emitLclBuff[ 40*sizeof(instrDesc)+15*TINY_IDSC_SIZE];

CRITICAL_SECTION    emitter::emitCritSect;
bool                emitter::emitCrScInit;
bool                emitter::emitCrScBusy;

#endif

/*****************************************************************************/

#ifdef  TRANSLATE_PDB

/* these are protected */

AddrMap     *       emitter::emitPDBOffsetTable = 0;
LocalMap    *       emitter::emitPDBLocalTable  = 0;
bool                emitter::emitIsPDBEnabled   = true;
BYTE        *       emitter::emitILBaseOfCode   = 0;
BYTE        *       emitter::emitILMethodBase   = 0;
BYTE        *       emitter::emitILMethodStart  = 0;
BYTE        *       emitter::emitImgBaseOfCode  = 0;

inline void emitter::SetIDSource( instrDesc *id )
{
    id->idilStart = emitInstrDescILBase;
}

void emitter::MapCode( long ilOffset, BYTE *imgDest )
{
    if( emitIsPDBEnabled )
    {
        emitPDBOffsetTable->MapSrcToDest( ilOffset, (long)( imgDest - emitImgBaseOfCode ));
    }
}

void emitter::MapFunc( long imgOff,    long procLen,  long dbgStart, long dbgEnd, short frameReg,
                       long stkAdjust, int  lvaCount, OptJit::LclVarDsc *lvaTable, bool framePtr )
{
    if( emitIsPDBEnabled )
    {
        // this code stores information about local symbols for the PDB translation

        assert( lvaCount >=0 );         // don't allow a negative count

        LvaDesc *rgLvaDesc = 0;

        if( lvaCount > 0 )
        {
            // @TODO: Check for out of memory
            rgLvaDesc = new LvaDesc[lvaCount];
            _ASSERTE(rgLvaDesc != NULL);

            LvaDesc *pDst = rgLvaDesc;
            OptJit::LclVarDsc *pSrc = lvaTable;
            for( int i = 0; i < lvaCount; ++i, ++pDst, ++pSrc )
            {
                pDst->slotNum = pSrc->lvSlotNum;
                pDst->isReg   = pSrc->lvRegister;
                pDst->reg     = (pSrc->lvRegister ? pSrc->lvRegNum : frameReg );
                pDst->off     =  pSrc->lvStkOffs + stkAdjust;
            }
        }

        emitPDBLocalTable->AddFunc( (long)(emitILMethodBase - emitILBaseOfCode),
                                    imgOff - (long)emitImgBaseOfCode,
                                    procLen,
                                    dbgStart - imgOff,
                                    dbgEnd - imgOff,
                                    lvaCount,
                                    rgLvaDesc,
                                    framePtr );
        // do not delete rgLvaDesc here -- responsibility is now on emitPDBLocalTable destructor
    }
}


/* these are public */

void emitter::SetILBaseOfCode ( BYTE    *pTextBase )
{
    emitILBaseOfCode = pTextBase;
}

void emitter::SetILMethodBase ( BYTE *pMethodEntry )
{
    emitILMethodBase = pMethodEntry;
}

void emitter::SetILMethodStart( BYTE  *pMethodCode )
{
    emitILMethodStart = pMethodCode;
}

void emitter::SetImgBaseOfCode( BYTE    *pTextBase )
{
    emitImgBaseOfCode = pTextBase;
}

void emitter::SetIDBaseToProlog()
{
    emitInstrDescILBase = (long)( emitILMethodBase - emitILBaseOfCode );
}

void emitter::SetIDBaseToOffset( long methodOffset )
{
    emitInstrDescILBase = methodOffset + (long)( emitILMethodStart - emitILBaseOfCode );
}

void emitter::DisablePDBTranslation()
{
    // this function should disable PDB translation code
    emitIsPDBEnabled = false;
}

bool emitter::IsPDBEnabled()
{
    return emitIsPDBEnabled;
}

void emitter::InitTranslationMaps( long ilCodeSize )
{
    if( emitIsPDBEnabled )
    {
        emitPDBOffsetTable = AddrMap::Create( ilCodeSize );
        emitPDBLocalTable = LocalMap::Create();
    }
}

void emitter::DeleteTranslationMaps()
{
    if( emitPDBOffsetTable )
    {
        delete emitPDBOffsetTable;
        emitPDBOffsetTable = 0;
    }
    if( emitPDBLocalTable )
    {
        delete emitPDBLocalTable;
        emitPDBLocalTable = 0;
    }
}

void emitter::InitTranslator( PDBRewriter *           pPDB,
                              int *                   rgSecMap,
                              IMAGE_SECTION_HEADER ** rgpHeader,
                              int                     numSections )
{
    if( emitIsPDBEnabled )
    {
        pPDB->InitMaps( rgSecMap,               // new PE section header order
                        rgpHeader,              // array of section headers
                        numSections,            // number of sections
                        emitPDBOffsetTable,     // code offset translation table
                        emitPDBLocalTable );    // slot variable translation table
    }
}

#endif // TRANSLATE_PDB

/*****************************************************************************/

#if EMITTER_STATS_RLS

unsigned            emitter::emitTotIDcount;
unsigned            emitter::emitTotIDsize;

#endif

/*****************************************************************************/

#if EMITTER_STATS

static  unsigned    totAllocdSize;
static  unsigned    totActualSize;

        unsigned    emitter::emitIFcounts[emitter::IF_COUNT];
#if SCHEDULER
        unsigned    emitter::schedFcounts[emitter::IF_COUNT];
#endif

static  size_t       emitSizeMethod;
static  unsigned     emitSizeBuckets[] = { 100, 1024*1, 1024*2, 1024*3, 1024*4, 1024*5, 1024*10, 0 };
static  histo        emitSizeTable(emitSizeBuckets);

static  unsigned      GCrefsBuckets[] = { 0, 1, 2, 5, 10, 20, 50, 128, 256, 512, 1024, 0 };
static  histo         GCrefsTable(GCrefsBuckets);

#if TRACK_GC_REFS
static  unsigned    stkDepthBuckets[] = { 0, 1, 2, 5, 10, 16, 32, 128, 1024, 0 };
static  histo       stkDepthTable(stkDepthBuckets);
#endif

#if SCHEDULER

static  unsigned    scdCntBuckets[] = { 0, 1, 2, 3, 4, 5, 8, 12, 16, 20, 24, 32, 128, 256, 1024, 0 };
histo      emitter::scdCntTable(scdCntBuckets);

static  unsigned    scdSucBuckets[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 28, 32, 48, 64, 1024, 0 };
histo      emitter::scdSucTable(scdSucBuckets);

static  unsigned    scdFrmCntBuckets[] = { 0, 1, 2, 3, 4, 5, 8, 12, 16, 20, 24, 32, 128, 256, 1024, 0 };
histo      emitter::scdFrmCntTable(scdFrmCntBuckets);

#endif  // SCHEDULER

unsigned            emitter::emitTotMemAlloc;
unsigned            emitter::emitLclMemAlloc;
unsigned            emitter::emitExtMemAlloc;

unsigned            emitter::emitTotalInsCnt;

unsigned            emitter::emitTotalIGcnt;
unsigned            emitter::emitTotalIGjmps;
unsigned            emitter::emitTotalIGptrs;
unsigned            emitter::emitTotalIGicnt;
unsigned            emitter::emitTotalIGsize;
unsigned            emitter::emitTotalIGmcnt;

unsigned            emitter::emitSmallDspCnt;
unsigned            emitter::emitLargeDspCnt;

unsigned            emitter::emitSmallCnsCnt;
unsigned            emitter::emitLargeCnsCnt;
unsigned            emitter::emitSmallCns[SMALL_CNS_TSZ];

void                emitterStats()
{
    if  (totAllocdSize)
    {
        assert(totActualSize <= totAllocdSize);

        printf("\nTotal allocated code size = %u\n", totAllocdSize);

        if  (totActualSize < totAllocdSize)
        {
            printf("Total generated code size = %u  ", totActualSize);

            printf("(%4.3f%% waste)", 100*((totAllocdSize-totActualSize)/(double)totActualSize));
            printf("\n");
        }

        assert(emitter::emitTotalInsCnt);

        printf("Average of %4.2f bytes of code generated per instruction\n", (double)totActualSize/emitter::emitTotalInsCnt);
    }

#if 0
#if SCHEDULER

    printf("\nSchedulable instruction format frequency table:\n\n");

    unsigned    f, ic = 0;

    for (f = 0; f < emitter::IF_COUNT; f++)
        ic += schedFcounts[f];

    for (f = 0; f < emitter::IF_COUNT; f++)
    {
        unsigned    cnt = schedFcounts[f];

        if  (cnt)
            printf("%20s %8u (%5.2f%%)\n", emitIfName(f), cnt, 100.0*cnt/ic);
    }

    printf("\n\n");

#endif
#endif

#if 0

    printf("\nInstruction format frequency table:\n\n");

    unsigned    f, ic = 0, dc = 0;

    for (f = 0; f < emitter::IF_COUNT; f++)
        ic += emitter::emitIFcounts[f];

    for (f = 0; f < emitter::IF_COUNT; f++)
    {
        unsigned    c = emitter::emitIFcounts[f];

        if  (c && 1000*c >= ic)
        {
            dc += c;
            printf("%20s %8u (%5.2f%%)\n", emitter::emitIfName(f), c, 100.0*c/ic);
        }
    }

    printf("         -----------------------------\n");
    printf("%20s %8u (%5.2f%%)\n", "Total shown", dc, 100.0*dc/ic);
    printf("\n");

#endif

#ifdef  DEBUG
    if  (!verbose) return;
#endif

#if 0

    printf("\n");
    printf("Offset of idIns       = %2u\n", offsetof(emitter::instrDesc, idIns       ));
    printf("Offset of idInsFmt    = %2u\n", offsetof(emitter::instrDesc, idInsFmt    ));
//  printf("Offset of idSmallCns  = %2u\n", offsetof(emitter::instrDesc, idSmallCns  ));
//  printf("Offset of idOpSize    = %2u\n", offsetof(emitter::instrDesc, idOpSize    ));
//  printf("Offset of idInsSize   = %2u\n", offsetof(emitter::instrDesc, idInsSize   ));
//  printf("Offset of idReg       = %2u\n", offsetof(emitter::instrDesc, idReg       ));
    printf("Offset of idAddr      = %2u\n", offsetof(emitter::instrDesc, idAddr      ));
    printf("\n");
    printf("Size   of idAddr      = %2u\n", sizeof(((emitter::instrDesc*)0)->idAddr  ));
    printf("Size   of insDsc      = %2u\n", sizeof(  emitter::instrDesc              ));
    printf("\n");
    printf("Offset of sdnDepsAll  = %2u\n", offsetof(emitter::scDagNode, sdnDepsAll  ));
//  printf("Offset of sdnDepsAGI  = %2u\n", offsetof(emitter::scDagNode, sdnDepsAGI  ));
    printf("Offset of sdnDepsFlow = %2u\n", offsetof(emitter::scDagNode, sdnDepsFlow ));
    printf("Offset of sdnNext     = %2u\n", offsetof(emitter::scDagNode, sdnNext     ));
    printf("Offset of sdnIndex    = %2u\n", offsetof(emitter::scDagNode, sdnIndex    ));
    printf("Offset of sdnPreds    = %2u\n", offsetof(emitter::scDagNode, sdnPreds    ));
    printf("Offset of sdnHeight   = %2u\n", offsetof(emitter::scDagNode, sdnHeight   ));
    printf("\n");
    printf("Size   of scDagNode   = %2u\n",   sizeof(emitter::scDagNode              ));
    printf("\n");

#endif

#if 0

    printf("Size   of regPtrDsc = %2u\n",   sizeof(Compiler::regPtrDsc           ));
    printf("Offset of rpdNext   = %2u\n", offsetof(Compiler::regPtrDsc, rpdNext  ));
    printf("Offset of rpdBlock  = %2u\n", offsetof(Compiler::regPtrDsc, rpdBlock ));
    printf("Offset of rpdOffs   = %2u\n", offsetof(Compiler::regPtrDsc, rpdOffs  ));
    printf("Offset of <union>   = %2u\n", offsetof(Compiler::regPtrDsc, rpdPtrArg));
    printf("\n");

#endif

    if  (emitter::emitTotalIGmcnt)
    {
        printf("Average of %8.1lf ins groups   per method\n", (double)emitter::emitTotalIGcnt  / emitter::emitTotalIGmcnt);
        printf("Average of %8.1lf instructions per method\n", (double)emitter::emitTotalIGicnt / emitter::emitTotalIGmcnt);
#ifndef DEBUG
        printf("Average of %8.1lf desc.  bytes per method\n", (double)emitter::emitTotalIGsize / emitter::emitTotalIGmcnt);
#endif
        printf("Average of %8.1lf jumps        per method\n", (double)emitter::emitTotalIGjmps / emitter::emitTotalIGmcnt);
        printf("Average of %8.1lf GC livesets  per method\n", (double)emitter::emitTotalIGptrs / emitter::emitTotalIGmcnt);
        printf("\n");
        printf("Average of %8.1lf instructions per group \n", (double)emitter::emitTotalIGicnt / emitter::emitTotalIGcnt );
#ifndef DEBUG
        printf("Average of %8.1lf desc.  bytes per group \n", (double)emitter::emitTotalIGsize / emitter::emitTotalIGcnt );
#endif
        printf("Average of %8.1lf jumps        per group \n", (double)emitter::emitTotalIGjmps / emitter::emitTotalIGcnt );
        printf("\n");
        printf("Average of %8.1lf bytes        per insdsc\n", (double)emitter::emitTotalIGsize / emitter::emitTotalIGicnt);
#ifndef DEBUG
        printf("\n");
        printf("A total of %8u desc.  bytes\n"              ,         emitter::emitTotalIGsize);
#endif
        printf("\n");
    }

#if 0

    printf("Descriptor size distribution:\n");
    emitSizeTable.histoDsp();
    printf("\n");

    printf("GC ref frame variable counts:\n");
    GCrefsTable.histoDsp();
    printf("\n");

    printf("Max. stack depth distribution:\n");
    stkDepthTable.histoDsp();
    printf("\n");

#if SCHEDULER

    printf("Schedulable instruction counts:\n");
    schedCntTable.histoDsp();
    printf("\n");

    printf("Scheduling dag node successor counts:\n");
    schedSucTable.histoDsp();
    printf("\n");

    printf("Schedulable frame range size counts:\n");
    scdFrmCntTable.histoDsp();
    printf("\n");

#endif  // SCHEDULER

#endif  // 0

#if 0

    int             i;
    unsigned        c;
    unsigned        m;

    if  (emitter::emitSmallCnsCnt || emitter::emitLargeCnsCnt)
    {
        printf("SmallCnsCnt = %6u\n"                  , emitter::emitSmallCnsCnt);
        printf("LargeCnsCnt = %6u (%3u %% of total)\n", emitter::emitLargeCnsCnt, 100*emitter::emitLargeCnsCnt/(emitter::emitLargeCnsCnt+emitter::emitSmallCnsCnt));
    }

    if  (emitter::emitSmallCnsCnt)
    {
        printf("\n");

        m = emitter::emitSmallCnsCnt/1000 + 1;

        for (i = ID_MIN_SMALL_CNS; i < ID_MAX_SMALL_CNS; i++)
        {
            c = emitter::emitSmallCns[i-ID_MIN_SMALL_CNS];
            if  (c >= m)
                printf("cns[%4d] = %u\n", i, c);
        }
    }

#endif

    printf("Altogether %8u total   bytes allocated.\n", emitter::emitTotMemAlloc);
    printf("           %8u       locally allocated.\n", emitter::emitLclMemAlloc);
    printf("           %8u     externaly allocated.\n", emitter::emitExtMemAlloc);
}

#endif  // EMITTER_STATS

/*****************************************************************************/

signed char         emitTypeSizes[] =
{
    #define DEF_TP(tn,nm,jitType,sz,sze,asze,st,al,tf,howUsed) sze,
    #include "typelist.h"
    #undef DEF_TP
};

signed char         emitTypeActSz[] =
{
    #define DEF_TP(tn,nm,jitType,sz,sze,asze,st,al,tf,howUsed) asze,
    #include "typelist.h"
    #undef DEF_TP
};

/*****************************************************************************
 *
 *  The following called for each recorded instruction -- use for debugging.
 */

#ifdef  DEBUG

static
unsigned            insCount;

void                emitter::emitInsTest(instrDesc *id)
{

#if 0

    if  (insCount == 24858)
        BreakIfDebuggerPresent();

#ifdef  NOT_JITC
    const char *m = emitComp->info.compMethodName;
    const char *c = emitComp->info.compClassName;
#endif

    insCount++;

#endif

}

#endif

/*****************************************************************************/
#ifndef NOT_JITC
/*****************************************************************************
 *
 *  When the JIT compiler is built as an executable (for testing), this routine
 *  supplies the functionality (normally supplied by the execution engine) that
 *  allocates memory for the code and data blocks.
 *
 *  IMPORTANT NOTE: The allocator is a static member (to keep things simple),
 *                  which means that the emitter can't be re-entered in the
 *                  command-line compiler.
 */

commitAllocator     emitter::eeAllocator;

bool                emitter::eeAllocMem(COMP_HANDLE   compHandle,
                                        size_t        codeSize,
                                        size_t        roDataSize,
                                        size_t        rwDataSize,
                                        const void ** codeBlock,
                                        const void ** roDataBlock,
                                        const void ** rwDataBlock)
{
    size_t          size = roundUp(codeSize);
    BYTE        *   base;

    assert(savCode);

    /* Make sure the data blocks are aligned (if non-empty) */

#if     EMIT_USE_LIT_POOLS

    assert(roDataSize == 0);
    assert(rwDataSize == 0);

#else

    if  (rwDataSize || roDataSize)
    {
        rwDataSize = roundUp(rwDataSize);
        roDataSize = roundUp(roDataSize);

        size += rwDataSize + roDataSize;
    }

#endif

    base = (BYTE*)eeAllocator.cmaGetm(size);
    if  (!base)
        return  false;

    /* Report the code block address to the caller */

    *codeBlock = base;

    /* Compute the data section offsets, if non-empty */

#if !   EMIT_USE_LIT_POOLS

    if  (rwDataSize || roDataSize)
    {
        base +=   codeSize; *rwDataBlock = base;
        base += rwDataSize; *roDataBlock = base;
    }
    else
#endif
    {
        /* For safety ... */

#ifdef  DEBUG
        *roDataBlock =
        *rwDataBlock = NULL;
#endif

    }

    return  true;
}

/*****************************************************************************/
#endif//NOT_JITC
/*****************************************************************************
 *
 *  Initialize the emitter - called once, at DLL load time.
 */

void                emitter::emitInit()
{

#if USE_LCL_EMIT_BUFF

//  printf("Local buff size in bytes  = 0x%04X\n", sizeof(emitLclBuff));
//  printf("Local buff size in tiny's = %u    \n", sizeof(emitLclBuff)/TINY_IDSC_SIZE);
//  printf("Local buff size in idsc's = %u    \n", sizeof(emitLclBuff)/sizeof(instrDesc));

    /* Initialize the critical section */

    InitializeCriticalSection(&emitCritSect);

    emitCrScInit = true;
    emitCrScBusy = false;

#endif

#ifndef NOT_JITC

    if  (savCode)
    {
        if  (eeAllocator.cmaInitT(4*OS_page_size,
                                  4*OS_page_size,
                                  MAX_SAVED_CODE_SIZE))
        {
            // CONSIDER: Telling the poor user that nothing will be saved

            runCode = savCode = false;
        }
    }

#endif

}

/*****************************************************************************
 *
 *  Shut down the emitter - called once, at DLL exit time.
 */

void                emitter::emitDone()
{

#if EMITTER_STATS_RLS

    printf("\n");
    printf("Offset of idIns       = %2u\n", offsetof(emitter::instrDesc, idIns       ));
    printf("Offset of idInsFmt    = %2u\n", offsetof(emitter::instrDesc, idInsFmt    ));
//  printf("Offset of idSmallCns  = %2u\n", offsetof(emitter::instrDesc, idSmallCns  ));
//  printf("Offset of idOpSize    = %2u\n", offsetof(emitter::instrDesc, idOpSize    ));
//  printf("Offset of idReg       = %2u\n", offsetof(emitter::instrDesc, idReg       ));
    printf("Offset of idInfo      = %2u\n", offsetof(emitter::instrDesc, idInfo      ));
    printf("Offset of idAddr      = %2u\n", offsetof(emitter::instrDesc, idAddr      ));
    printf("\n");
    printf("Size   of tinyID      = %2u\n", TINY_IDSC_SIZE);
    printf("Size   of scnsID      = %2u\n", SCNS_IDSC_SIZE);
    printf("Size   of instrDesc   = %2u\n", sizeof(emitter::instrDesc));
    printf("\n");
    printf("Size   of id.idAddr   = %2u\n", sizeof(((emitter::instrDesc*)0)->idAddr  ));
    printf("\n");
//  printf("ID_BIT_SMALL_CNS = %u\n", ID_BIT_SMALL_CNS);
//  printf("ID_MIN_SMALL_CNS = %u\n", ID_MIN_SMALL_CNS);
//  printf("ID_MAX_SMALL_CNS = %u\n", ID_MAX_SMALL_CNS);
//  printf("\n");

    printf("Total number of instrDesc's allocated = %u\n", emitTotIDcount);
    printf("Average size of instrDesc's allocated = %6.3f\n", (double)emitTotIDsize/emitTotIDcount);
    printf("\n");

#endif  // EMITTER_STATS_RLS

#ifndef NOT_JITC

    if  (savCode)
        eeAllocator.cmaFree();

#endif

#if USE_LCL_EMIT_BUFF

    /* Delete the critical section if we've created one */

    if  (emitCrScInit)
    {
        DeleteCriticalSection(&emitCritSect);
        emitCrScInit = false;
    }

#endif

}

/*****************************************************************************
 *
 *  Record some info about the method about to be emitted.
 */

void                emitter::emitBegCG(Compiler     *comp,
                                       COMP_HANDLE   cmpHandle)
{
    emitComp      = comp;
    emitCmpHandle = cmpHandle;
}

void                emitter::emitEndCG()
{
}

/*****************************************************************************
 *
 *  Allocate an instruction group descriptor and assign it the next index.
 */

inline
emitter::insGroup *   emitter::emitAllocIG()
{
    insGroup    *   ig;

    /* Allocate a group descriptor */

    ig = emitCurIG    = (insGroup*)emitGetMem(sizeof(*ig));

#if EMITTER_STATS
    emitTotalIGcnt   += 1;
    emitTotalIGsize  += sizeof(*ig);
    emitSizeMethod  += sizeof(*ig);
#endif

    /* Assign the next available index to the instruction group */

    ig->igNum       = emitNxtIGnum++;

#ifdef  DEBUG
    ig->igSelf      = ig;
#endif

#if     EMIT_USE_LIT_POOLS
    ig->igLPuseCntW = 0;
    ig->igLPuseCntL = 0;
    ig->igLPuseCntA = 0;
#endif

    ig->igFlags     = 0;

    return  ig;
}

/*****************************************************************************
 *
 *  Prepare the given IG for emission of code.
 */

void                emitter::emitGenIG(insGroup *ig, size_t sz)
{
    /* Set the "current IG" value */

    emitCurIG         = ig;

#if EMIT_TRACK_STACK_DEPTH

    /* Record the stack level on entry to this group */

    ig->igStkLvl      = emitCurStackLvl;

    // If we dont have enough bits in igStkLvl, refuse to compile

    if (ig->igStkLvl != emitCurStackLvl)
        fatal (ERRinternal, "Too many arguments pushed on stack", "");

//  printf("Start IG #%02u [stk=%02u]\n", ig->igNum, emitCurStackLvl);

#endif

    /* Record the (estimated) code offset of the group */

    ig->igOffs        = emitCurCodeOffset;

    /* Make sure the code offset looks reasonably aligned */

#if TGT_RISC
    assert((ig->igOffs & (INSTRUCTION_SIZE-1)) == 0);
#endif

    /* Prepare to issue instructions */

    emitCurIGinsCnt   = 0;
#if SCHEDULER
    emitCurIGscd1st   = 0;
    emitCurIGscdOfs   = 0;
#endif
    emitCurIGsize     = 0;
#if TGT_MIPS32
        emitLastHLinstr   = 0;
#endif

    assert(emitCurIGjmpList == NULL);
#if EMIT_USE_LIT_POOLS
    assert(emitLPRlistIG    == NULL);
#endif

    /* Figure out how much space we'd like to have */
    if  (sz == 0)
        sz = SC_IG_BUFFER_SIZE + sizeof(VARSET_TP);

#if USE_LCL_EMIT_BUFF

    /* Can we emit directly into the local buffer? */

    size_t          fs = emitLclAvailMem();

//  printf("Lcl buff available = %u, need = %u\n", fs, sz);

    if  (fs >= sz)
    {
        /* Make sure we don't grab too much space */

        fs = min(fs, 255*TINY_IDSC_SIZE);

        /* Prepare to record instructions in the buffer */

        emitCurIGfreeBase =
        emitCurIGfreeNext =   emitLclBuffNxt
                          + sizeof(unsigned)    // for IGF_BYREF_REGS
                          + sizeof(VARSET_TP);  // for IGF_GC_VARS
                          emitLclBuffNxt += fs;
        emitCurIGfreeEndp = emitLclBuffNxt;

        emitLclBuffDst    = true;
        return;
    }

    /* We'll have to use the other buffer and copy later */

    emitLclBuffDst    = false;

//  if  (!emitIGbuffAddr) printf("Switching to temp buffer: %4u/%4u\n", emitLclBuffEnd-emitLclBuffNxt, SC_IG_BUFFER_SIZE);

#endif

    /* Allocate the temp instruction buffer if we haven't done so */

    if  (emitIGbuffAddr == NULL)
    {
        emitIGbuffSize = SC_IG_BUFFER_SIZE;
        emitIGbuffAddr = (BYTE*)emitGetMem(emitIGbuffSize);
    }

    emitCurIGfreeBase =
    emitCurIGfreeNext = emitIGbuffAddr;
    emitCurIGfreeEndp = emitIGbuffAddr + emitIGbuffSize;
}

/*****************************************************************************
 *
 *  Append a new IG to the current list, and get it ready to receive code.
 */

inline
void                emitter::emitNewIG()
{
    insGroup    *   ig = emitAllocIG();

    /* Append the group to the list */

    assert(emitIGlist);
    assert(emitIGlast);

    ig->igNext   = NULL;
    ig->igPrev   = emitIGlast;
                   emitIGlast->igNext = ig;
                   emitIGlast         = ig;

    if (emitHasHandler)
        ig->igFlags |= IGF_IN_TRY;

    emitGenIG(ig);
}

/*****************************************************************************
 *
 *  Finish and save the current IG.
 */

emitter::insGroup *   emitter::emitSavIG(bool emitAdd)
{
    insGroup    *   ig;
    BYTE    *       id;

    size_t          sz;
    size_t          gs;

    assert(emitLastIns || emitCurIG == emitPrologIG);
    assert(emitCurIGfreeNext <= emitCurIGfreeEndp);

#if SCHEDULER
    if (emitComp->opts.compSchedCode) scInsNonSched();
#endif

    /* Get hold of the IG descriptor */

    ig = emitCurIG; assert(ig);

    /* Compute how much code we've generated */

    sz = emitCurIGfreeNext - emitCurIGfreeBase;

    /* Compute the total size we need to allocate */

    gs = roundUp(sz);

#if TRACK_GC_REFS

    if  (!(ig->igFlags & IGF_EMIT_ADD))
    {
        /* Is the initial set of live GC vars different from the previous one? */

        if (emitPrevGCrefVars != emitInitGCrefVars)
        {
            /* Remember that we will have a new set of live GC variables */

            ig->igFlags |= IGF_GC_VARS;

#if EMITTER_STATS
            emitTotalIGptrs++;
#endif

            /* We'll allocate extra space to record the liveset */

            gs += sizeof(VARSET_TP);
        }

        /* Is the initial set of live Byref regs different from the previous one? */

        /* @TODO : ISSUE - Can we avoid always storing the byref regs. If so,
           how come the emitXXXXGCrefVars stuff works ?
           The problem was that during codegen, emitThisXXrefRegs is the
           last reported lifetime, not the acutal one as we dont track
           the GC behavior of each instr we add. However during the
           emitting phase, emitThisXXrefRegs is accurate after every
           instruction as we track the GC behavior of each instr
         */

//      if (emitPrevByrefRegs != emitInitByrefRegs)
        {
            /* Remember that we will have a new set of live GC variables */

            ig->igFlags |= IGF_BYREF_REGS;

            /* We'll allocate extra space (DWORD aligned) to record the GC regs */

            gs += sizeof(int);
        }
    }

#endif

    /* Did we store the instructions in the local buffer? */

#if USE_LCL_EMIT_BUFF
    if  (emitLclBuffDst)
    {
        /* We can leave the instructions where we've stored them */

        id = emitCurIGfreeBase;

        if  (ig->igFlags & IGF_GC_VARS)
            id -= sizeof(VARSET_TP);

        if (ig->igFlags & IGF_BYREF_REGS)
            id -= sizeof(unsigned);

#if EMITTER_STATS
        emitTotMemAlloc += gs;
        emitLclMemAlloc += gs;
#endif

        /* Can we give back any unused space at the end of the buffer? */

        if  (emitCurIGfreeEndp == emitLclBuffNxt &&
             emitCurIGfreeNext != emitLclBuffEnd)
        {
            emitLclBuffNxt = (BYTE*)roundUp((int)emitCurIGfreeNext);
        }

//      printf("Remaining bytes in local buffer: %u\n", emitLclBuffEnd - emitLclBuffNxt);
    }
    else
#endif
    {
        /* Allocate space for the instructions and optional liveset */

        id = (BYTE*)emitGetMem(gs);
    }

#if TRACK_GC_REFS

    /* Do we need to store the byref regs */

    if (ig->igFlags & IGF_BYREF_REGS)
    {
        /* Record the byref regs in front the of the instructions */

        *castto(id, unsigned *)++ = emitInitByrefRegs;
    }

    /* Do we need to store the liveset? */

    if  (ig->igFlags & IGF_GC_VARS)
    {
        /* Record the liveset in front the of the instructions */

        *castto(id, VARSET_TP *)++ = emitInitGCrefVars;
    }

#endif

    /* Record the collected instructions */

    ig->igData = id;

    if  (id != emitCurIGfreeBase)
        memcpy(id, emitCurIGfreeBase, sz);

    /* Record how many instructions and bytes of code this group contains */

    ig->igInsCnt       = emitCurIGinsCnt;
    ig->igSize         = emitCurIGsize;
    emitCurCodeOffset += emitCurIGsize;

#if EMITTER_STATS
    emitTotalIGicnt   += emitCurIGinsCnt;
    emitTotalIGsize   += sz;
    emitSizeMethod    += sz;
#endif

//  printf("Group [%08X]%3u has %2u instructions (%4u bytes at %08X)\n", ig, ig->igNum, emitCurIGinsCnt, sz, id);

#if TRACK_GC_REFS

    /* Record the live GC register set - if and only if it is not an emiter added block */

    if  (!(ig->igFlags & IGF_EMIT_ADD))
    {
//      ig->igFlags     |= IGF_GC_REGS;
        ig->igGCregs     = emitInitGCrefRegs;
    }

    if (!emitAdd)
    {
        /* Update the previous recorded live GC ref sets, but not if
           if we are starting an "overflow" buffer
         */

        emitPrevGCrefVars = emitThisGCrefVars;
        emitPrevGCrefRegs = emitThisGCrefRegs;
        emitPrevByrefRegs = emitThisByrefRegs;
    }

#endif

#ifdef  DEBUG
    if  (dspCode)
    {
        printf("\n      G_%02u_%02u:", Compiler::s_compMethodsCount, ig->igNum);
        if (verbose) printf("        ; offs=%06XH", ig->igOffs);
        printf("\n");
    }
#endif

    /* Did we have any jumps in this group? */

    if  (emitCurIGjmpList)
    {
        instrDescJmp  * list = NULL;
        instrDescJmp  * last = NULL;

        /* Move jumps to the global list, update their 'next' links */

        do
        {
            size_t          of;
            instrDescJmp   *oj;
            instrDescJmp   *nj;

            /* Grab the jump and remove it from the list */

            oj = emitCurIGjmpList; emitCurIGjmpList = oj->idjNext;

            /* Figure out the address of where the jump got copied */

            of = (BYTE*)oj - emitCurIGfreeBase;
            nj = (instrDescJmp*)(ig->igData + of);

#if USE_LCL_EMIT_BUFF
            assert((oj == nj) == emitLclBuffDst);
#endif

//          printf("Jump moved from %08X to %08X\n", oj, nj);
//          printf("jmp [%08X] at %08X + %03u\n", nj, ig, nj->idjOffs);

            assert(nj->idjIG   == ig);
            assert(nj->idIns   == oj->idIns);
            assert(nj->idjNext == oj->idjNext);

            /* Make sure the jumps are correctly ordered */

            assert(last == NULL || last->idjOffs > nj->idjOffs);

            /* Append the new jump to the list */

            nj->idjNext = list;
                          list = nj;

            if  (!last)
                last = nj;
        }
        while (emitCurIGjmpList);

        /* Append the jump(s) from this IG to the global list */

        if  (emitJumpList)
            emitJumpLast->idjNext = list;
        else
            emitJumpList          = list;

        last->idjNext = NULL;
        emitJumpLast  = last;
    }

    /* Record any literal pool entries within the IG as needed */

    emitRecIGlitPoolRefs(ig);

#if TGT_SH3

    /* Remember whether the group's end is reachable */

    if  (emitLastIns)
    {
        switch (emitLastIns->idIns)
        {
        case INS_bra:
        case INS_rts:
        case INS_braf:
            ig->igFlags |= IGF_END_NOREACH;
            break;
        }
    }

#endif

#if TGT_x86

    /* Did we have any epilogs in this group? */

    if  (emitCurIGEpiList)
    {
        /* Move epilogs to the global list, update their 'next' links */

        do
        {
            size_t          offs;
            instrDescCns *  epin;

            /* Figure out the address of where the epilog got copied */

            offs = (BYTE*)emitCurIGEpiList - (BYTE*)emitCurIGfreeBase;
            epin = (instrDescCns*)(ig->igData + offs);

            assert(epin->idIns               == emitCurIGEpiList->idIns);
            assert(epin->idAddr.iiaNxtEpilog == emitCurIGEpiList->idAddr.iiaNxtEpilog);

            /* Append the new epilog to the per-method list */

            epin->idAddr.iiaNxtEpilog = 0;

            if  (emitEpilogList)
                emitEpilogLast->idAddr.iiaNxtEpilog = epin;
            else
                emitEpilogList                      = epin;

            emitEpilogLast = epin;

            /* Move on to the next epilog */

            emitCurIGEpiList = emitCurIGEpiList->idAddr.iiaNxtEpilog;
        }
        while (emitCurIGEpiList);
    }

#else

    /* For now we don't use epilog instructions for RISC */

    assert(emitCurIGEpiList == NULL);

#endif

    /* The last instruction field is no longer valid */

    emitLastIns = NULL;

    return  ig;
}

/*****************************************************************************
 *
 *  Save the current IG and start a new one.
 */

#ifndef BIRCH_SP2
 inline
#endif
void                emitter::emitNxtIG(bool emitAdd)
{
    /* Right now we don't allow multi-IG prologs */

    assert(emitCurIG != emitPrologIG);

    /* First save the current group */

    emitSavIG(emitAdd);

    /* Update the GC live sets for the group's start
     * Do it only if not an emiter added block */

#if TRACK_GC_REFS

    if  (!emitAdd)
    {
        emitInitGCrefVars = emitThisGCrefVars;
        emitInitGCrefRegs = emitThisGCrefRegs;
        emitInitByrefRegs = emitThisByrefRegs;
    }

#endif

    /* Start generating the new group */

    emitNewIG();

    /* If this is an emiter added block, flag it */

    if (emitAdd)
        emitCurIG->igFlags |= IGF_EMIT_ADD;

}

/*****************************************************************************
 *
 *  Start generating code to be scheduled; called once per method.
 */

void                emitter::emitBegFN(bool EBPframe, size_t lclSize, size_t maxTmpSize)
{
    insGroup    *   ig;

    /* Assume we won't need the temp instruction buffer */

    emitIGbuffAddr = NULL;
    emitIGbuffSize = 0;

#if USE_LCL_EMIT_BUFF

    assert(emitCrScInit);

    /* Enter the critical section guarding the "busy" flag */

    EnterCriticalSection(&emitCritSect);

    /* If the local buffer is available, grab it */

    if  (emitCrScBusy)
    {
        emitLclBuffNxt =
        emitLclBuffEnd = NULL;

        emitCrScUsed   = false;
    }
    else
    {
        emitLclBuffNxt = emitLclBuff;
        emitLclBuffEnd = emitLclBuff + sizeof(emitLclBuff);

        emitCrScUsed   =
        emitCrScBusy   = true;
    }

    /* Leave the critical section guarding the "busy" flag */

    LeaveCriticalSection(&emitCritSect);

#endif

    /* Record stack frame info (the temp size is just an estimate) */

    emitEBPframe        = EBPframe;
    emitLclSize         = lclSize;
    emitMaxTmpSize      = maxTmpSize;

    /* We have no epilogs yet */

    emitEpilogSize      = 0;
    emitExitSeqSize     = 0;
    emitEpilogCnt       = 0;
    emitHasHandler      = false;
    emitEpilog1st       = NULL;
#ifdef  DEBUG
    emitHaveEpilog      = false;
#endif
    emitEpilogList      =
    emitEpilogLast      = NULL;
    emitCurIGEpiList    = NULL;

    /* We don't have any jumps */

    emitJumpList        =
    emitJumpLast        = NULL;
    emitCurIGjmpList    = NULL;

#if TGT_x86 || SCHEDULER
    emitFwdJumps        = false;
#endif

#if TGT_RISC
    emitIndJumps        = false;
#if SCHEDULER
    emitIGmoved         = false;
#endif
#endif

    /* We have not recorded any live sets */

#if TRACK_GC_REFS

    emitInitGCrefVars   =
    emitPrevGCrefVars   = 0;
    emitInitGCrefRegs   =
    emitPrevGCrefRegs   = 0;
    emitInitByrefRegs   =
    emitPrevByrefRegs   = 0;

#endif

    /* Assume there will be no GC ref variables */

    emitGCrFrameOffsMin =
    emitGCrFrameOffsMax =
    emitGCrFrameOffsCnt = 0;
#ifdef  DEBUG
    emitGCrFrameLiveTab = NULL;
#endif

    /* We have no groups / code at this point */

    emitIGlist          =
    emitIGlast          = NULL;

    emitCurCodeOffset   = 0;
#ifdef  DEBUG
    emitTotalCodeSize   = 0;
#endif
#if     SCHEDULER
    emitMaxIGscdCnt     = 0;
#endif

#if     EMITTER_STATS
    emitTotalIGmcnt++;
    emitSizeMethod     = 0;
#endif

#ifdef  DEBUG
    emitInsCount        = 0;
#endif

#if TRACK_GC_REFS

    /* The stack is empty now */

    emitCurStackLvl     = 0;

#if EMIT_TRACK_STACK_DEPTH
    emitMaxStackDepth   = 0;
    emitCntStackDepth   = sizeof(int);
#endif

#endif

    /* We don't have any line# info just yet */

#ifdef  DEBUG
    emitBaseLineNo      =
    emitThisLineNo      =
    emitLastLineNo      = 0;
#endif

    /* No data sections have been created */

    emitDataDscCur      = 0;
    emitDataSecCur      = 0;

    memset(&emitConsDsc, 0, sizeof(emitConsDsc));
    memset(&emitDataDsc, 0, sizeof(emitDataDsc));

#if EMIT_USE_LIT_POOLS

    /* We haven't used any literal pool entries */

    emitEstLPwords      = 0;
    emitEstLPlongs      = 0;
    emitEstLPaddrs      = 0;

#ifdef  DEBUG
    emitLitPoolList     =
    emitLitPoolLast     = NULL;       // to prevent trouble in emitDispIGlist()
#endif

    emitLPRlist         =
    emitLPRlast         =
    emitLPRlistIG       = NULL;

#if SMALL_DIRECT_CALLS
    emitTotDCcount      = 0;
#endif

#endif

#if     TGT_RISC

    /* Don't have any indirect/table jumps */

    emitIndJumps        = false;
#if defined(DEBUG) && !defined(NOT_JITC)
    emitTmpJmpCnt       = 0;
#endif

    /* The following is used to display instructions with extra info */

#ifdef  DEBUG
    emitDispInsExtra    = false;
#endif

#endif

    /* Create the first IG, it will be used for the prolog */

    emitNxtIGnum        = 1;

    emitPrologIG        =
    emitIGlist          =
    emitIGlast          = ig = emitAllocIG();

    emitLastIns         = NULL;

    ig->igPrev          =
    ig->igNext          = NULL;

    /* Append another group, to start generating the method body */

    emitNewIG();
}

/*****************************************************************************
 *
 *  Done generating code to be scheduled; called once per method.
 */

void                emitter::emitEndFN()
{

#if USE_LCL_EMIT_BUFF

    /* Release the local buffer if we were using it */

    if  (emitCrScUsed)
    {
        emitCrScUsed =
        emitCrScBusy = false;
    }

#endif

}

/*****************************************************************************
 *
 *  Given a block cookie and an code position, return the actual code offset;
 *  this can only be called at the end of code generation.
 */

size_t              emitter::emitCodeOffset(void *blockPtr, unsigned codePos)
{
    insGroup    *   ig;

    unsigned        of;
    unsigned        no = emitGetInsNumFromCodePos(codePos);

    /* Make sure we weren't passed some kind of a garbage thing */

    ig = (insGroup*)blockPtr;
#ifdef DEBUG
    assert(ig && ig->igSelf == ig);
#endif

    /* The first and last offsets are always easy */

    if      (no == 0)
    {
        of = 0;
    }
    else if (no == ig->igInsCnt)
    {
        of = ig->igSize;
    }
    else if (ig->igFlags & IGF_UPD_ISZ)
    {
        /*
            Some instruction sizes have changed, so we'll have to figure
            out the instruction offset "the hard way".
         */

        of = emitFindOffset(ig, no);
    }
    else
    {
        /* All instructions correctly predicted, the offset stays the same */

        of = emitGetInsOfsFromCodePos(codePos);

//      printf("[IG=%02u;ID=%03u;OF=%04X] <= %08X\n", ig->igNum, emitGetInsNumFromCodePos(codePos), of, codePos);

        /* Make sure the offset estimate is accurate */

        assert(of == emitFindOffset(ig, emitGetInsNumFromCodePos(codePos)));
    }

    return  ig->igOffs + of;
}

/*****************************************************************************
 *
 *  The following series of methods allocates instruction descriptors.
 */

void        *       emitter::emitAllocInstr(size_t sz, emitAttr opsz)
{
    instrDesc * id;

#ifdef  DEBUG
#ifndef NOT_JITC

    /* Use -n:Txxx to stop at instruction xxx when debugging cmdline JIT */

    if  (emitInsCount+1 == CGknob) BreakIfDebuggerPresent();

#endif
#endif

    /* Make sure we have enough space for the new instruction */

    if  (emitCurIGfreeNext + sz >= emitCurIGfreeEndp)
        emitNxtIG(true);

    /* Grab the space for the instruction */

    emitLastIns = id = (instrDesc*)emitCurIGfreeNext;
                                   emitCurIGfreeNext += sz;

    /*
        The following is a bit subtle - we need to clear the various
        bitfields in the descriptor so that they are initialized to
        0, but there is no great way to do that as one is not allowed
        to get the offset of a bitfield. So, instead we simply clear
        the area defined by the ID_CLEARx_xxx macros (the second one
        conditionally, since not all descriptor contain it).

        In debug mode the layout of an instruction descriptor is very
        different, so to keep things simple we simply clear the whole
        thing via memset.
      */

#ifdef  DEBUG
    memset(id, 0, sz);
#endif

     /*
        Check to make sure the first area is present and its size is
        what we expect (an int), and then clear it.
      */

    assert(ID_CLEAR1_SIZE + ID_CLEAR1_OFFS <= sz);
    assert(ID_CLEAR1_SIZE == sizeof(int));

    *(int*)((BYTE*)id + ID_CLEAR1_OFFS) = 0;

    /* Is the second area to be cleared actually present? */

    if  (sz > ID_CLEAR2_OFFS)
    {
        /* Make sure our belief about the size of the area is correct */

        assert(ID_CLEAR2_SIZE == sizeof(int));

        /* Make sure the entire area is present */

        assert(ID_CLEAR2_SIZE + ID_CLEAR2_OFFS <= sz);

        /* Everything looks fine, let's clear it */

        *(int*)((BYTE*)id + ID_CLEAR2_OFFS) = 0;
    }

    /* In debug mode we clear/set some additional fields */

#ifdef  DEBUG

    id->idNum       = ++emitInsCount;
#if     TGT_x86
    id->idCodeSize  = 0;
#endif
    id->idSize      = sz;
    id->idMemCookie = 0;
    id->idClsCookie = 0;
    id->idSrcLineNo = emitThisLineNo;

#endif

#if     TRACK_GC_REFS

    /* Store the size and handle the two special values
       that indicate GCref and ByRef */

    if       (EA_IS_GCREF(opsz))
    {
        /* A special value indicates a GCref pointer value */

        id->idGCref  = GCT_GCREF;
        id->idOpSize = emitEncodeSize(EA_4BYTE);
    }
    else if  (EA_IS_BYREF(opsz))
    {
        /* A special value indicates a Byref pointer value */

        id->idGCref  = GCT_BYREF;
        id->idOpSize = emitEncodeSize(EA_4BYTE);
    }
    else
    {
        id->idGCref  = GCT_NONE;
        id->idOpSize = emitEncodeSize(EA_SIZE(opsz));
    }

#else

        id->idOpSize = emitEncodeSize(EA_SIZE(opsz));

#endif

#if TGT_x86 && RELOC_SUPPORT

    if       (EA_IS_DSP_RELOC(opsz) && emitComp->opts.compReloc)
    {
        /* Mark idInfo.idDspReloc to remember that the               */
        /* address mode has a displacement that is relocatable       */
        id->idInfo.idDspReloc  = 1;
    }

    if       (EA_IS_CNS_RELOC(opsz) && emitComp->opts.compReloc)
    {
        /* Mark idInfo.idCnsReloc to remember that the               */
        /* instruction has an immediate constant that is relocatable */
        id->idInfo.idCnsReloc  = 1;
    }

#endif


#if     EMITTER_STATS
    emitTotalInsCnt++;
#endif

#if EMITTER_STATS_RLS
    emitTotIDcount += 1;
    emitTotIDsize  += sz;
#endif

#ifdef  TRANSLATE_PDB
    // set id->idilStart to the IL offset of the instruction that generated the id
    SetIDSource( id );
#endif

    /* Update the instruction count */

    emitCurIGinsCnt++;

    return  id;
}

/*****************************************************************************
 *
 *  Make sure the code offsets of all instruction groups look reasonable.
 */

#ifdef  DEBUG

void                emitter::emitCheckIGoffsets()
{
    insGroup    *   tempIG;
    size_t          offsIG;

    for (tempIG = emitIGlist, offsIG = 0;
         tempIG;
         tempIG = tempIG->igNext)
    {
        if  (tempIG->igOffs != offsIG)
        {
            printf("Block #%u has offset %08X, expected %08X\n", tempIG->igNum,
                                                                 tempIG->igOffs,
                                                                 offsIG);
            assert(!"bad block offset");
        }

        /* Make sure the code offset looks reasonably aligned */

#if TGT_RISC
        if  (tempIG->igOffs & (INSTRUCTION_SIZE-1))
        {
            printf("Block #%u has mis-aligned offset %08X\n", tempIG->igNum,
                                                              tempIG->igOffs);
            assert(!"mis-aligned block offset");
        }
#endif

        offsIG += tempIG->igSize;
    }

    if  (emitTotalCodeSize && emitTotalCodeSize != offsIG)
    {
        printf("Total code size is %08X, expected %08X\n", emitTotalCodeSize,
                                                           offsIG);

        assert(!"bad total code size");
    }
}

#else

#define             emitCheckIGoffsets()

#endif

/*****************************************************************************
 *
 *  Begin generating a method prolog.
 */

void                emitter::emitBegProlog()
{

#if EMIT_TRACK_STACK_DEPTH

    /* Don't measure stack depth inside the prolog, it's misleading */

#if TGT_x86
    emitCntStackDepth = 0;
#endif

    assert(emitCurStackLvl == 0);

#endif

    /* Save the current IG if it's non-empty */

    if  (emitCurIGnonEmpty())
        emitSavIG();

    /* Switch to the pre-allocated prolog IG */

    emitGenIG(emitPrologIG, 32 * sizeof(instrDesc));

    /* Nothing is live on entry to the prolog */

#if TRACK_GC_REFS

    emitInitGCrefVars   =
    emitPrevGCrefVars   = 0;
    emitInitGCrefRegs   =
    emitPrevGCrefRegs   = 0;
    emitInitByrefRegs   =
    emitPrevByrefRegs   = 0;

#endif

}

/*****************************************************************************
 *
 *  Return the code offset of the current location in the prolog.
 */

size_t              emitter::emitSetProlog()
{
    /* For now only allow a single prolog ins group */

    assert(emitPrologIG);
    assert(emitPrologIG == emitCurIG);

    return  emitCurIGsize;
}

/*****************************************************************************
 *
 *  Finish generating a method prolog.
 */

void                emitter::emitEndProlog()
{
    size_t          prolSz;

    insGroup    *   tempIG;

    /* Save the prolog IG if non-empty or if only one block */

    if  (emitCurIGnonEmpty() || emitCurIG == emitPrologIG)
        emitSavIG();

    /* Reset the stack depth values */

#if EMIT_TRACK_STACK_DEPTH
    emitCurStackLvl   = 0;
    emitCntStackDepth = sizeof(int);
#endif

    /* Compute the size of the prolog */

    for (tempIG = emitPrologIG, prolSz  = 0;
         emitIGisInProlog(tempIG);
         tempIG = tempIG->igNext)
    {
        prolSz += tempIG->igSize;
    }

    emitPrologSize = prolSz;

    /* Update the offsets of all the blocks */

    emitRecomputeIGoffsets();

    /* We should not generate any more code after this */

    emitCurIG = NULL;
}

/*****************************************************************************
 *
 *  Begin generating an epilog.
 */

void                emitter::emitBegEpilog()
{
    /* Keep track of how many epilogs we have */

    emitEpilogCnt++;

#if TGT_x86

    size_t          sz;
    instrDescCns *  id;

#if EMIT_TRACK_STACK_DEPTH

    assert(emitCurStackLvl == 0);

    /* Don't measure stack depth inside the epilog, it's misleading */

    emitCntStackDepth = 0;

#endif

    /* Make sure the current IG has space for a few more instructions */

    if  (emitCurIGfreeNext + 5*sizeof(*id) > emitCurIGfreeEndp)
    {
        /* Get a fresh new group */

        emitNxtIG(true);
    }

    /* We can now allocate the epilog "instruction" */

    id = emitAllocInstrCns(EA_1BYTE);

    /* Append the epilog "instruction" to the epilog list */

    id->idAddr.iiaNxtEpilog = emitCurIGEpiList;
                              emitCurIGEpiList = id;

    /* Conservatively estimate the amount of code that will be added */

    sz             = MAX_EPILOG_SIZE;

    id->idInsFmt   = IF_EPILOG;
    id->idIns      = INS_nop;
    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize   += sz;

#endif

    /* Remember size so that we can compute total epilog size */

    emitExitSeqSize  = emitCurIGsize;

    /* Mark this group as being an epilog */

    emitCurIG->igFlags |= IGF_EPILOG;

    /* Remember the first epilog group */

    if  (!emitEpilog1st)
        emitEpilog1st = emitCurIG;
}

/*****************************************************************************
 *
 *  Finish generating an epilog.
 */

void                emitter::emitEndEpilog(bool last)
{
    /* Compute total epilog size */

    emitExitSeqSize = emitCurIGsize - emitExitSeqSize;

#if EMIT_TRACK_STACK_DEPTH

    emitCurStackLvl   = 0;
    emitCntStackDepth = sizeof(int);

#endif

#if TGT_RISC
    assert(last);   // for now only allow one epilog for RISC
#endif

    /* Finish the current instruction group */

    assert(emitCurIGnonEmpty()); emitSavIG();

    /* The end of an epilog sequence is never reached */

#if TGT_RISC
    emitCurIG->igFlags |= IGF_END_NOREACH;
#endif

    /* Start a new IG if more code follows */

    if  (last)
    {
        emitCurIG = NULL;
    }
    else
        emitNewIG();
}

/*****************************************************************************
 *
 *  Return non-zero if the current method only has one epilog, which is
 *  at the very end of the method body.
 */

bool                emitter::emitHasEpilogEnd()
{
    if  (emitEpilogCnt == 1 && (emitIGlast->igFlags & IGF_EPILOG))
        return   true;
    else
        return  false;
}

/*****************************************************************************
 *
 *  The code generator tells us the range of GC ref locals through this
 *  method. Needless to say, locals and temps should be allocated so that
 *  the size of the range is as small as possible.
 */

void                emitter::emitSetFrameRangeGCRs(int offsLo, int offsHi)
{

#ifndef OPT_IL_JIT
#ifdef  DEBUG

    //  A total of    47254 methods compiled.
    //
    //  GC ref frame variable counts:
    //
    //      <=         0 ===>  43175 count ( 91% of total)
    //       1 ..      1 ===>   2367 count ( 96% of total)
    //       2 ..      2 ===>    887 count ( 98% of total)
    //       3 ..      5 ===>    579 count ( 99% of total)
    //       6 ..     10 ===>    141 count ( 99% of total)
    //      11 ..     20 ===>     40 count ( 99% of total)
    //      21 ..     50 ===>     42 count ( 99% of total)
    //      51 ..    128 ===>     15 count ( 99% of total)
    //     129 ..    256 ===>      4 count ( 99% of total)
    //     257 ..    512 ===>      4 count (100% of total)
    //     513 ..   1024 ===>      0 count (100% of total)

    if  (verbose)
    {
        printf("GC refs are at stack offsets ");

        if  (offsLo >= 0)
        {
            printf(" %04X ..  %04X",  offsLo,  offsHi);
            assert(offsHi >= 0);
        }
        else
        {
            printf("-%04X .. -%04X", -offsLo, -offsHi);
            assert(offsHi <  0);
        }

        printf(" [count=%2u]\n", (offsHi-offsLo)/sizeof(void*) + 1);
    }

#endif
#endif

    emitGCrFrameOffsMin = offsLo;
    emitGCrFrameOffsMax = offsHi + sizeof(void*);
    emitGCrFrameOffsCnt = (offsHi-offsLo)/sizeof(void*) + 1;
}

/*****************************************************************************
 *
 *  The code generator tells us the range of local variables through this
 *  method.
 */

void                emitter::emitSetFrameRangeLcls(int offsLo, int offsHi)
{
}

/*****************************************************************************
 *
 *  The code generator tells us the range of used arguments through this
 *  method.
 */

void                emitter::emitSetFrameRangeArgs(int offsLo, int offsHi)
{
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Record a source line# as corresponding to the current code position.
 *  A negated line# indicates the "base" line# of the entire method (if
 *  called before any code is emitted) or the last line of a method (if
 *  called after all the code for the method has been generated).
 */

void                emitter::emitRecordLineNo(int lineno)
{
    if  (lineno < 0)
    {
        lineno = -lineno;

        if  (emitBaseLineNo)
            emitLastLineNo = lineno - 1;
        else
            emitBaseLineNo = lineno;
    }

    emitThisLineNo = lineno;
}

/*****************************************************************************/
#endif
/*****************************************************************************
 *
 *  A conversion table used to map an operand size value (in bytes) into its
 *  small encoding (0 through 3), and vice versa.
 */

BYTE                emitter::emitSizeEnc[] =
{
    0,      // 1
    1,      // 2
   -1,
    2,      // 4
   -1,
   -1,
   -1,
    3       // 8
};

BYTE                emitter::emitSizeDec[] =
{
    1,
    2,
    4,
    8
};

/*****************************************************************************
 *
 *  Allocate an instruction descriptor for an instruction that uses both
 *  a displacement and a constant.
 */

emitter::instrDesc *  emitter::emitNewInstrDspCns(emitAttr size, int dsp, int cns)
{
    if  (dsp == 0)
    {
        if  (cns >= ID_MIN_SMALL_CNS &&
             cns <= ID_MAX_SMALL_CNS)
        {
            instrDesc      *id = emitAllocInstr      (size);

            id->idInfo.idSmallCns = cns;

#if EMITTER_STATS
            emitSmallCnsCnt++;
            emitSmallCns[cns - ID_MIN_SMALL_CNS]++;
            emitSmallDspCnt++;
#endif

            return  id;
        }
        else
        {
            instrDescCns   *id = emitAllocInstrCns   (size);

            id->idInfo.idLargeCns = true;
            id->idcCnsVal  = cns;

#if EMITTER_STATS
            emitLargeCnsCnt++;
            emitSmallDspCnt++;
#endif

            return  id;
        }
    }
    else
    {
        if  (cns >= ID_MIN_SMALL_CNS &&
             cns <= ID_MAX_SMALL_CNS)
        {
            instrDescDsp   *id = emitAllocInstrDsp   (size);

            id->idInfo.idLargeDsp = true;
            id->iddDspVal  = dsp;

            id->idInfo.idSmallCns = cns;

#if EMITTER_STATS
            emitLargeDspCnt++;
            emitSmallCnsCnt++;
            emitSmallCns[cns - ID_MIN_SMALL_CNS]++;
#endif

            return  id;
        }
        else
        {
            instrDescDspCns*id = emitAllocInstrDspCns(size);

            id->idInfo.idLargeCns = true;
            id->iddcCnsVal = cns;

            id->idInfo.idLargeDsp = true;
            id->iddcDspVal = dsp;

#if EMITTER_STATS
            emitLargeDspCnt++;
            emitLargeCnsCnt++;
#endif

            return  id;
        }
    }
}

/*****************************************************************************
 *
 *  Returns true if calls to the given helper don't need to be recorded in
 *  the GC tables.
 */

bool                emitter::emitNoGChelper(unsigned IHX)
{
    // UNDONE: Make this faster (maybe via a simple table of bools?)

    switch (IHX)
    {
    case CPX_LONG_LSH:
    case CPX_LONG_RSH:
    case CPX_LONG_RSZ:

//  case CPX_LONG_MUL:
//  case CPX_LONG_DIV:
//  case CPX_LONG_MOD:
//  case CPX_LONG_UDIV:
//  case CPX_LONG_UMOD:

    case CPX_MATH_POW:

    case CPX_GC_REF_ASGN_EAX:
    case CPX_GC_REF_ASGN_ECX:
    case CPX_GC_REF_ASGN_EBX:
    case CPX_GC_REF_ASGN_EBP:
    case CPX_GC_REF_ASGN_ESI:
    case CPX_GC_REF_ASGN_EDI:

    case CPX_GC_REF_CHK_ASGN_EAX:
    case CPX_GC_REF_CHK_ASGN_ECX:
    case CPX_GC_REF_CHK_ASGN_EBX:
    case CPX_GC_REF_CHK_ASGN_EBP:
    case CPX_GC_REF_CHK_ASGN_ESI:
    case CPX_GC_REF_CHK_ASGN_EDI:

    case CPX_BYREF_ASGN:

//  case CPX_RES_IFC:
//  case CPX_RES_IFC_TRUSTED:
//  case CPX_RES_IFC_TRUSTED2:

        return  true;
    }

    return  false;
}

/*****************************************************************************
 *
 *  Mark the current spot as having a label.
 */

void                emitter::emitAddLabel(void **labPtr)
{
    /* Create a new IG if the current one is non-empty */

    if  (emitCurIGnonEmpty())
        emitNxtIG();

    /* Mark the IG as having a label */

    emitCurIG->igFlags |= IGF_HAS_LABEL;

    /* Give the caller a ref to the corresponding IG */

    *labPtr = emitCurIG;
}

#if TRACK_GC_REFS

void                emitter::emitAddLabel(void **   labPtr,
                                          VARSET_TP GCvars,
                                          unsigned  gcrefRegs,
                                          unsigned  byrefRegs)
{
    emitAddLabel(labPtr);

#if TGT_RISC

    #pragma message("NOTE: GC ref tracking disabled for RISC targets")

    GCvars      = 0;
    gcrefRegs   = 0;
    byrefRegs   = 0;

#endif

#ifndef OPT_IL_JIT
#ifdef  DEBUG
    if  (verbose) printf("Label: GCvars=%016I64X , gcrefRegs=%04X\n byrefRegs=%04X",
                                 GCvars,           gcrefRegs,       byrefRegs);
#endif
#endif

    emitThisGCrefVars = emitInitGCrefVars = GCvars;
    emitThisGCrefRegs = emitInitGCrefRegs = gcrefRegs;
    emitThisByrefRegs = emitInitByrefRegs = byrefRegs;
}

#endif

/*****************************************************************************/
#ifdef  DEBUG
#if     TRACK_GC_REFS
/*****************************************************************************
 *
 *  Display a register set in a readable form.
 */

void                emitter::emitDispRegSet(unsigned regs, bool calleeOnly)
{
    unsigned        reg;
    bool            sp;

    for (reg = 0, sp = false; reg < SR_COUNT; reg++)
    {
        char            tmp[4];

        if  (calleeOnly && !(RBM_CALLEE_SAVED & emitRegMask((emitRegs)reg)))
            continue;

        if  (regs & emitRegMask((emitRegs)reg))
        {
            strcpy(tmp, emitRegName((emitRegs)reg));
        }
        else
        {
            if  (!calleeOnly)
                continue;

            strcpy(tmp, "   ");
        }

        if  (sp)
            printf(" ");
        else
            sp = true;

        printf(tmp);
    }
}

/*****************************************************************************
 *
 *  Display the current GC ref variable set in a readable form.
 */

void                emitter::emitDispVarSet()
{
    unsigned        vn;
    int             of;
    bool            sp = false;

    for (vn  = 0, of  = emitGCrFrameOffsMin;
         vn < emitGCrFrameOffsCnt;
         vn += 1, of += sizeof(void *))
    {
        if  (emitGCrFrameLiveTab[vn])
        {
            if  (sp)
                printf(" ");
            else
                sp = true;

#if TGT_x86
            printf("[%s", emitEBPframe ? "EBP" : "ESP");
#else
            assert(!"need non-x86 code");
#endif

            if      (of < 0)
                printf("-%02XH", -of);
            else if (of > 0)
                printf("+%02XH", +of);

            printf("]");
        }
    }
}

/*****************************************************************************/
#endif//TRACK_GC_REFS
#endif//DEBUG
/*****************************************************************************
 *
 *  Allocate an instruction descriptor for an indirect call.
 *
 *  We use two different descriptors to save space - the common case records
 *  no GC variables and has both a very small argument count and an address
 *  mode displacement; the much rarer (we hope) case records the current GC
 *  var set, the call scope, and an arbitrarily large argument count and
 *  address mode displacement.
 */

emitter::instrDesc  * emitter::emitNewInstrCallInd(int        argCnt,
#if TGT_x86
                                                   int        disp,
#endif
#if TRACK_GC_REFS

                                                   VARSET_TP  GCvars,
                                                   unsigned   byrefRegs,
#endif
                                                   int        retSizeIn)
{
    emitAttr  retSize = retSizeIn ? EA_ATTR(retSizeIn) : EA_4BYTE;

    /*
        Allocate a larger descriptor if any GC values need to be saved
        or if we have an absurd number of arguments or a large address
        mode displacement, or we have some byref registers
     */

#if TRACK_GC_REFS
    if  (GCvars    != 0)                 goto BIG;
    if  (byrefRegs != 0)                 goto BIG;
#endif

#if TGT_x86
    if  (disp < AM_DISP_MIN)             goto BIG;
    if  (disp > AM_DISP_MAX)             goto BIG;
    if  (argCnt < 0)                     goto BIG;  // caller pops arguments
#endif

    if  (argCnt > ID_MAX_SMALL_CNS)
    {
        instrDescCIGCA* id;

    BIG:

        id = emitAllocInstrCIGCA(retSize);

        id->idInfo.idLargeCall = true;

#if TRACK_GC_REFS
        id->idciGCvars         = GCvars;
        id->idciByrefRegs      = emitEncodeCallGCregs(byrefRegs);
#endif
        id->idciArgCnt         = argCnt;
#if TGT_x86
        id->idciDisp           = disp;
#endif

        return  id;
    }
    else
    {
        instrDesc     * id;

        id = emitNewInstrCns(retSize, argCnt);

        /* Make sure we didn't waste space unexpectedly */

        assert(id->idInfo.idLargeCns == false);

#if TGT_x86

        /* Store the displacement and make sure the value fit */

        id->idAddr.iiaAddrMode.amDisp  = disp;
 assert(id->idAddr.iiaAddrMode.amDisp == disp);

#endif

        return  id;
    }
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Return a string with the name of the given class field (blank string (not
 *  NULL) is returned when the name isn't available).
 */

const   char *      emitter::emitFldName(int mem, void *cls)
{
    if  (varNames)
    {
        const  char *   memberName;
        const  char *   className;

        static char     buff[1024];

        if  (!cls)
            cls = emitComp->info.compScopeHnd;

       memberName = emitComp->eeGetFieldName(emitComp->eeFindField(mem, (SCOPE_HANDLE) cls, 0), &className);

        sprintf(buff, "'<%s>.%s'", className, memberName);
        return  buff;
    }
    else
        return  "";
}

/*****************************************************************************
 *
 *  Return a string with the name of the given function (blank string (not
 *  NULL) is returned when the name isn't available).
 */

const   char *      emitter::emitFncName(METHOD_HANDLE methHnd)
{
    const  char *   memberName;
    const  char *   className;

    static char     buff[1024];

    memberName = emitComp->eeGetMethodName(methHnd, &className);

    sprintf(buff, "'<%s>.%s'", className, memberName);
    return  buff;
}

/*****************************************************************************/
#endif//DEBUG
/*****************************************************************************
 *
 *  Be very careful, some instruction descriptors are allocated as "tiny" and
 *  don't have some of the tail fields of instrDesc (in particular, "idInfo").
 */

BYTE                emitter::emitFmtToOps[] =
{
    #define IF_DEF(en, op1, op2) ID_OP_##op2,
    #include "emitfmts.h"
    #undef  IF_DEF
};

#ifdef  DEBUG
unsigned            emitter::emitFmtCount = sizeof(emitFmtToOps)/sizeof(emitFmtToOps[0]);
#endif

/*****************************************************************************
 *
 *  Display the current instruction group list.
 */

#ifdef  DEBUG

void                emitter::emitDispIGlist(bool verbose)
{
    insGroup    *   ig;
    insGroup    *   il;

#if EMIT_USE_LIT_POOLS
    litPool *       lp = emitLitPoolList;
#endif

    for (il = NULL, ig = emitIGlist;
                    ig;
         il = ig  , ig = ig->igNext)
    {
        printf("G_%02u_%02u:", Compiler::s_compMethodsCount, ig->igNum);
        printf("        ; offs=%06XH , size=%04XH\n", ig->igOffs, ig->igSize);

        assert(ig->igPrev == il);

        if  (verbose)
        {
            BYTE    *   ins = ig->igData;
            size_t      ofs = ig->igOffs;
            unsigned    cnt = ig->igInsCnt;

            if  (cnt)
            {
                printf("\n");

                do
                {
                    instrDesc * id = (instrDesc *)ins;

                    emitDispIns(id, false, true, false, ofs);

                    ins += emitSizeOfInsDsc(id);
                    ofs += emitInstCodeSz  (id);
                }
                while (--cnt);

                printf("\n");
            }
        }

#if EMIT_USE_LIT_POOLS
        if  (lp && lp->lpIG == ig)
        {
            printf("        LitPool [%2u/%2u words, %2u/%2u longs, %2u/%2u addrs] at 0x%X ptr:%X\n", lp->lpWordCnt,
                                                                       lp->lpWordMax,
                                                                       lp->lpLongCnt,
                                                                       lp->lpLongMax,
                                                                       lp->lpAddrCnt,
                                                                       lp->lpAddrMax,
                                                                       lp->lpOffs,
                                                                       lp);

            lp = lp->lpNext;
        }
#endif

    }

#if EMIT_USE_LIT_POOLS
    assert(lp == NULL);
#endif

}

#endif

/*****************************************************************************
 *
 *  Issue the given instruction. Basically, this is just a thin wrapper around
 *  emitOutputInstr() that does a few debug checks.
 */

size_t              emitter::emitIssue1Instr(insGroup  *ig,
                                             instrDesc *id, BYTE **dp)
{
    size_t          is;

#if MAX_BRANCH_DELAY_LEN || SMALL_DIRECT_CALLS
    if  (id->idIns == INS_ignore)
        return  emitSizeOfInsDsc(id);
#endif

#ifdef DEBUG
    if  (id->idSrcLineNo != emitLastSrcLine && !emitIGisInProlog(ig))
    {
        emitLastSrcLine = id->idSrcLineNo;
        if (disAsm && dspLines)
            emitComp->compDspSrcLinesByLineNum(emitLastSrcLine, false);
    }
#endif

    /* Record the beginning offset of the instruction */

    emitCurInsAdr = *dp;

    /* Issue the next instruction */

//  printf("[S=%02u] " , emitCurStackLvl);

    is = emitOutputInstr(ig, id, dp);

//  printf("[S=%02u]\n", emitCurStackLvl);

#if EMIT_TRACK_STACK_DEPTH && TRACK_GC_REFS

    /*
        If we're generating a full pointer map and the stack
        is empty, there better not be any "pending" argument
        push entries.
     */

    assert(emitFullGCinfo  == false ||
           emitCurStackLvl != 0     ||
           emitGcArgTrackCnt == 0);

#endif

#if TGT_x86
#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)

    /* Did the size of the instruction match our expectations? */

    size_t          csz = *dp - emitCurInsAdr;

    if  (csz != id->idCodeSize && id->idInsFmt != IF_EPILOG)
    {
#ifdef  DEBUG
#ifndef NOT_JITC
        printf("; WARNING: [%3u(%5s)] Estimated size = %d , actual size = %d\n",
            id->idNum, emitComp->genInsName(id->idIns), id->idCodeSize, csz);
//      BreakIfDebuggerPresent();
#endif
#endif
        /* It is fatal to under-estimate the instruction size */
        assert(csz <= emitInstCodeSz(id));

        /* The instruction size estimate wasn't accurate; remember this */

        ig->igFlags   |= IGF_UPD_ISZ;
        id->idCodeSize = csz;
    }

#endif
#endif

#ifdef  DEBUG

    /* Make sure the instruction descriptor size also matches our expectations */

    if  (is != emitSizeOfInsDsc(id))
    {
        printf("%s at %u: Expected size = %u , actual size = %u\n",
               emitIfName(id->idInsFmt), id->idNum, is, emitSizeOfInsDsc(id));
        assert(is == emitSizeOfInsDsc(id));
    }

#endif

    return  is;
}

/*****************************************************************************
 *
 *  Dont schedule across this boundary
 */

#if SCHEDULER

void            emitter::emitIns_SchedBoundary()
{
    // Why add a boundary if we arent scheduling in the first place ?

    assert(emitComp->opts.compSchedCode);

    /* Insert a pseudo-instruction to prevent scheduling across this */

    instrDesc * id  = emitNewInstrTiny(EA_1BYTE);
    id->idIns       = INS_noSched;
    id->idCodeSize  = 0;

    assert(scIsSchedulable(id->idIns) == false);
}

#endif

/*****************************************************************************
 *
 *  Update the offsets of all the instruction groups (note: please don't be
 *  lazy and call this routine frequently, it walks the list of instruction
 *  groups and thus it isn't cheap).
 */

void                emitter::emitRecomputeIGoffsets()
{
    size_t          offs;
    insGroup    *   list;

    for (list = emitIGlist, offs = 0;
         list;
         list = list->igNext)
    {
        list->igOffs = offs;
                       offs += list->igSize;
    }

    /* Update the total code size (but only if it's been set already) */

    if  (emitTotalCodeSize)
        emitTotalCodeSize = offs;

    /* Paranoia? You bet! */

    emitCheckIGoffsets();
}

/*****************************************************************************
 *
 *  Called at the end of code generation, this method creates the code, data
 *  and GC info blocks for the method.
 */

size_t              emitter::emitEndCodeGen(Compiler *comp,
                                            bool      contTrkPtrLcls,
                                            bool      fullyInt,
                                            bool      fullPtrMap,
                                            bool      returnsGCr,
                                            unsigned *prologSize,
                                            unsigned *epilogSize, void **codeAddr,
                                                                  void **consAddr,
                                                                  void **dataAddr)
{
    insGroup     *  ig;
    instrDescJmp *  jmp;

    size_t          minx;
    size_t          adjIG;
#if TGT_x86
    size_t          adjLJ;
#endif
    insGroup    *   lstIG;

    BYTE    *       consBlock;
    BYTE    *       dataBlock;
    BYTE    *       codeBlock;
    BYTE    *       cp;

#if EMIT_USE_LIT_POOLS
    litPool   *     curLP;
    insGroup  *     litIG;
#endif

//  if  (!emitIGbuffAddr) printf("Temp buffer never used\n");

#ifdef  DEBUG
    emitCodeBlock     = NULL;
    emitConsBlock     = NULL;
    emitDataBlock     = NULL;
    emitLastSrcLine   = 0;
#endif

#ifdef  DEBUG

    if  (disAsm)
    {
        const   char *  doing = "   Emit";

#if     SCHEDULER
        if  (emitComp->opts.compSchedCode) doing = "Schedul";
#endif

        printf("%sing %s interruptible method [%s ptr map] '", doing,
                                                               fullyInt   ? " fully"  : "partly" ,
                                                               fullPtrMap ?  "full"   : "part"    );
#ifdef  NOT_JITC
        printf("%s.", emitComp->info.compClassName);
#endif
        printf("%s'\n", emitComp->info.compMethodName);
    }

#endif

    /* Tell everyone whether we have fully interruptible code or not */

#if TRACK_GC_REFS
    emitFullyInt   = fullyInt;
    emitFullGCinfo = fullPtrMap;
#endif

#if EMITTER_STATS
      GCrefsTable.histoRec(emitGCrFrameOffsCnt, 1);
    emitSizeTable.histoRec(emitSizeMethod     , 1);
#if TRACK_GC_REFS
    stkDepthTable.histoRec(emitMaxStackDepth  , 1);
#endif
#endif

#if TRACK_GC_REFS

    /* Convert max. stack depth from # of bytes to # of entries */

    emitMaxStackDepth /= sizeof(int);

    /* Should we use the simple stack */

    if  (emitMaxStackDepth <= MAX_SIMPLE_STK_DEPTH && !emitFullGCinfo)
    {
        emitSimpleStkUsed         = true;
        emitSimpleStkMask         = 0;
        emitSimpleByrefStkMask    = 0;
    }
    else
    {
        /* We won't use the "simple" argument table */

        emitSimpleStkUsed = false;

        /* Allocate the argument tracking table */

        if  (emitMaxStackDepth <= sizeof(emitArgTrackLcl))
            emitArgTrackTab = (BYTE*)emitArgTrackLcl;
        else
            emitArgTrackTab = (BYTE*)emitGetMem(roundUp(emitMaxStackDepth));

        emitArgTrackTop     = emitArgTrackTab;
        emitGcArgTrackCnt   = 0;
    }

#endif

    emitCheckIGoffsets();

    /* The following is a "nop" if literal pools aren't being used */

    emitEstimateLitPools();

    assert(emitHasHandler == 0);  // We should no longer be inside a try region

#if TGT_x86

    /* Do we have any epilogs at all? */

    if  (emitEpilogCnt)
    {
        /* Update all of the epilogs with the actual epilog size */

        if  (emitEpilogSize != MAX_EPILOG_SIZE)
        {
            assert(emitEpilogSize < MAX_EPILOG_SIZE);

            int             sizeAdj = MAX_EPILOG_SIZE - emitEpilogSize;
            insGroup    *   tempIG  = emitIGlist;
            size_t          offsIG  = 0;

            /* Start with the first epilog group */

            tempIG = emitEpilog1st; assert(tempIG->igFlags & IGF_EPILOG);
            offsIG = tempIG->igOffs;

            do
            {
                /* Assign a (possibly updated) offset to the block */

                tempIG->igOffs = offsIG;

                /* If this is an epilog block, adjust its size */

                if  (tempIG->igFlags & IGF_EPILOG)
                    tempIG->igSize -= sizeAdj;

                /* Update the offset and move on to the next block */

                offsIG += tempIG->igSize;
                tempIG  = tempIG->igNext;
            }
            while (tempIG);

            /* Update the total code size */

            emitCurCodeOffset = offsIG;

            emitCheckIGoffsets();
        }
    }
    else
    {
        /* No epilogs, make sure the epilog size is set to 0 */

        emitEpilogSize = emitExitSeqSize = 0;
    }

#endif

    /* The last code offset is the (estimated) total size of the method */

    emitTotalCodeSize = emitCurCodeOffset;

    /* Also return the size of the prolog/epilog to the caller */

    *prologSize       = emitPrologSize;
    *epilogSize       = emitEpilogSize + emitExitSeqSize;

#ifdef  DEBUG

    if  (verbose & 0)
    {
        printf("\nInstruction list before jump distance binding:\n\n");
        emitDispIGlist(true);
    }

#endif

    int jmp_iteration = 0;

AGAIN:

    emitCheckIGoffsets();

    /*
        In the following loop we convert all jump targets from "BasicBlock *"
        to "insGroup *" values. We also estimate which jumps will be short.
     */

#if     TGT_x86

#ifdef  DEBUG
    insGroup     *  lastIG = NULL;
    instrDescJmp *  lastLJ = NULL;
#endif

    lstIG = NULL;

    adjLJ = 0;

#else

    instrDescJmp *  lastLJ = NULL;

#endif

    adjIG = 0;

    for (jmp = emitJumpList, minx = 99999;
         jmp;
         jmp = jmp->idjNext)
    {
        insGroup    *   jmpIG;
        insGroup    *   tgt;

        size_t          jsz;

        size_t          ssz;            // small  jump size
        int             nsd;            // small  jump max. neg distance
        int             psd;            // small  jump max. pos distance

#if     TGT_SH3
        size_t          msz;            // middle jump size
        int             nmd;            // middle jump max. neg distance
        int             pmd;            // middle jump max. pos distance
#endif

        size_t          lsz;            // large  jump size

        int             extra;
        size_t          srcOffs;
        size_t          dstOffs;
        int             jmpDist;
        size_t          oldSize;
        size_t          sizeDif;

#if     TGT_RISC

        instrDescJmp *  pji = lastLJ; lastLJ = jmp;

        /* Ignore indirect jumps for now */

        if  (jmp->idInsFmt == IF_JMP_TAB)
            continue;

#if     SCHEDULER
        assert(emitComp->opts.compSchedCode ||
               jmp->idjAddBD == (unsigned)Compiler::instBranchDelay(jmp->idIns));
#else
#ifdef DEBUG
        assert(jmp_iteration ||
               jmp->idjAddBD == (unsigned)Compiler::instBranchDelay(jmp->idIns));
#endif
#endif

#endif

#if TGT_MIPSFP
        assert( (jmp->idInsFmt == IF_LABEL) ||
                (jmp->idInsFmt == IF_JR_R)  || (jmp->idInsFmt == IF_JR)  ||
                (jmp->idInsFmt == IF_RR_O)  || (jmp->idInsFmt == IF_R_O) ||
                (jmp->idInsFmt == IF_O));

#elif TGT_MIPS32
        assert( (jmp->idInsFmt == IF_LABEL) ||
                (jmp->idInsFmt == IF_JR_R)  || (jmp->idInsFmt == IF_JR) ||
                (jmp->idInsFmt == IF_RR_O)  || (jmp->idInsFmt == IF_R_O));
#else
        assert(jmp->idInsFmt == IF_LABEL);
#endif

        /* Figure out the smallest size we can end up with */

        if  (emitIsCondJump(jmp))
        {
            ssz = JCC_SIZE_SMALL;
            nsd = JCC_DIST_SMALL_MAX_NEG;
            psd = JCC_DIST_SMALL_MAX_POS;

#if     TGT_SH3
            msz = JCC_SIZE_MIDDL;
            nmd = JCC_DIST_MIDDL_MAX_NEG;
            pmd = JCC_DIST_MIDDL_MAX_POS;
#endif

            lsz = JCC_SIZE_LARGE;
        }
        else
        {
            ssz = JMP_SIZE_SMALL;
            nsd = JMP_DIST_SMALL_MAX_NEG;
            psd = JMP_DIST_SMALL_MAX_POS;

#if     TGT_SH3
            msz = JMP_SIZE_MIDDL;
            nmd = JMP_DIST_MIDDL_MAX_NEG;
            pmd = JMP_DIST_MIDDL_MAX_POS;
#endif

            lsz = JMP_SIZE_LARGE;
        }

        /* Make sure the jumps are properly ordered */

#ifdef  DEBUG
#if     TGT_x86
        assert(lastLJ == NULL || lastIG != jmp->idjIG ||
               lastLJ->idjOffs < jmp->idjOffs);
        lastLJ = (lastIG == jmp->idjIG) ? jmp : NULL;

        assert(lastIG == NULL ||
               lastIG->igNum   <= jmp->idjIG->igNum);
        lastIG = jmp->idjIG;
#endif
#endif

        /* Get hold of the current jump size */

        jsz = oldSize = emitSizeOfJump(jmp);

        /* Get the group the jump is in */

        jmpIG = jmp->idjIG;

#if     TGT_x86

        /* Are we in a group different from the previous jump? */

        if  (lstIG != jmpIG)
        {
            /* Were there any jumps before this one? */

            if  (lstIG)
            {
                /* Adjust the offsets of the intervening blocks */

                do
                {
                    lstIG = lstIG->igNext; assert(lstIG);
//                  printf("Adjusted offset of block %02u from %04X to %04X\n", lstIG->igNum, lstIG->igOffs, lstIG->igOffs - adjIG);
                    lstIG->igOffs -= adjIG;
                }
                while (lstIG != jmpIG);
            }

            /* We've got the first jump in a new group */

            adjLJ = 0;
            lstIG = jmpIG;
        }

        /* Apply any local size adjustment to the jump's relative offset */

        jmp->idjOffs -= adjLJ;

#endif

        // done if this is a jump via register, size does not change

#if     TGT_MIPS32
        if (IF_JR_R == jmp->idInsFmt || IF_JR == jmp->idInsFmt)
        {
            jsz = INSTRUCTION_SIZE;
            goto CONSIDER_DELAY_SLOT;
        }
#endif

        /* Have we bound this jump's target already? */

        if  (jmp->idInfo.idBound)
        {
            /* Does the jump already have the smallest size? */

            if  (jmp->idjShort)
            {
#if     TGT_RISC
                assert((emitSizeOfJump(jmp) == ssz) || jmp->idjAddBD);
#else
                assert(emitSizeOfJump(jmp) == ssz);
#endif
                continue;
            }

            tgt = jmp->idAddr.iiaIGlabel;
        }
        else
        {
            /* First time we've seen this label, convert its target */

            tgt = (insGroup*)emitCodeGetCookie(jmp->idAddr.iiaBBlabel); assert(tgt);

            /* Record the bound target */

            jmp->idAddr.iiaIGlabel = tgt;
            jmp->idInfo.idBound    = true;
        }

        /* Done if this is not a variable-sized jump */

#if     TGT_x86
        if  (jmp->idIns == INS_call)
            continue;
#endif

        /*
            In the following distance calculations, if we're not actually
            scheduling the code (i.e. reordering instructions), we can
            use the actual offset of the jump (rather than the beg/end of
            the instruction group) since the jump will not be moved around
            and thus its offset is accurate.

            First we need to figure out whether this jump is a forward or
            backward one; to do this we simply look at the ordinals of the
            group that contains the jump and the target.
         */

        dstOffs = tgt->igOffs;

#if     SCHEDULER
    JMP_REP:
#endif

        if  (jmpIG->igNum < tgt->igNum)
        {
            /* Forward jump: figure out the appropriate source offset */

            srcOffs = jmpIG->igOffs;

#if     SCHEDULER
            if  (jmp->idjSched)
            {
                assert(emitComp->opts.compSchedCode);

                srcOffs += jmp->idjTemp.idjOffs[0];
            }
            else
#endif
            {
                srcOffs += jmp->idjOffs;
            }

            /* Adjust the target offset by the current delta */

#if     TGT_x86
            dstOffs -= adjIG;
#endif

            /* Compute the distance estimate */

#if   TGT_SH3
            jmpDist = dstOffs - (srcOffs + INSTRUCTION_SIZE);
#elif TGT_MIPS32 || TGT_PPC
            jmpDist = dstOffs - (srcOffs + INSTRUCTION_SIZE) - (lsz - ssz);
#else
            jmpDist = dstOffs - srcOffs - ssz;
#endif

            /* How much beyond the max. short distance does the jump go? */

            extra   = jmpDist - psd;

#if     SCHEDULER

            if  (extra > 0 && jmp->idjSched)
            {
                /*
                    Could it happen that the jump might become non-short
                    solely due to scheduling?
                 */

                if  ((unsigned)extra <= jmp->idjOffs - jmp->idjTemp.idjOffs[0])
                {
                    /* Keep the jump short by not scheduling it */

                    jmp->idjSched = false;

                    goto JMP_REP;
                }
            }

#endif

#ifdef  DEBUG
            if  (jmp->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (INTERESTING_JUMP_NUM == 0)
                printf("[1] Jump %u:\n",               jmp->idNum);
                printf("[1] Jump  block is at %08X\n", jmpIG->igOffs);
                printf("[1] Jump source is at %08X\n", srcOffs+ssz);
                printf("[1] Label block is at %08X\n", dstOffs);
                printf("[1] Jump  dist. is    %04X\n", jmpDist);
                if  (extra > 0)
                printf("[1] Dist excess [S] = %d  \n", extra);
            }
#endif

#ifdef  DEBUG
            if  (verbose) printf("Estimate of fwd jump [%08X/%03u]: %04X -> %04X = %04X\n", jmp, jmp->idNum, srcOffs, dstOffs, jmpDist);
#endif

            if  (extra <= 0)
            {
                /* This jump will be a short one */

                goto SHORT_JMP;
            }

#if     TGT_SH3

            /* Can we use a "medium" jump? */

            if  (!msz)
                goto LARGE_JMP;

            /* Compute the distance estimate for a medium jump */

            jmpDist = dstOffs - srcOffs - msz;

            /* How much beyond the max. medium distance does the jump go? */

            extra   = jmpDist - pmd;

#ifdef  DEBUG
            if  (jmp->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (extra > 0)
                printf("[1] Dist excess [M] = %d  \n", extra);
            }
#endif

            if  (extra <= 0)
            {
                /* This jump will be a "medium" one */

                goto MIDDL_JMP;
            }

#endif

            /* This jumps needs to stay "long", at least for now */

            ;
        }
        else
        {
            /* This is a backward jump */

            size_t          srcOffs;

            /* Figure out the appropriate source offset to use */

            srcOffs = jmpIG->igOffs;
#if SCHEDULER
            if  (emitComp->opts.compSchedCode && jmp->idjSched)
            {
                srcOffs += jmp->idjTemp.idjOffs[1];
            }
            else
#endif
            {
                srcOffs += jmp->idjOffs;
            }

            /* Compute the distance estimate */

#if     (TGT_SH3 || TGT_MIPS32 || TGT_PPC)
            jmpDist = srcOffs + INSTRUCTION_SIZE - dstOffs;
#else
            jmpDist = srcOffs - dstOffs + ssz;
#endif

            /* How much beyond the max. short distance does the jump go? */

            extra = jmpDist + nsd;

#if     SCHEDULER

            if  (extra > 0 && jmp->idjSched)
            {
                /* Would the jump not short solely due to scheduling?
                 * We prefer short to schedulable.
                 */

                if  ((unsigned)extra <= jmp->idjTemp.idjOffs[1] - jmp->idjOffs)
                {
                    /* Prevent the jump from being scheduled */

                    jmp->idjSched = false;

                    goto JMP_REP;
                }
            }

#endif

#ifdef  DEBUG
            if  (jmp->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (INTERESTING_JUMP_NUM == 0)
                printf("[2] Jump %u:\n",               jmp->idNum);
                printf("[2] Jump reloffset is %04X\n", jmp->idjOffs);
                printf("[2] Jump  block is at %08X\n", jmpIG->igOffs);
                printf("[2] Jump source is at %08X\n", srcOffs+ssz);
                printf("[2] Label block is at %08X\n", tgt->igOffs);
                printf("[2] Jump  dist. is    %04X\n", jmpDist);
                if  (extra > 0)
                printf("[2] Dist excess [S] = %d  \n", extra);
            }
#endif

#ifdef  DEBUG
            if  (verbose) printf("Estimate of bwd jump [%08X/%03u]: %04X -> %04X = %04X\n", jmp, jmp->idNum, srcOffs, tgt->igOffs, jmpDist);
#endif

            if  (extra <= 0)
            {
                /* This jump will be a short one */

                goto SHORT_JMP;
            }

#if     TGT_SH3

            /* Can we use a "medium" jump? */

            if  (!msz)
                goto LARGE_JMP;

            /* We assume only conditional have a medium flavor */

            assert(emitIsCondJump(jmp));

            /* Compute the distance estimate for a medium jump */

            jmpDist = srcOffs - dstOffs - msz;

            /* How much beyond the max. short distance does the jump go? */

            extra = jmpDist + nmd;

#ifdef  DEBUG
            if  (jmp->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (extra > 0)
                printf("[2] Dist excess [M] = %d  \n", extra);
            }
#endif

            if  (extra <= 0)
            {
                /* This jump will be a "medium" one */

                goto MIDDL_JMP;
            }

#endif

            /* This jumps needs to stay "long", at least for now */

            ;
        }

#if     TGT_RISC
    LARGE_JMP:
#endif

        /* We arrive here if the jump needs to stay long */

        /* We had better not have eagerly marked the jump as short
         * in emitIns_J(). If we did, then it has to be able to stay short
         * as emitIns_J() uses the worst case scenario, and blocks can
         * only move closer togerther after that.
         */
        assert(jmp->idjShort  == 0);
#if     TGT_RISC
        assert(jmp->idjMiddle == 0);
#endif

        /* Keep track of the closest distance we got */

        if  (minx > (unsigned)extra)
             minx = (unsigned)extra;

        continue;

    SHORT_JMP:

        /* This jump will definitely be a short one */

        jmp->idjShort  = 1;
        jsz            = ssz;

#if TGT_MIPS32 || TGT_PPC

        /* jump elimination should work for any CPU, only tested for MIPS */

        if (0 == jmpDist)               // are we just falling thru?
        {
            jsz = 0;
            goto SMALL_JMP;
        }

#endif

#if TGT_RISC
CONSIDER_DELAY_SLOT:
        /* Some jumps may need a branch delay slot */

        if  (jmp->idjAddBD)
        {
#if TGT_MIPS32 || TGT_SH3 // @todo - add each CPU back in to this logic as needed

            /* Can we simply swap the branch with the previous instruction? */

            instrDesc * pid;

            /*
                CONSIDER: The following is very inefficient.

                The following is horrible - since we have no easy way
                of finding the previous instruction, we start at the
                beginning of the jump's group and walk through the
                instructions until we find the one just before the
                jump.

                One minor improvement: if the previous jump belongs
                to this group, we start the search at that jump.
            */

            pid = (pji && pji->idjIG == jmpIG) ? pji
                                               : (instrDesc *)jmpIG->igData;
            if (pid < jmp)
            {
                for (;;)
                {
                    /* Get hold of the next instruction */

                    instrDesc * nid = (instrDesc *)((BYTE*)pid + emitSizeOfInsDsc(pid));

                    /* Stop if the next instruction is our jump */

                    if  (nid == jmp)
                        break;

                    /* Continue looking (but make sure we're not too far) */

                    assert(nid < jmp);

                    pid = nid;
                }

                /* Now we can we decide whether we can swap the instructions */

                jmp->idjAddBD = emitIns_BD (jmp, pid, jmpIG);
            }
#endif  // CPUs as needed

            // If the delay slot is needed add its size

            if  (jmp->idjAddBD)
                jsz += INSTRUCTION_SIZE;
        }
#endif

        goto SMALL_JMP;

#if     TGT_SH3

    MIDDL_JMP:

        /* This jump will be a "medium" one */

        jsz            = msz;
        jmp->idjMiddle = 1;

#endif

    SMALL_JMP:

        /* This jump is becoming either short or medium */

        sizeDif = oldSize - jsz; assert((int)sizeDif >= 0);

#if     TGT_x86
        jmp->idCodeSize = jsz;
#endif
#if     TGT_SH3
        if (!all_jumps_shortened && sizeDif && oldSize > msz)
        {
            assert(jmpIG->igLPuseCntL > 0);
            jmpIG->igLPuseCntL--;
            //emitEstLPlongs--;
        }
#endif

        /* Make sure the size of the jump is marked correctly */

        assert((0 == (jsz | jmpDist)) || (jsz == emitSizeOfJump(jmp)));

#ifdef  DEBUG
        if  (verbose) printf("Shrinking jump [%08X/%03u]\n", jmp, jmp->idNum);
#endif

        adjIG             += sizeDif;
#if     TGT_x86
        adjLJ             += sizeDif;
#endif
        jmpIG->igSize     -= sizeDif;
        emitTotalCodeSize -= sizeDif;

        /* The jump size estimate wasn't accurate; flag its group */

        jmpIG->igFlags    |= IGF_UPD_ISZ;
    }

    /* Did we shorten any jumps? */

    if  (adjIG)
    {

#if     TGT_x86

        /* Adjust offsets of any remaining blocks */

        assert(lstIG);

        for (;;)
        {
            lstIG = lstIG->igNext;
            if  (!lstIG)
                break;
//          printf("Adjusted offset of block %02u from %04X to %04X\n", lstIG->igNum, lstIG->igOffs, lstIG->igOffs - adjIG);
            lstIG->igOffs -= adjIG;
        }

#else

        /* Simply update the offsets of all the blocks */

        emitRecomputeIGoffsets();

#endif

        emitCheckIGoffsets();

        /* Is there a chance of other jumps becoming short? */

        assert((int)minx >= 0);

#ifdef  DEBUG
        if  (verbose) printf("Total shrinkage = %3u, min extra jump size = %3u\n", adjIG, minx);
#endif

        if  (minx <= adjIG)
        {
            jmp_iteration++;
            goto AGAIN;
        }
    }

#ifdef BIRCH_SP2
    HRESULT hr;
#endif

#if     SMALL_DIRECT_CALLS

    /* Can we get the address of the method we're compiling? */

# ifdef BIRCH_SP2

    emitLPmethodAddr  = 0;
    hr = comp->getIJitInfo()->allocMem (  0,
                                          0,
                                          0,
                                          (void**) &emitLPmethodAddr,
                                          (void**) &consBlock,
                                          (void**) &dataBlock);
    if (FAILED (hr))
        fatal (ERRnoMemory, 0);

# else // not BIRCH_SP2

#ifdef  NOT_JITC

    assert(!"ToDo");
#  if 0
    emitLPmethodAddr = (BYTE*)emitComp->eeGetMethodEntryPoint(CT_USER_FUNC,
                                                              emitComp->compMethodHnd,
                                                              emitComp->info.compScopeHnd);
#  else
    emitLPmethodAddr = 0;
#  endif

#else  // not NOT_JITC

    /* The following is just a truly horrendous hack */

    void    *       toss1;
    void    *       toss2;

    if  (!eeAllocMem(NULL, 0, 0, 0, (const void**)&emitLPmethodAddr,
                                    (const void**)&toss1,
                                    (const void**)&toss2))
    {
        emitLPmethodAddr = 0;
    }

#endif  // NOT_JITC

#endif  // BIRCH_SP2

#endif  // SMALL_DIRECT_CALLS

    /* The following is a "nop" if indirect jumps aren't "special" */

    emitFinalizeIndJumps();

    /* The following is a "nop" if literal pools aren't being used */

    emitFinalizeLitPools();

#ifdef  DEBUG

    if  (verbose)
    {
        printf("\nInstruction list before instruction issue:\n\n");
        emitDispIGlist(true);
    }

    emitCheckIGoffsets();

#endif

#ifndef NOT_JITC

    /* Are we supposed to save the generated code? */

    if  (!savCode)
        return  emitTotalCodeSize;

#endif

    /* Allocate the code block (and optionally the data blocks) */

#if EMIT_USE_LIT_POOLS
    assert(emitConsDsc.dsdOffs == 0);
    assert(emitDataDsc.dsdOffs == 0);
#endif

#ifdef BIRCH_SP2
    size_t askCodeSize = emitTotalCodeSize;
    askCodeSize = (askCodeSize + 7) & ~7;

    hr = comp->getIJitInfo()->allocMem (  askCodeSize,
                                          emitConsDsc.dsdOffs,
                                          emitDataDsc.dsdOffs,
                                          (void**) &codeBlock,
                                          (void**) &consBlock,
                                          (void**) &dataBlock);
    if (FAILED (hr))
        fatal (ERRnoMemory, 0);

#if TGT_x86
    assert(askCodeSize >= 8);
    BYTE* nopPtr = ((BYTE*) codeBlock) + (askCodeSize - 8);

    for (int nopCnt=0; nopCnt < 8; nopCnt++)
        *nopPtr++ = 0xCC;       // INT 3 instruction
#endif

#else
    if  (!eeAllocMem(emitCmpHandle, emitTotalCodeSize,
                                    emitConsDsc.dsdOffs,
                                    emitDataDsc.dsdOffs,
                                    (const void**)&codeBlock,
                                    (const void**)&consBlock,
                                    (const void**)&dataBlock))
    {
        NOMEM();
    }
#endif  // BIRCH_SP2

//  if  (emitConsDsc.dsdOffs) printf("Cons=%08X\n", consBlock);
//  if  (emitDataDsc.dsdOffs) printf("Data=%08X\n", dataBlock);

    /* Give the block addresses to the caller and other functions here */

    *codeAddr = emitCodeBlock = codeBlock;
    *consAddr = emitConsBlock = consBlock;
    *dataAddr = emitDataBlock = dataBlock;

#if TGT_x86 && defined(RELOC_SUPPORT) && defined(BIRCH_SP2)
    emitConsBlock = getCurrentCodeAddr(NULL) + (consBlock - codeBlock);
#endif

#if SMALL_DIRECT_CALLS

    /* If we haven't done so already, ... */

    if  (!emitLPmethodAddr)
    {
        /* ... go try shrink calls that are direct and short */

        emitShrinkShortCalls();
    }
    else
    {
        /* Just make sure we had not been lied to earlier */

        assert(emitLPmethodAddr == codeBlock);
    }

#endif

    /* We have not encountered any source line numbers yet */

#ifdef  DEBUG
    emitLastSrcLine   = 0;
#endif

    /* Nothing has been pushed on the stack */

#if EMIT_TRACK_STACK_DEPTH
    emitCurStackLvl   = 0;
#endif

    /* Assume no live GC ref variables on entry */

#if TRACK_GC_REFS
    emitThisGCrefVars = 0;
    emitThisGCrefRegs =
    emitThisByrefRegs = 0;
    emitThisGCrefVset = true;

    /* Initialize the GC ref variable lifetime tracking logic */

    emitComp->gcVarPtrSetInit();
#endif

    emitThisArgOffs   = -1;     /* -1  means no offset set */

#if USE_FASTCALL
#if TRACK_GC_REFS

    if  (!emitComp->info.compIsStatic)
    {
        /* If "this" (which is passed in as a register argument in REG_ARG_0)
           is enregistered, we normally spot the "mov REG_ARG_0 -> thisReg"
           in the prolog and note the location of "this" at that point.
           However, if 'this' is enregistered into REG_ARG_0 itself, no code
           will be generated in the prolog, so we explicitly need to note
           the location of "this" here.
           NOTE that we can do this even if "this" is not enregistered in
           REG_ARG_0, and it will result in more accurate "this" info over the
           prolog. However, as methods are not interruptible over the prolog,
           we try to save space by avoiding that.
         */

        assert(emitComp->lvaIsThisArg(0));
        Compiler::LclVarDsc * thisDsc = &emitComp->lvaTable[0];

        if  (thisDsc->lvRegister && thisDsc->lvRegNum == REG_ARG_0)
        {
            if  (emitFullGCinfo && thisDsc->TypeGet() != TYP_I_IMPL)
            {
                GCtype   gcType = (thisDsc->TypeGet() == TYP_REF) ? GCT_GCREF
                                                                  : GCT_BYREF;
                emitGCregLiveSet(gcType,
                                 emitRegMask((emitRegs)REG_ARG_0),
                                 emitCodeBlock, // from offset 0
                                 true);
            }
            else
            {
                /* If emitFullGCinfo==false, the we dont use any
                   regPtrDsc's and so explictly note the location
                   of "this" in GCEncode.cpp
                 */
            }
        }
    }

#endif
#endif

    emitContTrkPtrLcls = contTrkPtrLcls;

    /* Are there any GC ref variables on the stack? */

    if  (emitGCrFrameOffsCnt)
    {
        size_t              siz;
        unsigned            cnt;
        unsigned            num;
        Compiler::LclVarDsc*dsc;
        int         *       tab;

        /* Allocate and clear emitGCrFrameLiveTab[]. This is the table
           mapping "stkOffs -> varPtrDsc". It holds a pointer to
           the liveness descriptor that was created when the
           variable became alive. When the variable becomes dead, the
           descriptor will be appended to the liveness descriptor list, and
           the entry in emitGCrFrameLiveTab[] will be make NULL.

           Note that if all GC refs are assigned consecutively,
           emitGCrFrameLiveTab[] can be only as big as the number of GC refs
           present, instead of lvaTrackedCount;
         */

        siz = emitGCrFrameOffsCnt * sizeof(*emitGCrFrameLiveTab);
        emitGCrFrameLiveTab = (varPtrDsc**)emitGetMem(roundUp(siz));
        memset(emitGCrFrameLiveTab, 0, siz);

        /* Allocate and fill in emitGCrFrameOffsTab[]. This is the table
           mapping "varIndex -> stkOffs".
           Non-ptrs or reg vars have entries of -1.
           Entries of Tracked stack byrefs have the lower bit set to 1.
        */

        emitTrkVarCnt       = cnt = emitComp->lvaTrackedCount; assert(cnt);
        emitGCrFrameOffsTab = tab = (int*)emitGetMem(cnt * sizeof(int));

        memset(emitGCrFrameOffsTab, -1, cnt * sizeof(int));

        /* Now fill in all the actual used entries */

        for (num = 0, dsc = emitComp->lvaTable, cnt = emitComp->lvaCount;
             num < cnt;
             num++  , dsc++)
        {
            if  (!dsc->lvOnFrame)
                continue;

            int  offs = dsc->lvStkOffs;

            /* Is it within the interesting range of offsets */

            if  (offs >= emitGCrFrameOffsMin && offs < emitGCrFrameOffsMax)
            {
                /* Are tracked stack ptr locals laid out contiguously?
                   If not, skip non-ptrs. The emitter is optimized to work
                   with contiguous ptrs, but for EditNContinue, the variables
                   are laid out in the order they occur in the local-sig.
                 */

                if (!emitContTrkPtrLcls)
                {
                    if (! dsc->lvTracked ||
                        !(dsc->TypeGet() == TYP_REF ||
                          dsc->TypeGet() == TYP_BYREF))
                        continue;
                }

                unsigned        indx = dsc->lvVarIndex;

                assert(!dsc->lvRegister);
                assert( dsc->lvTracked);
#if USE_FASTCALL
                assert(!dsc->lvIsParam || dsc->lvIsRegArg);
#else
                assert(!dsc->lvIsParam);
#endif
                assert( dsc->lvRefCnt != 0);

                assert( dsc->TypeGet() == TYP_REF   ||
                        dsc->TypeGet() == TYP_BYREF);

                assert(indx < emitComp->lvaTrackedCount);

                // printf("Variable #%2u/%2u is at stack offset %d\n", num, indx, offs);
                /* Remember the frame offset of the "this" argument */
                if  (dsc->lvIsThis)
                {
                    emitThisArgOffs = offs;
                    offs |= this_OFFSET_FLAG;
                }
                if (dsc->TypeGet() == TYP_BYREF)
                {
                    offs |= byref_OFFSET_FLAG;
                }
                tab[indx] = offs;
            }
        }
    }
    else
    {
#ifdef  DEBUG
        emitTrkVarCnt       = 0;
        emitGCrFrameOffsTab = NULL;
#endif
    }

#ifdef  DEBUG
#ifndef NOT_JITC

    if (disAsm && dspLines)
    {
        /* Seek to the "base" source line */

        emitComp->compDspSrcLinesByLineNum(emitBaseLineNo, true);

        /* Find the first source line# that's not in a prolog */

        for (ig = emitIGlist; ig; ig = ig->igNext)
        {
            if  (!emitIGisInProlog(ig))
            {
                instrDesc * id = (instrDesc *)ig->igData;

                if  (id->idSrcLineNo)
                {
                    /* Display lines to just before the first "real" one */

                    emitLastSrcLine = id->idSrcLineNo - 1;
                    emitComp->compDspSrcLinesByLineNum(emitLastSrcLine, false);
                }

                break;
            }
        }
    }

#endif
#endif

    /* Prepare for scheduling, if necessary */

    scPrepare();

#if EMIT_USE_LIT_POOLS
    curLP = emitLitPoolCur = emitLitPoolList;
    litIG = curLP ? curLP->lpIG : NULL;
#endif

    /* Issue all instruction groups in order */

    cp = codeBlock;

    for (ig = emitIGlist; ig; ig = ig->igNext)
    {
        assert(ig->igNext == NULL || ig->igNum + 1 == ig->igNext->igNum);

        instrDesc * id = (instrDesc *)ig->igData;

        BYTE      * bp = cp;

        /* Tell other methods which group we're issuing */

        emitCurIG = ig;

//      if  (Compiler::s_compMethodsCount == 12 && ig->igNum == 8) BreakIfDebuggerPresent();

#ifdef  DEBUG

        if  (disAsm)
        {
            printf("\nG_%02u_%02u:", Compiler::s_compMethodsCount, ig->igNum);

            if (verbose||1)
            {
                printf("  ; offs=%06XH", ig->igOffs);

                if  (ig->igOffs != emitCurCodeOffs(cp))
                    printf("/%06XH", cp - codeBlock);
            }

            printf("\n");
        }

#endif

#if TGT_x86

        /* Record the actual offset of the block, noting the difference */

        emitOffsAdj  = ig->igOffs - emitCurCodeOffs(cp); assert(emitOffsAdj >= 0);
//      printf("Block predicted offs = %08X, actual = %08X -> size adj = %d\n", ig->igOffs, emitCurCodeOffs(cp), emitOffsAdj);
        ig->igOffs = emitCurCodeOffs(cp);

#else

        /* For RISC targets, the offset estimate must always be accurate */

#if SCHEDULER

        /* Unless we're scheduling, of course ... */

        if  (ig->igOffs != emitCurCodeOffs(cp))
        {
            assert(emitComp->opts.compSchedCode);

            /* Remember that some block offsets have changed */

            emitIGmoved = true;
        }

#else

        assert(ig->igOffs == emitCurCodeOffs(cp));

#endif

#endif

#if EMIT_TRACK_STACK_DEPTH

        /* Set the proper stack level if appropriate */

        if  (ig->igStkLvl != emitCurStackLvl)
        {
            /* We are pushing stuff implicitly at this label */

            assert((unsigned)ig->igStkLvl > (unsigned)emitCurStackLvl);
            emitStackPushN(cp, (ig->igStkLvl - (unsigned)emitCurStackLvl)/sizeof(int));
        }

#endif

#if TRACK_GC_REFS

        /* Is this IG "real" (not added implicitly by the emitter) ? */

        if (!(ig->igFlags & IGF_EMIT_ADD))
        {
            /* Is there a new set of live GC ref variables? */

            if  (ig->igFlags & IGF_GC_VARS)
                emitUpdateLiveGCvars(castto(id, VARSET_TP *)[-1], cp);
            else if (!emitThisGCrefVset)
                emitUpdateLiveGCvars(            emitThisGCrefVars, cp);

            /* Is there a new set of live GC ref registers? */

//          if  (ig->igFlags & IGF_GC_REGS)
            {
                unsigned        GCregs = ig->igGCregs;

                if  (GCregs != emitThisGCrefRegs)
                    emitUpdateLiveGCregs(GCT_GCREF, GCregs, cp);
            }

            /* Is there a new set of live byref registers? */

            if  (ig->igFlags & IGF_BYREF_REGS)
            {
                unsigned        byrefRegs = ig->igByrefRegs();

                if  (byrefRegs != emitThisByrefRegs)
                    emitUpdateLiveGCregs(GCT_BYREF, byrefRegs, cp);
            }
        }

#endif

#if SCHEDULER

        /* Should we try to schedule instructions in this group? */

        if  (emitComp->opts.compSchedCode && (ig->igInsCnt >= SCHED_INS_CNT_MIN)
             && emitCanSchedIG(ig))
        {
            /* We'll try to schedule instructions in this group */

            unsigned        cnt;

            int             fpLo, spLo;
            int             fpHi, spHi;

            instrDesc  *  * scInsPtr;

            /*
                If we are scheduling for a target with branch-delay slots
                present, we'll include the next jump and the all of the
                nop instructions that follow it in the scheduling group.

                When we save a branch-delay instruction, we set the bdCnt
                variable to the number of branch-delay slots; when this
                count reaches zero, we'll schedule the group. If we have
                not yet encountered a branch-delay instruction, we keep
                the bdCnt value negative so that it never goes to zero.
             */

#if MAX_BRANCH_DELAY_LEN
            unsigned        bdLen;
            int             bdCnt;
            #define         startBranchDelayCnt( ) bdCnt = -1, bdLen = 0
            #define         checkBranchDelayCnt(m) assert(bdCnt <= m)
#else
            #define         startBranchDelayCnt( )
            #define         checkBranchDelayCnt(m)
#endif

            /* Use the following macro to mark the scheduling table as empty */

            #define         clearSchedTable()                   \
                                                                \
                scInsPtr = scInsTab;                            \
                                                                \
                startBranchDelayCnt();                          \
                                                                \
                fpLo = spLo = INT_MAX;                          \
                fpHi = spHi = INT_MIN;

            /* Prepare to fill the instruction table */

            clearSchedTable();

            /* Walk through all of the instructions in the IG */

            for (cnt = ig->igInsCnt;
                 cnt;
                 cnt--, castto(id, BYTE *) += emitSizeOfInsDsc(id))
            {
                /* Is this a schedulable instruction? */

//              emitDispIns(id, false, false, false);

                if  (scIsSchedulable(id))
                {
                    /* The instruction looks schedulable */

#if MAX_BRANCH_DELAY_LEN

                    /* Have we just consumed an entire branch-delay section? */

                    if  (--bdCnt == 0)
                        goto NOT_SCHED;

                    /* Don't schedule nop's except as branch-delay slots */

                    if  (id->idIns == INS_nop && bdCnt < 0)
                        goto NOT_SCHED;

                    /* Don't schedule zapped instructions */

                    if  (id->idIns == INS_ignore)
                        continue;

                    /* Check for a jump/call instruction */

                    if  (scIsBranchIns(id->idIns))
                    {
                        /* This better not be a branch-delay slot */

                        assert(bdCnt <  0);
                        assert(bdLen == 0);

                        /* Get the number of branch-delay slots */

                        bdLen = Compiler::instBranchDelayL(id->idIns);

                        /* If there are no branch-delay slots, give up */

                        if  (!bdLen)
                            goto NOT_SCHED;

                        /*
                            Do we have enough instructions available to fill
                            the branch-delay slots, and do we have room for
                            them in the scheduling table?
                         */

                        if  (scInsPtr + bdLen >= scInsMax || bdLen >= cnt)
                        {
                            bdLen = 0;
                            goto NOT_SCHED;
                        }

                        /* Save and schedule the whole shebang */

                        bdCnt = bdLen + 1;
                    }
#ifndef NDEBUG
                    else if (bdCnt > 0)
                    {
                        /* In a branch-delay section; this better be a nop */

                        assert(id->idIns == INS_nop);
                    }
#endif

#endif

                    /* Is there room in the schedule table? */

                    if  (scInsPtr == scInsMax)
                    {
                        /* Schedule and issue the instructions in the table */

                        checkBranchDelayCnt(0);

                        scGroup(ig, id, &cp, scInsTab,
                                             scInsPtr, fpLo, fpHi,
                                                       spLo, spHi, bdLen);

                        /* The table is now empty */

                        clearSchedTable();
                    }

#if     0
#ifdef  DEBUG
                    emitDispIns(id, false, false, false); printf("Append sched instr #%02u to table.\n", scInsPtr - scInsTab);
#endif
#endif

                    assert(scInsPtr < scInsTab + emitMaxIGscdCnt);

                    *scInsPtr++ = id;

                    /* Does this instruction reference the stack? */

                    if  (scInsSchedOpInfo(id) & IS_SF_RW)
                    {
                        int         ofs;
                        size_t      osz;
                        bool        fpb;

                        /* Keep track of min. and max. frame offsets */

                        ofs = scGetFrameOpInfo(id, &osz, &fpb);

                        if  (fpb)
                        {
                            if  (fpLo > (int)(ofs    )) fpLo = ofs;
                            if  (fpHi < (int)(ofs+osz)) fpHi = ofs+osz;
                        }
                        else
                        {
                            if  (spLo > (int)(ofs    )) spLo = ofs;
                            if  (spHi < (int)(ofs+osz)) spHi = ofs+osz;
                        }
                    }

                    continue;
                }

#if MAX_BRANCH_DELAY_LEN
            NOT_SCHED:
#endif

                /* Instruction is not schedulable; is the table non-empty? */

                if  (scInsPtr != scInsTab)
                {
                    /* Schedule and issue the instructions in the table */

                    checkBranchDelayCnt(0);

                    scGroup(ig, id, &cp, scInsTab,
                                         scInsPtr, fpLo, fpHi,
                                                   spLo, spHi, bdLen);

                    /* The table is now empty */

                    clearSchedTable();
                }

                /* Issue the non-schedulable instruction itself */

                emitIssue1Instr(ig, id, &cp);
            }

            /* Is the table non-empty? */

            if  (scInsPtr != scInsTab)
            {
                /* Issue whatever has been accumulated in the table */

                checkBranchDelayCnt(1);

                scGroup(ig, NULL, &cp, scInsTab,
                                       scInsPtr, fpLo, fpHi,
                                                 spLo, spHi, bdLen);
            }

            assert(ig->igSize >= cp - bp);
                   ig->igSize  = cp - bp;
        }
        else
#endif
        {
            /* Issue each instruction in order */

            for (unsigned cnt = ig->igInsCnt; cnt; cnt--)
            {

#if TGT_RISC && !TGT_ARM

                /* Are the next 2 instructions to be swapped? */

                if  (id->idSwap)
                {
                    instrDesc   *   i1;
                    instrDesc   *   i2;
                    size_t          s2;

                    assert(cnt >= 2);

                    /* Get hold of the 2 instructions */

                    i1 = id;
                    i2 = (instrDesc*)((BYTE*)id + emitSizeOfInsDsc(id));

                    /* Output the instruction in reverse order */

                    s2 = emitIssue1Instr(ig, i2, &cp);
                         emitIssue1Instr(ig, i1, &cp);

                    /* We've consumed 2 instructions, one more than for-loop expects */

                    cnt--;

                    /* Skip over the second instruction */

                    id = (instrDesc*)((BYTE*)i2 + s2);
                }
                else    // don't put out a solo if we just did a pair
#endif
                {
                    castto(id, BYTE *) += emitIssue1Instr(ig, id, &cp);
                }
            }

            assert(ig->igSize >= cp - bp);
                   ig->igSize  = cp - bp;
        }

#if EMIT_USE_LIT_POOLS

        /* Is the current literal pool supposed to go after this group? */

        if  (ig == litIG)
        {
            /* Output the contents of the literal pool */

            cp = emitOutputLitPool(curLP, cp);

            /* Move to the next literal pool, if any */

            curLP = emitLitPoolCur = curLP->lpNext;
            litIG = curLP ? curLP->lpIG : NULL;
        }

#endif

    }

#if EMIT_TRACK_STACK_DEPTH
    assert(emitCurStackLvl == 0);
#endif

    /* Output any initialized data we may have */

    if  (emitConsDsc.dsdOffs) emitOutputDataSec(&emitConsDsc, codeBlock, consBlock);
    if  (emitDataDsc.dsdOffs) emitOutputDataSec(&emitDataDsc, codeBlock, dataBlock);

#if TRACK_GC_REFS

    /* Make sure all GC ref variables are marked as dead */

    if  (emitGCrFrameOffsCnt)
    {
        unsigned        vn;
        int             of;
        varPtrDsc   * * dp;

        for (vn = 0, of  = emitGCrFrameOffsMin, dp = emitGCrFrameLiveTab;
             vn < emitGCrFrameOffsCnt;
             vn++  , of += sizeof(void*)    , dp++)
        {
            if  (*dp)
                emitGCvarDeadSet(of, cp, vn);
        }
    }

    /* No GC registers are live any more */

    if  (emitThisByrefRegs)
        emitUpdateLiveGCregs(GCT_BYREF, 0, cp);  // ISSUE: What if ptr returned in EAX?
    if  (emitThisGCrefRegs)
        emitUpdateLiveGCregs(GCT_GCREF, 0, cp);  // ISSUE: What if ptr returned in EAX?

#endif

#if TGT_RISC && SCHEDULER

    /* If all block offsets were correctly estimated, no jmp patching needed */

    if  (!emitIGmoved)
        emitFwdJumps = false;

#endif

#if TGT_x86 || SCHEDULER

    /* Patch any forward jumps */

    if  (emitFwdJumps)
    {
        instrDescJmp *  jmp;

        for (jmp = emitJumpList; jmp; jmp = jmp->idjNext)
        {
            insGroup    *   tgt;

#if TGT_MIPS32
            if ((IF_JR_R == jmp->idInsFmt) || (IF_JR == jmp->idInsFmt))
                continue;       // skip this calculation not relevant to indirect jumps

            assert( (jmp->idInsFmt == IF_LABEL) ||
                    (jmp->idInsFmt == IF_RR_O)  || (jmp->idInsFmt == IF_R_O));
#else
            assert(jmp->idInsFmt == IF_LABEL);
#endif
            tgt = jmp->idAddr.iiaIGlabel;

            if  (!jmp->idjTemp.idjAddr)
                continue;

            if  (jmp->idjOffs != tgt->igOffs)
            {
                BYTE    *       adr = jmp->idjTemp.idjAddr;
                int             adj = jmp->idjOffs - tgt->igOffs;

#if     TGT_x86

#ifdef  DEBUG
                if  (jmp->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
                {
                    if  (INTERESTING_JUMP_NUM == 0)
                        printf("[5] Jump %u:\n", jmp->idNum);

                    if  (jmp->idjShort)
                    {
                        printf("[5] Jump        is at %08X\n"              , (adr + 1 - emitCodeBlock));
                        printf("[5] Jump distance is  %02X - %02X = %02X\n", *(BYTE *)adr, adj, *(BYTE *)adr - adj);
                    }
                    else
                    {
                        printf("[5] Jump        is at %08X\n"              , (adr + 4 - emitCodeBlock));
                        printf("[5] Jump distance is  %08X - %02X = %08X\n", *(int  *)adr, adj, *(int  *)adr - adj);
                    }
                }
#endif

                if  (jmp->idjShort)
                {
                    *(BYTE *)adr -= adj;
//                  printf("; Updated jump distance = %04XH\n", *(BYTE *)adr);
                }
                else
                {
                    *(int  *)adr -= adj;
//                  printf("; Updated jump distance = %08XH\n", *(int *)adr);
#ifdef  DEBUG
//                  if  (*(int*)adr <= JMP_DIST_SMALL_MAX_POS)
//                      printf("STUPID forward jump %08X / %03u: %u = %u - (%d)\n", jmp, jmp->idNum, *(int *)adr, *(int *)adr+adj, -adj);
#endif
                }

#else

                /* Check the size of the jump and adjust the distance value */

                if  (jmp->idjShort)
                {
                    *(USHORT*)adr -= adj;
                }
                else
                {
                    assert(!"need to patch RISC non-short fwd jump distance");
                }

#endif

            }
        }
    }

#endif

#ifdef  DEBUG
    if (disAsm) printf("\n");
#endif

//  printf("Allocated method code size = %4u , actual size = %4u\n", emitTotalCodeSize, cp - codeBlock);

#if EMITTER_STATS
    totAllocdSize += emitTotalCodeSize;
    totActualSize += cp - codeBlock;
#endif

    /* Return the amount of code we've generated */

    return  cp - codeBlock;
}

/*****************************************************************************
 *
 *  We've been asked for the code offset of an instruction but alas one or
 *  more instruction sizes in the block have been mis-predicted, so we have
 *  to find the true offset by looking for the instruction within the group.
 */

size_t              emitter::emitFindOffset(insGroup *ig, unsigned insNum)
{
    instrDesc *     id = (instrDesc *)ig->igData;
    unsigned        of = 0;

    /* Make sure we were passed reasonable arguments */

#ifdef DEBUG
    assert(ig && ig->igSelf == ig);
    assert(ig->igInsCnt >= insNum);
#endif

    /* Walk the instruction list until all are counted */

    while (insNum)
    {
        of += emitInstCodeSz(id);

        castto(id, BYTE *) += emitSizeOfInsDsc(id);

        insNum--;
    }

    return  of;
}

/*****************************************************************************
 *
 *  Start generating a constant or read/write data section for the current
 *  function. Returns the offset of the section in the appropriate data
 *  block.
 */

unsigned            emitter::emitDataGenBeg(size_t size, bool readOnly,
                                                         bool codeLtab)
{
    unsigned        secOffs;
    dataSection *   secDesc;

    assert(emitDataDscCur == 0);
    assert(emitDataSecCur == 0);

    /* The size better not be some kind of an odd thing */

    assert(size && size % sizeof(int) == 0);

    /* Figure out which section to use */

    emitDataDscCur = readOnly ? &emitConsDsc
                            : &emitDataDsc;

    /* Get hold of the current offset and advance it */

    secOffs = emitDataDscCur->dsdOffs;
              emitDataDscCur->dsdOffs += size;

    /* Allocate a data section descriptor and add it to the list */

    secDesc = emitDataSecCur = (dataSection *)emitGetMem(roundUp(sizeof(*secDesc) + size));

    secDesc->dsSize = size | (int)codeLtab;
    secDesc->dsNext = 0;

    if  (emitDataDscCur->dsdLast)
        emitDataDscCur->dsdLast->dsNext = secDesc;
    else
        emitDataDscCur->dsdList         = secDesc;
    emitDataDscCur->dsdLast = secDesc;

    /* Set the low bit if the value is a constant */

    assert((secOffs & 1) == 0);
    assert(readOnly == 0 || readOnly == 1);

    return  secOffs + readOnly;
}

/*****************************************************************************
 *
 *  Emit the given block of bits into the current data section.
 */

void                emitter::emitDataGenData(unsigned    offs,
                                         const void *data,
                                         size_t      size)
{
    assert(emitDataDscCur);
    assert(emitDataSecCur && (emitDataSecCur->dsSize >= offs + size)
                        && (emitDataSecCur->dsSize & 1) == 0);

    memcpy(emitDataSecCur->dsCont + offs, data, size);
}

/*****************************************************************************
 *
 *  Emit the address of the given basic block into the current data section.
 */

void                emitter::emitDataGenData(unsigned offs, BasicBlock *label)
{
    assert(emitDataDscCur == &emitConsDsc);
    assert(emitDataSecCur != 0);
    assert(emitDataSecCur && (emitDataSecCur->dsSize >= offs + sizeof(void*))
                        && (emitDataSecCur->dsSize & 1) != 0);

    *(BasicBlock **)(emitDataSecCur->dsCont + offs) = label;
}

/*****************************************************************************
 *
 *  We're done generating a data section.
 */

void                emitter::emitDataGenEnd()
{

#ifndef NDEBUG
    assert(emitDataSecCur); emitDataSecCur = 0;
    assert(emitDataDscCur); emitDataDscCur = 0;
#endif

}

/*****************************************************************************
 *
 *  Output the given data section at the specified address.
 */

void                emitter::emitOutputDataSec(dataSecDsc *sec, BYTE *cbp, BYTE *dst)
{
    dataSection *   dsc;

#ifdef  DEBUG
    BYTE    *       dsb = dst;
#endif

#if TGT_x86 && defined(OPT_IL_JIT) && defined(BIRCH_SP2)
    cbp = getCurrentCodeAddr(NULL);
#endif

    assert(dst);
    assert(sec->dsdOffs);
    assert(sec->dsdList);

    /* Walk and emit the contents of all the data blocks */

    for (dsc = sec->dsdList; dsc; dsc = dsc->dsNext)
    {
        size_t          siz = dsc->dsSize;

        /* Is this a label table? */

        if  (siz & 1)
        {
            BasicBlock  * * bbp = (BasicBlock**)dsc->dsCont;

            siz -= 1;
            assert(siz && siz % sizeof(void *) == 0);
            siz /= sizeof(void*);

            /* Output the label table (it's stored as "BasicBlock*" values) */

            do
            {
                insGroup    *   lab;

                /* Convert the BasicBlock* value to an IG address */

                lab = (insGroup*)emitCodeGetCookie(*bbp++); assert(lab);

                /* Append the appropriate address to the destination */

                *castto(dst, BYTE**)++ = cbp + lab->igOffs;
#ifdef RELOC_SUPPORT
                emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
#endif
            }
            while (--siz);
        }
        else
        {
            /* Simple binary data: copy the bytes to the target */

            memcpy(dst, dsc->dsCont, siz);
                   dst       +=      siz;
        }
    }

#ifdef DEBUG
    assert(dst == dsb + sec->dsdOffs);
#endif
}

/*****************************************************************************/
#if     TRACK_GC_REFS
/*****************************************************************************
 *
 *  Record the fact that the given variable now contains a live GC ref.
 */

void                emitter::emitGCvarLiveSet(int       offs,
                                              GCtype    gcType,
                                              BYTE *    addr,
                                              int       disp)
{
    varPtrDsc   *   desc;

    assert((abs(offs) % sizeof(int)) == 0);
    assert(needsGC(gcType));

    /* Compute the index into the GC frame table if the caller didn't do it */

    if  (disp == -1)
        disp = (offs - emitGCrFrameOffsMin) / sizeof(void *);

    assert((unsigned)disp < emitGCrFrameOffsCnt);

    /* Allocate a lifetime record */

    desc = (varPtrDsc *)emitComp->compGetMem(sizeof(*desc));

    desc->vpdBegOfs = emitCurCodeOffs(addr);
#ifndef NDEBUG
    desc->vpdEndOfs = 0xFACEDEAD;
#endif

    desc->vpdVarNum = offs;

    /* the lower 2 bits encode props about the stk ptr */

    if  (offs == emitThisArgOffs)
    {
        desc->vpdVarNum |= this_OFFSET_FLAG;
    }

    if  (gcType == GCT_BYREF)
    {
        desc->vpdVarNum |= byref_OFFSET_FLAG;
    }

    /* Append the new entry to the end of the list */

    desc->vpdPrev   = emitComp->gcVarPtrLast;
                      emitComp->gcVarPtrLast->vpdNext = desc;
                      emitComp->gcVarPtrLast          = desc;

    /* Record the variable descriptor in the table */

    assert(emitGCrFrameLiveTab[disp] == NULL);
           emitGCrFrameLiveTab[disp]  = desc;

#ifdef  DEBUG
    if  (VERBOSE)
    {
        printf("[%08X] %s var born at [%s", desc, GCtypeStr(gcType), emitEBPframe ? "EBP" : "ESP");

        if      (offs < 0)
            printf("-%02XH", -offs);
        else if (offs > 0)
            printf("+%02XH", +offs);

        printf("]\n");
    }
#endif

    /* The "global" live GC variable mask is no longer up-to-date */

    emitThisGCrefVset = false;
}

/*****************************************************************************
 *
 *  Record the fact that the given variable no longer contains a live GC ref.
 */

void                emitter::emitGCvarDeadSet(int offs, BYTE *addr, int disp)
{
    varPtrDsc   *   desc;

    assert(abs(offs) % sizeof(int) == 0);

    /* Compute the index into the GC frame table if the caller didn't do it */

    if  (disp == -1)
        disp = (offs - emitGCrFrameOffsMin) / sizeof(void *);

    assert((unsigned)disp < emitGCrFrameOffsCnt);

    /* Get hold of the lifetime descriptor and clear the entry */

    desc = emitGCrFrameLiveTab[disp];
           emitGCrFrameLiveTab[disp] = NULL;

    assert( desc);
    assert((desc->vpdVarNum & ~OFFSET_MASK) == (unsigned)offs);

    /* Record the death code offset */

    assert(desc->vpdEndOfs == 0xFACEDEAD);
           desc->vpdEndOfs  = emitCurCodeOffs(addr);

#ifdef  DEBUG
    if  (VERBOSE)
    {
        GCtype  gcType = (desc->vpdVarNum & byref_OFFSET_FLAG) ? GCT_BYREF : GCT_GCREF;
        bool    isThis = (desc->vpdVarNum & this_OFFSET_FLAG) != 0;

        printf("[%08X] %s%s var died at [%s",
               desc,
               GCtypeStr(gcType),
               isThis       ? "this-ptr" : "",
               emitEBPframe ? "EBP"      : "ESP");

        if      (offs < 0)
            printf("-%02XH", -offs);
        else if (offs > 0)
            printf("+%02XH", +offs);

        printf("]\n");
    }
#endif

    /* The "global" live GC variable mask is no longer up-to-date */

    emitThisGCrefVset = false;
}

/*****************************************************************************
 *
 *  Record a new set of live GC ref variables.
 */

void                emitter::emitUpdateLiveGCvars(VARSET_TP vars, BYTE *addr)
{
    /* Is the current set accurate and unchanged? */

    if  (emitThisGCrefVset && emitThisGCrefVars == vars)
        return;

#ifdef  DEBUG
    if  (VERBOSE) printf("New GC ref live vars=%016I64X\n", vars);
#endif

    emitThisGCrefVars = vars;

    /* Are there any GC ref variables on the stack? */

    if  (emitGCrFrameOffsCnt)
    {
        int     *       tab;
        unsigned        cnt = emitTrkVarCnt;
        unsigned        num;

        /* Test all the tracked variable bits in the mask */

        for (num = 0, tab = emitGCrFrameOffsTab;
             num < cnt;
             num++  , tab++)
        {
            int         val = *tab;

            if  (val != -1)
            {
                // byref_OFFSET_FLAG and this_OFFSET_FLAG are set
                //  in the table-offsets for byrefs and this-ptr

                int     offs = val & ~OFFSET_MASK;

//              printf("var #%2u at %3d is now %s\n", num, offs, (vars & 1) ? "live" : "dead");

                if  (vars & 1)
                {
                    GCtype  gcType = (val & byref_OFFSET_FLAG) ? GCT_BYREF
                                                               : GCT_GCREF;
                    emitGCvarLiveUpd(offs, INT_MAX, gcType, addr);
                }
                else
                {
                    emitGCvarDeadUpd(offs,         addr);
                }
            }

            vars >>= 1;
        }
    }

    emitThisGCrefVset = true;
}

/*****************************************************************************/

inline
unsigned            getU4(const BYTE * ptr)
{
#ifdef _X86_
    return * (unsigned *) ptr;
#else
    return ptr[0] + ptr[1]<<8 + ptr[2]<<16 + ptr[3]<<24;
#endif
}

/*****************************************************************************
 *
 *  Record a call location for GC purposes (we know that this is a method that
 *  will not be fully interruptible).
 */

void                emitter::emitRecordGCcall(BYTE * codePos)
{
    assert(!emitFullGCinfo);

    unsigned        offs = emitCurCodeOffs(codePos);
    unsigned        regs = (emitThisGCrefRegs|emitThisByrefRegs) & ~SRM_INTRET;
    callDsc     *   call;

    /* Bail if this is a totally boring call */

    if  (regs == 0)
    {
#if EMIT_TRACK_STACK_DEPTH
        if  (emitCurStackLvl == 0)
            return;
#endif
        /* Nope, only interesting calls get recorded */

        if  (emitSimpleStkUsed)
            if  (!emitSimpleStkMask)
                return;
        else
            if (emitGcArgTrackCnt == 0)
                return;
    }

#ifdef  DEBUG

    if  (VERBOSE||(disAsm&&0))
    {
        printf("; Call at %04X[stk=%u] gcrefRegs [", offs, emitCurStackLvl);
        emitDispRegSet(emitThisGCrefRegs & ~SRM_INTRET, true);
        printf(" byrefRegs [");
        emitDispRegSet(emitThisByrefRegs & ~SRM_INTRET, true);
        printf("] GCvars: ");
        emitDispVarSet();
        printf("\n");
    }

#endif

    /* Allocate a 'call site' descriptor and start filling it in */

    call = (callDsc *)emitComp->compGetMem(sizeof(*call));

    call->cdBlock         = NULL;
    call->cdOffs          = offs;

    call->cdGCrefRegs     = emitThisGCrefRegs;
    call->cdByrefRegs     = emitThisByrefRegs;
#if EMIT_TRACK_STACK_DEPTH
    call->cdArgBaseOffset = emitCurStackLvl / sizeof(int);
#endif

    /* Append the call descriptor to the list */

    emitComp->gcCallDescLast->cdNext = call;
    emitComp->gcCallDescLast         = call;

    /* Record the current "pending" argument list */

    if  (emitSimpleStkUsed)
    {
        /* The biggest call is less than MAX_SIMPLE_STK_DEPTH. So use
           small format */

        call->cdArgMask         = emitSimpleStkMask;
        call->cdByrefArgMask    = emitSimpleByrefStkMask;
        call->cdArgCnt          = 0;
    }
    else
    {
        // CONSIDER : If the number of pending arguments at this call-site
        // CONSIDER : is less than MAX_SIMPLE_STK_DEPTH, we could still
        // CONSIDER : use the mask.

        /* The current call has too many arguments, so we need to report the
           offsets of each individual GC arg. */

        call->cdArgCnt      = emitGcArgTrackCnt;
        if (call->cdArgCnt == 0)
        {
            call->cdArgMask         =
            call->cdByrefArgMask    = 0;
            return;
        }

        call->cdArgTable    = (unsigned *)emitComp->compGetMem(emitGcArgTrackCnt*sizeof(unsigned));

        unsigned gcArgs = 0;
        unsigned stkLvl = emitCurStackLvl/sizeof(int);

        for (unsigned i = 0; i < stkLvl; i++)
        {
            GCtype  gcType = (GCtype)emitArgTrackTab[stkLvl-i-1];

            if (needsGC(gcType))
            {
                call->cdArgTable[gcArgs] = i * sizeof(void*);

                if (gcType == GCT_BYREF)
                {
                    call->cdArgTable[gcArgs] |= byref_OFFSET_FLAG;
                }

                gcArgs++;
            }
        }

        assert(gcArgs == emitGcArgTrackCnt);
    }

    return;
}

/*****************************************************************************
 *
 *  Record a new set of live GC ref registers.
 */

void                emitter::emitUpdateLiveGCregs(GCtype    gcType,
                                                  unsigned  regs,
                                                  BYTE *    addr)
{
    unsigned        life;
    unsigned        dead;
    unsigned        chg;

//  printf("New GC ref live regs=%04X [", regs); emitDispRegSet(regs); printf("]\n");

    assert(needsGC(gcType));

    unsigned & emitThisXXrefRegs = (gcType == GCT_GCREF) ? emitThisGCrefRegs
                                                         : emitThisByrefRegs;
    unsigned & emitThisYYrefRegs = (gcType == GCT_GCREF) ? emitThisByrefRegs
                                                         : emitThisGCrefRegs;
    assert(emitThisXXrefRegs != regs);

    if  (emitFullGCinfo)
    {
        /* Figure out which GC registers are becoming live/dead at this point */

        dead = ( emitThisXXrefRegs & ~regs);
        life = (~emitThisXXrefRegs &  regs);

        /* Can't simultaneously become live and dead at the same time */

        assert((dead | life) != 0);
        assert((dead & life) == 0);

        /* Compute the 'changing state' mask */

        chg = (dead | life);

        do
        {
            unsigned            bit = genFindLowestBit(chg);
            emitRegs           reg = emitRegNumFromMask(bit);

            if  (life & bit)
                emitGCregLiveUpd(gcType, reg, addr);
            else
                emitGCregDeadUpd(reg, addr);

            chg -= bit;
        }
        while (chg);

        assert(emitThisXXrefRegs == regs);
    }
    else
    {
        emitThisYYrefRegs &= ~regs; // Kill the regs from the other GC type (if live)

        emitThisXXrefRegs =   regs; // Mark them as live in the requested GC type
    }

    // The 2 GC reg masks cant be overlapping

    assert((emitThisGCrefRegs & emitThisByrefRegs) == 0);
}

/*****************************************************************************
 *
 *  Record the fact that the given register now contains a live GC ref.
 */

void                emitter::emitGCregLiveSet(GCtype    gcType,
                                              unsigned  regMask,
                                              BYTE *    addr,
                                              bool      isThis)
{
    assert(needsGC(gcType));

    regPtrDsc  *    regPtrNext;

//  assert(emitFullyInt || isThis);
    assert(emitFullGCinfo);

    assert(((emitThisGCrefRegs|emitThisByrefRegs) & regMask) == 0);

    /* Allocate a new regptr entry and fill it in */

    regPtrNext                     = emitComp->gcRegPtrAllocDsc();
    regPtrNext->rpdGCtype          = gcType;

    regPtrNext->rpdOffs            = emitCurCodeOffs(addr);
    regPtrNext->rpdArg             = FALSE;
    regPtrNext->rpdCall            = FALSE;
    regPtrNext->rpdIsThis          = isThis;
    regPtrNext->rpdCompiler.rpdAdd = regMask;
    regPtrNext->rpdCompiler.rpdDel = 0;
}

/*****************************************************************************
 *
 *  Record the fact that the given register no longer contains a live GC ref.
 */

void                emitter::emitGCregDeadSet(GCtype    gcType,
                                              unsigned  regMask,
                                              BYTE *    addr)
{
    assert(needsGC(gcType));

    regPtrDsc  *    regPtrNext;

//  assert(emitFullyInt);
    assert(emitFullGCinfo);

    assert(((emitThisGCrefRegs|emitThisByrefRegs) & regMask) != 0);

    /* Allocate a new regptr entry and fill it in */

    regPtrNext                     = emitComp->gcRegPtrAllocDsc();
    regPtrNext->rpdGCtype          = gcType;

    regPtrNext->rpdOffs            = emitCurCodeOffs(addr);
    regPtrNext->rpdCall            = FALSE;
    regPtrNext->rpdIsThis          = FALSE;
    regPtrNext->rpdArg             = FALSE;
    regPtrNext->rpdCompiler.rpdAdd = 0;
    regPtrNext->rpdCompiler.rpdDel = regMask;
}

/*****************************************************************************/
#if EMIT_TRACK_STACK_DEPTH
/*****************************************************************************
 *
 *  Record a push of a single word on the stack for a full pointer map.
 */

void                emitter::emitStackPushLargeStk (BYTE *    addr,
                                                    GCtype    gcType,
                                                    unsigned  count)
{
    unsigned        level = emitCurStackLvl / sizeof(int);

    assert(IsValidGCtype(gcType));
    assert(count);
    assert(!emitSimpleStkUsed);

    do
    {
        /* Push an entry for this argument on the tracking stack */

//      printf("Pushed [%d] at lvl %2u [max=%u]\n", isGCref, emitArgTrackTop - emitArgTrackTab, emitMaxStackDepth);

        assert(emitArgTrackTop == emitArgTrackTab + level);
              *emitArgTrackTop++ = (BYTE)gcType;
        assert(emitArgTrackTop <= emitArgTrackTab + emitMaxStackDepth);

        if (!emitEBPframe || needsGC(gcType))
        {
            if  (emitFullGCinfo)
            {
                /* Append an "arg push" entry if this is a GC ref or
                   FPO method. Allocate a new ptr arg entry and fill it in */

                regPtrDsc  * regPtrNext = emitComp->gcRegPtrAllocDsc();
                regPtrNext->rpdGCtype   = gcType;

                regPtrNext->rpdOffs     = emitCurCodeOffs(addr);
                regPtrNext->rpdArg      = TRUE;
                regPtrNext->rpdCall     = FALSE;
                regPtrNext->rpdPtrArg   = level;
                regPtrNext->rpdArgType  = (unsigned short)Compiler::rpdARG_PUSH;
                regPtrNext->rpdIsThis   = FALSE;

#ifdef  DEBUG
                if  (verbose||0) printf(" %08X  %s arg push %u\n",
                                        regPtrNext, GCtypeStr(gcType), level);
#endif
            }

            /* This is an "interesting" argument push */

            emitGcArgTrackCnt++;
        }
    }
    while (++level, --count);
}

/*****************************************************************************
 *
 *  Record a pop of the given number of words from the stack for a full ptr
 *  map.
 */

void                emitter::emitStackPopLargeStk(BYTE *    addr,
                                                  bool      isCall,
                                                  unsigned  count)
{
    unsigned        argStkCnt;
    unsigned        argRecCnt;  // arg count for ESP, ptr-arg count for EBP
    unsigned        gcrefRegs, byrefRegs;

    assert(!emitSimpleStkUsed);

    /* Count how many pointer records correspond to this "pop" */

    for (argStkCnt = count, argRecCnt = 0;
         argStkCnt;
         argStkCnt--)
    {
        assert(emitArgTrackTop > emitArgTrackTab);

        GCtype      gcType = (GCtype)(*--emitArgTrackTop);

        assert(IsValidGCtype(gcType));

//      printf("Popped [%d] at lvl %u\n", GCtypeStr(gcType), emitArgTrackTop - emitArgTrackTab);

        // This is an "interesting" argument

        if  (!emitEBPframe || needsGC(gcType))
            argRecCnt++;
    }

    assert(emitArgTrackTop >= emitArgTrackTab);
    assert(emitArgTrackTop == emitArgTrackTab + emitCurStackLvl / sizeof(int) - count);

    /* We're about to pop the corresponding arg records */

    emitGcArgTrackCnt -= argRecCnt;

    if (!emitFullGCinfo)
        return;

    /* Do we have any interesting registers live here? */

    gcrefRegs =
    byrefRegs = 0;

#if TGT_x86
    if  (emitThisGCrefRegs & RBM_EDI) gcrefRegs |= 0x01;
    if  (emitThisGCrefRegs & RBM_ESI) gcrefRegs |= 0x02;
    if  (emitThisGCrefRegs & RBM_EBX) gcrefRegs |= 0x04;
    if  (emitThisGCrefRegs & RBM_EBP) gcrefRegs |= 0x08;

    if  (emitThisByrefRegs & RBM_EDI) byrefRegs |= 0x01;
    if  (emitThisByrefRegs & RBM_ESI) byrefRegs |= 0x02;
    if  (emitThisByrefRegs & RBM_EBX) byrefRegs |= 0x04;
    if  (emitThisByrefRegs & RBM_EBP) byrefRegs |= 0x08;
#else
    assert(!"need non-x86 code");
#endif

    /* Are there any args to pop at this call site? */

    if  (argRecCnt == 0)
    {
        /*
            Or do we have a partially interruptible EBP-less frame, and any
            of EDI,ESI,EBX,EBP are live, or is there an outer/pending call?
         */

#if !FPO_INTERRUPTIBLE
        if  (emitFullyInt ||
             (gcrefRegs == 0 && byrefRegs == 0 && emitGcArgTrackCnt == 0))
#endif
            return;
    }

    /* Only calls may pop more than one value */

    if  (argRecCnt > 1)
        isCall = true;

    /* Allocate a new ptr arg entry and fill it in */

    regPtrDsc * regPtrNext      = emitComp->gcRegPtrAllocDsc();
    regPtrNext->rpdGCtype       = GCT_GCREF; // Pops need a non-0 value (??)

    regPtrNext->rpdOffs         = emitCurCodeOffs(addr);
    regPtrNext->rpdCall         = isCall;
    regPtrNext->rpdCallGCrefRegs= gcrefRegs;
    regPtrNext->rpdCallByrefRegs= byrefRegs;
    regPtrNext->rpdArg          = TRUE;
    regPtrNext->rpdArgType      = (unsigned short)Compiler::rpdARG_POP;
    regPtrNext->rpdPtrArg       = argRecCnt;

#ifdef  DEBUG
    if  (verbose||0) printf(" %08X  ptr arg pop  %u\n", regPtrNext, count);
#endif

}


/*****************************************************************************
 *  For caller-pop arguments, we report the arguments as pending arguments.
 *  However, any GC arguments are now dead, so we need to report them
 *  as non-GC.
 */

void            emitter::emitStackKillArgs(BYTE *addr, unsigned   count)
{
    assert(count > 0);

    if (emitSimpleStkUsed)
    {
        assert(!emitFullGCinfo); // Simple stk not used for emitFullGCInfo

        /* We dont need to report this to the GC info, but we do need
           to kill mark the ptrs on the stack as non-GC */

        assert(emitCurStackLvl/sizeof(int) >= count);

        for(unsigned lvl = 0; lvl < count; lvl++)
        {
            emitSimpleStkMask      &= ~(1 << lvl);
            emitSimpleByrefStkMask &= ~(1 << lvl);
        }
    }
    else
    {
        BYTE *          argTrackTop = emitArgTrackTop;
        unsigned        gcCnt = 0;

        for (unsigned i = 0; i < count; i++)
        {
            assert(argTrackTop > emitArgTrackTab);

            --argTrackTop;

            GCtype      gcType = (GCtype)(*argTrackTop);
            assert(IsValidGCtype(gcType));

            if (needsGC(gcType))
            {
//              printf("Killed %s at lvl %u\n", GCtypeStr(gcType), argTrackTop - emitArgTrackTab);

                *argTrackTop = GCT_NONE;
                gcCnt++;
            }
        }

        /* We're about to kill the corresponding (pointer) arg records */

        if (emitEBPframe)
            emitGcArgTrackCnt -= gcCnt;

        if (!emitFullGCinfo)
            return;

        /* Right after the call, the arguements are still sitting on the
           stack, but they are effectively dead. For fully-interruptible
           methods, we need to report that */

        if (emitFullGCinfo && gcCnt)
        {
            /* Allocate a new ptr arg entry and fill it in */

            regPtrDsc * regPtrNext      = emitComp->gcRegPtrAllocDsc();
            regPtrNext->rpdGCtype       = GCT_GCREF; // Kills need a non-0 value (??)

            regPtrNext->rpdOffs         = emitCurCodeOffs(addr);

            regPtrNext->rpdArg          = TRUE;
            regPtrNext->rpdArgType      = (unsigned short)Compiler::rpdARG_KILL;
            regPtrNext->rpdPtrArg       = gcCnt;

#ifdef  DEBUG
            if  (verbose||0) printf(" %08X  ptr arg kill %u\n", regPtrNext, count);
#endif
        }

        /* Now that ptr args have been marked as non-ptrs, we need to record
           the call itself as one that has no arguments. */

        emitStackPopLargeStk(addr, true, 0);
    }
}

/*****************************************************************************/
#endif//EMIT_TRACK_STACK_DEPTH
/*****************************************************************************/
#endif//TRACK_GC_REFS
/*****************************************************************************/
#endif//!TGT_IA64
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emit.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EMIT_H_
#define _EMIT_H_
/*****************************************************************************/
#include "emitTgt.h"
/*****************************************************************************/
#ifndef _INSTR_H_
#include "instr.h"
#endif
/*****************************************************************************/
#ifndef _GCINFO_H_
#include "GCInfo.h"
#endif
/*****************************************************************************/
#ifdef  TRANSLATE_PDB
#ifndef _ADDRMAP_INCLUDED_
#include "AddrMap.h"
#endif
#ifndef _LOCALMAP_INCLUDED_
#include "LocalMap.h"
#endif
#ifndef _PDBREWRITE_H_
#include "PDBRewrite.h"
#endif
#endif // TRANSLATE_PDB
/*****************************************************************************/
#pragma warning(disable:4200)           // allow arrays of 0 size inside structs

#define TRACK_GC_TEMP_LIFETIMES 0

/*****************************************************************************/

#ifndef TRACK_GC_REFS
#if     TGT_x86
#define TRACK_GC_REFS       1
#else
#define TRACK_GC_REFS       0
#endif
#endif

/*****************************************************************************/

#ifdef  DEBUG
#define EMITTER_STATS       0           // to get full stats (but no sizes!)
#define EMITTER_STATS_RLS   0           // don't use this one
#else
#define EMITTER_STATS       0           // don't use this one
#define EMITTER_STATS_RLS   0           // to get retail-only version of stats
#endif

#ifdef  NOT_JITC
#undef  EMITTER_STATS
#define EMITTER_STATS       0
#endif

#if     EMITTER_STATS
void                emitterStats();
#endif

/*****************************************************************************/

#if     TGT_IA64
#undef  USE_LCL_EMIT_BUFF
#else
#define USE_LCL_EMIT_BUFF   1
#endif

/*****************************************************************************/

enum    GCtype
{
    GCT_NONE,
    GCT_GCREF,
    GCT_BYREF
};

//-----------------------------------------------------------------------------

inline
bool    needsGC(GCtype gcType)
{
    if (gcType == GCT_NONE)
    {
        return false;
    }
    else
    {
        assert(gcType == GCT_GCREF || gcType == GCT_BYREF);
        return true;
    }
}

//-----------------------------------------------------------------------------

#ifdef DEBUG

inline
bool                IsValidGCtype(GCtype gcType)
{
    return (gcType == GCT_NONE  ||
            gcType == GCT_GCREF ||
            gcType == GCT_BYREF);
}

// Get a string name to represent the GC type

inline
const char *        GCtypeStr(GCtype gcType)
{
    switch(gcType)
    {
    case GCT_NONE:      return "npt";
    case GCT_GCREF:     return "gcr";
    case GCT_BYREF:     return "byr";
    default:            assert(!"Invalid GCtype"); return "err";
    }
}

#endif

/*****************************************************************************/

#ifdef  DEBUG
#define INTERESTING_JUMP_NUM    (1*999999)  // set to 0 to see all jump info
#ifdef  NOT_JITC
#undef  INTERESTING_JUMP_NUM
#define INTERESTING_JUMP_NUM    -1
#endif
#endif

/*****************************************************************************/

#define DEFINE_ID_OPS
#include "emitfmts.h"
#undef  DEFINE_ID_OPS

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************/

#if     TGT_x86
#define SCHED_INS_CNT_MIN   5                   //  x86: min. # of instrs we schedule
#elif   TGT_IA64
#define SCHED_INS_CNT_MIN   2                   // IA64: min. # of instrs we schedule
#else
#define SCHED_INS_CNT_MIN   3                   // RISC: min. # of instrs we schedule
#endif

#if     TGT_IA64
#define SCHED_INS_CNT_MAX   128                 // max. # of instrs we schedule
#else
#define SCHED_INS_CNT_MAX   64                  // max. # of instrs we schedule
#endif

#if     SCHED_INS_CNT_MAX > 64

typedef bitset128           schedDepMap_tp;     // must match SCHED_INS_CNT_MAX
typedef unsigned char       schedInsCnt_tp;     // big enough to hold ins count

inline  bool    schedDepIsZero(schedDepMap_tp mask) { return bitset128iszero(mask); }
inline  bool    schedDepIsNonZ(schedDepMap_tp mask) { return!bitset128iszero(mask); }

inline  void    schedDepClear (schedDepMap_tp *dst) { bitset128clear(dst); }
inline  void    schedDepClear (schedDepMap_tp *dst,
                               schedDepMap_tp  rmv) { bitset128clear(dst, rmv); }
inline  bool    schedDepOvlp  (schedDepMap_tp  op1,
                               schedDepMap_tp  op2) { return bitset128ovlp(op1, op2); }
inline  NatUns  schedDepLowX  (schedDepMap_tp mask) { return bitset128lowest1(mask); }

#else

typedef unsigned __int64    schedDepMap_tp;     // must match SCHED_INS_CNT_MAX
typedef unsigned char       schedInsCnt_tp;     // big enough to hold ins count

inline  bool    schedDepIsZero(schedDepMap_tp mask) { return (mask == 0); }
inline  bool    schedDepIsNonZ(schedDepMap_tp mask) { return (mask != 0); }

inline  void    schedDepClear (schedDepMap_tp *dst) { *dst = 0; }
inline  void    schedDepClear (schedDepMap_tp *dst,
                               schedDepMap_tp  rmv) { *dst &= ~rmv; }
inline  bool    schedDepOvlp  (schedDepMap_tp  op1,
                               schedDepMap_tp  op2) { return ((op1 & op2) != 0);    }
inline  NatUns  schedDepLowX  (schedDepMap_tp mask) { return genLog2(genFindLowestBit(mask)) - 1; }

#endif

#define SCHED_FRM_CNT_MAX   32                  // max. frame values we track

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/
#if !   TGT_IA64
/*****************************************************************************
 *
 *  The actual size is in the low 4 bits, the upper 4 bits are flags
 *  TYP_REF is 4+32 and TYP_BYREF is 4+64 so that it can track GC refs.
 */

#if NEW_EMIT_ATTR
#undef EA_UNKNOWN
enum emitAttr { EA_UNKNOWN       = 0x000,
                EA_1BYTE         = 0x001,
                EA_2BYTE         = 0x002,
                EA_4BYTE         = 0x004,
                EA_8BYTE         = 0x008,
                EA_OFFSET_FLG    = 0x010,
                EA_OFFSET        = 0x014,       /* size ==  0 */
                EA_GCREF_FLG     = 0x020,
                EA_GCREF         = 0x024,       /* size == -1 */
                EA_BYREF_FLG     = 0x040,
                EA_BYREF         = 0x044,       /* size == -2 */
                EA_DSP_RELOC_FLG = 0x100,
                EA_CNS_RELOC_FLG = 0x200,
};
# define EA_ATTR(x)          ((emitAttr) (x))
# define EA_SIZE(x)          ((emitAttr) ( ((unsigned) (x)) &  0x00f)      )
# define EA_SIZE_IN_BYTES(x) ((size_t)   ( ((unsigned) (x)) &  0x00f)      )
# define EA_SET_SIZE(x,sz)   ((emitAttr) ((((unsigned) (x)) & ~0x00f) | sz))
# define EA_SET_FLG(x,flg)   ((emitAttr) ( ((unsigned) (x)) |  flg  )      )
# define EA_4BYTE_DSP_RELOC  (EA_SET_FLG(EA_4BYTE,EA_DSP_RELOC_FLG)        )
# define EA_4BYTE_CNS_RELOC  (EA_SET_FLG(EA_4BYTE,EA_CNS_RELOC_FLG)        )
# define EA_IS_OFFSET(x)     ((((unsigned) (x)) & ((unsigned) EA_OFFSET_FLG)) != 0)
# define EA_IS_GCREF(x)      ((((unsigned) (x)) & ((unsigned) EA_GCREF_FLG )) != 0)
# define EA_IS_BYREF(x)      ((((unsigned) (x)) & ((unsigned) EA_BYREF_FLG )) != 0)
# define EA_IS_DSP_RELOC(x)  ((((unsigned) (x)) & ((unsigned) EA_DSP_RELOC_FLG )) != 0)
# define EA_IS_CNS_RELOC(x)  ((((unsigned) (x)) & ((unsigned) EA_CNS_RELOC_FLG )) != 0)
#else
# undef  emitAttr
# define emitAttr            int
# define EA_1BYTE            (sizeof(char))
# define EA_2BYTE            (sizeof(short))
# define EA_4BYTE            (sizeof(int))
# define EA_8BYTE            (sizeof(double))
# define EA_OFFSET           (0)
# define EA_GCREF            (-1)
# define EA_BYREF            (-2)
# define EA_DSP_RELOC_FLG    (0)             /* Can't be done */
# define EA_DSP_RELOC        (EA_4BYTE)      /* Can't be done */
# define EA_CNS_RELOC_FLG    (0)             /* Can't be done */
# define EA_CNS_RELOC        (EA_4BYTE)      /* Can't be done */
# define EA_ATTR(x)          ((emitAttr) (x))
# define EA_SIZE(x)          (((x) > 0) ? (x) : EA_4BYTE)
# define EA_SIZE_IN_BYTES(x) ((size_t) (((x) > 0) ? (x) : sizeof(int)))
# define EA_SET_SIZE(x,sz)   (sz)
# define EA_SET_FLG(x,flg)   ((x) | flg)
# define EA_IS_OFFSET(x)     ((x) ==  0)
# define EA_IS_GCREF(x)      ((x) == -1)
# define EA_IS_BYREF(x)      ((x) == -2)
# define EA_IS_DSP_RELOC(x)  (0)             /* Can't be done */
# define EA_IS_CNS_RELOC(x)  (0)             /* Can't be done */
#endif

class   emitter
{
    friend  class   Compiler;

public:

    /*************************************************************************
     *
     *  Define the public entry points.
     */

    #include "emitpub.h"

protected:

    /************************************************************************/
    /*                        Miscellaneous stuff                           */
    /************************************************************************/

    Compiler    *   emitComp;

    typedef Compiler::varPtrDsc varPtrDsc;
    typedef Compiler::regPtrDsc regPtrDsc;
    typedef Compiler::CallDsc   callDsc;

#if USE_LCL_EMIT_BUFF

    static
   CRITICAL_SECTION emitCritSect;
    static
    bool            emitCrScInit;
    static
    bool            emitCrScBusy;

    bool            emitCrScUsed;

    static
    BYTE            emitLclBuff[];

    BYTE    *       emitLclBuffNxt;
    BYTE    *       emitLclBuffEnd;
    bool            emitLclBuffDst;

    size_t          emitLclAvailMem()
    {
        return  emitLclBuffEnd - emitLclBuffNxt;
    }

    void    *       emitLclAllocMem(size_t sz)
    {
        BYTE    *   p = emitLclBuffNxt;

        assert(sz % sizeof(int) == 0);
        assert(p + sz <= emitLclBuffEnd);

        emitLclBuffNxt  += sz;

#if EMITTER_STATS
        emitTotMemAlloc += sz;
        emitLclMemAlloc += sz;
#endif

        return  p;
    }

    void    *       emitGetAnyMem(size_t sz)
    {
        return  (sz <= emitLclAvailMem()) ? emitLclAllocMem(sz)
                                          :      emitGetMem(sz);
    }

#else

    void    *       emitGetAnyMem(size_t sz)
    {
        return  emitGetMem(sz);
    }

#endif

    inline
    void    *       emitGetMem(size_t sz)
    {
        assert(sz % sizeof(int) == 0);

#if EMITTER_STATS
        emitTotMemAlloc += sz;
        emitExtMemAlloc += sz;
#endif

        return  emitComp->compGetMem(sz);
    }

    static
    BYTE            emitSizeEnc[];
    static
    BYTE            emitSizeDec[];

    static
    unsigned        emitEncodeSize(emitAttr size);
    static
    emitAttr        emitDecodeSize(unsigned ensz);

#if     TRACK_GC_REFS

    static
    regMaskSmall    emitRegMasks[REG_COUNT];

    inline
    regMaskTP       emitRegMask(emitRegs reg)
    {
        assert(reg < sizeof(emitRegMasks)/sizeof(emitRegMasks[0]));

        return emitRegMasks[reg];
    }

    emitRegs       emitRegNumFromMask(unsigned mask);

#endif

    /************************************************************************/
    /*          The following describes an instruction group                */
    /************************************************************************/

    struct          insGroup
    {
        insGroup    *   igPrev;         // all instruction groups are
        insGroup    *   igNext;         // kept in a doubly-linked list

#ifdef  DEBUG
        insGroup    *   igSelf;         // for consistency checking
#endif

        unsigned        igOffs;         // offset of this group within method

#if     EMIT_USE_LIT_POOLS
        unsigned short  igLPuse1stW;    // offset of 1st word use in literal pool
        unsigned short  igLPuse1stL;    // offset of 1st long use in literal pool
        unsigned short  igLPuse1stA;    // offset of 1st addr use in literal pool
        unsigned short  igLPuseCntW;    // number of words used   in literal pool
        unsigned short  igLPuseCntL;    // number of longs used   in literal pool
        unsigned short  igLPuseCntA;    // number of addrs used   in literal pool
#endif

        unsigned short  igNum;          // for ordering (and display) purposes
        unsigned short  igSize;         // # of bytes of code in this group

#if     EMIT_TRACK_STACK_DEPTH
        unsigned short   igStkLvl;       // stack level on entry
#endif

#if     TRACK_GC_REFS
        regMaskSmall    igGCregs;       // set of registers with live GC refs
#endif

        unsigned char   igInsCnt;       // # of instructions  in this group
        unsigned char   igFlags;        // see IGF_xxx below

    #define IGF_GC_VARS     0x0001      // new set of live GC ref variables
    #define IGF_BYREF_REGS  0x0002      // new set of live by-ref registers

    #define IGF_IN_TRY      0x0004      // this group is in a try(-catch) block

    #define IGF_EPILOG      0x0008      // this group belongs to the epilog

    #define IGF_HAS_LABEL   0x0010      // this IG is a target of a jump

    #define IGF_UPD_ISZ     0x0020      // some instruction sizes updated

    #define IGF_END_NOREACH 0x0040      // end of group is not reachable [RISC only]

    #define IGF_EMIT_ADD    0x0080      // this is a block added by the emiter
                                        // because the codegen block was too big

        BYTE    *       igData;         // addr of instruction descriptors

        unsigned        igByrefRegs()
        {
            assert(igFlags & IGF_BYREF_REGS);

            BYTE * ptr = (BYTE *)igData;

            if (igFlags & IGF_GC_VARS)
                ptr -= sizeof(VARSET_TP);

            ptr -= sizeof(unsigned);

            return *(unsigned *)ptr;
        }

    };

    // Currently, we only allow one IG for the prolog
    bool            emitIGisInProlog(insGroup * ig) { return ig == emitPrologIG; }

#if SCHEDULER
    bool            emitCanSchedIG(insGroup * ig)
    {
        // @TODO: We dont schedule code in "try" blocks. Do it by recording
        // dependancies between idMayFault instrs, global variable instrs,
        // indirections, writes to vars which are live on entry to the handler
        // (approximated currently by all stack variables), etc.
#if TGT_x86
        return ((!emitIGisInProlog(ig)) && ((ig->igFlags & (IGF_IN_TRY|IGF_EPILOG)) == 0));
#else
        return ((!emitIGisInProlog(ig)) && ((ig->igFlags & (IGF_IN_TRY           )) == 0));
#endif
    }
#endif

    void            emitRecomputeIGoffsets();

    /************************************************************************/
    /*          The following describes a single instruction                */
    /************************************************************************/

    enum            insFormats
    {
        #define IF_DEF(en, op1, op2) IF_##en,
        #include "emitfmts.h"
        #undef  IF_DEF

        IF_COUNT
    };

    struct          emitLclVarAddr
    {
        short           lvaVarNum;
        short           lvaOffset;  // offset into the variable to access
#ifdef  DEBUG
        unsigned        lvaRefOfs;
#endif
    };

    struct          instrDescCns;

    struct          instrDesc
    {
        /* Store as enums for easier debugging, bytes in retail to save size */

#ifdef  FAST
        unsigned char   idIns;
        unsigned char   idInsFmt;
#else
        instruction     idIns;
        insFormats      idInsFmt;
#endif

        instruction     idInsGet() { return (instruction)idIns; }

        /*
            The following controls which fields get automatically cleared
            when an instruction descriptor is allocated. If you add lots
            more fields that need to be cleared (such as various flags),
            you might need to update the ID_CLEARxxx macros. Right now
            there are two areas that get cleared; this is because some
            instruction descriptors get allocated very small and don't
            contain the second area.

            See the body of emitter::emitAllocInstr() for more details.
         */

#define ID_CLEAR1_OFFS  0               // idIns,idInsFmt, and the following flags
#define ID_CLEAR1_SIZE  sizeof(int)     // all of these add up to one 32-bit word

        /*
            The idReg and idReg2 fields hold the first and second register
            operand(s), whenever these are present. Note that the size of
            these fields ranges from 3 to 6 bits, and extreme care needs
            to be taken to make sure all of the fields stay reasonably
            aligned.
         */

        unsigned short  idReg       :REGNUM_BITS;
        unsigned short  idRg2       :REGNUM_BITS;

        unsigned short  idTinyDsc   :1; // is this a "tiny"        descriptor?
        unsigned short  idScnsDsc   :1; // is this a "small const" descriptor?

#if     TGT_x86
        unsigned short  idCodeSize  :4; // size of instruction in bytes
#define ID1_BITS1       (2*REGNUM_BITS+1+1+4)
#elif   TGT_ARM
        unsigned        cond        :CONDNUM_BITS;
#define ID1_BITS1       (2*REGNUM_BITS+1+1+CONDNUM_BITS)
#else
        unsigned short  idSwap      :1; // swap with next ins (branch-delay)
#define ID1_BITS1       (2*REGNUM_BITS+1+1+1)
#endif

        unsigned short  idOpSize    :2; // operand size: 0=1 , 1=2 , 2=4 , 3=8

#define OPSZ1   0
#define OPSZ2   1
#define OPSZ4   2
#define OPSZ8   3

#if     TRACK_GC_REFS
        unsigned short  idGCref     :2; // GCref operand? (value is a "GCtype")
#define ID1_BITS2       (ID1_BITS1+2+2)
#else
#define ID1_BITS2       (ID1_BITS1+2)
#endif

        /* Note: (16-ID1_BITS2) bits are available here "for free" */
        // PPC: for RISC implementations, this is actually 32-ID1_BITS2 for free

#ifdef  DEBUG

        unsigned        idNum;          // for tracking down problems
        size_t          idSize;         // size of descriptor
        unsigned        idSrcLineNo;    // for displaying  source code

        int             idMemCookie;    // for display of member names in addr modes
        void    *       idClsCookie;    // for display of member names in addr modes

        unsigned short  idStrLit    :1; // set for "push offset string"
#endif

        /* Trivial wrappers to return properly typed enums */

        emitRegs        idRegGet     ()  { return (emitRegs)idReg; }
        emitRegs        idRg2Get     ()  { return (emitRegs)idRg2; }
        bool            idIsTiny     ()  { return (bool) idTinyDsc; }
        bool            idIsSmallCns ()  { return (bool) idScnsDsc; }
#if     TRACK_GC_REFS
        GCtype          idGCrefGet   ()  { return (GCtype)idGCref; }
#endif

#ifdef  TRANSLATE_PDB

        /* instruction descriptor source information for PDB translation */

        unsigned long   idilStart;
#endif

        /* NOTE: The "tiny" descriptor ends here */

#define TINY_IDSC_SIZE  offsetof(emitter::instrDesc, idInfo)

        struct
        {
            unsigned        idLargeCns  :1; // does a large constant     follow?
            unsigned        idLargeDsp  :1; // does a large displacement follow?

            unsigned        idLargeCall :1; // large call descriptor used

            unsigned        idMayFault  :1; // instruction may cause a fault

            unsigned        idBound     :1; // jump target / frame offset bound

            #define ID2_BITS1       5       // number of bits taken up so far

#if   TGT_x86
            unsigned        idCallRegPtr:1; // IL indirect calls: addr in reg
            unsigned        idCallAddr  :1; // IL indirect calls: can make a direct call to iiaAddr
#ifndef RELOC_SUPPORT
            #define ID2_BITS2       (ID2_BITS1+1+1)
#else
            unsigned        idCnsReloc  :1; // LargeCns is an RVA and needs reloc tag
            unsigned        idDspReloc  :1; // LargeDsp is an RVA and needs reloc tag
            #define ID2_BITS2       (ID2_BITS1+1+1+1+1)
#endif
#elif TGT_MIPS32
            unsigned        idRg3       :REGNUM_BITS;
#  if TGT_MIPSFP
#  define FPFORMAT_BITS 5
            unsigned        idFPfmt     :FPFORMAT_BITS;
            #define ID2_BITS2       (ID2_BITS1 + REGNUM_BITS + FPFORMAT_BITS)
#  else
            #define ID2_BITS2       (ID2_BITS1 + REGNUM_BITS)
#  endif
#elif TGT_PPC
            unsigned        idRg3       :REGNUM_BITS;
            unsigned        idBit1      :1;
            unsigned        idBit2      :1;
            #define ID2_BITS2       (ID2_BITS1 + REGNUM_BITS + 1 + 1)
#elif TGT_ARM
            unsigned        idRg3       :REGNUM_BITS;
            //unsigned        cond        :CONDNUM_BITS;  // moved to tiny descriptor area
            unsigned        shift       :SHIFTER_BITS;
            #define ID2_BITS2       (ID2_BITS1 + REGNUM_BITS + SHIFTER_BITS + CONDNUM_BITS)
#elif TGT_SH3
            unsigned        idRelocType :2;
            #define ID2_BITS2       (ID2_BITS1 + 2)
#else
            #define ID2_BITS2       (ID2_BITS1)
#endif

            /* Use whatever bits are left over for small constants */

            #define ID_BIT_SMALL_CNS            (32-ID2_BITS2)

            unsigned        idSmallCns  :ID_BIT_SMALL_CNS;

            #define ID_MIN_SMALL_CNS            0
            #define ID_MAX_SMALL_CNS            ((1<<ID_BIT_SMALL_CNS)-1U)
        }
                        idInfo;

#if TGT_MIPS32
        emitRegs        idRg3MayGet ()  { return (idIsTiny()) ? SR_ZERO : idRg3Get();}
#endif
#if TGT_MIPS32 || TGT_ARM
        emitRegs        idRg3Get    ()  { return (emitRegs) idInfo.idRg3; }
#elif TGT_PPC
        void   setField1(USHORT field1)  { idReg = field1; }
        USHORT getField1()               { return (USHORT)idReg; }
        void   setField2(USHORT field2)  { idRg2 = field2; }
        USHORT getField2()               { return (USHORT)idRg2; }
        void   setField3(USHORT field3)  { idInfo.idRg3 = field3; }
        USHORT getField3()               { return (USHORT)idInfo.idRg3; }
        void   setImmed(USHORT immed)    { idInfo.idSmallCns = immed; }
        USHORT getImmed()                { return (USHORT)idInfo.idSmallCns; }
        void   setOE(USHORT OE)          { idInfo.idBit1 = OE;}
        USHORT getOE()                   { return (USHORT)idInfo.idBit1; }
        void   setRc(USHORT Rc)          { idInfo.idBit2 = Rc;}
        USHORT getRc()                   { return (USHORT)idInfo.idBit2; }
        void   setAA(USHORT AA)          { idInfo.idBit1 = AA;}
        USHORT getAA()                   { return (USHORT)idInfo.idBit1; }
        void   setLK(USHORT LK)          { idInfo.idBit2 = LK;}
        USHORT getLK()                   { return (USHORT)idInfo.idBit2; }
        void   setRelocHi(USHORT reloc)  { idInfo.idBit1 = reloc;}
        USHORT getRelocHi()              { return (USHORT)idInfo.idBit1; }
        void   setRelocLo(USHORT reloc)  { idInfo.idBit2 = reloc;}
        USHORT getRelocLo()              { return (USHORT)idInfo.idBit2; }
#endif
         /*
            See the body of emitter::emitAllocInstr() or the comments
            near the definition ID_CLEAR1_xxx above for more details
            on these macros.
         */

#define ID_CLEAR2_OFFS  (offsetof(emitter::instrDesc, idInfo))
#define ID_CLEAR2_SIZE  (sizeof(((emitter::instrDesc*)0)->idInfo))

        /* NOTE: The "small constant" descriptor ends here */

#define SCNS_IDSC_SIZE  offsetof(emitter::instrDesc, idAddr)

        union
        {
            emitLclVarAddr  iiaLclVar;
            instrDescCns *  iiaNxtEpilog;
            BasicBlock   *  iiaBBlabel;
            insGroup     *  iiaIGlabel;
            FIELD_HANDLE    iiaFieldHnd;
            METHOD_HANDLE   iiaMethHnd;
            void         *  iiaMembHnd; // method or field handle
            BYTE *          iiaAddr;
            int             iiaCns;
            BasicBlock  **  iiaBBtable;

            ID_TGT_DEP_ADDR
        }
                        idAddr;
    };

    struct          instrBaseCns    : instrDesc     // large const
    {
        long            ibcCnsVal;
    };

    struct          instrDescJmp    : instrDesc
    {
        instrDescJmp *  idjNext;        // next jump in the group/method
        insGroup     *  idjIG;          // containing group

#if TGT_RISC
        unsigned        idjCodeSize :24;// indirect jump size
        unsigned        idjJumpKind : 3;// see scIndJmpKinds enum
#endif

        unsigned        idjOffs     :24;// offset within IG / target offset
#if SCHEDULER
        unsigned        idjSched    : 1;// is the jump schedulable / moveable ?
#endif
        unsigned        idjShort    : 1;// is the jump known to be a short  one?
#if TGT_RISC
        unsigned        idjMiddle   : 1;// is the jump known to be a middle one?
        unsigned        idjAddBD    : 1;// does it need a branch-delay slot?
#endif

        union
        {
            BYTE         *  idjAddr;    // address of jump ins (for patching)
#if SCHEDULER
            USHORT          idjOffs[2]; // range of possible scheduled offsets
#endif
#if TGT_RISC
            unsigned        idjCount;   // indirect jump: # of jump targets
#endif
        }
                        idjTemp;
    };

    struct          instrDescCns    : instrDesc     // large const
    {
        long            idcCnsVal;
    };

    struct          instrDescDsp    : instrDesc     // large displacement
    {
        long            iddDspVal;
    };

    struct          instrDescAmd    : instrDesc     // large addrmode disp
    {
        long            idaAmdVal;
    };

    struct          instrDescDspCns : instrDesc     // large disp + cons
    {
        long            iddcDspVal;
        long            iddcCnsVal;
    };

    struct          instrDescDCM    : instrDescDspCns   // disp+cons+class mem
    {
        int             idcmCval;
    };

    struct          instrDescCIGCA  : instrDesc     // indir. call with ...
    {
        VARSET_TP       idciGCvars;                 // ... updated GC vars or
        unsigned        idciByrefRegs;              // ... byref registers
#if TGT_x86
        int             idciDisp;                   // ... big addrmode disp
#endif
        unsigned        idciArgCnt;                 // ... lots of args    or
    };

  //#if TGT_RISC && defined(DEBUG) && !defined(NOT_JITC)
#if TGT_RISC && defined(DEBUG)

    struct          instrDescDisp   : instrDesc
    {
        void        *   iddInfo;
        unsigned        iddNum;
        instrDesc   *   iddId;
    };

    struct          dspJmpInfo
    {
        instruction     iijIns;
#if TGT_SH3
        emitIndJmpKinds iijKind;
#endif
        unsigned        iijLabel;
        unsigned        iijTarget;

        union
        {
            emitRegs        iijReg;
            int             iijDist;
        }
                        iijInfo;
    };

#define dispSpecialIns(id,dst) ((disAsm || dspEmit) ? (emitDispIns(id, false, dspGCtbls, true, emitCurCodeOffs(dst)), (id)->iddNum++) : (void)0)

#else

#define dispSpecialIns(id,dst)

#endif

    insUpdateModes  emitInsUpdateMode(instruction ins);
    insFormats      emitInsModeFormat(instruction ins, insFormats base);

    static
    BYTE            emitInsModeFmtTab[];
#ifdef  DEBUG
    static
    unsigned        emitInsModeFmtCnt;
#endif

    int             emitGetInsCns   (instrDesc *id);
    int             emitGetInsDsp   (instrDesc *id);
    int             emitGetInsAmd   (instrDesc *id);
    int             emitGetInsDspCns(instrDesc *id, int   *dspPtr);
    int             emitGetInsSC    (instrDesc *id);
    int             emitGetInsCIdisp(instrDesc *id);
    unsigned        emitGetInsCIargs(instrDesc *id);

    /* Define the inline method that returns the size of a given instruction */

    EMIT_GET_INS_SIZE();

    /************************************************************************/
    /*           A few routines used for debug display purposes             */
    /************************************************************************/

#ifdef  DEBUG

    unsigned        emitInsCount;

    unsigned        emitVarRefOffs;

    const   char *  emitRegName     (emitRegs       reg,
                                     emitAttr       size    = EA_4BYTE,
                                     bool           varName = true);
#if TGT_MIPSFP
    const   char *  emitFPRegName   (emitRegs       reg,
                                     emitAttr       size    = EA_4BYTE,
                                     bool           varName = true) {
                return emitRegName((emitRegs)(reg + 32), size, varName);
    }
#endif

    const   char *  emitFldName     (int            mem,
                                     void   *       cls);
    const   char *  emitFncName     (METHOD_HANDLE  callVal);

    static
    const char  *   emitIfName      (unsigned f);

    void            emitDispIGlist  (bool verbose = false);
    void            emitDispClsVar  (FIELD_HANDLE fldHnd, int offs, bool reloc = false);
    void            emitDispFrameRef(int varx, int offs, int disp, bool asmfm);

    void            emitDispInsOffs (unsigned offs, bool doffs);

#endif

    /************************************************************************/
    /*                      Method prolog and epilog                        */
    /************************************************************************/

    size_t          emitPrologSize;

    BYTE            emitEpilogCode[MAX_EPILOG_SIZE];
    size_t          emitEpilogSize;
    insGroup     *  emitEpilog1st;
    unsigned        emitEpilogCnt;
    bool            emitHasHandler;
#ifdef  DEBUG
    bool            emitHaveEpilog;         // epilog sequence has been defined?
#endif

    instrDescCns *  emitEpilogList;         // per method epilog list - head
    instrDescCns *  emitEpilogLast;         // per method epilog list - tail

    size_t          emitExitSeqSize;

    /************************************************************************/
    /*           Members and methods used in PDB translation                */
    /************************************************************************/

#ifdef TRANSLATE_PDB

    inline void     SetIDSource( instrDesc *pID );
    void            MapCode    ( long ilOffset, BYTE *imgDest );
    void            MapFunc    ( long imgOff,
                                 long procLen,
                                 long dbgStart,
                                 long dbgEnd,
                                 short frameReg,
                                 long stkAdjust,
                                 int lvaCount,
                                 OptJit::LclVarDsc *lvaTable,
                                 bool framePtr );

    long                        emitInstrDescILBase;    // code offset of IL that produced this instruction desctriptor
    static AddrMap  *           emitPDBOffsetTable;     // translation table for mapping IL addresses to native addresses
    static LocalMap *           emitPDBLocalTable;      // local symbol translation table
    static bool                 emitIsPDBEnabled;       // flag to disable PDB translation code when a PDB is not found
    static BYTE     *           emitILBaseOfCode;       // start of IL .text section
    static BYTE     *           emitILMethodBase;       // beginning of IL method (start of header)
    static BYTE     *           emitILMethodStart;      // beginning of IL method code (right after the header)
    static BYTE     *           emitImgBaseOfCode;      // start of the image .text section

#endif

    /************************************************************************/
    /*    Methods to record a code position and later convert to offset     *
    /************************************************************************/

    unsigned        emitFindOffset(insGroup *ig, unsigned insNum);

    /************************************************************************/
    /*        Members and methods used to issue (encode) instructions.      */
    /************************************************************************/

    BYTE    *       emitCodeBlock;
    BYTE    *       emitConsBlock;
    BYTE    *       emitDataBlock;

    BYTE    *       emitCurInsAdr;

    size_t          emitCurCodeOffs(BYTE *dst)
    {
        return  dst - emitCodeBlock;
    }

    size_t          emitCurCodeOffs()
    {
        return  emitCurInsAdr - emitCodeBlock;
    }

    size_t          emitOutputByte(BYTE *dst, int val);
    size_t          emitOutputWord(BYTE *dst, int val);
    size_t          emitOutputLong(BYTE *dst, int val);

    size_t          emitIssue1Instr(insGroup *ig, instrDesc *id, BYTE **dp);
    size_t          emitOutputInstr(insGroup *ig, instrDesc *id, BYTE **dp);

    bool            emitEBPframe;

    size_t          emitLclSize;
    size_t          emitMaxTmpSize;

    insGroup    *   emitCurIG;

#ifdef  DEBUG
    unsigned        emitLastSrcLine;
#endif

    bool            emitIsCondJump(instrDesc    *jmp);

    size_t          emitSizeOfJump(instrDescJmp *jmp);
    size_t          emitInstCodeSz(instrDesc    *id);

    /************************************************************************/
    /*      The logic that creates and keeps track of instruction groups    */
    /************************************************************************/
    #define         SC_IG_BUFFER_SIZE  (50*sizeof(instrDesc)+14*TINY_IDSC_SIZE)

    BYTE        *   emitIGbuffAddr;
    size_t          emitIGbuffSize;

    insGroup    *   emitIGlist;             // first  instruction group
    insGroup    *   emitIGlast;             // last   instruction group
    insGroup    *   emitIGthis;             // issued instruction group

    insGroup    *   emitPrologIG;           // prolog instruction group

    instrDescJmp*   emitJumpList;           // list of local jumps in method
    instrDescJmp*   emitJumpLast;           // last of local jumps in method

#if TGT_x86 || SCHEDULER
    bool            emitFwdJumps;           // forward jumps present?
#endif

#if TGT_RISC
    bool            emitIndJumps;           // indirect/table jumps present?
#if SCHEDULER
    bool            emitIGmoved;            // did some IG offsets change?
#endif
  //#if defined(DEBUG) && !defined(NOT_JITC)
#if defined(DEBUG)
    unsigned        emitTmpJmpCnt;          // for display purposes
#endif
#endif

    BYTE        *   emitCurIGfreeNext;      // next available byte    in buffer
    BYTE        *   emitCurIGfreeEndp;      // last available byte    in buffer
    BYTE        *   emitCurIGfreeBase;      // first byte address

#if SCHEDULER
    unsigned        emitMaxIGscdCnt;        // max. schedulable instructions
    unsigned        emitCurIGscd1st;        // ordinal of 1st schedulable ins
    unsigned        emitCurIGscdOfs;        // offset of current group start
#endif

    unsigned        emitCurIGinsCnt;        // # of collected instr's in buffer
    unsigned        emitCurIGsize;          // est. size of current group
    size_t          emitCurCodeOffset;      // current code offset within group

    size_t          emitTotalCodeSize;      // bytes of code in entire method

#if TGT_x86
    int             emitOffsAdj;            // current code offset adjustment
#endif

    instrDescJmp *  emitCurIGjmpList;       // list of jumps   in current IG
    instrDescCns *  emitCurIGEpiList;       // list of epilogs in current IG

#if TRACK_GC_REFS

    VARSET_TP       emitPrevGCrefVars;
    unsigned        emitPrevGCrefRegs;
    unsigned        emitPrevByrefRegs;

    VARSET_TP       emitInitGCrefVars;
    unsigned        emitInitGCrefRegs;
    unsigned        emitInitByrefRegs;

    bool            emitThisGCrefVset;

    VARSET_TP       emitThisGCrefVars;
    unsigned        emitThisGCrefRegs;
    unsigned        emitThisByrefRegs;

    static
    unsigned        emitEncodeCallGCregs(unsigned regs);
    static
    void            emitEncodeCallGCregs(unsigned regs, instrDesc *id);

    static
    unsigned        emitDecodeCallGCregs(unsigned mask);
    static
    unsigned        emitDecodeCallGCregs(instrDesc *id);

#endif

    unsigned        emitNxtIGnum;

    insGroup    *   emitAllocIG();

    void            emitNewIG();
    void            emitGenIG(insGroup *ig, size_t sz = 0);
    insGroup    *   emitSavIG(bool emitAdd = false);
    void            emitNxtIG(bool emitAdd = false);

    bool            emitCurIGnonEmpty()
    {
        return  (emitCurIG && emitCurIGfreeNext > emitCurIGfreeBase);
    }

    instrDesc   *   emitLastIns;

#ifdef  DEBUG
    void            emitCheckIGoffsets();
#else
    void            emitCheckIGoffsets(){}
#endif

    /* This method sets/clears the emitHasHandler data member
     *  which records the current state that is used by NewIG
     *  Any new instruction groups that are created when we
     *  have a handler (inside a try region) must be handled
     *  more conservatively by the scheduler
     */
    void            emitSetHasHandler(bool hasHandler)
    {
        emitHasHandler = hasHandler;
    }

    void            emitAddLabel(void **    labPtr);

#if     TRACK_GC_REFS

    void            emitAddLabel(void **    labPtr,
                                 VARSET_TP  GCvars,
                                 unsigned   gcrefRegs,
                                 unsigned   byrefRegs);

#else

    void            emitAddLabel(void **    labPtr,
                                 VARSET_TP  GCvars,
                                 unsigned   gcrefRegs,
                                 unsigned   byrefRegs)
    {
        emitAddLabel(labPtr);
    }

#endif

    void            emitMarkStackLvl(size_t stackLevel);

    void        *   emitAllocInstr(size_t sz, emitAttr attr);

    instrDesc      *emitAllocInstr      (emitAttr attr)
    {
        return  (instrDesc      *)emitAllocInstr(sizeof(instrDesc      ), attr);
    }

    instrDescJmp   *emitAllocInstrJmp   ()
    {
        return  (instrDescJmp   *)emitAllocInstr(sizeof(instrDescJmp   ), EA_1BYTE);
    }

    instrDescCns   *emitAllocInstrCns   (emitAttr attr)
    {
        return  (instrDescCns   *)emitAllocInstr(sizeof(instrDescCns   ), attr);
    }

    instrDescDsp   *emitAllocInstrDsp   (emitAttr attr)
    {
        return  (instrDescDsp   *)emitAllocInstr(sizeof(instrDescDsp   ), attr);
    }

    instrDescDspCns*emitAllocInstrDspCns(emitAttr attr)
    {
        return  (instrDescDspCns*)emitAllocInstr(sizeof(instrDescDspCns), attr);
    }

    instrDescCIGCA *emitAllocInstrCIGCA (emitAttr attr)
    {
        return  (instrDescCIGCA *)emitAllocInstr(sizeof(instrDescCIGCA ), attr);
    }

    instrDescDCM   *emitAllocInstrDCM   (emitAttr attr)
    {
        return  (instrDescDCM   *)emitAllocInstr(sizeof(instrDescDCM   ), attr);
    }

    instrDesc      *emitNewInstr        (emitAttr attr = EA_4BYTE);
    instrDesc      *emitNewInstrTiny    (emitAttr attr);
    instrDesc      *emitNewInstrSC      (emitAttr attr, int val);
    instrDesc      *emitNewInstrDsp     (emitAttr attr, int dsp);
    instrDesc      *emitNewInstrCns     (emitAttr attr, int cns);
    instrDesc      *emitNewInstrDspCns  (emitAttr attr, int dsp, int cns);
    instrDescJmp   *emitNewInstrJmp     ();
    instrDescDCM   *emitNewInstrDCM     (emitAttr attr, int dsp, int cns, int val);

    static
    BYTE            emitFmtToOps[];

#ifdef  DEBUG

    static
    unsigned        emitFmtCount;

#endif

    bool            emitIsTinyInsDsc    (instrDesc       *id);
    bool            emitIsScnsInsDsc    (instrDesc       *id);

    size_t          emitSizeOfInsDsc    (instrDesc       *id);
    size_t          emitSizeOfInsDsc    (instrDescCns    *id);
    size_t          emitSizeOfInsDsc    (instrDescDsp    *id);
    size_t          emitSizeOfInsDsc    (instrDescDspCns *id);

#if EMIT_USE_LIT_POOLS

    void            emitRecIGlitPoolRefs(insGroup *ig);

    void            emitEstimateLitPools();
    void            emitFinalizeLitPools();

#if SMALL_DIRECT_CALLS
    void            emitShrinkShortCalls();
#else
    void            emitShrinkShortCalls() {}
#endif

#else

    void            emitRecIGlitPoolRefs(insGroup *ig) {}

    void            emitEstimateLitPools() {}
    void            emitFinalizeLitPools() {}

    void            emitShrinkShortCalls() {}

#endif

    #include "sched.h"      // scheduling members/methods

    /************************************************************************/
    /*         Logic to handle source line information / display            */
    /************************************************************************/

#ifdef  DEBUG

    unsigned        emitBaseLineNo;
    unsigned        emitThisLineNo;
    unsigned        emitLastLineNo;

#endif

    /************************************************************************/
    /*        The following keeps track of stack-based GC values            */
    /************************************************************************/

    unsigned        emitTrkVarCnt;
    int     *       emitGCrFrameOffsTab;  // Offsets of tracked stack ptr vars (varTrkIndex -> stkOffs)

    unsigned        emitGCrFrameOffsCnt;  // Number of       tracked stack ptr vars
    int             emitGCrFrameOffsMin;  // Min offset of a tracked stack ptr var
    int             emitGCrFrameOffsMax;  // Max offset of a tracked stack ptr var
    bool            emitContTrkPtrLcls;   // All lcl between emitGCrFrameOffsMin/Max are only tracked stack ptr vars
    varPtrDsc * *   emitGCrFrameLiveTab;  // Cache of currently live varPtrs (stkOffs -> varPtrDsc)

    int             emitArgFrameOffsMin;
    int             emitArgFrameOffsMax;

    int             emitLclFrameOffsMin;
    int             emitLclFrameOffsMax;

    int             emitThisArgOffs;

public:

    void            emitSetFrameRangeGCRs(int offsLo, int offsHi);
    void            emitSetFrameRangeLcls(int offsLo, int offsHi);
    void            emitSetFrameRangeArgs(int offsLo, int offsHi);

#ifdef  DEBUG
    void            emitInsTest(instrDesc *id);
#endif

    /************************************************************************/
    /*    The following is used to distinguish helper vs non-helper calls   */
    /************************************************************************/

    bool            emitNoGChelper(unsigned IHX);

    /************************************************************************/
    /*         The following logic keeps track of live GC ref values        */
    /************************************************************************/

#if TRACK_GC_REFS

    bool            emitFullGCinfo;         // full GC pointer maps?
    bool            emitFullyInt;           // fully interruptible code?

    unsigned        emitCntStackDepth;      // 0 in prolog/epilog, 1 elsewhere
    unsigned        emitMaxStackDepth;      // actual computed max. stack depth

    /* Stack modelling wrt GC */

    bool            emitSimpleStkUsed;      // using the "simple" stack table?

    union
    {
        struct                              // if emitSimpleStkUsed==true
        {
            #define     BITS_IN_BYTE            (8)
            #define     MAX_SIMPLE_STK_DEPTH    (BITS_IN_BYTE*sizeof(unsigned))

            unsigned    emitSimpleStkMask;      // bit per pushed dword (if it fits. Lowest bit <==> last pushed arg)
            unsigned    emitSimpleByrefStkMask; // byref qualifier for emitSimpleStkMask
        };

        struct                              // if emitSimpleStkUsed==false
        {
            BYTE        emitArgTrackLcl[16];    // small local table to avoid malloc
            BYTE    *   emitArgTrackTab;        // base of the argument tracking stack
            BYTE    *   emitArgTrackTop;        // top  of the argument tracking stack
            unsigned    emitGcArgTrackCnt;      // count of pending arg records (stk-depth for frameless methods, gc ptrs on stk for framed methods)
        };
    };

    unsigned        emitCurStackLvl;           // amount of stuff pushed on stack

    /* Functions for stack tracking */

    void            emitStackPush       (BYTE *     addr,
                                         GCtype     gcType);
    void            emitStackPushN      (BYTE *     addr,
                                         unsigned   count);

    void            emitStackPop        (BYTE *     addr,
                                         bool       isCall,
                                         unsigned   count = 1);
    void            emitStackKillArgs   (BYTE *     addr,
                                         unsigned   count);

    void            emitRecordGCcall    (BYTE *     codePos);

    // Helpers for the above

    void            emitStackPushLargeStk(BYTE*     addr,
                                         GCtype     gcType,
                                         unsigned   count = 1);
    void            emitStackPopLargeStk(BYTE *     addr,
                                         bool       isCall,
                                         unsigned   count = 1);

    /* Liveness of stack variables, and registers */

    void            emitUpdateLiveGCvars(int        offs, BYTE *addr, bool birth);
    void            emitUpdateLiveGCvars(VARSET_TP  vars, BYTE *addr);
    void            emitUpdateLiveGCregs(GCtype     gcType,
                                         unsigned   regs, BYTE *addr);

#ifdef  DEBUG
    void            emitDispRegSet      (unsigned   regs, bool calleeOnly = false);
    void            emitDispVarSet      ();
#endif

    void            emitGCregLiveUpd(GCtype gcType, emitRegs reg, BYTE *addr);
    void            emitGCregLiveSet(GCtype gcType, unsigned mask, BYTE *addr, bool isThis = false);
    void            emitGCregDeadUpd(regMaskTP, BYTE *addr);
    void            emitGCregDeadUpd(emitRegs reg, BYTE *addr);
    void            emitGCregDeadSet(GCtype gcType, unsigned mask, BYTE *addr);

    void            emitGCvarLiveUpd(int offs, int varNum, GCtype gcType, BYTE *addr);
    void            emitGCvarLiveSet(int offs, GCtype gcType, BYTE *addr, int disp = -1);
    void            emitGCvarDeadUpd(int offs,                BYTE *addr);
    void            emitGCvarDeadSet(int offs,                BYTE *addr, int disp = -1);

    GCtype          emitRegGCtype   (emitRegs reg);

#endif

    /************************************************************************/
    /*      The following logic keeps track of initialized data sections    */
    /************************************************************************/

    /* One of these is allocated for every blob of initialized data */

    struct  dataSection
    {
        dataSection *       dsNext;
        size_t              dsSize;
        BYTE                dsCont[0];
    };

    /* These describe the entire initialized/uninitialized data sections */

    struct  dataSecDsc
    {
        unsigned            dsdOffs;
        dataSection *       dsdList;
        dataSection *       dsdLast;
    };

    dataSecDsc      emitConsDsc;
    dataSecDsc      emitDataDsc;

    dataSection *   emitDataSecCur;
    dataSecDsc  *   emitDataDscCur;

    void            emitOutputDataSec(dataSecDsc *sec,
                                      BYTE       *cbp,
                                      BYTE       *dst);

    /************************************************************************/
    /*              Handles to the current class and method.                */
    /************************************************************************/

    COMP_HANDLE     emitCmpHandle;

#ifndef NOT_JITC

    /************************************************************************/
    /*           Fake memory allocator for command-line compiler.           */
    /************************************************************************/

    static
    commitAllocator eeAllocator;

    #define         MAX_SAVED_CODE_SIZE (1024*1024*64)

    static
    bool            eeAllocMem(COMP_HANDLE   compHandle,
                               size_t        codeSize,
                               size_t        roDataSize,
                               size_t        rwDataSize,
                               const void ** codeBlock,
                               const void ** roDataBlock,
                               const void ** rwDataBlock);

#endif

    /************************************************************************/
    /*               Logic to collect and display statistics                */
    /************************************************************************/

#if EMITTER_STATS_RLS

    static unsigned emitTotIDcount;
    static unsigned emitTotIDsize;

#endif

#if EMITTER_STATS

    friend  void    emitterStats();

    static unsigned emitTotalInsCnt;

    static unsigned emitTotalIGcnt;
    static unsigned emitTotalIGicnt;
    static unsigned emitTotalIGsize;
    static unsigned emitTotalIGmcnt;
    static unsigned emitTotalIGjmps;
    static unsigned emitTotalIGptrs;

    static unsigned emitTotMemAlloc;
    static unsigned emitLclMemAlloc;
    static unsigned emitExtMemAlloc;

    static unsigned emitSmallDspCnt;
    static unsigned emitLargeDspCnt;

    static unsigned emitSmallCnsCnt;
    #define                      SMALL_CNS_TSZ   256
    static unsigned emitSmallCns[SMALL_CNS_TSZ];
    static unsigned emitLargeCnsCnt;

    static unsigned emitIFcounts[IF_COUNT];
#if SCHEDULER
    static unsigned schedFcounts[IF_COUNT];
    static histo    scdCntTable;
    static histo    scdSucTable;
    static histo    scdFrmCntTable;
#endif

#endif

    /*************************************************************************
     *
     *  Define any target-dependent emitter members.
     */

    #include "emitDef.h"
};

/*****************************************************************************
 *
 *  Define any target-dependent inlines.
 */

#include "emitInl.h"

/*****************************************************************************
 *
 *  Returns true if the given instruction descriptor is a "tiny" or a "small
 *  constant" one (i.e. one of the descriptors that don't have all instrDesc
 *  fields allocated).
 */

inline
bool                emitter::emitIsTinyInsDsc(instrDesc *id)
{
    return  id->idIsTiny();
}

inline
bool                emitter::emitIsScnsInsDsc(instrDesc *id)
{
    return  id->idIsSmallCns();
}

/*****************************************************************************
 *
 *  Given an instruction, return its "update mode" (RD/WR/RW).
 */

#if !TGT_MIPS32

inline
insUpdateModes      emitter::emitInsUpdateMode(instruction ins)
{
#ifdef DEBUG
    assert((unsigned)ins < emitInsModeFmtCnt);
#endif
    return (insUpdateModes)emitInsModeFmtTab[ins];
}

#endif

/*****************************************************************************
 *
 *  Combine the given base format with the update mode of the instuction.
 */

#if !TGT_MIPS32

inline
emitter::insFormats   emitter::emitInsModeFormat(instruction ins, insFormats base)
{
    assert(IF_RRD + IUM_RD == IF_RRD);
    assert(IF_RRD + IUM_WR == IF_RWR);
    assert(IF_RRD + IUM_RW == IF_RRW);

    return  (insFormats)(base + emitInsUpdateMode(ins));
}

#endif

/*****************************************************************************
 *
 *  Return the number of epilog blocks generated so far.
 */

inline
unsigned            emitter::emitGetEpilogCnt()
{
    return emitEpilogCnt;
}

/*****************************************************************************
 *
 *  Return the current size of the specified data section.
 */

inline
size_t              emitter::emitDataSize(bool readOnly)
{
    return  (readOnly ? emitConsDsc
                      : emitDataDsc).dsdOffs;
}

/*****************************************************************************
 *
 *  Emit an 8-bit integer as code.
 */

inline
size_t              emitter::emitOutputByte(BYTE *dst, int val)
{
    *castto(dst, char  *) = val;

#ifdef  DEBUG
    if (dspEmit) printf("; emit_byte 0%02XH\n", val & 0xFF);
#endif

    return  sizeof(char);
}

/*****************************************************************************
 *
 *  Emit a 16-bit integer as code.
 */

inline
size_t              emitter::emitOutputWord(BYTE *dst, int val)
{
    MISALIGNED_WR_I2(dst, val);

#ifdef  DEBUG
#if     TGT_x86
    if (dspEmit) printf("; emit_word 0%02XH,0%02XH\n", (val & 0xFF), (val >> 8) & 0xFF);
#else
    if (dspEmit) printf("; emit_word 0%04XH\n"       , (val & 0xFFFF));
#endif
#endif

    return  sizeof(short);
}

/*****************************************************************************
 *
 *  Emit a 32-bit integer as code.
 */

inline
size_t              emitter::emitOutputLong(BYTE *dst, int val)
{
    MISALIGNED_WR_I4(dst, val);

#ifdef  DEBUG
    if (dspEmit) printf("; emit_long 0%08XH\n", val);
#endif

    return  sizeof(long );
}

/*****************************************************************************
 *
 *  Return a handle to the current position in the output stream. This can
 *  be later converted to an actual code offset in bytes.
 */

inline
void    *           emitter::emitCurBlock()
{
    return emitCurIG;
}

/*****************************************************************************
 *
 *  The emitCurOffset() method returns a cookie that identifies the current
 *  position in the instruction stream. Due to things like scheduling (and
 *  the fact that the final size of some instructions cannot be known until
 *  the end of code generation), we return a value with the instruction num.
 *  and its estimated offset to the caller.
 */

inline
unsigned            emitGetInsNumFromCodePos(unsigned codePos)
{
    return (codePos & 0xFFFF);
}

inline
unsigned            emitGetInsOfsFromCodePos(unsigned codePos)
{
    return (codePos >> 16);
}

inline
unsigned            emitter::emitCurOffset()
{
    unsigned        codePos = emitCurIGinsCnt + (emitCurIGsize << 16);

    assert(emitGetInsOfsFromCodePos(codePos) == emitCurIGsize);
    assert(emitGetInsNumFromCodePos(codePos) == emitCurIGinsCnt);

//  printf("[IG=%02u;ID=%03u;OF=%04X] => %08X\n", emitCurIG->igNum, emitCurIGinsCnt, emitCurIGsize, codePos);

    return codePos;
}

extern
signed char       emitTypeSizes[TYP_COUNT];

inline
emitAttr          emitTypeSize(var_types type)
{
    assert(type < TYP_COUNT);
#if !TRACK_GC_REFS
    assert(emitTypeSizes[type] > 0);
#else
# if NEW_EMIT_ATTR
    assert(emitTypeSizes[type] > 0);
# else
    assert(emitTypeSizes[type] >= -2);  // EA_BYREF is -2
# endif
#endif
    return (emitAttr) emitTypeSizes[type];
}

extern
signed char       emitTypeActSz[TYP_COUNT];

inline
emitAttr          emitActualTypeSize(var_types type)
{
    assert(type < TYP_COUNT);
#if !TRACK_GC_REFS
    assert(emitTypeActSz[type] > 0);
#else
# if NEW_EMIT_ATTR
    assert(emitTypeActSz[type] > 0);
# else
    assert(emitTypeActSz[type] >= -2);  // EA_BYREF is -2
# endif
#endif
    return (emitAttr) emitTypeActSz[type];
}

/*****************************************************************************
 *
 *  Little helpers to allocate various flavors of instructions.
 */

inline
emitter::instrDesc   *emitter::emitNewInstr      (emitAttr attr)
{
    return  emitAllocInstr(attr);
}

inline
emitter::instrDesc   *emitter::emitNewInstrTiny  (emitAttr attr)
{
    instrDesc        *id;

    id =  (instrDesc*)emitAllocInstr(TINY_IDSC_SIZE, attr);

    id->idTinyDsc = true;

    return  id;
}

inline
emitter::instrDescJmp*emitter::emitNewInstrJmp()
{
    return  emitAllocInstrJmp();
}

inline
emitter::instrDesc      * emitter::emitNewInstrDsp   (emitAttr attr, int dsp)
{
    if  (dsp == 0)
    {
        instrDesc      *id = emitAllocInstr      (attr);

#if EMITTER_STATS
        emitSmallDspCnt++;
#endif

        return  id;
    }
    else
    {
        instrDescDsp   *id = emitAllocInstrDsp   (attr);

        id->idInfo.idLargeDsp = true;
        id->iddDspVal  = dsp;

#if EMITTER_STATS
        emitLargeDspCnt++;
#endif

        return  id;
    }
}

inline
emitter::instrDesc      * emitter::emitNewInstrCns   (emitAttr attr, int cns)
{
    if  (cns >= ID_MIN_SMALL_CNS &&
         cns <= ID_MAX_SMALL_CNS)
    {
        instrDesc      *id = emitAllocInstr      (attr);

        id->idInfo.idSmallCns = cns;

#if EMITTER_STATS
        emitSmallCnsCnt++;
        if  (cns - ID_MIN_SMALL_CNS >= SMALL_CNS_TSZ)
            emitSmallCns[   SMALL_CNS_TSZ - 1  ]++;
        else
            emitSmallCns[cns - ID_MIN_SMALL_CNS]++;
#endif

        return  id;
    }
    else
    {
        instrDescCns   *id = emitAllocInstrCns   (attr);

        id->idInfo.idLargeCns = true;
        id->idcCnsVal  = cns;

#if EMITTER_STATS
        emitLargeCnsCnt++;
#endif

        return  id;
    }
}

/*****************************************************************************
 *
 *  Allocate an instruction descriptor for an instruction with a small integer
 *  constant operand.
 */

inline
emitter::instrDesc   *emitter::emitNewInstrSC(emitAttr attr, int cns)
{
    instrDesc      *id;

    if  (cns >= ID_MIN_SMALL_CNS &&
         cns <= ID_MAX_SMALL_CNS)
    {
        id = (instrDesc*)emitAllocInstr(      SCNS_IDSC_SIZE, attr);

        id->idInfo.idSmallCns           = cns;
    }
    else
    {
        id = (instrDesc*)emitAllocInstr(sizeof(instrBaseCns), attr);

        id->idInfo.idLargeCns           = true;
        ((instrBaseCns*)id)->ibcCnsVal  = cns;
    }

    id->idScnsDsc = true;

    return  id;
}

/*****************************************************************************
 *
 *  Return the allocated size (in bytes) of the given instruction descriptor.
 */

inline
size_t              emitter::emitSizeOfInsDsc(instrDescCns    *id)
{
    return  id->idInfo.idLargeCns ? sizeof(instrDescCns)
                                  : sizeof(instrDesc   );
}

inline
size_t              emitter::emitSizeOfInsDsc(instrDescDsp    *id)
{
    return  id->idInfo.idLargeDsp ? sizeof(instrDescDsp)
                                  : sizeof(instrDesc   );
}

inline
size_t              emitter::emitSizeOfInsDsc(instrDescDspCns *id)
{
    if      (id->idInfo.idLargeCns)
    {
        return  id->idInfo.idLargeDsp ? sizeof(instrDescDspCns)
                                      : sizeof(instrDescCns   );
    }
    else
    {
        return  id->idInfo.idLargeDsp ? sizeof(instrDescDsp   )
                                      : sizeof(instrDesc      );
    }
}

/*****************************************************************************
 *
 *  The following helpers should be used to access the various values that
 *  get stored in different places within the instruction descriptor.
 */

inline
int                 emitter::emitGetInsCns   (instrDesc *id)
{
    return  id->idInfo.idLargeCns ? ((instrDescCns*)id)->idcCnsVal
                                  :                 id ->idInfo.idSmallCns;
}

inline
int                 emitter::emitGetInsDsp   (instrDesc *id)
{
    return  id->idInfo.idLargeDsp ? ((instrDescDsp*)id)->iddDspVal
                                  : 0;
}

inline
int                 emitter::emitGetInsDspCns(instrDesc *id, int *dspPtr)
{
    if  (id->idInfo.idLargeCns)
    {
        if  (id->idInfo.idLargeDsp)
        {
            *dspPtr = ((instrDescDspCns*)id)->iddcDspVal;
            return    ((instrDescDspCns*)id)->iddcCnsVal;
        }
        else
        {
            *dspPtr = 0;
            return    ((instrDescCns   *)id)->idcCnsVal;
        }
    }
    else
    {
        if  (id->idInfo.idLargeDsp)
        {
            *dspPtr = ((instrDescDsp   *)id)->iddDspVal;
            return                       id ->idInfo.idSmallCns;
        }
        else
        {
            *dspPtr = 0;
            return                       id ->idInfo.idSmallCns;
        }
    }
}

inline
int                 emitter::emitGetInsSC(instrDesc *id)
{
    assert(id->idIsSmallCns());

    if  (id->idInfo.idLargeCns)
        return  ((instrBaseCns*)id)->ibcCnsVal;
    else
        return  id->idInfo.idSmallCns;
}

/*****************************************************************************
 *
 *  Get hold of the argument count for an indirect call.
 */

inline
unsigned            emitter::emitGetInsCIargs(instrDesc *id)
{
    if  (id->idInfo.idLargeCall)
    {
        return  ((instrDescCIGCA*)id)->idciArgCnt;
    }
    else
    {
        assert(id->idInfo.idLargeDsp == false);
        assert(id->idInfo.idLargeCns == false);

        return  emitGetInsCns(id);
    }
}

/*****************************************************************************
 *
 *  Display (optionally) an instruction offset.
 */

#ifdef  DEBUG

inline
void                emitter::emitDispInsOffs(unsigned offs, bool doffs)
{
    if  (doffs)
        printf("%06X", offs);
    else
        printf("      ");
}

#endif

/*****************************************************************************/
#if TRACK_GC_REFS
/*****************************************************************************
 *
 *  Map a register mask (must have only one bit set) to a register number.
 */

inline
emitRegs           emitter::emitRegNumFromMask(unsigned mask)
{
    emitRegs       reg;

    assert(mask && genOneBitOnly(mask));
    reg = (emitRegs)(genLog2(mask) - 1);
    assert(mask == emitRegMask(reg));

    return  reg;
}

/*****************************************************************************
 *
 *  Returns true if the given register contains a live GC ref.
 */

inline
GCtype              emitter::emitRegGCtype  (emitRegs reg)
{
    if       ((emitThisGCrefRegs & emitRegMask(reg)) != 0)
        return GCT_GCREF;
    else if  ((emitThisByrefRegs & emitRegMask(reg)) != 0)
        return GCT_BYREF;
    else
        return GCT_NONE;
}

/*****************************************************************************
 *
 *  Record the fact that the given register now       contains a live GC ref.
 */

inline
void                emitter::emitGCregLiveUpd(GCtype gcType, emitRegs reg, BYTE *addr)
{
    assert(needsGC(gcType));

    regMaskTP regMask = emitRegMask(reg);

    unsigned & emitThisXXrefRegs = (gcType == GCT_GCREF) ? emitThisGCrefRegs
                                                         : emitThisByrefRegs;
    unsigned & emitThisYYrefRegs = (gcType == GCT_GCREF) ? emitThisByrefRegs
                                                         : emitThisGCrefRegs;

    if  ((emitThisXXrefRegs & regMask) == 0)
    {
        // If the register was holding the other GC type, that type should
        // go dead now

        if (emitThisYYrefRegs & regMask)
            emitGCregDeadUpd(        reg    , addr);

        if  (emitFullGCinfo)
            emitGCregLiveSet(gcType, regMask, addr);

        emitThisXXrefRegs |=         regMask;

#ifdef  DEBUG
        if  (verbose && emitFullyInt)
            printf("%sReg +[%s]\n", GCtypeStr(gcType), emitRegName(reg));
#endif
    }

    // The 2 GC reg masks cant be overlapping

    assert((emitThisGCrefRegs & emitThisByrefRegs) == 0);
}

/*****************************************************************************
 *
 *  Record the fact that the given register no longer contains a live GC ref.
 */

inline
void                emitter::emitGCregDeadUpd(regMaskTP regs, BYTE *addr)
{
    regMaskTP   gcrefRegs = emitThisGCrefRegs & regs;

    if  (gcrefRegs)
    {
        assert((emitThisByrefRegs & gcrefRegs) == 0);

        if  (emitFullGCinfo)
            emitGCregDeadSet(GCT_GCREF, gcrefRegs, addr);

        emitThisGCrefRegs &= ~gcrefRegs;
        regs              &= ~gcrefRegs;

#ifdef  DEBUG
        if  (verbose && emitFullyInt)
            printf("%s -[%s]\n", "gcrReg",
                   genOneBitOnly(gcrefRegs) ? emitRegName((emitRegs)genLog2(gcrefRegs)) : "multi");
#endif
    }

    regMaskTP   byrefRegs = emitThisByrefRegs & regs;

    if (byrefRegs)
    {
        if  (emitFullGCinfo)
            emitGCregDeadSet(GCT_BYREF, byrefRegs, addr);

        emitThisByrefRegs &= ~byrefRegs;

#ifdef  DEBUG
        if  (verbose && emitFullyInt)
            printf("%s -[%s]\n", "byrReg",
                   genOneBitOnly(byrefRegs) ? emitRegName((emitRegs)genLog2(byrefRegs)) : "multi");
#endif
    }
}

inline
void                emitter::emitGCregDeadUpd(emitRegs reg, BYTE *addr)
{
    unsigned        regMask = emitRegMask(reg);

    if  ((emitThisGCrefRegs & regMask) != 0)
    {
        assert((emitThisByrefRegs & regMask) == 0);

        if  (emitFullGCinfo)
            emitGCregDeadSet(GCT_GCREF, regMask, addr);

        emitThisGCrefRegs &= ~regMask;

#ifdef  DEBUG
        if  (verbose && emitFullyInt)
            printf("%s -[%s]\n", "gcrReg", emitRegName(reg));
#endif
    }
    else if ((emitThisByrefRegs & regMask) != 0)
    {
        if  (emitFullGCinfo)
            emitGCregDeadSet(GCT_BYREF, regMask, addr);

        emitThisByrefRegs &= ~regMask;

#ifdef  DEBUG
        if  (verbose && emitFullyInt)
            printf("%s -[%s]\n", "byrReg", emitRegName(reg));
#endif
    }
}

/*****************************************************************************
 *
 *  Record the fact that the given variable now contains a live GC ref.
 *  varNum may be INT_MAX only if offs is guaranteed to be the offset of a
 *    tracked GC ref. Else we need a valid value to check if the variable
 *    is tracked or not.
 */

inline
void                emitter::emitGCvarLiveUpd(int offs, int varNum,
                                              GCtype gcType, BYTE *addr)
{
    assert(abs(offs) % sizeof(int) == 0);
    assert(needsGC(gcType));

    /* Is the frame offset within the "interesting" range? */

    if  (offs >= emitGCrFrameOffsMin &&
         offs <  emitGCrFrameOffsMax)
    {
        /* Normally all variables in this range must be tracked stack
           pointers. However, for EnC, we relax this condition. So we
           must check if this is not such a variable */

        if (varNum != INT_MAX && !emitComp->lvaTable[varNum].lvTracked)
        {
            assert(!emitContTrkPtrLcls);
            return;
        }

        size_t          disp;

        /* Compute the index into the GC frame table */

        disp = (offs - emitGCrFrameOffsMin) / sizeof(void *);
        assert(disp < emitGCrFrameOffsCnt);

        /* If the variable is currently dead, mark it as live */

        if  (emitGCrFrameLiveTab[disp] == NULL)
            emitGCvarLiveSet(offs, gcType, addr, disp);
    }
}

/*****************************************************************************
 *
 *  Record the fact that the given variable no longer contains a live GC ref.
 */

inline
void                emitter::emitGCvarDeadUpd(int offs, BYTE *addr)
{
    assert(abs(offs) % sizeof(int) == 0);

    /* Is the frame offset within the "interesting" range? */

    if  (offs >= emitGCrFrameOffsMin &&
         offs <  emitGCrFrameOffsMax)
    {
        size_t          disp;

        /* Compute the index into the GC frame table */

        disp = (offs - emitGCrFrameOffsMin) / sizeof(void *);
        assert(disp < emitGCrFrameOffsCnt);

        /* If the variable is currently live, mark it as dead */

        if  (emitGCrFrameLiveTab[disp] != NULL)
            emitGCvarDeadSet(offs, addr, disp);
    }
}

/*****************************************************************************/
#if     EMIT_TRACK_STACK_DEPTH
/*****************************************************************************
 *
 *  Record a push of a single dword on the stack.
 */

inline
void                emitter::emitStackPush(BYTE *addr, GCtype gcType)
{
#ifdef DEBUG
    assert(IsValidGCtype(gcType));
#endif

    if  (emitSimpleStkUsed)
    {
        assert(!emitFullGCinfo); // Simple stk not used for emitFullGCinfo
        assert(emitCurStackLvl/sizeof(int) < MAX_SIMPLE_STK_DEPTH);

        emitSimpleStkMask      <<= 1;
        emitSimpleStkMask      |= (unsigned)needsGC(gcType);

        emitSimpleByrefStkMask <<= 1;
        emitSimpleByrefStkMask |= (gcType == GCT_BYREF);

        assert((emitSimpleStkMask & emitSimpleByrefStkMask) == emitSimpleByrefStkMask);
    }
    else
    {
        emitStackPushLargeStk(addr, gcType);
    }

    emitCurStackLvl += sizeof(int);
}

/*****************************************************************************
 *
 *  Record a push of a bunch of non-GC dwords on the stack.
 */

inline
void                emitter::emitStackPushN(BYTE *addr, unsigned count)
{
    assert(count);

    if  (emitSimpleStkUsed)
    {
        assert(!emitFullGCinfo); // Simple stk not used for emitFullGCinfo

        emitSimpleStkMask       <<= count;
        emitSimpleByrefStkMask  <<= count;
    }
    else
    {
        emitStackPushLargeStk(addr, GCT_NONE, count);
    }

    emitCurStackLvl += count * sizeof(int);
}

/*****************************************************************************
 *
 *  Record a pop of the given number of dwords from the stack.
 */

inline
void                emitter::emitStackPop(BYTE *addr, bool isCall, unsigned count)
{
    assert(emitCurStackLvl/sizeof(int) >= count);

    if  (count)
    {
        if  (emitSimpleStkUsed)
        {
            assert(!emitFullGCinfo); // Simple stk not used for emitFullGCinfo

            unsigned    cnt = count;

            do
            {
                emitSimpleStkMask      >>= 1;
                emitSimpleByrefStkMask >>= 1;
            }
            while (--cnt);
        }
        else
        {
            emitStackPopLargeStk(addr, isCall, count);
        }

        emitCurStackLvl -= count * sizeof(int);
    }
    else
    {
        assert(isCall);

        if  (emitFullGCinfo)
            emitStackPopLargeStk(addr, true, 0);
    }
}

/*****************************************************************************/
#endif//EMIT_TRACK_STACK_DEPTH
/*****************************************************************************/
#endif//TRACK_GC_REFS
/*****************************************************************************/
#if SCHEDULER
/*****************************************************************************
 *
 *  Define the "IS_xxxx" enum.
 */

#define DEFINE_IS_OPS
#include "emitfmts.h"
#undef  DEFINE_IS_OPS

/*****************************************************************************
 *
 *  Return an integer that represents the stack offset referenced by the
 *  given instruction and a size that will be set to 0 for 32-bit values
 *  and 1 for 64-bit values. The offset value is guaranteed to change by
 *  1 for a real frame offset change of 4 (in other words, the caller can
 *  add the returned size to the returned offset to get the equivalent
 *  frame offset of the byte that follows the given operand).
 */

#if SCHEDULER

inline
int                 emitter::scGetFrameOpInfo(instrDesc *id, size_t *szp,
                                                             bool   *ebpPtr)
{
    int             ofs;

    ofs  = emitComp->lvaFrameAddress(id->idAddr.iiaLclVar.lvaVarNum, ebpPtr);
    ofs += id->idAddr.iiaLclVar.lvaOffset;

    assert(emitDecodeSize(0) == EA_1BYTE);
    assert(emitDecodeSize(1) == EA_2BYTE);
    assert(emitDecodeSize(2) == EA_4BYTE);
    assert(emitDecodeSize(3) == EA_8BYTE);

    *szp = 1 + (id->idOpSize == 3);

    return  ofs / (int)sizeof(int);
}

#endif

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/

#ifdef  DEBUG

#if     EMIT_TRACK_STACK_DEPTH
#define CHECK_STACK_DEPTH() assert((int)emitCurStackLvl >= 0)
#else
#define CHECK_STACK_DEPTH()
#endif

#if     EMITTER_STATS
#define dispIns(i)  emitIFcounts[i->idInsFmt]++;                            \
                    emitInsTest(id);                                        \
                    if (dspCode) emitDispIns(i, true, false, false);        \
                    assert(id->idSize == emitSizeOfInsDsc((instrDesc*)id)); \
                    CHECK_STACK_DEPTH();
#else
#define dispIns(i)  emitInsTest(id);                                        \
                    if (dspCode) emitDispIns(i, true, false, false);        \
                    assert(id->idSize == emitSizeOfInsDsc((instrDesc*)id)); \
                    CHECK_STACK_DEPTH();
#endif

#else

#define dispIns(i)

#endif

/*****************************************************************************/
#endif//!TGT_IA64
/*****************************************************************************/
#endif//_SCHED_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitfmts.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//////////////////////////////////////////////////////////////////////////////
#ifdef  DEFINE_ID_OPS
//////////////////////////////////////////////////////////////////////////////

#undef  DEFINE_ID_OPS

enum    ID_OPS
{
    ID_OP_NONE,                             // no additional arguments
    ID_OP_CNS,                              // constant     operand
    ID_OP_DSP,                              // displacement operand
    ID_OP_AMD,                              // addrmode dsp operand
    ID_OP_DC,                               // displacement + constant
    ID_OP_AC,                               // addrmode dsp + constant
    ID_OP_JMP,                              // local jump
    ID_OP_REG,                              // register     operand
    ID_OP_SCNS,                             // small const  operand
    ID_OP_CALL,                             // direct method call
    ID_OP_SPEC,                             // special handling required
};

//////////////////////////////////////////////////////////////////////////////
#else
//////////////////////////////////////////////////////////////////////////////
#ifdef  DEFINE_IS_OPS
#undef  DEFINE_IS_OPS

#define IS_NONE     0

#define IS_R1_SHF   0
#define IS_R1_RD    (1<<(IS_R1_SHF  ))      // register1 read
#define IS_R1_WR    (1<<(IS_R1_SHF+1))      // register1 write
#define IS_R1_RW    (IS_R1_RD|IS_R1_WR)

#define IS_R2_SHF   2
#define IS_R2_RD    (1<<(IS_R2_SHF  ))      // register2 read
#define IS_R2_WR    (1<<(IS_R2_SHF+1))      // register2 write
#define IS_R2_RW    (IS_R2_RD|IS_R2_WR)

#define IS_SF_SHF   4
#define IS_SF_RD    (1<<(IS_SF_SHF  ))      // stk frame read
#define IS_SF_WR    (1<<(IS_SF_SHF+1))      // stk frame write
#define IS_SF_RW    (IS_SF_RD|IS_SF_WR)

#define IS_GM_SHF   6
#define IS_GM_RD    (1<<(IS_GM_SHF  ))      // glob mem  read
#define IS_GM_WR    (1<<(IS_GM_SHF+1))      // glob mem  write
#define IS_GM_RW    (IS_GM_RD|IS_GM_WR)

#if TGT_x86

#define IS_AM_SHF   8
#define IS_AM_RD    (1<<(IS_AM_SHF  ))      // addr mode read
#define IS_AM_WR    (1<<(IS_AM_SHF+1))      // addr mode write
#define IS_AM_RW    (IS_AM_RD|IS_AM_WR)

#define IS_INDIR_RW IS_AM_RW
#define IS_INDIR_RD IS_AM_RD
#define IS_INDIR_WR IS_AM_WR

#define IS_FP_STK   0x1000                  // defs/uses the FP stack

#endif

#if TGT_SH3

#define IS_IR_SHF   8
#define IS_IR_RD    (1<<(IS_IR_SHF  ))      // ind. addr read
#define IS_IR_WR    (1<<(IS_IR_SHF+1))      // ind. addr write
#define IS_IR_RW    (IS_IR_RD|IS_IR_WR)

#define IS_INDIR_RW IS_IR_RW
#define IS_INDIR_RD IS_IR_RD
#define IS_INDIR_WR IS_IR_WR

#define IS_0R_SHF   10
#define IS_0R_RD    (1<<(IS_0R_SHF  ))      // read r0

#endif

#if TGT_MIPS32

#define IS_IR_SHF   8
#define IS_IR_RD    (1<<(IS_IR_SHF  ))      // ind. addr read
#define IS_IR_WR    (1<<(IS_IR_SHF+1))      // ind. addr write
#define IS_IR_RW    (IS_IR_RD|IS_IR_WR)

#define IS_R3_SHF   10
#define IS_R3_RD    (1<<(IS_R3_SHF  ))      // register2 read
#define IS_R3_WR    (1<<(IS_R3_SHF+1))      // register2 write
#define IS_R3_RW    (IS_R3_RD|IS_R3_WR)

#endif

#if TGT_PPC
// @ToDo
#endif

#define IS_SPECIAL  0x8000                  // needs special handling

//////////////////////////////////////////////////////////////////////////////
#else
//////////////////////////////////////////////////////////////////////////////
//     name
//                  opers
//                                           ID ops
//////////////////////////////////////////////////////////////////////////////

IF_DEF(NONE,        IS_NONE,                    NONE)     // no operands

IF_DEF(LABEL,       IS_NONE,                    JMP )     // label

#if TGT_x86 || TGT_MIPS32 || TGT_PPC
IF_DEF(METHOD,      IS_NONE,                    CALL)     // method
IF_DEF(METHPTR,     IS_NONE,                    CALL)     // method ptr (glbl)
IF_DEF(RWR_METHOD,  IS_R1_WR,                   SCNS)     // write  reg , method address
#else
IF_DEF(METHOD,      IS_NONE,                    CALL)     // method ptr call
#endif

IF_DEF(CNS,         IS_NONE,                    SCNS)     // const

#if TGT_x86
IF_DEF(EPILOG,      IS_NONE,                    SPEC)     // epilog
#endif

//----------------------------------------------------------------------------
// NOTE: The order of the "RD/WR/RW" varieties must match that of
//       the "insUpdateModes" enum in "instr.h".
//----------------------------------------------------------------------------

IF_DEF(RRD,         IS_R1_RD,                   REG )     // read   reg
IF_DEF(RWR,         IS_R1_WR,                   REG )     // write  reg
IF_DEF(RRW,         IS_R1_RW,                   REG )     // r/w    reg

IF_DEF(RRD_CNS,     IS_R1_RD,                   SCNS)     // read   reg , const
IF_DEF(RWR_CNS,     IS_R1_WR,                   SCNS)     // write  reg , const
IF_DEF(RRW_CNS,     IS_R1_RW,                   SCNS)     // r/w    reg , const

IF_DEF(RRW_SHF,     IS_R1_RW,                   SCNS)     // shift  reg , const

IF_DEF(RRD_RRD,     IS_R1_RD|IS_R2_RD,          SCNS)     // read   reg , read reg2
IF_DEF(RWR_RRD,     IS_R1_WR|IS_R2_RD,          SCNS)     // write  reg , read reg2
IF_DEF(RRW_RRD,     IS_R1_RW|IS_R2_RD,          SCNS)     // r/w    reg , read reg2
IF_DEF(RRW_RRW,     IS_R1_RW|IS_R2_RW,          SCNS)     // r/w    reg , r/w reg2 - for XCHG reg, reg2

#if TGT_x86
IF_DEF(RRW_RRW_CNS, IS_R1_RW|IS_R2_RW,          SCNS)     // r/w    reg , r/w  reg2 , const
#endif

#if TGT_RISC
IF_DEF(RWR_LIT,     IS_R1_WR,                   SPEC)     // write  reg , read [LP]
IF_DEF(JMP_TAB,     IS_NONE,                    JMP )     // table jump
#endif

//----------------------------------------------------------------------------
// The following formats are used for direct addresses (e.g. static data members)
//----------------------------------------------------------------------------

IF_DEF(MRD,         IS_GM_RD,                   SPEC)     // read  [mem] (indirect call req. SPEC)
IF_DEF(MWR,         IS_GM_WR,                   DC  )     // write [mem]
IF_DEF(MRW,         IS_GM_RW,                   DC  )     // r/w   [mem]
IF_DEF(MRD_OFF,     IS_GM_RD,                   DC  )     // offset mem

IF_DEF(RRD_MRD,     IS_GM_RD|IS_R1_RD,          DC  )     // read   reg , read [mem]
IF_DEF(RWR_MRD,     IS_GM_RD|IS_R1_WR,          DC  )     // write  reg , read [mem]
IF_DEF(RRW_MRD,     IS_GM_RD|IS_R1_RW,          DC  )     // r/w    reg , read [mem]

IF_DEF(RWR_MRD_OFF, IS_GM_RD|IS_R1_WR,          DC  )     // write  reg , offset mem

IF_DEF(MRD_RRD,     IS_GM_RD|IS_R1_RD,          DC  )     // read  [mem], read  reg
IF_DEF(MWR_RRD,     IS_GM_WR|IS_R1_RD,          DC  )     // write [mem], read  reg
IF_DEF(MRW_RRD,     IS_GM_RW|IS_R1_RD,          DC  )     // r/w   [mem], read  reg

IF_DEF(MRD_CNS,     IS_GM_RD,                   SPEC)     // read  [mem], const
IF_DEF(MWR_CNS,     IS_GM_WR,                   SPEC)     // write [mem], const
IF_DEF(MRW_CNS,     IS_GM_RW,                   SPEC)     // r/w   [mem], const

IF_DEF(MRW_SHF,     IS_GM_RW,                   SPEC)     // shift [mem], const

//----------------------------------------------------------------------------
// The following formats are used for stack frame refs
//----------------------------------------------------------------------------

IF_DEF(SRD,         IS_SF_RD,                   SPEC)     // read  [stk] (indirect call req. SPEC)
IF_DEF(SRW,         IS_SF_WR,                   NONE)     // write [stk]
IF_DEF(SWR,         IS_SF_RW,                   NONE)     // r/w   [stk]

IF_DEF(RRD_SRD,     IS_SF_RD|IS_R1_RD,          NONE)     // read   reg , read [stk]
IF_DEF(RWR_SRD,     IS_SF_RD|IS_R1_WR,          NONE)     // write  reg , read [stk]
IF_DEF(RRW_SRD,     IS_SF_RD|IS_R1_RW,          NONE)     // r/w    reg , read [stk]

IF_DEF(SRD_RRD,     IS_SF_RD|IS_R1_RD,          NONE)     // read  [stk], read  reg
IF_DEF(SWR_RRD,     IS_SF_WR|IS_R1_RD,          NONE)     // write [stk], read  reg
IF_DEF(SRW_RRD,     IS_SF_RW|IS_R1_RD,          NONE)     // r/w   [stk], read  reg

IF_DEF(SRD_CNS,     IS_SF_RD,                   CNS )     // read  [stk], const
IF_DEF(SWR_CNS,     IS_SF_WR,                   CNS )     // write [stk], const
IF_DEF(SRW_CNS,     IS_SF_RW,                   CNS )     // r/w   [stk], const

IF_DEF(SRW_SHF,     IS_SF_RW,                   CNS )     // shift [stk], const

//----------------------------------------------------------------------------
// The following formats are used for indirect address modes
//----------------------------------------------------------------------------

#if TGT_x86

IF_DEF(ARD,         IS_AM_RD,                   SPEC)     // read  [adr] (indirect call req. SPEC)
IF_DEF(ARW,         IS_AM_WR,                   AMD )     // write [adr]
IF_DEF(AWR,         IS_AM_RW,                   AMD )     // r/w   [adr]

IF_DEF(RRD_ARD,     IS_AM_RD|IS_R1_RD,          AMD )     // read   reg , read [adr]
IF_DEF(RWR_ARD,     IS_AM_RD|IS_R1_WR,          AMD )     // write  reg , read [adr]
IF_DEF(RRW_ARD,     IS_AM_RD|IS_R1_RW,          AMD )     // r/w    reg , read [adr]

IF_DEF(ARD_RRD,     IS_AM_RD|IS_R1_RD,          AMD )     // read  [adr], read  reg
IF_DEF(AWR_RRD,     IS_AM_WR|IS_R1_RD,          AMD )     // write [adr], read  reg
IF_DEF(ARW_RRD,     IS_AM_RW|IS_R1_RD,          AMD )     // r/w   [adr], read  reg

IF_DEF(ARD_CNS,     IS_AM_RD,                   AC  )     // read  [adr], const
IF_DEF(AWR_CNS,     IS_AM_WR,                   AC  )     // write [adr], const
IF_DEF(ARW_CNS,     IS_AM_RW,                   AC  )     // r/w   [adr], const

IF_DEF(ARW_SHF,     IS_AM_RW,                   AC  )     // shift [adr], const

#endif

#if TGT_SH3

IF_DEF(IRD,         IS_IR_RD,                   NONE)     // read  [ind]
IF_DEF(IWR,         IS_IR_WR,                   NONE)     // write [ind]

IF_DEF(IRD_RWR,     IS_IR_RD|IS_R1_WR,          NONE)     // read   reg , write [ind]
IF_DEF(RRD_IWR,     IS_IR_WR|IS_R1_RD,          NONE)     // read  [ind], write  reg

IF_DEF(DRD_RWR,     IS_IR_RD|IS_R1_WR,          DSP )     // read   reg , write [r+d]
IF_DEF(RRD_DWR,     IS_IR_WR|IS_R1_RD,          DSP )     // read  [r+d], write  reg

IF_DEF(0RD_XRD_RWR, IS_IR_RD|IS_R1_RD|IS_R2_WR, NONE)     // read (r0,r), write  reg
IF_DEF(0RD_RRD_XWR, IS_IR_WR|IS_R1_WR|IS_R2_RD, NONE)     // read   reg , write (r0,r)

IF_DEF(AWR_RRD,     IS_R1_RD, /*need arg wrt*/  NONE)     // write [arg], read   reg

IF_DEF(IRD_GBR,     IS_IR_RD,                   NONE)
IF_DEF(IWR_GBR,     IS_IR_WR,                   NONE)

IF_DEF(IRD_RWR_GBR, IS_IR_RD|IS_R1_WR,          NONE)
IF_DEF(RRD_IWR_GBR, IS_IR_WR|IS_R1_RD,          NONE)

#endif

#if TGT_MIPS32

IF_DEF(JR,      IS_R1_RD,                       JMP)
IF_DEF(JR_R,    IS_R1_RD | IS_R2_WR,            JMP)
IF_DEF(RR_R,    IS_R1_RD | IS_R2_RD | IS_R3_WR, SCNS)   // rg3 equiv to small const form of descriptor
IF_DEF(RI_R,    IS_R1_RD | IS_R2_WR,            SCNS)
IF_DEF(RI_R_PL, IS_R1_RD | IS_R2_WR,            SCNS)
IF_DEF(RR_O,    IS_R1_RD | IS_R2_RD,            JMP)
IF_DEF(R_O,     IS_R1_RD,                       JMP)
IF_DEF(RR_M,    IS_R1_RD | IS_R2_RD,            REG)
IF_DEF(M_R,     IS_R1_WR,                       REG)
IF_DEF(R_M,     IS_R1_RD,                       REG)
IF_DEF(AI_R,    IS_R1_RD | IS_R2_WR,            DSP)
IF_DEF(AI_R_PL, IS_R1_RD | IS_R2_WR,            DSP)
IF_DEF(I_R,     IS_R1_WR,                       SCNS)
IF_DEF(I_R_PH,  IS_R1_WR,                       SCNS)
IF_DEF(R_AI,    IS_R1_WR | IS_R2_RD,            DSP)
IF_DEF(R_AI_PL, IS_R1_WR | IS_R2_RD,            DSP)
IF_DEF(RS_R,    IS_R1_RD | IS_R2_WR,            CNS)

#if TGT_MIPSFP
// Floating point instruction formats
IF_DEF(fF_F,	IS_R1_RD | IS_R2_WR,			REG)
IF_DEF(fFF_F,	IS_R1_RD | IS_R2_RD | IS_R3_WR,	REG)
IF_DEF(O,		0,								JMP) // branch on FP status
IF_DEF(fF_Fc,	IS_R1_RD | IS_R2_RD,			REG) // comparisons
IF_DEF(F_R,		IS_R1_RD | IS_R2_WR,			REG)
IF_DEF(AI_F,	IS_R1_RD | IS_R2_WR,			DSP)
IF_DEF(AI_F_P,	IS_R1_RD | IS_R2_WR,			DSP)
#endif // TGT_MIPSFP

#endif // TGT_MIPS32

#if TGT_PPC
#include "instrPPC.h"
#endif

#if TGT_ARM
#include "emitfmtarm.h"
#endif // TGT_ARM


//----------------------------------------------------------------------------
// The following formats are used for FP coprocessor instructions
//----------------------------------------------------------------------------

#if TGT_x86

IF_DEF(FRD,         IS_FP_STK,                  NONE)     // read  ST(n)
IF_DEF(FWR,         IS_FP_STK,                  NONE)     // write ST(n)
IF_DEF(FRW,         IS_FP_STK,                  NONE)     // r/w   ST(n)

IF_DEF(TRD,         IS_FP_STK,                  NONE)     // read  ST(0)
IF_DEF(TWR,         IS_FP_STK,                  NONE)     // write ST(0)
IF_DEF(TRW,         IS_FP_STK,                  NONE)     // r/w   ST(0)

IF_DEF(FRD_TRD,     IS_FP_STK,                  NONE)     // read  ST(n), read ST(0)
IF_DEF(FWR_TRD,     IS_FP_STK,                  NONE)     // write ST(n), read ST(0)
IF_DEF(FRW_TRD,     IS_FP_STK,                  NONE)     // r/w   ST(n), read ST(0)

IF_DEF(TRD_FRD,     IS_FP_STK,                  NONE)     // read  ST(0), read ST(n)
IF_DEF(TWR_FRD,     IS_FP_STK,                  NONE)     // write ST(0), read ST(n)
IF_DEF(TRW_FRD,     IS_FP_STK,                  NONE)     // r/w   ST(0), read ST(n)

IF_DEF(TRD_SRD,     IS_FP_STK|IS_SF_RD,         NONE)     // read  ST(0), read [stk]
IF_DEF(TWR_SRD,     IS_FP_STK|IS_SF_RD,         NONE)     // write ST(0), read [stk]
IF_DEF(TRW_SRD,     IS_FP_STK|IS_SF_RD,         NONE)     // r/w   ST(0), read [stk]

//////(SRD_TRD,     IS_FP_STK|IS_SF_RD,         NONE)     // read  [stk], read ST(n)
IF_DEF(SWR_TRD,     IS_FP_STK|IS_SF_WR,         NONE)     // write [stk], read ST(n)
//////(SRW_TRD,     IS_FP_STK|IS_SF_RW,         NONE)     // r/w   [stk], read ST(n)

IF_DEF(TRD_MRD,     IS_FP_STK|IS_GM_RD,         NONE)     // read  ST(0), read [mem]
IF_DEF(TWR_MRD,     IS_FP_STK|IS_GM_RD,         NONE)     // write ST(0), read [mem]
IF_DEF(TRW_MRD,     IS_FP_STK|IS_GM_RD,         NONE)     // r/w   ST(0), read [mem]

//////(MRD_TRD,     IS_FP_STK|IS_GM_RD,         NONE)     // read  [mem], read ST(n)
IF_DEF(MWR_TRD,     IS_FP_STK|IS_GM_WR,         NONE)     // write [mem], read ST(n)
//////(MRW_TRD,     IS_FP_STK|IS_GM_RW,         NONE)     // r/w   [mem], read ST(n)

IF_DEF(TRD_ARD,     IS_FP_STK|IS_AM_RD,         AMD )     // read  ST(0), read [adr]
IF_DEF(TWR_ARD,     IS_FP_STK|IS_AM_RD,         AMD )     // write ST(0), read [adr]
IF_DEF(TRW_ARD,     IS_FP_STK|IS_AM_RD,         AMD )     // r/w   ST(0), read [adr]

//////(ARD_TRD,     IS_FP_STK|IS_AM_RD,         NONE)     // read  [adr], read ST(n)
IF_DEF(AWR_TRD,     IS_FP_STK|IS_AM_WR,         AMD )     // write [adr], read ST(n)
//////(ARW_TRD,     IS_FP_STK|IS_AM_RW,         NONE)     // r/w   [adr], read ST(n)

#endif

//////////////////////////////////////////////////////////////////////////////

#if TGT_RISC
IF_DEF(DISPINS,     IS_NONE,                    NONE)     // fake instruction
#endif

//////////////////////////////////////////////////////////////////////////////
#endif
#endif
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\ee_jit.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************\
 * This is a compatibility file - it has been replaced by corjit.h			 *
 *****************************************************************************
*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY      *
*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE        *
*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR      *
*  PURPOSE.                                                                   *
*                                                                             *
\*****************************************************************************/

#ifndef EE_JIT_H_
#define EE_JIT_H_

#include <corjit.h>

#if !CORJIT_NO_BACKWARD_COMPATIBILITY

typedef CORINFO_MODULE_HANDLE		SCOPE_HANDLE;
typedef CORINFO_CLASS_HANDLE		CLASS_HANDLE;
typedef CORINFO_METHOD_HANDLE		METHOD_HANDLE;
typedef CORINFO_FIELD_HANDLE		FIELD_HANDLE;
typedef CORINFO_ARG_LIST_HANDLE		ARG_LIST_HANDLE;
typedef CORINFO_SIG_HANDLE			SIG_HANDLE;
typedef CORINFO_GENERIC_HANDLE		GENERIC_HANDLE;
typedef CORINFO_PROFILING_HANDLE	PROFILING_HANDLE;
typedef CORINFO_VARARGS_HANDLE		JIT_VARARGS_HANDLE;

typedef CorInfoHelpFunc				JIT_HELP_FUNCS;
typedef CorJitResult				JIT_RESULT;
typedef CorInfoType					JIT_types;
typedef CorInfoCallConv				JIT_CALL_CONV;
typedef CorInfoUnmanagedCallConv   	UNMANAGED_CALL_CONV;
typedef CorInfoOptions				JIT_OPTIONS;
typedef CorInfoFieldCategory		JIT_FIELDCATEGORY;
typedef CorInfoException			JIT_Exception;

typedef CORINFO_SIG_INFO			JIT_SIG_INFO;
typedef CORINFO_METHOD_INFO			JIT_METHOD_INFO;
typedef CORINFO_EH_CLAUSE_FLAGS		JIT_EH_CLAUSE_FLAGS;
typedef CORINFO_EH_CLAUSE			JIT_EH_CLAUSE;
typedef CORINFO_EE_INFO				EEInfo;

typedef ICorMethodInfo				IJitMethodInfo;
typedef ICorClassInfo				IJitClassInfo;
typedef ICorModuleInfo				IJitScopeInfo;
typedef ICorFieldInfo				IJitFieldInfo;
typedef ICorDebugInfo				IJitDebugInfo;

#define IJitCompiler				ICorJitCompiler	 
#define IJitInfo					ICorJitInfo	 

typedef CORINFO_MethodPtr			JIT_MethodPtr;
typedef CORINFO_Object				JIT_Object;
typedef CORINFO_Array				JIT_Array;
typedef CORINFO_RefAny				JIT_RefAny;
typedef CORINFO_RefArray			JIT_RefArray;
typedef CORINFO_VarArgInfo			JIT_VarArgInfo;

#define JIT_PAGE_SIZE				CORINFO_PAGE_SIZE

#define JIT_OK						CORJIT_OK
#define JIT_REFUSED					CORJIT_REFUSED
#define JIT_OUTOFMEM				CORJIT_OUTOFMEM
#define JIT_INTERNALERROR			CORJIT_INTERNALERROR

#define JIT_TYP_UNDEF				CORINFO_TYPE_UNDEF
#define JIT_TYP_VOID				CORINFO_TYPE_VOID 
#define JIT_TYP_BOOL				CORINFO_TYPE_BOOL 
#define JIT_TYP_CHAR				CORINFO_TYPE_CHAR 
#define JIT_TYP_BYTE				CORINFO_TYPE_BYTE 
#define JIT_TYP_UBYTE				CORINFO_TYPE_UBYTE
#define JIT_TYP_SHORT				CORINFO_TYPE_SHORT 
#define JIT_TYP_USHORT				CORINFO_TYPE_USHORT
#define JIT_TYP_INT					CORINFO_TYPE_INT   
#define JIT_TYP_UINT				CORINFO_TYPE_UINT  
#define JIT_TYP_LONG				CORINFO_TYPE_LONG  
#define JIT_TYP_ULONG				CORINFO_TYPE_ULONG 
#define JIT_TYP_FLOAT				CORINFO_TYPE_FLOAT 
#define JIT_TYP_DOUBLE				CORINFO_TYPE_DOUBLE
#define JIT_TYP_STRING				CORINFO_TYPE_STRING
#define JIT_TYP_PTR					CORINFO_TYPE_PTR   
#define JIT_TYP_BYREF				CORINFO_TYPE_BYREF 
#define JIT_TYP_VALUECLASS			CORINFO_TYPE_VALUECLASS
#define JIT_TYP_CLASS     			CORINFO_TYPE_CLASS     
#define JIT_TYP_REFANY    			CORINFO_TYPE_REFANY    
#define JIT_TYP_COUNT     			CORINFO_TYPE_COUNT     

#define JIT_CALLCONV_DEFAULT    	CORINFO_CALLCONV_DEFAULT    
#define JIT_CALLCONV_C          	CORINFO_CALLCONV_C          
#define JIT_CALLCONV_STDCALL    	CORINFO_CALLCONV_STDCALL    
#define JIT_CALLCONV_THISCALL   	CORINFO_CALLCONV_THISCALL   
#define JIT_CALLCONV_FASTCALL   	CORINFO_CALLCONV_FASTCALL   
#define JIT_CALLCONV_VARARG     	CORINFO_CALLCONV_VARARG     
#define JIT_CALLCONV_FIELD      	CORINFO_CALLCONV_FIELD      
#define JIT_CALLCONV_LOCAL_SIG  	CORINFO_CALLCONV_LOCAL_SIG  
#define JIT_CALLCONV_PROPERTY		CORINFO_CALLCONV_PROPERTY	

#define JIT_CALLCONV_MASK       	CORINFO_CALLCONV_MASK       
#define JIT_CALLCONV_HASTHIS    	CORINFO_CALLCONV_HASTHIS    
#define JIT_CALLCONV_EXPLICITTHIS   CORINFO_CALLCONV_EXPLICTTHIS

#define UNMANAGED_CALLCONV_UNKNOWN	CORINFO_UNMANAGED_CALLCONV_UNKNOWN
#define UNMANAGED_CALLCONV_STDCALL	CORINFO_UNMANAGED_CALLCONV_STDCALL
#define UNMANAGED_CALLCONV_C		CORINFO_UNMANAGED_CALLCONV_C

#define JIT_OPT_INIT_LOCALS			CORINFO_OPT_INIT_LOCALS

#define JIT_EH_CLAUSE_NONE			CORINFO_EH_CLAUSE_NONE    
#define JIT_EH_CLAUSE_FILTER		CORINFO_EH_CLAUSE_FILTER  
#define JIT_EH_CLAUSE_FINALLY		CORINFO_EH_CLAUSE_FINALLY 
#define JIT_EH_CLAUSE_FAULT		    CORINFO_EH_CLAUSE_FAULT

#define FLG_PUBLIC					CORINFO_FLG_PUBLIC                
#define FLG_PRIVATE					CORINFO_FLG_PRIVATE               
#define FLG_PROTECTED				CORINFO_FLG_PROTECTED             
#define FLG_STATIC                	CORINFO_FLG_STATIC                
#define FLG_FINAL                 	CORINFO_FLG_FINAL                 
#define FLG_SYNCH                 	CORINFO_FLG_SYNCH                 
#define FLG_VIRTUAL               	CORINFO_FLG_VIRTUAL               
#define FLG_AGILE                 	CORINFO_FLG_AGILE                 
#define FLG_NATIVE                	CORINFO_FLG_NATIVE                
#define FLG_NOTREMOTABLE          	CORINFO_FLG_NOTREMOTABLE          
#define FLG_EnC						CORINFO_FLG_EnC              
#define FLG_ABSTRACT              	CORINFO_FLG_ABSTRACT              
#define FLG_CONSTRUCTOR           	CORINFO_FLG_CONSTRUCTOR           
#define FLG_CLASS_METHOD          	CORINFO_FLG_CLASS_METHOD          
#define FLG_IMPORT                	CORINFO_FLG_IMPORT                
#define FLG_DELEGATE_INVOKE       	CORINFO_FLG_DELEGATE_INVOKE       
#define FLG_UNCHECKEDPINVOKE  	    CORINFO_FLG_UNCHECKEDPINVOKE
#define FLG_SECURITYCHECK         	CORINFO_FLG_SECURITYCHECK         
#define FLG_JITTERFLAGSMASK       	CORINFO_FLG_JITTERFLAGSMASK       
#define FLG_DONT_INLINE           	CORINFO_FLG_DONT_INLINE           
#define FLG_INLINED               	CORINFO_FLG_INLINED               
#define FLG_NOSIDEEFFECTS         	CORINFO_FLG_NOSIDEEFFECTS         
#define FLG_SPECIAL               	CORINFO_FLG_SPECIAL               
#define FLG_TLS                         CORINFO_FLG_TLS               
#define FLG_TRUSTED               	CORINFO_FLG_TRUSTED               
#define FLG_VALUECLASS            	CORINFO_FLG_VALUECLASS            
#define FLG_INITIALIZED           	CORINFO_FLG_INITIALIZED           
#define FLG_VAROBJSIZE            	CORINFO_FLG_VAROBJSIZE            
#define FLG_ARRAY                 	CORINFO_FLG_ARRAY                 
#define FLG_INTERFACE             	CORINFO_FLG_INTERFACE    
#define FLG_UNMANAGED             	CORINFO_FLG_UNMANAGED             
#define FLG_CONTEXTFUL              CORINFO_FLG_CONTEXTFUL         
#define FLG_OBJECT                  CORINFO_FLG_OBJECT         
#define FLG_CONTAINS_GC_PTR         CORINFO_FLG_CONTAINS_GC_PTR         

#define JIT_FIELDCATEGORY_NORMAL		CORINFO_FIELDCATEGORY_NORMAL   
#define JIT_FIELDCATEGORY_UNKNOWN		CORINFO_FIELDCATEGORY_UNKNOWN  
#define JIT_FIELDCATEGORY_I1_I1			CORINFO_FIELDCATEGORY_I1_I1    
#define JIT_FIELDCATEGORY_I2_I2			CORINFO_FIELDCATEGORY_I2_I2    
#define JIT_FIELDCATEGORY_I4_I4			CORINFO_FIELDCATEGORY_I4_I4    
#define JIT_FIELDCATEGORY_I8_I8			CORINFO_FIELDCATEGORY_I8_I8    
#define JIT_FIELDCATEGORY_BOOLEAN_BOOL	CORINFO_FIELDCATEGORY_BOOLEAN_BOOL
#define JIT_FIELDCATEGORY_CHAR_CHAR		CORINFO_FIELDCATEGORY_CHAR_CHAR
#define JIT_FIELDCATEGORY_UI1_UI1		CORINFO_FIELDCATEGORY_UI1_UI1 
#define JIT_FIELDCATEGORY_UI2_UI2		CORINFO_FIELDCATEGORY_UI2_UI2 
#define JIT_FIELDCATEGORY_UI4_UI4		CORINFO_FIELDCATEGORY_UI4_UI4 
#define JIT_FIELDCATEGORY_UI8_UI8		CORINFO_FIELDCATEGORY_UI8_UI8 

#define JIT_HELP_UNDEF						CORINFO_HELP_UNDEF
#define JIT_HELP_LLSH						CORINFO_HELP_LLSH      
#define JIT_HELP_LRSH						CORINFO_HELP_LRSH
#define JIT_HELP_LRSZ						CORINFO_HELP_LRSZ
#define JIT_HELP_LMUL						CORINFO_HELP_LMUL
#define JIT_HELP_LMUL_OVF					CORINFO_HELP_LMUL_OVF
#define JIT_HELP_ULMUL_OVF					CORINFO_HELP_ULMUL_OVF
#define JIT_HELP_LDIV						CORINFO_HELP_LDIV
#define JIT_HELP_LMOD						CORINFO_HELP_LMOD
#define JIT_HELP_ULDIV						CORINFO_HELP_ULDIV
#define JIT_HELP_ULMOD						CORINFO_HELP_ULMOD
#define JIT_HELP_FLT2INT					CORINFO_HELP_FLT2INT
#define JIT_HELP_FLT2LNG					CORINFO_HELP_FLT2LNG
#define JIT_HELP_DBL2INT					CORINFO_HELP_DBL2INT
#define JIT_HELP_DBL2INT_OVF				CORINFO_HELP_DBL2INT_OVF
#define JIT_HELP_DBL2LNG					CORINFO_HELP_DBL2LNG
#define JIT_HELP_DBL2LNG_OVF				CORINFO_HELP_DBL2LNG_OVF
#define JIT_HELP_FLTREM						CORINFO_HELP_FLTREM
#define JIT_HELP_DBLREM						CORINFO_HELP_DBLREM
#define JIT_HELP_NEW_DIRECT					CORINFO_HELP_NEW_DIRECT
#define JIT_HELP_NEWFAST					CORINFO_HELP_NEWFAST
#define JIT_HELP_UNUSED1					CORINFO_HELP_UNUSED1
#define JIT_HELP_NEWARR_1_DIRECT			CORINFO_HELP_NEWARR_1_DIRECT
#define JIT_HELP_UNUSED2					CORINFO_HELP_UNUSED2
#define JIT_HELP_ISINSTANCEOF				CORINFO_HELP_ISINSTANCEOF
#define JIT_HELP_ISINSTANCEOFCLASS			CORINFO_HELP_ISINSTANCEOFCLASS
#define JIT_HELP_CHKCAST					CORINFO_HELP_CHKCAST
#define JIT_HELP_CHKCASTCLASS				CORINFO_HELP_CHKCASTCLASS
#define JIT_HELP_THROW						CORINFO_HELP_THROW
#define JIT_HELP_RETHROW					CORINFO_HELP_RETHROW
#define JIT_HELP_USER_BREAKPOINT			CORINFO_HELP_USER_BREAKPOINT
#define JIT_HELP_RESOLVEINTERFACE			CORINFO_HELP_RESOLVEINTERFACE 
#define JIT_HELP_EnC_RESOLVEVIRTUAL         CORINFO_HELP_EnC_RESOLVEVIRTUAL
#define JIT_HELP_MON_ENTER					CORINFO_HELP_MON_ENTER
#define JIT_HELP_MON_EXIT					CORINFO_HELP_MON_EXIT
#define JIT_HELP_MON_ENTER_STATIC			CORINFO_HELP_MON_ENTER_STATIC
#define JIT_HELP_MON_EXIT_STATIC			CORINFO_HELP_MON_EXIT_STATIC
#define JIT_HELP_RNGCHKFAIL					CORINFO_HELP_RNGCHKFAIL       
#define JIT_HELP_OVERFLOW					CORINFO_HELP_OVERFLOW         
#define JIT_HELP_STRCNS						CORINFO_HELP_STRCNS           
#define JIT_HELP_ARRADDR_ST					CORINFO_HELP_ARRADDR_ST
#define JIT_HELP_INITCLASS					CORINFO_HELP_INITCLASS        
#define JIT_HELP_STOP_FOR_GC				CORINFO_HELP_STOP_FOR_GC      
#define JIT_HELP_POLL_GC					CORINFO_HELP_POLL_GC          
#define JIT_HELP_ASSIGN_REF_EAX				CORINFO_HELP_ASSIGN_REF_EAX   
#define JIT_HELP_ASSIGN_REF_EBX				CORINFO_HELP_ASSIGN_REF_EBX   
#define JIT_HELP_ASSIGN_REF_ECX				CORINFO_HELP_ASSIGN_REF_ECX   
#define JIT_HELP_ASSIGN_REF_ESI				CORINFO_HELP_ASSIGN_REF_ESI   
#define JIT_HELP_ASSIGN_REF_EDI				CORINFO_HELP_ASSIGN_REF_EDI   
#define JIT_HELP_ASSIGN_REF_EBP				CORINFO_HELP_ASSIGN_REF_EBP   
#define JIT_HELP_GETFIELD32					CORINFO_HELP_GETFIELD32
#define JIT_HELP_SETFIELD32					CORINFO_HELP_SETFIELD32
#define JIT_HELP_GETFIELD64					CORINFO_HELP_GETFIELD64
#define JIT_HELP_SETFIELD64					CORINFO_HELP_SETFIELD64
#define JIT_HELP_GETFIELD32OBJ				CORINFO_HELP_GETFIELD32OBJ
#define JIT_HELP_SETFIELD32OBJ				CORINFO_HELP_SETFIELD32OBJ
#define JIT_HELP_GETFIELDADDR				CORINFO_HELP_GETFIELDADDR
#define JIT_HELP_INTERNALTHROW				CORINFO_HELP_INTERNALTHROW
#define JIT_HELP_INTERNALTHROWSTACK			CORINFO_HELP_INTERNALTHROWSTACK
#define JIT_HELP_NEWOBJ						CORINFO_HELP_NEWOBJ
#define JIT_HELP_ASSIGN_BYREF				CORINFO_HELP_ASSIGN_BYREF
#define JIT_HELP_CHECKED_ASSIGN_REF_EAX		CORINFO_HELP_CHECKED_ASSIGN_REF_EAX
#define JIT_HELP_CHECKED_ASSIGN_REF_EBX		CORINFO_HELP_CHECKED_ASSIGN_REF_EBX
#define JIT_HELP_CHECKED_ASSIGN_REF_ECX		CORINFO_HELP_CHECKED_ASSIGN_REF_ECX
#define JIT_HELP_CHECKED_ASSIGN_REF_ESI		CORINFO_HELP_CHECKED_ASSIGN_REF_ESI
#define JIT_HELP_CHECKED_ASSIGN_REF_EDI		CORINFO_HELP_CHECKED_ASSIGN_REF_EDI
#define JIT_HELP_CHECKED_ASSIGN_REF_EBP		CORINFO_HELP_CHECKED_ASSIGN_REF_EBP
#define JIT_HELP_BOX						CORINFO_HELP_BOX
#define JIT_HELP_UNBOX						CORINFO_HELP_UNBOX
#define JIT_HELP_GETREFANY					CORINFO_HELP_GETREFANY
#define JIT_HELP_NEWSFAST					CORINFO_HELP_NEWSFAST          
#define JIT_HELP_NEW_SPECIALDIRECT			CORINFO_HELP_NEW_SPECIALDIRECT 
#define JIT_HELP_ENDCATCH					CORINFO_HELP_ENDCATCH          

#define JIT_HELP_PROF_FCN_CALL			CORINFO_HELP_PROF_FCN_CALL
#define JIT_HELP_PROF_FCN_RET			CORINFO_HELP_PROF_FCN_RET
#define JIT_HELP_PROF_FCN_ENTER			CORINFO_HELP_PROF_FCN_ENTER
#define JIT_HELP_PROF_FCN_LEAVE			CORINFO_HELP_PROF_FCN_LEAVE
#define JIT_HELP_PROF_FCN_TAILCALL      CORINFO_HELP_PROF_FCN_TAILCALL

#define JIT_HELP_STRESS_GC					CORINFO_HELP_STRESS_GC			
#define JIT_HELP_RESOLVEINTERFACETRUSTED	CORINFO_HELP_RESOLVEINTERFACETRUSTED
#define JIT_HELP_GC_STATE					CORINFO_HELP_GC_STATE        
#define JIT_HELP_GETSTATICDATA				CORINFO_HELP_GETSTATICDATA
#define JIT_HELP_TAILCALL                   CORINFO_HELP_TAILCALL
#define JIT_HELP_I4_DIV						CORINFO_HELP_I4_DIV
#define JIT_HELP_I4_MOD						CORINFO_HELP_I4_MOD
#define JIT_HELP_U4_DIV						CORINFO_HELP_U4_DIV
#define JIT_HELP_U4_MOD						CORINFO_HELP_U4_MOD
#define JIT_HELP_R4_NEG						CORINFO_HELP_R4_NEG
#define JIT_HELP_R8_NEG						CORINFO_HELP_R8_NEG
#define JIT_HELP_R4_ADD						CORINFO_HELP_R4_ADD
#define JIT_HELP_R8_ADD						CORINFO_HELP_R8_ADD
#define JIT_HELP_R4_SUB						CORINFO_HELP_R4_SUB
#define JIT_HELP_R8_SUB						CORINFO_HELP_R8_SUB
#define JIT_HELP_R4_MUL						CORINFO_HELP_R4_MUL
#define JIT_HELP_R8_MUL						CORINFO_HELP_R8_MUL
#define JIT_HELP_R4_DIV						CORINFO_HELP_R4_DIV
#define JIT_HELP_R8_DIV						CORINFO_HELP_R8_DIV
#define JIT_HELP_R4_EQ						CORINFO_HELP_R4_EQ
#define JIT_HELP_R8_EQ						CORINFO_HELP_R8_EQ
#define JIT_HELP_R4_NE						CORINFO_HELP_R4_NE
#define JIT_HELP_R8_NE						CORINFO_HELP_R8_NE
#define JIT_HELP_R4_LT						CORINFO_HELP_R4_LT
#define JIT_HELP_R8_LT						CORINFO_HELP_R8_LT
#define JIT_HELP_R4_LE						CORINFO_HELP_R4_LE
#define JIT_HELP_R8_LE						CORINFO_HELP_R8_LE
#define JIT_HELP_R4_GE						CORINFO_HELP_R4_GE
#define JIT_HELP_R8_GE						CORINFO_HELP_R8_GE
#define JIT_HELP_R4_GT						CORINFO_HELP_R4_GT
#define JIT_HELP_R8_GT						CORINFO_HELP_R8_GT
#define JIT_HELP_R8_TO_I4					CORINFO_HELP_R8_TO_I4
#define JIT_HELP_R8_TO_I8					CORINFO_HELP_R8_TO_I8
#define JIT_HELP_R8_TO_R4					CORINFO_HELP_R8_TO_R4
#define JIT_HELP_R4_TO_I4					CORINFO_HELP_R4_TO_I4
#define JIT_HELP_R4_TO_I8					CORINFO_HELP_R4_TO_I8
#define JIT_HELP_R4_TO_R8					CORINFO_HELP_R4_TO_R8
#define JIT_HELP_I4_TO_R4					CORINFO_HELP_I4_TO_R4
#define JIT_HELP_I4_TO_R8					CORINFO_HELP_I4_TO_R8
#define JIT_HELP_I8_TO_R4					CORINFO_HELP_I8_TO_R4
#define JIT_HELP_I8_TO_R8					CORINFO_HELP_I8_TO_R8
#define JIT_HELP_U4_TO_R4					CORINFO_HELP_U4_TO_R4
#define JIT_HELP_U4_TO_R8					CORINFO_HELP_U4_TO_R8
#define JIT_HELP_U8_TO_R4					CORINFO_HELP_U8_TO_R4
#define JIT_HELP_U8_TO_R8					CORINFO_HELP_U8_TO_R8
#define JIT_HELP_WRAP                       CORINFO_HELP_WRAP
#define JIT_HELP_UNWRAP                     CORINFO_HELP_UNWRAP
#define JIT_HELP_COUNT						CORINFO_HELP_COUNT

#define JIT_NullReferenceException			CORINFO_NullReferenceException
#define JIT_DivideByZeroException			CORINFO_DivideByZeroException
#define JIT_InvalidCastException			CORINFO_InvalidCastException
#define JIT_IndexOutOfRangeException		CORINFO_IndexOutOfRangeException
#define JIT_OverflowException				CORINFO_OverflowException
#define JIT_SynchronizationLockException	CORINFO_SynchronizationLockException
#define JIT_ArrayTypeMismatchException		CORINFO_ArrayTypeMismatchException
#define JIT_RankException					CORINFO_RankException
#define JIT_ArgumentNullException           CORINFO_ArgumentNullException
#define JIT_Exception_Count					CORINFO_Exception_Count

#endif // !CORJIT_NO_BACKWARD_COMPATIBILITY

#endif // EE_JIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitinl.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EMITINL_H_
#define _EMITINL_H_
/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************
 *
 *  Return the number of bytes of machine code the given instruction will
 *  produce.
 */

inline
size_t              emitter::emitInstCodeSz(instrDesc    *id)
{
    if  (id->idInsFmt == IF_EPILOG)
        return MAX_EPILOG_SIZE;
    return   id->idCodeSize;
}

inline
size_t              emitter::emitSizeOfJump(instrDescJmp *jmp)
{
    return  jmp->idCodeSize;
}

/*****************************************************************************
 *
 *  Given a jump, return true if it's a conditional jump.
 */

inline
bool                emitter::emitIsCondJump(instrDesc *jmp)
{
    instruction     ins = (instruction)jmp->idIns;

    assert(jmp->idInsFmt == IF_LABEL);

    return  (ins != INS_call && ins != INS_jmp);
}

/*****************************************************************************
 *
 *  The following helpers should be used to access the various values that
 *  get stored in different places within the instruction descriptor.
 */

inline
int                 emitter::emitGetInsAmd   (instrDesc *id)
{
    return  id->idInfo.idLargeDsp ? ((instrDescAmd*)id)->idaAmdVal
                                  : id->idAddr.iiaAddrMode.amDisp;
}

inline
void                emitter::emitGetInsCns   (instrDesc *id, CnsVal *cv)
{
#ifdef RELOC_SUPPORT
    cv->cnsReloc =                    id ->idInfo.idCnsReloc;
#endif
    if  (id->idInfo.idLargeCns)
    {
        cv->cnsVal =  ((instrDescCns*)id)->idcCnsVal;
    }
    else
    {
        cv->cnsVal =                  id ->idInfo.idSmallCns;
    }
}

inline
int                 emitter::emitGetInsAmdCns(instrDesc *id, CnsVal *cv)
{
#ifdef RELOC_SUPPORT
    cv->cnsReloc =                           id ->idInfo.idCnsReloc;
#endif
    if  (id->idInfo.idLargeDsp)
    {
        if  (id->idInfo.idLargeCns)
        {
            cv->cnsVal = ((instrDescAmdCns*) id)->idacCnsVal;
            return       ((instrDescAmdCns*) id)->idacAmdVal;
        }
        else
        {
            cv->cnsVal =                     id ->idInfo.idSmallCns;
            return          ((instrDescAmd*) id)->idaAmdVal;
        }
    }
    else
    {
        if  (id->idInfo.idLargeCns)
            cv->cnsVal =   ((instrDescCns *) id)->idcCnsVal;
        else
            cv->cnsVal =                     id ->idInfo.idSmallCns;

        return  id->idAddr.iiaAddrMode.amDisp;
    }
}

inline
void                emitter::emitGetInsDcmCns(instrDesc *id, CnsVal *cv)
{
    assert(id->idInfo.idLargeCns);
    assert(id->idInfo.idLargeDsp);
#ifdef RELOC_SUPPORT
    cv->cnsReloc =                    id ->idInfo.idCnsReloc;
#endif
    cv->cnsVal   =    ((instrDescDCM*)id)->idcmCval;
}

inline
int                 emitter::emitGetInsAmdAny(instrDesc *id)
{
    /* The following is a bit sleazy but awfully convenient */

    assert(offsetof(instrDescAmd   ,  idaAmdVal) ==
           offsetof(instrDescAmdCns, idacAmdVal));

    return  emitGetInsAmd(id);
}

/*****************************************************************************
 *
 *  Convert between a register mask and a smaller version for storage.
 */

#if TRACK_GC_REFS

inline
unsigned            emitter::emitEncodeCallGCregs(unsigned regs)
{
    unsigned        mask = 0;

    if  (regs & RBM_EAX)     mask |= 0x01;
    if  (regs & RBM_ECX)     mask |= 0x02;
    if  (regs & RBM_EDX)     mask |= 0x04;
    if  (regs & RBM_EBX)     mask |= 0x08;
    if  (regs & RBM_ESI)     mask |= 0x10;
    if  (regs & RBM_EDI)     mask |= 0x20;
    if  (regs & RBM_EBP)     mask |= 0x40;

    return  mask;
}

inline
void                emitter::emitEncodeCallGCregs(unsigned regs, instrDesc *id)
{
    unsigned        mask1 = 0;
    unsigned        mask2 = 0;

    assert((regs & RBM_EDX) == 0);      // currently no place to save EDX

    if  (regs & RBM_EAX)     mask1 |= 0x01;
    if  (regs & RBM_ECX)     mask1 |= 0x02;
    if  (regs & RBM_EBX)     mask1 |= 0x04;

    if  (regs & RBM_ESI)     mask2 |= 0x01;
    if  (regs & RBM_EDI)     mask2 |= 0x02;
    if  (regs & RBM_EBP)     mask2 |= 0x04;

    id->idReg = mask1;
    id->idRg2 = mask2;
}

inline
unsigned            emitter::emitDecodeCallGCregs(unsigned mask)
{
    unsigned        regs = 0;

    if  (mask & 0x01)        regs |= RBM_EAX;
    if  (mask & 0x02)        regs |= RBM_ECX;
    if  (mask & 0x04)        regs |= RBM_EDX;
    if  (mask & 0x08)        regs |= RBM_EBX;
    if  (mask & 0x10)        regs |= RBM_ESI;
    if  (mask & 0x20)        regs |= RBM_EDI;
    if  (mask & 0x40)        regs |= RBM_EBP;

    return  regs;
}

inline
unsigned            emitter::emitDecodeCallGCregs(instrDesc *id)
{
    unsigned        regs  = 0;
    unsigned        mask1 = id->idRegGet();
    unsigned        mask2 = id->idRg2Get();

    if  (mask1 & 0x01)       regs |= RBM_EAX;
    if  (mask1 & 0x02)       regs |= RBM_ECX;
    if  (mask1 & 0x04)       regs |= RBM_EBX;

    if  (mask2 & 0x01)       regs |= RBM_ESI;
    if  (mask2 & 0x02)       regs |= RBM_EDI;
    if  (mask2 & 0x04)       regs |= RBM_EBP;

    return  regs;
}

#endif

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************
 *
 *  Returns true if the given instruction can be moved around during
 *  instruction scheduling.
 */

inline
bool                emitter::scIsSchedulable(instruction ins)
{
    if  (ins == INS_noSched)    // explicit scheduling boundary
        return  false;

    if  (ins == INS_i_jmp)
        return  false;

    if  (ins == INS_call)
        return  false;

    if  (ins == INS_ret)
        return  false;

    return true;
}

inline
bool                emitter::scIsSchedulable(instrDesc *id)
{
    instruction ins = id->idInsGet();

    if (!scIsSchedulable(ins))
        return false;

    /* UNDONE: Mark FP instrs as non-schedulable */

    if  (Compiler::instIsFP(ins))
        return  false;

    /* These instructions implicitly modify aliased memory. As the
       scheduler has no knowledge about aliasing, we have to assume that
       they can touch any memory. So dont schedule across them.
       @TODO : We could provide the scheduler with sufficient info such
       that it can do the aliasing analysis.
     */

    if  (id->idInsFmt == IF_NONE)
    {
        switch(ins)
        {
        case INS_r_movsb:
        case INS_r_movsd:
        case INS_movsd:
        case INS_r_stosb:
        case INS_r_stosd:
            return false;
        }
    }

    assert(id->idInsFmt != IF_EPILOG);

    if  (id->idInsFmt == IF_LABEL)
    {
        if  (!((instrDescJmp*)id)->idjSched)
            return  false;
    }

    return  true;
}

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#if TGT_RISC && !TGT_IA64
/*****************************************************************************
 *
 *  Return the number of bytes of machine code the given instruction will
 *  produce.
 */

inline
size_t              emitter::emitInstCodeSz(instrDesc *id)
{
    assert(id->idIns <  INS_count);
    //assert(id->idIns != INS_ignore);
    if (id->idIns == INS_ignore)
        return 0;

    if  (id->idInsFmt == IF_JMP_TAB)
        return  ((instrDescJmp*)id)->idjCodeSize;

#if TGT_MIPS32
    if  ( (id->idInsFmt == IF_LABEL) ||
          (id->idInsFmt == IF_JR_R)  || (id->idInsFmt == IF_JR) ||
          (id->idInsFmt == IF_RR_O)  || (id->idInsFmt == IF_R_O)
#if TGT_MIPSFP
                  || (id->idInsFmt == IF_O)
#endif
                  )
        return  emitSizeOfJump((instrDescJmp*)id);
#else
    if  (id->idInsFmt == IF_LABEL)
        return  emitSizeOfJump((instrDescJmp*)id);
#endif

    return  INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Given a jump, return true if it's a conditional jump.
 */

inline
bool                emitter::emitIsCondJump(instrDesc *jmp)
{
    instruction     ins = (instruction)jmp->idIns;

#if TGT_MIPSFP
        assert( (jmp->idInsFmt == IF_LABEL) ||
            (jmp->idInsFmt == IF_JR_R)  || (jmp->idInsFmt == IF_JR) ||
            (jmp->idInsFmt == IF_RR_O)  || (jmp->idInsFmt == IF_R_O) ||
                        (jmp->idInsFmt == IF_O));
#elif TGT_MIPS32
    assert( (jmp->idInsFmt == IF_LABEL) ||
            (jmp->idInsFmt == IF_JR_R)  || (jmp->idInsFmt == IF_JR) ||
            (jmp->idInsFmt == IF_RR_O)  || (jmp->idInsFmt == IF_R_O));
#else
    assert(jmp->idInsFmt == IF_LABEL);
#endif

#if   TGT_SH3
    return  (ins != INS_braf  && ins != INS_bra && ins != INS_bsr);
#elif TGT_MIPS32
    return  (ins != INS_jr  && ins != INS_j  && ins != INS_jal  && ins != INS_jalr);
#elif TGT_ARM
    return( ins != INS_b && ins != INS_bl );
#elif TGT_PPC
    return (ins == INS_bc);
#elif TGT_IA64
    UNIMPL("iscondjump");
    return false;
#elif
    assert (!"nyi");
#endif
}

/*****************************************************************************/
#endif//TGT_RISC && !TGT_IA64
/*****************************************************************************/
#if     TGT_SH3
/*****************************************************************************
 *
 *  Inline short-cuts to generate variations of the same opcode.
 */

inline
void                emitter::emitIns_IR_R (emitRegs areg,
                                           emitRegs dreg,
                                           bool      autox,
                                           int       size,
                                           bool      isfloat)
{
    emitIns_IMOV(IF_IRD_RWR, dreg, areg, autox, size, isfloat);
}

inline
void                emitter::emitIns_R_IR (emitRegs dreg,
                                           emitRegs areg,
                                           bool      autox,
                                           int       size,
                                           bool      isfloat)
{
    emitIns_IMOV(IF_RRD_IWR, dreg, areg, autox, size, isfloat);
}

inline
void                emitter::emitIns_R_XR0(emitRegs dreg,
                                           emitRegs areg,
                                           int       size)
{
    emitIns_X0MV(IF_0RD_XRD_RWR, dreg, areg, size);
}

inline
void                emitter::emitIns_XR0_R(emitRegs areg,
                                           emitRegs dreg,
                                           int       size)
{
    emitIns_X0MV(IF_0RD_RRD_XWR, dreg, areg, size);
}

// ============================
inline
void                emitter::emitIns_I_GBR_R(int       size)
{
    emitIns_Ig(INS_lod_gbr, false, size);
}

inline
void                emitter::emitIns_R_I_GBR(int       size)
{
    emitIns_Ig(INS_sto_gbr, false, size);
}

// ============================
inline
void                emitter::emitIns_R_RD (emitRegs dreg,
                                           emitRegs areg,
                                           int       offs,
                                           int       size)
{
    emitIns_RDMV(IF_DRD_RWR, dreg, areg, offs, size);
}

inline
void                emitter::emitIns_RD_R (emitRegs areg,
                                           emitRegs dreg,
                                           int       offs,
                                           int       size)
{
    emitIns_RDMV(IF_RRD_DWR, dreg, areg, offs, size);
}

/*****************************************************************************
 *
 *  Convert between a register mask and a smaller version for storage.
 */

#if TRACK_GC_REFS

inline
unsigned            emitter::emitEncodeCallGCregs(unsigned regs)
{
    #error  GC ref tracking for RISC NYI
}

inline
unsigned            emitter::emitDecodeCallGCregs(unsigned mask)
{
    #error  GC ref tracking for RISC NYI
}

#endif

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************
 *
 *  Returns true if the given instruction can be moved around during
 *  instruction scheduling.
 */

inline
bool                emitter::scIsSchedulable(instruction ins)
{
    if  (ins == INS_noSched)    // explicit scheduling boundary
        return  false;

    return  true;
}

inline
bool                emitter::scIsSchedulable(instrDesc *id)
{
    /* We should never encounter a "swapped" instructin here, right? */

    assert(id->idSwap == false);

    if  (!scIsSchedulable(id->idIns))
        return false;

    return  true;
}

/*****************************************************************************
 *
 *  Returns true if the given instruction is a jump or a call.
 */

inline
bool                emitter::scIsBranchIns(instruction ins)
{
    return  Compiler::instIsBranch(ins);
}

/*****************************************************************************/
#if     MAX_BRANCH_DELAY_LEN
/*****************************************************************************
 *
 *  Returns true if the given instruction is a jump or a call with delay slot(s).
 */

inline
bool                emitter::scIsBranchIns(scDagNode *node)
{
    return  node->sdnBranch;
}

/*****************************************************************************
 *
 *  Return true if the given dag node corresponds to a branch instruction
 *  that cannot be issued yet.
 */

inline
bool                emitter::scIsBranchTooEarly(scDagNode *node)
{
    /* Is this a branch instruction? */

    if  (scIsBranchIns(node))
    {
        /* Is it too early to issue the branch? */

        if  (scIssued < scBDTmin)
            return  true;
    }

    return  false;
}

/*****************************************************************************/
#endif//MAX_BRANCH_DELAY_LEN
/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************
 *
 *  Return the size of the jump we'll have to insert to jump over a literal
 *  pool that got placed in an unfortunate place.
 */

inline
size_t              emitter::emitLPjumpOverSize(litPool *lp)
{
    assert(lp->lpJumpIt);

    // note : nop is necessary because prev instr could be a jsr
    // we could pick a smarter place to break but this is easy
    if  (lp->lpJumpSmall)
        return  3 * INSTRUCTION_SIZE;           // nop + bra + nop
    else
        return  4 * INSTRUCTION_SIZE;           // nop + mov + br  + nop

}

/*****************************************************************************/
#endif//TGT_SH3
#if TGT_ARM
inline
size_t              emitter::emitLPjumpOverSize(litPool *lp)
{
    assert(lp->lpJumpIt);

    return INSTRUCTION_SIZE;           //  br

}

#endif //TGT_ARM
/*****************************************************************************/
#if     EMIT_USE_LIT_POOLS
/*****************************************************************************
 *
 *  Given a literal pool referencing instruction, return the "call type"
 *  of the reference (which is not necessarily a method).
 */

inline
gtCallTypes         emitter::emitGetInsLPRtyp(instrDesc *id)
{
    return  (gtCallTypes)id->idInfo.idSmallCns;
}

/*****************************************************************************
 *
 *  Given an instruction that references a method address (via a literal
 *  pool entry), return the address of the method if it's available (NULL
 *  otherwise).
 */

#if SMALL_DIRECT_CALLS

inline
BYTE    *           emitter::emitMethodAddr(instrDesc *lprID)
{
    gtCallTypes     callTyp = emitGetInsLPRtyp(lprID);
    METHOD_HANDLE   callHnd = lprID->idAddr.iiaMethHnd;
    BYTE *          addr;
    InfoAccessType  accessType;

    if  (callTyp == CT_DESCR)
    {
        addr = (BYTE*)emitComp->eeGetMethodEntryPoint(callHnd, &accessType);
        assert(accessType == IAT_PVALUE);
        return addr;
    }

    assert(callTyp == CT_USER_FUNC);

    if  (emitComp->eeIsOurMethod(callHnd))
    {
        /* Directly recursive call */

        return  emitCodeBlock;
    }
    else
    {
        addr = (BYTE*)emitComp->eeGetMethodEntryPoint(callHnd, &accessType);
        assert(accessType == IAT_PVALUE);
        return addr;
    }
}

#endif

/*****************************************************************************/
#endif//TGT_RISC
/*****************************************************************************/
#if SCHEDULER
/*****************************************************************************/
#if TGT_IA64
/*****************************************************************************
 *
 *  Map instruction value to the execution unit that can handle it.
 */

extern
unsigned char       genInsXUs[INS_count];

inline
IA64execUnits       genInsXU(instruction ins)
{
    assert(ins < INS_count); return (IA64execUnits)genInsXUs[ins];
}

/*****************************************************************************
 *
 *  Map instruction value to its functional class.
 */

extern
unsigned char       genInsFUs[INS_count];

inline
IA64funcUnits       genInsFU(instruction ins)
{
    assert(ins < INS_count); return (IA64funcUnits)genInsFUs[ins];
}

/*****************************************************************************
 *
 *  Map instruction value to its encoding index / value.
 */

extern
unsigned char       genInsEncIdxTab[INS_count];

inline
NatUns              genInsEncIdx(instruction ins)
{
    assert(ins < INS_count); return genInsEncIdxTab[ins];
}

extern
NatUns              genInsEncValTab[INS_count];

inline
NatUns              genInsEncVal(instruction ins)
{
    assert(ins < INS_count); return genInsEncValTab[ins];
}

/*****************************************************************************
 *
 *  Returns true if the given instruction can be moved around during
 *  instruction scheduling.
 */

inline
bool                emitter::scIsSchedulable(instruction ins)
{
    if  (genInsXU(ins) == XU_B)
        return  false;

    return  true;
}

inline
bool                emitter::scIsSchedulable(instrDesc *id)
{
    instruction ins = id->idInsGet();

    if  (!scIsSchedulable(ins))
        return false;

    // any other cases?

    return  true;
}

/*****************************************************************************/
#endif//TGT_IA64
/*****************************************************************************
 *
 *  Record a dependency for an instruction that defs the given entry.
 */

inline
void                emitter::scDepDef(scDagNode *node,
                                      const char*name, schedDef_tp def,
                                                       schedUse_tp use, bool antiOnly)
{
    scDagList *  useLst;

    /*
        Check for an output dependency; note that we check only the first
        def that follows after our instruction. We can do this because we
        know that any further defs must already have a dependency entry,
        so it's not necessary to add them (i.e. the transitive closure is
        done implicitly).
     */

    if  (def)
    {
        /* There is an output dependency */

        scAddDep(node, def, antiOnly ? SC_DEP_ANTI : SC_DEP_OUT, name);
    }

    /*
        Check for any flow dependencies; since no dependencies are noted
        between multiple uses, we keep all the "active" uses on a list
        and mark dependencies for all of them here.
     */

    scDepKinds  kind = antiOnly ? SC_DEP_ANTI : SC_DEP_FLOW;

    for (useLst = use; useLst; useLst = useLst->sdlNext)
    {
        /* There is a flow dependency */

        scAddDep(node, useLst->sdlNode, kind, name);
    }
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that defs the given register.
 */

inline
void                emitter::scDepDefReg(scDagNode *node, emitRegs reg)
{
#ifdef  DEBUG
    char            temp[32]; sprintf(temp, "reg %s", emitRegName(reg));
#endif
    scDepDef(node, temp, scRegDef[reg], scRegUse[reg], false);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses the given register.
 */

inline
void                emitter::scDepUseReg(scDagNode *node, emitRegs reg)
{
#ifdef  DEBUG
    char            temp[32]; sprintf(temp, "reg %s", emitRegName(reg));
#endif
    scDepUse(node, temp, scRegDef[reg], scRegUse[reg]);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  register.
 */

inline
void                emitter::scUpdDefReg(scDagNode *node, emitRegs reg)
{
    scUpdDef(node, &scRegDef[reg], &scRegUse[reg]);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  register.
 */

inline
void                emitter::scUpdUseReg(scDagNode *node, emitRegs reg)
{
    scUpdUse(node, &scRegDef[reg], &scRegUse[reg]);
}

/*****************************************************************************/
#if     TGT_IA64
/*****************************************************************************
 *
 *  Record a dependency for an instruction that defs the given frame slot.
 */

inline
void                emitter::scDepDefFrm(scDagNode   *node,
                                         instrDesc   *id,
                                         scStkDepRTP  frm)
{

#ifdef  DEBUG
    char            temp[32]; sprintf(temp, "frm[%u]", frm);
#endif

    scDepDef(node, temp, frm->ssdDef, frm->ssdUse, false);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses the given frame slot.
 */

inline
void                emitter::scDepUseFrm(scDagNode   *node,
                                         instrDesc   *id,
                                         scStkDepRTP  frm)
{

#ifdef  DEBUG
    char            temp[32]; sprintf(temp, "frm[%u]", frm);
#endif

    scDepUse(node, temp, frm->ssdDef, frm->ssdUse);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  stack slot.
 */

inline
void                emitter::scUpdDefFrm(scDagNode   *node,
                                         scStkDepRTP  frm)
{
    scUpdDef(node, &frm->ssdDef, &frm->ssdUse);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  stack slot.
 */

inline
void                emitter::scUpdUseFrm(scDagNode   *node,
                                         scStkDepRTP  frm)
{
    scUpdUse(node, &frm->ssdDef, &frm->ssdUse);
}

/*****************************************************************************/
#else //TGT_IA64
/*****************************************************************************
 *
 *  Record a dependency for an instruction that defs the given frame slot.
 */

inline
void                emitter::scDepDefFrm(scDagNode   *node,
                                         instrDesc   *id,
                                         unsigned     frm)
{
    assert(frm < scFrmUseSiz);

#ifdef  DEBUG
    char            temp[32]; sprintf(temp, "frm[%u]", frm);
#endif

    scDepDef(node, temp, scFrmDef[frm], scFrmUse[frm], false);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses the given frame slot.
 */

inline
void                emitter::scDepUseFrm(scDagNode   *node,
                                         instrDesc   *id,
                                         unsigned     frm)
{
    assert(frm < scFrmUseSiz);

#ifdef  DEBUG
    char            temp[32]; sprintf(temp, "frm[%u]", frm);
#endif

    scDepUse(node, temp, scFrmDef[frm], scFrmUse[frm]);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  stack slot.
 */

inline
void                emitter::scUpdDefFrm(scDagNode   *node,
                                         unsigned     frm)
{
    assert(frm < scFrmUseSiz);
    scUpdDef(node, scFrmDef+frm, scFrmUse+frm);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  stack slot.
 */

inline
void                emitter::scUpdUseFrm(scDagNode   *node,
                                         unsigned     frm)
{
    assert(frm < scFrmUseSiz);
    scUpdUse(node, scFrmDef+frm, scFrmUse+frm);
}

/*****************************************************************************/
#endif//TGT_IA64
/*****************************************************************************/
#if     SCHED_USE_FL
/*****************************************************************************
 *
 *  Record a dependency for an instruction that sets flags.
 */

inline
void                emitter::scDepDefFlg(scDagNode *node)
{
    if  (scFlgDef)
        scAddDep(node, scFlgDef, SC_DEP_OUT , "FLAGS");
    if  (scFlgUse)
        scAddDep(node, scFlgUse, SC_DEP_FLOW, "FLAGS");
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses flags.
 */

inline
void                emitter::scDepUseFlg(scDagNode *node, scDagNode *begp,
                                                             scDagNode *endp)
{
    while (begp != endp)
    {
        instrDesc   *   id  = scGetIns(begp);
        instruction     ins = id->idInsGet();

        if  (emitComp->instInfo[ins] & INST_DEF_FL)
            scAddDep(node, begp, SC_DEP_ANTI, "FLAGS");

        begp++;
    }
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that sets flags.
 */

inline
void                emitter::scUpdDefFlg(scDagNode *node)
{
    if  (scFlgUse || scFlgEnd)
    {
        scFlgDef = node;
        scFlgUse = NULL;
        scFlgEnd = false;
    }
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses flags.
 */

inline
void                emitter::scUpdUseFlg(scDagNode *node)
{
    /* As we dont keep a list of users for flags, if there are multiple
       users of flags, just pretend there is a dependancy between the various
       users. This will enforce a more stricter ordering than necessary, but
       it happens very rarely (eg. X=((Y+ovfZ)==0) produces add;jo;sete; )
       @CONSIDER: Keep a list of users for flags.
     */

    if (scFlgUse)
    {
        scDepUse(node, "FLAGS", scFlgUse, NULL);
    }

    scFlgUse = node;
    scFlgDef = NULL;
}

/*****************************************************************************/
#endif//SCHED_USE_FL
/*****************************************************************************
 *
 *  Record a dependency for an instruction that defs the given global.
 */

inline
void                emitter::scDepDefGlb(scDagNode *node, FIELD_HANDLE MBH)
{
#ifdef  DEBUG
//  char            temp[32]; sprintf(temp, "glob[%s]", scFldName(MBX, SCP));
    char            temp[32]; sprintf(temp, "global");
#endif
    scDepDef(node, temp, scGlbDef, scGlbUse, false);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses the given global.
 */

inline
void                emitter::scDepUseGlb(scDagNode *node, FIELD_HANDLE MBH)
{
#ifdef  DEBUG
//  char            temp[32]; sprintf(temp, "glob[%s]", scFldName(MBH));
    char            temp[32]; sprintf(temp, "global");
#endif
    scDepUse(node, temp, scGlbDef, scGlbUse);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  global.
 */

inline
void                emitter::scUpdDefGlb(scDagNode *node, FIELD_HANDLE MBH)
{
    scUpdDef(node, &scGlbDef, &scGlbUse);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  global.
 */

inline
void                emitter::scUpdUseGlb(scDagNode *node, FIELD_HANDLE MBH)
{
    scUpdUse(node, &scGlbDef, &scGlbUse);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  indirection.
 */

inline
void                emitter::scUpdDefInd(scDagNode *node, unsigned am)
{
    assert(am < sizeof(scIndUse));
    scUpdDef(node, scIndDef+am, scIndUse+am);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  indirection.
 */

inline
void                emitter::scUpdUseInd(scDagNode *node, unsigned am)
{
    assert(am < sizeof(scIndUse));
    scUpdUse(node, scIndDef+am, scIndUse+am);
}

/*****************************************************************************
 *
 *  Record a dependency for an instruction that uses the given entry.
 */

inline
void                emitter::scDepUse(scDagNode *node,
                                      const char*name, schedDef_tp def,
                                                       schedUse_tp use)

{
    /* Check for anti-dependence */

    if  (def)
    {
        /* There is an anti-dependence */

        scAddDep(node, def, SC_DEP_ANTI, name);
    }
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that defs the given
 *  entry.
 */

inline
void                emitter::scUpdDef(scDagNode *node, schedDef_tp*defPtr,
                                                       schedUse_tp*usePtr)
{
    /* Set the current definition to the defining instruction */

    *defPtr = node;

    /*
        Clear the use list, since all existing uses have just been marked
        as dependencies so no need to keep them around.
     */

    scClrUse(usePtr);
}

/*****************************************************************************
 *
 *  Update the dependency state following an instruction that uses the given
 *  register.
 */

inline
void                emitter::scUpdUse(scDagNode *node, schedDef_tp*defPtr,
                                                       schedUse_tp*usePtr)
{
    /* Add the entry to the use list */

    scAddUse(usePtr, node);
}

/*****************************************************************************
 *
 *  Return the appropriate address mode index for the given instruction; note
 *  that we currently only distinguish based on size, as follows:
 *
 *      0   ..   8-bit values
 *      1   ..  16-bit values
 *      2   ..  32-bit values
 *      3   ..  64-bit values
 *      4   ..  GC ref values
 */

inline
unsigned            emitter::scIndDepIndex(instrDesc *id)
{
    assert(emitDecodeSize(0) == 1);
    assert(emitDecodeSize(1) == 2);
    assert(emitDecodeSize(2) == 4);
    assert(emitDecodeSize(3) == 8);

#if TRACK_GC_REFS
    if  (id->idGCref)
        return  4;
#endif

    /* ISSUE: Assume pessimistic aliasing always ? */

    return  0; //id->idOpSize;
}

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************
 *
 *  Convert between an operand size in bytes and a smaller encoding used for
 *  storage in instruction descriptors.
 */

inline
unsigned           emitter::emitEncodeSize(emitAttr size)
{
    assert(size == EA_1BYTE ||
           size == EA_2BYTE ||
           size == EA_4BYTE ||
           size == EA_8BYTE);

    return  (unsigned) emitSizeEnc[((int) size)-1];
}

inline
emitAttr            emitter::emitDecodeSize(unsigned ensz)
{
    assert(ensz < 4);

    return  (emitAttr) emitSizeDec[ensz];
}

/*****************************************************************************/
#endif//_EMITINL_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitjmps.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
JMP_SMALL(jmp   , "jmp"   , 0x00EB)
JMP_SMALL(jo    , "jo"    , 0x0070)
JMP_SMALL(jno   , "jno"   , 0x0071)
JMP_SMALL(jb    , "jb"    , 0x0072)
JMP_SMALL(jae   , "jae"   , 0x0073)
JMP_SMALL(je    , "je"    , 0x0074)
JMP_SMALL(jne   , "jne"   , 0x0075)
JMP_SMALL(jbe   , "jbe"   , 0x0076)
JMP_SMALL(ja    , "ja"    , 0x0077)
JMP_SMALL(js    , "js"    , 0x0078)
JMP_SMALL(jns   , "jns"   , 0x0079)
JMP_SMALL(jpe   , "jpe"   , 0x007A)
JMP_SMALL(jpo   , "jpo"   , 0x007B)
JMP_SMALL(jl    , "jl"    , 0x007C)
JMP_SMALL(jge   , "jge"   , 0x007D)
JMP_SMALL(jle   , "jle"   , 0x007E)
JMP_SMALL(jg    , "jg"    , 0x007F)

JMP_LARGE(l_jmp , "jmp"   , 0x00E9)
JMP_LARGE(l_jo  , "jo"    , 0x800F)
JMP_LARGE(l_jno , "jno"   , 0x810F)
JMP_LARGE(l_jb  , "jb"    , 0x820F)
JMP_LARGE(l_jae , "jae"   , 0x830F)
JMP_LARGE(l_je  , "je"    , 0x840F)
JMP_LARGE(l_jne , "jne"   , 0x850F)
JMP_LARGE(l_jbe , "jbe"   , 0x860F)
JMP_LARGE(l_ja  , "ja"    , 0x870F)
JMP_LARGE(l_js  , "js"    , 0x880F)
JMP_LARGE(l_jns , "jns"   , 0x890F)
JMP_LARGE(l_jpe , "jpe"   , 0x8A0F)
JMP_LARGE(l_jpo , "jpo"   , 0x8B0F)
JMP_LARGE(l_jl  , "jl"    , 0x8C0F)
JMP_LARGE(l_jge , "jge"   , 0x8D0F)
JMP_LARGE(l_jle , "jle"   , 0x8E0F)
JMP_LARGE(l_jg  , "jg"    , 0x8F0F)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitsh3.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
    /************************************************************************/
    /*               Private helpers for instruction output                 */
    /************************************************************************/

    /************************************************************************/
    /*           The public entry points to output instructions             */
    /************************************************************************/

public:

    void            emitIns_A_R    (emitRegs     reg,
                                    unsigned    offs);

protected:

    void            emitIns_IMOV   (insFormats  fmt,
                                    emitRegs    dreg,
                                    emitRegs    areg,
                                    bool        autox,
                                    int         size, 
                                    bool        isfloat = false);

public:

/*

  void            emitIns_I      (instruction ins,
                                    int         val
#ifdef  DEBUG
                                  , bool        strlit = false
#endif
                                   );
*/
    void            emitIns_R      (instruction ins,
                                    int         size,
                                    emitRegs    reg);

    void            emitIns_C      (instruction ins,
                                    int         size,
                                    int         CPX,
                                    void *      CLS,
                                    int         offs);

    void            emitIns_R_R    (instruction ins,
                                    int         size,
                                    emitRegs    reg1,
                                    emitRegs    reg2);

    void            emitIns_S      (instruction ins,
                                    int         size,
                                    int         varx,
                                    int         offs);

    void            emitIns_S_R    (instruction ins,
                                    int         size,
                                    emitRegs    ireg,
                                    int         varx,
                                    int         offs);

    void            emitIns_R_S    (instruction ins,
                                    int         size,
                                    emitRegs    ireg,
                                    int         varx,
                                    int         offs);

    void            emitIns_R_I    (instruction ins,
                                    int         size,
                                    emitRegs    reg,
                                    int         val);

#if EMIT_USE_LIT_POOLS

    void            emitIns_R_LP_I (emitRegs    reg,
                                    int         size,
                                    int         val,
                                    int         relo_type = 0);

#if!INLINING
#define scAddIns_R_LP_V(r,m,s)  scAddIns_R_LP_V(r,m)
#endif

    void            emitIns_R_LP_V (emitRegs    reg,
                                    void    *   mem);

    void            emitIns_R_LP_M (emitRegs    reg,
                                    gtCallTypes callType,
                                    void   *    callHand);
    
#ifdef BIRCH_SP2
    void            emitIns_R_LP_P (emitRegs    reg,
                                    void   *    data,
                                    int         relo_type = 0);
#endif // BIRCH_SP2

#endif // EMIT_USE_LIT_POOLS

    void            emitIns_IR     (emitRegs     reg,
                                    instruction ins,
                                    bool        autox,
                                    int         size);

    void            emitIns_Ig    ( instruction ins,
                                    int         val,
                                    int         size);

    void            emitIns_IR_R   (emitRegs    dreg,
                                    emitRegs    areg,
                                    bool        autox,
                                    int         size,
                                    bool        isfloat);

    void            emitIns_R_IR   (emitRegs    dreg,
                                    emitRegs    areg,
                                    bool        autox,
                                    int         size,
                                    bool        isfloat);

protected:

    void            emitIns_X0MV   (insFormats  fmt,
                                    emitRegs    dreg,
                                    emitRegs    areg,
                                    int         size);

public:

    void            emitIns_R_XR0  (emitRegs    dreg,
                                    emitRegs    areg,
                                    int         size);

    void            emitIns_XR0_R  (emitRegs    areg,
                                    emitRegs    dreg,
                                    int         size);

    void            emitIns_I_GBR_R(int         size);
    void            emitIns_R_I_GBR(int         size);

protected:

    void            emitIns_RDMV   (insFormats  fmt,
                                    emitRegs    dreg,
                                    emitRegs    areg,
                                    int         offs,
                                    int         size);

public:

    void            emitIns_R_RD   (emitRegs    dreg,
                                    emitRegs    areg,
                                    int         offs,
                                    int         size);

    void            emitIns_RD_R   (emitRegs     areg,
                                    emitRegs     dreg,
                                    int         offs,
                                    int         size);

    int all_jumps_shortened;

    void            delete_id      (instrDesc *id);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitrisc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
   /************************************************************************/
    /*                  Routines that encode instructions                   */
    /************************************************************************/

    BYTE    *       emitOutputRIRD(BYTE *dst, instruction ins,
                                              emitRegs     reg,
                                              emitRegs     irg,
                                              unsigned    dsp,
                                              bool        rdst);

    BYTE    *       emitOutputSV  (BYTE *dst, instrDesc *id, bool     rdst);

#if TGT_MIPS32
    BYTE    *       emitOutputLJ  (BYTE *dst, instrDesc *id, emitRegs regS, emitRegs regT);
    BYTE    *       emitOutputCall (BYTE *dst, instrDesc *id);
    BYTE    *       emitOutputProcAddr (BYTE *dst, instrDesc *id);
#else
    BYTE    *       emitOutputLJ  (BYTE *dst, instrDesc *id);
#endif
    BYTE    *       emitOutputIJ  (BYTE *dst, instrDesc *id);

#if SMALL_DIRECT_CALLS
    BYTE    *       emitOutputDC  (BYTE *dst, instrDesc *id, instrDesc *im);
#endif

    BYTE    *       emitMethodAddr(instrDesc *id);

    /************************************************************************/
    /*             Debug-only routines to display instructions              */
    /************************************************************************/

#ifdef  DEBUG
    void            emitDispIndAddr (emitRegs base, bool dest, bool autox, int disp = 0);

    bool            emitDispInsExtra;

    unsigned        emitDispLPaddr;
    int             emitDispJmpDist;

#if     EMIT_USE_LIT_POOLS
    insGroup    *   emitDispIG;
#endif

    void            emitDispIns     (instrDesc *id, bool isNew,
                                                    bool doffs,
                                                    bool asmfm, unsigned offs = 0);

#endif

    /*----------------------------------------------------------------------*/

    bool            emitInsDepends  (instrDesc   *i1,
                                     instrDesc   *i2);

    /************************************************************************/
    /*                         Literal pool logic                           */
    /************************************************************************/

#if     EMIT_USE_LIT_POOLS

    struct  LPaddrDesc
    {
        gtCallTypes     lpaTyp;         // CT_xxxx (including the fake ones below)
        void    *       lpaHnd;         // member/method handle
    };

    /* These "fake" values are used to distinguish members from methods */

    #define CT_INTCNS       ((gtCallTypes)(CT_COUNT+1))
    #define CT_CLSVAR       ((gtCallTypes)(CT_COUNT+2))
#ifdef BIRCH_SP2
    #define CT_RELOCP       ((gtCallTypes)(CT_COUNT+3))
#endif

#if     SCHEDULER

    struct  LPcrefDesc
    {
        LPcrefDesc  *       lpcNext;    // next ref to this literal pool
        BYTE        *       lpcAddr;    // address of reference
    };

#endif

    struct  litPool
    {
        litPool     *   lpNext;

        insGroup    *   lpIG;           // the litpool follows this group

#ifdef  DEBUG
        unsigned        lpNum;
#endif

#if     SCHEDULER
        LPcrefDesc  *   lpRefs;         // list of refs (if scheduling)
        unsigned        lpDiff;         // base offset change value
#endif

        unsigned short  lpSize;         // total size in bytes
        unsigned short  lpSizeEst;      // total size in bytes estimate

        unsigned        lpOffs      :24;// offset within function

        unsigned        lpPadding   :1; // pad via first word entry?
        unsigned        lpPadFake   :1; // pad via adding a fake word?

        unsigned        lpJumpIt    :1; // do we need to jump over the LP?
        unsigned        lpJumpSmall :1; // jump is small  (if present)?
#if     JMP_SIZE_MIDDL
        unsigned        lpJumpMedium:1; // jump is medium (if present)?
#endif

        short       *   lpWordTab;      // address of word table
        short       *   lpWordNxt;      // next available entry
        unsigned short  lpWordCnt;      // number of entries added so far
        unsigned short  lpWordOfs;      // base offset of the first entry
#ifdef  DEBUG
        unsigned        lpWordMax;      // max. capacity
#endif

        long        *   lpLongTab;      // address of long table
        long        *   lpLongNxt;      // next available entry
        unsigned short  lpLongCnt;      // number of entries added so far
        unsigned short  lpLongOfs;      // base offset of the first entry
#ifdef  DEBUG
        unsigned        lpLongMax;      // max. capacity
#endif

        LPaddrDesc  *   lpAddrTab;      // address of addr table
        LPaddrDesc  *   lpAddrNxt;      // next available entry
        unsigned short  lpAddrCnt;      // number of entries added so far
        unsigned short  lpAddrOfs;      // base offset of the first entry
#ifdef  DEBUG
        unsigned        lpAddrMax;      // max. capacity
#endif
    };

    litPool *       emitLitPoolList;
    litPool *       emitLitPoolLast;
    litPool *       emitLitPoolCur;

    unsigned        emitTotLPcount;
#if SMALL_DIRECT_CALLS
    unsigned        emitTotDCcount;
#endif
    unsigned        emitEstLPwords;
    unsigned        emitEstLPlongs;
    unsigned        emitEstLPaddrs;

    size_t          emitAddLitPool     (insGroup   * ig,
                                        bool         skip,
                                        unsigned     wordCnt,
                                        short *    * nxtLPptrW,
                                        unsigned     longCnt,
                                        long  *    * nxtLPptrL,
                                        unsigned     addrCnt,
                                        LPaddrDesc** nxtAPptrL);

    int             emitGetLitPoolEntry(void       * table,
                                        unsigned     count,
                                        void       * value,
                                        size_t       size);

    size_t          emitAddLitPoolEntry(litPool    * lp,
                                        instrDesc  * id,
                                        bool         issue);

    BYTE    *       emitOutputLitPool  (litPool    * lp, BYTE *cp);

    size_t          emitLPjumpOverSize (litPool    * lp);

#if!JMP_SIZE_MIDDL
    #define         emitOutputFwdJmp(c,d,s,m) emitOutputFwdJmp(c,d,s)
#endif

    BYTE    *       emitOutputFwdJmp   (BYTE       * cp,
                                        unsigned     dist,
                                        bool         isSmall,
                                        bool         isMedium);

#if SMALL_DIRECT_CALLS
    BYTE    *       emitLPmethodAddr;
#endif

#if SCHEDULER

    void            emitRecordLPref    (litPool    * lp,
                                        BYTE       * dst);

    void            emitPatchLPref     (BYTE       * addr,
                                        unsigned     oldOffs,
                                        unsigned     newOffs);

#endif

#endif

    /************************************************************************/
    /*  Private members that deal with target-dependent instr. descriptors  */
    /************************************************************************/

private:

#if EMIT_USE_LIT_POOLS

    struct          instrDescLPR    : instrDesc     // literal pool/fixup ref
    {
        instrDescLPR  * idlNext;        // next litpool ref
        instrDesc     * idlCall;        // points to call instr if call
        size_t          idlOffs;        // offset within IG
        insGroup      * idlIG;          // IG this instruction belongs to
    };

    instrDescLPR   *emitAllocInstrLPR(size_t size)
    {
        return  (instrDescLPR*)emitAllocInstr(sizeof(instrDescLPR), size);
    }

    instrDescLPR *  emitLPRlist;        // list of litpool refs in method
    instrDescLPR *  emitLPRlast;        // last of litpool refs in method

    instrDescLPR *  emitLPRlistIG;      // list of litpool refs in current IG

#endif

    instrDesc      *emitNewInstrLPR    (size_t       size,
                                        gtCallTypes  type,
                                        void   *     hand = NULL);

    instrDesc      *emitNewInstrCallInd(int        argCnt,  // <0 ==> caller pops args
#if TRACK_GC_REFS
                                        VARSET_TP  GCvars,
                                        unsigned   byrefRegs,
#endif
                                        int        retSize);

#if EMIT_USE_LIT_POOLS
    gtCallTypes     emitGetInsLPRtyp(instrDesc *id);
#endif

    /************************************************************************/
    /*               Private helpers for instruction output                 */
    /************************************************************************/

private:

    void            emitFinalizeIndJumps();

    /************************************************************************/
    /*           The public entry points to output instructions             */
    /************************************************************************/

public:

    void            emitIns        (instruction ins);
#ifndef TGT_MIPS32
    bool            emitIns_BD     (instruction ins);
#endif
    bool            emitIns_BD     (instrDesc * id,
                                    instrDesc * pi,
                                    insGroup  * pg);

    void            emitIns_I      (instruction ins,
                                    int         val
#ifdef  DEBUG
                                  , bool        strlit = false
#endif
                                   );

#if!SCHEDULER
#define scAddIns_J(jmp, xcpt, move, dst) scAddIns_J(jmp, dst)
#endif

    void            emitIns_JmpTab (emitRegs     reg,
                                    unsigned    cnt,
                                    BasicBlock**tab);

    void            emitIns_Call   (size_t      argSize,
                                    int         retSize,
#if TRACK_GC_REFS
                                    VARSET_TP   ptrVars,
                                    unsigned    gcrefRegs,
                                    unsigned    byrefRegs,
#endif
                                    bool        chkNull,
#if TGT_MIPS32 || TGT_PPC
                                    unsigned    ftnIndex
#else
                                    emitRegs    areg
#endif
                                    );

#if defined(BIRCH_SP2) && TGT_SH3
    void            emitIns_CallDir(size_t      argSize,
                                    int         retSize,
#if TRACK_GC_REFS
                                    VARSET_TP   ptrVars,
                                    unsigned    gcrefRegs,
                                    unsigned    byrefRegs,
#endif
                                    unsigned    ftnIndex,
                                    emitRegs    areg
                                    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitia64.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                             emitIA64.cpp                                  XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/
#if 0
/*****************************************************************************/
#if     TGT_IA64    // this entire file is used only for targetting the IA64
/*****************************************************************************/

#include "alloc.h"
#include "instr.h"
#include "target.h"
#include "emit.h"

/*****************************************************************************
 *
 *  Initialize the emitter - called once, at DLL load time.
 */

void                emitter::emitInit()
{
}

/*****************************************************************************
 *
 *  Shut down the emitter - called once, at DLL exit time.
 */

void                emitter::emitDone()
{
}

/*****************************************************************************
 *
 *  Start emitting code for a function.
 */

void                emitter::emitBegCG(Compiler *comp, COMP_HANDLE cmpHandle)
{
    emitComp      = comp;
#ifdef  DEBUG
    TheCompiler   = comp;
#endif
    emitCmpHandle = cmpHandle;
}

void                emitter::emitEndCG()
{
}

/*****************************************************************************/
#endif//TGT_IA64
/*****************************************************************************/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitrisc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            emitRISC.cpp                                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "alloc.h"
#include "instr.h"
#include "target.h"
#include "emit.h"

/*****************************************************************************/
#if     TGT_RISC && !TGT_IA64
/*****************************************************************************
 *
 *  Call the specified function pointer for each epilog block in the current
 *  method with the epilog's relative code offset. Returns the sum of the
 *  values returned by the callback.
 */

#if     TRACK_GC_REFS

size_t              emitter::emitGenEpilogLst(size_t (*fp)(void *, unsigned),
                                              void    *cp)
{
    #error  GC ref tracking NYI for RISC targets
}

#endif

/*****************************************************************************/
#if     EMIT_USE_LIT_POOLS
/*****************************************************************************
 *
 *  Allocate an instruction descriptor for an instruction that references
 *  a literal pool entry.
 */

emitter::instrDesc* emitter::emitNewInstrLPR(size_t       size,
                                             gtCallTypes  typ,
                                             void   *     hnd)
{
    instrDescLPR *  ld = emitAllocInstrLPR(size);

    /* Fill in the instruction descriptor */

    ld->idInsFmt          = IF_RWR_LIT;
    ld->idIns             = LIT_POOL_LOAD_INS;
    ld->idAddr.iiaMembHnd = hnd;
    ld->idInfo.idSmallCns = typ;

    /* Make sure the type was stored properly */

    assert(emitGetInsLPRtyp(ld) == typ);

    /* Record the instruction's IG and offset within it */

    ld->idlIG             = emitCurIG;
    ld->idlOffs           = emitCurIGsize;

    /* Assume this is not a direct call sequence for now */

#if SMALL_DIRECT_CALLS
    ld->idlCall           = NULL;
#endif

    /* Add the instruction to this IG's litpool ref list */

    ld->idlNext           = emitLPRlistIG;
                            emitLPRlistIG = ld;

    return  ld;
}

/*****************************************************************************
 *
 *  When we're finished creating an instruction group, this routine is called
 *  to perform any literal pool-related work for the current IG.
 */

void                emitter::emitRecIGlitPoolRefs(insGroup *ig)
{
    /* Update the total estimate of literal pool entries */

    emitEstLPwords += emitCurIG->igLPuseCntW;
    emitEstLPlongs += emitCurIG->igLPuseCntL;
    emitEstLPaddrs += emitCurIG->igLPuseCntA;

    /* Does this IG have any instructions referencing the literal pool? */

    if  (emitLPRlistIG)
    {
        /* Move all LP referencing instructions to a global list */

        instrDescLPR  * list = NULL;
        instrDescLPR  * last = NULL;

        do
        {
            size_t          offs;

            instrDescLPR  * oldI;
            instrDescLPR  * newI;

            /* Grab the next instruction and remove it from the list */

            oldI = emitLPRlistIG; emitLPRlistIG = oldI->idlNext;

            /* Figure out the address of where the instruction got copied */

            offs = (BYTE*)oldI - emitCurIGfreeBase;
            newI = (instrDescLPR*)(ig->igData + offs);

#if USE_LCL_EMIT_BUFF
            assert((oldI == newI) == emitLclBuffDst);
#endif

            assert(newI->idlIG   == ig);
            assert(newI->idIns   == oldI->idIns);
            assert(newI->idlNext == oldI->idlNext);

            /* Update the "call" field if non-NULL */

            if  (newI->idlCall)
            {
                unsigned    diff = (BYTE*)newI->idlCall - emitCurIGfreeBase;

                newI->idlCall = (instrDescLPR*)(ig->igData + diff);
            }

            /* Append the new instruction to the list */

            newI->idlNext = list;
                            list = newI;

            if  (!last)
                last = newI;
        }
        while (emitLPRlistIG);

        /* Add the instruction(s) from this IG to the global list */

        if  (emitCurIG == emitPrologIG)
        {
            /* We're in the prolog, insert in front of the list */

            last->idlNext = emitLPRlist;
                            emitLPRlist = list;

            if  (!emitLPRlast)
                  emitLPRlast = last;
        }
        else
        {
            /* Append at the end of the current list */

            if  (emitLPRlist)
                emitLPRlast->idlNext = list;
            else
                emitLPRlist          = list;

            last->idlNext = NULL;
            emitLPRlast   = last;
        }
    }

    assert(emitLPRlistIG == NULL);
}

/*****************************************************************************
 *
 *  Append a literal pool after the specified instruction group. Return its
 *  estimated size.
 */

size_t              emitter::emitAddLitPool(insGroup  * ig,
                                            bool        skip,
                                            unsigned    wordCnt,
                                            short  *  * nxtLPptrW,
                                            unsigned    longCnt,
                                            long   *  * nxtLPptrL,
                                            unsigned    addrCnt,
                                            LPaddrDesc**nxtAPptrL)
{
    litPool *       lp;
    size_t          sz;

    /* Allocate a pool descriptor and append it to the list */

    lp = (litPool*)emitGetMem(sizeof(*lp));

    if  (emitLitPoolLast)
         emitLitPoolLast->lpNext = lp;
    else
         emitLitPoolList         = lp;

    emitLitPoolLast = lp;
                      lp->lpNext = 0;

    emitTotLPcount++;

#ifdef  DEBUG
    lp->lpNum = emitTotLPcount;
#endif

    /* If there are longs/addrs, we need at least one word for alignment */
    /* but only for sh3? */

#if !TGT_ARM
    if  ((longCnt || addrCnt) && !wordCnt)
        wordCnt++;
#endif // TGT_ARM

    /* Remember which group the pool belongs to */

    lp->lpIG      = ig;

    /* There are no references yet */

#if     SCHEDULER
    lp->lpRefs    = NULL;
#endif

    /* Conservative size estimate: assume the pool will be completely filled */

    sz = wordCnt * 2 +
         longCnt * 4 +
         addrCnt * 4;

    /* Do we need to jump over the literal pool? */

    lp->lpJumpIt  = skip;

    if  (skip)
    {
        size_t          jmpSize;

        /* Estimate what size jump we'll have to use */

#if     JMP_SIZE_MIDDL
        lp->lpJumpMedium = false;
#endif

        if      (sz < JMP_DIST_SMALL_MAX_POS)
        {
            lp->lpJumpSmall  =  true; jmpSize = JMP_SIZE_SMALL;
        }
#if     JMP_SIZE_MIDDL
        else if (sz < JMP_DIST_MIDDL_MAX_POS)
        {
            lp->lpJumpMedium =  true; jmpSize = JMP_SIZE_MIDDL;
        }
#endif
        else
        {
            lp->lpJumpSmall  = false; jmpSize = JMP_SIZE_LARGE;

            /* This one really hurts - the jump will need to use the LP */

            longCnt++; sz += 4;
        }

        /* Add the jump size to the total size estimate */

        sz += jmpSize;
    }

    /* Grab the appropriate space in the tables */

    lp->lpWordTab =
    lp->lpWordNxt = *nxtLPptrW; *nxtLPptrW += wordCnt;
#ifdef  DEBUG
    lp->lpWordMax = wordCnt;
#endif
    lp->lpWordCnt = 0;

    lp->lpLongTab =
    lp->lpLongNxt = *nxtLPptrL; *nxtLPptrL += longCnt;
#ifdef  DEBUG
    lp->lpLongMax = longCnt;
#endif
    lp->lpLongCnt = 0;

    lp->lpAddrTab =
    lp->lpAddrNxt = *nxtAPptrL; *nxtAPptrL += addrCnt;
#ifdef  DEBUG
    lp->lpAddrMax = addrCnt;
#endif
    lp->lpAddrCnt = 0;

    /* Record the size estimate and add it to the group's size */

    lp->lpSize    = 0;
    lp->lpSizeEst = sz;

    ig->igSize   += sz;

    return  sz;
}

/*****************************************************************************
 *
 *  Find an existing literal pool entry that matches the given one. Returns
 *  the offset of the entry (or -1 in case one wasn't found).
 */

int                 emitter::emitGetLitPoolEntry(void     *    table,
                                                 unsigned      count,
                                                 void     *    value,
                                                 size_t        size)
{
    BYTE    *       entry = (BYTE*)table;

    /* ISSUE: Using linear search here - brilliant!!! */

    while (count--)
    {
        if  (!memcmp(entry, value, size))
        {
            /* Match found, return offset from base of table */

            return  (BYTE *)entry - (BYTE*)table;
        }

        entry += size;
    }

    return  -1;
}

/*****************************************************************************
 *
 *  Add an entry for the instruction's operand to the specified literal pool;
 *  if 'issue' is non-zero, the actual final offset of the entry (relative
 *  to the method beginning) is returned.
 */

size_t              emitter::emitAddLitPoolEntry(litPool   *lp,
                                                 instrDesc *id, bool issue)
{
    int             offs;
    unsigned        base;

    int             val;

    size_t          size = emitDecodeSize(id->idOpSize); assert(size == 2 || size == 4);

    assert(lp);
    assert(id->idInsFmt == IF_RWR_LIT);

    /* Get the base offset of the pool (valid only when 'issue' is true) */

    base = lp->lpOffs;

    /* Try to reuse an existing entry */

    if  (emitGetInsLPRtyp(id) == CT_INTCNS)
    {
        int             val = id->idAddr.iiaCns;
        //printf ("adding lit pool %d with issue %d\n", val, issue);

        if  (size == 2)
        {
            /* Search the word table for a match */

            offs = emitGetLitPoolEntry(lp->lpWordTab,
                                       lp->lpWordCnt, &val, size);
            if  (offs != -1)
            {
                if  (issue)
                {
                    /* Do we have any padding? */

                    if  (lp->lpPadding)
                    {
                        /* We must be using the first word for padding */

                        assert(lp->lpPadFake == false);

                        /* Have we matched the padding word itself? */

                        if  (!offs)
                            return  base;
                    }

                    /* Add the long and address sections sizes to the offset */

                    return  base + offs + lp->lpLongCnt * sizeof(int) + lp->lpAddrCnt * sizeof(void*);
                }

                return  0;
            }

            /* Search the long table for a match as well */

            offs = emitGetLitPoolEntry(lp->lpLongTab,
                                       lp->lpLongCnt*2, &val, size);
            if  (offs != -1)
                goto FOUND_LONG;

            /* No match among the existing entries, append a new entry */

#ifdef DEBUG
            assert(lp->lpWordCnt < lp->lpWordMax);
#endif

            *lp->lpWordNxt++ = (short)val;
             lp->lpWordCnt++;
        }
        else
        {
            /* Search the long table for a match */

            offs = emitGetLitPoolEntry(lp->lpLongTab,
                                       lp->lpLongCnt, &val, size);

            if  (offs != -1)
            {
                if  (issue)
                {

                FOUND_LONG:

                    /* Add padding, if necessary */

                    if  (lp->lpPadding)
                        base += 2;

                    /* long/addr entries must always be aligned */

                    assert(((base + offs) & 3) == 0 || issue == false || size < sizeof(int));

                    /* Return the offset of the entry */

                    return  base + offs;
                }

                return  0;
            }

            /* No match among the existing entries, append a new entry */

#ifdef DEBUG
            assert(lp->lpLongCnt < lp->lpLongMax);
#endif

            *lp->lpLongNxt++ = val;
             lp->lpLongCnt++;
        }
    }
    else
    {
        LPaddrDesc  val;

        /* Create an entry for the lookup */

        memset(&val, 0, sizeof(val));

        val.lpaTyp = emitGetInsLPRtyp(id);
        val.lpaHnd = id->idAddr.iiaMethHnd;

//      printf("Adding [%d] addr entry [%02X,%08X]\n", issue+1, val.lpaTyp, val.lpaHnd);

        /* Search both the addr table for a match */

        offs = emitGetLitPoolEntry(lp->lpAddrTab,
                                   lp->lpAddrCnt  , &val, sizeof(val));

        if  (offs != -1)
        {
            if  (issue)
            {
                /* Add padding, if necessary */

                if  (base & 3)
                {
                    assert(lp->lpPadding);

                    base += 2;
                }
                else
                {
                    assert(lp->lpPadding == false &&
                           lp->lpPadFake == false);
                }

                // the offs returned is the offset into the address table, which
                // is not the same as the offset into the litpool, since the
                // address table contains structures, not simple 32-bit addresses
                offs = offs * sizeof(void*) / sizeof(val);

                /* Return the offset of the entry */

                //return  base + offs + lp->lpLongCnt * sizeof(int) + lp->lpAddrCnt * sizeof(void*);
                return  base + lp->lpLongCnt * sizeof(long) + offs;
            }

            return  0;
        }

        /* No match among the existing entries, append a new entry */

#ifdef DEBUG
        assert(lp->lpAddrCnt < lp->lpAddrMax);
#endif
        *lp->lpAddrNxt++ = val;
         lp->lpAddrCnt++;
    }

    /*
        If we get here it means that we've just added a new entry
        to the pool. We better not be issuing an instruction since
        all entries are supposed to have been added by that time.
     */

    assert(issue == false);

    return  0;
}

/*****************************************************************************
 *
 *  Compute a conservative estimate of the size of each literal pool.
 */

void                emitter::emitEstimateLitPools()
{
    emitTotLPcount = 0;

#ifndef NDEBUG
    unsigned        words = 0;
    unsigned        longs = 0;
    unsigned        addrs = 0;
#endif

    /* Does it look like we might need to create a constant pool? */

    if  (emitEstLPwords || emitEstLPlongs || emitEstLPaddrs)
    {
        size_t          curOffs;

        insGroup    *   tempIG;
        insGroup    *   nextIG;

        insGroup    *   lastIG = NULL;
        insGroup    *   bestIG = NULL;
        unsigned        bestWc = 0;
        unsigned        bestLc = 0;
        unsigned        bestAc = 0;
        unsigned        bestSz;
        unsigned        prevWc = 0;
        unsigned        prevLc = 0;
        unsigned        prevAc = 0;
        unsigned        prevSz;
        unsigned        bestMx = UINT_MAX;
        unsigned        need_bestmx = false;
        unsigned        need_bestmxw = false;

        unsigned        begOfsW = 0;
        unsigned        begOfsL = 0;

        unsigned        wordCnt = 0;
        unsigned        longCnt = 0;
        unsigned        addrCnt = 0;
        unsigned        litSize = 0;

        unsigned        endOffs;
        unsigned        maxOffs = UINT_MAX;

        bool            doneIG  = false;
        bool            skipIG  = false;

        short       *   LPtabW  = NULL;
        short       *   LPnxtW  = NULL;

        long        *   LPtabL  = NULL;
        long        *   LPnxtL  = NULL;

        LPaddrDesc  *   LPtabA  = NULL;
        LPaddrDesc  *   LPnxtA  = NULL;

            /*
            If the total estimated size of the entire method is less
            than the max. distance for "medium" jumps, decrement the
            "long" literal pool use counts for each jump marked as
            long.
            */

#if !TGT_ARM
        if  (emitCurCodeOffset < -min(JMP_DIST_SMALL_MAX_NEG,
                                      JCC_DIST_MIDDL_MAX_NEG) &&
             emitCurCodeOffset <  min(JMP_DIST_SMALL_MAX_POS,
                                      JCC_DIST_MIDDL_MAX_POS))
        {
            instrDescJmp *  jmp;

            for (jmp = emitJumpList; jmp; jmp = jmp->idjNext)
            {
                insGroup    *   jmpIG;

                if  (jmp->idInsFmt == IF_JMP_TAB)
                    continue;

#if TGT_MIPSFP
                assert( (jmp->idInsFmt == IF_LABEL) || (jmp->idInsFmt == IF_JR) || (jmp->idInsFmt == IF_JR_R) ||
                        (jmp->idInsFmt == IF_RR_O) || (jmp->idInsFmt == IF_R_O) || (jmp->idInsFmt == IF_O));
#elif TGT_MIPS32
                assert( (jmp->idInsFmt == IF_LABEL) || (jmp->idInsFmt == IF_JR) || (jmp->idInsFmt == IF_JR_R) ||
                        (jmp->idInsFmt == IF_RR_O) || (jmp->idInsFmt == IF_R_O));
#else
                assert(jmp->idInsFmt == IF_LABEL);
#endif

                /* Get the group the jump is in */

                jmpIG = jmp->idjIG;

                /* Decrease the "long" litpool count of the group */

                assert(jmpIG->igLPuseCntL > 0);

                jmpIG->igLPuseCntL--;
                    emitEstLPlongs--;
            }

#if TGT_SH3
            all_jumps_shortened = 1;
#endif
            /* Are there any litpool users left? */

            if  (!emitEstLPwords && !emitEstLPlongs && !emitEstLPaddrs)
                goto DONE_LP;
        }
        else
        {
#if TGT_SH3
            all_jumps_shortened = 0;
#endif
        }
#endif //TGT_ARM
#ifdef  DEBUG

        if  (verbose)
        {
            printf("\nInstruction list before literal pools are added:\n\n");
            emitDispIGlist(false);
        }

        /* Make sure our estimates were accurate */

        unsigned    wordChk;
        unsigned    longChk;
        unsigned    addrChk;

        for (wordChk =
             longChk =
             addrChk = 0, tempIG = emitIGlist; tempIG; tempIG = tempIG->igNext)
        {
            wordChk += tempIG->igLPuseCntW;
            longChk += tempIG->igLPuseCntL;
            addrChk += tempIG->igLPuseCntA;
            emitEstLPwords+=2;
            emitEstLPlongs+=2;
            // @todo
            // any lit pool can add a word for alignment.
            // also can add a long for a jump over the litpool.
            // here we pray there is not an avg of more than two lit pool per instr group.
        }

        assert(wordChk <= emitEstLPwords);
        assert(longChk <= emitEstLPlongs);
        assert(addrChk <= emitEstLPaddrs);

#else
        for (tempIG = emitIGlist; tempIG; tempIG = tempIG->igNext)
        {
            emitEstLPwords+=2;
            emitEstLPlongs+=2;
        }
#endif


        /* Allocate the arrays of the literal pool word/long entries */

        LPtabW = LPnxtW = (short     *)emitGetMem(roundUp(emitEstLPwords * sizeof(*LPtabW)));
        LPtabL = LPnxtL = (long      *)emitGetMem(        emitEstLPlongs * sizeof(*LPtabL) );
        LPtabA = LPnxtA = (LPaddrDesc*)emitGetMem(        emitEstLPaddrs * sizeof(*LPtabA) );

        /* We have not created any actual lit pools yet */

        emitLitPoolList =
        emitLitPoolLast = NULL;

        /* Walk the group list, looking for lit pool use */

        for (tempIG = emitIGlist, curOffs = litSize = bestSz = 0;;)
        {
            assert(lastIG == NULL || lastIG->igNext == tempIG);

            /* Record the (possibly) updated group offset */

            tempIG->igOffs = curOffs;

            /* Get hold of the next group */

            nextIG  = tempIG->igNext;

            /* Compute the offset of the group's end */

            endOffs = tempIG->igOffs + tempIG->igSize;

            //printf("\nConsider IG #%02u at %04X\n", tempIG->igNum, tempIG->igOffs);
            //printf("bestsz is %x\n", bestSz);

            /* Is the end of this group too far? */

            int nextLitSize =
                tempIG->igLPuseCntW * 2 + tempIG->igLPuseCntL * sizeof(int  ) + tempIG->igLPuseCntA * sizeof(void*);

            if  (endOffs + litSize + nextLitSize > maxOffs)
            //if  (endOffs + litSize > maxOffs)
            {
                size_t          offsAdj;

                /* We must place a literal pool before this group */

                if  (!bestIG)
                {

//                        Ouch - we'll have to jump over the literal pool
//                        since we have to place it here and there were
//                        no good places to put earlier. For now, we'll
//                        just set a flag on the liter pool (and bump its
//                        size), and we'll issue the jump just before we
//                        write out the literal pool contents.


                    skipIG = true;
                    bestIG = lastIG;

                ALL_LP:

                    bestWc = wordCnt;
                    bestLc = longCnt;
                    bestAc = addrCnt;
                    bestSz = litSize;
                    bestMx = UINT_MAX;
                    //printf ("had to split %d %d %d %x!\n", bestWc, bestLc, bestAc, litSize);
                }


                assert(bestIG && ((bestIG->igFlags & IGF_END_NOREACH) || skipIG));

                /* Append an LP right after "bestIG" */

                //printf("lit placed after IG #%02u at %04X uses : WLA %d %d %d : maxOffs was %X\n", bestIG->igNum, bestIG->igOffs, bestWc, bestLc, bestAc, maxOffs);
                //printf("lit size (bestsz) was %x, litsize+endoffs = %x  endoffs = %x\n", bestSz, bestSz+bestIG->igOffs+bestIG->igSize, bestIG->igOffs+bestIG->igSize);
                //printf("lit uses lpnxtW : %x\t lpnxtL : %x\t lpnxtA : %x\n", LPnxtW, LPnxtL, LPnxtA);

                offsAdj = emitAddLitPool(bestIG,
                                         skipIG, bestWc, &LPnxtW,
                                                 bestLc, &LPnxtL,
                                                 bestAc, &LPnxtA);


                // Do we need to skip over the literal pool?

                if  (skipIG)
                {
                    /* Reset the flag */

                    skipIG = false;

                    /* Update this group's and the current offset  */

                    tempIG->igOffs += offsAdj;
                }
                else
                {
                    /* Update the intervening group offsets */

                    while (bestIG != tempIG)
                    {
                        bestIG = bestIG->igNext;

                        bestIG->igOffs += offsAdj;
                    }
                }

                /* Update the total code size */

                emitCurCodeOffset += offsAdj;

                /* Update the current offset */

                curOffs           += offsAdj;

                /* Update the outstanding/"best" LP ref values */

                wordCnt -= bestWc; bestWc = 0;
                longCnt -= bestLc; bestLc = 0;
                addrCnt -= bestAc; bestAc = 0;
                litSize -= bestSz; bestSz = 0;

                /* if we've unloaded some litpool entries on bestIG but still */
                /* need to put more before the current IG, then need a skip and loop back */
                if (endOffs + litSize + nextLitSize > bestMx)
                {
                    skipIG = true;
                    bestIG = lastIG;
                    goto ALL_LP;
                }

                maxOffs  = bestMx; bestMx = UINT_MAX;

                /* We've used up our "best" IG */

                bestIG = NULL;

                if (doneIG) goto DONE_LP;
            }


#ifndef NDEBUG
            //printf("IG #%02u at %04X uses : WLA %d %d %d words %d longs %d\n", tempIG->igNum, tempIG->igOffs, tempIG->igLPuseCntW, tempIG->igLPuseCntL, tempIG->igLPuseCntA, wordCnt, longCnt);
            //printf("IG #%02u at %04X uses : WLA %d %d %d maxoffs %x bestMx %x\n", tempIG->igNum, tempIG->igOffs, tempIG->igLPuseCntW, tempIG->igLPuseCntL, tempIG->igLPuseCntA, maxOffs, bestMx);
            //printf("litsize : %x\n", litSize);

            words += tempIG->igLPuseCntW;
            longs += tempIG->igLPuseCntL;
            addrs += tempIG->igLPuseCntA;
#endif

            /* Does this group need any LP entries? */

            prevWc = wordCnt;
            prevLc = longCnt;
            prevAc = addrCnt;
            prevSz = litSize;

            if  (tempIG->igLPuseCntW)
            {
                if  (!wordCnt || !bestWc || need_bestmx || need_bestmxw)
                {
                    unsigned        tmpOffs;

                    /* This is the first "word" LP use */

                    tmpOffs = tempIG->igOffs;
#if SCHEDULER
                    if  (!emitComp->opts.compSchedCode)
#endif
                        tmpOffs += tempIG->igLPuse1stW;

                    /* Figure out the farthest acceptable offset */

                    tmpOffs += LIT_POOL_MAX_OFFS_WORD - 2*INSTRUCTION_SIZE;

                    /* Update the max. offset */

                    if  (!wordCnt)
                    {
                        if  (maxOffs > tmpOffs)
                             maxOffs = tmpOffs;
                    }
                    if (need_bestmx || need_bestmxw)
                    //else
                    {
                        if  (bestMx  > tmpOffs)
                             bestMx  = tmpOffs;
                        need_bestmx = false;
                        need_bestmxw = false;
                    }
                }

                wordCnt += tempIG->igLPuseCntW;
                litSize += tempIG->igLPuseCntW * 2;
                //bestSz  += tempIG->igLPuseCntW * 2;
            }

            if  (tempIG->igLPuseCntL || tempIG->igLPuseCntA)
            {
                if  ((!longCnt && !addrCnt) || (!bestLc && !bestAc) || need_bestmx)
                {
                    unsigned        tmpOffs;

                    /* This is the first long/addr LP use */

                    tmpOffs = tempIG->igOffs;

                    int firstuse = INT_MAX;

                    if (tempIG->igLPuseCntL)
                        firstuse = tempIG->igLPuse1stL;
                    if (tempIG->igLPuseCntA)
                        firstuse = min (firstuse, tempIG->igLPuse1stA);

#if SCHEDULER
                    if  (!emitComp->opts.compSchedCode)
#endif
                        tmpOffs += firstuse;

                    /* Figure out the farthest acceptable offset */

                    tmpOffs += LIT_POOL_MAX_OFFS_LONG - 2*INSTRUCTION_SIZE;

                    /* Update the max. offset */

                    if  (!longCnt && !addrCnt)
                    {
                        if  (maxOffs > tmpOffs)
                             maxOffs = tmpOffs;
                    }
                    if (need_bestmx)
                    {
                        if  (bestMx  > tmpOffs)
                             bestMx  = tmpOffs;
                        need_bestmx = false;
                    }
                }

                longCnt += tempIG->igLPuseCntL;
                litSize += tempIG->igLPuseCntL * sizeof(int  );
                //bestSz  += tempIG->igLPuseCntL * sizeof(int  );

                addrCnt += tempIG->igLPuseCntA;
                litSize += tempIG->igLPuseCntA * sizeof(void*);
                //bestSz  += tempIG->igLPuseCntA * sizeof(void*);
            }

            /* Is the end of this group unreachable? */

            if  (tempIG->igFlags & IGF_END_NOREACH)
            {
                /* Looks like the best candidate so far */

                bestIG = tempIG;

                /* Remember how much we can cram into the best candidate */

                bestWc = wordCnt;
                bestLc = longCnt;
                bestAc = addrCnt;

                //bestSz = 0;
                bestSz = litSize;
                bestMx = UINT_MAX;
                need_bestmx = true;
                need_bestmxw = true;
            }

            /* Is this the last group? */

            //printf("IG #%02u at %04X uses : WLA %d %d %d maxoffs %x bestMx %x\n", tempIG->igNum, tempIG->igOffs, tempIG->igLPuseCntW, tempIG->igLPuseCntL, tempIG->igLPuseCntA, maxOffs, bestMx);

            if  (!nextIG)
            {
                assert(bestIG == tempIG);

                /* Is there any need for a literal pool? */

                if  (wordCnt || longCnt || addrCnt)
                {
                    /* Prevent endless looping */

                    if  (doneIG)
                        break;

                    doneIG = true;
                    bestWc = wordCnt;
                    bestLc = longCnt;
                    bestAc = addrCnt;
                    bestSz = litSize;
                    goto ALL_LP;
                }

                /* We're all done */

                break;
            }

            /* Update the current offset and continue with the next group */

            curOffs += tempIG->igSize;

            lastIG   = tempIG;
            tempIG   = nextIG;
        }

DONE_LP:;

#ifndef NDEBUG
      if (verbose)
      {
          printf("Est word need = %3u, alloc = %3u, used = %3u\n", emitEstLPwords, words, LPnxtW - LPtabW);
          printf("Est long need = %3u, alloc = %3u, used = %3u\n", emitEstLPlongs, longs, LPnxtL - LPtabL);
          printf("Est addr need = %3u, alloc = %3u, used = %3u\n", emitEstLPaddrs, addrs, LPnxtA - LPtabA);
      }
#endif

#ifdef  DEBUG

        if  (verbose)
        {
            printf("\nInstruction list after literal pools have been added:\n\n");
            emitDispIGlist(false);
        }

        assert(words <= emitEstLPwords && emitEstLPwords + LPtabW >= LPnxtW);
        assert(longs <= emitEstLPlongs && emitEstLPlongs + LPtabL >= LPnxtL);
        assert(addrs <= emitEstLPaddrs && emitEstLPaddrs + LPtabA >= LPnxtA);
#endif
    }

    /* Make sure all the IG offsets are up-to-date */

    emitCheckIGoffsets();
}


/*****************************************************************************
 *
 *  Finalize the size and contents of each literal pool.
 */

void                emitter::emitFinalizeLitPools()
{
    litPool     *   curLP;
    insGroup    *   litIG;
    instrDescLPR*   lprID;

    insGroup    *   thisIG;
    size_t          offsIG;

    /* Do we have any literal pools? */

    if  (!emitTotLPcount)
        return;

#ifdef  DEBUG

    if  (verbose)
    {
        printf("\nInstruction list before final literal pool allocation:\n\n");
        emitDispIGlist(false);
    }

    emitCheckIGoffsets();

#endif

#if     SMALL_DIRECT_CALLS

    /* Do we already know where the code for this method will end up? */

    if  (emitLPmethodAddr)
        emitShrinkShortCalls();

#endif

    /* Get hold of the first literal pool and its group */

    curLP = emitLitPoolList; assert(curLP);
    litIG = curLP->lpIG;
    lprID = emitLPRlist;

    /* Walk the instruction groups to create the literal pool contents */

    for (thisIG = emitIGlist, offsIG = 0;
         thisIG;
         thisIG = thisIG->igNext)
    {
        thisIG->igOffs = offsIG;

        /* Does this group have any lit pool entries? */

        if  (thisIG->igLPuseCntW ||
             thisIG->igLPuseCntL ||
             thisIG->igLPuseCntA)
        {
            /* Walk the list of instructions that reference the literal pool */

#ifdef  DEBUG
            unsigned    wc = 0;
            unsigned    lc = 0;
            unsigned    ac = 0;
#endif

            do
            {
#if TGT_SH3
#ifdef DEBUG
                emitDispIns(lprID, false, true, false, 0);
#endif
                // maybe this was because of a jmp instruction
                if (lprID->idlIG != thisIG)
                {
                    unsigned    cnt = thisIG->igInsCnt;
                    BYTE    *   ins = thisIG->igData;
                    instrDesc*  id;
#ifdef DEBUG
                    _flushall();
#endif
                    do
                    {
                        instrDesc * id = (instrDesc *)ins;

                        //emitDispIns(id, false, true, false, 0);

                        if (id->idInsFmt == IF_LABEL)
                        {
                            /* Is the jump "very long" ? */

                            if  (((instrDescJmp*)lprID)->idjShort  == false &&
                                 ((instrDescJmp*)lprID)->idjMiddle == false)
                            {
                                /* Add a label entry to the current LP */
#ifdef  DEBUG
                                lc++;
#endif
                            }
                        }

                        ins += emitSizeOfInsDsc(id);
                    }
                    while (--cnt);

                    break;
                    thisIG = thisIG->igNext;
                    while (!(thisIG->igLPuseCntW || thisIG->igLPuseCntL || thisIG->igLPuseCntA))
                        thisIG = thisIG->igNext;
                    continue;

                }
#endif
                assert(lprID && lprID->idlIG == thisIG);

                switch (lprID->idInsFmt)
                {
                case IF_RWR_LIT:

#ifdef  DEBUG

                    /* Just to make sure the counts agree */

                    if  (emitGetInsLPRtyp(lprID) == CT_INTCNS)
                    {
                        if  (emitDecodeSize(lprID->idOpSize) == 2)
                            wc++;
                        else
                            lc++;
                    }
                    else
                    {
                        ac++;
                    }

#endif

#if     SMALL_DIRECT_CALLS

                    /* Ignore calls that have been made direct */

                    if  (lprID->idIns == DIRECT_CALL_INS)
                        break;

#endif

                    /* Add an entry for the operand to the current LP */

                    emitAddLitPoolEntry(curLP, lprID, false);
                    break;

                case IF_LABEL:

                    /* Is the jump "very long" ? */

                    if  (((instrDescJmp*)lprID)->idjShort  == false &&
                         ((instrDescJmp*)lprID)->idjMiddle == false)
                    {
                        /* Add a label entry to the current LP */

#ifdef  DEBUG
                        lc++;
#endif

                        assert(!"add long jump label address to litpool");
                    }
                    break;

#ifdef  DEBUG
                default:
                    assert(!"unexpected instruction in LP list");
#endif
                }

                lprID = lprID->idlNext;
            }
            while (lprID && lprID->idlIG == thisIG);

#ifdef DEBUG
            assert(thisIG->igLPuseCntW == wc);
            //assert(thisIG->igLPuseCntL == lc);
            assert(thisIG->igLPuseCntA == ac);
#endif
        }

        /* Is the current literal pool supposed to go after this group? */

        if  (litIG == thisIG)
        {
            unsigned        begOffs;
            unsigned        jmpSize;

            unsigned        wordCnt;
            unsigned        longCnt;
            unsigned        addrCnt;

            assert(curLP && curLP->lpIG == thisIG);

            /* Subtract the estimated pool size from the group's size */

            thisIG->igSize -= curLP->lpSizeEst; assert((int)thisIG->igSize >= 0);

            /* Compute the starting offset of the pool */

            begOffs = offsIG + thisIG->igSize;

            /* Adjust by the size of the "skip over LP" jump, if present */

            jmpSize = 0;

            if  (curLP->lpJumpIt)
            {
                jmpSize  = emitLPjumpOverSize(curLP);
                begOffs += jmpSize;
            }

            /* Get hold of the counts */

            wordCnt = curLP->lpWordCnt;
            longCnt = curLP->lpLongCnt;
            addrCnt = curLP->lpAddrCnt;


            /* Do we need to align the first long/addr? */

            curLP->lpPadding =
            curLP->lpPadFake = false;

            if  ((begOffs & 3) && (longCnt || addrCnt))
            {
                /* We'll definitely need one word of padding */

                curLP->lpPadding = true;

                /* Do we have any word-sized entries? */

                if  (!wordCnt)
                {
                    /* No, we'll have to pad by adding a "fake" word */

                    curLP->lpPadFake = true;

                    wordCnt++;
                }
            }

            /* Compute the final (accurate) size */

            curLP->lpSize  = wordCnt * 2 +
                             longCnt * 4 +
                             addrCnt * 4;

            /* Make sure the original estimate wasn't too low */

            assert(curLP->lpSize <= curLP->lpSizeEst);

            /* Record the pool's offset within the method */

            curLP->lpOffs  = begOffs;

            /* Add the actual size to the group's size */

            thisIG->igSize += curLP->lpSize + jmpSize;

            /* Move to the next literal pool, if any */

            curLP = curLP->lpNext;
            litIG = curLP ? curLP->lpIG : NULL;
        }

        offsIG += thisIG->igSize;
    }

    /* We should have processed all the literal pools */

    assert(curLP == NULL);
    assert(litIG == NULL);
    assert(lprID == NULL);

    /* Update the total code size of the method */

    emitTotalCodeSize = offsIG;

    /* Make sure all the IG offsets are up-to-date */

    emitCheckIGoffsets();
}

/*****************************************************************************/
#if     SMALL_DIRECT_CALLS
/*****************************************************************************
 *
 *  Convert as many calls as possible into the direct pc-relative variety.
 */

void                emitter::emitShrinkShortCalls()
{
    litPool     *   curLP;
    insGroup    *   litIG;
    unsigned        litIN;
    instrDescLPR*   lprID;

    size_t          ofAdj;

    bool            shrnk;
    bool            swapf;

    /* Do we have any candidate calls at all? */

#ifndef TGT_SH3
    if  (!emitTotDCcount)
        return;
#endif

    /* This is to make recursive calls find their target address */

    emitCodeBlock = emitLPmethodAddr;

    /* Get hold of the first literal pool and the group it belongs to */

    curLP = emitLitPoolList; assert(curLP);
    litIG = curLP->lpIG;
    litIN = litIG->igNum;

    /* Remember whether we shrank any calls at all */

    shrnk = false;

    /* Remember whether to swap any calls to fill branch-delay slots */

    swapf = false;
#if TGT_SH3
    shrnk = true; // always need to do delay slots on sh3
    swapf = true;
#endif

    /* Walk the list of instructions that reference the literal pool */

    for (lprID = emitLPRlist; lprID; lprID = lprID->idlNext)
    {
        instrDesc   *   nxtID;

        BYTE        *   srcAddr;
        BYTE        *   dstAddr;
        int             difAddr;

        /* Does this instruction reference a new literal pool? */

        while (lprID->idlIG->igNum > litIN)
        {
            /* Move to the next literal pool */

            curLP = curLP->lpNext; assert(curLP);
            litIG = curLP->lpIG;
            litIN = litIG->igNum;
        }

        /* We're only interested in direct-via-register call sequences */

        if  (lprID->idInsFmt != IF_RWR_LIT)
            continue;
        if  (lprID->idIns    != LIT_POOL_LOAD_INS)
            continue;
        if  (lprID->idlCall  == NULL)
            continue;

        switch (emitGetInsLPRtyp(lprID))
        {
        case CT_DESCR:

#if defined(BIRCH_SP2) && TGT_SH3
        case CT_RELOCP:
#endif
        case CT_USER_FUNC:
            break;

        default:
            continue;
        }

        /* Here we have a direct call via a register */

        nxtID = lprID->idlCall;

        assert(nxtID->idIns == INDIRECT_CALL_INS);
        assert(nxtID->idRegGet() == lprID->idRegGet());

        /* Assume the call will not be short */

        lprID->idlCall = NULL;

        /* Compute the address from where the call will originate */

        srcAddr = emitDirectCallBase(emitCodeBlock + litIG-> igOffs
                                                   + lprID->idlOffs);

        /* Ask for the address of the target and see how far it is */

#if defined(BIRCH_SP2) && TGT_SH3
        if (~0 != (unsigned) nxtID->idAddr.iiaMethHnd)
        {
            OptPEReader *oper =     &((OptJitInfo*)emitComp->info.compCompHnd)->m_PER;
            dstAddr =  (BYTE *)oper->m_rgFtnInfo[(unsigned)nxtID->idAddr.iiaMethHnd].m_pNative;
        }
        else
            dstAddr = 0;
#else
# ifdef BIRCH_SP2
        assert (0);     // you need to guarantee iiaMethHnd if you want this to work <tanj>
# endif
        dstAddr = emitMethodAddr(lprID);
#endif

        /* If the target address isn't known, there isn't much we can do */

        if  (!dstAddr)
            continue;

//      printf("Direct call: %08X -> %08X , dist = %d\n", srcAddr, dstAddr, dstAddr - srcAddr);

        /* Compute the distance and see if it's in range */

        difAddr = dstAddr - srcAddr;

        if  (difAddr < CALL_DIST_MAX_NEG)
            continue;
        if  (difAddr > CALL_DIST_MAX_POS)
            continue;

        /* The call can be made short */

        lprID->idlCall = nxtID;

        /* Change the load-address instruction to a direct call */

        lprID->idIns   = DIRECT_CALL_INS;

        /* The indirect call instruction won't generate any code */

        nxtID->idIns   = INS_ignore;

        /* Update the group's size [ISSUE: may have to use nxtID's group] */

        lprID->idlIG->igSize -= INSTRUCTION_SIZE;

        /* Remember that we've shrunk at least one call */

        shrnk = true;

        /* Is there a "nop" filling the branch-delay slot? */

        if  (Compiler::instBranchDelay(DIRECT_CALL_INS))
        {
            instrDesc   *   nopID;

            /* Get hold of the instruction that follows the call */

            nopID = (instrDesc*)((BYTE*)nxtID + emitSizeOfInsDsc(nxtID));

            /* Do we have a (branch-delay) nop? */

            if  (nopID->idIns == INS_nop)
            {
                /* We'll get rid of the nop later (see next loop below) */

                lprID->idSwap = true;

                swapf = true;
            }
        }
    }

    /* We should have processed all the literal pools */

    // maybe there are lit pools after this that are now empty
    // (could have been used by jumps that are now long)
    //assert(curLP->lpNext == NULL);
    //assert(lprID         == NULL);

    /* Did we manage to shrink any calls? */

    if  (shrnk)
    {
        insGroup    *   thisIG;
        size_t          offsIG;

        for (thisIG = emitIGlist, offsIG = 0;
             thisIG;
             thisIG = thisIG->igNext)
        {
            instrDesc *     id;

            int             cnt;

            /* Update the group's offset */

            thisIG->igOffs = offsIG;

            /* Does this group have any address entries? */

            if  (!thisIG->igLPuseCntA)
                goto NXT_IG;

            /* Did we find any branch-delay slots that can be eliminated? */

            if  (!swapf)
                goto NXT_IG;

            /*
                Walk the instructions of the group, looking for
                the following sequence:

                    <any_ins>
                    direct_call
                    nop

                If we find it, we swap the first instruction
                with the call and zap the nop.
             */

            id  = (instrDesc *)thisIG->igData;
            cnt = thisIG->igInsCnt - 2;

            while (cnt > 0)
            {
                instrDesc *     nd;

                /* Get hold of the instruction that follows */

                nd = (instrDesc*)((BYTE*)id + emitSizeOfInsDsc(id));

                /* Is the following instruction a direct call? */

                if  (nd->idIns == DIRECT_CALL_INS && nd->idSwap)
                {
                    instrDesc *     n1;
                    instrDesc *     n2;

                    /* Skip over the indirect call */

                    n1 = (instrDesc*)((BYTE*)nd + emitSizeOfInsDsc(nd));
                    assert(n1->idIns == INS_ignore);

                    /* Get hold of the "nop" that is known to follow */

                    n2 = (instrDesc*)((BYTE*)n1 + emitSizeOfInsDsc(n1));
                    assert(n2->idIns == INS_nop);

                    /* The call was marked as "swapped" only temporarily */

                    nd->idSwap = false;

                    /* Are we scheduling "for real" ? */

#if SCHEDULER
                    if  (emitComp->opts.compSchedCode)
                    {
                        /* Move the "nop" into the branch-delay slot */

                        n1->idIns       = INS_nop;
                        n2->idIns       = INS_ignore;
                    }
                    else
#endif
                    {
                        if (!emitInsDepends(nd, id))
                        {
                            /* Swap the call with the previous instruction */

                            id->idSwap      = true;

                            /* Zap the branch-delay slot (the "nop") */

                            n2->idIns       = INS_ignore;

                            /* Update the group's size */

                            thisIG->igSize -= INSTRUCTION_SIZE;
                        }
                    }
                }
#if TGT_SH3
                else if (nd->idIns == INS_jsr)
                {
                    instrDesc *     nop;

                    nop = (instrDesc*)((BYTE*)nd + emitSizeOfInsDsc(nd));
                    assert(nop->idIns == INS_nop);

                    if (!emitInsDepends(nd, id))
                    {
                        /* Swap the call with the previous instruction */
                        id->idSwap      = true;
                        /* Zap the branch-delay slot (the "nop") */
                        nop->idIns       = INS_ignore;

                        /* Update the group's size */
                        thisIG->igSize -= INSTRUCTION_SIZE;
                    }
                }
#endif

                /* Continue with the next instruction */

                id = nd;

                cnt--;
            }

        NXT_IG:

            /* Update the running offset */

            offsIG += thisIG->igSize;
        }

        assert(emitTotalCodeSize); emitTotalCodeSize = offsIG;
    }

    /* Make sure all the IG offsets are up-to-date */

    emitCheckIGoffsets();
}

/*****************************************************************************/
#endif//SMALL_DIRECT_CALLS
/*****************************************************************************
 *
 *  Output the contents of the next literal pool.
 */

BYTE    *           emitter::emitOutputLitPool(litPool *lp, BYTE *cp)
{
    unsigned        wordCnt = lp->lpWordCnt;
    short       *   wordPtr = lp->lpWordTab;
    unsigned        longCnt = lp->lpLongCnt;
    long        *   longPtr = lp->lpLongTab;
    unsigned        addrCnt = lp->lpAddrCnt;
    LPaddrDesc  *   addrPtr = lp->lpAddrTab;

    size_t          curOffs;

    /* Bail of no entry ended up being used in this pool */

    if  ((wordCnt|longCnt|addrCnt) == 0)
        return  cp;

    /* Compute the current code offset */

    curOffs = emitCurCodeOffs(cp);

    /* Do we need to jump over the literal pool? */

    if  (lp->lpJumpIt)
    {
        /* Reserve space for the jump over the pool */

        curOffs += emitLPjumpOverSize(lp);
    }

#if     SCHEDULER

    bool            addPad = false;

    /* Has the offset of this LP changed? */

    if  (lp->lpOffs != curOffs)
    {
        LPcrefDesc  *   ref;

        size_t          oldOffs = lp->lpOffs;
        size_t          tmpOffs = curOffs;

        assert(emitComp->opts.compSchedCode);

        /* Has the literal pool moved by an unaligned amount? */

        if  ((curOffs - oldOffs) & 2)
        {
            /* Did we originally think we would need padding? */

            if  (lp->lpPadding)
            {
                /*
                    OK, we thought we'd need padding but with the new LP
                    position that's not the case any more. If the padding
                    value is an unused one, simply get rid of it; if it
                    contains a real word entry, we'll have to add padding
                    in front of the LP to keep things aligned, as moving
                    the initial word entry is too difficult at this point.
                 */

                if  (lp->lpPadFake)
                {
                    /* Padding no longer needed, just get rid of it */

                    lp->lpPadding =
                    lp->lpPadFake = false;
                }
                else
                {
                    /*
                        This is the unfortunate scenario described above;
                        we thought we'd need padding and we achieved this
                        by sticking the first word entry in front of all
                        the dword entries. It's simply too hard to move
                        that initial word someplace else at this point,
                        so instead we just add another pad word. Sigh.
                     */

                ADD_PAD:

                    /* Come here to add a pad word in front of the LP */

                    addPad = true; lp->lpSize += 2;

                    /* Update the offset and see if it's still different */

                    curOffs += 2;

                    if  (curOffs == oldOffs)
                        goto DONE_MOVE;
                }
            }
            else
            {
                /*
                    There is currently no padding. If there are any
                    entries that need to be aligned, we'll have to
                    add padding now, lest they end up mis-aligned.
                 */

                assert((oldOffs & 2) == 0);
                assert((curOffs & 2) != 0);

                if  (longCnt || addrCnt)
                {
                    lp->lpPadding =
                    lp->lpPadFake = true;

                    /* Does the padding take up all the savings? */

                    if  (oldOffs == curOffs + sizeof(short))
                    {
                        /* Nothing really changed, no need to patch */

                        goto NO_PATCH;
                    }

                    tmpOffs += sizeof(short);
                }
            }
        }

        /* Patch all issued instructions that reference this LP */

        for (ref = lp->lpRefs; ref; ref = ref->lpcNext)
            emitPatchLPref(ref->lpcAddr, oldOffs, tmpOffs);

    NO_PATCH:

        /* Update the offset of the LP */

        lp->lpOffs = curOffs; assert(oldOffs != curOffs);
    }

DONE_MOVE:

#else

    assert(lp->lpOffs == curOffs);

#endif

    /* Do we need to jump over the literal pool? */

    if  (lp->lpJumpIt)
    {

#ifndef NDEBUG
        /* Remember the code offset so that we can verify the jump size */
        unsigned    jo = emitCurCodeOffs(cp);
#endif

        /* Skip over the literal pool */

#ifdef  DEBUG
        emitDispIG = lp->lpIG->igNext;  // for instruction display purposes
#endif

#if TGT_SH3
        if (lp->lpJumpSmall)
        {
            cp += emitOutputWord(cp, 0x0009);
        }
#endif
        cp = emitOutputFwdJmp(cp, lp->lpSize, lp->lpJumpSmall,
                                              lp->lpJumpMedium);

        /* Make sure the issued jump had the expected size */

#ifdef DEBUG
        assert(jo + emitLPjumpOverSize(lp) == emitCurCodeOffs(cp));
#endif
    }

#ifdef  DEBUG
    if (disAsm) printf("\n; Literal pool %02u:\n", lp->lpNum);
#endif

#ifndef NDEBUG
    unsigned    lpBaseOffs = emitCurCodeOffs(cp);
#endif

#if     SCHEDULER

    /* Do we need to insert additional padding? */

    if  (addPad)
    {
        /* This can only happen when the scheduler is enabled */

        assert(emitComp->opts.compSchedCode);

#ifdef  DEBUG
        if (disAsm)
        {
            emitDispInsOffs(emitCurCodeOffs(cp), dspGCtbls);
            printf(EMIT_DSP_INS_NAME "0                   ; pool alignment (due to scheduling)\n", ".data.w");
        }
#endif

        cp += emitOutputWord(cp, 0);
    }

#endif

    /* Output the contents of the literal pool */

    if  (lp->lpPadding)
    {

#ifdef  DEBUG
        if (disAsm) emitDispInsOffs(emitCurCodeOffs(cp), dspGCtbls);
#endif

        /* Are we padding with the first word entry? */

        if  (lp->lpPadFake)
        {

#if !   SCHEDULER
            assert(wordCnt == 0);
#endif

#ifdef  DEBUG
            if (disAsm) printf(EMIT_DSP_INS_NAME "0                   ; pool alignment\n", ".data.w");
#endif
            cp += emitOutputWord(cp, 0);
        }
        else
        {
            assert(wordCnt != 0);

#ifdef  DEBUG
            if (disAsm) printf(EMIT_DSP_INS_NAME "%d\n", ".data.w", *wordPtr);
#endif
            cp += emitOutputWord(cp, *wordPtr);

            wordPtr++;
            wordCnt--;
        }
    }

    /* Output any long entries */

    while (longCnt)
    {
        int         val = *longPtr;

#ifdef  DEBUG
        if (disAsm)
        {
            emitDispInsOffs(emitCurCodeOffs(cp), dspGCtbls);
            printf(EMIT_DSP_INS_NAME "%d\n", ".data.l", val);
        }
#endif

        assert(longPtr < lp->lpLongNxt);

        cp += emitOutputLong(cp, val);

        longPtr++;
        longCnt--;
    }

    /* Output any addr entries */

    while (addrCnt)
    {
        gtCallTypes     addrTyp = addrPtr->lpaTyp;
        void        *   addrHnd = addrPtr->lpaHnd;

        void        *   addr;

        /* What kind of an address do we have here? */

        switch (addrTyp)
        {
            InfoAccessType accessType;

#ifdef BIRCH_SP2

        case CT_RELOCP:
            addr = (BYTE*)addrHnd;
            // record that this addr must be in the .reloc section
            emitCmpHandle->recordRelocation((void**)cp, IMAGE_REL_BASED_HIGHLOW);
            break;

#endif

        case CT_CLSVAR:

#ifdef  NOT_JITC

            addr = (BYTE *)emitComp->eeGetFieldAddress(addrHnd);
            if (!addr)
                fatal(ERRinternal, "could not obtain address of static field");

#else

            addr = (BYTE *)addrHnd; // just a hack

#endif
            break;

        case CT_HELPER:

#ifdef  NOT_JITC
            assert(!"ToDo");
#else
            addr = NULL;
#endif

            break;

        case CT_DESCR:

            addr = (BYTE*)emitComp->eeGetMethodEntryPoint((METHOD_HANDLE)addrHnd, &accessType);
            assert(accessType == IAT_PVALUE);
            break;

        case CT_INDIRECT:
            assert(!"this should never happen");

        case CT_USER_FUNC:

            if  (emitComp->eeIsOurMethod((METHOD_HANDLE)addrHnd))
            {
                /* Directly recursive call */

                addr = emitCodeBlock;
            }
            else
            {
                addr = (BYTE*)emitComp->eeGetMethodPointer((METHOD_HANDLE)addrHnd, &accessType);
                assert(accessType == IAT_VALUE);
            }

            break;

        default:
            assert(!"unexpected call type");
        }

#ifdef  DEBUG
        if (disAsm)
        {
            emitDispInsOffs(emitCurCodeOffs(cp), dspGCtbls);
            printf(EMIT_DSP_INS_NAME, ".data.l");
            printf("0x%08X          ; ", addr);

            if  (addrTyp == CT_CLSVAR)
            {
                printf("&");
                emitDispClsVar((FIELD_HANDLE) addrHnd, 0);
            }
            else
            {
                const char  *   methodName;
                const char  *    className;

                printf("&");

                methodName = emitComp->eeGetMethodName((METHOD_HANDLE) addrHnd, &className);

                if  (className == NULL)
                    printf("'%s'", methodName);
                else
                    printf("'%s.%s'", className, methodName);
            }

            printf("\n");
        }
#endif

        assert(addrPtr < lp->lpAddrNxt);

        cp += emitOutputLong(cp, (int)addr);

        addrPtr++;
        addrCnt--;
    }

    /* Output any word entries that may remain */

    while (wordCnt)
    {
        int         val = *wordPtr;

#ifdef  DEBUG
        if (disAsm)
        {
            emitDispInsOffs(emitCurCodeOffs(cp), dspGCtbls);
            printf(EMIT_DSP_INS_NAME "%d\n", ".data.w", val);
        }
#endif

        assert(wordPtr < lp->lpWordNxt);

        cp += emitOutputWord(cp, val);

        wordPtr++;
        wordCnt--;
    }

    /* Make sure we've generated the exact right number of entries */

    assert(wordPtr == lp->lpWordNxt);
    assert(longPtr == lp->lpLongNxt);
    assert(addrPtr == lp->lpAddrNxt);

    /* Make sure the size matches our expectations */

    assert(lpBaseOffs + lp->lpSize == emitCurCodeOffs(cp));

    return  cp;
}

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************
 *
 *  Record a reference to a literal pool entry so that the distance can be
 *  updated if the literal pool moves due to scheduling.
 */

    struct  LPcrefDesc
    {
        LPcrefDesc  *       lpcNext;    // next ref to this literal pool
        void        *       lpcAddr;    // address of reference
    };


void                emitter::emitRecordLPref(litPool *lp, BYTE *dst)
{
    LPcrefDesc  *   ref;

    assert(emitComp->opts.compSchedCode);

    /* Allocate a reference descriptor and add it to the list */

    ref = (LPcrefDesc *)emitGetMem(sizeof(*ref));

    ref->lpcAddr = dst;
    ref->lpcNext = lp->lpRefs;
                   lp->lpRefs = ref;
}

/*****************************************************************************/
#endif//SCHEDULER
/*****************************************************************************/
#endif//EMIT_USE_LIT_POOLS
/*****************************************************************************/

/*****************************************************************************
 *
 *  Return the allocated size (in bytes) of the given instruction descriptor.
 */

size_t              emitter::emitSizeOfInsDsc(instrDesc *id)
{
    if  (emitIsTinyInsDsc(id))
        return  TINY_IDSC_SIZE;

    if  (emitIsScnsInsDsc(id))
    {
        return  id->idInfo.idLargeCns ? sizeof(instrBaseCns)
                                      : SCNS_IDSC_SIZE;
    }

    assert((unsigned)id->idInsFmt < emitFmtCount);

    switch (emitFmtToOps[id->idInsFmt])
    {
    case ID_OP_NONE:
        break;

    case ID_OP_JMP:
        return  sizeof(instrDescJmp);

    case ID_OP_CNS:
        return  emitSizeOfInsDsc((instrDescCns   *)id);

    case ID_OP_DSP:
        return  emitSizeOfInsDsc((instrDescDsp   *)id);

    case ID_OP_DC:
        return  emitSizeOfInsDsc((instrDescDspCns*)id);

    case ID_OP_SCNS:
        break;

    case ID_OP_CALL:

        if  (id->idInfo.idLargeCall)
        {
            /* Must be a "fat" indirect call descriptor */

            return  sizeof(instrDescCIGCA);
        }

        assert(id->idInfo.idLargeCns == false);
        assert(id->idInfo.idLargeDsp == false);
        break;

    case ID_OP_SPEC:

#if EMIT_USE_LIT_POOLS
        switch (id->idInsFmt)
        {
        case IF_RWR_LIT:
            return  sizeof(instrDescLPR);
        }
#endif  // EMIT_USE_LIT_POOLS

        assert(!"unexpected 'special' format");

    default:
        assert(!"unexpected instruction descriptor format");
    }

    return  sizeof(instrDesc);
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Return a string that represents the given register.
 */

const   char *      emitter::emitRegName(emitRegs reg, int size, bool varName)
{
    static
    char            rb[128];

    assert(reg < SR_COUNT);

    // CONSIDER: Make the following work just using a code offset

    const   char *  rn = emitComp->compRegVarName((regNumber)reg, varName);

//  assert(size == EA_GCREF || size == EA_BYREF || size == EA_4BYTE);

    return  rn;
}

/*****************************************************************************
 *
 *  Display a static data member reference.
 */

void                emitter::emitDispClsVar(FIELD_HANDLE hand, int offs, bool reloc)
{
    if  (varNames)
    {
        const   char *  clsn;
        const   char *  memn;

        memn = emitComp->eeGetFieldName(hand, &clsn);

        printf("'%s.%s", clsn, memn);
        if (offs) printf("%+d", offs);
        printf("'");
    }
    else
    {
        printf("classVar[%08X]", hand);
    }
}

/*****************************************************************************
 *
 *  Display a stack frame reference.
 */

void                emitter::emitDispFrameRef(int varx, int offs, int disp, bool asmfm)
{
    int         addr;
    bool        bEBP;

    assert(emitComp->lvaDoneFrameLayout);

    addr = emitComp->lvaFrameAddress(varx, &bEBP) + disp; assert((int)addr >= 0);

    printf("@(%u,%s)", addr, bEBP ? "fp" : "sp");

    if  (varx >= 0 && varNames)
    {
        Compiler::LclVarDsc*varDsc;
        const   char *      varName;

        assert((unsigned)varx < emitComp->lvaCount);
        varDsc  = emitComp->lvaTable + varx;
        varName = emitComp->compLocalVarName(varx, offs);

        if  (varName)
        {
            printf("'%s", varName);

            if      (disp < 0)
                    printf("-%d", -disp);
            else if (disp > 0)
                    printf("+%d", +disp);

            printf("'");
        }
    }
}

/*****************************************************************************
 *
 *  Display an indirection (possibly auto-inc/dec).
 */

void                emitter::emitDispIndAddr(emitRegs  base,
                                              bool       dest,
                                              bool       autox,
                                              int        disp)
{
    if  (dest)
    {
        printf("@%s%s", autox ? "-" : "", emitRegName(base));
    }
    else
    {
        printf("@%s%s", emitRegName(base), autox ? "+" : "");
    }
}

#endif  // DEBUG

/*****************************************************************************/
#endif//TGT_RISC
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitsh3.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                             emitSH3.cpp                                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/
#if     TGT_SH3     // this entire file is used only for targetting the SH-3
/*****************************************************************************/

#include "alloc.h"
#include "instr.h"
#include "target.h"
#include "emit.h"

/*****************************************************************************/

#if     TRACK_GC_REFS

regMaskSmall        emitter::emitRegMasks[] =
{
    #define REGDEF(name, strn, rnum, mask) mask,
    #include "regSH3.h"
    #undef  REGDEF
};

#endif

/*****************************************************************************
 *
 *  Initialize the table used by emitInsModeFormat().
 */

BYTE                emitter::emitInsModeFmtTab[] =
{
    #define INST1(id, nm, bd, um, rf, wf, rx, wx, br, i1        ) um,
    #define INST2(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2    ) um,
    #define INST3(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2, i3) um,
    #include "instrSH3.h"
    #undef  INST1
    #undef  INST2
    #undef  INST3
};

BYTE                emitInsWriteFlags[] =
{
    #define INST1(id, nm, bd, um, rf, wf, rx, wx, br, i1        ) wf,
    #define INST2(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2    ) wf,
    #define INST3(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2, i3) wf,
    #include "instrSH3.h"
    #undef  INST1
    #undef  INST2
    #undef  INST3
};

#ifdef  DEBUG
unsigned            emitter::emitInsModeFmtCnt = sizeof(emitInsModeFmtTab)/
                                                 sizeof(emitInsModeFmtTab[0]);
#endif

/*****************************************************************************
 *
 *  Returns true if instruction i2 depends on instruction i1.
 */

bool                emitter::emitInsDepends(instrDesc *i1, instrDesc *i2)
{
    /* What is the second instruction? */

    switch(i2->idIns)
    {
    case INS_rts:

        /* "rts" depends on the PR register only */

        return  (i1->idIns == INS_ldspr);

    case INS_bra:
    case INS_bsr:
    case INS_jsr:
    case INS_bf:
    case INS_bt:
    case INS_mov_PC:

        /* Branches can't be used as branch-delay slots */

        if (i1->idIns == INS_mov_PC 
            || i1->idIns == INS_mova || i1->idIns == INS_bsr || i1->idIns == INS_bra
            || i1->idIns == INS_jsr || i1->idIns == INS_nop)
            return true;

        return  (i1->idInsFmt == IF_LABEL);

    case INS_bfs:
    case INS_bts:


        return ((emitComp->instInfo[i1->idIns] & INST_DEF_FL) != 0);
    
    default:
		emitRegs	rx = i2->idRegGet();
		if (((rx == i1->idRegGet ()) || (rx == i1->idRg2Get())))
			return true;
		rx = i2->idRg2Get();
        if (Compiler::instBranchDelay ((instruction) i1->idIns))
        {
            return (rx == i1->idRegGet ());
        }
        else
        {
            return (((rx == i1->idRegGet ()) || (rx == i1->idRg2Get())));
        }
    }

    /* Play it safe if we're not sure */

    return  true;
}

/*****************************************************************************
 *
 *  Add an instruction with no operands.
 */

void                emitter::emitIns(instruction ins)
{
    instrDesc      *id = emitNewInstr();

    id->idInsFmt = IF_NONE;
    id->idIns    = ins;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  remove an id
 */

void                emitter::delete_id(instrDesc *id_del)
{

#ifdef DEBUG
    emitDispIns(id_del, false, true, false, 0);
#endif

    if ((void*)id_del >= (void*)emitCurIGfreeBase && (void*)emitCurIGfreeNext >= (void*)id_del)
    {
        emitCurIGsize -= emitInstCodeSz(id_del);
        id_del->idIns = INS_ignore;
        id_del->idInsFmt = IF_NONE;
    }

    else
    {

        insGroup    *ig = emitCurIG->igPrev;
        instrDesc   *id = (instrDesc *)ig->igData;
        instrDesc  *tmp = NULL;
        char *ins = (char *) id;
        

        // in retail there is no idNum.  So we have to assume that 
        // the last matching instruction is the correct one.
        for (int i=0; i<ig->igInsCnt; i++)
        {
            id = (instrDesc *)ins;
#ifdef DEBUG
//          emitDispIns(id, false, true, false, 0);
//          fflush(stdout);
#endif
            if (!memcmp(id, id_del, emitSizeOfInsDsc(id))) {
                tmp = id;
            }
            ins = (char *)id + emitSizeOfInsDsc(id);
        }
        assert(tmp);

#ifdef DEBUG
        assert(tmp->idNum == id_del->idNum);
#endif
        ig->igSize -= emitInstCodeSz(tmp);
        emitCurCodeOffset -= emitInstCodeSz(tmp);

        tmp->idIns = INS_ignore;
        tmp->idInsFmt = IF_NONE;
    }
   
    return;
}

/*****************************************************************************
 *
 *  We've just added an instruction with a branch-delay slot. See if it can
 *  be swapped with the previous instruction or whether we may need to add
 *  a nop.
 */

bool                emitter::emitIns_BD(instrDesc * id,
                                        instrDesc * pi,
                                        insGroup  * pg)
{
    /* This should only ever be called for branch-delayed instructions */

#ifdef DEBUG
    assert(Compiler::instBranchDelay(id->idIns));
#endif

#if SCHEDULER

    /* If we're scheduling "for real", we'll take care of this later */

    if  (emitComp->opts.compSchedCode)
        return  true;

#endif

    /* Is there a previous instruction? */

    if  (pi == NULL)
        return  true;

    /* Does the current instruction depend on the previous one? */

    if  (emitInsDepends(pi, id))
        return  true;

    /* Mark the previous instruction to be swapped with the new one */

    pi->idSwap = true;

    return  false;
}

/*****************************************************************************
 *
 *  Add a potentially branch-delaying instruction with no operands.
 */

bool                emitter::emitIns_BD(instruction ins)
{
    instrDesc      *pi = emitLastIns;
    insGroup       *pg = emitCurIG;

    instrDesc      *id = emitNewInstr();

    id->idInsFmt = IF_NONE;
    id->idIns    = ins;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;

    /* Is this actually a branch-delayed instruction? */

    if  (Compiler::instBranchDelay(ins))
        return  emitIns_BD(id, pi, pg);
    else
        return  false;
}

/*****************************************************************************
 *
 *  Add an instruction with a register operand.
 */

void                emitter::emitIns_R(instruction ins,
                                       int         size,
                                       emitRegs   reg)
{
    instrDesc      *id = emitNewInstrTiny(size);

    id->idReg                        = reg;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD);
    id->idIns                        = ins;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add an instruction referencing a register and a small integer constant.
 */

void                emitter::emitIns_R_I(instruction ins, int size, emitRegs reg,
                                                                    int      val)
{
    instrDesc      *id  = emitNewInstrSC(size, val);
    insFormats      fmt = emitInsModeFormat(ins, IF_RRD_CNS);

#if TGT_SH3
    assert(ins == INS_mov_imm || ins == INS_add_imm || ins == INS_mova || ins == INS_xor);
#else
#error Unexpected target
#endif

    id->idReg             = reg;
    id->idInsFmt          = fmt;
    id->idIns             = ins;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add an instruction referencing a register and a small integer constant.
 */

void                emitter::emitIns_I(instruction ins,
                                       int val
#ifdef  DEBUG
                                      ,bool        strlit
#endif
                                       )
{
    instrDesc      *id  = emitNewInstrSC(4, val);
    insFormats      fmt = emitInsModeFormat(ins, IF_RRD_CNS);

    assert(ins == INS_cmpeq || ins == INS_xor_imm);

    id->idInsFmt          = fmt;
    id->idIns             = ins;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}


/*****************************************************************************
 *
 *  Add a "mov" instruction referencing a register and a word/long constant.
 */

void                emitter::emitIns_R_LP_I(emitRegs    reg,
                                           int          size,
                                           int          val,
                                           int          relo_type)
{
    instrDesc      *id;

    /* Figure out whether the operand fits in a 16-bit word */

    if  ((signed short)val == val)
        size = 2;

    /* Create the instruction */

    id                = emitNewInstrLPR(size, CT_INTCNS);

    id->idReg         = reg;
    id->idInsFmt      = IF_RWR_LIT;

#if TGT_SH3
    id->idIns         = INS_mov_PC;
#else
#error Unexpected target
#endif

    id->idAddr.iiaCns = val;

    /*
        Increment the appropriate literal pool count (estimate), and
        record the offset if this is the first LP use in the group.
     */

    id->idInfo.idRelocType = relo_type;

    if  (size == 2)
    {
        if  (emitCurIG->igLPuseCntW == 0)
            emitCurIG->igLPuse1stW = emitCurIGsize;

        emitCurIG->igLPuseCntW++;
    }
    else
    {
        if  (emitCurIG->igLPuseCntL == 0)
            emitCurIG->igLPuse1stL = emitCurIGsize;

        emitCurIG->igLPuseCntL++;
    }

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a "mov" instruction referencing a register and a global variable addr.
 */

void                emitter::emitIns_R_LP_V(emitRegs reg, void *mem)
{
    instrDesc      *id;

    id                = emitNewInstrLPR(sizeof(void*), CT_CLSVAR, mem);
    id->idReg         = reg;

    /*
        Increment the appropriate literal pool count (estimate), and
        record the offset if this is the first LP use in the group.
     */

    if  (emitCurIG->igLPuseCntA == 0)
        emitCurIG->igLPuse1stA = emitCurIGsize;

    emitCurIG->igLPuseCntA++;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a "mov" instruction referencing a register and a method address.
 */

void                emitter::emitIns_R_LP_M(emitRegs    reg,
                                            gtCallTypes callType,
                                            void   *    callHand)
{
    instrDesc      *id;

    id                = emitNewInstrLPR(sizeof(void*), callType, callHand);

    id->idReg         = reg;
    id->idInsFmt      = IF_RWR_LIT;
    id->idIns         = INS_mov_PC;

    /*
        Increment the appropriate literal pool count (estimate), and
        record the offset if this is the first LP use in the group.
     */

    if  (emitCurIG->igLPuseCntA == 0)
        emitCurIG->igLPuse1stA = emitCurIGsize;

    emitCurIG->igLPuseCntA++;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

#ifdef BIRCH_SP2
/*****************************************************************************
 *
 *  Add a "mov" instruction referencing a register and a pointer that will
 *  need to be store in the .reloc section.
 */

void                emitter::emitIns_R_LP_P(emitRegs    reg,
                                            void   *    data,
                                             int        relo_type)
{
    instrDesc      *id;

    id                = emitNewInstrLPR(sizeof(void*), CT_RELOCP, data);

    id->idReg         = reg;
    id->idInsFmt      = IF_RWR_LIT;
    id->idIns         = INS_mov_PC;
    
    id->idInfo.idRelocType = relo_type;

    /*
        Increment the appropriate literal pool count (estimate), and
        record the offset if this is the first LP use in the group.
     */

    if  (emitCurIG->igLPuseCntA == 0)
        emitCurIG->igLPuse1stA = emitCurIGsize;

    emitCurIG->igLPuseCntA++;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}
#endif  // BIRCH_SP2 only


/*****************************************************************************
 *
 *  Add an instruction with two register operands.
 */

void                emitter::emitIns_R_R(instruction ins,
                                         int         size,
                                         emitRegs    reg1,
                                         emitRegs    reg2)
{
    instrDesc      *id = emitNewInstrTiny(size);

    id->idReg                        = reg1;
    id->idRg2                        = reg2;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_RRD);
    id->idIns                        = ins;


    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add an indirect jump through a table (this generates many instructions).
 */

void                emitter::emitIns_JmpTab(emitRegs   reg,
                                            unsigned    cnt,
                                            BasicBlock**tab)
{
    instrDescJmp   *id = emitNewInstrJmp();
    size_t          sz;

    assert(reg != SR_r00);

    id->idIns             = INS_braf;
    id->idInsFmt          = IF_JMP_TAB;
    id->idReg             = reg;
    id->idAddr.iiaBBtable = tab;
    id->idjTemp.idjCount  = cnt;

    /* Record the jump's IG and offset within it */

    id->idjIG             = emitCurIG;
    id->idjOffs           = emitCurIGsize;

    /* Append this jump to this IG's jump list */

    id->idjNext           = emitCurIGjmpList;
                            emitCurIGjmpList = id;

    /* This will take at most 6 instructions + alignment + the table itself */

    id->idjCodeSize = sz  = 6*INSTRUCTION_SIZE + sizeof(short) * 2
                                               + sizeof(void*) * cnt;

    dispIns(id);
    emitCurIGsize += sz;

    /* Force an end to the current IG */

    emitNxtIG();

    /* Remember that we have indirect jumps */

    emitIndJumps = true;
}

/*****************************************************************************
 *
 *  Add a "mov" instruction with a register and an indirection.
 */

void                emitter::emitIns_IMOV(insFormats fmt,
                                          emitRegs  dreg,
                                          emitRegs  areg,
                                          bool       autox,
                                          int        size,
                                          bool       isfloat
                                          )
{
    instrDesc      *id = emitNewInstr(size);

    id->idReg                        = dreg;
    id->idInsFmt                     = fmt;
#if SHX_SH4
    if (!isfloat)
        id->idIns                        = INS_mov_ind;
    else
        id->idIns                        = INS_fmov_ind;
#else
    id->idIns                        = INS_mov_ind;
#endif

    id->idAddr.iiaRegAndFlg.rnfReg   = areg;
    id->idAddr.iiaRegAndFlg.rnfFlg   = autox ? RNF_AUTOX : 0;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a "mov" instruction with a register and a "@(r0,reg)" indirection.
 */

void                emitter::emitIns_X0MV(insFormats fmt,
                                         emitRegs  dreg,
                                         emitRegs  areg,
                                         int        size)
{
    instrDesc      *id = emitNewInstr(size);

    id->idReg                        = dreg;
    id->idInsFmt                     = fmt;
    id->idIns                        = fmt == IF_0RD_RRD_XWR ? INS_mov_ix0 : INS_movl_ix0;

    id->idAddr.iiaRegAndFlg.rnfReg   = areg;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a "mov" instruction with a register and a "@(reg+disp)" indirection.
 */

void                emitter::emitIns_RDMV(insFormats fmt,
                                          emitRegs   dreg,
                                          emitRegs   areg,
                                          int        offs,
                                          int        size)
{
    instrDesc      *id = emitNewInstrDsp(size, offs);

#ifndef NDEBUG

    /* Make sure the displacement is aligned and within range */

    int temp                         = EA_SIZE(size);

    assert(temp == 1 || temp == 2 || temp == 4);
    assert(offs >= 0 && offs <= MAX_INDREG_DISP*temp);
    assert((offs & (temp-1)) == 0);

#endif

    id->idReg                        = dreg;
    id->idInsFmt                     = fmt;
    id->idIns                        = INS_mov_dsp;

    id->idAddr.iiaRegAndFlg.rnfReg   = areg;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a instruction with an indirection and an implied operand (such as PR).
 */

void                emitter::emitIns_IR(emitRegs    reg,
                                        instruction ins,
                                        bool        autox,
                                        int         size)
{
    instrDesc      *id = emitNewInstr(size);

    id->idAddr.iiaRegAndFlg.rnfReg   = reg;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_IRD);
    id->idIns                        = ins;

//  id->idAddr.iiaRegAndFlg.rnfReg   = SR_NA;
    id->idAddr.iiaRegAndFlg.rnfFlg   = autox ? RNF_AUTOX : 0;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a instruction with an indirection and an implied operand (such as PR).
 */

void                emitter::emitIns_Ig(instruction ins,
                                        int         val,
                                        int         size)
{
    instrDesc      *id  = emitNewInstrSC(size, val);

    id->idIns                        = ins;

    if (ins == INS_lod_gbr)
        id->idInsFmt                     = emitInsModeFormat(ins, IF_IRD_GBR);
    else
        id->idInsFmt                     = emitInsModeFormat(ins, IF_IWR_GBR);
    
    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  The following add instructions referencing stack-based local variables.
 */

#if 0

void                emitter::emitIns_S(instruction ins,
                                       int         size,
                                       int         varx,
                                       int         offs)
{
    instrDesc      *id = emitNewInstr(size);

    id->idIns                        = ins;
    id->idAddr.iiaLclVar.lvaVarNum   = varx;
    id->idAddr.iiaLclVar.lvaOffset   = offs;
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

    id->idInsFmt                     = emitInsModeFormat(ins, IF_SRD);

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

#endif

void                emitter::emitIns_S_R(instruction ins,
                                         int         size,
                                         emitRegs    ireg,
                                         int         varx,
                                         int         offs)
{
    instrDesc      *id = emitNewInstr(size);

    id->idIns                        = ins;
    id->idReg                        = ireg;
    id->idAddr.iiaLclVar.lvaVarNum   = varx;
    id->idAddr.iiaLclVar.lvaOffset   = offs;
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

    id->idInsFmt                     = emitInsModeFormat(ins, IF_SRD_RRD);

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

void                emitter::emitIns_R_S   (instruction ins,
                                           int         size,
                                           emitRegs   ireg,
                                           int         varx,
                                           int         offs)
{
    instrDesc      *id = emitNewInstr(size);

    id->idIns                        = ins;
    id->idReg                        = ireg;
    id->idAddr.iiaLclVar.lvaVarNum   = varx;
    id->idAddr.iiaLclVar.lvaOffset   = offs;
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_SRD);

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add an instruction with an operand off of SP and a register operand.
 */

void                emitter::emitIns_A_R(emitRegs reg, unsigned offs)
{
    instrDesc      *id = emitNewInstr(sizeof(int));

    id->idReg                        = reg;
    id->idInsFmt                     = IF_AWR_RRD;
    id->idIns                        = INS_mov_dsp;
    id->idAddr.iiaCns                = offs;

    dispIns(id);
    emitCurIGsize += INSTRUCTION_SIZE;
}

/*****************************************************************************
 *
 *  Add a jmp instruction.
 */

void                emitter::emitIns_J(instruction ins,
                                       bool        except,
                                       bool        moveable,
                                       BasicBlock *dst)
{
    size_t          sz;
    instrDescJmp  * id = emitNewInstrJmp();

#if SCHEDULER
    assert(except == moveable);
#endif

    assert(dst->bbFlags & BBF_JMP_TARGET);

    id->idInsFmt          = IF_LABEL;
    id->idIns             = ins;
    id->idAddr.iiaBBlabel = dst;

#if SCHEDULER
    if  (except)
        id->idInfo.idMayFault = true;
#endif

    /* Assume the jump will be long */

    id->idjShort          = 0;

    /* The jump may require a branch-delay slot */

    id->idjAddBD          = Compiler::instBranchDelay(ins);

    /* Record the jump's IG and offset within it */

    id->idjIG             = emitCurIG;
    id->idjOffs           = emitCurIGsize;

    /* Append this jump to this IG's jump list */

    id->idjNext           = emitCurIGjmpList;
                            emitCurIGjmpList = id;

#if EMITTER_STATS
    emitTotalIGjmps++;
#endif

    /* Record the offset if this is the first LP use in the group */

    if  (emitCurIG->igLPuseCntL == 0)
        emitCurIG->igLPuse1stL = emitCurIGsize;

    /* We might need a "long" literal pool entry for this call/jump */

    emitCurIG->igLPuseCntL++;

    /* Figure out the max. size of the jump/call instruction */

    if  (ins == INS_bsr)
    {
        /* This is a local call instruction */

        sz = JMP_SIZE_LARGE;
    }
    else
    {
        insGroup    *   tgt;

        assert(ins != INS_jsr);

        /* This is a jump - assume the worst */

        sz = (ins == JMP_INSTRUCTION) ? JMP_SIZE_LARGE
                                      : JCC_SIZE_LARGE;

        // ISSUE: On RISC - one or more literal pools might get in the way,
        // ISSUE: so for now we assume even backward jumps cannot be bound
        // ISSUE: to be short at this stage - we'll have to do it later.
    }

    dispIns(id);

#if SCHEDULER

    if (emitComp->opts.compSchedCode)
    {
        id->idjSched = moveable;

#if!MAX_BRANCH_DELAY_LEN
        if  (!moveable)
        {
            scInsNonSched(id);
        }
        else
#endif
        {
            /*
                This jump is moveable (can be scheduled), and so we'll need
                to figure out the range of offsets it may be moved to after
                it's scheduled (otherwise we wouldn't be able to correctly
                estimate the jump distance).
             */

            id->idjTemp.idjOffs[0] = emitCurIGscdOfs;
            id->idjTemp.idjOffs[1] = emitCurIGscdOfs - 1;
        }
    }
    else
    {
        id->idjSched = false;
    }

#endif

    emitCurIGsize += sz;

    /* Append a "nop" if the branch has delay slot(s) */

#if SCHEDULER && MAX_BRANCH_DELAY_LEN

    if  (id->idjAddBD && emitComp->opts.compSchedCode)
    {
        /* We'll let the "real" scheduler worry about filling the BD slot(s) */

        emitIns(INS_nop); id->idjAddBD = false;
    }

#endif

}

#ifdef BIRCH_SP2
void             emitter::emitIns_CallDir(size_t        argSize,
                                          int           retSize,
#if TRACK_GC_REFS
                                          VARSET_TP     ptrVars,
                                          unsigned      gcrefRegs,
                                          unsigned      byrefRegs,
#endif
                                          unsigned      ftnIndex,
                                          emitRegs      areg)
{
    unsigned        argCnt;

    instrDesc      *id;
    instrDesc      *pd = emitLastIns;

#if     TRACK_GC_REFS

#error  GC ref tracking for RISC is not yet implemented

#ifdef  DEBUG
    if  (verbose) printf("Call : GCvars=%016I64X , gcrefRegs=%04X , byrefRegs=%04X\n",
                                 ptrVars,          gcrefRegs,       byrefRegs);
#endif

#endif

    /* Figure out how many arguments we have */

    argCnt = argSize / sizeof(void*); assert(argSize == argCnt * sizeof(int));

    /* Allocate the instruction descriptor */

#if TRACK_GC_REFS
    id  = emitNewInstrCallInd(argCnt, ptrVars, byrefRegs, retSize);
#else
    id  = emitNewInstrCallInd(argCnt,                     retSize);
#endif

#if SMALL_DIRECT_CALLS

    /* Do we know the previous instruction? */

    OptPEReader *oper =     &((OptJitInfo*)emitComp->info.compCompHnd)->m_PER;
    BYTE        *dstAddr =  (BYTE *)oper->m_rgFtnInfo[ftnIndex].m_pNative;

    if  (pd && dstAddr)
    {
        /* Do we have a direct call sequence? */

        // ISSUE: Should we check whether we can get the address?

        if  (pd->idInsFmt == IF_RWR_LIT        &&
             pd->idIns    == LIT_POOL_LOAD_INS &&
             pd->idRegGet()== areg )
        {
            /* Mark the earlier address load */

            ((instrDescLPR *)pd)->idlCall = id;

            /* Remember that we a direct call candidate */

            emitTotDCcount++;

            // ISSUE: Should we make sure that 'areg' is not callee-saved?
        }
    }

#endif

    /* Set the instruction/format, record the address register */

    id->idIns             = INS_jsr;
    id->idInsFmt          = IF_METHOD;
    id->idReg             = areg;
	id->idAddr.iiaMethHnd = ~0;

#if TRACK_GC_REFS

    /* Update the "current" live GC ref sets */

    emitThisGCrefVars =   ptrVars;
    emitThisGCrefRegs = gcrefRegs;
    emitThisByrefRegs = byrefRegs;

    /* Save the live GC registers in the unused 'rnfReg' field */

    id->idAddr.iiaRegAndFlg.rnfReg = emitEncodeCallGCregs(gcrefRegs);

#endif

    dispIns(id);
    emitCurIGsize   += INSTRUCTION_SIZE;

    /* Append a "nop" if the call is branch-delayed */

    id->idAddr.iiaMethHnd = (METHOD_HANDLE) ftnIndex;
    
    if  (Compiler::instBranchDelay(id->idInsGet()))
        emitIns(INS_nop);
}
#endif  // BIRCH_SP2


/*****************************************************************************
 *
 *  Add a call-via-register instruction.
 */

void                emitter::emitIns_Call(size_t        argSize,
                                          int           retSize,
#if TRACK_GC_REFS
                                          VARSET_TP     ptrVars,
                                          unsigned      gcrefRegs,
                                          unsigned      byrefRegs,
#endif
                                          bool          chkNull,
                                          emitRegs      areg)
{
    unsigned        argCnt;

    instrDesc      *id;
    instrDesc      *pd = emitLastIns;

#if     TRACK_GC_REFS

#error  GC ref tracking for RISC is not yet implemented

#ifdef  DEBUG
    if  (verbose) printf("Call : GCvars=%016I64X , gcrefRegs=%04X , byrefRegs=%04X\n",
                                 ptrVars,          gcrefRegs,       byrefRegs);
#endif

#endif

    /* Figure out how many arguments we have */

    argCnt = argSize / sizeof(void*); assert(argSize == argCnt * sizeof(int));

    /* Allocate the instruction descriptor */

#if TRACK_GC_REFS
    id  = emitNewInstrCallInd(argCnt, ptrVars, byrefRegs, retSize);
#else
    id  = emitNewInstrCallInd(argCnt,                     retSize);
#endif

#if SMALL_DIRECT_CALLS

    /* Do we know the previous instruction? */

    if  (pd)
    {
        /* Do we have a direct call sequence? */

        // ISSUE: Should we check whether we can get the address?

        if  (pd->idInsFmt == IF_RWR_LIT        &&
             pd->idIns    == LIT_POOL_LOAD_INS &&
             pd->idRegGet()== areg )
        {
            /* Mark the earlier address load */

            ((instrDescLPR *)pd)->idlCall = id;

            /* Remember that we a direct call candidate */

            emitTotDCcount++;

            // ISSUE: Should we make sure that 'areg' is not callee-saved?
        }
    }

#endif

    /* Set the instruction/format, record the address register */

    id->idIns             = INS_jsr;
    id->idInsFmt          = IF_METHOD;
    id->idReg             = areg;
	id->idAddr.iiaMethHnd = ~0;

#if TRACK_GC_REFS

    /* Update the "current" live GC ref sets */

    emitThisGCrefVars =   ptrVars;
    emitThisGCrefRegs = gcrefRegs;
    emitThisByrefRegs = byrefRegs;

    /* Save the live GC registers in the unused 'rnfReg' field */

    id->idAddr.iiaRegAndFlg.rnfReg = emitEncodeCallGCregs(gcrefRegs);

#endif

    /* Is this a call via a function pointer which could be NULL? */

    if  (chkNull)
        id->idInfo.idMayFault;

#ifdef  DEBUG
    if  (verbose&&0)
    {
        if  (id->idInfo.idLargeCall)
            printf("[%02u] Rec call GC vars = %016I64X\n", id->idNum, ((instrDescCIGCA*)id)->idciGCvars);
    }
#endif

    dispIns(id);
    emitCurIGsize   += INSTRUCTION_SIZE;

    /* Append a "nop" if the call is branch-delayed */

    //id->idjAddBD          = Compiler::instBranchDelay(ins);
    if  (Compiler::instBranchDelay(id->idInsGet()))
        emitIns(INS_nop);
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Display the given instruction.
 */

void                emitter::emitDispIns(instrDesc *id, bool isNew,
                                                        bool doffs,
                                                        bool asmfm, unsigned offs)
{
    unsigned        sp;
    int             size;
    char            name[16];

#ifdef BIRCH_SP2
    if (!verbose)
        return;
#endif

    instruction     ins = id->idInsGet(); assert(ins != INS_none);

//  printf("[F=%s] "   , emitIfName(id->idInsFmt));
//  printf("INS#%03u: ", id->idNum);
//  printf("[S=%02u] " , emitCurStackLvl/sizeof(int));
//  printf("[A=%08X] " , emitSimpleStkMask);
//  printf("[A=%08X] " , emitSimpleByrefStkMask);

    if  (!dspEmit && !isNew && !asmfm)
        doffs = true;

    /* Display the instruction offset */

    emitDispInsOffs(offs, doffs);

    /* Get hold of the instruction name */

    strcpy(name, emitComp->genInsName(ins));

    /* Figure out the operand size */


    size = emitDecodeSize(id->idOpSize);

#if TRACK_GC_REFS
    switch(id->idGCrefGet())
    {
    case GCT_GCREF:     size = EA_GCREF; break;
    case GCT_BYREF:     size = EA_BYREF; break;
    case GCT_NONE:                       break;
#ifdef DEBUG
    default:            assert(!"bad GCtype");
#endif
    }
#endif

    switch (id->idInsFmt)
    {
        char    *   suffix;

    case IF_NONE:
    case IF_LABEL:
        break;

    case IF_DISPINS:
        goto NO_NAME;

    default:

        switch (ins)
        {
        case INS_jsr:
#if SMALL_DIRECT_CALLS
        case INS_bsr:
#endif
        case INS_cmpPL:
        case INS_cmpPZ:
            suffix = "";
            break;

        case INS_mov_imm:
            suffix = ".b";
            break;

        case INS_add_imm:
            suffix = ".l";
            break;

        case INS_extsb:
        case INS_extub:
            suffix = ".b";
            break;

        case INS_extsw:
        case INS_extuw:
            suffix = ".w";
            break;

        default:

            switch (size)
            {
            case 1:
                suffix = ".b";
                break;
            case 2:
                suffix = ".w";
                break;
            default:
                suffix = ".l";
                break;
            }
        }

        strcat(name, suffix);
        break;
    }

    /* Display the full instruction name */

    printf(EMIT_DSP_INS_NAME, name);

    /* If this instruction has just been added, check its size */

    assert(isNew == false || (int)emitSizeOfInsDsc(id) == emitCurIGfreeNext - (BYTE*)id);

NO_NAME:

    /* We keep track of the number of characters displayed (for alignment) */

    sp = 20;

#define TMPLABFMT "J_%u"

    /* Now see what instruction format we've got */

    switch (id->idInsFmt)
    {
        emitRegs       rg1;
        emitRegs       rg2;
        unsigned        flg;

        const char  *   rnm;
        const char  *   xr1;
        const char  *   xr2;

        void        *   mem;

        int             val;
        int             offs;

        instrDesc   *   idr;
        unsigned        idn;

        const char  *   methodName;
        const char  *    className;

    case IF_DISPINS:

        idr = ((instrDescDisp*)id)->iddId;
        idn = ((instrDescDisp*)id)->iddNum;

        switch (idr->idInsFmt)
        {
            dspJmpInfo *    info;

        case IF_JMP_TAB:
            {
            info = (dspJmpInfo*)((instrDescDisp*)id)->iddInfo;

            static
            BYTE            sizeChar[] =
            {
                'b',    // IJ_UNS_I1
                'b',    // IJ_UNS_U1
                'b',    // IJ_SHF_I1
                'b',    // IJ_SHF_U1

                'w',    // IJ_UNS_I2
                'w',    // IJ_UNS_U2

                'l',    // IJ_UNS_I4
            };

            switch (idn)
            {
            case 0:
            case 9:
                printf(EMIT_DSP_INS_NAME, ".align");
                printf("4");
                break;

            case 1:
                printf(EMIT_DSP_INS_NAME, emitComp->genInsName(info->iijIns));
                printf("%s", emitRegName(info->iijInfo.iijReg));
                break;

            case 2:
                printf(EMIT_DSP_INS_NAME, "mova.l");
                printf(TMPLABFMT, info->iijLabel+1);
                break;

            case 3:
                sprintf(name, "mov.%c", sizeChar[info->iijKind]);
                printf(EMIT_DSP_INS_NAME, name);
                printf("@(%s,r0),r0", emitRegName(id->idRegGet()));
                break;

            case 4:
                strcpy(name, emitComp->genInsName(info->iijIns));
                strcat(name, info->iijIns == INS_extub ? ".b" : ".w");
                printf(EMIT_DSP_INS_NAME, name);
                printf("%s", emitRegName(info->iijInfo.iijReg));
                break;

            case 5:
                printf(EMIT_DSP_INS_NAME, "shll.l");
                printf("%s", emitRegName(info->iijInfo.iijReg));
                break;

            case 6:
                printf(EMIT_DSP_INS_NAME, "braf");
                printf(emitRegName(SR_r00));
                break;

            case 7:
                printf(EMIT_DSP_INS_NAME, "nop");
                break;

            case 8:
                printf("  "TMPLABFMT":", info->iijLabel);
                break;

            case 10:
                printf("  "TMPLABFMT":", info->iijLabel+1);
                break;

            case 99:
                sprintf(name, ".data.%c", sizeChar[info->iijKind]);
                printf(EMIT_DSP_INS_NAME, name);
                printf("G_%02u_%02u - ", Compiler::s_compMethodsCount,
                                         info->iijTarget);
                printf(TMPLABFMT, info->iijLabel);
                break;

            default:
#ifdef  DEBUG
                printf("Index = %u\n", idn);
#endif
                assert(!"unexpected indirect jump display index");
            }
            }
            break;

        case IF_LABEL:

            if  (((instrDescJmp*)idr)->idjShort)
            {
                printf(EMIT_DSP_INS_NAME, "nop");
                printf("%*c; branch-delay slot", 20, ' ');
                break;
            }

            if  (ins != INS_xtrct)
                printf(EMIT_DSP_INS_NAME, name);

            info = (dspJmpInfo*)((instrDescDisp*)id)->iddInfo;

            if  (((instrDescJmp*)idr)->idjMiddle)
            {
                switch (idn)
                {
                case 0:
                    sp -= printf(TMPLABFMT, info->iijLabel);
                    printf("%*c; pc+2", sp, ' ');
                    break;
                case 1:
                    printf("G_%02u_%02u", Compiler::s_compMethodsCount, idr->idAddr.iiaIGlabel->igNum);
                    break;
                case 2:
                    break;
                case 3:
                    printf(TMPLABFMT ":", info->iijLabel);
                    break;
                default:
                    assert(!"unexpected 'special' medium jump display format");
                }
            }
            else
            {
                switch (idn)
                {
                case 0:
                default:
                    assert(!"unexpected 'special' long jump display format");
                }
            }

            break;

        default:
            assert(!"unexpected 'special' instruction display format");
        }

        break;

    case IF_RRD:
    case IF_RWR:
    case IF_RRW:

        xr1 = xr2 = NULL;

        switch (ins)
        {
        case INS_ldsmach: xr2 = "mach"; break;
        case INS_ldsmacl: xr2 = "macl"; break;
        case INS_ldspr  : xr2 = "PR"  ; break;
        case INS_stsmach: xr1 = "mach"; break;
        case INS_stsmacl: xr1 = "macl"; break;
        case INS_stspr  : xr1 = "PR"  ; break;
        }

        if  (xr1) printf("%s,", xr1);
        printf("%s", emitRegName(id->idRegGet()));
        if  (xr2) printf(",%s", xr2);
        break;

    case IF_RRD_CNS:
    case IF_RWR_CNS:
    case IF_RRW_CNS:
#if DSP_SRC_OPER_LEFT
        printf("#%d,%s", emitGetInsSC(id), emitRegName(id->idRegGet()));
#else
        printf("%s,#%d", emitRegName(id->idRegGet()), emitGetInsSC(id));
#endif
        break;

    case IF_RWR_LIT:

        if  (emitDispInsExtra)
        {
            unsigned    sp = 20;

#if SMALL_DIRECT_CALLS
            if  (ins == INS_bsr)
                sp -= printf("%+d", emitDispLPaddr);
            else
#endif
                sp -= printf("@(%u,pc),%s", emitDispLPaddr, emitRegName(id->idRegGet()));

            printf("%*c; ", sp, ' ');
        }

        mem = id->idAddr.iiaMembHnd;

        switch (emitGetInsLPRtyp(id))
        {
        case CT_INTCNS:
            if  (emitDispInsExtra)
            {
                if  ((int)mem > 0)
                    printf("0x%08X=", mem);

                printf("%d", mem);
            }
            else
                printf("#%d", mem);
            break;

#ifdef BIRCH_SP2

        case CT_RELOCP:
            if  (emitDispInsExtra)
            {
                if  ((int)mem > 0)
                    printf(".reloc 0x%08X=", mem);

                printf("%d", mem);
            }
            else
                printf(".reloc #%d", mem);
            break;

#endif

        case CT_CLSVAR:

#if SMALL_DIRECT_CALLS
            if  (ins != INS_bsr)
#endif
                printf("&");

            emitDispClsVar((FIELD_HANDLE) mem, 0);
            break;

        default:

#if SMALL_DIRECT_CALLS
            if  (ins != INS_bsr)
#endif
                printf("&");

            methodName = emitComp->eeGetMethodName((METHOD_HANDLE) mem, &className);

            if  (className == NULL)
                printf("'%s'", methodName);
            else
                printf("'%s.%s'", className, methodName);

            break;
        }

        if  (!emitDispInsExtra)
            printf(",%s", emitRegName(id->idRegGet()));

        break;

    case IF_RRD_RRD:
    case IF_RWR_RRD:
    case IF_RRW_RRD:
#if DSP_SRC_OPER_LEFT
        printf("%s,", emitRegName(id->idRg2Get()));
        printf("%s" , emitRegName(id->idRegGet()));
#else
        printf("%s,", emitRegName(id->idRegGet()));
        printf("%s" , emitRegName(id->idRg2Get()));
#endif
        break;

    case IF_IRD:
    case IF_IWR:

        switch (ins)
        {
        case INS_ldspr  :
        case INS_stspr  : rnm =   "pr"; break;

        case INS_ldcgbr :
        case INS_stcgbr : rnm =  "GBR"; break;

        case INS_ldsmach:
        case INS_stsmach: rnm = "mach"; break;

        case INS_ldsmacl:
        case INS_stsmacl: rnm = "macl"; break;

        default:
            assert(!"unexpected instruction");
        }

        rg1 = (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg;
        flg =           id->idAddr.iiaRegAndFlg.rnfFlg;

        if  (id->idInsFmt == IF_IRD)
        {
            printf("%s,", rnm);
            emitDispIndAddr(rg1,  true, (flg & RNF_AUTOX) != 0);
        }
        else
        {
            emitDispIndAddr(rg1, false, (flg & RNF_AUTOX) != 0);
            printf(",%s", rnm);
        }
        break;

#if DSP_DST_OPER_LEFT
    case IF_IRD_RWR:
#else
    case IF_RRD_IWR:
#endif

        rg1 = id->idRegGet();
        rg2 = (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg;
        flg = id->idAddr.iiaRegAndFlg.rnfFlg;

        emitDispIndAddr(rg2, false, (flg & RNF_AUTOX) != 0);
        printf(",%s", emitRegName(rg1));
        break;

#if DSP_DST_OPER_LEFT
    case IF_RRD_IWR:
#else
    case IF_IRD_RWR:
#endif

        rg1 = id->idRegGet();
        rg2 = (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg;
        flg = id->idAddr.iiaRegAndFlg.rnfFlg;

        printf("%s,", emitRegName(rg1));
        emitDispIndAddr(rg2, true, (flg & RNF_AUTOX) != 0);
        break;

    case IF_RRD_SRD:    // reg <- stk
    case IF_RWR_SRD:    // reg <- stk
    case IF_RRW_SRD:    // reg <- stk

#if DSP_DST_OPER_LEFT
        printf("%s,", emitRegName(id->idRegGet(), size));
#endif

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                       id->idAddr.iiaLclVar.lvaRefOfs,
                       id->idAddr.iiaLclVar.lvaOffset, asmfm);


#if DSP_SRC_OPER_LEFT
        printf(",%s", emitRegName(id->idRegGet(), size));
#endif

        break;

    case IF_SRD_RRD:    // stk <- reg
    case IF_SWR_RRD:    // stk <- reg
    case IF_SRW_RRD:    // stk <- reg

#if DSP_SRC_OPER_LEFT
        printf("%s,", emitRegName(id->idRegGet(), size));
#endif

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                       id->idAddr.iiaLclVar.lvaRefOfs,
                       id->idAddr.iiaLclVar.lvaOffset, asmfm);


#if DSP_DST_OPER_LEFT
        printf(",%s", emitRegName(id->idRegGet(), size));
#endif

        break;

    case IF_AWR_RRD:

#if DSP_SRC_OPER_LEFT
        printf("%s,", emitRegName(id->idRegGet(), size));
#endif
        printf("@(sp,%u)", id->idAddr.iiaCns);
#if DSP_DST_OPER_LEFT
        printf(",%s", emitRegName(id->idRegGet(), size));
#endif

        break;

#if DSP_SRC_OPER_LEFT
    case IF_0RD_RRD_XWR:
#else
    case IF_0RD_XRD_RWR:
#endif
        printf("%s,@(r0,%s)", emitRegName(id->idRegGet(), size),
                              emitRegName((emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, sizeof(void*)));
        break;

#if DSP_SRC_OPER_LEFT
    case IF_0RD_XRD_RWR:
#else
    case IF_0RD_RRD_XWR:
#endif
        printf("@(r0,%s),%s", emitRegName((emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, size),
                              emitRegName(id->idRegGet(),             sizeof(void*)));
        break;

#if DSP_SRC_OPER_LEFT
    case IF_DRD_RWR:
#else
    case IF_RRD_DWR:
#endif
        printf("@(%s,%d),%s", emitRegName((emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, size),
                              emitGetInsDsp(id),
                              emitRegName(id->idRegGet(),             sizeof(void*)));
        break;

#if DSP_SRC_OPER_LEFT
    case IF_RRD_DWR:
#else
    case IF_DRD_RWR:
#endif
        printf("%s,@(%s,%d)", emitRegName(id->idRegGet(),             sizeof(void*)),
                              emitRegName((emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, size),
                              emitGetInsDsp(id));
        break;

    case IF_NONE:
        break;

    case IF_LABEL:

//      if  (((instrDescJmp*)id)->idjShort ) printf("SHORT ");
//      if  (((instrDescJmp*)id)->idjMiddle) printf("MIDDLE");

        if  (id->idInfo.idBound)
        {
            printf("G_%02u_%02u", Compiler::s_compMethodsCount, id->idAddr.iiaIGlabel->igNum);
        }
        else
        {
            printf("L_%02u_%02u", Compiler::s_compMethodsCount, id->idAddr.iiaBBlabel->bbNum);
        }

        if  (emitDispInsExtra)
            printf("             ; pc%+d", emitDispJmpDist);

        break;

    case IF_METHOD:

        sp -= printf("@%s", emitRegName(id->idRegGet()));

        if  (id->idInfo.idLargeCall)
        {
            // CONSIDER: Display GC info
        }
        break;

    case IF_JMP_TAB:
        printf("<indirect jump>");
        break;

    case IF_IRD_RWR_GBR:
        printf("@(#%d,GBR),%s", emitGetInsSC(id), emitRegName(id->idRegGet(),             sizeof(void*)));
        break;

    case IF_RRD_IWR_GBR:
        printf("%s, @(#%d,GBR)", emitRegName(id->idRegGet(), sizeof(void*)), emitGetInsSC(id));
        break;


    default:

        printf("unexpected SH-3 instruction format %s\n", emitIfName(id->idInsFmt));

        BreakIfDebuggerPresent();
        assert(!"oops");
        break;
    }

    emitDispInsExtra = false;

    printf("\n");
}

/*****************************************************************************/
#endif//DEBUG
/*****************************************************************************
 *
 *  Finalize the modes and sizes of all indirect jumps.
 *
 */

void                emitter::emitFinalizeIndJumps()
{
    /* Do we have any table jumps? */

    if  (emitIndJumps)
    {
        unsigned        ofs;
        instrDescJmp *  jmp;

        insGroup    *   ig1 = NULL;

        /* Fix the size of all table jumps; start by finding the first one */

        for (jmp = emitJumpList; jmp; jmp = jmp->idjNext)
        {
            insGroup  *     jmpIG;

            unsigned        jmpCnt;
            BasicBlock  * * jmpTab;

            unsigned        srcNeg;
            unsigned        srcPos;
            unsigned        srcOfs;

            int             minOfs;
            int             maxOfs;

            emitIndJmpKinds   kind;

            size_t          size;
            size_t          adrs;
            size_t          diff;

            if  (jmp->idInsFmt != IF_JMP_TAB)
                continue;

            jmpIG = jmp->idjIG;

            /* Remember the group of the first indirect jump */

            if  (!ig1) ig1 = jmpIG;

            /* Compute the max. distance of any entry in the table */

            jmpCnt = jmp->idjTemp.idjCount;
            jmpTab = jmp->idAddr.iiaBBtable;

            /* Estimate the source offsets for the jump */

            srcOfs = jmpIG->igOffs + jmpIG->igSize - jmp->idjCodeSize;
            srcNeg = jmpIG->igOffs + jmpIG->igSize - jmpCnt * sizeof(void*);
            srcPos = jmpIG->igOffs + jmpIG->igSize - roundUp(jmpCnt, INSTRUCTION_SIZE);

//          printf("Estimated offs/size/end of ind jump: %04X/%02X/%04X\n", srcOfs, jmp->idjCodeSize, jmpIG->igOffs + jmpIG->igSize);

            /* Compute the max. distance of any entry in the table */

            minOfs = INT_MAX & ~1;
            maxOfs = INT_MIN & ~1;

            do
            {
                insGroup    *   tgt;
                unsigned        ofs;
                int             dif;
#ifdef  DEBUG
                unsigned        src = 0xDDDD;
#endif

                /* Get the target IG of the entry */

                tgt = (insGroup*)emitCodeGetCookie(*jmpTab); assert(tgt);
                ofs = tgt->igOffs;

                /* Is the target before or after our jump? */

                if  (ofs > srcPos)
                {
                    /* Compute the positive distance estimate */

                    dif = ofs - srcPos; assert(dif > 0);
#ifdef  DEBUG
                    src = srcPos;
#endif

                    if  (maxOfs < dif) maxOfs = dif;
                }
                else
                {
                    /* Compute the negative distance estimate */

                    dif = tgt->igOffs - srcNeg; assert(dif < 0);
#ifdef  DEBUG
                    src = srcNeg;
#endif

                    if  (minOfs > dif) minOfs = dif;
                }

#ifdef  DEBUG
                if  (verbose)
                {
                    printf("Indirect jump entry: %04X -> %04X (dist=%d)\n", src,
                                                                            tgt->igOffs,
                                                                            dif);
                }
#endif

            }
            while (++jmpTab, --jmpCnt);

            /* The distance should be multiple of instruction size */

            assert((minOfs & 1) == 0);
            assert((maxOfs & 1) == 0);

#ifdef  DEBUG
            if  (verbose)
            {
                if (minOfs < 0) printf("Max. negative distance = %d\n", minOfs);
                if (maxOfs > 0) printf("Max. positive distance = %d\n", maxOfs);

                printf("Base offset: %04X\n", srcOfs);
            }
#endif

            /*
                Compute the total size:

                    2   alignment                    [optional]
                    2   mova  instruction
                    2   load of distance value
                    2   extu  instruction            [optional]
                    2   shift instruction            [optional]
                    2   braf  instruction
                    2   delay slot
                    2   alignment                    [optional]
                    x   jump table
             */

            size = 2 + 2 + 2 + 2;   // mova + mov + braf + delay slot

            /* Add alignment, if necessary */

//            if  (srcOfs & 2)
                size   += 2;

            minOfs -= 8;
            maxOfs += 8;
            /* How big will the table entries need to be? */

            if      (minOfs >=   SCHAR_MIN && maxOfs <=   SCHAR_MAX)
            {
                /* We'll use           signed  byte distances */

                kind = IJ_UNS_I1;
                adrs = 1;
            }
            else if (minOfs >=           0 && maxOfs <=   UCHAR_MAX)
            {
                /* We'll use         unsigned  byte distances */

                kind = IJ_UNS_U1;
                size = size + 2;
                adrs = 1;
            }
            else if (minOfs >= 2*SCHAR_MIN && maxOfs <= 2*SCHAR_MAX)
            {
                /* We'll use shifted   signed byte distances */

                kind = IJ_SHF_I1;
                size = size + 2;
                adrs = 1;
            }
            else if (minOfs >=           0 && maxOfs <= 2*UCHAR_MAX)
            {
                /* We'll use shifted unsigned  byte distances */

                kind = IJ_SHF_U1;
                size = size + 4;
                adrs = 1;
            }
            else if (minOfs >=    SHRT_MIN && maxOfs <=    SHRT_MAX)
            {
                /* We'll use           signed word distances */

                kind = IJ_UNS_I2;
                size = size + 2;
                adrs = 2;
            }
            else if (minOfs >=           0 && maxOfs <=   USHRT_MAX)
            {
                /* We'll use         unsigned word distances */

                kind = IJ_UNS_U2;
                size = size + 4;
                adrs = 2;
            }
            else
            {
                /* We'll use           signed long distances */

                kind = IJ_UNS_I4;
                size = size + 2;
                adrs = 4;
            }

            /* Align the table if necessary */

            srcOfs += size;

//            if  (srcOfs & 2)
//                size += 2;

            /* Remember what kind of of a jump we're planning to use */

            jmp->idjJumpKind = kind;

            /* Total size = size of code + size of table */

            size += roundUp(adrs * jmp->idjTemp.idjCount, INSTRUCTION_SIZE);
            size += 4;

            /* Figure out the size adjustment */

            diff  = jmp->idjCodeSize - size; assert((int)diff >= 0);

            /* Update the code size and adjust the instruction group size */

            jmp  ->idjCodeSize = size;
            jmpIG->igSize     -= diff;


            /* Update offsets of IG's that follow the 1st adjusted one */

            for (ofs = ig1->igOffs;;)
            {
                ofs += ig1->igSize;
                ig1  = ig1->igNext;
                if  (!ig1)
                    break;
                ig1->igOffs = ofs;
            }
#ifdef  DEBUG
            if  (verbose)
            {
                printf("\nInstruction list after an adjustment:\n\n");
                emitDispIGlist(true);
            }
#endif
	}

        /* Update the total code size of the method */

        emitTotalCodeSize = ofs;

        emitCheckIGoffsets();
    }
}

/*****************************************************************************
 *
 *  Returns the base encoding of the given CPU instruction.
 */

inline
unsigned            insCode(instruction ins)
{
    static
    unsigned        insCodes[] =
    {
        #define INST1(id, nm, bd, um, rf, wf, rx, wx, br, i1        ) i1,
        #define INST2(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2    ) i1,
        #define INST3(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2, i3) i1,
        #include "instrSH3.h"
        #undef  INST1
        #undef  INST2
        #undef  INST3
    };

    assert(ins < sizeof(insCodes)/sizeof(insCodes[0]));
    assert((insCodes[ins] != BAD_CODE));

    return  insCodes[ins];
}

/*****************************************************************************
 *
 *  Returns the encoding of the given CPU instruction for the flavor that
 *  takes a single register.
 */

inline
unsigned            insCode_RV(instruction ins, emitRegs reg)
{
    return  insCode(ins) | (reg << 8);
}

/*****************************************************************************
 *
 *  Returns the encoding of the given CPU instruction for the flavor that
 *  takes a single immed and implied R0
 */

inline
unsigned            insCode_IV(instruction ins, int icon)
{
    static
    unsigned        insCodes[] =
    {
        #define INST1(id, nm, bd, um, rf, wf, rx, wx, br, i1        ) 0,
        #define INST2(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2    ) 0, 
        #define INST3(id, nm, bd, um, rf, wf, rx, wx, br, i1, i2, i3) i2,
        #include "instrSH3.h"
        #undef  INST1
        #undef  INST2
        #undef  INST3
    };

    assert(ins < sizeof(insCodes)/sizeof(insCodes[0]));
    assert((insCodes[ins] != BAD_CODE));

    return  insCodes[ins] | (icon & 0xFF);
}

/*****************************************************************************
 *
 *  Returns the encoding of the given CPU instruction for the flavor that
 *  takes a register and integer constant operands.
 */

inline
unsigned            insCode_RV_IV(instruction ins, emitRegs reg, int icon)
{
    assert(icon == (signed char)icon);

    assert(ins == INS_mov_imm || ins == INS_add_imm || ins == INS_mova || ins == INS_xor_imm);

    return  insCode(ins) | (reg << 8) | (icon & 0xFF);
}

/*****************************************************************************
 *
 *  Returns the encoding of the given CPU instruction for the flavor that
 *  takes two register operands.
 */

inline
unsigned            insCode_R1_R2(instruction ins, emitRegs rg1, emitRegs rg2)
{
    return  insCode(ins) | (rg1 << 4) | (rg2 << 8);
}

/*****************************************************************************
 *
 *  Output an instruction that references a register and an indirection
 *  given by "irg+dsp" (if 'rdst' is non-zero, the register is the target).
 */

BYTE    *           emitter::emitOutputRIRD(BYTE *dst, instruction ins,
                                                       emitRegs    reg,
                                                       emitRegs    irg,
                                                       unsigned    dsp,
                                                       bool        rdst)
{
    unsigned        code = insCode(ins);

    assert(dsp < 64);
    assert(dsp % 4 == 0);

    if  (rdst)
    {
        code |= (irg << 4) | (reg << 8) | 0x4000;
    }
    else
    {
        code |= (reg << 4) | (irg << 8);
    }

    return  dst + emitOutputWord(dst, code | dsp >> 2);
}

/*****************************************************************************
 *
 *  Output an instruction that (directly) references a stack frame location
 *  and a register (if 'rdst' is non-zero, the register is the target).
 */

BYTE    *           emitter::emitOutputSV(BYTE *dst, instrDesc *id, bool rdst)
{
    bool            FPbased;

    emitRegs        base;
    unsigned        addr;

    assert(id->idIns == INS_mov_dsp);

    addr = emitComp->lvaFrameAddress(id->idAddr.iiaLclVar.lvaVarNum, &FPbased);

    base = FPbased ? (emitRegs)REG_FPBASE
                   : (emitRegs)REG_SPBASE;

    return  emitOutputRIRD(dst, id->idInsGet(),
                                id->idRegGet(),
                                base,
                                addr + id->idAddr.iiaLclVar.lvaOffset,
                                rdst);
}

/*****************************************************************************
 *
 *  Return the number of bytes of machine code the given instruction will
 *  produce.
 */

size_t              emitter::emitSizeOfJump(instrDescJmp *jmp)
{
    size_t          sz;

    assert(jmp->idInsFmt == IF_LABEL);

    if      (jmp->idjShort)
    {
        sz = INSTRUCTION_SIZE;

        if  (jmp->idjAddBD)
            sz += INSTRUCTION_SIZE;
    }
    else if (jmp->idjMiddle)
    {
        sz = JCC_SIZE_MIDDL;
    }
    else
    {
        sz = emitIsCondJump(jmp) ? JCC_SIZE_LARGE
                                 : JMP_SIZE_LARGE;
    }

    return  sz;
}

/*****************************************************************************
 *
 *  Output a local jump instruction.
 */

BYTE    *           emitter::emitOutputLJ(BYTE *dst, instrDesc *i)
{
    unsigned        srcOffs;
    unsigned        dstOffs;
    int             jmpDist;

    assert(i->idInsFmt == IF_LABEL);

    instrDescJmp *  id  = (instrDescJmp*)i;
    instruction     ins = id->idInsGet();

#ifdef DEBUG

    /* Crate a fake instruction for display purposes */

    instrDescDisp   disp;
    dspJmpInfo      info;

    disp.idInsFmt = IF_DISPINS;
    disp.iddInfo  = &info;
    disp.iddNum   = 0;
    disp.iddId    = id;

#endif

    /* Figure out the distance to the target */

    srcOffs = emitCurCodeOffs(dst);
    dstOffs = id->idAddr.iiaIGlabel->igOffs;
    jmpDist = dstOffs - srcOffs;

    /* Is the jump a forward one and are we scheduling? */

#if SCHEDULER

    if  (emitComp->opts.compSchedCode && jmpDist > 0)
    {
        /* The jump distance might change later */

        emitFwdJumps = true;

        /* Record the target offset and the addr of the distance value */

        id->idjOffs         = dstOffs;
        id->idjTemp.idjAddr = dst;
    }
    else
        id->idjTemp.idjAddr = NULL;

#endif

    /* Is the jump short, medium, or long? */

    if  (id->idjShort)
    {
        /* The distance is computed from after the jump */

        jmpDist -= INSTRUCTION_SIZE * 2;

#ifdef  DEBUG

        if  (id->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
        {
            size_t      blkOffs = id->idjIG->igOffs;

            if  (INTERESTING_JUMP_NUM == 0)
            printf("[3] Jump %u:\n", id->idNum);
//          printf("[3] Jump  block is at %08X\n", blkOffs);
            printf("[3] Jump        is at %08X\n", srcOffs);
            printf("[3] Label block is at %08X\n", dstOffs);
            printf("[3] Jump is from      %08X\n", dstOffs - jmpDist);
            printf("[3] Jump distance  is %04X\n", jmpDist);
        }

        /* The distance better fit in the jump's range */

        size_t      exsz = id->idjAddBD ? INSTRUCTION_SIZE : 0;

        if  (emitIsCondJump(id))
        {
            assert(emitSizeOfJump(id) == JCC_SIZE_SMALL + exsz);
            assert(jmpDist >= JCC_DIST_SMALL_MAX_NEG &&
                   jmpDist <= JCC_DIST_SMALL_MAX_POS);
        }
        else
        {
            assert(emitSizeOfJump(id) == JMP_SIZE_SMALL + exsz);
            assert(jmpDist >= JMP_DIST_SMALL_MAX_NEG &&
                   jmpDist <= JMP_DIST_SMALL_MAX_POS);
        }

#endif

        /* Now issue the instruction */

#ifdef  DEBUG
        if  (emitDispInsExtra)
        {
            emitDispJmpDist  = jmpDist;
            emitDispIns(id, false, dspGCtbls, true, emitCurCodeOffs(dst));
            emitDispInsExtra = false;
        }
#endif

        /* The distance is scaled automatically */

        assert((jmpDist & 1) == 0); jmpDist >>= 1;

        /* What kind of a jump do we have? */

        switch (ins)
        {
        case INS_bra:

            if (jmpDist)/* The distance is a 12-bit number */
                dst += emitOutputWord(dst, insCode(ins) | (jmpDist & 0x0FFF));
            else
                dst += emitOutputWord(dst, insCode(INS_nop));
            break;

        case INS_bsr:

            /* The distance is a 12-bit number */
            dst += emitOutputWord(dst, insCode(ins) | (jmpDist & 0x0FFF));
            break;

        case INS_bt:
        case INS_bts:
        case INS_bf:
        case INS_bfs:

            /* The distance is an 8-bit number */

            dst += emitOutputWord(dst, insCode(ins) | (jmpDist & 0x00FF));
            break;

        default:
            assert(!"unexpected SH-3 jump");
        }

        /* Some jumps need a branch delay slot */

        if  (id->idjAddBD)
        {

#ifdef DEBUG
            disp.idIns = INS_nop;
            dispSpecialIns(&disp, dst);
#endif

            dst += emitOutputWord(dst, insCode(INS_nop));
        }

        return  dst;
    }

    if  (id->idjMiddle)
    {
        instruction     ins;

        /* This is a medium-size jump (it must be a conditional one) */

        assert(emitIsCondJump(id));

        /*
            Generate the following sequence for bt/bf label:

                    bf/bt skip
                    bra   label
                    nop
               skip:

            First reverse the sense of the condition.
         */

        assert(id->idIns == INS_bt  ||
               id->idIns == INS_bts ||
               id->idIns == INS_bf  ||
               id->idIns == INS_bfs);

        switch (id->idIns)
        {
        case INS_bf : ins = INS_bt ; break;
        case INS_bfs: ins = INS_bts; break;
        case INS_bt : ins = INS_bf ; break;
        case INS_bts: ins = INS_bfs; break;

        default:
            assert(!"unexpected medium jump");
        }

        /* Generate (and optionally display) the flipped conditional jump */

#ifdef DEBUG
        disp.iddNum   = 0;
        disp.idIns    = ins;
        info.iijLabel = emitTmpJmpCnt; emitTmpJmpCnt++;
        dispSpecialIns(&disp, dst);
#endif

        dst += emitOutputWord(dst, insCode(ins) | 1);

        /* Update the distance of the unconditional jump */

        jmpDist -= INSTRUCTION_SIZE * 3;

        assert(jmpDist >= JMP_DIST_SMALL_MAX_NEG &&
               jmpDist <= JMP_DIST_SMALL_MAX_POS);

#ifdef DEBUG
        disp.idIns = INS_bra;
        dispSpecialIns(&disp, dst);
#endif

        /* The distance is a 12-bit number */

        dst += emitOutputWord(dst, insCode(INS_bra) | (jmpDist >> 1 & 0x0FFF));

        /* Fill in the branch-delay slot with a nop */

#ifdef DEBUG
        disp.idIns = INS_nop;
        dispSpecialIns(&disp, dst);
#endif

        dst += emitOutputWord(dst, insCode(INS_nop));

        /* Display the "skip" temp label */

#ifdef DEBUG
        disp.idIns = INS_xtrct;  // just a hack to suppress instruction display
        dispSpecialIns(&disp, dst);
#endif

    }
    else
    {
        // long branch
        instruction     ins;

        switch (id->idIns)
        {
        case INS_bf : ins = INS_bt ; break;
        case INS_bfs: ins = INS_bts; break;
        case INS_bt : ins = INS_bf ; break;
        case INS_bra: ins = INS_bf ; break;
        case INS_bts: ins = INS_bfs; break;
        default:
            assert(!"unexpected medium jump");
        }
        

        if (emitIsCondJump(id))
        {
            // take 7 instructions 
            int align = 1;
            
            dst += emitOutputWord(dst, insCode(ins) | 5);
            unsigned code = insCode(INS_mov_PC);
            code |= 0x4000; // load 4 byte constant
            dst += emitOutputWord(dst, code | 1);
            dst += emitOutputWord(dst, insCode(INS_braf));
            dst += emitOutputWord(dst, insCode(INS_nop));

            if  (emitCurCodeOffs(dst) & 2) {
                dst += emitOutputWord(dst, insCode(INS_nop));
                align = 0;
            }

            srcOffs = emitCurCodeOffs(dst);
            jmpDist = dstOffs - srcOffs;
            dst += emitOutputWord(dst, jmpDist & 0xffff);
            dst += emitOutputWord(dst, (jmpDist >> 16) & 0xffff);

            if (align)
                dst += emitOutputWord(dst, insCode(INS_nop));
        }
        else
        {
            // take 6 instructions 
            int align = 1;
            
            unsigned code = insCode(INS_mov_PC);
            code |= 0x4000; // load 4 byte constant
            dst += emitOutputWord(dst, code | 1);
            dst += emitOutputWord(dst, insCode(INS_braf));
            dst += emitOutputWord(dst, insCode(INS_nop));

            if  (emitCurCodeOffs(dst) & 2) {
                dst += emitOutputWord(dst, insCode(INS_nop));
                align = 0;
            }

            srcOffs = emitCurCodeOffs(dst);
            jmpDist = dstOffs - srcOffs;
            dst += emitOutputWord(dst, jmpDist & 0xffff);
            dst += emitOutputWord(dst, (jmpDist >> 16) & 0xffff);

            if (align)
                dst += emitOutputWord(dst, insCode(INS_nop));
        }
    }
    return  dst;
}

/*****************************************************************************
 *
 *  Output an unconditional forward jump to PC+dist.
 */

#undef                       emitOutputFwdJmp

BYTE    *           emitter::emitOutputFwdJmp(BYTE *dst, unsigned    dist,
                                                         bool        isSmall)
{
    assert(isSmall);

#ifdef  DEBUG

    /* Create a fake jump instruction descriptor so that we can display it */

    instrDescJmp    jmp;

    jmp.idIns             = INS_bra;
    jmp.idInsFmt          = IF_LABEL;
    jmp.idAddr.iiaIGlabel = emitDispIG;
    jmp.idjShort          = true;

    if  (disAsm || dspEmit)
    {
        emitDispInsExtra = true;
        emitDispJmpDist  = dist;
        emitDispIns(&jmp, false, dspGCtbls, true, emitCurCodeOffs(dst));
        emitDispInsExtra = false;
    }

#endif

    /* The scaled distance must fit in 12 bits */

    assert(dist < 0x2000);

    /* Output the branch opcode */

    dst += emitOutputWord(dst, insCode(INS_bra) | dist >> 1);

    /* Fill the branch-delay slot with a nop */

#ifdef DEBUG
    if  (disAsm || dspEmit)
    {
        jmp.idIns    = INS_nop;
        jmp.idInsFmt = IF_NONE;
        emitDispIns(&jmp, false, dspGCtbls, true, emitCurCodeOffs(dst));
    }
#endif

    dst += emitOutputWord(dst, insCode(INS_nop));

    return  dst;
}

/*****************************************************************************
 *
 *  Output an indirect jump.
 */

BYTE    *           emitter::emitOutputIJ(BYTE *dst, instrDesc *i)
{
    unsigned        jmpCnt;
    BasicBlock  * * jmpTab;

    unsigned        srcOfs;

    emitIndJmpKinds kind;
    unsigned        dist;
    size_t          asiz;
    int             nops_added = 0;

#ifdef  DEBUG
    size_t          base = emitCurCodeOffs(dst);
#endif

    instrDescJmp  * jmp = (instrDescJmp*)i;
    emitRegs        reg = jmp->idRegGet();

    assert(jmp->idInsFmt == IF_JMP_TAB);

    static
    BYTE            movalDisp[] =
    {
        1,  // IJ_UNS_I1
        2,  // IJ_UNS_U1
        2,  // IJ_SHF_I1
        2,  // IJ_SHF_U1

        1,  // IJ_UNS_I2
        2,  // IJ_UNS_U2

        2,  // IJ_UNS_I4
    };

    #define IJaddrGetSz(kind)    (addrInfo[kind] & 3)
    #define IJaddrIsExt(kind)   ((addrInfo[kind] & 4) != 0)
    #define IJaddrIsShf(kind)   ((addrInfo[kind] & 8) != 0)

    #define IJaddrEntry(size, isext, isshf) (size | (isext*4) | (isshf*8))

    static
    BYTE            addrInfo[] =
    {
        //          size ext shf     kind

        IJaddrEntry(0,   0,  0),    // IJ_UNS_I1
        IJaddrEntry(0,   1,  0),    // IJ_UNS_U1
        IJaddrEntry(0,   0,  1),    // IJ_SHF_I1
        IJaddrEntry(0,   1,  1),    // IJ_SHF_U1

        IJaddrEntry(1,   0,  0),    // IJ_UNS_I2
        IJaddrEntry(1,   1,  0),    // IJ_UNS_U2

        IJaddrEntry(2,   0,  0),    // IJ_UNS_I4
    };

#ifdef  DEBUG

    static
    const   char *  ijkNames[] =
    {
        "UNS_I1",                   // IJ_UNS_I1
        "UNS_U1",                   // IJ_UNS_U1
        "SHF_I1",                   // IJ_SHF_I1
        "SHF_U1",                   // IJ_SHF_U1
        "UNS_I2",                   // IJ_UNS_I2
        "UNS_U2",                   // IJ_UNS_U2
        "UNS_I4",                   // IJ_UNS_I4
    };

#endif

    /* Get hold of the jump kind */

    kind = (emitIndJmpKinds)jmp->idjJumpKind;

#ifdef DEBUG

    /* Crate a fake instruction for display purposes */

    instrDescDisp   disp;
    dspJmpInfo      info;

    disp.idIns    = INS_nop;
    disp.idInsFmt = IF_DISPINS;
    disp.iddInfo  = &info;
    disp.iddNum   = 0;
    disp.iddId    = i;

    info.iijLabel = emitTmpJmpCnt; emitTmpJmpCnt += 2;
    info.iijKind  = kind;

#endif

    /* Figure out the size of each address entry */

    asiz = IJaddrGetSz(kind);

    /* Shift the switch value if necessary */

    if  (asiz)
    {
        instruction     ishf = (asiz == 1) ? INS_shll
                                           : INS_shll2;

#ifdef DEBUG
        info.iijIns         = ishf;
        info.iijInfo.iijReg = reg;
        dispSpecialIns(&disp, dst);
#endif

        dst += emitOutputWord(dst, insCode(ishf) | (reg << 8));
    }
#ifdef DEBUG
    else
    {
        disp.iddNum++;  // no display of shift instruction
    }
#endif

    /* Make sure we're aligned properly */

    dispSpecialIns(&disp, dst);

    if  (emitCurCodeOffs(dst) & 2)
    {
        dst += emitOutputWord(dst, insCode(INS_nop));
        nops_added++;
    }

    /* Generate the "mova.l addr-of-jump-table r0" instruction */

    dist = movalDisp[kind];

    dispSpecialIns(&disp, dst);

    dst += emitOutputWord(dst, insCode(INS_mova) | dist);

    /* Generate "mov.sz @(r0,reg),r0" */

    dispSpecialIns(&disp, dst);

    dst += emitOutputWord(dst, insCode(INS_mov_ix0) | 8 | asiz | (reg << 4));

    /* Generate "extu" if necessary */

    if  (IJaddrIsExt(kind))
    {
        instruction     iext = (asiz == 0) ? INS_extub
                                           : INS_extuw;

#ifdef DEBUG
        info.iijIns         = iext;
        info.iijInfo.iijReg = reg;
        dispSpecialIns(&disp, dst);
#endif

        dst += emitOutputWord(dst, insCode(iext));
    }
#ifdef DEBUG
    else
    {
        disp.iddNum++;  // no display of zero-extend instruction
    }
#endif

    /* Shift the distance if necessary */

    if  (IJaddrIsShf(kind))
    {
        dispSpecialIns(&disp, dst);

        dst += emitOutputWord(dst, insCode(INS_shll));
    }
#ifdef DEBUG
    else
    {
        disp.iddNum++;  // no display of shift instruction
    }
#endif

    // ISSUE: Should we use "jmp @r0" for 32-bit addresses? Makes the code
    // ISSUE: location-dependent, but there is presumably some reason the
    // ISSUE: SHCL compiler does this, no?

    dispSpecialIns(&disp, dst);
    dst += emitOutputWord(dst, insCode(INS_braf));

    /* Fill the delay slot with a "nop" */

    dispSpecialIns(&disp, dst);
    dst += emitOutputWord(dst, insCode(INS_nop));

    /* The jumps are relative to the current point */

    srcOfs = emitCurCodeOffs(dst);
    dispSpecialIns(&disp, dst);

    /* Align the address table */

    dispSpecialIns(&disp, dst);

    if  (emitCurCodeOffs(dst) & 2)
    {
        dst += emitOutputWord(dst, insCode(INS_nop));
        nops_added++;
    }

    /* Output the address table contents */

    jmpCnt = jmp->idjTemp.idjCount;
    jmpTab = jmp->idAddr.iiaBBtable;

    dispSpecialIns(&disp, dst);

    do
    {
        insGroup    *   tgt;
        int             dif;

        /* Get the target IG of the entry and compute distance */

        tgt = (insGroup*)emitCodeGetCookie(*jmpTab); assert(tgt);
        dif = tgt->igOffs - srcOfs;

        /* Shift the distance if necessary */

        if  (IJaddrIsShf(kind))
            dif >>= 1;

#ifdef DEBUG
        disp.iddNum          = 99;
        info.iijTarget       = tgt->igNum;
        info.iijInfo.iijDist = dif;
        dispSpecialIns(&disp, dst);
#endif

        switch (asiz)
        {
        case 0: dst += emitOutputByte(dst, dif); break;
        case 1: dst += emitOutputWord(dst, dif); break;
        case 2: dst += emitOutputLong(dst, dif); break;
        }
    }
    while (++jmpTab, --jmpCnt);

    /* If we have an odd number of byte entries, pad it */

    if  (emitCurCodeOffs(dst) & 1)
    {

#ifdef DEBUG
        disp.iddNum = 19;
        dispSpecialIns(&disp, dst);
#endif

        dst += emitOutputByte(dst, 0);
    }
    while (nops_added < 3)
    {
        dst += emitOutputWord(dst, insCode(INS_nop));
        nops_added++;
    }

    /* Make sure we've generated the expected amount of code */

#ifdef  DEBUG
    if    (emitCurCodeOffs(dst) - base != jmp->idjCodeSize)
        printf("ERROR: Generated %u bytes for '%s' table jump, predicted %u\n", emitCurCodeOffs(dst) - base, ijkNames[kind], jmp->idjCodeSize);
    assert(emitCurCodeOffs(dst) - base == jmp->idjCodeSize);
#endif

    return  dst;
}

/*****************************************************************************
 *
 *  Output a direct (pc-relative) call.
 */

#if SMALL_DIRECT_CALLS

inline
BYTE    *           emitter::emitOutputDC(BYTE *dst, instrDesc *id,
                                                     instrDesc *im)
{
    BYTE    *       srcAddr = emitDirectCallBase(dst);
    BYTE    *       dstAddr;
#ifndef BIRCH_SP2
    dstAddr = emitMethodAddr(im);
#else
    OptPEReader *oper = &((OptJitInfo*)emitComp->info.compCompHnd)->m_PER;
    dstAddr = (BYTE *)oper->m_rgFtnInfo[(unsigned)(id->idAddr.iiaMethHnd)].m_pNative;
#endif
    int             difAddr = dstAddr - srcAddr;

    /* Display the instruction if appropriate */

#ifdef  DEBUG
    if  (emitDispInsExtra)
    {
        emitDispLPaddr   = difAddr;
        emitDispIns(im, false, dspGCtbls, true, dst - emitCodeBlock);
        emitDispInsExtra = false;
    }
#endif

    dst += emitOutputWord(dst, insCode(INS_bsr) | ((difAddr >> 1) & 0x0FFF));
    return dst;
}

#endif

/*****************************************************************************
 *
 *  Append the machine code corresponding to the given instruction descriptor
 *  to the code block at '*dp'; the base of the code block is 'bp', and 'ig'
 *  is the instruction group that contains the instruction. Updates '*dp' to
 *  point past the generated code, and returns the size of the instruction
 *  descriptor in bytes.
 */

size_t              emitter::emitOutputInstr(insGroup  *ig,
                                             instrDesc *id, BYTE **dp)
{
    BYTE    *       dst  = *dp;
    size_t          sz   = sizeof(instrDesc);
    instruction     ins  = id->idInsGet();
    size_t          size = emitDecodeSize(id->idOpSize);

#ifdef  DEBUG

#if     MAX_BRANCH_DELAY_LEN || SMALL_DIRECT_CALLS

    /* Zapped instructions should never reach here */

    assert(ins != INS_ignore);

#endif

    emitDispInsExtra = false;

    if  (disAsm || dspEmit)
    {
        /* Wait to display instructions that display extra info */

        switch (id->idInsFmt)
        {
        case IF_LABEL:
        case IF_RWR_LIT:
        case IF_JMP_TAB:

            /* We'll display the instruction a bit later */

            emitDispInsExtra = true;
            break;

        default:

            /* Display the instruction now */

            emitDispIns(id, false, dspGCtbls, true, emitCurCodeOffs(dst));
            break;
        }
    }

    if  (id->idNum == CGknob)
        BreakIfDebuggerPresent();

#endif

    /* What instruction format have we got? */

    switch (id->idInsFmt)
    {
        unsigned        code;
        size_t          disp;

#if TRACK_GC_REFS

        bool            nrc;

        bool            GCnewv;
        VARSET_TP       GCvars;

        unsigned        gcrefRegs;
        unsigned        byrefRegs;

#endif

#if SMALL_DIRECT_CALLS
        instrDesc   *   im;
#endif

        /********************************************************************/
        /*                        No operands                               */
        /********************************************************************/

    case IF_NONE:

#if TRACK_GC_REFS
        assert(id->idGCrefGet() == GCT_NONE);
#endif

        if (id->idIns != INS_ignore)
            dst += emitOutputWord(dst, insCode(ins));
        break;

        /********************************************************************/
        /*                      Single register                             */
        /********************************************************************/

    case IF_RRD:
    case IF_RWR:
    case IF_RRW:

        dst += emitOutputWord(dst, insCode_RV(ins, id->idRegGet()));
        sz   = TINY_IDSC_SIZE;
        break;

        /********************************************************************/
        /*                    Register and constant                         */
        /********************************************************************/

    case IF_RRD_CNS:
    case IF_RWR_CNS:
    case IF_RRW_CNS:

        assert(emitGetInsSC(id) >= IMMED_INT_MIN);
        assert(emitGetInsSC(id) <= IMMED_INT_MAX);

        if ( id->idIns == INS_cmpeq) {
            dst += emitOutputWord(dst, insCode_IV(ins, emitGetInsSC(id)));
            sz   = emitSizeOfInsDsc(id);
        }
        else {
            dst += emitOutputWord(dst, insCode_RV_IV(ins, id->idRegGet(), emitGetInsSC(id)));
            sz   = emitSizeOfInsDsc(id);
        }
        break;

        /********************************************************************/
        /*                Register and literal pool entry                   */
        /********************************************************************/

    case IF_RWR_LIT:
        {
        unsigned        offs;
        unsigned        base;
        unsigned        dist;

        /* The operand size must be word/long */

        assert(size == 2 || size == 4);

        /* Set the size of the instruction */

        sz = sizeof(instrDescLPR);

#if SMALL_DIRECT_CALLS

        /* Is this a direct (pc-relative) call? */

        if  (ins == INS_bsr)
        {
            /* Remember the first instruction for later */

            im = id;

            /* Switch to what used to be the call instruction */

            id = ((instrDescLPR*)id)->idlCall;

            /* Go process this as a call */

            goto EMIT_CALL;
        }

#endif

        /* The instruction must be "mov @(disp,pc), reg" */

        assert(ins == INS_mov_PC);

        /* Find the appropriate entry for the value in the current LP */

        offs = emitAddLitPoolEntry(emitLitPoolCur, id, true);
        base = emitCurCodeOffs(dst);

        if  (size == 4)
            base &= -4;

#ifdef  DEBUG
        if  (emitDispInsExtra)
        {
            emitDispLPaddr   = offs - base;
            emitDispIns(id, false, dspGCtbls, true, dst - emitCodeBlock);
            emitDispInsExtra = false;
        }
#endif

        /* Compute the distance from the current instruction */

        if (size == 4)
            dist = (offs-base)/size - 1;
        else
            dist = (offs-base)/size - 2;

//      printf("Cur offset = %04X, LP offs = %04X, dist = %04X [%04X]\n", base, offs, offs - base, dist);

        /* Start forming the opcode */

        switch (id->idInfo.idRelocType)
        {
        case 0:
        case 2:
            break;
#ifdef BIRCH_SP2
        case 1: // is a call
//        case 2: // is a ldftn
            {
                //if (!dstAddr)
                {
                    instrDescLPR *lprid = (instrDescLPR *) id;
		    OptJit::SH3DeferredLocation *s = OptJit::SH3DeferredLocation::Create(
                        id->idAddr.iiaMethHnd, ((OptJit *)emitComp)->getCurMethodH(), emitComp);
                
                    s->offset = offs;
                    //if (verbose) printf("this lit pool refs a call/ftninfo at %X in method %x to %x\n", offs, lprid->idAddr.iiaCns, s->methodH);
                    emitCmpHandle->deferLocation(s->methodH, s);
                }

            }
            break;
#endif
        default:
            assert(!"unreached");
        }

        code = insCode(ins);
        if  (size == 4)
            code |= 0x4000;

#if     SCHEDULER

        /* If we're scheduling, the distance might change later */

        if  (emitComp->opts.compSchedCode)
            emitRecordLPref(emitLitPoolCur, dst);

#endif

        assert((dist & 0xff) == dist);
        dst += emitOutputWord(dst, code | (id->idRegGet() << 8) | dist);
        }

        break;

        /********************************************************************/
        /*                        Two registers                             */
        /********************************************************************/

    case IF_RRD_RRD:
    case IF_RWR_RRD:
    case IF_RRW_RRD:
        dst += emitOutputWord(dst, insCode_R1_R2(ins, id->idRg2Get(),
                                                      id->idRegGet()));
        sz   = emitSizeOfInsDsc(id);
        break;

        /********************************************************************/
        /*                         Indirection                              */
        /********************************************************************/

    case IF_IRD:
    case IF_IWR:

        code = insCode(ins) | (id->idAddr.iiaRegAndFlg.rnfReg << 8);

        if  (!(id->idAddr.iiaRegAndFlg.rnfFlg & RNF_AUTOX))
            code |= 0x0004;

        assert(emitEncodeSize(1) == 0);
        assert(emitEncodeSize(2) == 1);
        assert(emitEncodeSize(4) == 2);

        dst += emitOutputWord(dst, code|id->idOpSize);
        break;

        /********************************************************************/
        /*                           Call                                   */
        /********************************************************************/

    case IF_METHOD:

#if SMALL_DIRECT_CALLS
    EMIT_CALL:
#endif

#if TRACK_GC_REFS

        /* Assume we'll be recording this call */

        nrc  = false;

        /* Is this a "fat" call descriptor? */

        if  (id->idInfo.idLargeCall)
        {
            GCnewv    = true;
            GCvars    = ((instrDescCIGCA*)id)->idciGCvars;

            byrefRegs = ((instrDescCIGCA*)id)->idciByrefRegs;
            byrefRegs = emitDecodeCallGCregs(byrefRegs);

            sz        = sizeof(instrDescCIGCA);
        }
        else
        {
            assert(id->idInfo.idLargeCns == false);
            assert(id->idInfo.idLargeDsp == false);

            byrefRegs = emitThisByrefRegs;

            GCnewv    = false;
            sz        = sizeof(instrDesc);
        }

        /* Output the opcode */

#if SMALL_DIRECT_CALLS
        if  (ins == INS_bsr)
        {
            dst  = emitOutputDC(dst, id, im);
        }
        else
#endif
        {
            assert(ins == INS_jsr);

            dst += emitOutputWord(dst, insCode(ins) | (id->idRegGet() << 8));
        }

    DONE_CALL:

        /* Get the new set of live GC ref registers */

        gcrefRegs = emitDecodeCallGCregs(id->idAddr.iiaRegAndFlg.rnfReg);

        /* If the method returns a GC ref, mark the return reg appropriately */

        if       (id->idGCrefGet() == GCT_GCREF)
            gcrefRegs |= RBM_INTRET;
        else if  (id->idGCrefGet() == GCT_BYREF)
            byrefRegs |= RBM_INTRET;

        /* If the GC register set has changed, report the new set */

        if  (gcrefRegs != emitThisGCrefRegs)
            emitUpdateLiveGCregs(GCT_GCREF, gcrefRegs, dst);

        if  (byrefRegs != emitThisByrefRegs)
            emitUpdateLiveGCregs(GCT_BYREF, byrefRegs, dst);

        /* Is there a new set of live GC ref variables? */

#ifdef  DEBUG
        if  (verbose&&0)
        {
            if  (GCnewv)
                printf("[%02u] Gen call GC vars = %016I64X\n", id->idNum, GCvars);
        }
#endif

        if      (GCnewv)
            emitUpdateLiveGCvars(           GCvars, dst);
        else if (!emitThisGCrefVset)
            emitUpdateLiveGCvars(emitThisGCrefVars, dst);

        /* Do we need to record a call location for GC purposes? */

        if  (!emitFullGCinfo && !nrc)
            emitRecordGCcall(dst);

#else

        /* Output the opcode */

#if SMALL_DIRECT_CALLS
        if  (ins == INS_bsr)
        {
            dst  = emitOutputDC(dst, id, im);
        }
        else
#endif
        {
            assert(ins == INS_jsr);

            dst += emitOutputWord(dst, insCode(ins) | (id->idRegGet() << 8));
        }

#endif

        break;

        /********************************************************************/
        /*               Register and various indirections                  */
        /********************************************************************/

    case IF_IRD_RWR_GBR:
    case IF_RRD_IWR_GBR:
        code = emitGetInsSC(id) | insCode(ins) | (id->idOpSize<<8);
        assert((emitGetInsSC(id) & 0xFF) == emitGetInsSC(id));
        dst += emitOutputWord(dst, code);
        sz   = emitSizeOfInsDsc(id);
        break;

    case IF_IRD_RWR:

        assert(ins == INS_mov_ind || ins == INS_fmov_ind);

        code = insCode_R1_R2(ins, id->idRegGet(),
                                  (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg);

        if  (id->idAddr.iiaRegAndFlg.rnfFlg & RNF_AUTOX)
        {
            if (ins == INS_mov_ind)
                code |= 0x0004;
            else
                code |= 0x0001;
        }

        assert(emitEncodeSize(1) == 0);
        assert(emitEncodeSize(2) == 1);
        assert(emitEncodeSize(4) == 2);

        dst += emitOutputWord(dst, code|id->idOpSize);
        break;

    case IF_RRD_IWR:

        assert(ins == INS_mov_ind || ins == INS_fmov_ind);

        code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg,
                                  id->idRegGet());

        if  (id->idAddr.iiaRegAndFlg.rnfFlg & RNF_AUTOX)
        {
            if (ins == INS_mov_ind)
                code |= 0x0004;
            else
                code |= 0x0001;
        }


        assert(emitEncodeSize(1) == 0);
        assert(emitEncodeSize(2) == 1);
        assert(emitEncodeSize(4) == 2);

        if (ins == INS_mov_ind)
            dst += emitOutputWord(dst, code|id->idOpSize|0x4000);
        else
            dst += emitOutputWord(dst, code);

        break;

    case IF_0RD_RRD_XWR:

        assert(ins == INS_mov_ix0);

        code = insCode_R1_R2(ins, id->idRegGet(),
                                  (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg);

        assert(emitEncodeSize(1) == 0);
        assert(emitEncodeSize(2) == 1);
        assert(emitEncodeSize(4) == 2);

        dst += emitOutputWord(dst, code|id->idOpSize);
        break;

    case IF_0RD_XRD_RWR:

        assert(ins == INS_movl_ix0);

        code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg,
                                  id->idRegGet());

        assert(emitEncodeSize(1) == 0);
        assert(emitEncodeSize(2) == 1);
        assert(emitEncodeSize(4) == 2);

        dst += emitOutputWord(dst, code|id->idOpSize|8);
        break;

    case IF_DRD_RWR:

        // read
        assert(ins == INS_mov_dsp);

        disp = emitGetInsDsp(id);
        code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg,
                                  id->idRegGet());

        switch (size)
        {
        case 1: 
            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
            code &= 0xff;
            code |= 0x8400;             
            dst += emitOutputWord(dst, code|disp);
            break;
        case 2: 
            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
            code &= 0xff;
            code |= 0x8500; 
            disp >>= 1; 
            dst += emitOutputWord(dst, code|disp);
            break;
        default:                
            disp >>= 2; 
            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
//            code = insCode_R1_R2(ins, id->idRegGet(), (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg);
            dst += emitOutputWord(dst, code|disp|0x4000);
            break;
        }

        sz   = emitSizeOfInsDsc(id);
        break;

    case IF_RRD_DWR:

        // write
        assert(ins == INS_mov_dsp);

        disp = emitGetInsDsp(id);

        switch (size)
        {
        case 1: 
            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
            code &= 0xff;
            code |= 0x8000;             
            break;
        case 2: 
            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
            code &= 0xff;
            code |= 0x8100; 
            disp >>= 1; 
            break;
        default:                
            disp >>= 2; 
//            code = insCode_R1_R2(ins, (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg, id->idRegGet());
            code = insCode_R1_R2(ins, id->idRegGet(), (emitRegs)id->idAddr.iiaRegAndFlg.rnfReg);
            break;
        }

        dst += emitOutputWord(dst, code|disp);
        sz   = emitSizeOfInsDsc(id);
        break;

        /********************************************************************/
        /*                      Stack-based operand                         */
        /********************************************************************/

    case IF_SRD_RRD:    // stk <- reg
    case IF_SWR_RRD:    // stk <- reg
    case IF_SRW_RRD:    // stk <- reg

        dst = emitOutputSV(dst, id, false);
        break;

    case IF_RRD_SRD:    // reg <- stk
    case IF_RWR_SRD:    // reg <- stk
    case IF_RRW_SRD:    // reg <- stk

        dst = emitOutputSV(dst, id,  true);
        break;

    case IF_AWR_RRD:
        code = insCode_R1_R2(ins, id->idRegGet(), (emitRegs)REG_SPBASE);
        dst += emitOutputWord(dst, code | id->idAddr.iiaCns / sizeof(int));
        break;

        /********************************************************************/
        /*                           Local label                            */
        /********************************************************************/

    case IF_LABEL:

#if TRACK_GC_REFS
        assert(id->idGCrefGet() == GCT_NONE);
#endif
        assert(id->idInfo.idBound);

        dst = emitOutputLJ(dst, id);
        sz  = sizeof(instrDescJmp);
//      printf("jump #%u\n", id->idNum);
        break;

        /********************************************************************/
        /*                          Indirect jump                           */
        /********************************************************************/

    case IF_JMP_TAB:

#if TRACK_GC_REFS
        assert(id->idGCrefGet() == GCT_NONE);
#endif

        dst = emitOutputIJ(dst, id);
        sz  = sizeof(instrDescJmp);
        break;

        /********************************************************************/
        /*                            oops                                  */
        /********************************************************************/

    default:

#ifdef  DEBUG
        printf("unexpected non-x86 instr format %s\n", emitIfName(id->idInsFmt));
        BreakIfDebuggerPresent();
        assert(!"don't know how to encode this instruction");
#endif

        break;
    }

#ifdef	TRANSLATE_PDB
	/* Map the IL instruction group to the native instruction group for PDB translation */

	MapCode( id->idilStart, *dp );
#endif

    /* Make sure some code got generated */

    assert(*dp != dst); *dp = dst;

    return  sz;
}

/*****************************************************************************/
#if     SCHEDULER
/*****************************************************************************
 *
 *  Due to scheduling the offset of a literal pool may change; when that
 *  happens, all references to that literal pool need to be updated to
 *  reflect the new offset by patching the pc-relative value in the
 *  instruction (the distance always gets smaller, one hopes).
 */

void                emitter::emitPatchLPref(BYTE *addr, unsigned oldOffs,
                                                        unsigned newOffs)

{
    unsigned        opcode = *(USHORT *)addr;

    assert((opcode & 0xB000) == insCode(INS_mov_PC));

    /* Is this a 32-bit reference? */

    if  (opcode & 4)
    {
        unsigned        srcOffs;

        /* Recompute the distance (note that the source offset is rounded down) */

        srcOffs = emitCurCodeOffs(addr) & -4;

        /* Replace the distance value in the opcode */

        *(USHORT *)addr  = (opcode & 0xFF00) | ((newOffs - srcOffs) / 4 - 1);
    }
    else
    {
        /* Simply apply the (shifted) distance delta to the offset value */

        *(USHORT *)addr -= (oldOffs - newOffs) / 2;
    }

#ifdef  DEBUG
    if  (verbose)
    {
        unsigned    refSize = (opcode & 4) ? sizeof(int) : sizeof(short);

        printf("Patch %u-bit LP ref at %04X: %04X->%04X [offs=%04X->%04X,dist=%04X->%04X]\n",
            refSize * 8,
            addr - emitCodeBlock,
            opcode,
            *(USHORT *)addr,
            oldOffs,
            newOffs,
            (opcode & 0xFF) * refSize,
            (opcode & 0xFF) * refSize + (newOffs - oldOffs));
    }
#endif

}

/*****************************************************************************/
#endif//SCHEDULER

/*****************************************************************************/
#endif//TGT_SH3
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitpub.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
    /************************************************************************/
    /*       Overall emitter control (including startup and shutdown)       */
    /************************************************************************/

    static
    void            emitInit();
    static
    void            emitDone();

    void            emitBegCG(Compiler   *  comp,
                              COMP_HANDLE   cmpHandle);
    void            emitEndCG();

    void            emitBegFN(bool EBPframe, size_t lclSize, size_t maxTmpSize);
    void            emitEndFN();

    size_t          emitEndCodeGen(Compiler *comp,
                                   bool      contTrkPtrLcls,
                                   bool      fullyInt,
                                   bool      fullPtrMap,
                                   bool      returnsGCr,
                                   unsigned *prologSize,
                                   unsigned *epilogSize, void **codeAddr,
                                                         void **consAddr,
                                                         void **dataAddr);

    /************************************************************************/
    /*                      Method prolog and epilog                        */
    /************************************************************************/

    void            emitBegEpilog();
    void            emitEndEpilog(bool last);
#if!TGT_RISC
    void            emitDefEpilog(BYTE *codeAddr, size_t codeSize);
#endif

    bool            emitHasEpilogEnd();
    unsigned        emitGetEpilogCnt();
    size_t          emitGenEpilogLst(size_t (*fp)(void *, unsigned),
                                     void    *cp);

    void            emitBegProlog();
    size_t          emitSetProlog();
    void            emitEndProlog();

    /************************************************************************/
    /*           Record a code position and later convert it to offset      */
    /************************************************************************/

    void    *       emitCurBlock ();
    unsigned        emitCurOffset();

    size_t          emitCodeOffset(void *blockPtr, unsigned codeOffs);

    /************************************************************************/
    /*                      Display source line information                 */
    /************************************************************************/

#ifdef  DEBUG
    void            emitRecordLineNo(int lineno);
#endif

    /************************************************************************/
    /*                   Output target-independent instructions             */
    /************************************************************************/

    void            emitIns_J(instruction ins,
                              bool        except,
                              bool        moveable,
                              BasicBlock *dst);

#if SCHEDULER
    void            emitIns_SchedBoundary();
#endif

    /************************************************************************/
    /*                   Emit initialized data sections                     */
    /************************************************************************/

    unsigned        emitDataGenBeg (size_t        size,
                                    bool          readOnly,
                                    bool          codeLtab);

    void            emitDataGenData(unsigned      offs,
                                    const void *  data,
                                    size_t        size);
    void            emitDataGenData(unsigned      offs,
                                    BasicBlock *  label);

    void            emitDataGenEnd();

    size_t          emitDataSize(bool readOnly);

    /************************************************************************/
    /*                   Emit PDB offset translation information            */
    /************************************************************************/

#ifdef	TRANSLATE_PDB
	static void			SetILBaseOfCode ( BYTE    *pTextBase );
	static void			SetILMethodBase ( BYTE *pMethodEntry );
	static void			SetILMethodStart( BYTE  *pMethodCode );
	static void			SetImgBaseOfCode( BYTE    *pTextBase );
	
	void 				SetIDBaseToProlog();
	void				SetIDBaseToOffset( long methodOffset );

	static void			DisablePDBTranslation();
	static bool			IsPDBEnabled();

	static void			InitTranslationMaps( long ilCodeSize );
	static void			DeleteTranslationMaps();
	static void			InitTranslator(	PDBRewriter *pPDB,					// PDB translator object to initialize
										int *rgSecMap,						// use PDB isect as index to obtain new isect (1-based)
										IMAGE_SECTION_HEADER **rgpHeader,	// array of pointers to the PE section headers
										int numSections );					// number of sections
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emittyp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EMITTYP_H_
#define _EMITTYP_H_
/*****************************************************************************/

struct  emitbase;

#if     TGT_x86

struct  emitX86;
typedef emitX86 emitter;

#elif   TGT_SH3

struct  emitSH3;
typedef emitSH3 emitter;

#elif   TGT_MIPS32

struct  emitMIPS;
typedef emitMIPS emitter;

#elif   TGT_ARM

struct  emitARM;
typedef emitARM emitter;

#elif   TGT_PPC

struct  emitPPC;
typedef emitPPC emitter;

#else

#error  Unexpected target

#endif

/*****************************************************************************/
#endif//_EMITTYP_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\error.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _ERROR_H_
#define _ERROR_H_
/*****************************************************************************/

/*****************************************************************************/
#include <setjmp.h>
/*****************************************************************************/

#undef  JVC_ERR
#undef  JVC_WR1
#undef  JVC_WRN
#define JVC_ERR(name, lvl, str)  name,
#define JVC_WR1(name, lvl, str)  name, WRNfirstWarn = name,
#define JVC_WRN(name, lvl, str)  name,
enum    errors
{
    #include "errors.h"
};
#undef  JVC_ERR
#undef  JVC_WR1
#undef  JVC_WRN

/*****************************************************************************/
#if TRAP_VIA_SETJMP
/*****************************************************************************/

 // WARNING. LONGJUMP implmentation uses a global varaibel g_currentErrorTrap
 // THIS IS NOT THREADSAFE!!!

struct  errTrapDesc
{
    errTrapDesc *   etdPrev;
    jmp_buf         etdJmpBuf;
};

extern  errTrapDesc *   g_currentErrorTrap;

#define                 setErrorTrap()                                      \
    errTrapDesc __trap;   bool __isFinally = false;                         \
                                                                            \
    __trap.etdPrev    = g_currentErrorTrap;                                 \
                        g_currentErrorTrap = &__trap;                       \
                                                                            \
    int  __errc = setjmp(__trap.etdJmpBuf);                                 \
    if (__errc == 0)                                                        \
    {

#define                 impErrorTrap()                                      \
        g_currentErrorTrap = __trap.etdPrev;                                \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        g_currentErrorTrap = __trap.etdPrev;

#define                 impJitErrorTrap   impErrorTrap

#define                 finallyErrorTrap()                                  \
        g_currentErrorTrap = __trap.etdPrev;                                \
        __isFinally = true;                                                 \
    }                                                                       \
    {

#define                 endErrorTrap()                                      \
    if (__isFinally) rstErrorTrap();     /* propage the error */            \
    }

#define                 jmpErrorTrap(errCode)                               \
                                                                            \
    longjmp(g_currentErrorTrap->etdJmpBuf, errCode)

#define                 rstErrorTrap()                                      \
                                                                            \
    longjmp(g_currentErrorTrap->etdJmpBuf, __errc)


/*****************************************************************************/
#else   // !TRAP_VIA_SETJMP
/*****************************************************************************/

extern  int             __filter  (int   exceptCode, void *exceptInfo, int *errCode);

        // Only catch JIT internal errors (will not catch EE generated Errors)
extern  int             __JITfilter  (int   exceptCode, void *exceptInfo, int *errCode);

extern  void            __JITraiseErr(int errCode);

#define                 setErrorTrap()                                      \
    int  __errc = ERRinternal;                                              \
    __try                                                                   \
    {

        // Catch only JitGeneratedErrors
#define                 impJitErrorTrap()                                   \
    }                                                                       \
    __except(__JITfilter(_exception_code(), _exception_info(), &__errc))    \
    {


        // Catch all errors (including recoverable ones from the EE)
#ifdef NOT_JITC
#define                 impErrorTrap(compHnd)                               \
    }                                                                       \
    __except(compHnd->canHandleException(GetExceptionInformation()))            \
    {
#else
#define impErrorTrap(compHnd) impJitErrorTrap()
#endif

#define                 endErrorTrap()                                      \
    }                                                                       \

#define                 jmpErrorTrap(errCode)                               \
    __JITraiseErr(errCode);

#define                 rstErrorTrap()                                      \
    __JITraiseErr(__errc);

#define                 finallyErrorTrap()                                  \
    }                                                                       \
    __finally                                                               \
    {


/*****************************************************************************/
#endif  // !TRAP_VIA_SETJMP
/*---------------------------------------------------------------------------*/

extern  void    _cdecl  warn (unsigned errNum, ...);
extern  void    _cdecl  error(unsigned errNum, ...);
extern  void    _cdecl  fatal(unsigned errNum, ...);

extern  unsigned        ErrorCount;
extern  const   char *  ErrorSrcf;

/*****************************************************************************
 *
 *  The following is used to temporarily disable error messages.
 */

extern  unsigned        ErrorMssgDisabled;

inline  void            disableErrorMessages()
{
    ErrorMssgDisabled++;
}

inline  void             enableErrorMessages()
{
    ErrorMssgDisabled--;
}

/*****************************************************************************/
#endif
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emittgt.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EMITTGT_H_
#define _EMITTGT_H_
/*****************************************************************************/

#if !   TGT_IA64

enum    emitRegs
{
    #if     TGT_x86
    #define REGDEF(name, rnum, mask, byte)  SR_##name = rnum,
    #include "register.h"
    #undef  REGDEF
    #endif

    #if     TGT_SH3
    #define REGDEF(name, strn, rnum, mask)  SR_##name = rnum,
    #include "regSH3.h"
    #undef  REGDEF
    #endif

    #if     TGT_MIPS32
    #define REGDEF(name, strn, rnum, mask)  SR_##name = rnum,
    #include "regMIPS.h"
    #undef  REGDEF
    #endif

    #if     TGT_ARM
    #define REGDEF(name, strn, rnum, mask)  SR_##name = rnum,
    #include "regARM.h"
    #undef  REGDEF
    #endif

    #if     TGT_PPC
    #define REGDEF(name, strn, rnum, mask)  SR_##name = rnum,
    #include "regPPC.h"
    #undef  REGDEF
    #endif

    SR_COUNT,
    SR_NA = SR_COUNT
};

enum    emitRegMasks
{
    #if     TGT_x86
    #define REGDEF(name, rnum, mask, byte)  SRM_##name = mask,
    #include "register.h"
    #undef  REGDEF
    SRM_BYTE_REGS = (SRM_EAX|SRM_EBX|SRM_ECX|SRM_EDX)
    #define SRM_INTRET  SRM_EAX
    #endif

    #if     TGT_SH3
    #define REGDEF(name, strn, rnum, mask)  SRM_##name = mask,
    #include "regSH3.h"
    #undef  REGDEF
    #define SRM_INTRET  SRM_r00
    #endif

    #if     TGT_MIPS32
    #define REGDEF(name, strn, rnum, mask)  SRM_##name = mask,
    #include "regMIPS.h"
    #undef  REGDEF
    #define SRM_INTRET  SRM_r00
    #endif

    #if     TGT_ARM
    #define REGDEF(name, strn, rnum, mask)  SRM_##name = mask,
    #include "regARM.h"
    #undef  REGDEF
    #define SRM_INTRET  SRM_r00
    #endif

    #if     TGT_PPC
    #define REGDEF(name, strn, rnum, mask)  SRM_##name = mask,
    #include "regPPC.h"
    #undef  REGDEF
    #define SRM_INTRET  SRM_r00
    #endif
};

#endif

/*****************************************************************************
 *
 *  Define any target-specific flags that get passed to the various emit
 *  functions.
 */

#if     TGT_SH3

#define AIF_MOV_IND_AUTOX   0x01        // @reg+ or @-reg

#endif

/*****************************************************************************
 *
 *  Define the various indirect jump types supported for the given target.
 */

#if     TGT_SH3

enum    emitIndJmpKinds
{
    IJ_UNS_I1,           //   signed, unshifted  8-bit distance
    IJ_UNS_U1,           // unsigned, unshifted  8-bit distance
    IJ_SHF_I1,           //   signed,   shifted  8-bit distance
    IJ_SHF_U1,           // unsigned,   shifted  8-bit distance

    IJ_UNS_I2,           //   signed, unshifted 16-bit distance
    IJ_UNS_U2,           // unsigned, unshifted 16-bit distance

    IJ_UNS_I4,           // unsigned, unshifted 32-bit distance
};

#elif TGT_MIPS32

enum    emitIndJmpKinds
{
    IJ_UNS_I1,           //   signed, unshifted  8-bit distance
    IJ_SHF_I1,           //   signed,   shifted  8-bit distance

    IJ_UNS_I2,           //   signed, unshifted 16-bit distance
    IJ_SHF_I2,           // unsigned, unshifted 16-bit distance

    IJ_UNS_I4,           // unsigned, unshifted 32-bit distance
};

#elif TGT_PPC // @TODO: Don't be a copycat

enum    emitIndJmpKinds
{
    IJ_UNS_I1,           //   signed, unshifted  8-bit distance
    IJ_SHF_I1,           //   signed,   shifted  8-bit distance

    IJ_UNS_I2,           //   signed, unshifted 16-bit distance
    IJ_SHF_I2,           // unsigned, unshifted 16-bit distance

    IJ_UNS_I4,           // unsigned, unshifted 32-bit distance
};

#elif TGT_ARM

enum    emitIndJmpKinds
{
    IJ_UNS_I1,           //   signed, unshifted  8-bit distance
    IJ_UNS_U1,           // unsigned, unshifted  8-bit distance
    IJ_SHF_I1,           //   signed,   shifted  8-bit distance
    IJ_SHF_U1,           // unsigned,   shifted  8-bit distance

    IJ_UNS_I2,           //   signed, unshifted 16-bit distance
    IJ_UNS_U2,           // unsigned, unshifted 16-bit distance
    IJ_SHF_I2,           // unsigned, unshifted 16-bit distance

    IJ_UNS_I4,           // unsigned, unshifted 32-bit distance
};
#endif

/*****************************************************************************
 *
 *  Different targets needs to store additonal varieties of values in
 *  the instruction descriptor's "idAddr" union. These should all be
 *  defined here and bound to the "ID_TGT_DEP_ADDR" macro, which is
 *  invoked within the union.
 */

/*****************************************************************************/
#if     TGT_x86
/*****************************************************************************/

struct          emitAddrMode
{
    BYTE            amBaseReg;
    BYTE            amIndxReg;
    short           amDisp :14;
#define AM_DISP_BIG_VAL   (-(1<<13  ))
#define AM_DISP_MIN       (-(1<<13-1))
#define AM_DISP_MAX       (+(1<<13-1))
    unsigned short  amScale :2;         // 0=*1 , 1=*2 , 2=*4 , 3=*8
};

#define ID_TGT_DEP_ADDR                 \
                                        \
    emitAddrMode    iiaAddrMode;

/*****************************************************************************/
#elif   TGT_SH3
/*****************************************************************************/

struct          emitRegNflags
{
    unsigned short  rnfFlg;             // see RNF_xxxx below
    #define RNF_AUTOX       0x0001      // auto-index addressing mode

    unsigned short  rnfReg;
};

#define ID_TGT_DEP_ADDR                 \
                                        \
    emitRegNflags   iiaRegAndFlg;

/*****************************************************************************/
#elif   TGT_IA64
/*****************************************************************************/

#define ID_TGT_DEP_ADDR

/*****************************************************************************/
#elif   TGT_MIPS32
    #define ID_TGT_DEP_ADDR
#elif   TGT_ARM
    #define ID_TGT_DEP_ADDR
#elif   TGT_PPC
    #define ID_TGT_DEP_ADDR
#else
/*****************************************************************************/
#error  Unexpected target
/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
#endif//_EMITTGT_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitx86.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
    /************************************************************************/
    /*         Routines that compute the size of / encode instructions      */
    /************************************************************************/

    struct CnsVal
    {
        long cnsVal;
#ifdef RELOC_SUPPORT
        bool cnsReloc;
#endif
    };

    size_t          emitInsSize   (unsigned   code);
    size_t          emitInsSizeRM (instruction ins);
    size_t          emitInsSizeSV (unsigned   code, int var, int dsp);
    size_t          emitInsSizeSV (instrDesc * id,  int var, int dsp, int val);
    size_t          emitInsSizeRR (instruction ins);
    size_t          emitInsSizeAM (instrDesc * id,  unsigned code);
    size_t          emitInsSizeAM (instrDesc * id,  unsigned code, int val);
    size_t          emitInsSizeCV (instrDesc * id,  unsigned code);
    size_t          emitInsSizeCV (instrDesc * id,  unsigned code, int val);

    BYTE    *       emitOutputAM  (BYTE *dst, instrDesc *id, unsigned code, 
                                                             CnsVal * addc = NULL);
    BYTE    *       emitOutputSV  (BYTE *dst, instrDesc *id, unsigned code,
                                                             CnsVal * addc = NULL);
    BYTE    *       emitOutputCV  (BYTE *dst, instrDesc *id, unsigned code,
                                                             CnsVal * addc = NULL);

    BYTE    *       emitOutputR   (BYTE *dst, instrDesc *id);
    BYTE    *       emitOutputRI  (BYTE *dst, instrDesc *id);
    BYTE    *       emitOutputRR  (BYTE *dst, instrDesc *id);
    BYTE    *       emitOutputIV  (BYTE *dst, instrDesc *id);

    BYTE    *       emitOutputLJ  (BYTE *dst, instrDesc *id);

    /************************************************************************/
    /*             Debug-only routines to display instructions              */
    /************************************************************************/

#ifdef  DEBUG

    const   char *  emitFPregName   (unsigned       reg,
                                     bool           varName = true);

    void            emitDispEpilog  (instrDesc *id, unsigned offs);

    void            emitDispAddrMode(instrDesc *id, bool noDetail = false);
    void            emitDispShift   (instruction ins, int cnt = 0);

    void            emitDispIns     (instrDesc *id, bool isNew,
                                                    bool doffs,
                                                    bool asmfm, unsigned offs = 0);

#endif

    /************************************************************************/
    /*  Private members that deal with target-dependent instr. descriptors  */
    /************************************************************************/

private:

    struct          instrDescAmdCns : instrDesc     // large addrmode disp + cons
    {
        long            idacAmdVal;
        long            idacCnsVal;
    };

    struct          instrDescCDGCA  : instrDesc     // direct call with ...
    {
        VARSET_TP       idcdGCvars;                 // ... updated GC vars or
        unsigned        idcdByrefRegs;              // ... byref registers
        int             idcdArgCnt;                 // ... lots of args    or (<0 ==> caller pops args)
    };

    instrDescAmd   *emitAllocInstrAmd    (emitAttr attr)
    {
        return  (instrDescAmd   *)emitAllocInstr(sizeof(instrDescAmd   ), attr);
    }

    instrDescAmdCns*emitAllocInstrAmdCns (emitAttr attr)
    {
        return  (instrDescAmdCns*)emitAllocInstr(sizeof(instrDescAmdCns), attr);
    }

    instrDescCDGCA *emitAllocInstrCDGCA  (emitAttr attr)
    {
        return  (instrDescCDGCA *)emitAllocInstr(sizeof(instrDescCDGCA ), attr);
    }

    instrDesc      *emitNewInstrAmd     (emitAttr attr, int dsp);
    instrDesc      *emitNewInstrAmdCns  (emitAttr attr, int dsp, int cns);

    instrDesc      *emitNewInstrCallDir (int        argCnt,
#if TRACK_GC_REFS
                                         VARSET_TP  GCvars,
                                         unsigned   byrefRegs,
#endif
                                         int        retSize);

    instrDesc      *emitNewInstrCallInd( int        argCnt,
                                         int        disp,
#if TRACK_GC_REFS

                                         VARSET_TP  GCvars,
                                         unsigned   byrefRegs,
#endif
                                         int        retSize);

    void            emitGetInsCns   (instrDesc *id, CnsVal *cv);
    int             emitGetInsAmdCns(instrDesc *id, CnsVal *cv);
    void            emitGetInsDcmCns(instrDesc *id, CnsVal *cv);
    int             emitGetInsAmdAny(instrDesc *id);
    int             emitGetInsCDinfo(instrDesc *id);

    size_t          emitSizeOfInsDsc(instrDescAmd    *id);
    size_t          emitSizeOfInsDsc(instrDescAmdCns *id);

    /************************************************************************/
    /*               Private helpers for instruction output                 */
    /************************************************************************/

private:

    insFormats      emitInsModeFormat(instruction ins, insFormats base,
                                                       insFormats FPld,
                                                       insFormats FPst);

    void            emitFinalizeIndJumps(){}

    /*****************************************************************************
    *
    *  Convert between an index scale in bytes to a smaller encoding used for
    *  storage in instruction descriptors.
    */

    inline
    unsigned           emitEncodeScale(size_t scale)
    {
        assert(scale == 1 || scale == 2 || scale == 4 || scale == 8);
        
        return  (unsigned) emitSizeEnc[scale-1];
    }

    inline
    size_t            emitDecodeScale(unsigned ensz)
    {
        assert(ensz < 4);

        return  (size_t) emitter::emitSizeDec[ensz];
    }


    /************************************************************************/
    /*           The public entry points to output instructions             */
    /************************************************************************/

public:

    void            emitIns        (instruction ins);

    void            emitIns_I      (instruction ins,
                                    emitAttr    attr,
                                    int         val
#ifdef  DEBUG
                                  , bool        strlit = false
#endif
                                   );

    void            emitIns_R      (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    reg);

    void            emitIns_C      (instruction  ins,
                                    emitAttr     attr,
                                    FIELD_HANDLE fdlHnd,
                                    int          offs);

    void            emitIns_R_I    (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    reg,
                                    int         val);

    void            emitIns_R_MP   (instruction   ins,
                                    emitAttr      attr,
                                    emitRegs      reg,
                                    METHOD_HANDLE methHnd);

    void            emitIns_R_R    (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    reg1,
                                    emitRegs    reg2);

    void            emitIns_R_R_I  (instruction ins,
                                    emitRegs    reg1,
                                    emitRegs    reg2,
                                    int         ival);

    void            emitIns_S      (instruction ins,
                                    emitAttr    attr,
                                    int         varx,
                                    int         offs);

    void            emitIns_S_R    (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    int         varx,
                                    int         offs);

    void            emitIns_R_S    (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    int         varx,
                                    int         offs);

    void            emitIns_S_I    (instruction ins,
                                    emitAttr    attr,
                                    int         varx,
                                    int         offs,
                                    long        val);

    void            emitIns_R_C    (instruction  ins,
                                    emitAttr     attr,
                                    emitRegs     reg,
                                    FIELD_HANDLE fdlHnd,
                                    int          offs);

    void            emitIns_C_R    (instruction  ins,
                                    emitAttr     attr,
                                    FIELD_HANDLE fdlHnd,
                                    emitRegs     reg,
                                    int          offs);

    void            emitIns_C_I    (instruction  ins,
                                    emitAttr     attr,
                                    FIELD_HANDLE fdlHnd,
                                    int          offs,
                                    int          val);

    void            emitIns_IJ     (emitAttr    attr,
				    emitRegs    reg,
                                    unsigned    base,
                                    unsigned    offs);

    void            emitIns_I_AR   (instruction ins,
                                    emitAttr    attr,
                                    int         val,
                                    emitRegs    reg,
                                    int         offs,
                                    int         memCookie = 0,
                                    void *      clsCookie = NULL);

    void            emitIns_R_AR   (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    int         offs,
                                    int         memCookie = 0,
                                    void *      clsCookie = NULL);

    void            emitIns_AR_R   (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    int         offs,
                                    int         memCookie = 0,
                                    void *      clsCookie = NULL);

    void            emitIns_I_ARR  (instruction ins,
                                    emitAttr    attr,
                                    int         val,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    int         disp);

    void            emitIns_R_ARR  (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    int         disp);

    void            emitIns_ARR_R  (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    int         disp);

    void            emitIns_I_ARX  (instruction ins,
                                    emitAttr    attr,
                                    int         val,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_R_ARX  (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_ARX_R  (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    emitRegs    rg2,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_I_AX   (instruction ins,
                                    emitAttr    attr,
                                    int         val,
                                    emitRegs    reg,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_R_AX   (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_AX_R   (instruction ins,
                                    emitAttr    attr,
                                    emitRegs    ireg,
                                    emitRegs    reg,
                                    unsigned    mul,
                                    int         disp);

    void            emitIns_F_F0   (instruction ins,
                                    unsigned    fpreg);

    void            emitIns_F0_F   (instruction ins,
                                    unsigned    fpreg);

#if!SCHEDULER
#define scAddIns_J(jmp, xcpt, move, dst) scAddIns_J(jmp, dst)
#endif

    enum EmitCallType
    {
        EC_FUNC_TOKEN,          //   Direct call to a helper/static/nonvirtual/global method
        EC_FUNC_TOKEN_INDIR,    // Indirect call to a helper/static/nonvirtual/global method
        EC_FUNC_ADDR,           // Direct call to an absolute address

        EC_FUNC_VIRTUAL,        // Call to a virtual method (using the vtable)
        EC_INDIR_R,             // Indirect call via register
        EC_INDIR_SR,            // Indirect call via stack-reference (local var)
        EC_INDIR_C,             // Indirect call via static class var
        EC_INDIR_ARD,           // Indirect call via an addressing mode

        EC_COUNT
    };

    void            emitIns_Call   (EmitCallType    callType,
                                    void*           callVal,
                                    int             argSize,
                                    int             retSize,
                                    VARSET_TP       ptrVars,
                                    unsigned        gcrefRegs,
                                    unsigned        byrefRegs,
                                    emitRegs        ireg = SR_NA,
                                    emitRegs        xreg = SR_NA,
                                    unsigned        xmul = 0,
                                    int             disp = 0,
                                    bool            isJump = false);

#ifdef  RELOC_SUPPORT

    BYTE* getCurrentCodeAddr(BYTE* codeBuffPtr);

    class X86deferredCall : public IDeferredLocation
    {
      private:
          METHOD_HANDLE   m_mh;
          unsigned *      m_dest;
          BYTE *          m_srcAddr;
		  COMP_HANDLE	  m_cmp;
      
      public:

          X86deferredCall (COMP_HANDLE cmp, METHOD_HANDLE mh, BYTE* dest, BYTE* srcAddr)
             : m_cmp(cmp), m_mh(mh), m_dest((unsigned*)dest), m_srcAddr(srcAddr) {}

          virtual void  applyLocation();

          static X86deferredCall* create(COMP_HANDLE cmp, METHOD_HANDLE methHnd, 
                                         BYTE* dest, BYTE* srcAddr)
          {
              // if srcAddr is zero then this is a absolute address, not pcrel
              return new X86deferredCall(cmp, methHnd, dest, srcAddr);
          }

    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\emitx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                             emitX86.cpp                                   XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/
#if     TGT_x86     // this entire file is used only for targetting the x86
/*****************************************************************************/

#include "alloc.h"
#include "instr.h"
#include "target.h"
#include "emit.h"

/*****************************************************************************/

regMaskSmall        emitter::emitRegMasks[] =
{
    #define REGDEF(name, rnum, mask, byte) mask,
    #include "register.h"
    #undef  REGDEF
};


/*****************************************************************************
 *
 *  Record a non-empty stack (this may only happen at a label).
 */

void                emitter::emitMarkStackLvl(size_t stackLevel)
{
    assert((int)stackLevel   >= 0);
    assert(emitCurStackLvl     == 0);
    assert(emitCurIG->igStkLvl == 0);

    assert(emitCurIGfreeNext == emitCurIGfreeBase);
    assert(stackLevel && stackLevel % sizeof(int) == 0);

    emitCurStackLvl = emitCurIG->igStkLvl = stackLevel;

    if (emitMaxStackDepth < emitCurStackLvl)
        emitMaxStackDepth = emitCurStackLvl;
}

/*****************************************************************************
 *
 *  Get hold of the address mode displacement value for an indirect call.
 */

inline
int                 emitter::emitGetInsCIdisp(instrDesc *id)
{
    if  (id->idInfo.idLargeCall)
    {
        return  ((instrDescCIGCA*)id)->idciDisp;
    }
    else
    {
        assert(id->idInfo.idLargeDsp == false);
        assert(id->idInfo.idLargeCns == false);

        return  id->idAddr.iiaAddrMode.amDisp;
    }
}

/*****************************************************************************
 *
 *  Use the specified code bytes as the epilog sequence.
 */

void                emitter::emitDefEpilog(BYTE *codeAddr, size_t codeSize)
{
    memcpy(emitEpilogCode, codeAddr, codeSize);
           emitEpilogSize      =     codeSize;

#ifdef  DEBUG
    emitHaveEpilog = true;
#endif

}

/*****************************************************************************
 *
 *  Call the specified function pointer for each epilog block in the current
 *  method with the epilog's relative code offset. Returns the sum of the
 *  values returned by the callback.
 */

size_t              emitter::emitGenEpilogLst(size_t (*fp)(void *, unsigned),
                                              void    *cp)
{
    instrDescCns *  id;
    size_t          sz;

    for (id = emitEpilogList, sz = 0; id; id = id->idAddr.iiaNxtEpilog)
    {
        assert(id->idInsFmt == IF_EPILOG);

        sz += fp(cp, id->idcCnsVal);
    }

    return  sz;
}

/*****************************************************************************
 *
 *  Initialize the table used by emitInsModeFormat().
 */

BYTE                emitter::emitInsModeFmtTab[] =
{
    #define INST0(id, nm, fp, um, rf, wf, ss, mr                ) um,
    #define INST1(id, nm, fp, um, rf, wf, ss, mr                ) um,
    #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            ) um,
    #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        ) um,
    #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) um,
    #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) um,
    #include "instrs.h"
    #undef  INST0
    #undef  INST1
    #undef  INST2
    #undef  INST3
    #undef  INST4
    #undef  INST5
};

#ifdef  DEBUG
unsigned            emitter::emitInsModeFmtCnt = sizeof(emitInsModeFmtTab)/
                                                 sizeof(emitInsModeFmtTab[0]);
#endif

/*****************************************************************************
 *
 *  A version of scInsModeFormat() that handles floating-point instructions.
 */

emitter::insFormats   emitter::emitInsModeFormat(instruction ins, insFormats base,
                                                                  insFormats FPld,
                                                                  insFormats FPst)
{
    if  (Compiler::instIsFP(ins))
    {
        assert(IF_TRD_SRD + 1 == IF_TWR_SRD);
        assert(IF_TRD_SRD + 2 == IF_TRW_SRD);

        assert(IF_TRD_MRD + 1 == IF_TWR_MRD);
        assert(IF_TRD_MRD + 2 == IF_TRW_MRD);

        assert(IF_TRD_ARD + 1 == IF_TWR_ARD);
        assert(IF_TRD_ARD + 2 == IF_TRW_ARD);

        switch (ins)
        {
        case INS_fst:
        case INS_fstp:
        case INS_fistp:
        case INS_fistpl:
            return  (insFormats)(FPst  );

        case INS_fld:
        case INS_fild:
            return  (insFormats)(FPld+1);

        case INS_fcomp:
        case INS_fcompp:
            return  (insFormats)(FPld  );

        default:
            return  (insFormats)(FPld+2);
        }
    }
    else
    {
        return  emitInsModeFormat(ins, base);
    }
}

/*****************************************************************************
 *
 *  Returns the base encoding of the given CPU instruction.
 */

inline
unsigned            insCode(instruction ins)
{
    static
    unsigned        insCodes[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                ) mr,
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                ) mr,
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            ) mr,
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        ) mr,
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) mr,
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) mr,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodes)/sizeof(insCodes[0]));
    assert((insCodes[ins] != BAD_CODE));

    return  insCodes[ins];
}

/*****************************************************************************
 *
 *  Returns the "[r/m], 32-bit icon" encoding of the given CPU instruction.
 */

inline
unsigned            insCodeMI(instruction ins)
{
    static
    unsigned        insCodesMI[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            ) mi,
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        ) mi,
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) mi,
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) mi,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodesMI)/sizeof(insCodesMI[0]));
    assert((insCodesMI[ins] != BAD_CODE));

    return  insCodesMI[ins];
}

/*****************************************************************************
 *
 *  Returns the "reg, [r/m]" encoding of the given CPU instruction.
 */

inline
unsigned            insCodeRM(instruction ins)
{
    static
    unsigned        insCodesRM[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            )
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        ) rm,
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) rm,
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) rm,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodesRM)/sizeof(insCodesRM[0]));
    assert((insCodesRM[ins] != BAD_CODE));

    return  insCodesRM[ins];
}

/*****************************************************************************
 *
 *  Returns the "AL/AX/EAX, imm" accumulator encoding of the given instruction.
 */

inline
unsigned            insCodeACC(instruction ins)
{
    static
    unsigned        insCodesACC[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            )
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        )
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) a4,
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) a4,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodesACC)/sizeof(insCodesACC[0]));
    assert((insCodesACC[ins] != BAD_CODE));

    return  insCodesACC[ins];
}

/*****************************************************************************
 *
 *  Returns the "register" encoding of the given CPU instruction.
 */

inline
unsigned            insCodeRR(instruction ins)
{
    static
    unsigned        insCodesRR[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            )
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        )
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    )
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) rr,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodesRR)/sizeof(insCodesRR[0]));
    assert((insCodesRR[ins] != BAD_CODE));

    return  insCodesRR[ins];
}

/*****************************************************************************
 *
 *  Returns the "[r/m], reg" or "[r/m]" encoding of the given CPU instruction.
 */

inline
unsigned            insCodeMR(instruction ins)
{
    static
    unsigned        insCodesMR[] =
    {
        #define INST0(id, nm, fp, um, rf, wf, ss, mr                )
        #define INST1(id, nm, fp, um, rf, wf, ss, mr                ) mr,
        #define INST2(id, nm, fp, um, rf, wf, ss, mr, mi            ) mr,
        #define INST3(id, nm, fp, um, rf, wf, ss, mr, mi, rm        ) mr,
        #define INST4(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4    ) mr,
        #define INST5(id, nm, fp, um, rf, wf, ss, mr, mi, rm, a4, rr) mr,
        #include "instrs.h"
        #undef  INST0
        #undef  INST1
        #undef  INST2
        #undef  INST3
        #undef  INST4
        #undef  INST5
    };

    assert(ins < sizeof(insCodesMR)/sizeof(insCodesMR[0]));
    assert((insCodesMR[ins] != BAD_CODE));

    return  insCodesMR[ins];
}

/*****************************************************************************
 *
 *  Returns an encoding for the specified register to be used in the bit0-2
 *  part of an opcode.
 */

inline
unsigned            insEncodeReg012(emitRegs reg)
{
    assert(reg < 8);
    return reg;
}

/*****************************************************************************
 *
 *  Returns an encoding for the specified register to be used in the bit3-5
 *  part of an opcode.
 */

inline
unsigned            insEncodeReg345(emitRegs reg)
{
    assert(reg < 8);
    return(reg<< 3);
}

/*****************************************************************************
 *
 *  Returns the given opcode with the [r/m] field set to a register.
 */

inline
unsigned            insEncodeMRreg(unsigned code)
{
    assert((code & 0xC000) == 0);
    return  code | 0xC000;
}

/*****************************************************************************
 *
 *  Returns the "[r/m]" opcode with the mod/RM field set to register.
 */

inline
unsigned            insEncodeMRreg(instruction ins)
{
    return  insEncodeMRreg(insCodeMR(ins));
}

/*****************************************************************************
 *
 *  Returns the "[r/m], icon" opcode with the mod/RM field set to register.
 */

inline
unsigned            insEncodeMIreg(instruction ins)
{
    return  insEncodeMRreg(insCodeMI(ins));
}

/*****************************************************************************
 *
 *  Returns the "[r/m]" opcode with the mod/RM field set to register.
 */

inline
unsigned            insEncodeRMreg(instruction ins)
{
    return  insEncodeMRreg(insCodeRM(ins));
}

/*****************************************************************************
 *
 *  Returns the "byte ptr [r/m]" opcode with the mod/RM field set to
 *  the given register.
 */

inline
unsigned            insEncodeMRreg(instruction ins, emitRegs reg)
{
    return  insEncodeMRreg(insCodeMR(ins)) |  (insEncodeReg012(reg) << 8);
}

/*****************************************************************************
 *
 *  Returns the "byte ptr [r/m], icon" opcode with the mod/RM field set to
 *  the given register.
 */

inline
unsigned            insEncodeMIreg(instruction ins, emitRegs reg)
{
    return  insEncodeMRreg(insCodeMI(ins)) |  (insEncodeReg012(reg) << 8);
}

/*****************************************************************************
 *
 *  Return the 'SS' field value for the given index scale factor.
 */

inline
unsigned            insSSval(unsigned scale)
{
    assert(scale == 1 ||
           scale == 2 ||
           scale == 4 ||
           scale == 8);

    static
    BYTE    scales[] =
    {
        0x00,   // 1
        0x40,   // 2
        0xFF,   // 3
        0x80,   // 4
        0xFF,   // 5
        0xFF,   // 6
        0xFF,   // 7
        0xC0,   // 8
    };

    return  scales[scale-1];
}

/*****************************************************************************
 * The size for these instructions is less than EA_4BYTE,
 * but the target register need not be byte-addressable
 */

inline
bool                emitInstHasNoCode(instruction ins)
{
#if SCHEDULER
    if (ins == INS_noSched)
        return true;
#endif

    return false;
}

/*****************************************************************************
 * The size for these instructions is less than EA_4BYTE,
 * but the target register need not be byte-addressable
 */

#ifdef DEBUG
bool                insLooksSmall(instruction ins)
{
    if (ins == INS_movsx || ins == INS_movzx)
        return true;
    else
        return false;
}
#endif

/*****************************************************************************
 *
 *  Estimate the size (in bytes of generated code) of the given instruction.
 */

inline
size_t              emitter::emitInsSize(unsigned code)
{
    return  (code & 0x00FF0000) ? 3 : 2;
}

inline
size_t              emitter::emitInsSizeRM(instruction ins)
{
    return  emitInsSize(insCodeRM(ins));
}

inline
size_t              emitter::emitInsSizeRR(instruction ins)
{
    return  emitInsSize(insEncodeRMreg(ins));
}

inline
size_t              emitter::emitInsSizeSV(unsigned code, int var, int dsp)
{
    size_t          size = emitInsSize(code);
    size_t          offs;

    /*  Is this a temporary? */

    if  (var < 0)
    {
        /* An address off of ESP takes an extra byte */

        if  (!emitEBPframe)
            size++;

        /* We'll have to estimate the max. possible offset of this temp */

        // UNDONE: Get an estimate of the temp offset instead of assuming
        // UNDONE: that any temp may be at the max. temp offset!!!!!!!!!!

        offs = emitLclSize + emitMaxTmpSize;
    }
    else
    {
        bool            EBPbased;

        /* Get the frame offset of the (non-temp) variable */

        offs = dsp + emitComp->lvaFrameAddress(var, &EBPbased);

        /* An address off of ESP takes an extra byte */

        assert(!EBPbased == 0 || !EBPbased == 1); size += !EBPbased;

        /* Is this a parameter reference? */

        if  (emitComp->lvaIsParameter(var)
#if USE_FASTCALL
            /* register arguments end up as locals */
            && !emitComp->lvaIsRegArgument(var)
#endif
            )
        {

            /* If no EBP frame, arguments are off of ESP, above temps */

            if  (!EBPbased)
            {
                assert((int)offs >= 0);

                offs += emitMaxTmpSize;
            }
        }
        else
        {
            /* Locals off of EBP are at negative offsets */

            if  (EBPbased)
            {
                assert((int)offs < 0);

                return  size + (((int)offs >= -128) ? sizeof(char)
                                                    : sizeof(int));
            }
        }
    }

    assert((int)offs >= 0);

    /* Are we addressing off of ESP? */

    if  (!emitEBPframe)
    {
        /* Adjust the effective offset if necessary */

        if  (emitCntStackDepth)
            offs += emitCurStackLvl;

#if SCHEDULER
        /* If we move any pushes before this instruction, it will increase
           the offset of the local. As we dont know if this will happen,
           we keep a limit on the number of pushes that can be scheduled.
           Assume that we will hit the limit for estimating the instruction
           encoding size */

        if (emitComp->opts.compSchedCode)
            offs += SCHED_MAX_STACK_CHANGE;
#endif

        /* Special case: check for "[ESP]" */

        if  (offs == 0)
            return  size;
    }

//  printf("lcl = %04X, tmp = %04X, stk = %04X, offs = %04X\n",
//         emitLclSize, emitMaxTmpSize, emitCurStackLvl, offs);

    return  size + (offs > (size_t)SCHAR_MAX ? sizeof(int)
                                             : sizeof(char));
}

inline
size_t              emitter::emitInsSizeSV(instrDesc * id, int var, int dsp, int val)
{
    instruction  ins       = id->idInsGet();
    size_t       valSize   = EA_SIZE_IN_BYTES(emitDecodeSize(id->idOpSize));
    bool         valInByte = ((signed char)val == val) && (ins != INS_mov) && (ins != INS_test);

    if  (valSize > sizeof(int))
        valSize = sizeof(int);

#ifdef RELOC_SUPPORT
    if (id->idInfo.idCnsReloc)
    {
        valInByte = false;      // relocs can't be placed in a byte
        assert(valSize == sizeof(int));
    }
#endif

    if  (valInByte)
    {
        valSize = sizeof(char);
    }

    return valSize + emitInsSizeSV(insCodeMI(ins), var, dsp);
}

size_t              emitter::emitInsSizeAM(instrDesc * id, unsigned code)
{
    emitAttr    attrSize  = emitDecodeSize(id->idOpSize);
    emitRegs    reg       = (emitRegs)id->idAddr.iiaAddrMode.amBaseReg;
    emitRegs    rgx       = (emitRegs)id->idAddr.iiaAddrMode.amIndxReg;
    instruction ins       = id->idInsGet();
    /* The displacement field is in an unusual place for calls */
    int         dsp       = (ins == INS_call) ? emitGetInsCIdisp(id)
                                              : emitGetInsAmdAny(id);
    bool        dspInByte = ((signed char)dsp == (int)dsp);
    bool        dspIsZero = (dsp == 0);
    size_t      size;


#ifdef RELOC_SUPPORT
    if (id->idInfo.idDspReloc)
    {
        dspInByte = false;      // relocs can't be placed in a byte
        dspIsZero = false;      // relocs won't always be zero
    }
#endif

    if  (code & 0x00FF0000)
    {
        assert(    (attrSize == EA_4BYTE)
                || (ins == INS_movzx)
                || (ins == INS_movsx));

        size = 3;
    }
    else
    {
        size = 2;

        /* most 16-bit operands will require a size prefix */

        if  (    (attrSize == EA_2BYTE)
              && (ins != INS_fldcw)
              && (ins != INS_fnstcw))
        {
            size++;
        }
    }

    if  (rgx == SR_NA)
    {
        /* The address is of the form "[reg+disp]" */

        switch (reg)
        {

        case SR_NA:

            /* The address is of the form "[disp]" */

            size += sizeof(int);
            return size;

        case SR_EBP:
            break;

        case SR_ESP:
            size++;

            // Fall through ...

        default:
            if  (dspIsZero)
                return size;
        }

        /* Does the offset fit in a byte? */

        if  (dspInByte)
            size += sizeof(char);
        else
            size += sizeof(int);
    }
    else
    {
        /* An index register is present */

        size++;

        /* Is the index value scaled? */

        if  (emitDecodeScale(id->idAddr.iiaAddrMode.amScale) > 1)
        {
            /* Is there a base register? */

            if  (reg != SR_NA)
            {
                /* The address is "[reg + {2/4/8} * rgx + icon]" */

                if  (dspIsZero && reg != SR_EBP)
                {
                    /* The address is "[reg + {2/4/8} * rgx]" */

                }
                else
                {
                    /* The address is "[reg + {2/4/8} * rgx + disp]" */

                    if  (dspInByte)
                        size += sizeof(char);
                    else
                        size += sizeof(int );
                }
            }
            else
            {
                /* The address is "[{2/4/8} * rgx + icon]" */

                size += sizeof(int);
            }
        }
        else
        {
            if  (dspIsZero && (reg == SR_EBP)
                           && (rgx != SR_EBP))
            {
                /* Swap reg and rgx, such that reg is not EBP */
                id->idAddr.iiaAddrMode.amBaseReg = reg = rgx;
                id->idAddr.iiaAddrMode.amIndxReg = rgx = SR_EBP;
            }

            /* The address is "[reg+rgx+dsp]" */

            if  (dspIsZero && reg != SR_EBP)
            {
                /* This is [reg+rgx]" */

            }
            else
            {
                /* This is [reg+rgx+dsp]" */

                if  (dspInByte)
                    size += sizeof(char);
                else
                    size += sizeof(int );
            }
        }
    }

    return  size;
}

inline
size_t              emitter::emitInsSizeAM(instrDesc * id, unsigned code, int val)
{
    instruction  ins       = id->idInsGet();
    size_t       valSize   = EA_SIZE_IN_BYTES(emitDecodeSize(id->idOpSize));
    bool         valInByte = ((signed char)val == val) && (ins != INS_mov) && (ins != INS_test);

    if  (valSize > sizeof(int))
        valSize = sizeof(int);

#ifdef RELOC_SUPPORT
    if (id->idInfo.idCnsReloc)
    {
        valInByte = false;      // relocs can't be placed in a byte
        assert(valSize == sizeof(int));
    }
#endif

    if  (valInByte)
    {
        valSize = sizeof(char);
    }

    return  valSize + emitInsSizeAM(id, code);
}

inline
size_t              emitter::emitInsSizeCV(instrDesc * id, unsigned code)
{
    instruction  ins       = id->idInsGet();
    size_t       size      = sizeof(void*);

    /* Most 16-bit operand instructions will need a prefix */

    if  (emitDecodeSize(id->idOpSize) == EA_2BYTE && ins != INS_movzx
                                                  && ins != INS_movsx)
        size++;

    return  size + emitInsSize(code);
}

inline
size_t              emitter::emitInsSizeCV(instrDesc * id, unsigned code, int val)
{
    instruction  ins       = id->idInsGet();
    size_t       valSize   = EA_SIZE_IN_BYTES(emitDecodeSize(id->idOpSize));
    bool         valInByte = ((signed char)val == val) && (ins != INS_mov) && (ins != INS_test);

    if  (valSize > sizeof(int))
        valSize = sizeof(int);

#ifdef RELOC_SUPPORT
    if (id->idInfo.idCnsReloc)
    {
        valInByte = false;      // relocs can't be placed in a byte
        assert(valSize == sizeof(int));
    }
#endif

    if  (valInByte)
    {
        valSize = sizeof(char);
    }

    return valSize + emitInsSizeCV(id, code);
}

/*****************************************************************************
 *
 *  Allocate instruction descriptors for instructions with address modes.
 */

inline
emitter::instrDesc      * emitter::emitNewInstrAmd   (emitAttr size, int dsp)
{
    if  (dsp < AM_DISP_MIN || dsp > AM_DISP_MAX)
    {
        instrDescAmd   *id = emitAllocInstrAmd   (size);

        id->idInfo.idLargeDsp          = true;
#ifdef  DEBUG
        id->idAddr.iiaAddrMode.amDisp  = AM_DISP_BIG_VAL;
#endif
        id->idaAmdVal                  = dsp;

        return  id;
    }
    else
    {
        instrDesc      *id = emitAllocInstr      (size);

        id->idAddr.iiaAddrMode.amDisp  = dsp;
 assert(id->idAddr.iiaAddrMode.amDisp == dsp);  // make sure the value fit

        return  id;
    }
}

inline
emitter::instrDescDCM   * emitter::emitNewInstrDCM (emitAttr size, int dsp, int cns, int val)
{
    // @ToDo: cns is always zero [briansul]

    instrDescDCM   *id = emitAllocInstrDCM (size);

    id->idInfo.idLargeCns = true;
    id->idInfo.idLargeDsp = true;

    id->iddcDspVal = dsp;
    id->iddcCnsVal = cns;

#if EMITTER_STATS
    emitLargeDspCnt++;
    emitLargeCnsCnt++;
#endif

    id->idcmCval   = val;

    return  id;
}

/*****************************************************************************
 *
 *  Allocate an instruction descriptor for a direct call.
 *
 *  We use two different descriptors to save space - the common case records
 *  with no GC variables or byrefs and has a very small argument count, and no
 *  explicit scope;
 *  the much rarer (we hope) case records the current GC var set, the call scope,
 *  and an arbitrarily large argument count.
 */

emitter::instrDesc *emitter::emitNewInstrCallDir(int        argCnt,
#if TRACK_GC_REFS
                                                 VARSET_TP  GCvars,
                                                 unsigned   byrefRegs,
#endif
                                                 int        retSizeIn)
{
    emitAttr       retSize = retSizeIn ? EA_ATTR(retSizeIn) : EA_4BYTE;

    /*
        Allocate a larger descriptor if new GC values need to be saved
        or if we have an absurd number of arguments or if we need to
        save the scope.
     */

    if  (GCvars    != 0            ||   // any frame GCvars live
         byrefRegs != 0            ||   // any register byrefs live
         argCnt > ID_MAX_SMALL_CNS ||   // too many args
         argCnt < 0                   ) // caller pops arguments
    {
        instrDescCDGCA* id = emitAllocInstrCDGCA(retSize);

//      printf("Direct call with GC vars / big arg cnt / explicit scope\n");

        id->idInfo.idLargeCall = true;

        id->idcdGCvars         = GCvars;
        id->idcdByrefRegs      = emitEncodeCallGCregs(byrefRegs);

        id->idcdArgCnt         = argCnt;

        return  id;
    }
    else
    {
        instrDesc     * id = emitNewInstrCns(retSize, argCnt);

//      printf("Direct call w/o  GC vars / big arg cnt / explicit scope\n");

        /* Make sure we didn't waste space unexpectedly */

        assert(id->idInfo.idLargeCns == false);

        return  id;
    }
}

/*****************************************************************************
 *
 *  Get hold of the argument count for a direct call.
 */

inline
int             emitter::emitGetInsCDinfo(instrDesc *id)
{
    if  (id->idInfo.idLargeCall)
    {
        return  ((instrDescCDGCA*)id)->idcdArgCnt;
    }
    else
    {
        assert(id->idInfo.idLargeDsp == false);
        assert(id->idInfo.idLargeCns == false);

        return  emitGetInsCns(id);
    }
}

/*****************************************************************************
 *
 *  Allocate an instruction descriptor for an instruction that uses both
 *  an address mode displacement and a constant.
 */

emitter::instrDesc *  emitter::emitNewInstrAmdCns(emitAttr size, int dsp, int cns)
{
    if  (dsp >= AM_DISP_MIN && dsp <= AM_DISP_MAX)
    {
        if  (cns >= ID_MIN_SMALL_CNS &&
             cns <= ID_MAX_SMALL_CNS)
        {
            instrDesc      *id = emitAllocInstr      (size);

            id->idInfo.idSmallCns          = cns;

            id->idAddr.iiaAddrMode.amDisp  = dsp;
     assert(id->idAddr.iiaAddrMode.amDisp == dsp);  // make sure the value fit

            return  id;
        }
        else
        {
            instrDescCns   *id = emitAllocInstrCns   (size);

            id->idInfo.idLargeCns          = true;
            id->idcCnsVal                  = cns;

            id->idAddr.iiaAddrMode.amDisp  = dsp;
     assert(id->idAddr.iiaAddrMode.amDisp == dsp);  // make sure the value fit

            return  id;
        }
    }
    else
    {
        if  (cns >= ID_MIN_SMALL_CNS &&
             cns <= ID_MAX_SMALL_CNS)
        {
            instrDescAmd   *id = emitAllocInstrAmd   (size);

            id->idInfo.idLargeDsp          = true;
#ifdef  DEBUG
            id->idAddr.iiaAddrMode.amDisp  = AM_DISP_BIG_VAL;
#endif
            id->idaAmdVal                  = dsp;

            id->idInfo.idSmallCns          = cns;

            return  id;
        }
        else
        {
            instrDescAmdCns*id = emitAllocInstrAmdCns(size);

            id->idInfo.idLargeCns          = true;
            id->idacCnsVal                 = cns;

            id->idInfo.idLargeDsp          = true;
#ifdef  DEBUG
            id->idAddr.iiaAddrMode.amDisp  = AM_DISP_BIG_VAL;
#endif
            id->idacAmdVal                 = dsp;

            return  id;
        }
    }
}

/*****************************************************************************
 *
 *  Add an instruction with no operands.
 */

void                emitter::emitIns(instruction ins)
{
    size_t      sz;
    instrDesc  *id = emitNewInstr();

    sz = (insCodeMR(ins) & 0xFF00) ? sizeof(short)
                                   : sizeof(char);

    id->idInsFmt   = Compiler::instIsFP(ins) ? emitInsModeFormat(ins, IF_TRD)
                                             : IF_NONE;

#if SCHEDULER
    if (emitComp->opts.compSchedCode)
    {
        if (Compiler::instIsFP(ins))
            scInsNonSched(id);
    }
#endif

    id->idIns      = ins;
    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction of the form "op ST(0),ST(n)".
 */

void                emitter::emitIns_F0_F(instruction ins, unsigned fpreg)
{
    size_t      sz = 2;
    instrDesc  *id = emitNewInstr();

#if SCHEDULER
    if (emitComp->opts.compSchedCode) scInsNonSched(id);
#endif

    id->idIns      = ins;
    id->idInsFmt   = emitInsModeFormat(ins, IF_TRD_FRD);
    id->idReg      = (emitRegs)fpreg;
    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction of the form "op ST(n),ST(0)".
 */

void                emitter::emitIns_F_F0(instruction ins, unsigned fpreg)
{
    size_t      sz = 2;
    instrDesc  *id = emitNewInstr();

#if SCHEDULER
    if (emitComp->opts.compSchedCode) scInsNonSched(id);
#endif

    id->idIns      = ins;
    id->idInsFmt   = emitInsModeFormat(ins, IF_FRD_TRD);
    id->idReg      = (emitRegs)fpreg;

    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction referencing a single register.
 */

void                emitter::emitIns_R(instruction ins,
                                       emitAttr    attr,
                                       emitRegs    reg)
{
    emitAttr   size = EA_SIZE(attr);

    assert(size <= EA_4BYTE);
    assert(size != EA_1BYTE || (emitRegMask(reg) & SRM_BYTE_REGS));

    size_t          sz;
    instrDesc      *id   = emitNewInstrTiny(attr);


    switch (ins)
    {
    case INS_inc:
    case INS_dec:
        if (size == EA_1BYTE)
            sz = 2; // Use the long form as the small one has no 'w' bit
        else
            sz = 1; // Use short form
        break;

    case INS_pop:
    case INS_push:
    case INS_push_hide:

        /* We dont currently push/pop small values */

        assert(size == EA_4BYTE);

        sz = 1;
        break;

    default:

        /* All the sixteen INS_setCCs are contiguous. */

        if (INS_seto <= ins && ins <= INS_setg)
        {
            // Rough check that we used the endpoints for the range check

            assert(INS_seto + 0xF == INS_setg);

            /* We expect this to always be a 'big' opcode */

            assert(insEncodeMRreg(ins, reg) & 0x00FF0000);

            sz = 3;
            break;
        }
        else
        {
            sz = 2;
            break;
        }
    }
    id->idIns      = ins;
    id->idReg      = reg;
    id->idInsFmt   = emitInsModeFormat(ins, IF_RRD);

    /* 16-bit operand instructions will need a prefix */

    if (size == EA_2BYTE)
        sz += 1;

    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

/*****************************************************************************
 *
 *  Add an instruction referencing a register and a constant.
 */

void                emitter::emitIns_R_I(instruction ins,
                                         emitAttr    attr,
                                         emitRegs    reg,
                                         int         val)
{
    emitAttr   size = EA_SIZE(attr);

    assert(size <= EA_4BYTE);
    assert(size != EA_1BYTE || (emitRegMask(reg) & SRM_BYTE_REGS));

    size_t      sz;
    instrDesc  *id;
    insFormats  fmt       = emitInsModeFormat(ins, IF_RRD_CNS);
    bool        valInByte = ((signed char)val == val) && (ins != INS_mov) && (ins != INS_test);

    /* Figure out the size of the instruction */

    switch (ins)
    {
    case INS_mov:
        sz = 5;
        break;

    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_RRW_SHF;
        sz   = 3;
        val &= 0x7F;
        break;

    default:

        if (EA_IS_CNS_RELOC(attr))
            valInByte = false;  // relocs can't be placed in a byte

        if  (valInByte)
        {
            sz = 3;
        }
        else
        {
            if  (reg == SR_EAX && !instrIsImulReg(ins))
            {
                sz = 1;
            }
            else
            {
                sz = 2;
            }
            sz += EA_SIZE_IN_BYTES(attr);
        }
        break;
    }

    id             = emitNewInstrSC(attr, val);
    id->idIns      = ins;
    id->idReg      = reg;
    id->idInsFmt   = fmt;

    /* 16-bit operand instructions will need a prefix */

    if (size == EA_2BYTE)
        sz += 1;

    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;

    if  (reg == SR_ESP)
    {
        if  (emitCntStackDepth)
        {
            if      (ins == INS_sub)
            {
                emitCurStackLvl += val;

                if  (emitMaxStackDepth < emitCurStackLvl)
                     emitMaxStackDepth = emitCurStackLvl;
            }
            else if (ins == INS_add)
            {
                emitCurStackLvl -= val; assert((int)emitCurStackLvl >= 0);
            }
        }
    }
}

/*****************************************************************************
 *
 *  Load a register with the address of a method
 *
 *  instruction must be INS_mov
 */

void emitter::emitIns_R_MP(instruction ins, emitAttr attr, emitRegs reg, METHOD_HANDLE methHnd)
{
    assert(ins == INS_mov && EA_SIZE(attr) == EA_4BYTE);

    instrBaseCns *     id = (instrBaseCns*)emitAllocInstr(sizeof(instrBaseCns), attr);
    size_t             sz = 1 + sizeof(void*);

    id->idIns             = INS_mov;
    id->idCodeSize        = sz;
    id->idInsFmt          = IF_RWR_METHOD;
    id->idReg             = reg;
    id->idScnsDsc         = true;
    id->idInfo.idLargeCns = true;
    id->idAddr.iiaMethHnd = methHnd;

    dispIns(id);
    emitCurIGsize += sz;

}

/*****************************************************************************
 *
 *  Add an instruction referencing an integer constant.
 */

void                emitter::emitIns_I(instruction ins,
                                       emitAttr    attr,
                                       int         val
#ifdef  DEBUG
                                      ,bool        strlit
#endif
                                      )
{
    size_t     sz;
    instrDesc *id;
    bool       valInByte = ((signed char)val == val);

    if (EA_IS_CNS_RELOC(attr))
        valInByte = false;  // relocs can't be placed in a byte

    switch (ins)
    {
    case INS_loop:
        sz = 2;
        break;

    case INS_ret:
        sz = 3;
        break;

    case INS_push_hide:
    case INS_push:
        sz = valInByte ? 2 : 5;
        break;

    default:
        assert(!"unexpected instruction");
    }

    id                = emitNewInstrSC(attr, val);
    id->idIns         = ins;
    id->idInsFmt      = IF_CNS;

#ifdef  DEBUG
    id->idStrLit      = strlit;
#endif

    id->idCodeSize    = sz;

    dispIns(id);
    emitCurIGsize += sz;

    if  (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
}

/*****************************************************************************
 *
 *  Add a "jump through a table" instruction.
 */

void                emitter::emitIns_IJ(emitAttr attr,
                                        emitRegs reg,
                                        unsigned base,
                                        unsigned offs)

{
    assert(EA_SIZE(attr) == EA_4BYTE);

    size_t                       sz  = 3 + sizeof(void*);
    instrDesc                   *id  = emitNewInstr(attr);
    unsigned                     adr = base + offs - 1;

    assert(base & 1);

    id->idIns                        = INS_i_jmp;
    id->idInsFmt                     = IF_ARD;
    id->idAddr.iiaAddrMode.amBaseReg = SR_NA;
    id->idAddr.iiaAddrMode.amIndxReg = reg;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(sizeof(void*));
    id->idAddr.iiaAddrMode.amDisp    = adr;

    assert(id->idAddr.iiaAddrMode.amDisp == (int)adr); // make sure it fit

#ifdef  DEBUG
    id->idMemCookie                  = base - 1;
#endif

    id->idCodeSize                   = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction with a static data member operand. If 'size' is 0, the
 *  instruction operates on the address of the static member instead of its
 *  value (e.g. "push offset clsvar", rather than "push dword ptr [clsvar]").
 */

void                emitter::emitIns_C(instruction  ins,
                                       emitAttr     attr,
                                       FIELD_HANDLE fldHnd,
                                       int          offs)
{
#if RELOC_SUPPORT
    // Static always need relocs
    if (!jitStaticFldIsGlobAddr(fldHnd))
        attr = EA_SET_FLG(attr, EA_DSP_RELOC_FLG);
#endif

    size_t          sz;
    instrDesc      *id;

    /* Are we pushing the offset of the class variable? */

    if  (EA_IS_OFFSET(attr))
    {
        assert(ins == INS_push);
        sz = 1 + sizeof(void*);

        id                 = emitNewInstrDsp(EA_1BYTE, offs);
        id->idIns          = ins;
        id->idInsFmt       = IF_MRD_OFF;
    }
    else
    {
        id                 = emitNewInstrDsp(attr, offs);
        id->idIns          = ins;
        id->idInsFmt       = emitInsModeFormat(ins, IF_MRD,
                                                    IF_TRD_MRD,
                                                    IF_MWR_TRD);
        sz                 = emitInsSizeCV(id, insCodeMR(ins));
    }

    id->idAddr.iiaFieldHnd = fldHnd;

    id->idCodeSize         = sz;

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

/*****************************************************************************
 *
 *  Add an instruction with two register operands.
 */

void                emitter::emitIns_R_R   (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    reg1,
                                            emitRegs    reg2)
{
    emitAttr   size = EA_SIZE(attr);

    assert(   size <= EA_4BYTE);
    assert(   size != EA_1BYTE
           || (   (emitRegMask(reg1) & SRM_BYTE_REGS)
               && (emitRegMask(reg2) & SRM_BYTE_REGS))
           || insLooksSmall(ins));

    size_t          sz = emitInsSizeRR(ins);

    /* Most 16-bit operand instructions will need a prefix */

    if (size == EA_2BYTE && ins != INS_movsx
                         && ins != INS_movzx)
        sz += 1;

    instrDesc      *id = emitNewInstrTiny(attr);
    id->idIns          = ins;
    id->idReg          = reg1;
    id->idRg2          = reg2;
    id->idCodeSize     = sz;

    /* Special case: "XCHG" uses a different format */

    id->idInsFmt       = (ins == INS_xchg) ? IF_RRW_RRW
                                           : emitInsModeFormat(ins, IF_RRD_RRD);

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction with two register operands and an integer constant.
 */

void                emitter::emitIns_R_R_I (instruction ins,
                                            emitRegs    reg1,
                                            emitRegs    reg2,
                                            int         ival)
{
    size_t          sz = 4;
    instrDesc      *id = emitNewInstrSC(EA_4BYTE, ival);

    id->idIns          = ins;
    id->idReg          = reg1;
    id->idRg2          = reg2;
    id->idInsFmt       = IF_RRW_RRW_CNS;
    id->idCodeSize     = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction with a register + static member operands.
 */
void                emitter::emitIns_R_C(instruction  ins,
                                         emitAttr     attr,
                                         emitRegs     reg,
                                         FIELD_HANDLE fldHnd,
                                         int          offs)
{
#if RELOC_SUPPORT
    // Static always need relocs
    if (!jitStaticFldIsGlobAddr(fldHnd))
        attr = EA_SET_FLG(attr, EA_DSP_RELOC_FLG);
#endif

    emitAttr   size = EA_SIZE(attr);

    assert(size <= EA_4BYTE);
    assert(size != EA_1BYTE || (emitRegMask(reg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    size_t          sz;
    instrDesc      *id;

    /* Are we MOV'ing the offset of the class variable into EAX? */

    if  (EA_IS_OFFSET(attr))
    {
        id                 = emitNewInstrDsp(EA_1BYTE, offs);
        id->idIns          = ins;
        id->idInsFmt       = IF_RWR_MRD_OFF;

        assert(ins == INS_mov && reg == SR_EAX);

        /* Special case: "mov eax, [addr]" is smaller */

        sz = 1 + sizeof(void *);
    }
    else
    {
        id                 = emitNewInstrDsp(attr, offs);
        id->idIns          = ins;
        id->idInsFmt       = emitInsModeFormat(ins, IF_RRD_MRD);

        /* Special case: "mov eax, [addr]" is smaller */

        if  (ins == INS_mov && reg == SR_EAX)
            sz = 1 + sizeof(void *);
        else
            sz = emitInsSizeCV(id, insCodeRM(ins));

        /* Special case: mov reg, fs:[ddd] */

        if (fldHnd == FLD_GLOBAL_FS)
            sz += 1;
    }

    id->idReg              = reg;
    id->idAddr.iiaFieldHnd = fldHnd;

    id->idCodeSize         = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction with a static member + register operands.
 */

void                emitter::emitIns_C_R  (instruction  ins,
                                           emitAttr     attr,
                                           FIELD_HANDLE fldHnd,
                                           emitRegs     reg,
                                           int          offs)
{
#if RELOC_SUPPORT
    // Static always need relocs
    if (!jitStaticFldIsGlobAddr(fldHnd))
        attr = EA_SET_FLG(attr, EA_DSP_RELOC_FLG);
#endif

    emitAttr   size = EA_SIZE(attr);

    assert(size <= EA_4BYTE);
    assert(size != EA_1BYTE || (emitRegMask(reg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    instrDesc      *id     = emitNewInstrDsp(attr, offs);
    id->idIns              = ins;
    size_t          sz;

    /* Special case: "mov [addr], EAX" is smaller */

    if  (ins == INS_mov && reg == SR_EAX)
        sz = 1 + sizeof(void *);
    else
        sz = emitInsSizeCV(id, insCodeMR(ins));

    /* Special case: mov reg, fs:[ddd] */

    if (fldHnd == FLD_GLOBAL_FS)
        sz += 1;

    id->idInsFmt           = emitInsModeFormat(ins, IF_MRD_RRD);
    id->idReg              = reg;
    id->idAddr.iiaFieldHnd = fldHnd;
    id->idCodeSize         = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add an instruction with a static member + constant.
 */

void                emitter::emitIns_C_I   (instruction  ins,
                                            emitAttr     attr,
                                            FIELD_HANDLE fldHnd,
                                            int          offs,
                                            int          val)
{
#if RELOC_SUPPORT
    // Static always need relocs
    if (!jitStaticFldIsGlobAddr(fldHnd))
        attr = EA_SET_FLG(attr, EA_DSP_RELOC_FLG);
#endif

    instrDescDCM   *id     = emitNewInstrDCM(attr, offs, 0, val);
    id->idIns              = ins;
    size_t          sz     = emitInsSizeCV(id, insCodeMI(ins), val);
    insFormats      fmt;


    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_MRW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt = emitInsModeFormat(ins, IF_MRD_CNS);
        break;
    }

    id->idInsFmt           = fmt;
    id->idAddr.iiaFieldHnd = fldHnd;
    id->idCodeSize         = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  The following add instructions referencing address modes.
 */

void                emitter::emitIns_I_AR  (instruction ins,
                                            emitAttr    attr,
                                            int         val,
                                            emitRegs    reg,
                                            int         disp,
                                            int         memCookie,
                                            void *      clsCookie)
{
    emitAttr   size = EA_SIZE(attr);

    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

    instrDesc      *id               = emitNewInstrAmdCns(attr, disp, val);
    size_t          sz;
    insFormats      fmt;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_ARW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt  = emitInsModeFormat(ins, IF_ARD_CNS);
        break;
    }

    id->idIns                        = ins;
    id->idInsFmt                     = fmt;
    id->idInfo.idMayFault            = true;

    assert((memCookie == NULL) == (clsCookie == NULL));

#ifdef  DEBUG
    id->idMemCookie                  = memCookie;
    id->idClsCookie                  = clsCookie;
#endif

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = SR_NA;

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMI(ins), val);

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_R_AR (instruction ins,
                                           emitAttr    attr,
                                           emitRegs    ireg,
                                           emitRegs    reg,
                                           int         disp,
                                           int         memCookie,
                                           void *      clsCookie)
{
    emitAttr   size = EA_SIZE(attr);

    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE) && (ireg != SR_NA));
    assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    id->idIns                        = ins;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_ARD);
    id->idReg                        = ireg;

    if  (ins != INS_lea)
        id->idInfo.idMayFault = true;

    assert((memCookie == NULL) == (clsCookie == NULL));

#ifdef  DEBUG
    id->idMemCookie                  = memCookie;
    id->idClsCookie                  = clsCookie;
#endif

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = SR_NA;

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeRM(ins));

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_AR_R (instruction ins,
                                           emitAttr    attr,
                                           emitRegs    ireg,
                                           emitRegs    reg,
                                           int         disp,
                                           int         memCookie,
                                           void *      clsCookie)
{
    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    if  (ireg == SR_NA)
    {
        id->idInsFmt                 = emitInsModeFormat(ins, IF_ARD,
                                                              IF_TRD_ARD,
                                                              IF_AWR_TRD);
#if SCHEDULER
        if (emitComp->opts.compSchedCode)
        {
            if (Compiler::instIsFP(ins))
                scInsNonSched(id);
        }
#endif

    }
    else
    {
        emitAttr  size = EA_SIZE(attr);
        assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));
        assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS));

        id->idReg    = ireg;
        id->idInsFmt = emitInsModeFormat(ins, IF_ARD_RRD);
    }

    id->idIns                        = ins;
    id->idInfo.idMayFault            = true;

    assert((memCookie == NULL) == (clsCookie == NULL));

#ifdef  DEBUG
    id->idMemCookie                  = memCookie;
    id->idClsCookie                  = clsCookie;
#endif

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = SR_NA;

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly


    id->idCodeSize               = sz = emitInsSizeAM(id, insCodeMR(ins));

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

void                emitter::emitIns_I_ARR (instruction ins,
                                            emitAttr    attr,
                                            int         val,
                                            emitRegs    reg,
                                            emitRegs    rg2,
                                            int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

    size_t          sz;
    instrDesc      *id   = emitNewInstrAmdCns(attr, disp, val);
    insFormats      fmt;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_ARW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt  = emitInsModeFormat(ins, IF_ARD_CNS);
        break;
    }

    id->idIns                        = ins;
    id->idInsFmt                     = fmt;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(1);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMI(ins), val);

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_R_ARR(instruction ins,
                                           emitAttr    attr,
                                           emitRegs    ireg,
                                           emitRegs    reg,
                                           emitRegs    rg2,
                                           int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE) && (ireg != SR_NA));
    assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    id->idIns                        = ins;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_ARD);
    id->idReg                        = ireg;

    if  (ins != INS_lea)
        id->idInfo.idMayFault        = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(1);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeRM(ins));

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_ARR_R (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    ireg,
                                            emitRegs    reg,
                                            emitRegs    rg2,
                                            int         disp)
{
    size_t          sz;
    instrDesc      *id   = emitNewInstrAmd(attr, disp);

    if  (ireg == SR_NA)
    {
        id->idInsFmt                 = emitInsModeFormat(ins, IF_ARD,
                                                              IF_TRD_ARD,
                                                              IF_AWR_TRD);

#if SCHEDULER
        if (emitComp->opts.compSchedCode)
        {
            if (Compiler::instIsFP(ins))
                scInsNonSched(id);
        }
#endif

    }
    else
    {
        emitAttr size = EA_SIZE(attr);
        assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));
        assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS));

        id->idReg                    = ireg;
        id->idInsFmt                 = emitInsModeFormat(ins, IF_ARD_RRD);
    }

    id->idIns                        = ins;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(1);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly


    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMR(ins));

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

void                emitter::emitIns_I_ARX (instruction ins,
                                            emitAttr    attr,
                                            int         val,
                                            emitRegs    reg,
                                            emitRegs    rg2,
                                            unsigned    mul,
                                            int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

    size_t          sz;
    instrDesc      *id   = emitNewInstrAmdCns(attr, disp, val);
    insFormats      fmt;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_ARW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt  = emitInsModeFormat(ins, IF_ARD_CNS);
        break;
    }

    id->idInsFmt                     = fmt;
    id->idIns                        = ins;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMI(ins), val);

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_R_ARX (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    ireg,
                                            emitRegs    reg,
                                            emitRegs    rg2,
                                            unsigned    mul,
                                            int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE) && (ireg != SR_NA));
    assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    id->idReg                        = ireg;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_ARD);
    id->idIns                        = ins;

    if  (ins != INS_lea)
        id->idInfo.idMayFault = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly


    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeRM(ins));

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_ARX_R (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    ireg,
                                            emitRegs    reg,
                                            emitRegs    rg2,
                                            unsigned    mul,
                                            int         disp)
{
    size_t          sz;
    instrDesc      *id   = emitNewInstrAmd(attr, disp);


    if  (ireg == SR_NA)
    {
        id->idInsFmt = emitInsModeFormat(ins, IF_ARD,
                                              IF_TRD_ARD,
                                              IF_AWR_TRD);
#if SCHEDULER
        if (emitComp->opts.compSchedCode)
        {
            if (Compiler::instIsFP(ins))
                scInsNonSched(id);
        }
#endif

    }
    else
    {
        emitAttr size = EA_SIZE(attr);
        assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS));
        assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

        id->idReg    = ireg;
        id->idInsFmt = emitInsModeFormat(ins, IF_ARD_RRD);
    }

    id->idIns                        = ins;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = reg;
    id->idAddr.iiaAddrMode.amIndxReg = rg2;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMR(ins));

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

void                emitter::emitIns_I_AX (instruction ins,
                                           emitAttr    attr,
                                           int         val,
                                           emitRegs    reg,
                                           unsigned    mul,
                                           int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

    size_t          sz;
    instrDesc      *id               = emitNewInstrAmdCns(attr, disp, val);
    insFormats      fmt;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt  = IF_ARW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt  = emitInsModeFormat(ins, IF_ARD_CNS);
        break;
    }

    id->idIns                        = ins;
    id->idInsFmt                     = fmt;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = SR_NA;
    id->idAddr.iiaAddrMode.amIndxReg = reg;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMI(ins), val);

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_R_AX  (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    ireg,
                                            emitRegs    reg,
                                            unsigned    mul,
                                            int         disp)
{
    emitAttr   size = EA_SIZE(attr);
    assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE) && (ireg != SR_NA));
    assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    id->idReg                        = ireg;
    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_ARD);
    id->idIns                        = ins;

    if  (ins != INS_lea)
        id->idInfo.idMayFault = true;

    id->idAddr.iiaAddrMode.amBaseReg = SR_NA;
    id->idAddr.iiaAddrMode.amIndxReg = reg;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly


    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeRM(ins));

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_AX_R  (instruction ins,
                                            emitAttr    attr,
                                            emitRegs    ireg,
                                            emitRegs    reg,
                                            unsigned    mul,
                                            int         disp)
{
    size_t          sz;
    instrDesc      *id               = emitNewInstrAmd(attr, disp);

    if  (ireg == SR_NA)
    {
        id->idInsFmt                 = emitInsModeFormat(ins, IF_ARD,
                                                              IF_TRD_ARD,
                                                              IF_AWR_TRD);

#if SCHEDULER
        if (emitComp->opts.compSchedCode)
        {
            if (Compiler::instIsFP(ins))
                scInsNonSched(id);
        }
#endif

    }
    else
    {
        emitAttr size = EA_SIZE(attr);
        assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS));
        assert((Compiler::instIsFP(ins) == false) && (size <= EA_4BYTE));

        id->idReg                    = ireg;
        id->idInsFmt                 = emitInsModeFormat(ins, IF_ARD_RRD);
    }

    id->idIns                        = ins;
    id->idInfo.idMayFault            = true;

    id->idAddr.iiaAddrMode.amBaseReg = SR_NA;
    id->idAddr.iiaAddrMode.amIndxReg = reg;
    id->idAddr.iiaAddrMode.amScale   = emitEncodeScale(mul);

    assert(emitGetInsAmdAny(id) == disp); // make sure "disp" is stored properly

    id->idCodeSize              = sz = emitInsSizeAM(id, insCodeMR(ins));

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

/*****************************************************************************
 *
 *  The following add instructions referencing stack-based local variables.
 */

void                emitter::emitIns_S     (instruction ins,
                                            emitAttr    attr,
                                            int         varx,
                                            int         offs)
{
    instrDesc      *id               = emitNewInstr(attr);
    size_t          sz               = emitInsSizeSV(insCodeMR(ins), varx, offs);

    /* 16-bit operand instructions will need a prefix */

    if (EA_SIZE(attr) == EA_2BYTE)
        sz += 1;

    id->idIns                        = ins;
    id->idAddr.iiaLclVar.lvaVarNum   = varx;
    id->idAddr.iiaLclVar.lvaOffset   = offs;
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

#if SCHEDULER
    if (emitComp->opts.compSchedCode)
    {
        if (Compiler::instIsFP(ins))
            scInsNonSched(id);
    }
#endif

    id->idInsFmt   = emitInsModeFormat(ins, IF_SRD,
                                            IF_TRD_SRD,
                                            IF_SWR_TRD);
    id->idCodeSize = sz;

    dispIns(id);
    emitCurIGsize += sz;

    if      (ins == INS_push)
    {
        emitCurStackLvl += emitCntStackDepth;

        if  (emitMaxStackDepth < emitCurStackLvl)
             emitMaxStackDepth = emitCurStackLvl;
    }
    else if (ins == INS_pop)
    {
        emitCurStackLvl -= emitCntStackDepth; assert((int)emitCurStackLvl >= 0);
    }
}

void                emitter::emitIns_S_R  (instruction ins,
                                           emitAttr    attr,
                                           emitRegs    ireg,
                                           int         varx,
                                           int         offs)
{
    instrDesc      *id               = emitNewInstr(attr);
    size_t          sz               = emitInsSizeSV(insCodeMR(ins), varx, offs);

    /* 16-bit operand instructions will need a prefix */

    if (EA_SIZE(attr) == EA_2BYTE)
        sz++;

    id->idIns                        = ins;
    id->idReg                        = ireg;
    id->idAddr.iiaLclVar.lvaVarNum   = varx;
    id->idAddr.iiaLclVar.lvaOffset   = offs;
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

    id->idInsFmt                     = emitInsModeFormat(ins, IF_SRD_RRD);

    id->idCodeSize                   = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_R_S  (instruction ins,
                                           emitAttr    attr,
                                           emitRegs    ireg,
                                           int         varx,
                                           int         offs)
{
    emitAttr   size = EA_SIZE(attr);
    assert(size != EA_1BYTE || (emitRegMask(ireg) & SRM_BYTE_REGS) || insLooksSmall(ins));

    instrDesc      *id               = emitNewInstr(attr);
    size_t          sz               = emitInsSizeSV(insCodeRM(ins), varx, offs);

    /* Most 16-bit operand instructions need a prefix */

    if (size == EA_2BYTE && ins != INS_movsx
                         && ins != INS_movzx)
        sz++;

    id->idIns                        = ins;
    id->idReg                        = ireg;
    id->idAddr.iiaLclVar.lvaVarNum   = varx;
    id->idAddr.iiaLclVar.lvaOffset   = offs;
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs   = emitVarRefOffs;
#endif

    id->idInsFmt                     = emitInsModeFormat(ins, IF_RRD_SRD);

    id->idCodeSize                   = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

void                emitter::emitIns_S_I  (instruction ins,
                                           emitAttr    attr,
                                           int         varx,
                                           int         offs,
                                           long        val)
{
    instrDesc      *id             = emitNewInstrCns(attr, val);
    id->idIns                      = ins;
    size_t          sz             = emitInsSizeSV(id, varx, offs, val);
    insFormats      fmt;

    /* 16-bit operand instructions need a prefix */

    if (EA_SIZE(attr) == EA_2BYTE)
        sz += 1;

    switch (ins)
    {
    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        assert(val != 1);
        fmt                        = IF_SRW_SHF;
        val &= 0x7F;
        break;

    default:
        fmt                        = emitInsModeFormat(ins, IF_SRD_CNS);
        break;
    }

    id->idAddr.iiaLclVar.lvaVarNum = varx;
    id->idAddr.iiaLclVar.lvaOffset = offs;
#ifdef  DEBUG
    id->idAddr.iiaLclVar.lvaRefOfs = emitVarRefOffs;
#endif

    id->idInsFmt                   = fmt;

    id->idCodeSize                 = sz;

    dispIns(id);
    emitCurIGsize += sz;
}

/*****************************************************************************
 *
 *  Add a jmp instruction.
 */

void                emitter::emitIns_J(instruction ins,
                                       bool        except,
                                       bool        moveable,
                                       BasicBlock *dst)
{
    size_t          sz;
    instrDescJmp  * id        = emitNewInstrJmp();

#if SCHEDULER
    assert(except == moveable);
#endif

    assert(dst->bbFlags & BBF_JMP_TARGET);

    id->idIns                 = ins;
    id->idInsFmt              = IF_LABEL;
    id->idAddr.iiaBBlabel     = dst;

#if SCHEDULER
    if  (except)
        id->idInfo.idMayFault = true;
#endif

    /* Assume the jump will be long */

    id->idjShort              = 0;

    /* Record the jump's IG and offset within it */

    id->idjIG                 = emitCurIG;
    id->idjOffs               = emitCurIGsize;

    /* Append this jump to this IG's jump list */

    id->idjNext               = emitCurIGjmpList;
                                emitCurIGjmpList = id;

#if EMITTER_STATS
    emitTotalIGjmps++;
#endif

    /* Figure out the max. size of the jump/call instruction */

    if  (ins == INS_call)
    {
        sz = CALL_INST_SIZE;
    }
    else
    {
        insGroup    *   tgt;

        /* This is a jump - assume the worst */

        sz = (ins == JMP_INSTRUCTION) ? JMP_SIZE_LARGE
                                      : JCC_SIZE_LARGE;

        /* Can we guess at the jump distance? */

        tgt = (insGroup*)emitCodeGetCookie(dst);

        if  (tgt)
        {
            int             extra;
            size_t          srcOffs;
            int             jmpDist;

            assert(JMP_SIZE_SMALL == JCC_SIZE_SMALL);

            /* This is a backward jump - figure out the distance */

            srcOffs = emitCurCodeOffset + emitCurIGsize + JMP_SIZE_SMALL;

            /* Compute the distance estimate */

            jmpDist = srcOffs - tgt->igOffs; assert((int)jmpDist > 0);

            /* How much beyond the max. short distance does the jump go? */

            extra = jmpDist + JMP_DIST_SMALL_MAX_NEG;

#ifdef  DEBUG
            if  (id->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (INTERESTING_JUMP_NUM == 0)
                printf("[0] Jump %u:\n",               id->idNum);
#if SCHEDULER
                printf("[0] Jump is %s schedulable\n", moveable ? "   " : "not");
#endif
                printf("[0] Jump source is at %08X\n", srcOffs);
                printf("[0] Label block is at %08X\n", tgt->igOffs);
                printf("[0] Jump  distance  - %04X\n", jmpDist);
                if  (extra > 0)
                printf("[0] Distance excess = %d  \n", extra);
            }
#endif

            if  (extra <= 0)
            {
                /* Wonderful - this jump surely will be short */

                id->idjShort = 1;
                sz           = JMP_SIZE_SMALL;
            }
        }
#ifdef  DEBUG
        else
        {
            if  (id->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
            {
                if  (INTERESTING_JUMP_NUM == 0)
                printf("[0] Jump %u:\n",               id->idNum);
#if SCHEDULER
                printf("[0] Jump is %s schedulable\n", moveable ? "   " : "not");
#endif
                printf("[0] Jump source is at %04X/%08X\n", emitCurIGsize, emitCurCodeOffset + emitCurIGsize + JMP_SIZE_SMALL);
                printf("[0] Label block is uknown \n");
            }
        }
#endif
    }

    id->idCodeSize = sz;

    dispIns(id);

#if SCHEDULER

    if (emitComp->opts.compSchedCode)
    {
        id->idjSched = moveable;

        if  (moveable)
        {
            /*
                This jump is moveable (can be scheduled), and so we'll need
                to figure out the range of offsets it may be moved to after
                it's scheduled (otherwise we wouldn't be able to correctly
                estimate the jump distance).
             */

            id->idjTemp.idjOffs[0] = emitCurIGscdOfs;
            id->idjTemp.idjOffs[1] = emitCurIGscdOfs - 1;
        }
        else
        {
            scInsNonSched(id);
        }
    }
    else
    {
        id->idjSched = false;
    }

#endif

    emitCurIGsize += sz;
}


/*****************************************************************************
 *
 *  Add a call instruction (direct or indirect).
 *      argSize<0 means that the caller will pop the arguments
 *
 * The other arguments are interpreted depending on callType as shown:
 * Unless otherwise specified, ireg,xreg,xmul,disp should have default values.
 *
 * EC_FUNC_TOKEN       : callVal is the method token.
 * EC_FUNC_TOKEN_INDIR : callVal is the method token.
 * EC_FUNC_ADDR        : callVal is the absolute address of the function
 *
 * EC_FUNC_VIRTUAL     : callVal is the method token. "call [ireg+disp]"
 *
 * If callType is one of these 4 emitCallTypes, callVal has to be NULL.
 * EC_INDIR_R          : "call ireg".
 * EC_INDIR_SR         : "call lcl<disp>" (eg. call [ebp-8]).
 * EC_INDIR_C          : "call clsVar<disp>" (eg. call [clsVarAddr])
 * EC_INDIR_ARD        : "call [ireg+xreg*xmul+disp]"
 *
 */

void                emitter::emitIns_Call(EmitCallType  callType,
                                          void       *  callVal,
                                          int           argSize,
                                          int           retSize,
                                          VARSET_TP     ptrVars,
                                          unsigned      gcrefRegs,
                                          unsigned      byrefRegs,
                                          emitRegs      ireg    /* = SR_NA */,
                                          emitRegs      xreg    /* = SR_NA */,
                                          unsigned      xmul    /* = 0     */,
                                          int           disp    /* = 0     */,
                                          bool          isJump  /* = false */)
{
    /* Sanity check the arguments depending on callType */

    assert(callType < EC_COUNT);
    assert(callType != EC_FUNC_TOKEN || callType != EC_FUNC_TOKEN_INDIR ||
           callType != EC_FUNC_ADDR ||
           (ireg == SR_NA && xreg == SR_NA && xmul == 0 && disp == 0));
    assert(callType != EC_FUNC_VIRTUAL ||
           (ireg < SR_COUNT && xreg == SR_NA && xmul == 0));
    assert(callType < EC_INDIR_R || callVal == NULL);
    assert(callType != EC_INDIR_R ||
           (ireg < SR_COUNT && xreg == SR_NA && xmul == 0 && disp == 0));
    assert(callType != EC_INDIR_SR ||
           (ireg == SR_NA && xreg == SR_NA && xmul == 0 &&
            disp < (int)emitComp->lvaCount));
    assert(callType != EC_INDIR_C); // @TODO : NYI : Calls via static class vars

    int             argCnt;

    size_t          sz;
    instrDesc      *id;

    unsigned        fl  = 0;

    /* This is the saved set of registers after a normal call */
    unsigned savedSet = RBM_CALLEE_SAVED;

    /* some special helper calls have a different saved set registers */
    if (callType == EC_FUNC_TOKEN)
    {
        JIT_HELP_FUNCS helperNum = Compiler::eeGetHelperNum((METHOD_HANDLE) callVal);
        if ((helperNum != JIT_HELP_UNDEF) && emitNoGChelper(helperNum))
        {
            /* This call will preserve the liveness of the full register set */

            savedSet = RBM_ALL;
        }
    }

    /* Trim out any calle trashed registers from the live set */

    gcrefRegs &= savedSet;
    byrefRegs &= savedSet;

#ifndef OPT_IL_JIT
#ifdef  DEBUG
    if  (verbose) printf("Call : GCvars=%016I64X , gcrefRegs=%04X , byrefRegs=%04X\n",
                                 ptrVars,          gcrefRegs,       byrefRegs);
#endif
#endif

    assert(  argSize % (int)sizeof(void*) == 0);
    argCnt = argSize / (int)sizeof(void*);

    /*
        We need to allocate the appropriate instruction descriptor based
        on whether this is a direct/indirect call, and whether we need to
        record an updated set of live GC variables.

        The stats for a ton of classes is as follows:

            Direct call w/o  GC vars        220,216
            Indir. call w/o  GC vars        144,781

            Direct call with GC vars          9,440
            Indir. call with GC vars          5,768
     */

    if  (callType >= EC_FUNC_VIRTUAL)
    {
        /* Indirect call, virtual calls */

        assert(callType == EC_FUNC_VIRTUAL || callType == EC_INDIR_R ||
               callType == EC_INDIR_SR     || callType == EC_INDIR_C ||
               callType == EC_INDIR_ARD);

        id  = emitNewInstrCallInd(argCnt, disp, ptrVars, byrefRegs, retSize);
    }
    else
    {
        /* Helper/static/nonvirtual/function calls (direct or through handle),
           and calls to an absolute addr. */

        assert(callType == EC_FUNC_TOKEN || callType == EC_FUNC_TOKEN_INDIR ||
               callType == EC_FUNC_ADDR);

        id  = emitNewInstrCallDir(argCnt,       ptrVars, byrefRegs, retSize);
    }

#if SCHEDULER
    if (emitComp->opts.compSchedCode) scInsNonSched(id);
#endif

    /* Update the emitter's live GC ref sets */

    emitThisGCrefVars = ptrVars;
    emitThisGCrefRegs = gcrefRegs;
    emitThisByrefRegs = byrefRegs;

    /* Set the instruction - special case jumping a function */

    if (isJump)
    {
        assert(callType != CT_INDIRECT);
        id->idIns = INS_l_jmp;
    }
    else
        id->idIns = INS_call;

    /* Save the live GC registers in the unused 'idReg/idRg2' fields */

    emitEncodeCallGCregs(emitThisGCrefRegs, id);

    /* Record the address: method, indirection, or funcptr */

    if  (callType >= EC_FUNC_VIRTUAL)
    {
        /* This is an indirect call (either a virtual call or func ptr call) */

        id->idInfo.idMayFault = true;

#ifdef  DEBUG
        id->idMemCookie = 0;
#endif

        switch(callType)
        {
        case EC_INDIR_R:            // the address is in a register

            id->idInfo.idCallRegPtr         = true;

            // Fall-through

        case EC_INDIR_ARD:          // the address is an indirection

            goto CALL_ADDR_MODE;

        case EC_INDIR_SR:           // the address is in a lcl var

            id->idInsFmt                    = IF_SRD;

            id->idAddr.iiaLclVar.lvaVarNum  = disp;
            id->idAddr.iiaLclVar.lvaOffset  = 0;
#ifdef DEBUG
            id->idAddr.iiaLclVar.lvaRefOfs  = 0;
#endif
            sz = emitInsSizeSV(insCodeMR(INS_call), disp, 0);

            break;

        case EC_FUNC_VIRTUAL:

#ifdef  DEBUG
            id->idMemCookie = (int) callVal;    // method token
            id->idClsCookie = 0;
#endif
            // fall-through

        CALL_ADDR_MODE:

            /* The function is "ireg" if id->idInfo.idCallRegPtr,
               else [ireg+xmul*xreg+disp] */

            id->idInsFmt                     = IF_ARD;

            id->idAddr.iiaAddrMode.amBaseReg = ireg;

            id->idAddr.iiaAddrMode.amIndxReg = xreg;
            id->idAddr.iiaAddrMode.amScale   = xmul ? emitEncodeScale(xmul) : 0;

            sz = emitInsSizeAM(id, insCodeMR(INS_call));
            break;

        default:
            assert(!"Invalid callType");
            break;
        }

    }
    else if (callType == EC_FUNC_TOKEN_INDIR)
    {
        /* "call [method_addr]" */

        id->idInsFmt                     = IF_METHPTR;
        id->idAddr.iiaMethHnd            = (METHOD_HANDLE) callVal;
        sz                               = 6;

#if RELOC_SUPPORT
        if (emitComp->opts.compReloc)
        {
            // Since this is an indirect call through a pointer and we don't
            // currently pass in emitAttr into this function we have decided
            // to always mark the displacement as being relocatable.

            id->idInfo.idDspReloc        = 1;
        }
#endif

    }
    else
    {
        /* This is a simple direct call: "call helper/method/addr" */

        assert(callType == EC_FUNC_TOKEN || callType == EC_FUNC_ADDR);

        id->idInsFmt                     = IF_METHOD;
        sz                               = 5;

        if (callType == EC_FUNC_ADDR)
        {
            id->idInfo.idCallAddr        = true;
            id->idAddr.iiaAddr           = (BYTE*)callVal;

#if RELOC_SUPPORT
            if (emitComp->opts.compReloc)
            {
                // Since this is an indirect call through a pointer and we don't
                // currently pass in emitAttr into this function we have decided
                // to always mark the displacement as being relocatable.

                id->idInfo.idDspReloc    = 1;
            }
#endif
        }
        else    /* This is a direct call or a helper call */
        {
            assert(callType == EC_FUNC_TOKEN);
            id->idAddr.iiaMethHnd        = (METHOD_HANDLE) callVal;
        }
    }

#ifdef  DEBUG
    if  (verbose&&0)
    {
        if  (id->idInfo.idLargeCall)
        {
            if  (callType >= EC_FUNC_VIRTUAL)
                printf("[%02u] Rec call GC vars = %016I64X\n", id->idNum, ((instrDescCIGCA*)id)->idciGCvars);
            else
                printf("[%02u] Rec call GC vars = %016I64X\n", id->idNum, ((instrDescCDGCA*)id)->idcdGCvars);
        }
    }
#endif

    id->idCodeSize = sz;

    dispIns(id);

    emitCurIGsize   += sz;

    /* The call will pop the arguments */

    if  (emitCntStackDepth && argSize > 0)
    {
        emitCurStackLvl -= argSize; assert((int)emitCurStackLvl >= 0);
    }
}

/*****************************************************************************
 *
 *  Return the allocated size (in bytes) of the given instruction descriptor.
 */

inline
size_t              emitter::emitSizeOfInsDsc(instrDescAmd    *id)
{
    assert(emitIsTinyInsDsc(id) == false);

    return  id->idInfo.idLargeDsp ? sizeof(instrDescAmd)
                                  : sizeof(instrDesc   );
}

inline
size_t              emitter::emitSizeOfInsDsc(instrDescAmdCns *id)
{
    assert(emitIsTinyInsDsc(id) == false);

    if      (id->idInfo.idLargeCns)
    {
        return  id->idInfo.idLargeDsp ? sizeof(instrDescAmdCns)
                                      : sizeof(instrDescCns   );
    }
    else
    {
        return  id->idInfo.idLargeDsp ? sizeof(instrDescAmd   )
                                      : sizeof(instrDesc      );
    }
}

size_t              emitter::emitSizeOfInsDsc(instrDesc *id)
{
    if  (emitIsTinyInsDsc(id))
        return  TINY_IDSC_SIZE;

    if  (emitIsScnsInsDsc(id))
    {
        return  id->idInfo.idLargeCns ? sizeof(instrBaseCns)
                                      : SCNS_IDSC_SIZE;
    }

    assert((unsigned)id->idInsFmt < emitFmtCount);

    BYTE idOp = emitFmtToOps[id->idInsFmt];

    // An INS_call instruction may use a "fat" direct/indirect call descriptor
    // except for a local call to a label (i.e. call to a finally)
    // Only ID_OP_CALL and ID_OP_SPEC check for this, so we enforce that the
    //  INS_call instruction always uses one of these idOps

    assert(id->idIns != INS_call ||
           idOp == ID_OP_CALL    ||     // direct calls
           idOp == ID_OP_SPEC    ||     // indirect calls
           idOp == ID_OP_JMP       );   // local calls to finally clause

    switch (idOp)
    {
    case ID_OP_NONE:
        break;

    case ID_OP_JMP:
        return  sizeof(instrDescJmp);

    case ID_OP_CNS:
        return  emitSizeOfInsDsc((instrDescCns   *)id);

    case ID_OP_DSP:
        return  emitSizeOfInsDsc((instrDescDsp   *)id);

    case ID_OP_DC:
        return  emitSizeOfInsDsc((instrDescDspCns*)id);

    case ID_OP_AMD:
        return  emitSizeOfInsDsc((instrDescAmd   *)id);

    case ID_OP_AC:
        return  emitSizeOfInsDsc((instrDescAmdCns*)id);

    case ID_OP_CALL:

        if  (id->idInfo.idLargeCall)
        {
            /* Must be a "fat" direct call descriptor */

            return  sizeof(instrDescCDGCA);
        }

        assert(id->idInfo.idLargeDsp == false);
        assert(id->idInfo.idLargeCns == false);
        break;

    case ID_OP_SPEC:

        switch (id->idIns)
        {
        case INS_i_jmp:
            return  sizeof(instrDesc);

        case INS_call:

            if  (id->idInfo.idLargeCall)
            {
                /* Must be a "fat" indirect call descriptor */

                return  sizeof(instrDescCIGCA);
            }

            assert(id->idInfo.idLargeDsp == false);
            assert(id->idInfo.idLargeCns == false);
            return  sizeof(instrDesc);
        }

        switch (id->idInsFmt)
        {
        case IF_ARD:
        case IF_SRD:
        case IF_MRD:
            return  emitSizeOfInsDsc((instrDescDspCns*)id);

        case IF_MRD_CNS:
        case IF_MWR_CNS:
        case IF_MRW_CNS:
        case IF_MRW_SHF:
            return  sizeof(instrDescDCM);

        case IF_EPILOG:
            return  sizeof(instrDescCns);
        }

        assert(!"unexpected 'special' format");

    default:
        assert(!"unexpected instruction descriptor format");
    }

    return  sizeof(instrDesc);
}

/*****************************************************************************/
#ifdef  DEBUG
/*****************************************************************************
 *
 *  Return a string that represents the given register.
 */

const   char *      emitter::emitRegName(emitRegs reg, emitAttr attr, bool varName)
{
    static
    char            rb[128];

    assert(reg < SR_COUNT);

    // CONSIDER: Make the following work just using a code offset

    const   char *  rn = emitComp->compRegVarName((regNumber)reg, varName);

    assert(strlen(rn) >= 3);

    switch (EA_SIZE(attr))
    {
    case EA_4BYTE:
        break;

    case EA_2BYTE:
        rn++;
        break;

    case EA_1BYTE:
        rb[0] = rn[1];
        rb[1] = 'L';
        strcpy(rb+2, rn+3);

        rn = rb;
        break;
    }

    return  rn;
}

/*****************************************************************************
 *
 *  Return a string that represents the given FP register.
 */

const   char *      emitter::emitFPregName(unsigned reg, bool varName)
{
    assert(reg < SR_COUNT);

    // CONSIDER: Make the following work just using a code offset

    return emitComp->compFPregVarName((regNumber)(reg), varName);
}

/*****************************************************************************
 *
 *  Display a static data member reference.
 */

void                emitter::emitDispClsVar(FIELD_HANDLE fldHnd, int offs, bool reloc /* = false */)
{
    int doffs;

    /* Filter out the special case of fs:[offs] */

    if (fldHnd == FLD_GLOBAL_FS)
    {
        printf("FS:[0x%04X]", offs);
        return;
    }

    if (fldHnd == FLD_GLOBAL_DS)
    {
        printf("[0x%04X]", offs);
        return;
    }

    printf("[");

    doffs = Compiler::eeGetJitDataOffs(fldHnd);

#ifdef RELOC_SUPPORT
    if (reloc)
        printf("reloc ");
#endif

    if (doffs >= 0)
    {
        if  (doffs & 1)
            printf("@CNS%02u", doffs-1);
        else
            printf("@RWD%02u", doffs);

        if  (offs)
            printf("%+d", offs);
    }
    else
    {
        printf("classVar[%#x]", fldHnd);

        if  (offs)
            printf("%+d", offs);
    }

    printf("]");

    if  (varNames && offs < 0)
    {
        printf("'%s", emitComp->eeGetFieldName(fldHnd));
        if (offs) printf("%+d", offs);
        printf("'");
    }
}

/*****************************************************************************
 *
 *  Display a stack frame reference.
 */

void                emitter::emitDispFrameRef(int varx, int offs, int disp, bool asmfm)
{
    int         addr;
    bool        bEBP;

    printf("[");

    if  (!asmfm || !emitComp->lvaDoneFrameLayout)
    {
        if  (varx < 0)
            printf("T_%03u", -varx);
        else
            printf("L_%03u", +varx);

        if      (disp < 0)
                printf("-%d", -disp);
        else if (disp > 0)
                printf("+%d", +disp);
    }

    if  (emitComp->lvaDoneFrameLayout > 1)
    {
        if  (!asmfm)
            printf(" ");

        addr = emitComp->lvaFrameAddress(varx, &bEBP) + disp;

        if  (bEBP)
        {
            printf("EBP");

            if      (addr < 0)
                printf("-%02XH", -addr);
            else if (addr > 0)
                printf("+%02XH",  addr);
        }
        else
        {
            /* Adjust the offset by amount currently pushed on the stack */

            printf("ESP");

            if      (addr < 0)
                printf("-%02XH", -addr);
            else if (addr > 0)
                printf("+%02XH",  addr);

            if  (emitCurStackLvl)
                printf("+%02XH", emitCurStackLvl);
        }
    }

    printf("]");

    if  (varx >= 0 && varNames)
    {
        Compiler::LclVarDsc*varDsc;
        const   char *      varName;

        assert((unsigned)varx < emitComp->lvaCount);
        varDsc  = emitComp->lvaTable + varx;
        varName = emitComp->compLocalVarName(varx, offs);

        if  (varName)
        {
            printf("'%s", varName);

            if      (disp < 0)
                    printf("-%d", -disp);
            else if (disp > 0)
                    printf("+%d", +disp);

            printf("'");
        }
    }
}

/*****************************************************************************
 *
 *  Display an address mode.
 */

void                emitter::emitDispAddrMode(instrDesc *id, bool noDetail)
{
    bool            nsep = false;
    int             disp;

    unsigned        jtno;
    dataSection *   jdsc;

    /* The displacement field is in an unusual place for calls */

    disp = (id->idIns == INS_call) ? emitGetInsCIdisp(id)
                                   : emitGetInsAmdAny(id);

    /* Display a jump table label if this is a switch table jump */

    if  (id->idIns == INS_i_jmp)
    {
        int             offs = 0;

        /* Find the appropriate entry in the data section list */

        for (jdsc = emitConsDsc.dsdList, jtno = 0;
             jdsc;
             jdsc = jdsc->dsNext)
        {
            size_t          size = jdsc->dsSize;

            /* Is this a label table? */

            if  (size & 1)
            {
                size--;
                jtno++;

                if  (offs == id->idMemCookie)
                    break;
            }

            offs += size;
        }

        /* If we've found a matching entry then is a table jump */

        if  (jdsc)
        {
#ifdef RELOC_SUPPORT
            if (id->idInfo.idDspReloc)
            {
                printf("reloc ");
            }
#endif
            printf("J_%02u_%02u", Compiler::s_compMethodsCount, jtno);
        }

        disp -= id->idMemCookie;
    }

    printf("[");

    if  (id->idAddr.iiaAddrMode.amBaseReg != SR_NA)
    {
        printf("%s", emitRegName((emitRegs)id->idAddr.iiaAddrMode.amBaseReg));
        nsep = true;
    }

    if  (id->idAddr.iiaAddrMode.amIndxReg != SR_NA)
    {
        size_t          scale = emitDecodeScale(id->idAddr.iiaAddrMode.amScale);

        if  (nsep)
            printf("+");
        if  (scale > 1)
            printf("%u*", scale);
        printf("%s", emitRegName((emitRegs)id->idAddr.iiaAddrMode.amIndxReg));
        nsep = true;
    }

#ifdef RELOC_SUPPORT
    if ((id->idInfo.idDspReloc) && (id->idIns != INS_i_jmp))
    {
        if  (nsep)
            printf("+");
        printf("(reloc 0x%x)", disp);
    }
    else
#endif
    {
        if      (disp < 0)
        {
            if (disp > -1000)
                printf("%d", disp);
            else
                printf("-0x%x", -disp);
        }
        else if (disp > 0)
        {
            if  (nsep)
                printf("+");
            if (disp < 1000)
                printf("%d", disp);
            else
                printf("0x%x", disp);
        }
    }

    printf("]");

    if  (id->idClsCookie)
    {
        if  (id->idIns == INS_call)
            printf("%s", emitFncName((METHOD_HANDLE) id->idMemCookie));
        else
            printf("%s", emitFldName(id->idMemCookie, id->idClsCookie));
    }

    if  (id->idIns == INS_i_jmp && jdsc && !noDetail)
    {
        unsigned        cnt = (jdsc->dsSize - 1) / sizeof(void*);
        BasicBlock  * * bbp = (BasicBlock**)jdsc->dsCont;

        printf("\n\n    J_%02u_%02u LABEL   DWORD", Compiler::s_compMethodsCount, jtno);

        /* Display the label table (it's stored as "BasicBlock*" values) */

        do
        {
            insGroup    *   lab;

            /* Convert the BasicBlock* value to an IG address */

            lab = (insGroup*)emitCodeGetCookie(*bbp++); assert(lab);

            printf("\n            DD      G_%02u_%02u", Compiler::s_compMethodsCount, lab->igNum);
        }
        while (--cnt);
    }
}

/*****************************************************************************
 *
 *  If the given instruction is a shift, display the 2nd operand.
 */

void                emitter::emitDispShift(instruction ins, int cnt)
{
    switch (ins)
    {
    case INS_rcl_1:
    case INS_rcr_1:
    case INS_shl_1:
    case INS_shr_1:
    case INS_sar_1:
        printf(", 1");
        break;

    case INS_rcl:
    case INS_rcr:
    case INS_shl:
    case INS_shr:
    case INS_sar:
        printf(", CL");
        break;

    case INS_rcl_N:
    case INS_rcr_N:
    case INS_shl_N:
    case INS_shr_N:
    case INS_sar_N:
        printf(", %d", cnt);
        break;
    }
}

/*****************************************************************************
 *
 *  Display the epilog instructions.
 */

void                emitter::emitDispEpilog(instrDesc *id, unsigned offs = 0)
{
    BYTE    *       sp = emitEpilogCode;
    BYTE    *       ep = sp + emitEpilogSize;

    assert(id->idInsFmt == IF_EPILOG);
    assert(emitHaveEpilog);

    while (sp < ep)
    {
        unsigned        op1 = *(unsigned char*)sp;
        unsigned        op2 =  (unsigned short)MISALIGNED_RD_I2(sp);

        if  (offs)
            printf("%06X", offs + (sp - emitEpilogCode));
        else
            printf("      ");

        sp++;

        if      (op1 == (insCodeRR     (INS_pop) | insEncodeReg012(SR_EBX)))
        {
            printf("      pop     EBX\n");
        }
        else if (op1 == (insCodeRR     (INS_pop) | insEncodeReg012(SR_ECX)))
        {
            printf("      pop     ECX\n");
        }
        else if (op1 == (insCodeRR     (INS_pop) | insEncodeReg012(SR_ESI)))
        {
            printf("      pop     ESI\n");
        }
        else if (op1 == (insCodeRR     (INS_pop) | insEncodeReg012(SR_EDI)))
        {
            printf("      pop     EDI\n");
        }
        else if (op1 == (insCodeRR     (INS_pop) | insEncodeReg012(SR_EBP)))
        {
            printf("      pop     EBP\n");
        }
        else if (op1 == (insCodeMI     (INS_ret)))
        {
            printf("      ret     %u\n", *castto(sp, unsigned short*)++);
        }
        else if (op1 == (insCode       (INS_leave)))
        {
            printf("      leave\n");
        }
        else if (op1 == 0x64)           // FS segment override prefix
        {
            printf("      mov     FS:[0], ECX\n");
            op2 = *sp++; assert(op2 == 0x89);
            op2 = *sp++; assert(op2 == 0x0d);
            op2 = *sp++; assert(op2 == 0x00);
            op2 = *sp++; assert(op2 == 0x00);
            op2 = *sp++; assert(op2 == 0x00);
            op2 = *sp++; assert(op2 == 0x00);
        }
        else if (op2 == (insEncodeMIreg(INS_add, SR_ESP) | 1 | 2))
        {
            sp++;
            printf("      add     ESP, %d\n", *castto(sp, char*)++);
        }
        else if (op2 == (insEncodeMIreg(INS_add, SR_ESP) | 1))
        {
            sp++;
            printf("      add     ESP, %d\n", *castto(sp, int*)++);
        }
        else if (op2 == (insEncodeRMreg(INS_mov) | 1 /* w=1 */
                                     /* R/M */   | insEncodeReg345(SR_ESP) << 8
                                     /* Reg */   | insEncodeReg012(SR_EBP) << 8
                                     /* Mod */   | 0 << 14))
        {
            sp++;
            printf("      mov     ESP, EBP\n");
        }
        else if (op2 == (insCodeRM     (INS_lea) | 0 /* w=0 */
                                     /* R/M */   | insEncodeReg345(SR_ESP) << 8
                                     /* Reg */   | insEncodeReg012(SR_EBP) << 8
                                     /* Mod */   | 1 << 14))
        {
            sp++;
            int offset = *castto(sp, char*)++;
            printf("      lea     ESP, [EBP%s%d]\n",
                   (offset >= 0) ? "+" : "", offset);
        }
        else if (op2 == (insCodeRM     (INS_lea) | 0 /* w=0 */
                                     /* R/M */   | insEncodeReg345(SR_ESP) << 8
                                     /* Reg */   | insEncodeReg012(SR_EBP) << 8
                                     /* Mod */   | 2 << 14))
        {
            sp++;
            int offset = *castto(sp, int*)++;
            printf("      lea     ESP, [EBP%s%d]\n",
                   (offset >= 0) ? "+" : "", offset);
        }
        else if (op2 == (insCodeRM     (INS_mov) | 1 /* w=1 */
                                     /* R/M */   | insEncodeReg345(SR_ECX) << 8
                                     /* Reg */   | insEncodeReg012(SR_EBP) << 8
                                     /* Mod */   | 1 << 14))
        {
            sp++;
            int offset = *castto(sp, char*)++;
            printf("      mov     ECX, [EBP%S%d]\n",
                   (offset >= 0) ? "+" : "", offset);
        }
        else
        {
            printf("OOPS: Unrecognized epilog opcode: %02X/%04X\n", op1, op2);
            return;
        }
    }

    assert(sp == ep);
}

/*****************************************************************************
 *
 *  Display the given instruction.
 */

void                emitter::emitDispIns(instrDesc *id, bool isNew,
                                                        bool doffs,
                                                        bool asmfm, unsigned offs)
{
    emitAttr        attr;
    const   char *  sstr;

    instruction     ins = id->idInsGet();

#ifdef RELOC_SUPPORT
# define ID_INFO_DSP_RELOC ((bool) (id->idInfo.idDspReloc))
#else
# define ID_INFO_DSP_RELOC false
#endif
    /* Display a constant value if the instruction references one */

    if  (!isNew)
    {
        switch (id->idInsFmt)
        {
#ifndef OPT_IL_JIT
            int             offs;
#endif

        case IF_MRD_RRD:
        case IF_MWR_RRD:
        case IF_MRW_RRD:

        case IF_RRD_MRD:
        case IF_RWR_MRD:
        case IF_RRW_MRD:

        case IF_MRD_CNS:
        case IF_MWR_CNS:
        case IF_MRW_CNS:
        case IF_MRW_SHF:

        case IF_MRD:
        case IF_MWR:
        case IF_MRW:

        case IF_TRD_MRD:
        case IF_TWR_MRD:
        case IF_TRW_MRD:

//      case IF_MRD_TRD:
        case IF_MWR_TRD:
//      case IF_MRW_TRD:

        case IF_MRD_OFF:

#ifndef OPT_IL_JIT

            /* Is this actually a reference to a data section? */

            offs = Compiler::eeGetJitDataOffs(id->idAddr.iiaFieldHnd);

            if  (offs >= 0)
            {
                void    *   addr;

                /* Display a data section reference */

                if  (offs & 1)
                {
                    offs--;
                    assert((unsigned)offs < emitConsDsc.dsdOffs);
                    addr = emitConsBlock ? emitConsBlock + offs : NULL;
                }
                else
                {
                    assert((unsigned)offs < emitDataDsc.dsdOffs);
                    addr = emitDataBlock ? emitDataBlock + offs : NULL;
                }

#if 0
                /* Is the operand an integer or floating-point value? */

                bool isFP = false;

                if  (Compiler::instIsFP(id->idInsGet()))
                {
                    switch (id->idIns)
                    {
                    case INS_fild:
                    case INS_fildl:
                        break;

                    default:
                        isFP = true;
                        break;
                    }
                }

                if (offs & 1)
                    printf("@CNS%02u", offs);
                else
                    printf("@RWD%02u", offs);

                printf("      ");

                if  (addr)
                {
                    addr = 0;
                    // UNDONE:  This was busted by switching the order
                    //          in which we output the code block vs.
                    //          the data blocks -- when we get here,
                    //          the data block has not been filled in
                    //          yet, so we'll display garbage.

                    if  (isFP)
                    {
                        if  (emitDecodeSize(id->idOpSize) == EA_4BYTE)
                            printf("DF      %f \n", addr ? *(float   *)addr : 0);
                        else
                            printf("DQ      %lf\n", addr ? *(double  *)addr : 0);
                    }
                    else
                    {
                        if  (emitDecodeSize(id->idOpSize) <= EA_4BYTE)
                            printf("DD      %d \n", addr ? *(int     *)addr : 0);
                        else
                            printf("DQ      %D \n", addr ? *(__int64 *)addr : 0);
                    }
                }
#endif
            }
#endif
            break;
        }
    }

//  printf("[F=%s] "   , emitIfName(id->idInsFmt));
//  printf("INS#%03u: ", id->idNum);
//  printf("[S=%02u] " , emitCurStackLvl); if (isNew) printf("[M=%02u] ", emitMaxStackDepth);
//  printf("[S=%02u] " , emitCurStackLvl/sizeof(int));
//  printf("[A=%08X] " , emitSimpleStkMask);
//  printf("[A=%08X] " , emitSimpleByrefStkMask);
//  printf("[L=%02u] " , id->idCodeSize);

    if  (!dspEmit && !isNew && !asmfm)
        doffs = true;

    /* Special case: epilog "instruction" */

    if  (id->idInsFmt == IF_EPILOG && emitHaveEpilog)
    {
        emitDispEpilog(id, doffs ? offs : 0);
        return;
    }

    /* Display the instruction offset */

    emitDispInsOffs(offs, doffs);

    /* Display the instruction name */

    sstr = (id->idInsFmt == IF_EPILOG) ? "__epilog"
                                       : emitComp->genInsName(ins);

    printf("      %-8s", sstr);

    /* By now the size better be set to something */

    assert(emitInstCodeSz(id) || emitInstHasNoCode(ins));

    /* If this instruction has just been added, check its size */

    assert(isNew == false || (int)emitSizeOfInsDsc(id) == emitCurIGfreeNext - (BYTE*)id);

    /* Figure out the operand size */

    if       (id->idGCrefGet() == GCT_GCREF)
    {
        attr = EA_GCREF;
        sstr = "gword ptr ";
    }
    else if  (id->idGCrefGet() == GCT_BYREF)
    {
        attr = EA_BYREF;
        sstr = "bword ptr ";
    }
    else
    {
        attr = emitDecodeSize(id->idOpSize);
        sstr = emitComp->genSizeStr(attr);

        if (ins == INS_lea) {
            assert(attr == EA_4BYTE);
            sstr = "";
        }
    }

    /* Now see what instruction format we've got */

    switch (id->idInsFmt)
    {
        int             val;
        int             offs;
        CnsVal          cnsVal;

        const char  *   methodName;
        const char  *    className;

    case IF_CNS:
        val = emitGetInsSC(id);
#ifdef RELOC_SUPPORT
        if (id->idInfo.idCnsReloc)
            printf("reloc 0x%x", val);
        else
#endif
//      if  (id->idStrLit)
//          printf("offset _S_%08X", val);
//      else
        {
            if ((val > -1000) && (val < 1000))
                printf("%d", val);
            else if (val > 0)
                printf("0x%x", val);
            else // (val < 0)
                printf("-0x%x", -val);
        }
        break;

    case IF_ARD:
    case IF_AWR:
    case IF_ARW:

    case IF_TRD_ARD:
    case IF_TWR_ARD:
    case IF_TRW_ARD:

//  case IF_ARD_TRD:
    case IF_AWR_TRD:
//  case IF_ARW_TRD:

        if  (ins == INS_call && id->idInfo.idCallRegPtr)
        {
            printf("%s", emitRegName((emitRegs)id->idAddr.iiaAddrMode.amBaseReg));
            break;
        }

        printf("%s", sstr);
        emitDispAddrMode(id, isNew);

        if  (ins == INS_call)
        {
            assert(id->idInsFmt == IF_ARD);

            /* Ignore indirect calls */

            if  (id->idMemCookie == 0)
                break;

            assert(id->idMemCookie);

            /* This is a virtual call */

            methodName = emitComp->eeGetMethodName((METHOD_HANDLE)id->idMemCookie, &className);

            printf("%s.%s", className, methodName);
        }
        break;

    case IF_RRD_ARD:
    case IF_RWR_ARD:
    case IF_RRW_ARD:
        if  (ins == INS_movsx || ins == INS_movzx)
        {
            printf("%s, %s", emitRegName((emitRegs)id->idReg, EA_4BYTE), sstr);
        }
        else
        {
            printf("%s, %s", emitRegName((emitRegs)id->idReg, attr), sstr);
        }
        emitDispAddrMode(id);
        break;

    case IF_ARD_RRD:
    case IF_AWR_RRD:
    case IF_ARW_RRD:

        printf("%s", sstr);
        emitDispAddrMode(id);
        printf(", %s", emitRegName(id->idRegGet(), attr));
        break;

    case IF_ARD_CNS:
    case IF_AWR_CNS:
    case IF_ARW_CNS:
    case IF_ARW_SHF:

        printf("%s", sstr);
        emitDispAddrMode(id);
        emitGetInsAmdCns(id, &cnsVal);
        val = cnsVal.cnsVal;
        if  (id->idInsFmt == IF_ARW_SHF)
            emitDispShift(ins, val);
        else
        {
#ifdef RELOC_SUPPORT
            if (cnsVal.cnsReloc)
                printf(", reloc 0x%x", val);
            else
#endif
            if ((val > -1000) && (val < 1000))
                printf(", %d", val);
            else if (val > 0)
                printf(", 0x%x", val);
            else // val <= -1000
                printf(", -0x%x", -val);
        }
        break;

    case IF_SRD:
    case IF_SWR:
    case IF_SRW:

    case IF_TRD_SRD:
    case IF_TWR_SRD:
    case IF_TRW_SRD:

//  case IF_SRD_TRD:
    case IF_SWR_TRD:
//  case IF_SRW_TRD:

        printf("%s", sstr);

        if  (ins == INS_pop) emitCurStackLvl -= sizeof(int);

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                       id->idAddr.iiaLclVar.lvaRefOfs,
                       id->idAddr.iiaLclVar.lvaOffset, asmfm);

        if  (ins == INS_pop) emitCurStackLvl += sizeof(int);

        emitDispShift(ins);
        break;

    case IF_SRD_RRD:
    case IF_SWR_RRD:
    case IF_SRW_RRD:

        printf("%s", sstr);

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                       id->idAddr.iiaLclVar.lvaRefOfs,
                       id->idAddr.iiaLclVar.lvaOffset, asmfm);

        printf(", %s", emitRegName(id->idRegGet(), attr));
        break;

    case IF_SRD_CNS:
    case IF_SWR_CNS:
    case IF_SRW_CNS:
    case IF_SRW_SHF:

        printf("%s", sstr);

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                         id->idAddr.iiaLclVar.lvaRefOfs,
                         id->idAddr.iiaLclVar.lvaOffset, asmfm);

        emitGetInsCns(id, &cnsVal);
        val = cnsVal.cnsVal;
#ifdef RELOC_SUPPORT
        if (cnsVal.cnsReloc)
            printf(", reloc 0x%x", val);
        else
#endif
        if  (id->idInsFmt == IF_SRW_SHF)
            emitDispShift(ins, val);
        else if ((val > -1000) && (val < 1000))
            printf(", %d", val);
        else if (val > 0)
            printf(", 0x%x", val);
        else // val <= -1000
            printf(", -0x%x", -val);
        break;

    case IF_RRD_SRD:
    case IF_RWR_SRD:
    case IF_RRW_SRD:

        if  (ins == INS_movsx || ins == INS_movzx)
        {
            printf("%s, %s", emitRegName(id->idRegGet(), EA_4BYTE), sstr);
        }
        else
        {
            printf("%s, %s", emitRegName(id->idRegGet(), attr), sstr);
        }

        emitDispFrameRef(id->idAddr.iiaLclVar.lvaVarNum,
                       id->idAddr.iiaLclVar.lvaRefOfs,
                       id->idAddr.iiaLclVar.lvaOffset, asmfm);

        break;

    case IF_RRD_RRD:
    case IF_RWR_RRD:
    case IF_RRW_RRD:

        if  (ins == INS_movsx || ins == INS_movzx)
        {
            printf("%s, %s", emitRegName(id->idRegGet(),  EA_4BYTE),
                             emitRegName(id->idRg2Get(),  attr));
        }
        else
        {
            printf("%s, %s", emitRegName(id->idRegGet(),  attr),
                             emitRegName(id->idRg2Get(),  attr));
        }
        break;

    case IF_RRW_RRW:
        assert(ins == INS_xchg);
        printf("%s,", emitRegName(id->idRegGet(), attr));
        printf(" %s", emitRegName(id->idRg2Get(), attr));
        break;

    case IF_RRW_RRW_CNS:
        printf("%s,", emitRegName(id->idRegGet(), attr));
        printf(" %s", emitRegName(id->idRg2Get(), attr));
        val = emitGetInsSC(id);
#ifdef RELOC_SUPPORT
        if (id->idInfo.idCnsReloc)
            printf(", reloc 0x%x", val);
        else
#endif
        if ((val > -1000) && (val < 1000))
            printf(", %d", val);
        else if (val > 0)
            printf(", 0x%x", val);
        else // val <= -1000
            printf(", -0x%x", -val);
        break;

    case IF_RRD:
    case IF_RWR:
    case IF_RRW:
        printf("%s", emitRegName(id->idRegGet(), attr));
        emitDispShift(ins);
        break;

    case IF_RRW_SHF:
        printf("%s", emitRegName(id->idRegGet()));
        emitDispShift(ins, emitGetInsSC(id));
        break;

    case IF_RRD_MRD:
    case IF_RWR_MRD:
    case IF_RRW_MRD:

        printf("%s, %s", emitRegName(id->idRegGet(), attr), sstr);
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        break;

    case IF_RWR_MRD_OFF:

        printf("%s, %s", emitRegName(id->idRegGet(), attr), "offset");
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        break;

    case IF_MRD_RRD:
    case IF_MWR_RRD:
    case IF_MRW_RRD:

        printf("%s", sstr);
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        printf(", %s", emitRegName(id->idRegGet(), attr));
        break;

    case IF_MRD_CNS:
    case IF_MWR_CNS:
    case IF_MRW_CNS:
    case IF_MRW_SHF:

        printf("%s", sstr);
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        emitGetInsDcmCns(id, &cnsVal);
        val = cnsVal.cnsVal;
#ifdef RELOC_SUPPORT
        if (cnsVal.cnsReloc)
            printf(", reloc 0x%x", val);
        else
#endif
        if  (id->idInsFmt == IF_MRW_SHF)
            emitDispShift(ins, val);
        else if ((val > -1000) && (val < 1000))
            printf(", %d", val);
        else if (val > 0)
            printf(", 0x%x", val);
        else // val <= -1000
            printf(", -0x%x", -val);
        break;

    case IF_MRD:
    case IF_MWR:
    case IF_MRW:

    case IF_TRD_MRD:
    case IF_TWR_MRD:
    case IF_TRW_MRD:

//  case IF_MRD_TRD:
    case IF_MWR_TRD:
//  case IF_MRW_TRD:

        printf("%s", sstr);
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        emitDispShift(ins);
        break;

    case IF_MRD_OFF:

        printf("offset ");
        offs = emitGetInsDsp(id);
        emitDispClsVar(id->idAddr.iiaFieldHnd, offs, ID_INFO_DSP_RELOC);
        break;

    case IF_RRD_CNS:
    case IF_RWR_CNS:
    case IF_RRW_CNS:
        printf("%s, ", emitRegName((emitRegs)id->idReg, attr));
        val = emitGetInsSC(id);
#ifdef RELOC_SUPPORT
        if (id->idInfo.idCnsReloc)
            printf("reloc 0x%x", val);
        else
#endif
        if ((val > -1000) && (val < 1000))
            printf("%d", val);
        else if (val > 0)
            printf("0x%x", val);
        else // val <= -1000
            printf("-0x%x", -val);
        break;

    case IF_TRD_FRD:
    case IF_TWR_FRD:
    case IF_TRW_FRD:
        switch (ins)
        {
        case INS_fld:
        case INS_fxch:
            break;

        default:
            printf("%s, ", emitFPregName(0));
            break;
        }
        printf("%s", emitFPregName(id->idReg));
        break;

    case IF_FRD_TRD:
    case IF_FWR_TRD:
    case IF_FRW_TRD:
        printf("%s", emitFPregName(id->idReg));
        if  (ins != INS_fst && ins != INS_fstp)
            printf(", %s", emitFPregName(0));
        break;

    case IF_LABEL:

        if  (((instrDescJmp*)id)->idjShort)
            printf("SHORT ");

        if  (id->idInfo.idBound)
        {
            printf("G_%02u_%02u", Compiler::s_compMethodsCount, id->idAddr.iiaIGlabel->igNum);
        }
        else
        {
            printf("L_%02u_%02u", Compiler::s_compMethodsCount, id->idAddr.iiaBBlabel->bbNum);
        }
        break;

    case IF_RWR_METHOD:
        if (id->idIns == INS_mov)
            printf("%s, ", emitRegName((emitRegs)id->idReg, attr));

        // Fall through ...

    case IF_METHOD:
    case IF_METHPTR:
        methodName = emitComp->eeGetMethodName(id->idAddr.iiaMethHnd, &className);

        if  (id->idInsFmt == IF_METHPTR) printf("[");

        if  (className == NULL)
            printf("%s", methodName);
        else
            printf("%s.%s", className, methodName);

        if  (id->idInsFmt == IF_METHPTR) printf("]");
        break;

    case IF_TRD:
    case IF_TWR:
    case IF_TRW:
    case IF_NONE:
    case IF_EPILOG:
        break;

    default:

        printf("unexpected format %s", emitIfName(id->idInsFmt));
        BreakIfDebuggerPresent();
        break;
    }

    printf("\n");
}

/*****************************************************************************/
#endif
/*****************************************************************************
 *
 *  Output an instruction involving an address mode.
 */

BYTE    *  emitter::emitOutputAM  (BYTE *dst, instrDesc *id, unsigned code,
                                                             CnsVal*  addc)
{
    emitRegs        reg;
    emitRegs        rgx;
    int             dsp;
    bool            dspInByte;
    bool            dspIsZero;

    instruction     ins  = id->idInsGet();
    emitAttr        size = emitDecodeSize(id->idOpSize);
    size_t          opsz = EA_SIZE_IN_BYTES(size);

    /* Get the base/index registers */

    reg = (emitRegs)id->idAddr.iiaAddrMode.amBaseReg;
    rgx = (emitRegs)id->idAddr.iiaAddrMode.amIndxReg;

    /* For INS_call the instruction size is actually the return value size */

    if  (ins == INS_call)
    {
        /* Special case: call via a register */

        if  (id->idInfo.idCallRegPtr)
        {
            dst += emitOutputWord(dst, insEncodeMRreg(INS_call, reg));
            goto DONE;
        }

        /* The displacement field is in an unusual place for calls */

        dsp = emitGetInsCIdisp(id);
        goto GOT_DSP;
    }

    /* Is there a large constant operand? */

    if  (addc && (size > EA_1BYTE))
    {
        long cval = addc->cnsVal;

        /* Does the constant fit in a byte? */
        if  ((signed char)cval == cval &&
#ifdef RELOC_SUPPORT
             addc->cnsReloc == false   &&
#endif
             ins != INS_mov      &&
             ins != INS_test)
        {
            if  (id->idInsFmt != IF_ARW_SHF)
                code |= 2;

            opsz = 1;
        }
    }

    /* Is this a 'big' opcode? */

    if  (code & 0x00FF0000)
    {
        /* Output the highest byte of the opcode */

        dst += emitOutputByte(dst, code >> 16); code &= 0x0000FFFF;

        /* Use the large version if this is not a byte */

        if ((size != EA_1BYTE) && (ins != INS_imul))
            code++;
    }
    else if (Compiler::instIsFP(ins))
    {
        assert(size == EA_4BYTE   ||
               size == EA_8BYTE   ||
               ins  == INS_fldcw  ||
               ins  == INS_fnstcw);

        if  (size == EA_8BYTE)
            code += 4;
    }
    else
    {
        /* Is the operand size larger than a byte? */

        switch (size)
        {
        case EA_1BYTE:
            break;

        case EA_2BYTE:

            /* Output a size prefix for a 16-bit operand */

            dst += emitOutputByte(dst, 0x66);

            // Fall through ...

        case EA_4BYTE:

            /* Set the 'w' bit to get the large version */

            code |= 0x1;
            break;

        case EA_8BYTE:

            /* Double operand - set the appropriate bit */

            code |= 0x04;
            break;

        default:
            assert(!"unexpected size");
        }
    }

    /* Get the displacement value */

    dsp = emitGetInsAmdAny(id);

GOT_DSP:

    dspInByte = ((signed char)dsp == (int)dsp);
    dspIsZero = (dsp == 0);

#ifdef RELOC_SUPPORT
    if (id->idInfo.idDspReloc)
    {
        dspInByte = false;      // relocs can't be placed in a byte
    }
#endif

    /* Is there a [scaled] index component? */

    if  (rgx == SR_NA)
    {
        /* The address is of the form "[reg+disp]" */

        switch (reg)
        {
        case SR_NA:

            /* The address is of the form "[disp]" */

            dst += emitOutputWord(dst, code | 0x0500);
            dst += emitOutputLong(dst, dsp);

#ifdef RELOC_SUPPORT
            if (id->idInfo.idDspReloc)
            {
                emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
            }
#endif
            break;

        case SR_EBP:

            /* Does the offset fit in a byte? */

            if  (dspInByte)
            {
                dst += emitOutputWord(dst, code | 0x4500);
                dst += emitOutputByte(dst, dsp);
            }
            else
            {
                dst += emitOutputWord(dst, code | 0x8500);
                dst += emitOutputLong(dst, dsp);

#ifdef RELOC_SUPPORT
                if (id->idInfo.idDspReloc)
                {
                    emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                }
#endif
            }

            break;

        case SR_ESP:
#ifndef OPT_IL_JIT
            //
            // This assert isn't too helpful from the OptJit point of view
            //
            // a better question is why is it here at all
            //
            assert((ins == INS_lea)  ||
                   (ins == INS_mov)  ||
                   (ins == INS_test) ||
                   (ins == INS_fld   && dspIsZero) ||
                   (ins == INS_fstp  && dspIsZero) ||
                   (ins == INS_fistp && dspIsZero));
#endif

            /* Is the offset 0 or does it at least fit in a byte? */

            if  (dspIsZero)
            {
                dst += emitOutputWord(dst, code | 0x0400);
                dst += emitOutputByte(dst, 0x24);
            }
            else if     (dspInByte)
            {
                dst += emitOutputWord(dst, code | 0x4400);
                dst += emitOutputByte(dst, 0x24);
                dst += emitOutputByte(dst, dsp);
            }
            else
            {
                dst += emitOutputWord(dst, code | 0x8400);
                dst += emitOutputByte(dst, 0x24);
                dst += emitOutputLong(dst, dsp);
#ifdef RELOC_SUPPORT
                if (id->idInfo.idDspReloc)
                {
                    emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                }
#endif
            }

            break;

        default:

            /* Put the register in the opcode */

            code |= insEncodeReg012(reg) << 8;

            /* Is there a displacement? */

            if  (dspIsZero)
            {
                /* This is simply "[reg]" */

                dst += emitOutputWord(dst, code);
            }
            else
            {
                /* This is [reg + dsp]" -- does the offset fit in a byte? */

                if  (dspInByte)
                {
                    dst += emitOutputWord(dst, code | 0x4000);
                    dst += emitOutputByte(dst, dsp);
                }
                else
                {
                    dst += emitOutputWord(dst, code | 0x8000);
                    dst += emitOutputLong(dst, dsp);
#ifdef RELOC_SUPPORT
                    if (id->idInfo.idDspReloc)
                    {
                        emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                    }
#endif
                }
            }

            break;
        }
    }
    else
    {
        unsigned    regByte;

        /* We have a scaled index operand */

        size_t      mul = emitDecodeScale(id->idAddr.iiaAddrMode.amScale);

        /* Is the index operand scaled? */

        if  (mul > 1)
        {
            /* Is there a base register? */

            if  (reg != SR_NA)
            {
                /* The address is "[reg + {2/4/8} * rgx + icon]" */

                regByte = insEncodeReg012(reg) |
                          insEncodeReg345(rgx) | insSSval(mul);

                /* Emit [ebp + {2/4/8} * rgz] as [ebp + {2/4/8} * rgx + 0] */

                if  (dspIsZero && reg != SR_EBP)
                {
                    /* The address is "[reg + {2/4/8} * rgx]" */

                    dst += emitOutputWord(dst, code | 0x0400);
                    dst += emitOutputByte(dst, regByte);
                }
                else
                {
                    /* The address is "[reg + {2/4/8} * rgx + disp]" */

                    if  (dspInByte)
                    {
                        dst += emitOutputWord(dst, code | 0x4400);
                        dst += emitOutputByte(dst, regByte);
                        dst += emitOutputByte(dst, dsp);
                    }
                    else
                    {
                        dst += emitOutputWord(dst, code | 0x8400);
                        dst += emitOutputByte(dst, regByte);
                        dst += emitOutputLong(dst, dsp);
#ifdef RELOC_SUPPORT
                        if (id->idInfo.idDspReloc)
                        {
                            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                        }
#endif
                    }
                }
            }
            else
            {
                /* The address is "[{2/4/8} * rgx + icon]" */

                regByte = insEncodeReg012(SR_EBP) |
                          insEncodeReg345( rgx  ) | insSSval(mul);

                dst += emitOutputWord(dst, code | 0x0400);
                dst += emitOutputByte(dst, regByte);

                /* Special case: jump through a jump table */
                if  (ins == INS_i_jmp)
                    dsp += (int)emitConsBlock;

                dst += emitOutputLong(dst, dsp);
#ifdef RELOC_SUPPORT
                if (id->idInfo.idDspReloc)
                {
                    emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                }
#endif
            }
        }
        else
        {
            /* The address is "[reg+rgx+dsp]" */

            regByte = insEncodeReg012(reg) |
                      insEncodeReg345(rgx);

            if  (dspIsZero && reg != SR_EBP)
            {
                /* This is [reg+rgx]" */

                dst += emitOutputWord(dst, code | 0x0400);
                dst += emitOutputByte(dst, regByte);
            }
            else
            {
                /* This is [reg+rgx+dsp]" -- does the offset fit in a byte? */

                if  (dspInByte)
                {
                    dst += emitOutputWord(dst, code | 0x4400);
                    dst += emitOutputByte(dst, regByte);
                    dst += emitOutputByte(dst, dsp);
                }
                else
                {
                    dst += emitOutputWord(dst, code | 0x8400);
                    dst += emitOutputByte(dst, regByte);
                    dst += emitOutputLong(dst, dsp);
#ifdef RELOC_SUPPORT
                    if (id->idInfo.idDspReloc)
                    {
                        emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                    }
#endif
                }
            }
        }
    }

    /* Now generate the constant value, if present */

    if  (addc)
    {
        long cval = addc->cnsVal;
        switch (opsz)
        {
        case 0:
        case 4:
        case 8: dst += emitOutputLong(dst, cval); break;
        case 2: dst += emitOutputWord(dst, cval); break;
        case 1: dst += emitOutputByte(dst, cval); break;

        default:
            assert(!"unexpected operand size");
        }

#ifdef RELOC_SUPPORT
        if (addc->cnsReloc)
        {
            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
            assert(opsz == 4);
        }
#endif
    }

DONE:

    /* Does this instruction operate on a GC ref value? */

    if  (id->idGCref)
    {
        switch (id->idInsFmt)
        {
        case IF_ARD:
        case IF_AWR:
        case IF_ARW:
            break;

        case IF_RRD_ARD:
            break;

        case IF_RWR_ARD:
            emitGCregLiveUpd(id->idGCrefGet(), id->idRegGet(), dst);
            break;

        case IF_RRW_ARD:
            assert(id->idGCrefGet() == GCT_BYREF);

#ifdef DEBUG
            regMaskTP regMask;
            regMask = emitRegMask(reg);

            // r1 could have been a GCREF as GCREF + int=BYREF
            //                            or BYREF+/-int=BYREF
            assert(((regMask & emitThisGCrefRegs) && (ins == INS_add                  )) ||
                   ((regMask & emitThisByrefRegs) && (ins == INS_add || ins == INS_sub)));
#endif
            // Mark it as holding a GCT_BYREF
            emitGCregLiveUpd(GCT_BYREF, id->idRegGet(), dst);
            break;

        case IF_ARD_RRD:
        case IF_AWR_RRD:
            break;

        case IF_ARD_CNS:
        case IF_AWR_CNS:
            break;

        case IF_ARW_RRD:
        case IF_ARW_CNS:
            assert(id->idGCrefGet() == GCT_BYREF && (ins == INS_add || ins == INS_sub));
            break;

        default:
#ifdef  DEBUG
            emitDispIns(id, false, false, false);
#endif
            assert(!"unexpected GC ref instruction format");
        }
    }
    else
    {
        switch (id->idInsFmt)
        {
        case IF_RWR_ARD:
            emitGCregDeadUpd(id->idRegGet(), dst);
            break;
        }
    }

    return  dst;
}

/*****************************************************************************
 *
 *  Output an instruction involving a stack frame value.
 */

BYTE    *  emitter::emitOutputSV  (BYTE *dst, instrDesc *id, unsigned code,
                                                             CnsVal*  addc)
{
    int             adr;
    int             dsp;
    bool            EBPbased;
    bool            dspInByte;
    bool            dspIsZero;

    emitAttr        size = emitDecodeSize(id->idOpSize);
    size_t          opsz = EA_SIZE_IN_BYTES(size);

    assert(id->idIns != INS_imul || id->idReg == SR_EAX || size == EA_4BYTE);

    /* Is there a large constant operand? */

    if  (addc && (size > EA_1BYTE))
    {
        long cval = addc->cnsVal;
        /* Does the constant fit in a byte? */
        if  ((signed char)cval == cval &&
#ifdef RELOC_SUPPORT
             addc->cnsReloc == false   &&
#endif
             id->idIns != INS_mov      &&
             id->idIns != INS_test)
        {
            if  (id->idInsFmt != IF_SRW_SHF)
                code |= 2;

            opsz = 1;
        }
    }

    /* Is this a 'big' opcode? */

    if  (code & 0x00FF0000)
    {
        /* Output the highest byte of the opcode */

        dst += emitOutputByte(dst, code >> 16); code &= 0x0000FFFF;

        /* Use the large version if this is not a byte */

        if ((size != EA_1BYTE) && (id->idIns != INS_imul))
            code |= 0x1;
    }
    else if (Compiler::instIsFP((instruction)id->idIns))
    {
        assert(size == EA_4BYTE || size == EA_8BYTE);

        if  (size == EA_8BYTE)
            code += 4;
    }
    else
    {
        /* Is the operand size larger than a byte? */

        switch (size)
        {
        case EA_1BYTE:
            break;

        case EA_2BYTE:

            /* Output a size prefix for a 16-bit operand */

            dst += emitOutputByte(dst, 0x66);

            // Fall through ...

        case EA_4BYTE:

            /* Set the 'w' size bit to indicate 32-bit operation
             * Note that incrementing "code" for INS_call (0xFF) would
             * overflow, whereas setting the lower bit to 1 just works out */

            code |= 0x01;
            break;

        case EA_8BYTE:

            /* Double operand - set the appropriate bit */

            code |= 0x04;
            break;

        default:
            assert(!"unexpected size");
        }
    }

    /* Figure out the variable's frame position */

    int varNum = id->idAddr.iiaLclVar.lvaVarNum;

    adr = emitComp->lvaFrameAddress(varNum, &EBPbased);
    dsp = adr + id->idAddr.iiaLclVar.lvaOffset;

    dspInByte = ((signed char)dsp == (int)dsp);
    dspIsZero = (dsp == 0);

#ifdef RELOC_SUPPORT
    /* for stack varaibles the dsp should never be a reloc */
    assert(id->idInfo.idDspReloc == 0);
#endif

    if  (EBPbased)
    {
        /* EBP-based variable: does the offset fit in a byte? */

        if  (dspInByte)
        {
            dst += emitOutputWord(dst, code | 0x4500);
            dst += emitOutputByte(dst, dsp);
        }
        else
        {
            dst += emitOutputWord(dst, code | 0x8500);
            dst += emitOutputLong(dst, dsp);
        }
    }
    else
    {
        /* Adjust the offset by the amount currently pushed on the CPU stack */

        dsp += emitCurStackLvl;

        dspInByte = ((signed char)dsp == (int)dsp);
        dspIsZero = (dsp == 0);

        /* Does the offset fit in a byte? */

        if (dspInByte)
        {
            if  (dspIsZero)
            {
                dst += emitOutputWord(dst, code | 0x0400);
                dst += emitOutputByte(dst, 0x24);
            }
            else
            {
                dst += emitOutputWord(dst, code | 0x4400);
                dst += emitOutputByte(dst, 0x24);
                dst += emitOutputByte(dst, dsp);
            }
        }
        else
        {
            dst += emitOutputWord(dst, code | 0x8400);
            dst += emitOutputByte(dst, 0x24);
            dst += emitOutputLong(dst, dsp);
        }
    }

    /* Now generate the constant value, if present */

    if  (addc)
    {
        long cval = addc->cnsVal;
        switch (opsz)
        {
        case 0:
        case 4:
        case 8: dst += emitOutputLong(dst, cval); break;
        case 2: dst += emitOutputWord(dst, cval); break;
        case 1: dst += emitOutputByte(dst, cval); break;

        default:
            assert(!"unexpected operand size");
        }

#ifdef RELOC_SUPPORT
        if (addc->cnsReloc)
        {
            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
            assert(opsz == 4);
        }
#endif
    }

    /* Does this instruction operate on a GC ref value? */

    if  (id->idGCref)
    {
        switch (id->idInsFmt)
        {
        case IF_SRD:
            /* Read  stack                    -- no change */
            break;

        case IF_SWR:
            /* Write stack                    -- GC var may be born */
            emitGCvarLiveUpd(adr, varNum, id->idGCrefGet(), dst);
            break;

        case IF_SRD_CNS:
            /* Read  stack                    -- no change */
            break;

        case IF_SWR_CNS:
            /* Write stack                    -- no change */
            break;

        case IF_SRD_RRD:
        case IF_RRD_SRD:
            /* Read  stack   , read  register -- no change */
            break;

        case IF_RWR_SRD:

            /* Read  stack   , write register -- GC reg may be born */

#if !USE_FASTCALL // For fastcall, "this" is in REG_ARG_0 on entry, not on stk

            if  (emitIGisInProlog(emitCurIG) &&
                 emitComp->lvaIsThisArg(id->idAddr.iiaLclVar.lvaVarNum))
            {
                /* We're loading a "this" argument in the prolog */

                if  (emitFullGCinfo)
                {
                    emitGCregLiveSet(id->idGCrefGet(), emitRegMask(id->idRegGet()), dst, true);
                    break;
                }
            }
#endif

            emitGCregLiveUpd(id->idGCrefGet(), id->idRegGet(), dst);
            break;

        case IF_SWR_RRD:
            /* Read  register, write stack    -- GC var may be born */
            emitGCvarLiveUpd(adr, varNum, id->idGCrefGet(), dst);
            break;

        case IF_RRW_SRD:

            /* This must be "or reg, [ptr]" */

            assert(id->idIns == INS_or);
            emitGCvarLiveUpd(adr, varNum, id->idGCrefGet(), dst);
            break;

        case IF_SRW:
            break;

        case IF_SRW_CNS:
        case IF_SRW_RRD:

            /* These should never occur with GC refs */

        default:
#ifdef  DEBUG
            emitDispIns(id, false, false, false);
#endif
            assert(!"unexpected GC ref instruction format");
        }
    }
    else
    {
        switch (id->idInsFmt)
        {
        case IF_RWR_SRD:
        case IF_RRW_SRD:
            emitGCregDeadUpd(id->idRegGet(), dst);
            break;
        }
    }

    return  dst;
}

/*****************************************************************************
 *
 *  Output an instruction with a static data member (class variable).
 */

BYTE    *  emitter::emitOutputCV  (BYTE *dst, instrDesc *id, unsigned code,
                                                             CnsVal*  addc)
{
    BYTE    *       addr;
    FIELD_HANDLE    fldh;
    int             offs;
    int             doff;

    emitAttr        size = emitDecodeSize(id->idOpSize);
    size_t          opsz = EA_SIZE_IN_BYTES(size);

    /* Get hold of the field handle and offset */

    fldh = id->idAddr.iiaFieldHnd;
    offs = emitGetInsDsp(id);

    /* Special case: mov reg, fs:[ddd] */

    if (fldh == FLD_GLOBAL_FS)
        dst += emitOutputByte(dst, 0x64);

    /* Is there a large constant operand? */

    if  (addc && (size > EA_1BYTE))
    {
        long cval = addc->cnsVal;
        /* Does the constant fit in a byte? */
        if  ((signed char)cval == cval &&
#ifdef RELOC_SUPPORT
             addc->cnsReloc == false   &&
#endif
             id->idIns != INS_mov      &&
             id->idIns != INS_test)
        {
            if  (id->idInsFmt != IF_MRW_SHF)
                code |= 2;

            opsz = 1;
        }
    }
    else
    {
        /* Special case: "mov eax, [addr]" and "mov [addr], eax" */

        if  (id->idIns == INS_mov && id->idReg == SR_EAX)
        {
            switch (id->idInsFmt)
            {
            case IF_RWR_MRD:

                assert(code == (insCodeRM(id->idIns) | (insEncodeReg345(SR_EAX) << 8) | 0x0500));

                dst += emitOutputByte(dst, 0xA1);
                goto ADDR;

            case IF_MWR_RRD:

                assert(code == (insCodeMR(id->idIns) | (insEncodeReg345(SR_EAX) << 8) | 0x0500));

                dst += emitOutputByte(dst, 0xA3);
                goto ADDR;
            }
        }
    }

    /* Is this a 'big' opcode? */

    if  (code & 0x00FF0000)
    {
        dst += emitOutputByte(dst, code >> 16); code &= 0x0000FFFF;

        if ((id->idIns == INS_movsx || id->idIns == INS_movzx) &&
             size      != EA_1BYTE)
        {
            // movsx and movzx are 'big' opcodes but also have the 'w' bit
            code++;
        }
    }
    else if (Compiler::instIsFP((instruction)id->idIns))
    {
        assert(size == EA_4BYTE || size == EA_8BYTE);

        if  (size == EA_8BYTE)
            code += 4;
    }
    else
    {
        /* Is the operand size larger than a byte? */

        switch (size)
        {
        case EA_1BYTE:
            break;

        case EA_2BYTE:

            /* Output a size prefix for a 16-bit operand */

            dst += emitOutputByte(dst, 0x66);

            // Fall through ...

        case EA_4BYTE:

            /* Set the 'w' bit to get the large version */

            code |= 0x1;
            break;

        case EA_8BYTE:

            /* Double operand - set the appropriate bit */

            code |= 0x04;
            break;

        default:
            assert(!"unexpected size");
        }
    }

    if  (id->idInsFmt == IF_MRD_OFF ||
         id->idInsFmt == IF_RWR_MRD_OFF)
        dst += emitOutputByte(dst, code);
    else
        dst += emitOutputWord(dst, code);

ADDR:

    /* Do we have a constant or a static data member? */

    doff = Compiler::eeGetJitDataOffs(fldh);
    if  (doff >= 0)
    {
        /* Is this the constant or data block? */

        if  (doff & 1)
            addr = emitConsBlock + doff - 1;
        else
            addr = emitDataBlock + doff;
    }
    else
    {

        /* Special case: mov reg, fs:[ddd] or mov reg, [ddd] */

        if (fldh == FLD_GLOBAL_DS || fldh == FLD_GLOBAL_FS)
            addr = NULL;
        else
        {
#ifdef  NOT_JITC
            addr = (BYTE *)emitComp->eeGetFieldAddress(fldh,
                                                       NULL); // @TODO: Support instal-o-jit
            if (addr == NULL)
                fatal(ERRinternal, "could not obtain address of static field", "");
#else
            addr = (BYTE *)fldh;
#endif
        }
    }

    dst += emitOutputLong(dst, (int)(addr + offs));
#ifdef RELOC_SUPPORT
    if (id->idInfo.idDspReloc)
    {
        emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
    }
#endif

    /* Now generate the constant value, if present */

    if  (addc)
    {
        long cval = addc->cnsVal;
        switch (opsz)
        {
        case 0:
        case 4:
        case 8: dst += emitOutputLong(dst, cval); break;
        case 2: dst += emitOutputWord(dst, cval); break;
        case 1: dst += emitOutputByte(dst, cval); break;

        default:
            assert(!"unexpected operand size");
        }
#ifdef RELOC_SUPPORT
        if (addc->cnsReloc)
        {
            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
            assert(opsz == 4);
        }
#endif
    }

    /* Does this instruction operate on a GC ref value? */

    if  (id->idGCref)
    {
        switch (id->idInsFmt)
        {
        case IF_MRD:
        case IF_MRW:
        case IF_MWR:
            break;

        case IF_RRD_MRD:
            break;

        case IF_RWR_MRD:
            emitGCregLiveUpd(id->idGCrefGet(), id->idRegGet(), dst);
            break;

        case IF_MRD_RRD:
        case IF_MWR_RRD:
        case IF_MRW_RRD:
            break;

        case IF_MRD_CNS:
        case IF_MWR_CNS:
        case IF_MRW_CNS:
            break;

        case IF_RRW_MRD:

        default:
#ifdef  DEBUG
            emitDispIns(id, false, false, false);
#endif
            assert(!"unexpected GC ref instruction format");
        }
    }
    else
    {
        switch (id->idInsFmt)
        {
        case IF_RWR_MRD:
            emitGCregDeadUpd(id->idRegGet(), dst);
            break;
        }
    }

    return  dst;
}

/*****************************************************************************
 *
 *  Output an instruction with one register operand.
 */

BYTE    *           emitter::emitOutputR(BYTE *dst, instrDesc *id)
{
    unsigned        code;

    instruction     ins  = id->idInsGet();
    emitRegs        reg  = id->idRegGet();
    emitAttr        size = emitDecodeSize(id->idOpSize);

    /* Get the 'base' opcode */

    switch(ins)
    {
    case INS_inc:
    case INS_dec:

        if (size == EA_1BYTE)
        {
            assert(INS_inc_l == INS_inc + 1);
            assert(INS_dec_l == INS_dec + 1);

            /* Can't use the compact form, use the long form */

            instruction ins_l = (instruction)(ins + 1);

            dst += emitOutputWord(dst, insCodeRR(ins_l) | insEncodeReg012(reg));
        }
        else
        {
            if (size == EA_2BYTE)
            {
                /* Output a size prefix for a 16-bit operand */
                dst += emitOutputByte(dst, 0x66);
            }
            dst += emitOutputByte(dst, insCodeRR(ins  ) | insEncodeReg012(reg));
        }
        break;

    case INS_pop:
    case INS_push:
    case INS_push_hide:

        assert(size == EA_4BYTE);
        dst += emitOutputByte(dst, insCodeRR(ins) | insEncodeReg012(reg));
        break;

    case INS_seto:
    case INS_setno:
    case INS_setb:
    case INS_setae:
    case INS_sete:
    case INS_setne:
    case INS_setbe:
    case INS_seta:
    case INS_sets:
    case INS_setns:
    case INS_setpe:
    case INS_setpo:
    case INS_setl:
    case INS_setge:
    case INS_setle:
    case INS_setg:

        assert(id->idGCrefGet() == GCT_NONE);

        code = insEncodeMRreg(ins, reg);

        /* We expect this to always be a 'big' opcode */

        assert(code & 0x00FF0000);

        dst += emitOutputByte(dst, code >> 16);
        dst += emitOutputWord(dst, code & 0x0000FFFF);

        break;

    default:

        assert(id->idGCrefGet() == GCT_NONE);

        code = insEncodeMRreg(ins, reg);

        if (size != EA_1BYTE)
        {
            /* Set the 'w' bit to get the large version */
            code |= 0x1;

            if (size == EA_2BYTE)
            {
                /* Output a size prefix for a 16-bit operand */
                dst += emitOutputByte(dst, 0x66);
            }
        }

        dst += emitOutputWord(dst, code);
        break;
    }

    /* Are we writing the register? if so then update the GC information */

    switch (id->idInsFmt)
    {
    case IF_RRD:
        break;
    case IF_RWR:
        if  (id->idGCref)
            emitGCregLiveUpd(id->idGCrefGet(), id->idRegGet(), dst);
        else
            emitGCregDeadUpd(id->idRegGet(), dst);
        break;
    case IF_RRW:
        {
#ifdef DEBUG
            regMaskTP regMask = emitRegMask(reg);
#endif
            if  (id->idGCref)
            {
                // The reg must currently be holding either a gcref or a byref
                // GCT_GCREF+int = GCT_BYREF, and GCT_BYREF+/-int = GCT_BYREF
                assert(((emitThisGCrefRegs & regMask) && (ins == INS_inc)) ||
                       ((emitThisByrefRegs & regMask) && (ins == INS_inc || ins == INS_dec)));
                assert(id->idGCrefGet() == GCT_BYREF);
                // Mark it as holding a GCT_BYREF
                emitGCregLiveUpd(GCT_BYREF, id->idRegGet(), dst);
            }
            else
            {
                // Can't use RRW to trash a GC ref or Byref
                assert(((emitThisGCrefRegs & regMask) == 0) &&
                       ((emitThisByrefRegs & regMask) == 0)    );
            }
        }
        break;
    default:
#ifdef  DEBUG
        emitDispIns(id, false, false, false);
#endif
        assert(!"unexpected instruction format");
        break;
    }

    return  dst;
}

/*****************************************************************************
 *
 *  Output an instruction with two register operands.
 */

BYTE    *           emitter::emitOutputRR(BYTE *dst, instrDesc *id)
{
    unsigned        code;

    instruction     ins  = id->idInsGet();
    emitRegs        reg1 = id->idRegGet();
    emitRegs        reg2 = id->idRg2Get();
    emitAttr        size = emitDecodeSize(id->idOpSize);

    /* Get the 'base' opcode */

    switch(ins)
    {
    case INS_movsx:
    case INS_movzx:
        code = insEncodeRMreg(ins) | (int)(size == EA_2BYTE);
        break;

    case INS_test:
        assert(size == EA_4BYTE);
        code = insEncodeMRreg(ins) | 1;
        break;

    default:
        code = insEncodeMRreg(ins) | 2;

        switch (size)
        {
        case EA_1BYTE:
            assert(SRM_BYTE_REGS & emitRegMask(reg1));
            assert(SRM_BYTE_REGS & emitRegMask(reg2));
            break;

        case EA_2BYTE:

            /* Output a size prefix for a 16-bit operand */

            dst += emitOutputByte(dst, 0x66);

            // Fall through ...

        case EA_4BYTE:

            /* Set the 'w' bit to get the large version */

            code |= 0x1;
            break;

        default:
            assert(!"unexpected size");
        }

        break;
    }

    /* Is this a 'big' opcode? */

    if  (code & 0x00FF0000)
    {
        dst += emitOutputByte(dst, code >> 16); code &= 0x0000FFFF;
    }

    dst += emitOutputWord(dst, code | (insEncodeReg345(reg1) |
                                     insEncodeReg012(reg2)) << 8);

    /* Does this instruction operate on a GC ref value? */

    if  (id->idGCref)
    {
        switch (id->idInsFmt)
        {
        case IF_RRD_RRD:
            break;

        case IF_RWR_RRD:

#if USE_FASTCALL // For fastcall, "this" is in REG_ARG_0 on entry

            if  (emitIGisInProlog(emitCurIG) &&
                 (!emitComp->info.compIsStatic) && (reg2 == REG_ARG_0)
                                 && emitComp->lvaTable[0].TypeGet() != TYP_I_IMPL)
            {
                /* We're relocating "this" in the prolog */

                assert(emitComp->lvaIsThisArg(0));
                assert(emitComp->lvaTable[0].lvRegister);
                assert(emitComp->lvaTable[0].lvRegNum == reg1);

                if  (emitFullGCinfo)
                {
                    emitGCregLiveSet(id->idGCrefGet(), emitRegMask(reg1), dst, true);
                    break;
                }
                else
                {
                    /* If emitFullGCinfo==false, the we dont use any
                       regPtrDsc's and so explictly note the location
                       of "this" in GCEncode.cpp
                     */
                }
            }
#endif

            emitGCregLiveUpd(id->idGCrefGet(), id->idRegGet(), dst);
            break;

        case IF_RRW_RRD:

            /*
                This must be one of the following cases:

                    xor reg, reg        to assign NULL

                    and r1 , r2         if (ptr1 && ptr2) ...
                    or  r1 , r2         if (ptr1 || ptr2) ...
             */

            switch (id->idIns)
            {
            case INS_xor:
                assert(id->idReg == id->idRg2);
                emitGCregLiveUpd(id->idGCrefGet(), id->idRegGet(), dst);
                break;

            case INS_or:
            case INS_and:
                emitGCregDeadUpd(id->idRegGet(), dst);
                break;

            case INS_add:
            case INS_sub:
                assert(id->idGCrefGet() == GCT_BYREF);

#ifdef DEBUG
                regMaskTP regMask;
                regMask = emitRegMask(reg1) | emitRegMask(reg2);

                // r1/r2 could have been a GCREF as GCREF + int=BYREF
                //                            or BYREF+/-int=BYREF
                assert(((regMask & emitThisGCrefRegs) && (ins == INS_add                  )) ||
                       ((regMask & emitThisByrefRegs) && (ins == INS_add || ins == INS_sub)));
#endif
                // Mark r1 as holding a byref
                emitGCregLiveUpd(GCT_BYREF, id->idRegGet(), dst);
                break;

            default:
#ifdef  DEBUG
                emitDispIns(id, false, false, false);
#endif
                assert(!"unexpected GC reg update instruction");
            }

            break;

        case IF_RRW_RRW:

            /* This must be "xchg reg1, reg2" */
            assert(id->idIns == INS_xchg);

            /* If we got here, one and only ONE of the two registers
             * holds a pointer, so we have to "swap" them in the GC
             * register pointer mask */
#if 0
            GCtype gc1, gc2;

            gc1 = emitRegGCtype(reg1);
            gc2 = emitRegGCtype(reg2);

            if (gc1 != gc2)
            {
                // Kill the GC-info about the GC registers

                if (needsGC(gc1))
                    emitGCregDeadUpd(reg1, dst);

                if (needsGC(gc2))
                    emitGCregDeadUpd(reg2, dst);

                // Now, swap the info

                if (needsGC(gc1))
                    emitGCregLiveUpd(gc1, reg2, dst);

                if (needsGC(gc2))
                    emitGCregLiveUpd(gc2, reg1, dst);
            }
#endif
            break;

        default:
#ifdef  DEBUG
            emitDispIns(id, false, false, false);
#endif
            assert(!"unexpected GC ref instruction format");
        }
    }
    else
    {
        switch (id->idInsFmt)
        {
        case IF_RWR_RRD:
        case IF_RRW_RRD:
            emitGCregDeadUpd(id->idRegGet(), dst);
            break;
        }
    }

    return  dst;
}

/*****************************************************************************
 *
 *  Output an instruction with a register and constant operands.
 */

BYTE    *           emitter::emitOutputRI(BYTE *dst, instrDesc *id)
{
    unsigned     code;
    emitAttr     size      = emitDecodeSize(id->idOpSize);
    instruction  ins       = id->idInsGet();
    emitRegs     reg       = (emitRegs  )id->idReg;
    int          val       = emitGetInsSC(id);
    bool         valInByte = ((signed char)val == val) && (ins != INS_mov) && (ins != INS_test);

#ifdef RELOC_SUPPORT
    if (id->idInfo.idCnsReloc)
    {
        valInByte = false;      // relocs can't be placed in a byte
    }
#endif

    assert(size != EA_1BYTE || (emitRegMask(reg) & SRM_BYTE_REGS));

    /* The 'mov' opcode is special */

    if  (ins == INS_mov)
    {
        assert(val);

        code = insCodeACC(ins);
        assert(code < 0x100);

        assert(size == EA_4BYTE);       // Only 32-bit mov's are implemented
        code |= 0x08;                   // Set the 'w' bit

        dst += emitOutputByte(dst, code | insEncodeReg012(reg));
        dst += emitOutputLong(dst, val);
#ifdef RELOC_SUPPORT
        if (id->idInfo.idCnsReloc)
        {
            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
        }
#endif

        goto DONE;
    }

    /* Decide which encoding is the shortest */

    bool    useSigned, useACC;

    if (reg == SR_EAX && !instrIsImulReg(ins))
    {
         if (size == EA_1BYTE || (ins == INS_test))
         {
             // For al, ACC encoding is always the smallest

             useSigned = false; useACC = true;
         }
         else
         {
             /* For ax/eax, we avoid ACC encoding for small constants as we
              * can emit the small constant and have it sign-extended.
              * For big constants, the ACC encoding is better as we can use
              * the 1 byte opcode
              */

             if (valInByte)
             {
                 // avoid using ACC encoding
                 useSigned = true;  useACC = false;
             }
             else
             {
                 useSigned = false; useACC = true;
             }
         }
    }
    else
    {
        useACC = false;

        if (valInByte)
            useSigned = true;
        else
            useSigned = false;
    }

    /* "test" has no 's' bit */

    if (ins == INS_test) useSigned = false;

    /* Get the 'base' opcode */

    if (useACC)
    {
        assert(!useSigned);

        code    = insCodeACC(ins);
    }
    else
    {
        assert(!useSigned || valInByte);

        code    = insEncodeMIreg(ins, reg);
    }

    switch (size)
    {
    case EA_1BYTE:
        break;

    case EA_2BYTE:

        /* Output a size prefix for a 16-bit operand */

        dst += emitOutputByte(dst, 0x66);

        // Fall through ...

    case EA_4BYTE:

        /* Set the 'w' bit to get the large version */

        code |= 0x1;
        break;

    default:
        assert(!"unexpected size");
    }

    /* Does the value fit in a single byte?
     * We can just set the 's' bit, and issue an immediate byte */

    if  (useSigned)
    {
        dst += emitOutputWord(dst, code | 2);
        dst += emitOutputByte(dst, val);

        goto DONE;
    }

    /* Can we use an accumulator (EAX) encoding? */

    if  (useACC)
        dst += emitOutputByte(dst, code);
    else
        dst += emitOutputWord(dst, code);

    switch(size)
    {
    case EA_1BYTE:   dst += emitOutputByte(dst, val);  break;
    case EA_2BYTE:   dst += emitOutputWord(dst, val);  break;
    case EA_4BYTE:   dst += emitOutputLong(dst, val);  break;
    }

#ifdef RELOC_SUPPORT
    if (id->idInfo.idCnsReloc)
    {
        emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
        assert(size == EA_4BYTE);
    }
#endif

DONE:

    /* Does this instruction operate on a GC ref value? */


#ifdef DEBUG
    regMaskTP regMask;
#endif
    if  (id->idGCref)
    {
        switch (id->idInsFmt)
        {
        case IF_RRD_CNS:
            break;

        case IF_RWR_CNS:
            emitGCregLiveUpd(id->idGCrefGet(), id->idRegGet(), dst);
            break;

        case IF_RRW_CNS:
            assert(id->idGCrefGet() == GCT_BYREF);

#ifdef DEBUG
            regMask = emitRegMask(reg);

            // The reg must currently be holding either a gcref or a byref
            // GCT_GCREF+int = GCT_BYREF, and GCT_BYREF+/-int = GCT_BYREF
            assert(((emitThisGCrefRegs & regMask) && (ins == INS_add)) ||
                   ((emitThisByrefRegs & regMask) && (ins == INS_add || ins == INS_sub)));
#endif
            // Mark it as holding a GCT_BYREF
            emitGCregLiveUpd(GCT_BYREF, id->idRegGet(), dst);
            break;

        default:
#ifdef  DEBUG
            emitDispIns(id, false, false, false);
#endif
            assert(!"unexpected GC ref instruction format");
        }
        //
        // A three operand imul instruction can never produce a GC ref
        //
        assert(!instrIsImulReg(ins));
    }
    else
    {
        switch (id->idInsFmt)
        {
        case IF_RRD_CNS:
            break;
        case IF_RRW_CNS:
#ifdef DEBUG
            regMask = emitRegMask(reg);
            // The reg must not currently be holding either a gcref
            assert((emitThisGCrefRegs & regMask) == 0);
#endif
            break;
        case IF_RWR_CNS:
            emitGCregDeadUpd(id->idRegGet(), dst);
            break;
        default:
#ifdef  DEBUG
            emitDispIns(id, false, false, false);
#endif
            assert(!"unexpected GC ref instruction format");
        }

        // For the three operand imul instruction the target
        // register is encoded in the opcode
        //

        if (instrIsImulReg(ins))
        {
            emitRegs tgtReg = ((emitRegs) Compiler::instImulReg(ins));
            emitGCregDeadUpd(tgtReg, dst);
        }
    }

    return dst;
}

/*****************************************************************************
 *
 *  Output an instruction with a constant operand.
 */

BYTE    *           emitter::emitOutputIV(BYTE *dst, instrDesc *id)
{
    unsigned     code;
    instruction  ins       = id->idInsGet();
    int          val       = emitGetInsSC(id);
    bool         valInByte = ((signed char)val == val);

#ifdef RELOC_SUPPORT
    if (id->idInfo.idCnsReloc)
    {
        valInByte = false;        // relocs can't be placed in a byte

        // Of these instructions only the push instruction can have reloc
        assert(ins == INS_push || ins == INS_push_hide);
    }
#endif

   switch (ins)
    {
    case INS_loop:

        assert((val >= -128) && (val <= 127));
        dst += emitOutputByte(dst, insCodeMI(ins));
        dst += emitOutputByte(dst, val);
        break;

    case INS_ret:

        assert(val);
        dst += emitOutputByte(dst, insCodeMI(ins));
        dst += emitOutputWord(dst, val);
        break;

    case INS_push_hide:
    case INS_push:

        code = insCodeMI(ins);

        /* Does the operand fit in a byte? */

        if  (valInByte)
        {
            dst += emitOutputByte(dst, code|2);
            dst += emitOutputByte(dst, val);
        }
        else
        {
            dst += emitOutputByte(dst, code);
            dst += emitOutputLong(dst, val);
#ifdef RELOC_SUPPORT
            if (id->idInfo.idCnsReloc)
            {
                emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
            }
#endif
        }

        /* Did we push a GC ref value? */

        if  (id->idGCref)
        {
#ifdef  DEBUG
            printf("UNDONE: record GCref push [cns]\n");
#endif
        }

        break;

    default:
        assert(!"unexpected instruction");
    }

    return  dst;
}

/*****************************************************************************
 *
 *  Output a local jump instruction.
 */

BYTE    *           emitter::emitOutputLJ(BYTE *dst, instrDesc *i)
{
    unsigned        srcOffs;
    unsigned        dstOffs;
    int             jmpDist;

    instrDescJmp *  id  = (instrDescJmp*)i;
    instruction     ins = id->idInsGet();
    bool            jmp;

    size_t          ssz;
    size_t          lsz;

    switch (ins)
    {
    default:
        ssz = JCC_SIZE_SMALL;
        lsz = JCC_SIZE_LARGE;
        jmp = true;
        break;

    case INS_jmp:
        ssz = JMP_SIZE_SMALL;
        lsz = JMP_SIZE_LARGE;
        jmp = true;
        break;

    case INS_call:
        ssz =
        lsz = CALL_INST_SIZE;
        jmp = false;
        break;
    }

    /* Figure out the distance to the target */

    srcOffs = emitCurCodeOffs(dst);
    dstOffs = id->idAddr.iiaIGlabel->igOffs;
    jmpDist = dstOffs - srcOffs;

    if  (jmpDist <= 0)
    {
        /* This is a backward jump - distance is known at this point */

#ifdef  DEBUG
        if  (id->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
        {
            size_t      blkOffs = id->idjIG->igOffs;

            if  (INTERESTING_JUMP_NUM == 0)
            printf("[3] Jump %u:\n", id->idNum);
            printf("[3] Jump  block is at %08X - %02X = %08X\n", blkOffs, emitOffsAdj, blkOffs - emitOffsAdj);
            printf("[3] Jump        is at %08X - %02X = %08X\n", srcOffs, emitOffsAdj, srcOffs - emitOffsAdj);
            printf("[3] Label block is at %08X - %02X = %08X\n", dstOffs, emitOffsAdj, dstOffs - emitOffsAdj);
        }
#endif

        /* Can we use a short jump? */

        if  (jmpDist - ssz >= JMP_DIST_SMALL_MAX_NEG && jmp)
        {
            id->idjShort = 1;
#ifdef  DEBUG
            if  (verbose) printf("; Bwd jump [%08X] from %04X to %04X: dist =     %04XH\n", id, srcOffs+ssz, dstOffs, jmpDist-ssz);
#endif
        }
        else
        {
#ifdef  DEBUG
            if  (verbose) printf("; Bwd jump [%08X] from %04X to %04X: dist = %08Xh\n", id, srcOffs+lsz, dstOffs, jmpDist-lsz);
#endif
        }
    }
    else
    {
        /* This is a  forward jump - distance will be an upper limit */

        emitFwdJumps  = true;

        /* The target offset will be closer by at least 'emitOffsAdj' */

        dstOffs -= emitOffsAdj;
        jmpDist -= emitOffsAdj;

        /* Record the location of the jump for later patching */

        id->idjOffs = dstOffs;

#ifdef  DEBUG
        if  (id->idNum == INTERESTING_JUMP_NUM || INTERESTING_JUMP_NUM == 0)
        {
            size_t      blkOffs = id->idjIG->igOffs;

            if  (INTERESTING_JUMP_NUM == 0)
            printf("[4] Jump %u:\n", id->idNum);
            printf("[4] Jump  block is at %08X\n"              , blkOffs);
            printf("[4] Jump        is at %08X\n"              , srcOffs);
            printf("[4] Label block is at %08X - %02X = %08X\n", dstOffs + emitOffsAdj, emitOffsAdj, dstOffs);
        }
#endif

        /* Can we use a short jump? */

        if  (jmpDist - ssz <= JMP_DIST_SMALL_MAX_POS && jmp)
        {
            id->idjShort = 1;
#ifdef  DEBUG
            if  (verbose) printf("; Fwd jump [%08X/%03u] from %04X to %04X: dist =     %04XH\n", id, id->idNum, srcOffs+ssz, dstOffs, jmpDist-ssz);
#endif
        }
        else
        {
#ifdef  DEBUG
            if  (verbose) printf("; Fwd jump [%08X/%03u] from %04X to %04X: dist = %08XH\n", id, id->idNum, srcOffs+lsz, dstOffs, jmpDist-lsz);
#endif
        }
    }

    /* What size jump should we use? */

    if  (id->idjShort)
    {
        /* Short jump */

        assert(JMP_SIZE_SMALL == JCC_SIZE_SMALL);
        assert(JMP_SIZE_SMALL == 2);

        assert(jmp);

        if  (emitInstCodeSz(id) != JMP_SIZE_SMALL)
        {
            emitOffsAdj += emitInstCodeSz(id) - JMP_SIZE_SMALL;

#ifdef  DEBUG
#ifndef NOT_JITC
            printf("; NOTE: size of jump [%08X] mis-predicted\n", id);
#endif
#endif
        }

        dst += emitOutputByte(dst, insCode(ins));

        /* For forward jumps, record the address of the distance value */

        id->idjTemp.idjAddr = (jmpDist > 0) ? dst : NULL;

        dst += emitOutputByte(dst, jmpDist - 2);
    }
    else
    {
        unsigned        code;

        /* Long  jump */

        if  (jmp)
        {
            assert(INS_jmp + (INS_l_jmp - INS_jmp) == INS_l_jmp);
            assert(INS_jo  + (INS_l_jmp - INS_jmp) == INS_l_jo );
            assert(INS_jb  + (INS_l_jmp - INS_jmp) == INS_l_jb );
            assert(INS_jae + (INS_l_jmp - INS_jmp) == INS_l_jae);
            assert(INS_je  + (INS_l_jmp - INS_jmp) == INS_l_je );
            assert(INS_jne + (INS_l_jmp - INS_jmp) == INS_l_jne);
            assert(INS_jbe + (INS_l_jmp - INS_jmp) == INS_l_jbe);
            assert(INS_ja  + (INS_l_jmp - INS_jmp) == INS_l_ja );
            assert(INS_js  + (INS_l_jmp - INS_jmp) == INS_l_js );
            assert(INS_jns + (INS_l_jmp - INS_jmp) == INS_l_jns);
            assert(INS_jpe + (INS_l_jmp - INS_jmp) == INS_l_jpe);
            assert(INS_jpo + (INS_l_jmp - INS_jmp) == INS_l_jpo);
            assert(INS_jl  + (INS_l_jmp - INS_jmp) == INS_l_jl );
            assert(INS_jge + (INS_l_jmp - INS_jmp) == INS_l_jge);
            assert(INS_jle + (INS_l_jmp - INS_jmp) == INS_l_jle);
            assert(INS_jg  + (INS_l_jmp - INS_jmp) == INS_l_jg );

            code = insCode((instruction)(ins + (INS_l_jmp - INS_jmp)));
        }
        else
            code = 0xE8;

        dst += emitOutputByte(dst, code);

        if  (code & 0xFF00)
            dst += emitOutputByte(dst, code >> 8);

        /* For forward jumps, record the address of the distance value */

        id->idjTemp.idjAddr = (jmpDist > 0) ? dst : NULL;

        /* Compute PC relative distance into a long */

        dst += emitOutputLong(dst, jmpDist - lsz);
    }

    // Local calls kill all registers

    if (!jmp && (emitThisGCrefRegs|emitThisByrefRegs))
        emitGCregDeadUpd(emitThisGCrefRegs|emitThisByrefRegs, dst);

    return  dst;
}

/*****************************************************************************
 *
 *  Append the machine code corresponding to the given instruction descriptor
 *  to the code block at '*dp'; the base of the code block is 'bp', and 'ig'
 *  is the instruction group that contains the instruction. Updates '*dp' to
 *  point past the generated code, and returns the size of the instruction
 *  descriptor in bytes.
 */

size_t              emitter::emitOutputInstr(insGroup  *ig,
                                             instrDesc *id, BYTE **dp)
{
    BYTE    *       dst  = *dp;
    size_t          sz   = sizeof(instrDesc);
    instruction     ins  = id->idInsGet();
    emitAttr        size = emitDecodeSize(id->idOpSize);

#ifdef  DEBUG

#if     DUMP_GC_TABLES
    bool            dspOffs = dspGCtbls;
#else
    const
    bool            dspOffs = false;
#endif

    if  (disAsm || dspEmit)
        emitDispIns(id, false, dspOffs, true, dst - emitCodeBlock);

#endif

    assert(SR_NA == REG_NA);

    assert(id->idIns != INS_imul          || size == EA_4BYTE); // Has no 'w' bit
    assert(instrIsImulReg(id->idIns) == 0 || size == EA_4BYTE); // Has no 'w' bit

    /* What instruction format have we got? */

    switch (id->idInsFmt)
    {
        unsigned        code;
        int             args;
        CnsVal          cnsVal;

        BYTE    *       addr;
        METHOD_HANDLE   methHnd;
        bool            nrc;

        VARSET_TP       GCvars;
        unsigned        gcrefRegs;
        unsigned        byrefRegs;
        unsigned        bregs;

        /********************************************************************/
        /*                        No operands                               */
        /********************************************************************/
    case IF_NONE:
            // INS_cdq kills the EDX register implicitly
        if (id->idIns == INS_cdq)
            emitGCregDeadUpd(SR_EDX, dst);

        // Fall through
    case IF_TRD:
    case IF_TWR:
    case IF_TRW:
        assert(id->idGCrefGet() == GCT_NONE);

#if SCHEDULER
        if (ins == INS_noSched) // explicit scheduling boundary.
        {
            sz = TINY_IDSC_SIZE;
            break;
        }
#endif

        code = insCodeMR(ins);

        if  (code & 0xFF00)
            dst += emitOutputWord(dst, code);
        else
            dst += emitOutputByte(dst, code);

        break;

        /********************************************************************/
        /*                Simple constant, local label, method              */
        /********************************************************************/

    case IF_CNS:

        dst = emitOutputIV(dst, id);
        sz  = emitSizeOfInsDsc(id);
        break;

    case IF_LABEL:

        assert(id->idGCrefGet() == GCT_NONE);
        assert(id->idInfo.idBound);

        dst = emitOutputLJ(dst, id);
        sz  = sizeof(instrDescJmp);
//      printf("jump #%u\n", id->idNum);
        break;

    case IF_METHOD:
    case IF_METHPTR:

        /* Assume we'll be recording this call */

        nrc  = false;

        /* Get hold of the argument count and field Handle*/

        args = emitGetInsCDinfo(id);

        methHnd = id->idAddr.iiaMethHnd;

        /* Is this a "fat" call descriptor? */

        if  (id->idInfo.idLargeCall)
        {
            GCvars      = ((instrDescCDGCA*)id)->idcdGCvars;
            bregs       = ((instrDescCDGCA*)id)->idcdByrefRegs;
            byrefRegs   = emitDecodeCallGCregs(bregs);

            sz          = sizeof(instrDescCDGCA);
        }
        else
        {
            assert(id->idInfo.idLargeDsp == false);
            assert(id->idInfo.idLargeCns == false);

            GCvars      = 0;
            byrefRegs   = 0;

            sz          = sizeof(instrDesc);
        }

        /* What kind of a call do we have here? */

        if (id->idInfo.idCallAddr)
        {
            /*
                This is call indirect where we know the target, thus we can
                use a direct call; the target to jump to is in iiaAddr.
             */

            assert(id->idInsFmt == IF_METHOD);

            addr = (BYTE *)id->idAddr.iiaAddr;
        }
        else
        {
            /* See if this is a call to a helper function */

            JIT_HELP_FUNCS helperNum = Compiler::eeGetHelperNum(methHnd);

            if (helperNum != JIT_HELP_UNDEF)
            {
                /* This is a helper call */


#ifndef RELOC_SUPPORT
                assert(id->idInsFmt != IF_METHPTR);
#else
                assert(id->idInsFmt != IF_METHPTR || emitComp->opts.compReloc);

                if (id->idInsFmt == IF_METHPTR)
                {
                    assert(id->idInfo.idDspReloc);

                    // Get the indirection handle

                    void * dirAddr = eeGetHelperFtn(emitCmpHandle,
                                                helperNum, (void***)&addr);
                    assert(dirAddr == NULL && addr);

                    goto EMIT_INDIR_CALL;
                }
#endif
                /* Some helpers don't get recorded in GC tables */

                if  (emitNoGChelper(helperNum))
                    nrc = true;

#if defined(NOT_JITC) || defined(OPT_IL_JIT)
                addr = (BYTE *)eeGetHelperFtn(emitCmpHandle,  helperNum, NULL);
#else

                /* Only worry about fixup address if we're trying to run code */

                if  (runCode)
                {
//                  switch (emitComp->eeGetHelperNum(methHnd))
                    {
//                  default:
#ifdef DEBUG
                        printf("WARNING: Helper function '%s' not implemented, call will crash\n", emitComp->eeHelperMethodName(emitComp->eeGetHelperNum(methHnd)));
#endif
                        addr = NULL;
//                  }
                }
                else
                {
                    addr = NULL;
                }
#endif  // NOT_JITC
            }
            else
            {
                /* It's a call to a user-defined function/method */

                if  (emitComp->eeIsOurMethod(methHnd))
                {
                    assert(id->idInsFmt != IF_METHPTR);

                    /* Directly recursive call */

                    addr = emitCodeBlock;
                }
                else
                {
                    /* Static method call */

                    InfoAccessType accessType;

                    if  (id->idInsFmt == IF_METHPTR)
                    {
                        /* This is a call via a global method pointer */

                        addr = (BYTE*)emitComp->eeGetMethodEntryPoint(methHnd, &accessType);
                        assert(accessType == IAT_PVALUE);

#ifdef RELOC_SUPPORT
                    EMIT_INDIR_CALL:
#endif

                        assert(addr);

                        dst += emitOutputWord(dst, insCodeMR(ins) | 0x0500);
                        dst += emitOutputLong(dst, (int)addr);
#ifdef RELOC_SUPPORT
                        if (id->idInfo.idDspReloc)
                        {
                            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
                        }
#endif

                        goto DONE_CALL;
                    }

                    /* Direct static method call */

                    addr = (BYTE*)emitComp->eeGetMethodPointer(methHnd, &accessType);
                    assert(accessType == IAT_VALUE);

#ifdef RELOC_SUPPORT
                    if (emitComp->opts.compReloc)
                    {
                        /* Output the call opcode followed by the target distance */

                        dst += (ins == INS_l_jmp) ? emitOutputByte(dst, insCode(ins))
                                                  : emitOutputByte(dst, insCodeMI(ins));

                        /* Get true code address for the byte following this call */
                        BYTE* srcAddr = getCurrentCodeAddr(dst + sizeof(void*));

                        if (addr == NULL)   // do we need to defer this?
                        {
                            X86deferredCall * pDC = X86deferredCall::create(emitCmpHandle,
                                                                            methHnd,
                                                                            dst, srcAddr);

                            dst += emitOutputLong(dst, 0);

                            emitCmpHandle->deferLocation (methHnd, pDC);
                        }
                        else
                        {
                            /* Calculate PC relative displacement */
                            dst += emitOutputLong(dst, (int)(addr - srcAddr));
                        }

                        emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_REL32);

                        goto DONE_CALL;
                    }
#endif
                }
            }
        }

#ifdef BIRCH_SP2
        {
            //
            // Should always end up jumping to DONE_CALL for RELOC_SUPPORT
            //
            // Because the code below makes the assumption that we are running
            // in memory and that the PC relative address can be formed by
            // subtracting dst from addr.
            //
            // This assuption is never true for RELOC_SUPPORT
            //

#ifdef DEBUG
            emitDispIns(id, false, false, false);
#endif

            assert(!"Should Not Be Reached");
        }
#endif // BIRCH_SP2

        /* Output the call opcode followed by the target distance */

        dst += (ins == INS_l_jmp) ? emitOutputByte(dst, insCode(ins)) : emitOutputByte(dst, insCodeMI(ins));

        /* Calculate PC relative displacement */
        dst += emitOutputLong(dst, addr - (dst + sizeof(void*)));

#ifdef RELOC_SUPPORT
        if (emitComp->opts.compReloc)
            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_REL32);
#endif

    DONE_CALL:

#ifdef BIRCH_SP2
        if (args >= 0)
            emitStackPop(dst, true, args);
        break;
#endif
        /* Get the new set of live GC ref registers */

        gcrefRegs = emitDecodeCallGCregs(id);

        /* If the method returns a GC ref, mark EAX appropriately */

        if       (id->idGCrefGet() == GCT_GCREF)
            gcrefRegs |= SRM_EAX;
        else if  (id->idGCrefGet() == GCT_BYREF)
            byrefRegs |= SRM_EAX;

        /* If the GC register set has changed, report the new set */

        if  (gcrefRegs != emitThisGCrefRegs)
            emitUpdateLiveGCregs(GCT_GCREF, gcrefRegs, dst);

        if  (byrefRegs != emitThisByrefRegs)
            emitUpdateLiveGCregs(GCT_BYREF, byrefRegs, dst);

        if  (nrc == false || args)
        {
            /* For callee-pop, all arguments will be popped  after the call.
               For caller-pop, any GC arguments will go dead after the call. */

            if (args >= 0)
                emitStackPop(dst, true, args);
            else
                emitStackKillArgs(dst, -args);
        }

        /* Is there a new set of live GC ref variables? */

#ifdef  DEBUG
        if  (verbose&&0)
        {
            printf("[%02u] Gen call GC vars = %016I64X\n",
                   id->idNum, GCvars);
        }
#endif

        emitUpdateLiveGCvars(GCvars, dst);

        /* Do we need to record a call location for GC purposes? */

        if  (!emitFullGCinfo && !nrc)
            emitRecordGCcall(dst);

        break;

        /********************************************************************/
        /*                      One register operand                        */
        /********************************************************************/

    case IF_RRD:
    case IF_RWR:
    case IF_RRW:

        dst = emitOutputR(dst, id);
        sz = TINY_IDSC_SIZE;
        break;

        /********************************************************************/
        /*                 Register and register/constant                   */
        /********************************************************************/

    case IF_RRW_SHF:
        dst += emitOutputWord(dst, insEncodeMRreg(ins, id->idRegGet()) | 1);
        dst += emitOutputByte(dst, emitGetInsSC(id));
        sz   = emitSizeOfInsDsc(id);
        break;

    case IF_RRD_RRD:
    case IF_RWR_RRD:
    case IF_RRW_RRD:
    case IF_RRW_RRW:

        dst = emitOutputRR(dst, id);
        sz  = TINY_IDSC_SIZE;
        break;

    case IF_RWR_METHOD:
        assert(ins == INS_mov);

        /* Move the address of a static method into the target register */

        methHnd = id->idAddr.iiaMethHnd;

        /* Output the mov r32,imm opcode followed by the method's address */
        code = insCodeACC(ins) | 0x08 | insEncodeReg012(id->idRegGet());
        assert(code < 0x100);
        dst += emitOutputByte(dst, code);

        addr = (BYTE*)emitComp->eeGetMethodEntryPoint(methHnd, NULL);

        if (addr != NULL)
        {
            dst += emitOutputLong(dst, (int)addr);
#ifdef RELOC_SUPPORT
            if (id->idInfo.idCnsReloc)
            {
                emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);
            }
#endif
        }
        else
        {
#ifdef RELOC_SUPPORT
            assert(id->idInfo.idCnsReloc);

            // We need to defer this with a fixup

            X86deferredCall * pDC = X86deferredCall::create(emitCmpHandle, methHnd, dst, 0);

            assert(id->idInfo.idCnsReloc);

            dst += emitOutputLong(dst, 0);

            emitCmpHandle->recordRelocation((void**)dst-1, IMAGE_REL_BASED_HIGHLOW);

            emitCmpHandle->deferLocation (methHnd, pDC);
#else
            assert(addr != NULL);       // @ToDo: fixup address for Std JIT
#endif
        }
        sz = sizeof(instrDescCns);
        break;

    case IF_RRD_CNS:
    case IF_RWR_CNS:
    case IF_RRW_CNS:

        dst = emitOutputRI(dst, id);
        sz  = emitSizeOfInsDsc(id);
        break;

    case IF_RRW_RRW_CNS:

        assert(id->idGCrefGet() == GCT_NONE);

        /* Get the 'base' opcode (it's a big one) */

        code = insEncodeMRreg(ins); assert(code & 0x00FF0000);

        dst += emitOutputByte(dst, code >> 16);

        dst += emitOutputWord(dst, code | (insEncodeReg345(id->idRg2Get()) |
                                           insEncodeReg012(id->idRegGet())) << 8);

        dst += emitOutputByte(dst, emitGetInsSC(id));

        sz   = emitSizeOfInsDsc(id);
        break;

        /********************************************************************/
        /*                      Address mode operand                        */
        /********************************************************************/

    case IF_ARD:
    case IF_AWR:
    case IF_ARW:

    case IF_TRD_ARD:
    case IF_TWR_ARD:
    case IF_TRW_ARD:

//  case IF_ARD_TRD:
    case IF_AWR_TRD:
//  case IF_ARW_TRD:

        dst = emitOutputAM(dst, id, insCodeMR(ins));

        switch (ins)
        {
        case INS_call:

    IND_CALL:
            /* Get hold of the argument count and method handle */

            args = emitGetInsCIargs(id);

            /* Is this a "fat" call descriptor? */

            if  (id->idInfo.idLargeCall)
            {
                GCvars      = ((instrDescCIGCA*)id)->idciGCvars;
                bregs       = ((instrDescCIGCA*)id)->idciByrefRegs;
                byrefRegs   = emitDecodeCallGCregs(bregs);

                sz          = sizeof(instrDescCIGCA);
            }
            else
            {
                assert(id->idInfo.idLargeDsp == false);
                assert(id->idInfo.idLargeCns == false);

                GCvars      = 0;
                byrefRegs   = 0;

                sz          = sizeof(instrDesc);
            }

            nrc = false;

            goto DONE_CALL;

        case INS_i_jmp:
            sz = emitSizeOfInsDsc((instrDescDsp*)id);
            break;

        default:
            sz = emitSizeOfInsDsc((instrDescAmd*)id);
            break;
        }
        break;

    case IF_RRD_ARD:
    case IF_RWR_ARD:
    case IF_RRW_ARD:

        dst = emitOutputAM(dst, id, insCodeRM(ins) | (insEncodeReg345(id->idRegGet()) << 8));
        sz  = emitSizeOfInsDsc((instrDescAmd*)id);
        break;

    case IF_ARD_RRD:
    case IF_AWR_RRD:
    case IF_ARW_RRD:

        dst = emitOutputAM(dst, id, insCodeMR(ins) | (insEncodeReg345(id->idRegGet()) << 8));
        sz  = emitSizeOfInsDsc((instrDescAmd*)id);
        break;

    case IF_ARD_CNS:
    case IF_AWR_CNS:
    case IF_ARW_CNS:

        emitGetInsAmdCns(id, &cnsVal);
        dst = emitOutputAM(dst, id, insCodeMI(ins), &cnsVal);
        sz  = emitSizeOfInsDsc((instrDescAmdCns*)id);
        break;

    case IF_ARW_SHF:

        emitGetInsAmdCns(id, &cnsVal);
        dst = emitOutputAM(dst, id, insCodeMR(ins), &cnsVal);
        sz  = emitSizeOfInsDsc((instrDescAmdCns*)id);
        break;

        /********************************************************************/
        /*                      Stack-based operand                         */
        /********************************************************************/

    case IF_SRD:
    case IF_SWR:
    case IF_SRW:

    case IF_TRD_SRD:
    case IF_TWR_SRD:
    case IF_TRW_SRD:

//  case IF_SRD_TRD:
    case IF_SWR_TRD:
//  case IF_SRW_TRD:

        if  (ins == INS_pop)
        {
            /* The offset in "pop [ESP+xxx]" is relative to the new ESP value */

            emitCurStackLvl -= sizeof(int);
            dst = emitOutputSV(dst, id, insCodeMR(ins));
            emitCurStackLvl += sizeof(int);
            break;
        }

        dst = emitOutputSV(dst, id, insCodeMR(ins));

        if (ins == INS_call)
            goto IND_CALL;

        break;

    case IF_SRD_CNS:
    case IF_SWR_CNS:
    case IF_SRW_CNS:

        emitGetInsCns(id, &cnsVal);
        dst = emitOutputSV(dst, id, insCodeMI(ins), &cnsVal);
        sz  = emitSizeOfInsDsc((instrDescCns*)id);
        break;

    case IF_SRW_SHF:

        emitGetInsCns(id, &cnsVal);
        dst = emitOutputSV(dst, id, insCodeMR(ins), &cnsVal);
        sz  = emitSizeOfInsDsc((instrDescCns*)id);
        break;

    case IF_RRD_SRD:
    case IF_RWR_SRD:
    case IF_RRW_SRD:

        dst = emitOutputSV(dst, id, insCodeRM(ins) | (insEncodeReg345(id->idRegGet()) << 8));
        break;

    case IF_SRD_RRD:
    case IF_SWR_RRD:
    case IF_SRW_RRD:

        dst = emitOutputSV(dst, id, insCodeMR(ins) | (insEncodeReg345(id->idRegGet()) << 8));
        break;

        /********************************************************************/
        /*                    Direct memory address                         */
        /********************************************************************/

    case IF_MRD:
    case IF_MRW:
    case IF_MWR:

    case IF_TRD_MRD:
    case IF_TWR_MRD:
    case IF_TRW_MRD:

//  case IF_MRD_TRD:
    case IF_MWR_TRD:
//  case IF_MRW_TRD:

        dst = emitOutputCV(dst, id, insCodeMR(ins) | 0x0500);

        if  (ins == INS_call)
        {
#if 0
            /* All arguments will be popped after the call */

            emitStackPop(dst, true, emitGetInsDspCns(id, &offs));

            /* Figure out the size of the instruction descriptor */

            if  (id->idInfo.idLargeCall)
                sz = sizeof(instrDescDCGC);
            else
                sz = emitSizeOfInsDsc((instrDescDspCns*)id);

            /* Do we need to record a call location for GC purposes? */

            if  (!emitFullGCinfo)
                scRecordGCcall(dst);

#else

            assert(!"what???????");

#endif

        }
        else
            sz = emitSizeOfInsDsc((instrDescDspCns*)id);

        break;

    case IF_MRD_OFF:
        dst = emitOutputCV(dst, id, insCodeMI(ins));
        break;

    case IF_RRD_MRD:
    case IF_RWR_MRD:
    case IF_RRW_MRD:

        dst = emitOutputCV(dst, id, insCodeRM(ins) | (insEncodeReg345(id->idRegGet()) << 8) | 0x0500);
        sz  = emitSizeOfInsDsc((instrDescDspCns*)id);
        break;

    case IF_RWR_MRD_OFF:

        dst = emitOutputCV(dst, id, insCode(ins) | 0x30 | insEncodeReg012(id->idRegGet()));
        sz  = emitSizeOfInsDsc((instrDescDspCns*)id);
        break;

    case IF_MRD_RRD:
    case IF_MWR_RRD:
    case IF_MRW_RRD:

        dst = emitOutputCV(dst, id, insCodeMR(ins) | (insEncodeReg345(id->idRegGet()) << 8) | 0x0500);
        sz  = emitSizeOfInsDsc((instrDescDspCns*)id);
        break;

    case IF_MRD_CNS:
    case IF_MWR_CNS:
    case IF_MRW_CNS:

        emitGetInsDcmCns(id, &cnsVal);
        dst = emitOutputCV(dst, id, insCodeMI(ins) | 0x0500, &cnsVal);
        sz  = sizeof(instrDescDCM);
        break;

    case IF_MRW_SHF:

        emitGetInsDcmCns(id, &cnsVal);
        dst = emitOutputCV(dst, id, insCodeMR(ins) | 0x0500, &cnsVal);
        sz  = sizeof(instrDescDCM);
        break;

        /********************************************************************/
        /*                  FP coprocessor stack operands                   */
        /********************************************************************/

    case IF_TRD_FRD:
    case IF_TWR_FRD:
    case IF_TRW_FRD:

        assert(id->idGCrefGet() == GCT_NONE);

        dst += emitOutputWord(dst, insCodeMR(ins) | 0xC000 | (id->idReg << 8));
        break;

    case IF_FRD_TRD:
    case IF_FWR_TRD:
    case IF_FRW_TRD:

        assert(id->idGCrefGet() == GCT_NONE);

        dst += emitOutputWord(dst, insCodeMR(ins) | 0xC004 | (id->idReg << 8));
        break;

        /********************************************************************/
        /*                           Epilog block                           */
        /********************************************************************/

    case IF_EPILOG:

#if 0

        /* Nothing is live at this point */

        if  (emitThisGCrefRegs)
            emitUpdateLiveGCregs(0, dst); // ISSUE: What if ptr returned in EAX?

        emitUpdateLiveGCvars(0, dst);

#endif

        /* Record the code offset of the epilog */

        ((instrDescCns*)id)->idcCnsVal = emitCurCodeOffs(dst);

        /* Output the epilog code bytes */

        memcpy(dst, emitEpilogCode, emitEpilogSize);
        dst += emitEpilogSize;

        sz = sizeof(instrDescCns);

        break;

        /********************************************************************/
        /*                            oops                                  */
        /********************************************************************/

    default:

#ifdef  DEBUG
        printf("unexpected format %s\n", emitIfName(id->idInsFmt));
        BreakIfDebuggerPresent();
        assert(!"don't know how to encode this instruction");
#endif
        break;
    }

    /* Make sure we set the instruction descriptor size correctly */

    assert(sz == emitSizeOfInsDsc(id));

    /* Make sure we keep the current stack level up to date */

    if  (!emitIGisInProlog(ig))
    {
        switch (ins)
        {
        case INS_push:

            emitStackPush(dst, id->idGCrefGet());
            break;

        case INS_pop:

            emitStackPop(dst, false, 1);
            break;

        case INS_sub:

            /* Check for "sub ESP, icon" */

            if  (ins == INS_sub && id->idInsFmt == IF_RRW_CNS
                                && id->idReg    == SR_ESP)
            {
                emitStackPushN(dst, emitGetInsSC(id) / sizeof(void*));
            }
            break;

        case INS_add:

            /* Check for "add ESP, icon" */

            if  (ins == INS_add && id->idInsFmt == IF_RRW_CNS
                                && id->idReg    == SR_ESP)
            {
                emitStackPop (dst, false, emitGetInsSC(id) / sizeof(void*));
            }
            break;

        }
    }

    assert((int)emitCurStackLvl >= 0);

    /* Only epilog "instructions" and some pseudo-instrs
      are allowed not to generate any code */

    assert(*dp != dst || emitInstHasNoCode(ins) || id->idInsFmt == IF_EPILOG);

#ifdef  TRANSLATE_PDB
    if(*dp != dst)
    {
        // only map instruction groups to instruction groups
        MapCode( id->idilStart, *dp );
    }
#endif

    *dp = dst;

    return  sz;
}


#ifdef RELOC_SUPPORT

/*****************************************************************************
 *
 *  Fixup a deferred direct call instruction.
 */

#ifdef BIRCH_SP2

#include "EE_Jit.h"
#include "OptJitInfo.h"
#include "PEReader.h"

void emitter::X86deferredCall::applyLocation()
{
    // if m_srcAddr is zero then this is a absolute address, not pcrel
    // but the same code path determines the correct fixup value

    BYTE *   addr  = OptJitInfo::sm_oper->getCallAddrByIndex((unsigned)m_mh);
    unsigned pcrel = (addr - m_srcAddr);

    assert(addr    != 0);
    assert(*m_dest == 0);

    *m_dest = pcrel;
}

#else

void emitter::X86deferredCall::applyLocation()
{
    // !!! is m_cmp still allocated at this point?

    BYTE * addr = (BYTE*) m_cmp->getMethodEntryPoint(m_mh, NULL);

    *m_dest = (unsigned) (addr - (BYTE*)m_srcAddr);
}

#endif // BIRCH_SP2

/*****************************************************************************
 *
 *  Return the translated code address for the codeBuffPtr or
 *          the translated code address for the start of the
 *          current method, if codeBuffPtr is NULL
 *
 */

BYTE* emitter::getCurrentCodeAddr(BYTE* codeBuffPtr)
{
#ifdef BIRCH_SP2

    BYTE* srcAddr = OptJitInfo::sm_oper->getCallAddrByIndex(OptJitInfo::sm_oper->m_iCurrentlyCompiling);
    if (codeBuffPtr != NULL)
        srcAddr += emitCurCodeOffs(codeBuffPtr);

#else

    BYTE* srcAddr = codeBuffPtr;

#endif

    return srcAddr;
}

#endif // RELOC_SUPPORT


/*****************************************************************************/
#endif//TGT_x86
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\errors.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
JVC_ERR(ERRnone         ,0, 0                                                   )
JVC_ERR(ERRignore       ,0, "Potential problem: %s (in '%s')"                   )
JVC_ERR(ERRinternal     ,0, "Internal: %s"                                      )
JVC_ERR(ERRnoMemory     ,0, "Out of memory"                                     )
JVC_ERR(ERRbadCode      ,0, "Invalid code: '%s'(in '%s')"                       )

#ifndef NOT_JITC
JVC_ERR(ERRreadErr      ,0, "Could not read class file '%s'"                    )
#endif

#ifdef  TGT_IA64

JVC_ERR(ERRopenWrErr    ,0, "Could not open target file '%s' for writing"       )
JVC_ERR(ERRopenRdErr    ,0, "Could not open source file '%s' for reading"       )

JVC_ERR(ERRloadPDB      ,0, "Could not load 'MSPDB60.DLL'"                      )
JVC_ERR(ERRwithPDB      ,0, "Error related to PDB: %s"                          )

JVC_ERR(ERRwriteErr     ,0, "Could not write to output file '%s'"               )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\error.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                           error.cpp                                       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/

#undef fatal

/*****************************************************************************/

#include "error.h"

#ifdef NOT_JITC
#include <winbase.h>
#undef  JVC_ERR
#define JVC_ERR(name, lvl, str)  str,
#define JVC_WR1(name, lvl, str)  str,
#define JVC_WRN(name, lvl, str)  str,
static  const   char *  errorTable[] =
{
    #include "errors.h"
};
#undef  JVC_ERR
#undef  JVC_WR1
#undef  JVC_WRN
#endif

/*****************************************************************************/
#if !defined(NOT_JITC)
/*****************************************************************************/

#undef  JVC_ERR
#define JVC_ERR(name, lvl, str)  str,
#define JVC_WR1(name, lvl, str)  str,
#define JVC_WRN(name, lvl, str)  str,
static  const   char *  errorTable[] =
{
    #include "errors.h"
};
#undef  JVC_ERR
#undef  JVC_WR1
#undef  JVC_WRN

/*****************************************************************************/

unsigned            ErrorCount;
const   char *      ErrorSrcf;

unsigned            ErrorMssgDisabled;

/*****************************************************************************/

static
void                showMsg(unsigned errNum, const char *kind, va_list args)
{
    assert(errNum != ERRnone);

#ifdef DEBUG
    if  (!ErrorMssgDisabled)
    {
        /* Display the message */

        printf("%s: ", kind);

        /* Form the error message string */

        vprintf(errorTable[errNum], args);
        printf("\n");
    }
#endif

    return;
}

/*****************************************************************************/

void    _cdecl      error(unsigned errNum, ...)
{
    va_list  args;
    va_start(args, errNum);
    showMsg (errNum, "error", args);
    va_end  (args);

    ErrorCount++;
}

/*****************************************************************************/

void    _cdecl      fatal(unsigned errNum, ...)
{
    va_list  args;
    va_start(args, errNum);
    showMsg (errNum, "fatal error", args);
    va_end  (args);

    ErrorCount++;

    if  (errNum != ERRignore)
        BreakIfDebuggerPresent();

#if TRAP_VIA_SETJMP
    if  (g_currentErrorTrap)
#endif
        jmpErrorTrap(errNum);
}

/*****************************************************************************/
#endif//!NOT_JITC
/*****************************************************************************/
#ifdef  NOT_JITC


// On windows, we need to set the MB_SERVICE_NOTIFICATION bit on message
//  boxes, but that bit isn't defined under windows CE.  This bit of code
//  will provide '0' for the value, and if the value ever is defined, will
//  pick it up automatically.

#if defined(MB_SERVICE_NOTIFICATION)
 # define COMPLUS_MB_SERVICE_NOTIFICATION MB_SERVICE_NOTIFICATION
#else
 # define COMPLUS_MB_SERVICE_NOTIFICATION 0
#endif


#if defined(BIRCH_SP2) && !defined(COMPLUS_BUILD)

#define NoGuiOnAssert() false
#define TerminateOnAssert() {;}
#define LogAssert(x,y,z) {;}

#else // normal COM+ case

#undef NoGuiOnAssert
#undef TerminateOnAssert
#undef LogAssert

// VOID _cdecl LogAssert( LPCSTR szFile, int iLine, LPCSTR expr);
// BOOL _cdecl NoGuiOnAssert();
// VOID _cdecl TerminateOnAssert();


typedef BOOL (_stdcall *stdboolfptr) ();
typedef VOID (_stdcall *stdfptr) ();
typedef VOID (_stdcall *plogassertptr) (LPCSTR, int, LPCSTR);

BOOL (_stdcall *pNoGuiOnAssert)() = 0;
VOID (_stdcall *pLogAssert)(LPCSTR szFile, int iLine, LPCSTR expr) = 0;
VOID (_stdcall *pTerminateOnAssert)() = 0;

void ConnectToRuntime()
{
    HINSTANCE msCorEE = LoadLibrary(TEXT("mscoree.dll"));

    if (msCorEE)
    {
        pNoGuiOnAssert = (stdboolfptr)GetProcAddress(msCorEE,"LogHelp_NoGuiOnAssert");
        pLogAssert     = (plogassertptr)GetProcAddress(msCorEE, "LogHelp_LogAssert");
        pTerminateOnAssert = (stdfptr)GetProcAddress(msCorEE, "LogHelp_TerminateOnAssert");

        /* Technically it is wrong to call FreeLibrary right away (while holding on to the
           entry points. Alas, we can get here only after being called by the EE, so it
           will be around no matter what.

           NOTE: This will not work it the DLL will run in another context (i.e. not in the
           context of mscoree.dll!!!!
        */
        FreeLibrary(msCorEE);
    }

}

bool NoGuiOnAssert()
{
    if (!pNoGuiOnAssert)
        ConnectToRuntime();
    if (!pNoGuiOnAssert)
        return false;
    else
        return (pNoGuiOnAssert()? true : false);
}

inline
void LogAssert(LPCSTR szFile, int iLine, LPCSTR expr)
{
    assert(pLogAssert);

    pLogAssert(szFile, iLine, expr);
}

inline
void TerminateOnAssert()
{
    assert(pTerminateOnAssert);

    pTerminateOnAssert();
}

#endif


void    _cdecl      fatal(unsigned errNum, ...)
{
#ifndef OPT_IL_JIT
#ifndef NDEBUG
    char buff[1024];
    va_list  args;
    va_start(args, errNum);
    wsprintf(buff, "fatal error #%02d: ", errNum);
    OutputDebugString(buff);
    wvsprintf(buff, errorTable[errNum], args);
    OutputDebugString(buff);
    OutputDebugString("\n");
    va_end  (args);

    if (getEERegistryDWORD("JitRequired", 1))
    {
        if (NoGuiOnAssert())
        {
            LogAssert("", 0, buff);
            jmpErrorTrap(errNum);
        }

        char buffMsg[1024];

        sprintf(buffMsg, "%s\n\nHit [Ignore] and the method will be interpreted", buff);

        switch (MessageBox(NULL, buffMsg, TEXT("Microsoft JIT Compiler"),
                           MB_ABORTRETRYIGNORE | COMPLUS_MB_SERVICE_NOTIFICATION))
        {
        case IDABORT  : exit(0);
        case IDRETRY  : DebugBreak(); break;
        case IDIGNORE : break;
        }
    }
    else
    {
        BreakIfDebuggerPresent();
    }
#endif // NDEBUG
#else  // OPT_IL_JIT
    DebugBreak(); // OptJit does not yet set the error trap. So just break
#endif

    jmpErrorTrap(errNum);
}

#endif

/*****************************************************************************/
#if TRAP_VIA_SETJMP

errTrapDesc *       g_currentErrorTrap;

#else

int                 __JITfilter(int exceptCode, void *exceptInfo, int *errCode)
{
                // Only catch EH from __JVCraiseErr
        return(exceptCode ==  0x02345678);
}

void                __JITraiseErr(int errCode)
{
    DWORD       exceptArg = errCode;
    RaiseException(0x02345678, 0, 1, &exceptArg);
}

#endif

/*****************************************************************************/
#ifndef NDEBUG

const   char *  jitCurSource = NULL;

extern  "C"
void  __cdecl   assertAbort(const char *why,
                            const char *what, const char *file, unsigned line)
{

#if defined(UNDER_CE_GUI) || defined(NOT_JITC)

#if defined(UNDER_CE_GUI)
    MYCHAR      buff[1024];
#else
    char               buff[1024];
#endif

#ifndef UNDER_CE_GUI
    if (NoGuiOnAssert())
    {
        if (what)
            sprintf(buff, "Assertion failed '%s' in '%s'\n", why, what);
        else
            sprintf(buff, "Assertion failed '%s'\n", why);

        LogAssert(file, line, buff);
        TerminateOnAssert();
    }
#endif

    if  (what)
        sprintf(buff, "%s(%u) : Assertion failed '%s' in '%s'\n", file, line, why, what);
    else
        sprintf(buff, "%s(%u) : Assertion failed '%s'\n"        , file, line, why);

    switch (MessageBox(NULL, buff, TEXT("Microsoft JIT Compiler"),
                       MB_ABORTRETRYIGNORE | COMPLUS_MB_SERVICE_NOTIFICATION))
    {
    case IDABORT  : exit(0);
    case IDRETRY  : DebugBreak(); break;
    case IDIGNORE : return;
    }

#else // not [defined(UNDER_CE_GUI) || defined(NOT_JITC)]

#ifdef DEBUG
    printf("\n%s(%u) : Assertion failed '%s'", file, line, why);
    if  (what)
        printf(" in '%s'", what);
    printf("\n");

    _flushall();
#endif
    BreakIfDebuggerPresent();
    exit(2);

#endif

}

#endif
/*****************************************************************************/
void    totalCodeSizeEnd(){}
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\exec.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************/
#ifndef _EXEC_H_
#define _EXEC_H_
/*****************************************************************************/

struct BasicBlock;

/*****************************************************************************/

#pragma pack(push, 4)

/*****************************************************************************/

enum    execFixKinds
{
    FIX_MODE_ERROR,
    FIX_MODE_SELF32,
    FIX_MODE_SEGM32,
#if SCHEDULER
    FIX_MODE_SCHED,                     // fake fixup only used for scheduling
#endif
};

enum    execFixTgts
{
    FIX_TGT_ERROR = 0,

    // The first group of fixups are the same as the CCF format

    FIX_TGT_HELPER          =  1,       // target is a VM helper function
    FIX_TGT_FIELD_OFFSET    =  2,       // target is a field offset
    FIX_TGT_VTABLE_OFFSET   =  3,       // target is a vtable offset
    FIX_TGT_STATIC_METHOD   =  4,       // target is a static member address
    FIX_TGT_STATIC_FIELD    =  5,       // target is a static member address
    FIX_TGT_CLASS_HDL       =  6,       // target is a class handle
    FIX_TGT_METHOD_HDL      =  7,       // target is a method handle
    FIX_TGT_FIELD_HDL       =  8,       // target is a field handle
    FIX_TGT_STATIC_HDL      =  9,       // target is a static data block handle
    FIX_TGT_IID             = 10,       // target is an interface ID
    FIX_TGT_STRCNS_HDL      = 11,       // target is a string literal handle
    FIX_TGT_VM_DATA         = 12,       // target is address of static VM data
    FIX_TGT_DESCR_METHOD    = 13,       // target is a descriptor of a method

    // These are additional fixups internal to the VM

    FIX_TGT_CONST           = 17,       // target is a constant   data item
    FIX_TGT_DATA,                       // target is a read/write data item
    FIX_TGT_LCLADR,                     // target is a     local function
    FIX_TGT_EXTADR,                     // target is an external function
    FIX_TGT_RECURSE,                    // target is our own method
    FIX_TGT_STATDM,                     // target is a static data member   (OLD)

#if SCHEDULER
    FIX_TGT_SCHED,                      // fake fixup only used for scheduling
#endif
};

struct  execFixDsc
{
    unsigned        efdOffs;            // offset of fixed-up location
    union
    {
    void       *    efdTgtAddr;         // handle to code   target
    BasicBlock *    efdTgtCode;         // handle to code   target
    unsigned        efdTgtData;         // offset of data   target
    int             efdTgtHlpx;         // index  of helper target
#if defined(JIT_AS_COMPILER) || defined(LATE_DISASM)
    METHOD_HANDLE   efdTgtMeth;         // method handle of target
    struct
    {
        SCOPE_HANDLE    cls;			// TODO fix name 
        unsigned        CPidx;
    }
                    efdTgtCP;           // Class and Constant pool index of target
#endif
    FIELD_HANDLE    efdTgtSDMH;         // handle of static data member
#if     SCHEDULER
    unsigned        efdTgtInfo;         // info about schedulable instruction
#endif
    };

#ifdef  FAST
#if     SCHEDULER
    unsigned        efdMode     :2;     // fixup kind/mode
    unsigned        efdTarget   :6;     // fixup target kind
#else
    BYTE            efdMode;            // fixup kind/mode
    BYTE            efdTarget;          // fixup target kind
#endif
#else
    execFixKinds    efdMode;            // fixup kind/mode
    execFixTgts     efdTarget;          // fixup target kind
#endif

#if     SCHEDULER

    unsigned        efdInsSize  :4;     // instruction size (bytes of code)

    unsigned        efdInsSetFL :1;     // this          instruction sets the flags?
    unsigned        efdInsUseFL :1;     // this          instruction uses the flags?

    unsigned        efdInsNxtFL :1;     // the following instruction uses the flags?

    unsigned        efdInsUseX87:1;     // uses the numeric processor

#endif

};

struct  execMemDsc
{
    execMemDsc  *   emdNext;            // next member in the list

    char    *       emdName;            // null-terminated member name

    unsigned        emdCodeSize;        // the size    of code
    BYTE    *       emdCodeAddr;        // the address of code

    unsigned        emdConsSize;        // the size    of read-only  data
    BYTE    *       emdConsAddr;        // the address of read-only  data

    unsigned        emdDataSize;        // the size    of read-write data
    BYTE    *       emdDataAddr;        // the address of read-write data
};

struct  execClsDsc
{
    const   char *  ecdClassPath;       // name of the class file (?)

    unsigned        ecdMethodCnt;       // number of method bodies
    execMemDsc  *   ecdMethodLst;       // list   of method bodies
};

/*****************************************************************************/
#pragma pack(pop)
/*****************************************************************************/

#ifndef EXECCC
#define EXECCC      __fastcall
#endif

/*****************************************************************************
 *
 *  The following is used by EMIT.CPP to build an executable descriptor
 *  for a class.
 */

execClsDsc* EXECCC  createExecClassInit(const char  * classPath);

execMemDsc* EXECCC  createExecAddMethod(execClsDsc  * dsc,
                                        const char  * name,
                                        unsigned      codeSize,
                                        unsigned      consSize,
                                        unsigned      dataSize);

execMemDsc* EXECCC  createExecAddStatDm(execClsDsc  * dsc,
                                        const char  * name,
                                        unsigned      size);

void      * EXECCC  createExecImageAddr(execMemDsc  * mem);

void        EXECCC  createExecClassDone(execClsDsc  * dsc);

/*****************************************************************************/

inline
void      * EXECCC  createExecCodeAddr(execMemDsc   * mem)
{
    return  mem->emdCodeAddr;
}

inline
void      * EXECCC  createExecConsAddr(execMemDsc   * mem)
{
    return  mem->emdConsAddr;
}

inline
void      * EXECCC  createExecDataAddr(execMemDsc   * mem)
{
    return  mem->emdDataAddr;
}

/*****************************************************************************/
#endif  // _EXEC_H_
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\fake.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "jitpch.h"
#pragma hdrstop

#if 0

#define DECLARE_DATA
#include "OpMaps.h"

#define JIT_OR_NATIVE_SUPPORTED 1
#include "SigInfo.cpp"
//#include "corhandle.cpp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\fclsia64.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// The first argument is the name (used to declare the enum)
//
// The last 3 arguments are non-zero if instructions of the given class
// can only execute in the 0'th execution unit; the order is F,I,M.
//

#ifndef FU_DEF
#error  Must define FU_DEF before including this file
#endif

//     name
//
//                F0 only
//                  I0 only
//                    M0 only

FU_DEF(NONE,      0,0,0)

FU_DEF(BR,        0,0,0)
FU_DEF(BRP,       0,0,0)
FU_DEF(CHK,       0,0,0)
FU_DEF(CLD,       0,0,0)
FU_DEF(FCLD,      0,0,0)
FU_DEF(FCMP,      0,0,0)
FU_DEF(FCVTFP,    0,0,0)
FU_DEF(FCVTINT,   0,0,0)
FU_DEF(FLD,       0,0,0)
FU_DEF(FLDP,      0,0,0)
FU_DEF(FMAC,      0,0,0)
FU_DEF(FMISC,     0,0,0)
FU_DEF(FRAR,      0,0,0)
FU_DEF(FRBR,      0,0,0)
FU_DEF(FRCR,      0,0,0)
FU_DEF(FRFR,      0,0,0)
FU_DEF(FRIP,      0,0,0)
FU_DEF(FRPR,      0,0,0)
FU_DEF(IALU,      0,0,0)
FU_DEF(ICMP,      0,0,0)
FU_DEF(ILOG,      0,0,0)
FU_DEF(ISHF,      0,0,0)
FU_DEF(LD,        0,0,0)
FU_DEF(MMALU,     0,0,0)
FU_DEF(MMMUL,     0,0,0)
FU_DEF(MMSHF,     0,0,0)
FU_DEF(NOP,       0,0,0)
FU_DEF(RSE_B,     0,0,0)
FU_DEF(RSE_M,     0,0,0)
FU_DEF(SFCVTINT,  0,0,0)
FU_DEF(SFMAC,     0,0,0)
FU_DEF(SFMISC,    0,0,0)
FU_DEF(ST,        0,0,0)
FU_DEF(SYST,      0,0,0)
FU_DEF(TBIT,      0,0,0)
FU_DEF(TOAR,      0,0,0)
FU_DEF(TOBR,      0,0,0)
FU_DEF(TOCR,      0,0,0)
FU_DEF(TOFR,      0,0,0)
FU_DEF(TOPR,      0,0,0)
FU_DEF(XMPY,      0,0,0)

#undef  FU_DEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\gentree.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          GenTree                                          XX
XX                                                                           XX
XX  This is the node in the semantic tree graph. It represents the operation XX
XX  corresponing to the node, and other information during code-gen          XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

/*****************************************************************************/
#ifndef _GENTREE_H_
#define _GENTREE_H_
/*****************************************************************************/

#include "vartype.h"    // For "var_types"
#include "target.h"     // For "regNumber"

/*****************************************************************************/

enum genTreeOps
{
    #define GTNODE(en,sn,cm,ok) en,
    #include "gtlist.h"
    #undef  GTNODE

    GT_COUNT
};

/*****************************************************************************
 *
 *  The following enum defines a set of bit flags that can be used
 *  to classify expression tree nodes. Note that some operators will
 *  have more than one bit set, as follows:
 *
 *          GTK_CONST    implies    GTK_LEAF
 *          GTK_RELOP    implies    GTK_BINOP
 *          GTK_LOGOP    implies    GTK_BINOP
 */

enum genTreeKinds
{
    GTK_NONE    = 0x0000,       // unclassified operator

    GTK_CONST   = 0x0001,       // constant     operator
    GTK_LEAF    = 0x0002,       // leaf         operator
    GTK_UNOP    = 0x0004,       // unary        operator
    GTK_BINOP   = 0x0008,       // binary       operator
    GTK_RELOP   = 0x0010,       // comparison   operator
    GTK_LOGOP   = 0x0020,       // logical      operator
    GTK_ASGOP   = 0x0040,       // assignment   operator

    GTK_COMMUTE = 0x0080,       // commutative  operator

    /* Define composite value(s) */

    GTK_SMPOP   = (GTK_UNOP|GTK_BINOP|GTK_RELOP|GTK_LOGOP)
};

/*****************************************************************************/
#if INLINE_MATH
/*****************************************************************************
 *
 *  Enum used for GT_MATH calls.
 */

enum mathIntrinsics
{
    MATH_FN_ABS,
    MATH_FN_EXP,
    MATH_FN_SIN,
    MATH_FN_COS,
    MATH_FN_SQRT,
    MATH_FN_POW,

    MATH_FN_NONE,
};

/*****************************************************************************/
#endif
/*****************************************************************************/

#define SMALL_TREE_NODES    1

/*****************************************************************************/

enum gtCallTypes
{
    CT_USER_FUNC,       // User function
    CT_HELPER,          // Jit-helper
    CT_DESCR,           // @TODO: Obsolete but the name is used by the RISC emitter
    CT_INDIRECT,        // Indirect call

    CT_COUNT            // fake entry (must be last)
};

/*****************************************************************************/

struct                  BasicBlock;

/*****************************************************************************/

typedef
struct GenTree        * GenTreePtr;

/*****************************************************************************/
#pragma pack(push, 4)
/*****************************************************************************/

struct GenTree
{

#ifdef  FAST
    BYTE                gtOper;
    BYTE                gtType;
#else
    genTreeOps          gtOper;
    var_types           gtType;
#endif
    genTreeOps          OperGet() { return (genTreeOps)gtOper; };
    var_types           TypeGet() { return (var_types )gtType; };

#if CSE

    unsigned char       gtCost;         // estimate of expression cost

    #define MAX_COST    UCHAR_MAX
    union
    {
          signed char   gtCSEnum;       // 0 or CSE index (negated if def)
                                        // valid only for CSE expressions
        unsigned char   gtConstAsgNum;  // 0 or Const Assignment index
                                        // valid only for GT_ASG nodes
    };
    union
    {
        unsigned char   gtCopyAsgNum;   // 0 or Copy Assignment index
                                        // valid only for GT_ASG nodes
#if TGT_x86
        unsigned char   gtStmtFPrvcOut; // FP regvar count on exit
#endif                                  // valid only for GT_STMT nodes
    };

#endif // end CSE

#if TGT_x86

    regMaskSmall        gtRsvdRegs;     // set of fixed trashed  registers
    regMaskSmall        gtUsedRegs;     // set of used (trashed) registers
    unsigned char       gtFPregVars;    // count of enregistered FP variables
    unsigned char       gtFPlvl;        // x87 stack depth at this node

#else // not TGT_x86

    unsigned char       gtTempRegs;     // temporary registers used by op

#if!TGT_IA64
    regMaskSmall        gtIntfRegs;     // registers used at this node
#endif

#endif

#if TGT_IA64

       regNumberSmall   gtRegNum;       // which register      the value is in

#else

    union
    {
       regNumberSmall   gtRegNum;       // which register      the value is in
       regPairNoSmall   gtRegPair;      // which register pair the value is in
    };

#endif

    unsigned            gtFlags;        // see GTF_xxxx below

    union
    {
        VARSET_TP       gtLiveSet;      // set of variables live after op - not used for GT_STMT
#if defined(DEBUGGING_SUPPORT) || defined(DEBUG)
        IL_OFFSET       gtStmtILoffs;   // IL offset (if available) - only for GT_STMT nodes
#endif
    };

    //---------------------------------------------------------------------
    //  The first set of flags can be used with a large set of nodes, and
    //  thus they must all have distinct values. That is, one can test any
    //  expression node for one of these flags.
    //---------------------------------------------------------------------

    #define GTF_ASG             0x00000001  // sub-expression contains an assignment
    #define GTF_CALL            0x00000002  // sub-expression contains a  func. call
    #define GTF_EXCEPT          0x00000004  // sub-expression might throw an exception
    #define GTF_GLOB_REF        0x00000008  // sub-expression uses global variable(s)
    #define GTF_OTHER_SIDEEFF   0x00000010  // sub-expression has other side effects

    #define GTF_SIDE_EFFECT     (GTF_ASG|GTF_CALL|GTF_EXCEPT|GTF_OTHER_SIDEEFF)
    #define GTF_GLOB_EFFECT     (GTF_ASG|GTF_CALL|GTF_EXCEPT|GTF_OTHER_SIDEEFF|GTF_GLOB_REF)

    #define GTF_REVERSE_OPS     0x00000020  // second operand should be eval'd first
    #define GTF_REG_VAL         0x00000040  // operand is sitting in a register

    #define GTF_SPILLED         0x00000080  // the value   has been spilled
    #define GTF_SPILLED_OPER    0x00000100  // sub-operand has been spilled
    #define GTF_SPILLED_OP2     0x00000200  // both sub-operands have been spilled

    #define GTF_ZF_SET          0x00000400  // the zero/sign flag  set to the operand
    #define GTF_CC_SET          0x00000800  // all condition flags set to the operand

#if CSE
    #define GTF_DEAD            0x00001000  // this node isn't used any more
    #define GTF_DONT_CSE        0x00002000  // don't bother CSE'ing this expr
    #define GTF_MAKE_CSE        0x00004000  // try hard to make this into CSE
#endif

#if !defined(NDEBUG) && defined(SMALL_TREE_NODES)
    #define GTF_NODE_LARGE      0x00008000
    #define GTF_NODE_SMALL      0x00010000
    #define GTF_PRESERVE        (GTF_NODE_SMALL|GTF_NODE_LARGE)
#else
    #define GTF_PRESERVE        (0)
#endif

    #define GTF_NON_GC_ADDR     0x00020000  // non-GC pointer value

    #define GTF_BOOLEAN         0x00040000  // value is known to be 0/1

    #define GTF_SMALL_OK        0x00080000  // actual small int sufficient

    #define GTF_UNSIGNED        0x00100000  // the specified node is an unsigned operator or type

    #define GTF_REG_ARG         0x00200000  // the specified node is a register argument

    #define GTF_CONTEXTFUL      0x00400000  // TYP_REF node with contextful class

#if TGT_RISC
    #define GTF_DEF_ADDRMODE    0x00800000  // address mode which may not be ready yet
#endif

    //---------------------------------------------------------------------
    //  The following flags can be used only with a small set of nodes, and
    //  thus their values need not be distinct (other than within the set
    //  that goes with a particular node/nodes, of course). That is, one can
    //  only test for one of these flags if the 'gtOper' value is tested as
    //  well to make sure it's the right opetrator for the particular flag.
    //---------------------------------------------------------------------

    #define GTF_VAR_DEF         0x80000000  // GT_LCL_VAR -- this is a definition
    #define GTF_VAR_USE         0x40000000  // GT_LCL_VAR -- this is a use/def for a x<op>=y
    #define GTF_VAR_USEDEF      0x20000000  // GT_LCL_VAR -- this is a use/def as in x=x+y (only the lhs x is tagged)
    #define GTF_VAR_NARROWED    0x10000000  // GT_LCL_VAR -- narrowed (long -> int)

    #define GTF_REG_BIRTH       0x08000000  // GT_REG_VAR -- variable born here
    #define GTF_REG_DEATH       0x04000000  // GT_REG_VAR -- variable dies here

    #define GTF_NOP_RNGCHK      0x80000000  // GT_NOP     -- checked array index
    #define GTF_NOP_DEATH       0x40000000  // GT_NOP     -- operand dies here

    #define GTF_CALL_VIRT       0x80000000  // GT_CALL    -- virtual   call?
    #define GTF_CALL_INTF       0x40000000  // GT_CALL    -- interface call?
    #define GTF_CALL_USER    (0*0x20000000) // GT_CALL    -- call to a user function?
    #define GTF_CALL_UNMANAGED  0x20000000  // GT_CALL    -- direct call to unmanaged code
    #define GTF_CALL_POP_ARGS   0x10000000  // GT_CALL    -- caller pop arguments?
    #define GTF_CALL_RETBUFFARG 0x08000000  // GT_CALL    -- first parameter is the return buffer argument
    #define GTF_CALL_TAILREC    0x04000000  // GT_CALL    -- this is a tail-recursive call

    /* This is currently disabled - if enable we have to find more bits for the call flags */
    #define GTF_CALL_REGSAVE (0*0x02000000) // - GT_CALL  -- call preserves all regs?

    #define GTF_DELEGATE_INVOKE 0x02000000  // GT_CALL    -- call to Delegate.Invoke
    #define GTF_CALL_VIRT_RES   0x01000000  // GT_CALL    -- resolvable virtual call. Can call direct

    #define GTF_IND_RNGCHK      0x40000000  // GT_IND     -- checked array index
    #define GTF_IND_OBJARRAY    0x20000000  // GT_IND     -- the array holds objects (effects layout of Arrays)
    #define GTF_IND_TGTANYWHERE 0x10000000  // GT_IND     -- the target could be anywhere
    #define GTF_IND_TLS_REF     0x08000000  // GT_IND     -- the target is accessed via TLS

    #define GTF_ADDR_ONSTACK    0x80000000  // GT_ADDR    -- this expression is guarenteed to be on the stack

    #define GTF_INX_RNGCHK      0x80000000  // GT_INDEX   -- checked array index

    #define GTF_ALN_CSEVAL      0x80000000  // GT_ARR_RNG -- copied for CSE

    #define GTF_MUL_64RSLT      0x80000000  // GT_MUL     -- produce 64-bit result

    #define GTF_CMP_NAN_UN      0x80000000  // GT_<cond>  -- Is branch taken if ops are NaN?

    #define GTF_JMP_USED        0x40000000  // GT_<cond>  -- result of compare used for jump or ?:

    #define GTF_QMARK_COND      0x20000000  // GT_<cond>  -- the node is the condition for ?:

    #define GTF_ICON_HDL_MASK   0xF0000000  // Bits used by handle types below

    #define GTF_ICON_SCOPE_HDL  0x10000000  // GT_CNS_INT -- constant is a scope handle
    #define GTF_ICON_CLASS_HDL  0x20000000  // GT_CNS_INT -- constant is a class handle
    #define GTF_ICON_METHOD_HDL 0x30000000  // GT_CNS_INT -- constant is a method handle
    #define GTF_ICON_FIELD_HDL  0x40000000  // GT_CNS_INT -- constant is a field handle
    #define GTF_ICON_STATIC_HDL 0x50000000  // GT_CNS_INT -- constant is a handle to static data
    #define GTF_ICON_IID_HDL    0x60000000  // GT_CNS_INT -- constant is a interface ID
    #define GTF_ICON_STR_HDL    0x70000000  // GT_CNS_INT -- constant is a string literal handle
    #define GTF_ICON_PTR_HDL    0x80000000  // GT_CNS_INT -- constant is a ldptr handle
    #define GTF_ICON_VARG_HDL   0x90000000  // GT_CNS_INT -- constant is a var arg cookie handle
    #define GTF_ICON_TOKEN_HDL  0xA0000000  // GT_CNS_INT -- constant is a token handle
    #define GTF_ICON_TLS_HDL    0xB0000000  // GT_CNS_INT -- constant is a TLS ref with offset
    #define GTF_ICON_FTN_ADDR   0xC0000000  // GT_CNS_INT -- constant is a function address


#if     TGT_SH3
    #define GTF_SHF_NEGCNT      0x80000000  // GT_RSx     -- shift count negated?
#endif

    #define GTF_OVERFLOW        0x10000000  // GT_ADD, GT_SUB, GT_MUL, - Need overflow check
                                            // GT_ASG_ADD, GT_ASG_SUB,
                                            // GT_POST_INC, GT_POST_DEC,
                                            // GT_CAST
                                            // Use gtOverflow(Ex)() to check this flag

    //----------------------------------------------------------------

    #define GTF_STMT_CMPADD     0x80000000  // GT_STMT    -- added by compiler

    //----------------------------------------------------------------

    GenTreePtr          gtNext;
    GenTreePtr          gtPrev;

    union
    {
        /*
            NOTE:   Any tree nodes that are larger than 8 bytes (two
                    ints or pointers) must be flagged as 'large' in
                    GenTree::InitNodeSize().
         */

        struct
        {
            GenTreePtr      gtOp1;
            GenTreePtr      gtOp2;
        }
                        gtOp;

        struct
        {
            unsigned        gtVal1;
            unsigned        gtVal2;
        }
                        gtVal;

        /* gtIntCon -- integer constant (GT_CNS_INT) */

        struct
        {
            long            gtIconVal;

#if defined(JIT_AS_COMPILER) || defined (LATE_DISASM)

            /*  If the constant was morphed from some other node,
                these fields enable us to get back to what the node
                originally represented. See use of gtNewIconHandleNode()
             */

            union
            {
                /* Template struct - The significant field of the other
                 * structs should overlap exactly with this struct
                 */

                struct
                {
                    unsigned        gtIconHdl1;
                    void *          gtIconHdl2;
                }
                                    gtIconHdl;

                /* GT_FIELD, etc */

                struct
                {
                    unsigned        gtIconCPX;
                    CLASS_HANDLE    gtIconCls;
                };
            };
#endif
        }
                        gtIntCon;

        /* gtLngCon -- long    constant (GT_CNS_LNG) */

        struct
        {
            __int64         gtLconVal;
        }
                        gtLngCon;

        /* gtFltCon -- float   constant (GT_CNS_FLT) */

        struct
        {
            float           gtFconVal;
        }
                        gtFltCon;

        /* gtDblCon -- double  constant (GT_CNS_DBL) */

        struct
        {
            double          gtDconVal;
        }
                        gtDblCon;

        /* gtStrCon -- string  constant (GT_CNS_STR) */

        struct
        {
            unsigned        gtSconCPX;
            SCOPE_HANDLE    gtScpHnd;
        }
                        gtStrCon;

        /* gtLvlVar -- local variable   (GT_LCL_VAR) */

        struct
        {
            unsigned        gtLclNum;
            IL_OFFSET       gtLclOffs;      // IL offset of ref (for debug info & remapping slot)
        }
                        gtLclVar;

        /* gtField  -- data member ref  (GT_FIELD) */

        struct
        {
            GenTreePtr      gtFldObj;
            FIELD_HANDLE    gtFldHnd;
#if HOIST_THIS_FLDS
            unsigned short  gtFldHTX;       // hoist index
#endif
        }
                        gtField;

        /* gtCall   -- method call      (GT_CALL) */

        struct
        {
            GenTreePtr      gtCallArgs;             // list of the arguments
            GenTreePtr      gtCallObjp;
            GenTreePtr      gtCallVptr;

#if USE_FASTCALL
            GenTreePtr      gtCallRegArgs;
            unsigned short  regArgEncode;           // argument register mask
#endif

            #define         GTF_CALL_M_CAN_TAILCALL 0x0001      // the call can be converted to a tailcall
            #define         GTF_CALL_M_TAILCALL     0x0002      // the call is a tailcall
            #define         GTF_CALL_M_NOGCCHECK    0x0004      // not a call for computing full interruptability

            unsigned short  gtCallMoreFlags;        // in addition to gtFlags

            gtCallTypes     gtCallType;
            unsigned        gtCallCookie;           // only used for CALLI unmanaged calls
                                                    // maybe union with gtCallVptr ?
            union
            {
              METHOD_HANDLE gtCallMethHnd;          // CT_USER_FUNC
                GenTreePtr  gtCallAddr;             // CT_INDIRECT
            };
        }
                        gtCall;

#if INLINE_MATH

        /* gtMath   -- math intrinsic   (binary op with an additional field) */

        struct
        {
            GenTreePtr      gtOp1;
            GenTreePtr      gtOp2;
            mathIntrinsics  gtMathFN;
        }
                        gtMath;

#endif

        /* gtIndex -- array access */

        struct
        {
            GenTreePtr      gtIndOp1;       // The pointer to indirect
            GenTreePtr      gtIndOp2;       // Label to jump to for array-index-out-of-range
            unsigned        elemSize;       // size of elements in the array
        }
                        gtIndex;

        /* gtInd -- indirect mem access (fields, arrays, C ptrs, etc) (GT_IND) */

        struct
        {
            GenTreePtr      gtIndOp1;       // The pointer to indirect
            GenTreePtr      gtIndOp2;       // Label to jump to for array-index-out-of-range

#if     CSELENGTH
                /* If  (gtInd->gtFlags & GTF_IND_RNGCHK) and (gtInd != NULL),
                   gtInd.gtArrLen is the array address for the range check */

            GenTreePtr      gtIndLen;       // array length node (optional)
#endif

#if     RNGCHK_OPT
            unsigned        gtIndex;        // Hash index for the index for range check tree
            unsigned        gtStkDepth;     // Only out-of-ranges at same stack depth can jump to the same label (finding return address is easier)
#endif
        }
                        gtInd;

#if     CSELENGTH

        /* gtArrLen -- array length. (GT_ARR_LENGTH)
           Hangs off gtInd.gtIndLen, or used for "arr.length" */

        struct
        {
            GenTreePtr      gtArrLenAdr;    // the array address node
            GenTreePtr      gtArrLenCse;    // optional CSE def/use expr
        }
                        gtArrLen;
#endif

        /* gtStmt   -- 'statement expr' (GT_STMT)
         * NOTE: GT_STMT is a SMALL NODE in retail */

        struct
        {
            GenTreePtr      gtStmtExpr;     // root of the expression tree
            GenTreePtr      gtStmtList;     // first node (for  forward walks)
#ifdef DEBUG
            IL_OFFSET       gtStmtLastILoffs;// IL offset at end of stmt
#endif
        }
                        gtStmt;

        /* This is also used for GT_MKREFANY */

        struct
        {
            GenTreePtr      gtOp1;          // pointer to object
            CLASS_HANDLE    gtClass;        // object being loaded
        }
                        gtLdObj;


        //--------------------------------------------------------------------
        //  The following nodes used only within the code generator:
        //--------------------------------------------------------------------

        /* gtRegVar -- 'register variable'  (GT_REG_VAR) */

        struct
        {
            unsigned        gtRegVar;       // variable #
            regNumberSmall  gtRegNum;       // register #
        }
                        gtRegVar;

        /* gtClsVar -- 'static data member' (GT_CLS_VAR) */

        struct
        {
            FIELD_HANDLE    gtClsVarHnd;    //
        }
                        gtClsVar;

        /* gtLabel  -- code label target    (GT_LABEL) */

        struct
        {
            BasicBlock  *   gtLabBB;
        }
                        gtLabel;


#ifdef  NOT_JITC //------------------------------------------------------------

        #define CPX_ISTYPE          (JIT_HELP_ISINSTANCEOF) // helper for OP_instanceof
        #define CPX_CHKCAST         (JIT_HELP_CHKCAST)      // helper for OP_checkcast

        #define CPX_ISTYPE_CLASS    (JIT_HELP_ISINSTANCEOFCLASS)
        #define CPX_CHKCAST_CLASS   (JIT_HELP_CHKCASTCLASS)
        #define CPX_INIT_CLASS      (JIT_HELP_INITCLASS)   // helper to initialize a class

        #define CPX_STRCNS          (JIT_HELP_STRCNS)   // helper for OP_ldc of "string"
        #define CPX_NEWCLS_DIRECT   (JIT_HELP_NEW_DIRECT)
        #define CPX_NEWCLS_DIRECT2  (JIT_HELP_NEW_DIRECT2)
        #define CPX_NEWCLS_SPECIALDIRECT (JIT_HELP_NEW_SPECIALDIRECT)
        #define CPX_NEWARR_1_DIRECT (JIT_HELP_NEWARR_1_DIRECT)

        #define CPX_NEWOBJ          (JIT_HELP_NEWOBJ)   // create a object that can be variable sized
        #define CPX_NEWSFAST        (JIT_HELP_NEWSFAST) // allocator for small, non-finalizer, non-array object
        #define CPX_NEWCLS_FAST     (JIT_HELP_NEWFAST)

        #define CPX_MON_ENTER       (JIT_HELP_MON_ENTER)   // helper for OP_monitorenter
        #define CPX_MON_EXIT        (JIT_HELP_MON_EXIT)    // helper for OP_monitorexit
        #define CPX_MONENT_STAT     (JIT_HELP_MON_ENTER_STATIC)
        #define CPX_MONEXT_STAT     (JIT_HELP_MON_EXIT_STATIC)

        #define CPX_RNGCHK_FAIL     (JIT_HELP_RNGCHKFAIL)  // helper for out-of-range indices
        #define CPX_THROW           (JIT_HELP_THROW)       // helper for CEE_THROW
        #define CPX_RETHROW         (JIT_HELP_RETHROW)     // helper for CEE_RETHROW

        #define CPX_USER_BREAKPOINT (JIT_HELP_USER_BREAKPOINT)  // helper for CEE_break
        #define CPX_ARITH_EXCPN     (JIT_HELP_OVERFLOW)    // helper to throw arith excptn

        #define CPX_LONG_LSH        (JIT_HELP_LLSH)     // helper for OP_lshl
        #define CPX_LONG_RSH        (JIT_HELP_LRSH)     // helper for OP_lshr
        #define CPX_LONG_RSZ        (JIT_HELP_LRSZ)     // helper for OP_lushr
        #define CPX_LONG_MUL        (JIT_HELP_LMUL)     // helper for OP_lmul
        #define CPX_LONG_DIV        (JIT_HELP_LDIV)     // helper for OP_ldiv
        #define CPX_LONG_MOD        (JIT_HELP_LMOD)     // helper for OP_lmod

        #define CPX_LONG_UDIV       (JIT_HELP_ULDIV)        // helper for div.u8
        #define CPX_LONG_UMOD       (JIT_HELP_ULMOD)        // helper for mod.u8
        #define CPX_LONG_MUL_OVF    (JIT_HELP_LMUL_OVF)     // helper for mul.ovf.i8
        #define CPX_ULONG_MUL_OVF   (JIT_HELP_ULMUL_OVF)    // helper for mul.ovf.u8
        #define CPX_DBL2INT_OVF     (JIT_HELP_DBL2INT_OVF)  // helper for convf.ovf.r8.i4
        #define CPX_DBL2LNG_OVF     (JIT_HELP_DBL2LNG_OVF)  // helper for convf.ovf.r8.i8
        #define CPX_ULNG2DBL        (CORINFO_HELP_ULNG2DBL) // helper for conv.r.un

        #define CPX_FLT2INT         (JIT_HELP_FLT2INT)  // helper for OP_f2i
        #define CPX_FLT2LNG         (JIT_HELP_FLT2LNG)  // helper for OP_f2l
        #define CPX_DBL2INT         (JIT_HELP_DBL2INT)  // helper for OP_d2i
        #define CPX_DBL2LNG         (JIT_HELP_DBL2LNG)  // helper for OP_d2l
        #define CPX_FLT_REM         (JIT_HELP_FLTREM)
        #define CPX_DBL_REM         (JIT_HELP_DBLREM)   // helper for OP_drem

        #define CPX_DBL2UINT_OVF    (CORINFO_HELP_DBL2UINT_OVF)
        #define CPX_DBL2ULNG_OVF    (CORINFO_HELP_DBL2ULNG_OVF)
        #define CPX_DBL2UINT        (CORINFO_HELP_DBL2UINT)
        #define CPX_DBL2ULNG        (CORINFO_HELP_DBL2ULNG)

        #define CPX_RES_IFC         (JIT_HELP_RESOLVEINTERFACE)     // helper for cee_callvirt(interface)

        #define CPX_EnC_RES_VIRT    (JIT_HELP_EnC_RESOLVEVIRTUAL)   // helper to get addr of EnC-added virtual method

        #define CPX_STATIC_DATA     (JIT_HELP_GETSTATICDATA) // helper for static data access
        #define CPX_GETFIELD32      (JIT_HELP_GETFIELD32)  // read  32-bit COM field
        #define CPX_GETFIELD64      (JIT_HELP_GETFIELD64)  // read  64-bit COM field
        #define CPX_PUTFIELD32      (JIT_HELP_PUTFIELD32)  // write 32-bit COM field
        #define CPX_PUTFIELD64      (JIT_HELP_PUTFIELD64)  // write 64-bit COM field
        #define CPX_GETFIELDOBJ     (JIT_HELP_GETFIELD32OBJ)
        #define CPX_PUTFIELDOBJ     (JIT_HELP_SETFIELD32OBJ)

        #define CPX_GETFIELDADDR    (JIT_HELP_GETFIELDADDR) // get the address of a field

        #define CPX_ARRADDR_ST      (JIT_HELP_ARRADDR_ST)  // helper for OP_aastore
        #define CPX_LDELEMA_REF     (CORINFO_HELP_LDELEMA_REF)

        #define CPX_BOX             (JIT_HELP_BOX)
        #define CPX_UNBOX           (JIT_HELP_UNBOX)
        #define CPX_GETREFANY       (JIT_HELP_GETREFANY)
        #define CPX_ENDCATCH        (JIT_HELP_ENDCATCH)

        #define CPX_GC_STATE        (JIT_HELP_GC_STATE)    // address of GC_STATE
        #define CPX_CALL_GC         (JIT_HELP_STOP_FOR_GC) // invoke GC
        #define CPX_POLL_GC         (JIT_HELP_POLL_GC)     // poll GC

        #define CPX_GC_REF_ASGN_EAX         (JIT_HELP_ASSIGN_REF_EAX)
        #define CPX_GC_REF_ASGN_EBX         (JIT_HELP_ASSIGN_REF_EBX)
        #define CPX_GC_REF_ASGN_ECX         (JIT_HELP_ASSIGN_REF_ECX)
        #define CPX_GC_REF_ASGN_ESI         (JIT_HELP_ASSIGN_REF_ESI)
        #define CPX_GC_REF_ASGN_EDI         (JIT_HELP_ASSIGN_REF_EDI)
        #define CPX_GC_REF_ASGN_EBP         (JIT_HELP_ASSIGN_REF_EBP)

        #define CPX_GC_REF_CHK_ASGN_EAX     (JIT_HELP_CHECKED_ASSIGN_REF_EAX)
        #define CPX_GC_REF_CHK_ASGN_EBX     (JIT_HELP_CHECKED_ASSIGN_REF_EBX)
        #define CPX_GC_REF_CHK_ASGN_ECX     (JIT_HELP_CHECKED_ASSIGN_REF_ECX)
        #define CPX_GC_REF_CHK_ASGN_ESI     (JIT_HELP_CHECKED_ASSIGN_REF_ESI)
        #define CPX_GC_REF_CHK_ASGN_EDI     (JIT_HELP_CHECKED_ASSIGN_REF_EDI)
        #define CPX_GC_REF_CHK_ASGN_EBP     (JIT_HELP_CHECKED_ASSIGN_REF_EBP)
        #define CPX_BYREF_ASGN              (JIT_HELP_ASSIGN_BYREF) // assign relative to a by-ref
        #define CPX_WRAP                    (JIT_HELP_WRAP)
        #define CPX_UNWRAP                  (JIT_HELP_UNWRAP)

#ifdef PROFILER_SUPPORT
        #define CPX_PROFILER_CALLING        (JIT_HELP_PROF_FCN_CALL)
        #define CPX_PROFILER_RETURNED       (JIT_HELP_PROF_FCN_RET)
        #define CPX_PROFILER_ENTER          (JIT_HELP_PROF_FCN_ENTER)
        #define CPX_PROFILER_LEAVE          (JIT_HELP_PROF_FCN_LEAVE)
#endif

        #define CPX_TAILCALL                (JIT_HELP_TAILCALL)

#else // NOT_JITC--------------------------------------------------------------

        #define CPX_ISTYPE                  ( 1)    // helper for OP_instanceof
        #define CPX_CHKCAST                 ( 2)    // helper for OP_checkcast

        #define CPX_ISTYPE_CLASS            ( 3)
        #define CPX_CHKCAST_CLASS           ( 4)

        #define CPX_INIT_CLASS              ( 5)    // helper to initialize a class

        #define CPX_NEWCLS                  (10)    // helper for OP_new

        #define CPX_NEWCLS_DIRECT           (13)
        #define CPX_NEWCLS_DIRECT2          (14)
        #define CPX_NEWCLS_SPECIALDIRECT    (15)
        #define CPX_NEWARR_1_DIRECT         (16)
        #define CPX_STRCNS                  (18)    // helper for OP_ldc of "string"
        #define CPX_NEWCLS_FAST             (19)
        #define CPX_NEWOBJ                  (20)    // create a object that can be variable sized

        #define CPX_RNGCHK_FAIL             (30)    // helper for out-of-range indices
        #define CPX_THROW                   (31)    // helper for CEE_RETHROW
        #define CPX_RETHROW                 (32)

        #define CPX_USER_BREAKPOINT         (33)
        #define CPX_ARITH_EXCPN             (34)    // helper to throw arith excptn

        #define CPX_MON_ENTER               (40)    // helper for OP_monitorenter
        #define CPX_MON_EXIT                (41)    // helper for OP_monitorexit
        #define CPX_MONENT_STAT             (42)
        #define CPX_MONEXT_STAT             (43)

        #define CPX_LONG_LSH                (50)    // helper for OP_lshl
        #define CPX_LONG_RSH                (51)    // helper for OP_lshr
        #define CPX_LONG_RSZ                (52)    // helper for OP_lushr
        #define CPX_LONG_MUL                (53)    // helper for OP_lmul
        #define CPX_LONG_DIV                (54)    // helper for OP_ldiv
        #define CPX_LONG_MOD                (55)    // helper for OP_lmod

        #define CPX_LONG_UDIV               (56)    // helper for CEE_UDIV
        #define CPX_LONG_UMOD               (57)    // helper for CEE_UMOD
        #define CPX_LONG_MUL_OVF            (58)    // helper for mul.ovf.i8
        #define CPX_ULONG_MUL_OVF           (59)    // helper for mul.ovf.u8
        #define CPX_DBL2INT_OVF             (60)    // helper for convf.ovf.r8.i4
        #define CPX_DBL2LNG_OVF             (61)    // helper for convf.ovf.r8.i8

        #define CPX_FLT2INT                 (70)    // helper for OP_f2i
        #define CPX_FLT2LNG                 (71)    // helper for OP_f2l
        #define CPX_DBL2INT                 (72)    // helper for OP_d2i
        #define CPX_DBL2LNG                 (73)    // helper for OP_d2l
        #define CPX_FLT_REM                 (74)
        #define CPX_DBL_REM                 (75)    // helper for OP_drem

        #define CPX_RES_IFC                 (80)    // helper for OP_invokeinterface
        #define CPX_RES_IFC_TRUSTED         (81)
        #define CPX_RES_IFC_TRUSTED2        (82)
        #define CPX_EnC_RES_VIRT            (83)    // helper to get addr of EnC-added virtual method

        #define CPX_GETFIELD32              (90)    // read  32-bit COM field
        #define CPX_GETFIELD64              (91)    // read  64-bit COM field
        #define CPX_PUTFIELD32              (92)    // write 32-bit COM field
        #define CPX_PUTFIELD64              (93)    // write 64-bit COM field

        #define CPX_GETFIELDOBJ             (94)    // read GC ref field
        #define CPX_PUTFIELDOBJ             (95)    // write GC ref field
        #define CPX_GETFIELDADDR            (96)    // get adddress of field

        #define CPX_ARRADDR_ST              (100)   // helper for OP_aastore
        #define CPX_GETOBJFIELD             (101)
        #define CPX_STATIC_DATA             (102)   // get base address of static data


        #define CPX_GC_STATE                (110)   // address of GC_STATE
        #define CPX_CALL_GC                 (111)   // invoke GC
        #define CPX_POLL_GC                 (112)   // poll GC

        #define CPX_GC_REF_ASGN_EAX         (120)
        #define CPX_GC_REF_ASGN_EBX         (121)
        #define CPX_GC_REF_ASGN_ECX         (122)
        #define CPX_GC_REF_ASGN_ESI         (123)
        #define CPX_GC_REF_ASGN_EDI         (124)
        #define CPX_GC_REF_ASGN_EBP         (125)

        #define CPX_GC_REF_CHK_ASGN_EAX     (130)
        #define CPX_GC_REF_CHK_ASGN_EBX     (131)
        #define CPX_GC_REF_CHK_ASGN_ECX     (132)
        #define CPX_GC_REF_CHK_ASGN_ESI     (133)
        #define CPX_GC_REF_CHK_ASGN_EDI     (134)
        #define CPX_GC_REF_CHK_ASGN_EBP     (135)

        #define CPX_BYREF_ASGN              (140)   // assign relative to a by-ref

        #define CPX_WRAP                    (141)
        #define CPX_UNWRAP                  (142)
        #define CPX_BOX                     (150)
        #define CPX_UNBOX                   (151)
        #define CPX_GETREFANY               (152)
        #define CPX_NEWSFAST                (153)
        #define CPX_ENDCATCH                (154)

#ifdef PROFILER_SUPPORT
        #define CPX_PROFILER_CALLING        (156)
        #define CPX_PROFILER_RETURNED       (157)
        #define CPX_PROFILER_ENTER          (158)
        #define CPX_PROFILER_LEAVE          (159)
#endif



#if !   CPU_HAS_FP_SUPPORT

        #define CPX_R4_ADD                  (160)   // float  +
        #define CPX_R8_ADD                  (161)   // double +
        #define CPX_R4_SUB                  (162)   // float  -
        #define CPX_R8_SUB                  (163)   // double -
        #define CPX_R4_MUL                  (164)   // float  *
        #define CPX_R8_MUL                  (165)   // double *
        #define CPX_R4_DIV                  (166)   // float  /
        #define CPX_R8_DIV                  (167)   // double /

        #define CPX_R4_EQ                   (170)   // float  ==
        #define CPX_R8_EQ                   (171)   // double ==
        #define CPX_R4_NE                   (172)   // float  !=
        #define CPX_R8_NE                   (173)   // double !=
        #define CPX_R4_LT                   (174)   // float  <
        #define CPX_R8_LT                   (175)   // double <
        #define CPX_R4_LE                   (176)   // float  <=
        #define CPX_R8_LE                   (177)   // double <=
        #define CPX_R4_GE                   (178)   // float  >=
        #define CPX_R8_GE                   (179)   // double >=
        #define CPX_R4_GT                   (180)   // float  >
        #define CPX_R8_GT                   (181)   // double >

        #define CPX_R4_NEG                  (190)   // float  - (unary)
        #define CPX_R8_NEG                  (191)   // double - (unary)

        #define CPX_R8_TO_I4                (200)   // double -> int
        #define CPX_R8_TO_I8                (201)   // double -> long
        #define CPX_R8_TO_R4                (202)   // double -> float

        #define CPX_R4_TO_I4                (203)   // float  -> int
        #define CPX_R4_TO_I8                (204)   // float  -> long
        #define CPX_R4_TO_R8                (205)   // float  -> double

        #define CPX_I4_TO_R4                (206)   // int    -> float
        #define CPX_I4_TO_R8                (207)   // int    -> double

        #define CPX_I8_TO_R4                (208)   // long   -> float
        #define CPX_I8_TO_R8                (209)   // long   -> double

        #define CPX_R8_TO_U4                (220)   // double -> uint
        #define CPX_R8_TO_U8                (221)   // double -> ulong
        #define CPX_R4_TO_U4                (222)   // float  -> uint
        #define CPX_R4_TO_U8                (223)   // float  -> ulong
        #define CPX_U4_TO_R4                (224)   // uint   -> float
        #define CPX_U4_TO_R8                (225)   // uint   -> double
        #define CPX_U8_TO_R4                (226)   // ulong  -> float
        #define CPX_U8_TO_R8                (227)   // ulong  -> double

#endif//CPU_HAS_FP_SUPPORT

#if     TGT_IA64

        #define CPX_R4_DIV                  (166)   // float  /
        #define CPX_R8_DIV                  (167)   // double /

#else

        #define CPX_ULNG2DBL                (228)

#endif

        #define CPX_DBL2UINT_OVF            (229)
        #define CPX_DBL2ULNG_OVF            (230)
        #define CPX_DBL2UINT                (231)
        #define CPX_DBL2ULNG                (232)

#ifdef  USE_HELPERS_FOR_INT_DIV
        #define CPX_I4_DIV                  (240)   // int    /
        #define CPX_I4_MOD                  (241)   // int    %

        #define CPX_U4_DIV                  (242)   // uint   /
        #define CPX_U4_MOD                  (243)   // unit   %
#endif

        #define CPX_TAILCALL                (250)
        #define CPX_LDELEMA_REF             (251)

#endif // NOT_JITC-------------------------------------------------------------

        #define CPX_MATH_POW                (300)   // "fake" helper

        #define CPX_HIGHEST                 (999)   // be conservative
    };


    static
    const   BYTE    gtOperKindTable[GT_COUNT];

    static
    unsigned        OperKind(unsigned gtOper)
    {
        assert(gtOper < GT_COUNT);

        return  gtOperKindTable[gtOper];
    }

    unsigned        OperKind()
    {
        assert(gtOper < GT_COUNT);

        return  gtOperKindTable[gtOper];
    }

    static
    int             OperIsConst(genTreeOps gtOper)
    {
        return  (OperKind(gtOper) & GTK_CONST  ) != 0;
    }

    int             OperIsConst()
    {
        return  (OperKind(gtOper) & GTK_CONST  ) != 0;
    }

    static
    int             OperIsLeaf(genTreeOps gtOper)
    {
        return  (OperKind(gtOper) & GTK_LEAF   ) != 0;
    }

    int             OperIsLeaf()
    {
        return  (OperKind(gtOper) & GTK_LEAF   ) != 0;
    }

    static
    int             OperIsCompare(genTreeOps gtOper)
    {
        return  (OperKind(gtOper) & GTK_RELOP  ) != 0;
    }

    int             OperIsCompare()
    {
        return  (OperKind(gtOper) & GTK_RELOP  ) != 0;
    }

    static
    int             OperIsLogical(genTreeOps gtOper)
    {
        return  (OperKind(gtOper) & GTK_LOGOP  ) != 0;
    }

    int             OperIsLogical()
    {
        return  (OperKind(gtOper) & GTK_LOGOP  ) != 0;
    }

    static
    int             OperIsUnary(genTreeOps gtOper)
    {
        return  (OperKind(gtOper) & GTK_UNOP   ) != 0;
    }

    int             OperIsUnary()
    {
        return  (OperKind(gtOper) & GTK_UNOP   ) != 0;
    }

    static
    int             OperIsBinary(genTreeOps gtOper)
    {
        return  (OperKind(gtOper) & GTK_BINOP  ) != 0;
    }

    int             OperIsBinary()
    {
        return  (OperKind(gtOper) & GTK_BINOP  ) != 0;
    }

    static
    int             OperIsSimple(genTreeOps gtOper)
    {
        return  (OperKind(gtOper) & GTK_SMPOP  ) != 0;
    }

    int             OperIsSimple()
    {
        return  (OperKind(gtOper) & GTK_SMPOP  ) != 0;
    }

    static
    int             OperIsCommutative(genTreeOps gtOper)
    {
        return  (OperKind(gtOper) & GTK_COMMUTE) != 0;
    }

    int             OperIsCommutative()
    {
        return  (OperKind(gtOper) & GTK_COMMUTE) != 0;
    }

#if OPT_BOOL_OPS
    int             IsNotAssign();
#endif
    int             IsLeafVal();
    bool            OperMayThrow();

    unsigned        IsScaleIndexMul();
    unsigned        IsScaleIndexShf();
    unsigned        IsScaledIndex();


public:

#if SMALL_TREE_NODES
    static
    unsigned char   s_gtNodeSizes[GT_COUNT];
#endif

    static
    void            InitNodeSize();

    bool            IsNodeProperlySized();

    void            CopyFrom(GenTreePtr src);

    static
    genTreeOps      ReverseRelop(genTreeOps relop);

    static
    genTreeOps      SwapRelop(genTreeOps relop);

    //---------------------------------------------------------------------

    static
    bool            Compare(GenTreePtr op1, GenTreePtr op2, bool swapOK = false);

    //---------------------------------------------------------------------
    #ifdef DEBUG
    //---------------------------------------------------------------------

    static
    const   char *  NodeName(genTreeOps op);

    //---------------------------------------------------------------------
    #endif
    //---------------------------------------------------------------------

#if INLINING || OPT_BOOL_OPS || USE_FASTCALL
    bool                        IsNothingNode();
#endif

    void                        gtBashToNOP();

    void                        ChangeOper   (int oper);

    bool                        IsVarAddr    ();
    bool                        gtOverflow   ();
    bool                        gtOverflowEx ();
};

/*****************************************************************************/
#pragma pack(pop)
/*****************************************************************************/

/* Generic list of nodes - primarily used by the CSE logic */

typedef
struct  treeLst *   treeLstPtr;

struct  treeLst
{
    treeLstPtr      tlNext;
    GenTreePtr      tlTree;
};

typedef
struct  treeStmtLst * treeStmtLstPtr;

struct  treeStmtLst
{
    treeStmtLstPtr  tslNext;
    GenTreePtr      tslTree;                // tree node
    GenTreePtr      tslStmt;                // statement containing the tree
    BasicBlock  *   tslBlock;               // block containing the statement
};

#if     SMALL_TREE_NODES

const
size_t              TREE_NODE_SZ_SMALL = offsetof(GenTree, gtOp) + sizeof(((GenTree*)0)->gtOp);

const
size_t              TREE_NODE_SZ_LARGE = sizeof(GenTree);

#endif

/*****************************************************************************
 * Types returned by GenTree::lvaLclVarRefs()
 */

enum varRefKinds
{
    VR_IND_PTR = 0x01,      // a pointer object-field
    VR_IND_SCL = 0x02,      // a scalar  object-field
    VR_GLB_REF = 0x04,      // a global (clsVar)
};

/*****************************************************************************/
#endif  // !GENTREE_H
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\gentree.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                               GenTree                                     XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/

#define fflush(stdout)          // why on earth does this crash inside NTDLL?

/*****************************************************************************/

const
unsigned char       GenTree::gtOperKindTable[] =
{
    #define GTNODE(en,sn,cm,ok) ok + GTK_COMMUTE*cm,
    #include "gtlist.h"
    #undef  GTNODE
};

/*****************************************************************************
 *
 *  The types of different GenTree nodes
 */

#ifdef DEBUG

static
const   char *      nodeNames[] =
{
    #define GTNODE(en,sn,cm,ok) sn,
    #include "gtlist.h"
};

const   char    *   GenTree::NodeName(genTreeOps op)
{
    assert(op < sizeof(nodeNames)/sizeof(nodeNames[0]));

    return  nodeNames[op];
}

#endif

/*****************************************************************************
 *
 *  When 'SMALL_TREE_NODES' is enabled, we allocate tree nodes in 2 different
 *  sizes: 'GTF_NODE_SMALL' for most nodes and 'GTF_NODE_LARGE' for the few
 *  nodes (such as calls and statement list nodes) that have more fields and
 *  take up a lot more space.
 */

#if SMALL_TREE_NODES

/* static */
unsigned char       GenTree::s_gtNodeSizes[GT_COUNT];


/* static */
void                GenTree::InitNodeSize()
{
    unsigned        op;

    /* 'GT_LCL_VAR' gets often changed to 'GT_REG_VAR' */

    assert(GenTree::s_gtNodeSizes[GT_LCL_VAR] >= GenTree::s_gtNodeSizes[GT_REG_VAR]);

    /* Set all sizes to 'small' first */

    for (op = 0; op < GT_COUNT; op++)
        GenTree::s_gtNodeSizes[op] = TREE_NODE_SZ_SMALL;

    /* Now set all of the appropriate entries to 'large' */

    GenTree::s_gtNodeSizes[GT_CALL      ] = TREE_NODE_SZ_LARGE;

    GenTree::s_gtNodeSizes[GT_INDEX     ] = TREE_NODE_SZ_LARGE;

#if RNGCHK_OPT
    GenTree::s_gtNodeSizes[GT_IND       ] = TREE_NODE_SZ_LARGE;
#endif

#if INLINE_MATH
    GenTree::s_gtNodeSizes[GT_MATH      ] = TREE_NODE_SZ_LARGE;
#endif

#if INLINING
    GenTree::s_gtNodeSizes[GT_FIELD     ] = TREE_NODE_SZ_LARGE;
#endif

#ifdef DEBUG
    /* GT_STMT is large in DEBUG */
    GenTree::s_gtNodeSizes[GT_STMT      ] = TREE_NODE_SZ_LARGE;
#endif
}

#if !defined(NDEBUG)

bool                GenTree::IsNodeProperlySized()
{
    size_t          size;

    if      (gtFlags & GTF_NODE_SMALL)
        size = TREE_NODE_SZ_SMALL;
    else if (gtFlags & GTF_NODE_LARGE)
        size = TREE_NODE_SZ_SMALL;
    else
        assert(!"bogus node size");

    return  (bool)(GenTree::s_gtNodeSizes[gtOper] >= size);
}

#endif

#else // SMALL_TREE_NODES

#if !defined(NDEBUG)

bool                GenTree::IsNodeProperlySized()
{
    return  true;
}

#endif

#endif // SMALL_TREE_NODES

/*****************************************************************************/

int                 Compiler::fgWalkTreeRec(GenTreePtr tree)
{
    int             result;

    genTreeOps      oper;
    unsigned        kind;

AGAIN:

    assert(tree);
    assert(tree->gtOper != GT_STMT);

    /* Visit this node */

    if  (!fgWalkLclsOnly)
    {
        result = fgWalkVisitorFn(tree, fgWalkCallbackData);
        if  (result)
            return result;
    }

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

    /* Is this a constant or leaf node? */

    if  (kind & (GTK_CONST|GTK_LEAF))
    {
        if  (fgWalkLclsOnly && oper == GT_LCL_VAR)
            return fgWalkVisitorFn(tree, fgWalkCallbackData);

        return  0;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        if  (tree->gtOp.gtOp2)
        {
            result = fgWalkTreeRec(tree->gtOp.gtOp1);
            if  (result < 0)
                return result;

            tree = tree->gtOp.gtOp2;
            goto AGAIN;
        }
        else
        {

#if CSELENGTH

            /* Some GT_IND have "secret" array length subtrees */

            if  ((tree->gtFlags & GTF_IND_RNGCHK) != 0       &&
                 (tree->gtOper                    == GT_IND) &&
                 (tree->gtInd.gtIndLen            != NULL))
            {
                result = fgWalkTreeRec(tree->gtInd.gtIndLen);
                if  (result < 0)
                    return result;
            }

#endif

            tree = tree->gtOp.gtOp1;
            if  (tree)
                goto AGAIN;

            return 0;
        }
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_MKREFANY:
    case GT_LDOBJ:
            // assert op1 is the same place for ldobj and for fields
        assert(&tree->gtField.gtFldObj == &tree->gtLdObj.gtOp1);
            // fall through let field take care of it

    case GT_FIELD:
        tree = tree->gtField.gtFldObj;
        break;

    case GT_CALL:

        assert(tree->gtFlags & GTF_CALL);

        if  (tree->gtCall.gtCallObjp)
        {
            result = fgWalkTreeRec(tree->gtCall.gtCallObjp);
            if  (result < 0)
                return result;
        }

        if  (tree->gtCall.gtCallArgs)
        {
            result = fgWalkTreeRec(tree->gtCall.gtCallArgs);
            if  (result < 0)
                return result;
        }

#if USE_FASTCALL
        if  (tree->gtCall.gtCallRegArgs)
        {
            result = fgWalkTreeRec(tree->gtCall.gtCallRegArgs);
            if  (result < 0)
                return result;
        }
#endif

        if  (tree->gtCall.gtCallVptr)
            tree = tree->gtCall.gtCallVptr;
        else if (tree->gtCall.gtCallType == CT_INDIRECT)
            tree = tree->gtCall.gtCallAddr;
        else
            tree = NULL;

        break;

    case GT_JMP:
        return 0;
        break;

    case GT_JMPI:
        tree = tree->gtOp.gtOp1;
        break;

#if CSELENGTH

    case GT_ARR_RNGCHK:

        if  (tree->gtArrLen.gtArrLenCse)
        {
            result = fgWalkTreeRec(tree->gtArrLen.gtArrLenCse);
            if  (result < 0)
                return result;
        }

        if  (!(tree->gtFlags & GTF_ALN_CSEVAL))
            return  0;

        tree = tree->gtArrLen.gtArrLenAdr; assert(tree);
        break;

#endif

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected operator");
    }

    if  (tree)
        goto AGAIN;

    return 0;
}

int                 Compiler::fgWalkTreeDepRec(GenTreePtr tree)
{
    int             result;

    genTreeOps      oper;
    unsigned        kind;

    assert(tree);
    assert(tree->gtOper != GT_STMT);

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

    /* Is this a prefix node? */

    if  (oper == fgWalkPrefixNode)
    {
        result = fgWalkVisitorDF(tree, fgWalkCallbackData, true);
        if  (result < 0)
            return result;
    }

    /* Is this a constant or leaf node? */

    if  (kind & (GTK_CONST|GTK_LEAF))
        goto DONE;

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        if  (tree->gtOp.gtOp1)
        {
            result = fgWalkTreeDepRec(tree->gtOp.gtOp1);
            if  (result < 0)
                return result;
        }

        if  (tree->gtOp.gtOp2)
        {
            result = fgWalkTreeDepRec(tree->gtOp.gtOp2);
            if  (result < 0)
                return result;
        }

#if CSELENGTH

        /* Some GT_IND have "secret" array length subtrees */

        if  ((tree->gtFlags & GTF_IND_RNGCHK) != 0       &&
             (tree->gtOper                    == GT_IND) &&
             (tree->gtInd.gtIndLen            != NULL))
        {
            result = fgWalkTreeDepRec(tree->gtInd.gtIndLen);
            if  (result < 0)
                return result;
        }

#endif

        goto DONE;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_MKREFANY:
    case GT_LDOBJ:
            // assert op1 is the same place for ldobj and for fields
        assert(&tree->gtField.gtFldObj == &tree->gtLdObj.gtOp1);
            // fall through let field take care of it

    case GT_FIELD:
        if  (tree->gtField.gtFldObj)
        {
            result = fgWalkTreeDepRec(tree->gtField.gtFldObj);
            if  (result < 0)
                return result;
        }

        break;

    case GT_CALL:

        assert(tree->gtFlags & GTF_CALL);

        if  (tree->gtCall.gtCallObjp)
        {
            result = fgWalkTreeDepRec(tree->gtCall.gtCallObjp);
            if  (result < 0)
                return result;
        }

        if  (tree->gtCall.gtCallArgs)
        {
            result = fgWalkTreeDepRec(tree->gtCall.gtCallArgs);
            if  (result < 0)
                return result;
        }

#if USE_FASTCALL
        if  (tree->gtCall.gtCallRegArgs)
        {
            result = fgWalkTreeDepRec(tree->gtCall.gtCallRegArgs);
            if  (result < 0)
                return result;
        }
#endif

        if  (tree->gtCall.gtCallVptr)
        {
            result = fgWalkTreeDepRec(tree->gtCall.gtCallVptr);
            if  (result < 0)
                return result;
        }
        else if  (tree->gtCall.gtCallType == CT_INDIRECT)
        {
            result = fgWalkTreeDepRec(tree->gtCall.gtCallAddr);
            if  (result < 0)
                return result;
        }

        break;

#if CSELENGTH

    case GT_ARR_RNGCHK:

        if  (tree->gtArrLen.gtArrLenCse)
        {
            result = fgWalkTreeDepRec(tree->gtArrLen.gtArrLenCse);
            if  (result < 0)
                return result;
        }

        if  (tree->gtFlags & GTF_ALN_CSEVAL)
        {
            assert(tree->gtArrLen.gtArrLenAdr);

            result = fgWalkTreeDepRec(tree->gtArrLen.gtArrLenAdr);
            if  (result < 0)
                return result;
        }

        goto DONE;

#endif

        break;


    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected operator");
    }

DONE:

    /* Finally, visit the current node */

    return  fgWalkVisitorDF(tree, fgWalkCallbackData, false);
}


/*****************************************************************************
 *
 *  Returns non-zero if the two trees are identical.
 */

bool                GenTree::Compare(GenTreePtr op1, GenTreePtr op2, bool swapOK)
{
    genTreeOps      oper;
    unsigned        kind;

//  printf("tree1:\n"); gtDispTree(op1);
//  printf("tree2:\n"); gtDispTree(op2);

AGAIN:

#if CSELENGTH
    if  (op1 == NULL) return (op2 == NULL);
    if  (op2 == NULL) return false;
#else
    assert(op1 && op2);
#endif

    assert(op1->gtOper != GT_STMT);
    assert(op2->gtOper != GT_STMT);

    oper = op1->OperGet();

    /* The operators must be equal */

    if  (oper != op2->gtOper)
        return false;

    /* The types must be equal */

    if  (op1->gtType != op2->gtType)
        return false;

    /* Figure out what kind of nodes we're comparing */

    kind = op1->OperKind();

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
    {
        switch (oper)
        {
        case GT_CNS_INT:

            if  (op1->gtIntCon.gtIconVal != op2->gtIntCon.gtIconVal)
                break;

            return true;


            // UNDONE [low pri]: match non-int constant values
        }

        return  false;
    }

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        switch (oper)
        {
        case GT_LCL_VAR:
            if  (op1->gtLclVar.gtLclNum    != op2->gtLclVar.gtLclNum)
                break;

            return true;

        case GT_CLS_VAR:
            if  (op1->gtClsVar.gtClsVarHnd != op2->gtClsVar.gtClsVarHnd)
                break;

            return true;

        case GT_LABEL:
            return true;
        }

        return false;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        if  (op1->gtOp.gtOp2)
        {
            if  (!Compare(op1->gtOp.gtOp1, op2->gtOp.gtOp1, swapOK))
            {
                if  (swapOK)
                {
                    /* Special case: "lcl1 + lcl2" matches "lcl2 + lcl1" */

                    if  (oper == GT_ADD && op1->gtOp.gtOp1->gtOper == GT_LCL_VAR
                                        && op1->gtOp.gtOp2->gtOper == GT_LCL_VAR)
                    {
                        if  (Compare(op1->gtOp.gtOp1, op2->gtOp.gtOp2, swapOK) &&
                             Compare(op1->gtOp.gtOp2, op2->gtOp.gtOp1, swapOK))
                        {
                            return  true;
                        }
                    }
                }

                return false;
            }

            op1 = op1->gtOp.gtOp2;
            op2 = op2->gtOp.gtOp2;

            goto AGAIN;
        }
        else
        {

#if CSELENGTH

            /* Is either operand a GT_IND node with an array length? */

            if  (oper == GT_IND)
            {
                if  ((op1->gtFlags|op2->gtFlags) & GTF_IND_RNGCHK)
                {
                    GenTreePtr  tmp1 = op1->gtInd.gtIndLen;
                    GenTreePtr  tmp2 = op2->gtInd.gtIndLen;

                    if  (!(op1->gtFlags & GTF_IND_RNGCHK)) tmp1 = NULL;
                    if  (!(op2->gtFlags & GTF_IND_RNGCHK)) tmp2 = NULL;

                    if  (tmp1)
                    {
                        if  (!Compare(tmp1, tmp2, swapOK))
                            return  false;
                    }
                    else
                    {
                        if  (tmp2)
                            return  false;
                    }
                }
            }

#endif

            op1 = op1->gtOp.gtOp1;
            op2 = op2->gtOp.gtOp1;

            if  (!op1) return  ((bool)(op2 == 0));
            if  (!op2) return  false;

            goto AGAIN;
        }
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_MKREFANY:
    case GT_LDOBJ:
        if (op1->gtLdObj.gtClass != op2->gtLdObj.gtClass)
            break;
        op1 = op1->gtLdObj.gtOp1;
        op2 = op2->gtLdObj.gtOp1;
        goto AGAIN;

    case GT_FIELD:
        if  (op1->gtField.gtFldHnd != op2->gtField.gtFldHnd)
            break;

        op1 = op1->gtField.gtFldObj;
        op2 = op2->gtField.gtFldObj;

        if  (op1 || op2)
        {
            if  (op1 && op2)
                goto AGAIN;
        }

        return true;

    case GT_CALL:
        break;

#if CSELENGTH

    case GT_ARR_RNGCHK:

        if  (!Compare(op1->gtArrLen.gtArrLenAdr,
                      op2->gtArrLen.gtArrLenAdr, swapOK))
        {
            return  false;
        }

        op1 = op1->gtArrLen.gtArrLenCse;
        op2 = op2->gtArrLen.gtArrLenCse;

        goto AGAIN;

#endif


    default:
        assert(!"unexpected operator");
    }

    return false;
}

/*****************************************************************************
 *
 *  Returns non-zero if the given tree contains a use of a local #lclNum.
 */

 // @TODO: make this work with byrefs.  In particular, calls with byref
 // parameters should be counted as a def.

bool                Compiler::gtHasRef(GenTreePtr tree, int lclNum, bool defOnly)
{
    genTreeOps      oper;
    unsigned        kind;

AGAIN:

    assert(tree);

    oper = tree->OperGet();
    kind = tree->OperKind();

    assert(oper != GT_STMT);

    /* Is this a constant node? */

    if  (kind & GTK_CONST)
        return  false;

    /* Is this a leaf node? */

    if  (kind & GTK_LEAF)
    {
        if  (oper == GT_LCL_VAR)
        {
            if  (tree->gtLclVar.gtLclNum == (unsigned)lclNum)
            {
                if  (!defOnly)
                    return true;
            }
        }

        return false;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        if  (tree->gtOp.gtOp2)
        {
            if  (gtHasRef(tree->gtOp.gtOp1, lclNum, defOnly))
                return true;

            tree = tree->gtOp.gtOp2;
            goto AGAIN;
        }
        else
        {
            tree = tree->gtOp.gtOp1;

            if  (!tree)
                return  false;

            if  (kind & GTK_ASGOP)
            {
                // 'tree' is the gtOp1 of an assignment node. So we can handle
                // the case where defOnly is either true or false.

                if  (tree->gtOper == GT_LCL_VAR &&
                     tree->gtLclVar.gtLclNum == (unsigned)lclNum)
                {
                    return true;
                }
                else if (tree->gtOper == GT_FIELD &&
                         lclNum == (int)tree->gtField.gtFldHnd)
                {
                     return true;
                }
            }

            goto AGAIN;
        }
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_MKREFANY:
    case GT_LDOBJ:
        tree = tree->gtField.gtFldObj;
        if  (tree)
            goto AGAIN;
        break;

    case GT_FIELD:
        if  (lclNum == (int)tree->gtField.gtFldHnd)
        {
            if  (!defOnly)
                return true;
        }

        tree = tree->gtField.gtFldObj;
        if  (tree)
            goto AGAIN;
        break;

    case GT_CALL:

        if  (tree->gtCall.gtCallObjp)
            if  (gtHasRef(tree->gtCall.gtCallObjp, lclNum, defOnly))
                return true;

        if  (tree->gtCall.gtCallArgs)
            if  (gtHasRef(tree->gtCall.gtCallArgs, lclNum, defOnly))
                return true;

#if USE_FASTCALL
        if  (tree->gtCall.gtCallRegArgs)
            if  (gtHasRef(tree->gtCall.gtCallRegArgs, lclNum, defOnly))
                return true;
#endif

        if  (tree->gtCall.gtCallVptr)
            tree = tree->gtCall.gtCallVptr;
        else if  (tree->gtCall.gtCallType == CT_INDIRECT)
            tree = tree->gtCall.gtCallAddr;
        else
            tree = NULL;

        if  (tree)
            goto AGAIN;

        break;

    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected operator");
    }

    return false;
}

/*****************************************************************************/
#if RNGCHK_OPT || CSE
/*****************************************************************************
 *
 *  Helper used to compute hash values for trees.
 */

inline
unsigned            genTreeHashAdd(unsigned old, unsigned add)
{
    return  (old + old/2) ^ add;
}

inline
unsigned            genTreeHashAdd(unsigned old, unsigned add1,
                                                 unsigned add2)
{
    return  (old + old/2) ^ add1 ^ add2;
}

/*****************************************************************************
 *
 *  Given an arbitrary expression tree, compute a hash value for it.
 */

unsigned            Compiler::gtHashValue(GenTree * tree)
{
    genTreeOps      oper;
    unsigned        kind;

    unsigned        hash = 0;

#if CSELENGTH
    GenTreePtr      temp;
#endif

AGAIN:

    assert(tree);
    assert(tree->gtOper != GT_STMT);

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

#if CSELENGTH

    if  (oper == GT_ARR_LENGTH)
    {
        /* GT_ARR_LENGTH must hash to the same thing as GT_ARR_RNGCHK */

        hash = genTreeHashAdd(hash, GT_ARR_RNGCHK);
        temp = tree->gtOp.gtOp1;
        goto ARRLEN;
    }

#endif

    /* Include the operator value in the hash */

    hash = genTreeHashAdd(hash, oper);

    /* Is this a constant or leaf node? */

    if  (kind & (GTK_CONST|GTK_LEAF))
    {
        unsigned        add;

        switch (oper)
        {
        case GT_LCL_VAR: add = tree->gtLclVar.gtLclNum;       break;

        case GT_CNS_INT: add = (int)tree->gtIntCon.gtIconVal; break;
        case GT_CNS_LNG: add = (int)tree->gtLngCon.gtLconVal; break;
        case GT_CNS_FLT: add = (int)tree->gtFltCon.gtFconVal; break;
        case GT_CNS_DBL: add = (int)tree->gtDblCon.gtDconVal; break;

        default:         add = 0;                             break;
        }

        hash = genTreeHashAdd(hash, add);
        goto DONE;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        GenTreePtr      op1  = tree->gtOp.gtOp1;
        GenTreePtr      op2  = tree->gtOp.gtOp2;

        unsigned        hsh1;

        /* Is there a second sub-operand? */

        if  (!op2)
        {
            /* Special case: no sub-operands at all */

            if  (!op1)
                goto DONE;

            /* This is a unary operator */

            tree = op1;
            goto AGAIN;
        }

        /* This is a binary operator */

        hsh1 = gtHashValue(op1);

        /* Special case: addition of two values */

        if  (oper == GT_ADD)
        {
            unsigned    hsh2 = gtHashValue(op2);

            /* Produce a hash that allows swapping the operands */

            hash = genTreeHashAdd(hash, hsh1, hsh2);
            goto DONE;
        }

        /* Add op1's hash to the running value and continue with op2 */

        hash = genTreeHashAdd(hash, hsh1);

        tree = op2;
        goto AGAIN;
    }

#if CSELENGTH

    if  (oper == GT_ARR_RNGCHK)
    {
        /* GT_ARR_LENGTH must hash to the same thing as GT_ARR_RNGCHK */

        temp = tree->gtArrLen.gtArrLenAdr; assert(temp && temp->gtType == TYP_REF);

    ARRLEN:

        hash = genTreeHashAdd(hash, gtHashValue(temp));
        goto DONE;
    }

#endif

#ifdef  DEBUG
    gtDispTree(tree);
#endif
    assert(!"unexpected operator");

DONE:

    return hash;
}

/*****************************************************************************
 *
 *  Given an arbitrary expression tree, return the set of all local variables
 *  referenced by the tree. If the tree contains any references that are not
 *  local variables or constants, returns 'VARSET_NONE'. If there are any
 *  indirections or global refs in the expression, the "*refsPtr" argument
 *  will be assigned the appropriate bit set based on the 'varRefKinds' type.
 *  It won't be assigned anything when there are no indirections or global
 *  references, though, so this value should be initialized before the call.
 *  If we encounter an expression that is equal to *findPtr we set *findPtr
 *  to NULL.
 */

VARSET_TP           Compiler::lvaLclVarRefs(GenTreePtr  tree,
                                            GenTreePtr *findPtr,
                                            unsigned   *refsPtr)
{
    genTreeOps      oper;
    unsigned        kind;

    VARSET_TP       vars = 0;

AGAIN:

    assert(tree);
    assert(tree->gtOper != GT_STMT);

    /* Remember whether we've come across the expression we're looking for */

    if  (findPtr && *findPtr == tree) *findPtr = NULL;

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

    /* Is this a constant or leaf node? */

    if  (kind & (GTK_CONST|GTK_LEAF))
    {
        if  (oper == GT_LCL_VAR)
        {
            unsigned        lclNum;
            LclVarDsc   *   varDsc;

            assert(tree->gtOper == GT_LCL_VAR);
            lclNum = tree->gtLclVar.gtLclNum;

            /* Should we use the variable table? */

            if  (findPtr)
            {
                if (lclNum >= VARSET_SZ)
                    return  VARSET_NONE;

                vars |= genVarIndexToBit(lclNum);
            }
            else
            {
                assert(lclNum < lvaCount);
                varDsc = lvaTable + lclNum;

                if (varDsc->lvTracked == false)
                    return  VARSET_NONE;

                /* Don't deal with expressions with volatile variables */

                if (varDsc->lvVolatile)
                    return  VARSET_NONE;

                vars |= genVarIndexToBit(varDsc->lvVarIndex);
            }
        }
        else if (oper == GT_CLS_VAR)
        {
            *refsPtr |= VR_GLB_REF;
        }

        return  vars;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        if  (oper == GT_IND)
        {
            assert(tree->gtOp.gtOp2 == 0);

            /* Set the proper indirection bits */

            *refsPtr |= (varTypeIsGC(tree->TypeGet()) ? VR_IND_PTR
                                                      : VR_IND_SCL );

#if CSELENGTH

            /* Some GT_IND have "secret" array length subtrees */

            if  ((tree->gtFlags & GTF_IND_RNGCHK) && tree->gtInd.gtIndLen)
            {
                vars |= lvaLclVarRefs(tree->gtInd.gtIndLen, findPtr, refsPtr);
                if  (vars == VARSET_NONE)
                    return  vars;
            }

#endif

        }

        if  (tree->gtOp.gtOp2)
        {
            /* It's a binary operator */

            vars |= lvaLclVarRefs(tree->gtOp.gtOp1, findPtr, refsPtr);
            if  (vars == VARSET_NONE)
                return  vars;

            tree = tree->gtOp.gtOp2; assert(tree);
            goto AGAIN;
        }
        else
        {
            /* It's a unary (or nilary) operator */

            tree = tree->gtOp.gtOp1;
            if  (tree)
                goto AGAIN;

            return vars;
        }
    }

#if CSELENGTH

    /* An array length value depends on the array address */

    if  (oper == GT_ARR_RNGCHK)
    {
        tree = tree->gtArrLen.gtArrLenAdr;
        goto AGAIN;
    }

#endif

    return  VARSET_NONE;
}

/*****************************************************************************/
#endif//RNGCHK_OPT || CSE
/*****************************************************************************
 *
 *  Return a relational operator that is the reverse of the given one.
 */

/* static */
genTreeOps          GenTree::ReverseRelop(genTreeOps relop)
{
    static
    unsigned char   reverseOps[] =
    {
        GT_NE,          // GT_EQ
        GT_EQ,          // GT_NE
        GT_GE,          // GT_LT
        GT_GT,          // GT_LE
        GT_LT,          // GT_GE
        GT_LE,          // GT_GT
    };

    assert(reverseOps[GT_EQ - GT_EQ] == GT_NE);
    assert(reverseOps[GT_NE - GT_EQ] == GT_EQ);

    assert(reverseOps[GT_LT - GT_EQ] == GT_GE);
    assert(reverseOps[GT_LE - GT_EQ] == GT_GT);
    assert(reverseOps[GT_GE - GT_EQ] == GT_LT);
    assert(reverseOps[GT_GT - GT_EQ] == GT_LE);

    assert(OperIsCompare(relop));
    assert(relop >= GT_EQ && relop - GT_EQ < sizeof(reverseOps));

    return (genTreeOps)reverseOps[relop - GT_EQ];
}

/*****************************************************************************
 *
 *  Return a relational operator that will work for swapped operands.
 */

/* static */
genTreeOps          GenTree::SwapRelop(genTreeOps relop)
{
    static
    unsigned char   swapOps[] =
    {
        GT_EQ,          // GT_EQ
        GT_NE,          // GT_NE
        GT_GT,          // GT_LT
        GT_GE,          // GT_LE
        GT_LE,          // GT_GE
        GT_LT,          // GT_GT
    };

    assert(swapOps[GT_EQ - GT_EQ] == GT_EQ);
    assert(swapOps[GT_NE - GT_EQ] == GT_NE);

    assert(swapOps[GT_LT - GT_EQ] == GT_GT);
    assert(swapOps[GT_LE - GT_EQ] == GT_GE);
    assert(swapOps[GT_GE - GT_EQ] == GT_LE);
    assert(swapOps[GT_GT - GT_EQ] == GT_LT);

    assert(OperIsCompare(relop));
    assert(relop >= GT_EQ && relop - GT_EQ < sizeof(swapOps));

    return (genTreeOps)swapOps[relop - GT_EQ];
}

/*****************************************************************************
 *
 *  Reverse the meaning of the given test condition.
 */

GenTreePtr FASTCALL Compiler::gtReverseCond(GenTree * tree)
{
    if  (tree->OperIsCompare())
    {
        tree->gtOper = GenTree::ReverseRelop(tree->OperGet());

        /* Flip the GTF_CMP_NAN_UN bit */

        if (varTypeIsFloating(tree->gtOp.gtOp1->TypeGet()))
            tree->gtFlags ^= GTF_CMP_NAN_UN;
    }
    else
    {
        tree = gtNewOperNode(GT_NOT, TYP_INT, tree);
    }

    return tree;
}

/*****************************************************************************
 *
 *  If the given tree is an assignment of the form "lcl = log0(lcl)",
 *  returns the variable number of the local. Otherwise returns -1.
 */

#if OPT_BOOL_OPS

int                 GenTree::IsNotAssign()
{
    if  (gtOper != GT_ASG)
        return  -1;

    GenTreePtr      dst = gtOp.gtOp1;
    GenTreePtr      src = gtOp.gtOp2;

    if  (dst->gtOper != GT_LCL_VAR)
        return  -1;
    if  (src->gtOper != GT_LOG0)
        return  -1;

    src = src->gtOp.gtOp1;
    if  (src->gtOper != GT_LCL_VAR)
        return  -1;

    if  (dst->gtLclVar.gtLclNum != src->gtLclVar.gtLclNum)
        return  -1;

    return  dst->gtLclVar.gtLclNum;
}

#endif

/*****************************************************************************
 *
 *  Returns non-zero if the given tree is a 'leaf'.
 */

int                 GenTree::IsLeafVal()
{
    unsigned        kind = OperKind();

    if  (kind & (GTK_LEAF|GTK_CONST))
        return 1;

    if  (kind &  GTK_SMPOP)
        return 1;

    if  (gtOper == GT_FIELD && !gtField.gtFldObj)
        return 1;

    return 0;
}

/*****************************************************************************
 *
 *  Figure out the evaluation order for a list of values.
 */

unsigned            Compiler::gtSetListOrder(GenTree *list)
{
    GenTreePtr      tree;
    GenTreePtr      next;

    unsigned        lvl;

    unsigned        level = 0;
#if!TGT_IA64
    regMaskTP       ftreg = 0;
#endif

#if TGT_x86
    unsigned        FPlvlSave;
#endif

    assert(list && list->gtOper == GT_LIST);

#if TGT_x86
    /* Save the current FP stack level since an argument list
     * will implicitly pop the FP stack when pushing the argument */
    FPlvlSave = genFPstkLevel;
#endif

    next = list->gtOp.gtOp2;
    if  (next)
    {
        //list->gtFlags |= GTF_REVERSE_OPS;

        lvl = gtSetListOrder(next);

#if!TGT_IA64
        ftreg |= next->gtRsvdRegs;
#endif

        if  (level < lvl)
             level = lvl;
    }

    tree = list->gtOp.gtOp1;
    lvl  = gtSetEvalOrder(tree);

#if TGT_x86
    /* restore the FP level */
    genFPstkLevel = FPlvlSave;
#endif

#if!TGT_IA64
    list->gtRsvdRegs = ftreg | tree->gtRsvdRegs;
#endif

    if  (level < lvl)
         level = lvl;

    return level;
}

/*****************************************************************************
 *
 *  Figure out the evaluation order for a list of values.
 */

#if TGT_x86

#define gtSetRArgOrder(a,m) gtSetListOrder(a)

#else

unsigned            Compiler::gtSetRArgOrder(GenTree *list, unsigned regs)
{
    GenTreePtr      tree;
    GenTreePtr      next;

    unsigned        lvl;
    regNumber       reg;

    unsigned        level = 0;
#if!TGT_IA64
    regMaskTP       ftreg = 0;
#endif

    assert(list && list->gtOper == GT_LIST);

    next = list->gtOp.gtOp2;
    if  (next)
    {
        list->gtFlags |= GTF_REVERSE_OPS;

        lvl = gtSetRArgOrder(next, regs >> 4);

#if!TGT_IA64
        ftreg |= next->gtRsvdRegs;
#endif

        if  (level < lvl)
             level = lvl;
    }

    /* Get hold of the argument value */

    tree = list->gtOp.gtOp1;

    /* Figure out which register this argument will be passed in */

    reg  = (regNumber)(regs & 0x0F);

//  printf("RegArgOrder [reg=%s]:\n", getRegName(reg)); gtDispTree(tree);

    /* Process the argument value itself */

    lvl  = gtSetEvalOrder(tree);

#if!TGT_IA64

    list->gtRsvdRegs = ftreg | tree->gtRsvdRegs;

    /* Mark the interference with the argument register */

    tree->gtIntfRegs |= genRegMask(reg);

#endif

    if  (level < lvl)
         level = lvl;

    return level;
}

#endif


/*****************************************************************************
 *
 *  Given a tree, figure out the order in which its sub-operands should be
 *  evaluated.
 *
 *  Returns the 'complexity' estimate for this tree (the higher the number,
 *  the more expensive it is to evaluate it).
 *
 *  #if TGT_x86
 *
 *      We compute the "FPdepth" value for each tree, i.e. the max. number
 *      of operands the tree will push on the x87 (coprocessor) stack.
 *
 *  #else
 *
 *      We compute an estimate of the number of temporary registers each
 *      node will require - this is used later for register allocation.
 *
 *  #endif
 */

unsigned            Compiler::gtSetEvalOrder(GenTree * tree)
{
    genTreeOps      oper;
    unsigned        kind;

    unsigned        level;
    unsigned        lvl2;

#if!TGT_IA64
    regMaskTP       ftreg;
#endif

#if CSE
    unsigned        cost;
#endif

#if TGT_x86
    int             isflt;
    unsigned        FPlvlSave;
#endif

    assert(tree);
    assert(tree->gtOper != GT_STMT);

#if TGT_RISC && !TGT_IA64
    tree->gtIntfRegs = 0;
#endif

    /* Assume no fixed registers will be trashed */

#if!TGT_IA64
    ftreg = 0;
#endif

    /* Since this function can be called several times
     * on a tree (e.g. after nodes have been folded)
     * reset the GTF_REVERSE_OPS flag */

    tree->gtFlags &= ~GTF_REVERSE_OPS;

    /* Is this a FP value? */

#if TGT_x86
    isflt = varTypeIsFloating(tree->TypeGet()) ? 1 : 0;
#endif

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

    /* Is this a constant or leaf node? */

    if  (kind & (GTK_CONST|GTK_LEAF))
    {
        /*
            Note that some code below depends on constants always getting
            moved to be the second operand of a binary operator. This is
            easily accomplished by giving constants a level of 0, which
            we do on the next line. If you ever decide to change this, be
            aware that unless you make other arrangements for costants to
            be moved, stuff will break.
         */

        level = ((kind & GTK_CONST) == 0);
#if CSE
        cost  = 1;  // CONSIDER: something more accurate?
#endif
#if TGT_x86
        genFPstkLevel += isflt;
#endif
        goto DONE;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        unsigned        lvlb;

        GenTreePtr      op1 = tree->gtOp.gtOp1;
        GenTreePtr      op2 = tree->gtOp.gtOp2;

        /* Check for a nilary operator */

        if  (!op1)
        {
            assert(op2 == 0);

#if TGT_x86
            if  (oper == GT_BB_QMARK || oper == GT_BB_COLON)
                genFPstkLevel += isflt;
#endif
            level    = 0;
#if CSE
            cost     = 1;
#endif
            goto DONE;
        }

        /* Is this a unary operator? */

        if  (!op2)
        {
            /* Process the operand of the operator */

        UNOP:

            level  = gtSetEvalOrder(op1);
#if!TGT_IA64
            ftreg |= op1->gtRsvdRegs;
#endif

#if CSE
            cost   = op1->gtCost + 1;
#endif

            /* Special handling for some operators */

            switch (oper)
            {
            case GT_NOP:

                /* Special case: array range check */

                if  (tree->gtFlags & GTF_NOP_RNGCHK)
                    level++;

                break;

            case GT_ADDR:

#if TGT_x86
                /* If the operand was floating point pop the value from the stack */

                if (varTypeIsFloating(op1->TypeGet()))
                {
                    assert(genFPstkLevel);
                    genFPstkLevel--;
                }
#endif
                break;

            case GT_IND:

                /* Indirect loads of FP values push a new value on the FP stack */

#if     TGT_x86
                genFPstkLevel += isflt;
#endif

#if     CSELENGTH

                if  ((tree->gtFlags & GTF_IND_RNGCHK) && tree->gtInd.gtIndLen)
                {
                    GenTreePtr      len = tree->gtInd.gtIndLen;

                    /* Make sure the array length gets costed */

                    assert(len->gtOper == GT_ARR_RNGCHK);

                    gtSetEvalOrder(len);
                }
#endif

#if     TGT_SH3

                /* Is this an indirection with an index address? */

                if  (op1->gtOper == GT_ADD)
                {
                    int             rev;
#if SCALED_ADDR_MODES
                    unsigned        mul;
#endif
                    unsigned        cns;
                    GenTreePtr      adr;
                    GenTreePtr      idx;

                    if  (genCreateAddrMode(op1,             // address
                                           0,               // mode
                                           false,           // fold
                                           0,               // reg mask
#if!LEA_AVAILABLE
                                           tree->TypeGet(), // operand type
#endif
                                           &rev,            // reverse ops
                                           &adr,            // base addr
                                           &idx,            // index val
#if SCALED_ADDR_MODES
                                           &mul,            // scaling
#endif
                                           &cns,            // displacement
                                           true))           // don't generate code
                    {
                        if  (adr && idx)
                        {
                            /* The address is "[adr+idx]" */

                            ftreg |= RBM_r00;
                        }
                    }
                }

#endif

                /* An indirection should always have a non-zero level *
                 * Only constant leaf nodes have level 0 */

                if (level == 0)
                    level = 1;
                break;
            }

            goto DONE;
        }

        /* Binary operator - check for certain special cases */

        lvlb = 0;

        switch (oper)
        {
        case GT_MOD:
        case GT_UMOD:

            /* Modulo by a power of 2 is easy */

            if  (op2->gtOper == GT_CNS_INT)
            {
                unsigned    ival = op2->gtIntCon.gtIconVal;

                if  (ival > 0 && ival == genFindLowestBit(ival))
                    break;
            }

            // Fall through ...

        case GT_DIV:
        case GT_UDIV:

            /* Non-integer division is boring */

            if  (!varTypeIsIntegral(tree->TypeGet()))
                break;

            /* Note the fact that division always uses EAX/EDX */

#if     TGT_x86

            ftreg |= RBM_EAX|RBM_EDX;

#if     LONG_MATH_REGPARAM

            // UNDONE: Be smarter about the weighing of sub-operands

            if  (tree->gtType == TYP_LONG)
            {
                ftreg |= RBM_EBX|RBM_ECX;
                break;
            }

#endif

#endif

            /* Encourage the second operand to be evaluated first (strongly) */

            lvlb += 3;

        case GT_MUL:

#if     TGT_x86
#if     LONG_MATH_REGPARAM

            // UNDONE: Be smarter about the weighing of sub-operands

            if  (tree->gtType == TYP_LONG)
            {
                /* Does the second argument trash EDX:EAX ? */

                if  (op2->gtRsvdRegs & (RBM_EAX|RBM_EDX))
                {
                    /* Encourage the second operand to go first (strongly) */

                    lvlb += 30;
                }

                ftreg |= RBM_EBX|RBM_ECX;
                break;
            }

#endif
#endif

            /* Encourage the second operand to be evaluated first (weakly) */

            lvlb++;
            break;

        case GT_CAST:

            /* Estimate the cost of the cast */

            switch (tree->gtType)
            {
            case TYP_LONG:

#if     TGT_x86

                /* Cast from int to long always requires the use of EAX:EDX */

                //
                // UNSIGNED_ISSUE : Unsigned casting doesnt need to use EAX:EDX
                //
                if  (op1->gtType <= TYP_INT)
                {
                    ftreg |= RBM_EAX|RBM_EDX;
                    lvlb += 3;
                }

#endif

                break;
            }

            lvlb++;
            break;

        case GT_COMMA:

            /* Comma tosses the result of the left operand */

#if     TGT_x86
            FPlvlSave = genFPstkLevel;
            level = gtSetEvalOrder(op1);
            genFPstkLevel = FPlvlSave;
#else
            level = gtSetEvalOrder(op1);
#endif

            goto DONE_OP1;

        case GT_COLON:

#if     TGT_x86
            FPlvlSave = genFPstkLevel;
#endif
            level = gtSetEvalOrder(op1);

#if     TGT_x86
            genFPstkLevel = FPlvlSave;
#endif
            lvl2  = gtSetEvalOrder(op2);

            if  (level < lvl2)
                 level = lvl2;

#if!TGT_IA64
            ftreg |= op1->gtRsvdRegs|op2->gtRsvdRegs;
#endif
            cost   = op1->gtCost + op2->gtCost + 1;

            goto DONE;

        case GT_IND:

            /* The second operand of an indirection is just a fake */

            goto UNOP;
        }

        /* Assignments need a bit special handling */

        if  (kind & GTK_ASGOP)
        {
            /* Process the target */

            level = gtSetEvalOrder(op1);

#if     TGT_x86

            /* If assigning an FP value, the target won't get pushed */

            if  (isflt)
            {
                 op1->gtFPlvl--;
                assert(genFPstkLevel);
                genFPstkLevel--;
            }

#endif

            goto DONE_OP1;
        }

        /* Process the sub-operands */

        level  = gtSetEvalOrder(op1);

    DONE_OP1:

        lvl2   = gtSetEvalOrder(op2) + lvlb;

#if!TGT_IA64
        ftreg |= op1->gtRsvdRegs|op2->gtRsvdRegs;
#endif

#if CSE
        cost   = op1->gtCost + op2->gtCost + 1;
#endif

#if TGT_x86

        if  (oper == GT_CAST)
        {
            /* Casts between non-FP and FP push on / pop from the FP stack */

            if  (varTypeIsFloating(op1->TypeGet()))
            {
                if  (isflt == false)
                {
                    assert(genFPstkLevel);
                    genFPstkLevel--;
                }
            }
            else
            {
                if  (isflt != false)
                    genFPstkLevel++;
            }
        }
        else
        {
            /*
                Binary FP operators pop 2 operands and produce 1 result;
                assignments consume 1 value and don't produce anything.
             */

            if  (isflt)
            {
                switch (oper)
                {
                case GT_COMMA:
                    break;

                default:
                    assert(genFPstkLevel);
                    genFPstkLevel--;
                    break;
                }
            }
        }

#endif

        if  (kind & GTK_ASGOP)
        {
            /* If this is a local var assignment, evaluate RHS before LHS */

            switch (op1->gtOper)
            {
            case GT_IND:

                if  (op1->gtOp.gtOp1->gtFlags & GTF_GLOB_EFFECT)
                    break;

                if (op2->gtOper == GT_LCL_VAR)
                    break;

                // fall through

            case GT_LCL_VAR:

                tree->gtFlags |= GTF_REVERSE_OPS;
                break;
            }
        }
#if     TGT_x86
        else if (kind & GTK_RELOP)
        {
            /* Float compares remove both operands from the FP stack
             * Also FP comparison uses EAX for flags */

            if  (varTypeIsFloating(op1->TypeGet()))
            {
                assert(genFPstkLevel >= 2);
                genFPstkLevel -= 2;
                ftreg         |= RBM_EAX;
                level++;
            }
        }
#endif

        /* Check for any 'interesting' cases */

        switch (oper)
        {
        case GT_LSH:
        case GT_RSH:
        case GT_RSZ:
        case GT_ASG_LSH:
        case GT_ASG_RSH:
        case GT_ASG_RSZ:

#if     TGT_x86

            /* Shifts by a non-constant amount are expensive and use ECX */

            if  (op2->gtOper != GT_CNS_INT)
            {
                level += 5;
                ftreg |= RBM_ECX;
            }

#endif

            break;

#if     INLINE_MATH

        case GT_MATH:

            switch (tree->gtMath.gtMathFN)
            {
            case MATH_FN_EXP:
                level += 4;
                break;

            case MATH_FN_POW:
                level += 3;
                break;
            }

            break;

#endif

        }

        /* Is the second operand more expensive? */

        if (level < lvl2)
        {
            /* Relative of order of global / side effects cant be swapped */

            bool    canSwap = true;

            if (op1->gtFlags & GTF_GLOB_EFFECT)
            {
                /* op1 has side efects - check some special cases
                 * where we may be able to still swap */

                if (op2->gtFlags & GTF_GLOB_EFFECT)
                {
                    /* op2 has also side effects - can't swap */
                    canSwap = false;
                }
                else
                {
                    /* No side effects in op2 - we can swap iff
                     *  op1 has no way of modifying op2, i.e. through assignments of byref calls
                     *  op2 is a constant
                     */

                    if (op1->gtFlags & (GTF_ASG | GTF_CALL))
                    {
                        /* We have to be conservative - can swap iff op2 is constant */
                        if (!op2->OperIsConst())
                            canSwap = false;
                    }
                }

                /* We cannot swap in the presence of special side effects such as QMARK COLON */

                if (op1->gtFlags & GTF_OTHER_SIDEEFF)
                    canSwap = false;
            }

            if  (canSwap)
            {
                /* Can we swap the order by commuting the operands? */

                switch (oper)
                {
                    unsigned    tmpl;

                case GT_ADD:
                case GT_MUL:

                case GT_OR:
                case GT_XOR:
                case GT_AND:

                    /* Swap the operands */

                    tree->gtOp.gtOp1 = op2;
                    tree->gtOp.gtOp2 = op1;

                    /* Swap the level counts */

                    tmpl = level;
                           level = lvl2;
                                   lvl2 = tmpl;

                    /* We may have to recompute FP levels */
#if TGT_x86
                    if  (op1->gtFPlvl)
                        fgFPstLvlRedo = true;
#endif
                    break;

#if INLINING
                case GT_QMARK:
                case GT_COLON:
                    break;
#endif

                case GT_COMMA:
                case GT_LIST:
                    break;

                case GT_SUB:

                    /* CONSIDER: Re-enable reversing "-" operands for non-FP types */

#if TGT_x86
                    if  (!isflt)
                        break;
#else
                    if  (!varTypeIsFloating(tree->TypeGet()))
                        break;
#endif

                    // Fall through ....

                default:

                    /* Mark the operand's evaluation order to be swapped */

                    tree->gtFlags |= GTF_REVERSE_OPS;

                    /* Swap the level counts */

                    tmpl = level;
                           level = lvl2;
                                   lvl2 = tmpl;

                    /* We may have to recompute FP levels */

#if TGT_x86
                    if  (op1->gtFPlvl)
                        fgFPstLvlRedo = true;
#endif
                    break;
                }
            }
        }

#if TGT_RISC && !TGT_IA64 /////////////////////////////////////////////////////

        if  (op1 && op2 && ((op1->gtFlags|op2->gtFlags) & GTF_CALL) && oper != GT_COMMA)
        {
            GenTreePtr  x1 = op1;
            GenTreePtr  x2 = op2;

            if  (tree->gtFlags & GTF_REVERSE_OPS)
            {
                x1 = op2;
                x2 = op1;
            }

            if  (x2->gtFlags & GTF_CALL)
            {
                if  (oper != GT_ASG || op1->gtOper == GT_IND)
                {
#ifdef  DEBUG
                    printf("UNDONE: Needs spill/callee-saved temp\n");
//                  gtDispTree(tree);
#endif
                }
            }
        }

#endif       //////////////////////////////////////////////////////////////////

        /* Compute the sethi number for this binary operator */

        if  (level < lvl2)
        {
            level = lvl2;
        }
        else
        {
            if  (level == lvl2)
                level++;
        }

        goto DONE;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_MKREFANY:
    case GT_LDOBJ:
        level  = gtSetEvalOrder(tree->gtLdObj.gtOp1);
#if!TGT_IA64
        ftreg |= tree->gtLdObj.gtOp1->gtRsvdRegs;
#endif
#if CSE
        cost   = tree->gtLdObj.gtOp1->gtCost + 1;
#endif
        break;

    case GT_FIELD:
        assert(tree->gtField.gtFldObj == 0);
        level = 1;
#if CSE
        cost  = 1;
#endif
#if TGT_x86
        genFPstkLevel += isflt;
#endif
        break;

    case GT_CALL:

        assert(tree->gtFlags & GTF_CALL);

        level = 0;
#if CSE
        cost  = 0;  // doesn't matter, calls can't be CSE's anyway
#endif

        /* Evaluate the 'this' argument, if present */

        if  (tree->gtCall.gtCallObjp)
        {
            GenTreePtr     thisVal = tree->gtCall.gtCallObjp;

            level  = gtSetEvalOrder(thisVal);
#if!TGT_IA64
            ftreg |= thisVal->gtRsvdRegs;
#endif
        }

        /* Evaluate the arguments, right to left */

        if  (tree->gtCall.gtCallArgs)
        {
#if TGT_x86
            FPlvlSave = genFPstkLevel;
#endif
            lvl2   = gtSetListOrder(tree->gtCall.gtCallArgs);
#if!TGT_IA64
            ftreg |= tree->gtCall.gtCallArgs->gtRsvdRegs;
#endif
            if  (level < lvl2)
                 level = lvl2;

#if TGT_x86
            genFPstkLevel = FPlvlSave;
#endif
        }

#if USE_FASTCALL

        /* Evaluate the temp register arguments list
         * This is a "hidden" list and its only purpose is to
         * extend the life of temps until we make the call */

        if  (tree->gtCall.gtCallRegArgs)
        {
#if TGT_x86
            FPlvlSave = genFPstkLevel;
#endif

            lvl2   = gtSetRArgOrder(tree->gtCall.gtCallRegArgs,
                                    tree->gtCall.regArgEncode);
#if!TGT_IA64
            ftreg |= tree->gtCall.gtCallRegArgs->gtRsvdRegs;
#endif
            if  (level < lvl2)
                 level = lvl2;

#if TGT_x86
            genFPstkLevel = FPlvlSave;
#endif
        }

#endif

        /* Evaluate the vtable pointer, if present */

        if  (tree->gtCall.gtCallVptr)
        {
            lvl2   = gtSetEvalOrder(tree->gtCall.gtCallVptr);
#if!TGT_IA64
            ftreg |= tree->gtCall.gtCallVptr->gtRsvdRegs;
#endif
            if  (level < lvl2)
                 level = lvl2;
        }

        if  (tree->gtCall.gtCallType == CT_INDIRECT)
        {
            GenTreePtr     indirect = tree->gtCall.gtCallAddr;

            level  = gtSetEvalOrder(indirect);
#if!TGT_IA64
            ftreg |= indirect->gtRsvdRegs;
#endif
            if  (level < lvl2)
                 level = lvl2;
        }

        /* Function calls are quite expensive unless regs are preserved */

        if  (tree->gtFlags & GTF_CALL_REGSAVE)
        {
            level += 1;
        }
        else
        {
            level += 10;                    // ISSUE: is '10' a good value?
#if!TGT_IA64
            ftreg |= RBM_CALLEE_TRASH;
#endif
        }

#if TGT_x86
        genFPstkLevel += isflt;
#endif

        break;

    case GT_JMP:
        level = 0;
        break;

    case GT_JMPI:
        level  = gtSetEvalOrder(tree->gtOp.gtOp1);
#if!TGT_IA64
        ftreg |= tree->gtOp.gtOp1->gtRsvdRegs;
#endif
#if CSE
        cost   = tree->gtOp.gtOp1->gtCost + 1;
#endif
        break;

#if CSELENGTH

    case GT_ARR_RNGCHK:

        {
            GenTreePtr  addr = tree->gtArrLen.gtArrLenAdr; assert(addr);

            /* Has the address already been costed? */

            if  (tree->gtFlags & GTF_ALN_CSEVAL)
                level = gtSetEvalOrder(addr) + 1;
            else
                level = 1;

#if!TGT_IA64
            ftreg |= addr->gtRsvdRegs;
#endif
            cost   = addr->gtCost + 1;
        }
        break;

#endif


    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected operator");
    }

DONE:

#if TGT_x86
//  printf("[FPlvl=%2u] ", genFPstkLevel); gtDispTree(tree, 0, true);
    assert((int)genFPstkLevel >= 0);
    tree->gtFPlvl    = genFPstkLevel;
#endif

#if!TGT_IA64
    tree->gtRsvdRegs = ftreg;
#endif

#if CSE
    tree->gtCost     = (cost > MAX_COST) ? MAX_COST : cost;
#endif

#if     0
#ifdef  DEBUG
    printf("ftregs=%04X ", ftreg);
    gtDispTree(tree, 0, true);
#endif
#endif

    return level;
}

/*****************************************************************************
 *
 *  Returns non-zero if the given tree is an integer constant that can be used
 *  in a scaled index address mode as a multiplier (e.g. "[4*index]").
 */

unsigned            GenTree::IsScaleIndexMul()
{
    if  (gtOper == GT_CNS_INT)
    {
        switch (gtIntCon.gtIconVal)
        {
        case 1:
        case 2:
        case 4:
        case 8:
            return gtIntCon.gtIconVal;
        }
    }

    return 0;
}

/*****************************************************************************
 *
 *  Returns non-zero if the given tree is an integer constant that can be used
 *  in a scaled index address mode as a multiplier (e.g. "[4*index]").
 */

unsigned            GenTree::IsScaleIndexShf()
{
    if  (gtOper == GT_CNS_INT)
    {
        if  (gtIntCon.gtIconVal > 0 &&
             gtIntCon.gtIconVal < 4)
        {
            return 1 << gtIntCon.gtIconVal;
        }
    }

    return 0;
}

/*****************************************************************************
 *
 *  If the given tree is a scaled index (i.e. "op * 4" or "op << 2"), returns
 *  the multiplier (and in that case also makes sure the scaling constant is
 *  the second sub-operand of the tree); otherwise returns 0.
 */

unsigned            GenTree::IsScaledIndex()
{
    GenTreePtr      scale;

    switch (gtOper)
    {
    case GT_MUL:

        scale = gtOp.gtOp2;

        if  (scale->IsScaleIndexMul())
            return scale->gtIntCon.gtIconVal;

        break;

    case GT_LSH:

        scale = gtOp.gtOp2;

        if  (scale->IsScaleIndexShf())
            return  1 << scale->gtIntCon.gtIconVal;

        break;
    }

    return 0;
}

#ifndef FAST

GenTreePtr FASTCALL Compiler::gtNewNode(genTreeOps oper, varType_t  type)
{
#if     SMALL_TREE_NODES
    size_t          size = GenTree::s_gtNodeSizes[oper];
#else
    size_t          size = sizeof(*node);
#endif
    GenTreePtr      node = (GenTreePtr)compGetMem(size);

#ifdef  DEBUG
//  if ((int)node == 0x02bc0a68) debugStop(0);
#endif

#if     MEASURE_NODE_SIZE
    genNodeSizeStats.genTreeNodeCnt  += 1;
    genNodeSizeStats.genTreeNodeSize += size;
#endif

#ifdef  DEBUG
    memset(node, 0xDD, size);
#endif

    node->gtOper     = oper;
    node->gtType     = type;
    node->gtFlags    = 0;
#if TGT_x86
    node->gtUsedRegs = 0;
#endif
    node->gtNext     = 0;

#ifndef NDEBUG
#if     SMALL_TREE_NODES
    if      (size == TREE_NODE_SZ_SMALL)
    {
        node->gtFlags |= GTF_NODE_SMALL;
    }
    else if (size == TREE_NODE_SZ_LARGE)
    {
        node->gtFlags |= GTF_NODE_LARGE;
    }
    else
        assert(!"bogus node size");
#endif
#endif

    return node;
}

#endif

GenTreePtr FASTCALL Compiler::gtNewOperNode(genTreeOps oper,
                                            varType_t  type, GenTreePtr op1,
                                                             GenTreePtr op2)
{
    GenTreePtr      node = gtNewNode(oper, type);

    node->gtOp.gtOp1 = op1;
    node->gtOp.gtOp2 = op2;

    if  (op1) node->gtFlags |= op1->gtFlags & GTF_GLOB_EFFECT;
    if  (op2) node->gtFlags |= op2->gtFlags & GTF_GLOB_EFFECT;

    return node;
}


GenTreePtr FASTCALL Compiler::gtNewIconNode(long value, varType_t type)
{
    GenTreePtr      node = gtNewNode(GT_CNS_INT, type);

    node->gtIntCon.gtIconVal = value;

    return node;
}



GenTreePtr FASTCALL Compiler::gtNewFconNode(float value)
{
    GenTreePtr      node = gtNewNode(GT_CNS_FLT, TYP_FLOAT);

    node->gtFltCon.gtFconVal = value;

    return node;
}


/*****************************************************************************
 *
 *  Allocates a integer constant entry that represents a HANDLE to something.
 *  It may not be allowed to embed HANDLEs directly into the JITed code (for eg,
 *  as arguments to JIT helpers). Get a corresponding value that can be embedded.
 *  If the handle needs to be accessed via an indirection, pValue points to it.
 */

GenTreePtr          Compiler::gtNewIconEmbHndNode(void *       value,
                                                  void *       pValue,
                                                  unsigned     flags,
                                                  unsigned     handle1,
                                                  void *       handle2)
{
    GenTreePtr      node;

    assert((!value) != (!pValue));

    if (value)
    {
        node = gtNewIconHandleNode((long)value, flags, handle1, handle2);
    }
    else
    {
        node = gtNewIconHandleNode((long)pValue, flags, handle1, handle2);
        node->gtFlags |= GTF_NON_GC_ADDR;
        node = gtNewOperNode(GT_IND, TYP_I_IMPL, node);
    }

    return node;
}

/*****************************************************************************/

GenTreePtr FASTCALL Compiler::gtNewLconNode(__int64 *value)
{
    GenTreePtr      node = gtNewNode(GT_CNS_LNG, TYP_LONG);

    node->gtLngCon.gtLconVal = *value;

    return node;
}


GenTreePtr FASTCALL Compiler::gtNewDconNode(double *value)
{
    GenTreePtr      node = gtNewNode(GT_CNS_DBL, TYP_DOUBLE);

    node->gtDblCon.gtDconVal = *value;

    return node;
}


GenTreePtr          Compiler::gtNewSconNode(int CPX, SCOPE_HANDLE scpHandle)
{

#if SMALL_TREE_NODES

    /* 'GT_CNS_STR' nodes later get transformed into 'GT_CALL' */

    assert(GenTree::s_gtNodeSizes[GT_CALL] > GenTree::s_gtNodeSizes[GT_CNS_STR]);

    GenTreePtr      node = gtNewNode(GT_CALL, TYP_REF);
    node->ChangeOper(GT_CNS_STR);
#else
    GenTreePtr      node = gtNewNode(GT_CNS_STR, TYP_REF);
#endif

    node->gtStrCon.gtSconCPX = CPX;

    /* Because this node can come from an inlined method we need to
     * have the scope handle since it will become a helper call */

    node->gtStrCon.gtScpHnd = scpHandle;

    return node;
}


GenTreePtr          Compiler::gtNewZeroConNode(var_types type)
{
    static __int64  lzero = 0;
    static double   dzero = 0.0;

    switch(type)
    {
        GenTreePtr      zero;

    case TYP_INT:       return gtNewIconNode(0);
    case TYP_BYREF:
    case TYP_REF:       zero = gtNewIconNode(0);
                        zero->gtType = type;
                        return zero;
    case TYP_LONG:      return gtNewLconNode(&lzero);
    case TYP_FLOAT:     return gtNewFconNode(0.0);
    case TYP_DOUBLE:    return gtNewDconNode(&dzero);
    default:            assert(!"Bad type");
                        return NULL;
    }
}


GenTreePtr          Compiler::gtNewCallNode(gtCallTypes   callType,
                                            METHOD_HANDLE callHnd,
                                            varType_t     type,
                                            unsigned      flags,
                                            GenTreePtr    args)
{
    GenTreePtr      node = gtNewNode(GT_CALL, type);

    node->gtFlags             |= GTF_CALL|flags;
    node->gtCall.gtCallType    = callType;
    node->gtCall.gtCallMethHnd = callHnd;
    node->gtCall.gtCallArgs    = args;
    node->gtCall.gtCallObjp    =
    node->gtCall.gtCallVptr    = 0;
    node->gtCall.gtCallMoreFlags = 0;
    node->gtCall.gtCallCookie  = 0;
#if USE_FASTCALL
    node->gtCall.gtCallRegArgs = 0;
#endif

    return node;
}

GenTreePtr FASTCALL Compiler::gtNewLclvNode(unsigned   lnum,
                                            varType_t  type,
                                            unsigned   offs)
{
    GenTreePtr      node = gtNewNode(GT_LCL_VAR, type);

    /* Cannot have this assert because the inliner uses this function
     * to add temporaries */

    //assert(lnum < lvaCount);

    node->gtLclVar.gtLclNum  = lnum;
    node->gtLclVar.gtLclOffs = offs;

    return node;
}

#if INLINING

GenTreePtr FASTCALL Compiler::gtNewLclLNode(unsigned   lnum,
                                            varType_t  type,
                                            unsigned   offs)
{
    GenTreePtr      node;

#if SMALL_TREE_NODES

    /* This local variable node may later get transformed into a large node */

    assert(GenTree::s_gtNodeSizes[GT_CALL] > GenTree::s_gtNodeSizes[GT_LCL_VAR]);

    node = gtNewNode(GT_CALL   , type);
    node->ChangeOper(GT_LCL_VAR);
#else
    node = gtNewNode(GT_LCL_VAR, type);
#endif

    node->gtLclVar.gtLclNum  = lnum;
    node->gtLclVar.gtLclOffs = offs;

    return node;
}

#endif

/*****************************************************************************
 *
 *  Create a list out of one value.
 */

GenTreePtr          Compiler::gtNewArgList(GenTreePtr op)
{
    return  gtNewOperNode(GT_LIST, TYP_VOID, op, 0);
}

/*****************************************************************************
 *
 *  Create a list out of the two values.
 */

GenTreePtr          Compiler::gtNewArgList(GenTreePtr op1, GenTreePtr op2)
{
    GenTreePtr      tree;

    tree = gtNewOperNode(GT_LIST, TYP_VOID, op2, 0);
    tree = gtNewOperNode(GT_LIST, TYP_VOID, op1, tree);

    return tree;
}

/*****************************************************************************
 *
 *  Create a node that will assign 'src' to 'dst'.
 */

GenTreePtr FASTCALL Compiler::gtNewAssignNode(GenTreePtr dst, GenTreePtr src)
{
    GenTreePtr      asg;

    /* Mark the target as being assigned */

    if  (dst->gtOper == GT_LCL_VAR) dst->gtFlags |= GTF_VAR_DEF;

    /* Create the assignment node */

    asg = gtNewOperNode(GT_ASG, dst->gtType, dst, src);

    /* Mark the expression as containing an assignment */

    asg->gtFlags |= GTF_ASG;

    return asg;
}

/*****************************************************************************
 *
 *  Clones the given tree value and returns a copy of the given tree. If the
 *  value of 'complexOK' is zero, the cloning is only done provided the tree
 *  is not too complex (whatever that may mean); if it is too complex, 0 is
 *  returned.
 *
 *  Note that there is the fucntion gcCloneExpr which does a more complete
 *  job if you can't handle this funciton failing.
 */

GenTreePtr          Compiler::gtClone(GenTree * tree, bool complexOK)
{
    switch (tree->gtOper)
    {
    case GT_CNS_INT:

#if defined(JIT_AS_COMPILER) || defined (LATE_DISASM)
        if (tree->gtFlags & GTF_ICON_HDL_MASK)
            return gtNewIconHandleNode(tree->gtIntCon.gtIconVal,
                                       tree->gtFlags,
                                       tree->gtIntCon.gtIconHdl.gtIconHdl1,
                                       tree->gtIntCon.gtIconHdl.gtIconHdl2);
        else
#endif
            return gtNewIconNode(tree->gtIntCon.gtIconVal, tree->gtType);

    case GT_LCL_VAR:
        return  gtNewLclvNode(tree->gtLclVar.gtLclNum , tree->gtType,
                              tree->gtLclVar.gtLclOffs);

    case GT_CLS_VAR:
        return  gtNewClsvNode(tree->gtClsVar.gtClsVarHnd, tree->gtType);

    case GT_REG_VAR:
        assert(!"clone regvar");

    default:
        if  (complexOK)
        {
            if  (tree->gtOper == GT_FIELD)
            {
                GenTreePtr  copy;
                GenTreePtr  objp;

                // copied from line 9850

                objp = 0;
                if  (tree->gtField.gtFldObj)
                {
                    objp = gtClone(tree->gtField.gtFldObj, false);
                    if  (!objp)
                        return  objp;
                }

                copy = gtNewFieldRef(tree->TypeGet(),
                                     tree->gtField.gtFldHnd,
                                     objp);

#if HOIST_THIS_FLDS
                copy->gtField.gtFldHTX = tree->gtField.gtFldHTX;
#endif
                copy->gtFlags          = tree->gtFlags;

                return  copy;
            }
            else if  (tree->gtOper == GT_ADD)
            {
                GenTreePtr  op1 = tree->gtOp.gtOp1;
                GenTreePtr  op2 = tree->gtOp.gtOp2;

                if  (op1->OperIsLeaf() &&
                     op2->OperIsLeaf())
                {
                    GenTreePtr clone =  gtNewOperNode(GT_ADD,
                                                      tree->TypeGet(),
                                                      gtClone(op1),
                                                      gtClone(op2));

                    clone->gtFlags |= (tree->gtFlags &
                                       (GTF_OVERFLOW|GTF_EXCEPT|GTF_UNSIGNED));

                    return clone;
                }
            }
                        else if (tree->gtOper == GT_ADDR)
                        {
                                GenTreePtr  op1 = gtClone(tree->gtOp.gtOp1);
                                if (op1 == 0)
                                        return 0;
                                GenTreePtr clone =  gtNewOperNode(GT_ADDR, tree->TypeGet(), op1);
                                clone->gtFlags |= (tree->gtFlags &
                                        (GTF_OVERFLOW|GTF_EXCEPT|GTF_UNSIGNED));
                                return clone;
                        }
        }

        break;
    }

    return 0;
}

/*****************************************************************************
 *
 *  Clones the given tree value and returns a copy of the given tree. Any
 *  references to local variable varNum will be replaced with the integer
 *  constant varVal. If the expression cannot be cloned, 0 is returned.
 */

GenTreePtr          Compiler::gtCloneExpr(GenTree * tree,
                                          unsigned  addFlags,
                                          unsigned  varNum,
                                          long      varVal)
{
    genTreeOps      oper;
    unsigned        kind;
    GenTree *       copy;

    /* Figure out what kind of a node we have */

    oper = tree->OperGet();
    kind = tree->OperKind();

    /* Is this a constant or leaf node? */

    if  (kind & (GTK_CONST|GTK_LEAF))
    {
        switch (tree->gtOper)
        {
        case GT_CNS_INT:

#if defined(JIT_AS_COMPILER) || defined (LATE_DISASM)
            if  (tree->gtFlags & GTF_ICON_HDL_MASK)
            {
                copy = gtNewIconHandleNode(tree->gtIntCon.gtIconVal,
                                           tree->gtFlags,
                                           tree->gtIntCon.gtIconCPX,
                                           tree->gtIntCon.gtIconCls);

            }
            else
#endif
            {
                copy = gtNewIconNode      (tree->gtIntCon.gtIconVal,
                                           tree->gtType);
            }

            goto DONE;

        case GT_CNS_LNG:
            copy = gtNewLconNode(&tree->gtLngCon.gtLconVal);
            goto DONE;

        case GT_CNS_FLT:
            copy = gtNewFconNode( tree->gtFltCon.gtFconVal);
            goto DONE;

        case GT_CNS_DBL:
            copy = gtNewDconNode(&tree->gtDblCon.gtDconVal);
            goto DONE;

        case GT_CNS_STR:
            copy = gtNewSconNode(tree->gtStrCon.gtSconCPX, tree->gtStrCon.gtScpHnd);
            goto DONE;

        case GT_LCL_VAR:

            if  (tree->gtLclVar.gtLclNum == varNum)
                copy = gtNewIconNode(varVal, tree->gtType);
            else
                copy = gtNewLclvNode(tree->gtLclVar.gtLclNum , tree->gtType,
                                     tree->gtLclVar.gtLclOffs);

            goto DONE;

        case GT_CLS_VAR:
            copy = gtNewClsvNode(tree->gtClsVar.gtClsVarHnd, tree->gtType);

            goto DONE;

        case GT_REG_VAR:
            assert(!"regvar should never occur here");

        default:
            assert(!"unexpected leaf/const");
        }
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        /* If necessary, make sure we allocate a "fat" tree node */

#if SMALL_TREE_NODES
        switch (oper)
        {
        case GT_MUL:
        case GT_DIV:
        case GT_MOD:
        case GT_CAST:
        case GT_INDEX:

        case GT_UDIV:
        case GT_UMOD:

            /* These nodes sometimes get bashed to "fat" ones */

            copy = gtNewOperNode(GT_CALL, tree->TypeGet());
            copy->ChangeOper(oper);
            break;

        default:
           copy = gtNewOperNode(oper, tree->TypeGet());
           break;
        }
#else
        copy = gtNewOperNode(oper, tree->TypeGet());
#endif

        /* Some unary/binary nodes have extra fields */

        switch (oper)
        {
#if INLINE_MATH
        case GT_MATH:
            copy->gtMath.gtMathFN = tree->gtMath.gtMathFN;
            break;
#endif

        case GT_IND:

            copy->gtInd.gtIndex    = tree->gtInd.gtIndex;
#if CSELENGTH
            copy->gtInd.gtIndLen   = tree->gtInd.gtIndLen;
#endif
            copy->gtInd.gtStkDepth = tree->gtInd.gtStkDepth;

#if CSELENGTH

            if  (tree->gtOper == GT_IND && tree->gtInd.gtIndLen)
            {
                if  (tree->gtFlags & GTF_IND_RNGCHK)
                {
                    GenTreePtr      len = tree->gtInd.gtIndLen;
                    GenTreePtr      tmp;

                    GenTreePtr      gtSaveCopyVal;
                    GenTreePtr      gtSaveCopyNew;

                    /* Make sure the array length value looks reasonable */

                    assert(len->gtOper == GT_ARR_RNGCHK);

                    /* Clone the array length subtree */

                    copy->gtInd.gtIndLen = tmp = gtCloneExpr(len, addFlags, varNum, varVal);

                    /*
                        When we clone the operand, we take care to find
                        the copied array address.
                     */

                    gtSaveCopyVal = gtCopyAddrVal;
                    gtSaveCopyNew = gtCopyAddrNew;

                    gtCopyAddrVal = len->gtArrLen.gtArrLenAdr;
#ifndef NDEBUG
                    gtCopyAddrNew = (GenTreePtr)-1;
#endif

                    copy->gtOp.gtOp1 = gtCloneExpr(tree->gtOp.gtOp1, addFlags, varNum, varVal);

#ifndef NDEBUG
                    assert(gtCopyAddrNew != (GenTreePtr)-1);
#endif

                    tmp->gtArrLen.gtArrLenAdr = gtCopyAddrNew;

                    gtCopyAddrVal = gtSaveCopyVal;
                    gtCopyAddrNew = gtSaveCopyNew;

#if 0
                    {
                        unsigned svf = copy->gtFlags;
                        copy->gtFlags = tree->gtFlags;
                        printf("Copy %08X to %08X\n", tree, copy);
                        gtDispTree(tree);
                        printf("\n");
                        gtDispTree(copy);
                        printf("\n");
                        gtDispTree(len->gtArrLen.gtArrLenAdr);
                        printf("\n");
                        gtDispTree(tmp->gtArrLen.gtArrLenAdr);
                        printf("\n\n");
                        copy->gtFlags = svf;
                    }
#endif

                    goto DONE;
                }
            }

#endif // CSELENGTH

            break;
        }

        if  (tree->gtOp.gtOp1) copy->gtOp.gtOp1 = gtCloneExpr(tree->gtOp.gtOp1, addFlags, varNum, varVal);
        if  (tree->gtOp.gtOp2) copy->gtOp.gtOp2 = gtCloneExpr(tree->gtOp.gtOp2, addFlags, varNum, varVal);

        /* HACK: Poor man's constant folder */

        if  (copy->gtOp.gtOp1 && copy->gtOp.gtOp1->gtOper == GT_CNS_INT &&
             copy->gtOp.gtOp2 && copy->gtOp.gtOp2->gtOper == GT_CNS_INT)
        {
            long        v1 = copy->gtOp.gtOp1->gtIntCon.gtIconVal;
            long        v2 = copy->gtOp.gtOp2->gtIntCon.gtIconVal;

            switch (oper)
            {
            case GT_ADD: v1 += v2; break;
            case GT_SUB: v1 -= v2; break;
            case GT_MUL: v1 *= v2; break;

            default:
                goto DONE;
            }

            copy->gtOper             = GT_CNS_INT;
            copy->gtIntCon.gtIconVal = v1;
        }

        goto DONE;
    }

    /* See what kind of a special operator we have here */

    switch  (oper)
    {
    case GT_STMT:
        copy = gtCloneExpr(tree->gtStmt.gtStmtExpr, addFlags, varNum, varVal);
        copy = gtNewStmt(copy, tree->gtStmtILoffs);
        goto DONE;

    case GT_CALL:

        copy = gtNewOperNode(oper, tree->TypeGet());

        copy->gtCall.gtCallObjp = tree->gtCall.gtCallObjp ? gtCloneExpr(tree->gtCall.gtCallObjp, addFlags, varNum, varVal) : 0;
        copy->gtCall.gtCallVptr = tree->gtCall.gtCallVptr ? gtCloneExpr(tree->gtCall.gtCallVptr, addFlags, varNum, varVal) : 0;
        copy->gtCall.gtCallArgs = tree->gtCall.gtCallArgs ? gtCloneExpr(tree->gtCall.gtCallArgs, addFlags, varNum, varVal) : 0;
        copy->gtCall.gtCallMoreFlags = tree->gtCall.gtCallMoreFlags;
#if USE_FASTCALL
        copy->gtCall.gtCallRegArgs  = tree->gtCall.gtCallRegArgs ? gtCloneExpr(tree->gtCall.gtCallRegArgs, addFlags, varNum, varVal) : 0;
        copy->gtCall.regArgEncode   = tree->gtCall.regArgEncode;
#endif
        copy->gtCall.gtCallType     = tree->gtCall.gtCallType;
        copy->gtCall.gtCallCookie   = tree->gtCall.gtCallCookie;

        /* Copy all of the union */

        copy->gtCall.gtCallMethHnd  = tree->gtCall.gtCallMethHnd;
        copy->gtCall.gtCallAddr     = tree->gtCall.gtCallAddr;

        goto DONE;

    case GT_MKREFANY:
    case GT_LDOBJ:
        copy = gtNewOperNode(oper, TYP_STRUCT);
        copy->gtLdObj.gtClass = tree->gtLdObj.gtClass;
        copy->gtLdObj.gtOp1 = gtCloneExpr(tree->gtLdObj.gtOp1, addFlags, varNum, varVal);
        goto DONE;

    case GT_FIELD:

        copy = gtNewFieldRef(tree->TypeGet(),
                             tree->gtField.gtFldHnd,
                             0);

        copy->gtField.gtFldObj  = tree->gtField.gtFldObj  ? gtCloneExpr(tree->gtField.gtFldObj , addFlags, varNum, varVal) : 0;

#if HOIST_THIS_FLDS
        copy->gtField.gtFldHTX  = tree->gtField.gtFldHTX;
#endif

        goto DONE;

#if CSELENGTH

    case GT_ARR_RNGCHK:

        copy = gtNewOperNode(oper, tree->TypeGet());

        /*
            Note: if we're being cloned as part of an GT_IND expression,
            gtArrLenAdr will be filled in when the GT_IND is cloned. If
            we're the root of the tree being copied, though, we need to
            make a copy of the address expression.
         */

        copy->gtArrLen.gtArrLenCse = tree->gtArrLen.gtArrLenCse ? gtCloneExpr(tree->gtArrLen.gtArrLenCse, addFlags, varNum, varVal) : 0;
        copy->gtArrLen.gtArrLenAdr = NULL;

        if  (tree->gtFlags & GTF_ALN_CSEVAL)
        {
            assert(tree->gtArrLen.gtArrLenAdr);
            copy->gtArrLen.gtArrLenAdr = gtCloneExpr(tree->gtArrLen.gtArrLenAdr, addFlags, varNum, varVal);
        }

        goto DONE;

#endif


    default:
#ifdef  DEBUG
        gtDispTree(tree);
#endif
        assert(!"unexpected operator");
    }

DONE:

    /* We assume the FP stack level will be identical */

#if TGT_x86
    copy->gtFPlvl = tree->gtFPlvl;
#endif

    /* Compute the flags for the copied node */

    addFlags |= tree->gtFlags;

    /* Make sure we preserve the node size flags */

#ifdef  DEBUG
    addFlags &= ~GTF_PRESERVE;
    addFlags |=  GTF_PRESERVE & copy->gtFlags;
#endif

    copy->gtFlags = addFlags;

#if CSELENGTH

    if  (tree == gtCopyAddrVal)
        gtCopyAddrNew = copy;

#endif

    /* Make sure to copy back fields that may have been initialized */

    copy->gtCost     = tree->gtCost;
#if!TGT_IA64
    copy->gtRsvdRegs = tree->gtRsvdRegs;
#endif

    return  copy;
}


/*****************************************************************************/
#ifdef DEBUG
/*****************************************************************************/

//  "tree" may be NULL.

void                Compiler::gtDispNode(GenTree    *   tree,
                                         unsigned       indent,
                                         const char *   name,
                                         bool           terse)
{
    /* Indent the node accordingly */

    if  (indent)
        printf("%*c ", 1+indent*3, ' ');
    else if (!terse)
        printf(">>");

    /* Print the node address */

    printf("[%08X] ", tree);

    if  (tree)
    {
        /* Print the flags associated with the node */

        if  (terse)
        {
            switch (tree->gtOper)
            {
            case GT_LCL_VAR:
            case GT_REG_VAR:
                printf("%c", (tree->gtFlags & GTF_VAR_DEF    ) ? 'D' : ' ');
                printf("%c", (tree->gtFlags & GTF_VAR_USE    ) ? 'U' : ' ');
                printf("%c", (tree->gtFlags & GTF_VAR_USEDEF ) ? 'b' : ' ');
                printf(" ");
                break;

            default:
                printf("    ");
                break;
            }
        }
        else
        {
            switch (tree->gtOper)
            {
            case GT_LCL_VAR:
            case GT_REG_VAR:
                printf("%c", (tree->gtFlags & GTF_VAR_DEF    ) ? 'D' : ' ');
                printf("%c", (tree->gtFlags & GTF_VAR_USE    ) ? 'U' : ' ');
                break;

            default:
                printf("  ");
                break;
            }

            printf("%c", (tree->gtFlags & GTF_REVERSE_OPS   ) ? 'R' : ' ');
            printf("%c", (tree->gtFlags & GTF_ASG           ) ? 'A' : ' ');
            printf("%c", (tree->gtFlags & GTF_CALL          ) ? 'C' : ' ');
            printf("%c", (tree->gtFlags & GTF_EXCEPT        ) ? 'X' : ' ');
            printf("%c", (tree->gtFlags & GTF_GLOB_REF      ) ? 'G' : ' ');
            printf("%c", (tree->gtFlags & GTF_OTHER_SIDEEFF ) ? 'O' : ' ');
            printf("%c", (tree->gtFlags & GTF_DONT_CSE   ) ? 'N' : ' ');
            printf(" ");
        }

        /* print the type of the node */

        printf("%-6s ", varTypeName(tree->TypeGet()));

#if TGT_x86

        if  ((BYTE)tree->gtFPlvl == 0xDD)
            printf("    ");
        else
            printf("FP=%u ", tree->gtFPlvl);

#else

        if  (!terse)
        {
            if  ((unsigned char)tree->gtTempRegs == 0xDD)
                printf("    ");
            else
                printf("T=%u ", tree->gtTempRegs);
        }

#endif

//      printf("RR="); dspRegMask(tree->gtRsvdRegs);

#if 0

        // for tracking down problems in reguse prediction or liveness tracking

        if (verbose)
        {
            dspRegMask(tree->gtUsedRegs);
            printf(" liveset %s ", genVS2str(tree->gtLiveSet));
        }

#endif

        if  (!terse)
        {
            if  (tree->gtFlags & GTF_REG_VAL)
            {
#if     TGT_x86
                if (tree->gtType == TYP_LONG)
                    printf("%s ", compRegPairName(tree->gtRegPair));
                else
#endif
                    printf("%s ", compRegVarName(tree->gtRegNum));
            }
        }
    }

    /* print the node name */

    assert(tree || name);

    if  (!name)
    {
        name = (tree->gtOper < GT_COUNT) ? GenTree::NodeName(tree->OperGet()) : "<ERROR>";
    }

    printf("%6s%3s ", name, tree->gtOverflowEx() ? "ovf" : "");

    assert(tree == 0 || tree->gtOper < GT_COUNT);
}


/*****************************************************************************/
#ifdef  DEBUG

const   char *      Compiler::findVarName(unsigned varNum, BasicBlock * block)
{
    if  (info.compLocalVarsCount <= 0 || !block)
        return  NULL;

    unsigned        blkBeg = block->bbCodeOffs;
    unsigned        blkEnd = block->bbCodeSize + blkBeg;

    unsigned        i;
    LocalVarDsc *   t;

#if RET_64BIT_AS_STRUCTS

    /* Adjust the variable number if it follows secret arg */

    if  (fgRetArgUse)
    {
        if  (varNum == fgRetArgNum)
            break;

        if  (varNum >  fgRetArgNum)
            varNum--;
    }

#endif

if  ((int)info.compLocalVars == 0xDDDDDDDD) return NULL;    // why is this needed?????

    for (i = 0, t = info.compLocalVars;
         i < info.compLocalVarsCount;
         i++  , t++)
    {
        if  (t->lvdVarNum  != varNum)
            continue;
        if  (t->lvdLifeBeg >= blkEnd)
            continue;
        if  (t->lvdLifeEnd <= blkBeg)
            continue;

        return lvdNAMEstr(t->lvdName);
    }

    return  NULL;
}

#endif
/*****************************************************************************/

void                Compiler::gtDispTree(GenTree *  tree,
                                         unsigned   indent,
                                         bool       topOnly)
{
    unsigned        kind;

    if  (tree == 0)
    {
        printf("%*c [%08X] <NULL>\n", 1+indent*3, ' ', tree);
        fflush(stdout);
        return;
    }

    assert((int)tree != 0xDDDDDDDD);    /* Value used to initalize nodes */

    if  (tree->gtOper >= GT_COUNT)
    {
        gtDispNode(tree, indent, NULL, topOnly); assert(!"bogus operator");
    }

    kind = tree->OperKind();

    /* Is tree a constant node? */

    if  (kind & GTK_CONST)
    {
        gtDispNode(tree, indent, NULL, topOnly);

        switch  (tree->gtOper)
        {
        case GT_CNS_INT: printf(" %ld"   , tree->gtIntCon.gtIconVal); break;
        case GT_CNS_LNG: printf(" %I64d" , tree->gtLngCon.gtLconVal); break;
        case GT_CNS_FLT: printf(" %f"    , tree->gtFltCon.gtFconVal); break;
        case GT_CNS_DBL: printf(" %lf"   , tree->gtDblCon.gtDconVal); break;

        case GT_CNS_STR:

            const char * str;

            if  (str = eeGetCPString(tree->gtStrCon.gtSconCPX))
                printf("'%s'", str);
            else
                printf("<cannot get string constant>");

            break;

        default: assert(!"unexpected constant node");
        }

        printf("\n");
        fflush(stdout);
        return;
    }

    /* Is tree a leaf node? */

    if  (kind & GTK_LEAF)
    {
        gtDispNode(tree, indent, NULL, topOnly);

        switch  (tree->gtOper)
        {
            unsigned        varNum;
            const   char *  varNam;

        case GT_LCL_VAR:

            varNum = tree->gtLclVar.gtLclNum;

            printf("#%u", varNum);

            varNam = compCurBB ? findVarName(varNum, compCurBB) : NULL;

            if  (varNam)
                printf(" '%s'", varNam);

            break;

        case GT_REG_VAR:
            printf("#%u reg=" , tree->gtRegVar.gtRegVar);
            if  (tree->gtType == TYP_DOUBLE)
                printf("ST(%u)",            tree->gtRegVar.gtRegNum);
            else
                printf("%s", compRegVarName(tree->gtRegVar.gtRegNum));

#ifdef  DEBUG

            if  (info.compLocalVarsCount>0 && compCurBB)
            {
                unsigned        blkBeg = compCurBB->bbCodeOffs;
                unsigned        blkEnd = compCurBB->bbCodeSize + blkBeg;

                unsigned        i;
                LocalVarDsc *   t;

                for (i = 0, t = info.compLocalVars;
                     i < info.compLocalVarsCount;
                     i++  , t++)
                {
                    if  (t->lvdVarNum  != tree->gtRegVar.gtRegVar)
                        continue;
                    if  (t->lvdLifeBeg >  blkEnd)
                        continue;
                    if  (t->lvdLifeEnd <= blkBeg)
                        continue;

                    printf(" '%s'", lvdNAMEstr(t->lvdName));
                    break;
                }
            }

#endif

            break;

        case GT_CLS_VAR:
            printf("Hnd=%#x"     , tree->gtClsVar.gtClsVarHnd);
            break;

        case GT_LABEL:
            printf("dst=%u"     , tree->gtLabel.gtLabBB->bbNum);
            break;

        case GT_FTN_ADDR:
            printf("fntAddr=%d" , tree->gtVal.gtVal1);
            break;

        // Vanilla leaves. No qualifying information available. So do nothing

        case GT_NO_OP:
        case GT_RET_ADDR:
        case GT_CATCH_ARG:
        case GT_POP:
#if OPTIMIZE_QMARK
        case GT_BB_QMARK:
#endif
            break;

        default:
            assert(!"don't know how to display tree leaf node");
        }

        printf("\n");
        fflush(stdout);
        return;
    }

    /* Is it a 'simple' unary/binary operator? */

    if  (kind & GTK_SMPOP)
    {
        if  (tree->gtOp.gtOp2 && !topOnly)
            gtDispTree(tree->gtOp.gtOp2, indent + 1);

#if CSELENGTH

        if  (tree->gtOper == GT_IND && tree->gtInd.gtIndLen && !topOnly)
        {
            if  (tree->gtFlags & GTF_IND_RNGCHK)
            {
                GenTreePtr  len = tree->gtInd.gtIndLen;

                /* Prevent recursive death */

                if  (!(len->gtFlags & GTF_CC_SET))
                {
                               len->gtFlags |=  GTF_CC_SET;
                    gtDispTree(len, indent + 1);
                               len->gtFlags &= ~GTF_CC_SET;
                }
            }
        }

#endif

        gtDispNode(tree, indent, NULL, topOnly);

#if     CSELENGTH || RNGCHK_OPT

        if  (tree->gtOper == GT_IND)
        {
            int         temp;

            temp = tree->gtInd.gtIndex;
            if  (temp != 0xDDDDDDDD) printf(" indx=%u", temp);

            temp = tree->gtInd.gtStkDepth;
            if  (temp != 0xDDDDDDDD) printf(" stkDepth=%u", temp);
        }

#endif

        printf("\n");

        if  (tree->gtOp.gtOp1 && !topOnly)
            gtDispTree(tree->gtOp.gtOp1, indent + 1);

        fflush(stdout);
        return;
    }

    /* See what kind of a special operator we have here */

    switch  (tree->gtOper)
    {
    case GT_MKREFANY:
    case GT_LDOBJ:
        gtDispNode(tree, indent, NULL, topOnly);
        printf("\n");

        if  (tree->gtOp.gtOp1 && !topOnly)
            gtDispTree(tree->gtOp.gtOp1, indent + 1);
        fflush(stdout);
        return;

    case GT_FIELD:

        gtDispNode(tree, indent, NULL, topOnly);

#ifdef  NOT_JITC
#if     INLINING
        printf("[");
        printf("%08x] ", tree->gtField.gtFldHnd);
#endif
#endif

#if     INLINING
        printf("'%s'\n", eeGetFieldName(tree->gtField.gtFldHnd), 0);
#else
        printf("'%s'\n", eeGetFieldName(tree->gtField.gtFldHnd), 0);
#endif

        if  (tree->gtField.gtFldObj  && !topOnly)  gtDispTree(tree->gtField.gtFldObj, indent + 1);

        fflush(stdout);
        return;

    case GT_CALL:

        assert(tree->gtFlags & GTF_CALL);

        if  (tree->gtCall.gtCallArgs && !topOnly)
        {
#if USE_FASTCALL
            if  (tree->gtCall.gtCallRegArgs)
            {
                printf("%*c ", 1+indent*3, ' ');
                printf("Call Arguments:\n");
            }
#endif
            gtDispTree(tree->gtCall.gtCallArgs, indent + 1);
        }

#if USE_FASTCALL
        if  (tree->gtCall.gtCallRegArgs && !topOnly)
        {
            printf("%*c ", 1+indent*3, ' ');
            printf("Register Arguments:\n");
            gtDispTree(tree->gtCall.gtCallRegArgs, indent + 1);
        }
#endif

        gtDispNode(tree, indent, NULL, topOnly);

        if (tree->gtCall.gtCallType == CT_INDIRECT)
        {
            printf("'indirect'\n");
        }
        else
        {
            const char *    methodName;
            const char *     className;

            methodName = eeGetMethodName(tree->gtCall.gtCallMethHnd, &className);

            printf("'%s.%s'\n", className, methodName);
        }

        if  (tree->gtCall.gtCallObjp && !topOnly) gtDispTree(tree->gtCall.gtCallObjp, indent + 1);

        if  (tree->gtCall.gtCallVptr && !topOnly) gtDispTree(tree->gtCall.gtCallVptr, indent + 1);

        if  (tree->gtCall.gtCallType == CT_INDIRECT && !topOnly)
            gtDispTree(tree->gtCall.gtCallAddr, indent + 1);

        fflush(stdout);
        return;

    case GT_JMP:
        const char *    methodName;
        const char *     className;

        gtDispNode(tree, indent, NULL, topOnly);

        methodName = eeGetMethodName((METHOD_HANDLE)tree->gtVal.gtVal1, &className);

        printf("'%s.%s'\n", className, methodName);
        fflush(stdout);
        return;

    case GT_JMPI:
        gtDispNode(tree, indent, NULL, topOnly);
        printf("\n");

        if  (tree->gtOp.gtOp1 && !topOnly)
            gtDispTree(tree->gtOp.gtOp1, indent + 1);

        fflush(stdout);
        return;

    case GT_STMT:

        gtDispNode(tree, indent, NULL, topOnly); printf("\n");

        if  (!topOnly)
            gtDispTree(tree->gtStmt.gtStmtExpr, indent + 1);
        fflush(stdout);
        return;

#if CSELENGTH

    case GT_ARR_RNGCHK:

        if  (!(tree->gtFlags & GTF_CC_SET))
        {
            if  (tree->gtArrLen.gtArrLenAdr && !topOnly)
                gtDispTree(tree->gtArrLen.gtArrLenAdr, indent + 1);
        }

        gtDispNode(tree, indent, NULL, topOnly); printf(" [adr=%08X]\n", tree->gtArrLen.gtArrLenAdr);

        if  (tree->gtArrLen.gtArrLenCse && !topOnly)
            gtDispTree(tree->gtArrLen.gtArrLenCse, indent + 1);

        fflush(stdout);
        return;

#endif

    default:
        gtDispNode(tree, indent, NULL, topOnly);

        printf("<DON'T KNOW HOW TO DISPLAY THIS NODE>\n");
        fflush(stdout);
        return;
    }
}

/*****************************************************************************/

void                Compiler::gtDispTreeList(GenTree * tree)
{
    for (/*--*/; tree != NULL; tree = tree->gtNext)
    {
        if (tree->gtOper == GT_STMT && opts.compDbgInfo)
            printf("start IL : %03Xh, end IL : %03Xh\n",
                    tree->gtStmtILoffs, tree->gtStmt.gtStmtLastILoffs);

        gtDispTree(tree, 0);

        printf("\n");
    }
}

/*****************************************************************************/
#endif // DEBUG
/*****************************************************************************
 *
 *  Check if the given node can be folded,
 *  and call the methods to perform the folding
 */

GenTreePtr             Compiler::gtFoldExpr(GenTreePtr tree)
{
    unsigned        kind = tree->OperKind();

    /* We must have a simple operation to fold */

    if (!(kind & GTK_SMPOP))
        return tree;

    /* Filter out non-foldable trees that can have constant children */

    assert (kind & (GTK_UNOP | GTK_BINOP));
    switch (tree->gtOper)
    {
    case GT_RETFILT:
    case GT_RETURN:
    case GT_IND:
    case GT_NOP:
        return tree;
    }

    GenTreePtr  op1 = tree->gtOp.gtOp1;
    GenTreePtr  op2 = tree->gtOp.gtOp2;

    /* try to fold the current node */

    if  ((kind & GTK_UNOP) && op1)
    {
        if  (op1->OperKind() & GTK_CONST)
            return gtFoldExprConst(tree);
    }
    else if ((kind & GTK_BINOP) && op1 && op2)
    {
        if  ((op1->OperKind() & op2->OperKind()) & GTK_CONST)
        {
            /* both nodes are constants - fold the expression */
            return gtFoldExprConst(tree);
        }
        else if ((op1->OperKind() | op2->OperKind()) & GTK_CONST)
        {
            /* at least one is a constant - see if we have a
             * special operator that can use only one constant
             * to fold - e.g. booleans */

            return gtFoldExprSpecial(tree);
        }
    }

    /* Return the original node (folded/bashed or not) */

    return tree;
}

/*****************************************************************************
 *
 *  Some binary operators can be folded even if they have only one
 *  operand constant - e.g. boolean operators, add with 0
 *  multiply with 1, etc
 */

GenTreePtr              Compiler::gtFoldExprSpecial(GenTreePtr tree)
{
    GenTreePtr      op1 = tree->gtOp.gtOp1;
    GenTreePtr      op2 = tree->gtOp.gtOp2;

    GenTreePtr      op, cons;
    unsigned        val;

    assert(tree->OperKind() & GTK_BINOP);

    /* Filter out operators that cannot be folded here */
    if  ((tree->OperKind() & (GTK_ASGOP|GTK_RELOP)) ||
         (tree->gtOper == GT_CAST)       )
         return tree;

    /* We only consider TYP_INT for folding
     * Do not fold pointer arythmetic (e.g. addressing modes!) */

    if (tree->gtOper != GT_QMARK)
        if  ((tree->gtType != TYP_INT) || (tree->gtFlags & GTF_NON_GC_ADDR))
            return tree;

    /* Find out which is the constant node
     * CONSIDER - allow constant other than INT */

    if (op1->gtOper == GT_CNS_INT)
    {
        op    = op2;
        cons  = op1;
    }
    else if (op2->gtOper == GT_CNS_INT)
    {
        op    = op1;
        cons  = op2;
    }
    else
        return tree;

    /* Get the constant value */

    val = cons->gtIntCon.gtIconVal;

    /* Here op is the non-constant operand, val is the constant, first is true if the constant is op1
     * IMPORTANT: Need to save the gtStmtList links of the initial node and restore them on the folded node */

    GenTreePtr  saveGtNext = tree->gtNext;
    GenTreePtr  saveGtPrev = tree->gtPrev;

    switch  (tree->gtOper)
    {
    case GT_ADD:
    case GT_ASG_ADD:
        if  (val == 0) goto DONE_FOLD;
        break;

    case GT_MUL:
    case GT_ASG_MUL:
        if  (val == 1)
            goto DONE_FOLD;
        else if (val == 0)
        {
            /* Multiply by zero - return the 'zero' node, but not if side effects */
            if (!(op->gtFlags & (GTF_SIDE_EFFECT & ~GTF_OTHER_SIDEEFF)))
            {
                op = cons;
                goto DONE_FOLD;
            }
        }
        break;

    case GT_DIV:
    case GT_UDIV:
    case GT_ASG_DIV:
        if ((val == 1) && !(op1->OperKind() & GTK_CONST))
        {
            goto DONE_FOLD;
        }
        break;

    case GT_AND:
        if  (val == 0)
        {
            /* AND with zero - return the 'zero' node, but not if side effects */

            if (!(op->gtFlags & (GTF_SIDE_EFFECT & ~GTF_OTHER_SIDEEFF)))
            {
                op = cons;
                goto DONE_FOLD;
            }
        }
        else
        {
            /* The GTF_BOOLEAN flag is set for nodes that are part
             * of a boolean expression, thus all their children
             * are known to evaluate to only 0 or 1 */

            if (tree->gtFlags & GTF_BOOLEAN)
            {
                /* The constant value must be 1
                 * AND with 1 stays the same */
                assert(val == 1);
                goto DONE_FOLD;
            }
        }
        break;

    case GT_OR:
        if  (val == 0)
            goto DONE_FOLD;
        else if (tree->gtFlags & GTF_BOOLEAN)
        {
            /* The constant value must be 1 - OR with 1 is 1 */

            assert(val == 1);

            /* OR with one - return the 'one' node, but not if side effects */

            if (!(op->gtFlags & (GTF_SIDE_EFFECT & ~GTF_OTHER_SIDEEFF)))
            {
                op = cons;
                goto DONE_FOLD;
            }
        }
        break;

    case GT_QMARK:
        assert(op1->gtOper == GT_CNS_INT);
        assert(op2->gtOper == GT_COLON);
        assert(op2->gtOp.gtOp1 && op2->gtOp.gtOp2);

        assert(val == 0 || val == 1);

        if (val)
            op = op2->gtOp.gtOp2;
        else
            op = op2->gtOp.gtOp1;

        goto DONE_FOLD;

    default:
        break;
    }

    /* The node is not foldable */

    return tree;

DONE_FOLD:

    /* The node has beeen folded into 'op'
     * Return 'op' with the restored links */

    op->gtNext = saveGtNext;
    op->gtPrev = saveGtPrev;

    return op;
}


/*****************************************************************************
 *
 *  Fold the given constant tree.
 */

GenTreePtr                  Compiler::gtFoldExprConst(GenTreePtr tree)
{
    unsigned        kind = tree->OperKind();

    long            i1, i2, itemp;
    __int64         lval1, lval2, ltemp;
    float           f1, f2;
    double          d1, d2;

    GenTreePtr      op1;
    GenTreePtr      op2;

    assert (kind & (GTK_UNOP | GTK_BINOP));

    if      (kind & GTK_UNOP)
    {
        op1 = tree->gtOp.gtOp1;

        assert(op1->OperKind() & GTK_CONST);

#ifdef  DEBUG
        if  (verbose&&1)
        {
            if (tree->gtOper == GT_NOT ||
                tree->gtOper == GT_NEG ||
                tree->gtOper == GT_CHS  )
            {
                printf("Folding unary operator with constant node:\n");
                gtDispTree(tree);
                printf("\n");
            }
        }
#endif
        switch(op1->gtType)
        {
        case TYP_INT:

            /* Fold constant INT unary operator */
            i1 = op1->gtIntCon.gtIconVal;

            switch (tree->gtOper)
            {
            case GT_NOT: i1 = ~i1; break;

            case GT_NEG:
            case GT_CHS: i1 = -i1; break;

            default:
                return tree;
            }

            goto CNS_INT;

        case TYP_LONG:

            /* Fold constant LONG unary operator */

            lval1 = op1->gtLngCon.gtLconVal;

            switch (tree->gtOper)
            {
            case GT_NOT: lval1 = ~lval1; break;

            case GT_NEG:
            case GT_CHS: lval1 = -lval1; break;

            default:
                return tree;
            }

            goto CNS_LONG;

        case TYP_FLOAT:

            /* Fold constant FLOAT unary operator */

            f1 = op1->gtFltCon.gtFconVal;

            switch (tree->gtOper)
            {
            case GT_NEG:
            case GT_CHS: f1 = -f1; break;

            default:
                return tree;
            }

            goto CNS_FLOAT;

        case TYP_DOUBLE:

            /* Fold constant DOUBLE unary operator */

            d1 = op1->gtDblCon.gtDconVal;

            switch (tree->gtOper)
            {
            case GT_NEG:
            case GT_CHS: d1 = -d1; break;

            default:
                return tree;
            }

            goto CNS_DOUBLE;

        default:
            /* not a foldable typ - e.g. RET const */
            return tree;
        }
    }

    /* We have a binary operator */

    assert(kind & GTK_BINOP);

    op1 = tree->gtOp.gtOp1;
    op2 = tree->gtOp.gtOp2;

    assert(op1->OperKind() & GTK_CONST);
    assert(op2->OperKind() & GTK_CONST);

#ifdef  DEBUG
    if  (verbose&&1)
    {
        printf("\nFolding binary operator with constant nodes:\n");
        gtDispTree(tree);
        printf("\n");
    }
#endif

    switch(op1->gtType)
    {

    /*-------------------------------------------------------------------------
     * Fold constant INT binary operator
     */

    case TYP_INT:

        assert (op2->gtType == TYP_INT || op2->gtType == TYP_NAT_INT);

        assert (tree->gtType == TYP_INT ||
                tree->gtType == TYP_NAT_INT ||
                tree->gtType == TYP_REF ||
                tree->gtType == TYP_BYREF || tree->gtOper == GT_CAST ||
                                             tree->gtOper == GT_LIST  );

        i1 = op1->gtIntCon.gtIconVal;
        i2 = op2->gtIntCon.gtIconVal;

        switch (tree->gtOper)
        {
        case GT_EQ : i1 = (i1 == i2); break;
        case GT_NE : i1 = (i1 != i2); break;

        case GT_LT :
            if (tree->gtFlags & GTF_UNSIGNED)
                i1 = ((unsigned)i1 <  (unsigned)i2);
            else
                i1 = (i1 <  i2);
            break;

        case GT_LE :
            if (tree->gtFlags & GTF_UNSIGNED)
                i1 = ((unsigned)i1 <=  (unsigned)i2);
            else
                i1 = (i1 <=  i2);
            break;

        case GT_GE :
            if (tree->gtFlags & GTF_UNSIGNED)
                i1 = ((unsigned)i1 >=  (unsigned)i2);
            else
                i1 = (i1 >=  i2);
            break;

        case GT_GT :
            if (tree->gtFlags & GTF_UNSIGNED)
                i1 = ((unsigned)i1  >  (unsigned)i2);
            else
                i1 = (i1  >  i2);
            break;

        case GT_ADD:
            itemp = i1 + i2;
            if (tree->gtOverflow())
            {
                if (tree->gtFlags & GTF_UNSIGNED)
                {
                    if (((__int64)(unsigned)itemp) != ((__int64)(unsigned)i1 + (__int64)(unsigned)i2))
                        goto INT_OVF;
                }
                else
                    if (((__int64)itemp) != ((__int64)i1+(__int64)i2))  goto INT_OVF;
            }
            i1 = itemp; break;

        case GT_SUB:
            itemp = i1 - i2;
            if (tree->gtOverflow())
            {
                if (tree->gtFlags & GTF_UNSIGNED)
                {
                    if (((__int64)(unsigned)itemp) != ((__int64)(unsigned)i1 - (__int64)(unsigned)i2))
                        goto INT_OVF;
                }
                else
                    if (((__int64)itemp) != ((__int64)i1-(__int64)i2))  goto INT_OVF;
            }
            i1 = itemp; break;

        case GT_MUL:
            itemp = (unsigned long)i1 * (unsigned long)i2;
            if (tree->gtOverflow())
                if (((unsigned __int64)itemp) !=
                    ((unsigned __int64)i1*(unsigned __int64)i2))    goto INT_OVF;
            i1 = itemp; break;

        case GT_OR : i1 |= i2; break;
        case GT_XOR: i1 ^= i2; break;
        case GT_AND: i1 &= i2; break;

        case GT_LSH: i1 <<= (i2 & 0x1f); break;
        case GT_RSH: i1 >>= (i2 & 0x1f); break;
        case GT_RSZ:
                /* logical shift -> make it unsigned to propagate the sign bit */
                i1 = (unsigned)i1 >> (i2 & 0x1f);
            break;

        /* DIV and MOD can generate an INT 0 - if division by 0
         * or overflow - when dividing MIN by -1 */

            // @TODO: Convert into std exception throw
        case GT_DIV:
            if (!i2) return tree;
            if ((unsigned)i1 == 0x80000000 && i2 == -1)
            {
                /* In IL we have to throw an exception */
                return tree;
            }
            i1 /= i2; break;

        case GT_MOD:
            if (!i2) return tree;
            if ((unsigned)i1 == 0x80000000 && i2 == -1)
            {
                /* In IL we have to throw an exception */
                return tree;
            }
            i1 %= i2; break;

        case GT_UDIV:
            if (!i2) return tree;
            if ((unsigned)i1 == 0x80000000 && i2 == -1) return tree;
            i1 = (unsigned)i1 / (unsigned)i2; break;

        case GT_UMOD:
            if (!i2) return tree;
            if ((unsigned)i1 == 0x80000000 && i2 == -1) return tree;
            i1 = (unsigned)i1 % (unsigned)i2; break;

        case GT_CAST:
            assert (genActualType((var_types)i2) == tree->gtType);
            switch ((var_types)i2)
            {
            case TYP_BYTE:
                itemp = (__int32)(signed   __int8 )i1;
                if (tree->gtOverflow()) if (itemp != i1) goto INT_OVF;
                i1 = itemp; goto CNS_INT;

            case TYP_SHORT:
                itemp = (__int32)(         __int16)i1;
                if (tree->gtOverflow()) if (itemp != i1) goto INT_OVF;
                i1 = itemp; goto CNS_INT;

            case TYP_CHAR:
                itemp = (__int32)(unsigned __int16)i1;
                if (tree->gtOverflow())
                    if (itemp != i1) goto INT_OVF;
                i1 = itemp;
                goto CNS_INT;

            case TYP_BOOL:
            case TYP_UBYTE:
                itemp = (__int32)(unsigned __int8 )i1;
                if (tree->gtOverflow()) if (itemp != i1) goto INT_OVF;
                i1 = itemp; goto CNS_INT;

            case TYP_UINT:
                                if (!(tree->gtFlags & GTF_UNSIGNED) && tree->gtOverflow() && i1 < 0)
                                        goto INT_OVF;
                                goto CNS_INT;

            case TYP_INT:
                                if ((tree->gtFlags & GTF_UNSIGNED) && tree->gtOverflow() && i1 < 0)
                                        goto INT_OVF;
                                goto CNS_INT;

            case TYP_ULONG:
                                if (!(tree->gtFlags & GTF_UNSIGNED) && tree->gtOverflow() && i1 < 0)
                                {
                                        op1->ChangeOper(GT_CNS_LNG);    // need type of oper to be same as tree
                                    op1->gtType = TYP_LONG;
                                        // We don't care about the value as we are throwing an exception
                                        goto LNG_OVF;
                                }
                                // Fall through
            case TYP_LONG:
                                if (tree->gtFlags & GTF_UNSIGNED)
                                        lval1 = (unsigned __int64) (unsigned) i1;
                                else
                                        lval1 = (         __int64)i1;
                                goto CNS_LONG;

            case TYP_FLOAT:
                                if (tree->gtFlags & GTF_UNSIGNED)
                                        f1 = (float) (unsigned) i1;
                                else
                                        f1 = (float) i1;
                                goto CNS_FLOAT;

            case TYP_DOUBLE:
                                if (tree->gtFlags & GTF_UNSIGNED)
                                        d1 = (double) (unsigned) i1;
                                else
                                        d1 = (double) i1;
                                goto CNS_DOUBLE;

#ifdef  DEBUG
            default:
                assert(!"BAD_TYP");
#endif
            }
            break;

        default:
            return tree;
        }

        /* We get here after folding to a GT_CNS_INT type
         * bash the node to the new type / value and make sure the node sizes are OK */
CNS_INT:
FOLD_COND:
        /* Also all conditional folding jumps here since the node hanging from
         * GT_JTRUE has to be a GT_CNS_INT - value 0 or 1 */

        tree->ChangeOper          (GT_CNS_INT);
        tree->gtType             = TYP_INT;
        tree->gtIntCon.gtIconVal = i1;
        tree->gtFlags           &= GTF_PRESERVE;
        goto DONE;

        /* This operation is going to cause an overflow exception. Morph into
           an overflow helper. Put a dummy constant value for code generation.
           We could remove all subsequent trees in the current basic block,
           unless this node is a child of GT_COLON

           NOTE: Since the folded value is not constant we should not bash the
                 "tree" node - otherwise we confuse the logic that checks if the folding
                 was successful - instead use one of the operands, e.g. op1
         */

INT_FROM_LNG_OVF:
                op1->ChangeOper(GT_CNS_INT);    // need type of oper to be same as tree
                op1->gtType = TYP_INT;
INT_OVF:
                assert(op1->gtType == TYP_INT);
                goto OVF;
LNG_OVF:
                assert(op1->gtType == TYP_LONG);
                goto OVF;
OVF:
        /* We will bashed cast to a GT_COMMA and atach the exception helper as gtOp.gtOp1
         * the original constant expression becomes op2 */

        assert(tree->gtOverflow());
                assert(tree->gtOper == GT_CAST || tree->gtOper == GT_ADD ||
                           tree->gtOper == GT_SUB || tree->gtOper == GT_MUL);
        assert(op1 && op2);

        tree->ChangeOper(GT_COMMA);
                tree->gtOp.gtOp2 = op1;         // original expression becomes op2
        tree->gtOp.gtOp1 = gtNewHelperCallNode(CPX_ARITH_EXCPN, TYP_VOID, GTF_EXCEPT,
                                gtNewOperNode(GT_LIST, TYP_VOID, gtNewIconNode(compCurBB->bbTryIndex)));
        tree->gtFlags |= GTF_EXCEPT|GTF_CALL;


        /* We use FASTCALL so we have to morph the arguments in registers */
        fgMorphArgs(tree->gtOp.gtOp1);

        return tree;

    /*-------------------------------------------------------------------------
     * Fold constant REF of BYREF binary operator
     * These can only be comparissons or null pointers
     * Currently cannot have constant byrefs
     */

    case TYP_REF:

        /* String nodes are an RVA at this point */

        if (op1->gtOper == GT_CNS_STR || op2->gtOper == GT_CNS_STR)
            return tree;

        i1 = op1->gtIntCon.gtIconVal;
        i2 = op2->gtIntCon.gtIconVal;

        assert(i1 == 0);

        switch (tree->gtOper)
        {
        case GT_EQ : i1 = 1; goto FOLD_COND;
        case GT_NE : i1 = 0; goto FOLD_COND;

        /* For the null pointer case simply keep the null pointer */

        case GT_ADD:
            tree->ChangeOper(GT_CNS_INT);
            tree->gtType = TYP_REF;
            tree->gtIntCon.gtIconVal = i1;
            tree->gtFlags           &= GTF_PRESERVE;
            goto DONE;

        default:
            assert(!"Illegal operation on TYP_REF");
            return tree;
        }

    case TYP_BYREF:
        assert(!"Can we have constants of TYP_BYREF?");
        return tree;

    /*-------------------------------------------------------------------------
     * Fold constant LONG binary operator
     */

    case TYP_LONG:

        lval1 = op1->gtLngCon.gtLconVal;

        if (tree->gtOper == GT_CAST ||
            tree->gtOper == GT_LSH  ||
            tree->gtOper == GT_RSH  ||
            tree->gtOper == GT_RSZ   )
        {
            /* second operand is an INT */
            assert (op2->gtType == TYP_INT);
            i2 = op2->gtIntCon.gtIconVal;
        }
        else
        {
            /* second operand must be a LONG */
            assert (op2->gtType == TYP_LONG);
            lval2 = op2->gtLngCon.gtLconVal;
        }

        switch (tree->gtOper)
        {
        case GT_EQ : i1 = (lval1 == lval2); goto FOLD_COND;
        case GT_NE : i1 = (lval1 != lval2); goto FOLD_COND;

        case GT_LT :
            if (tree->gtFlags & GTF_UNSIGNED)
                i1 = ((unsigned __int64)lval1 <  (unsigned __int64)lval2);
            else
                i1 = (lval1 <  lval2);
            goto FOLD_COND;

        case GT_LE :
            if (tree->gtFlags & GTF_UNSIGNED)
                i1 = ((unsigned __int64)lval1 <=  (unsigned __int64)lval2);
            else
                i1 = (lval1 <=  lval2);
            goto FOLD_COND;

        case GT_GE :
            if (tree->gtFlags & GTF_UNSIGNED)
                i1 = ((unsigned __int64)lval1 >=  (unsigned __int64)lval2);
            else
                i1 = (lval1 >=  lval2);
            goto FOLD_COND;

        case GT_GT :
            if (tree->gtFlags & GTF_UNSIGNED)
                i1 = ((unsigned __int64)lval1  >  (unsigned __int64)lval2);
            else
                i1 = (lval1  >  lval2);
            goto FOLD_COND;

        case GT_ADD:
            ltemp = lval1 + lval2;

LNG_ADD_CHKOVF:
            /* For the SIGNED case - If there is one positive and one negative operand, there can be no overflow
             * If both are positive, the result has to be positive, and similary for negatives.
             *
             * For the UNSIGNED case - If an (unsigned) operand is bigger than the result then OVF */

            if (tree->gtOverflow())
            {
                if (tree->gtFlags & GTF_UNSIGNED)
                {
                    if ( ((unsigned __int64)lval1 > (unsigned __int64)ltemp) ||
                         ((unsigned __int64)lval2 > (unsigned __int64)ltemp)  )
                        goto LNG_OVF;
                }
                else
                    if ( ((lval1<0) == (lval2<0)) && ((lval1<0) != (ltemp<0)) )
                        goto LNG_OVF;
            }
            lval1 = ltemp; break;

        case GT_SUB:
            ltemp = lval1 - lval2;
            // If both operands are positive or both are negative, there can be no overflow
            // Else use the logic for : lval1 + (-lval2)
            if (tree->gtOverflow() && ((lval1<0) != (lval2<0)))
            {
                if (lval2 == INT_MIN) goto LNG_OVF;
                lval2 = -lval2; goto LNG_ADD_CHKOVF;
            }
            lval1 = ltemp; break;

        case GT_MUL:
            ltemp = lval1 * lval2;
            if (tree->gtOverflow())
                if ((ltemp != 0) && ((ltemp/lval2) != lval1)) goto LNG_OVF;
            lval1 = ltemp; break;

        case GT_OR : lval1 |= lval2; break;
        case GT_XOR: lval1 ^= lval2; break;
        case GT_AND: lval1 &= lval2; break;

        case GT_LSH: lval1 <<= (i2 & 0x3f); break;
        case GT_RSH: lval1 >>= (i2 & 0x3f); break;
        case GT_RSZ:
                /* logical shift -> make it unsigned to propagate the sign bit */
                lval1 = (unsigned __int64)lval1 >> (i2 & 0x3f);
            break;

        case GT_DIV:
            if (!lval2) return tree;
            if ((unsigned __int64)lval1 == 0x8000000000000000 && lval2 == (__int64)-1)
            {
                /* In IL we have to throw an exception */
                return tree;
            }
            lval1 /= lval2; break;

        case GT_MOD:
            if (!lval2) return tree;
            if ((unsigned __int64)lval1 == 0x8000000000000000 && lval2 == (__int64)-1)
            {
                /* In IL we have to throw an exception */
                return tree;
            }
            lval1 %= lval2; break;

        case GT_UDIV:
            if (!lval2) return tree;
            if ((unsigned __int64)lval1 == 0x8000000000000000 && lval2 == (__int64)-1) return tree;
            lval1 = (unsigned __int64)lval1 / (unsigned __int64)lval2; break;

        case GT_UMOD:
            if (!lval2) return tree;
            if ((unsigned __int64)lval1 == 0x8000000000000000 && lval2 == (__int64)-1) return tree;
            lval1 = (unsigned __int64)lval1 % (unsigned __int64)lval2; break;

        case GT_CAST:
            assert (genActualType((var_types)i2) == tree->gtType);
            switch ((var_types)i2)
            {
            case TYP_BYTE:
                i1 = (__int32)(signed   __int8 )lval1;
                                goto CHECK_INT_OVERFLOW;

            case TYP_SHORT:
                i1 = (__int32)(         __int16)lval1;
                                goto CHECK_INT_OVERFLOW;

            case TYP_CHAR:
                i1 = (__int32)(unsigned __int16)lval1;
                                goto CHECK_UINT_OVERFLOW;

            case TYP_UBYTE:
                i1 = (__int32)(unsigned __int8 )lval1;
                                goto CHECK_UINT_OVERFLOW;

            case TYP_INT:
                i1 =                   (__int32)lval1;

                        CHECK_INT_OVERFLOW:
                if (tree->gtOverflow())
                                {
                                        if (i1 != lval1)
                                                goto INT_FROM_LNG_OVF;
                                        if ((tree->gtFlags & GTF_UNSIGNED) && i1 < 0)
                                                goto INT_FROM_LNG_OVF;
                                }
               goto CNS_INT;

            case TYP_UINT:
               i1 =           (unsigned __int32)lval1;

                        CHECK_UINT_OVERFLOW:
                           if (tree->gtOverflow() && (unsigned) i1 != lval1)
                                   goto INT_FROM_LNG_OVF;
               goto CNS_INT;

            case TYP_ULONG:
               if (!(tree->gtFlags & GTF_UNSIGNED) && tree->gtOverflow() && lval1 < 0)
                                        goto LNG_OVF;
               goto CNS_INT;

            case TYP_LONG:
                if ((tree->gtFlags & GTF_UNSIGNED) && tree->gtOverflow() && lval1 < 0)
                                        goto LNG_OVF;
                                goto CNS_INT;

            case TYP_FLOAT:
                f1 = (float) lval1;
                        // VC does not have unsigned convert to float, so we
                        // implement it by adding 2^64 if the number is negative
                if ((tree->gtFlags & GTF_UNSIGNED) && lval1 < 0)
                        f1 +=  4294967296.0 * 4294967296.0;
                goto CNS_FLOAT;

                        case TYP_DOUBLE:
                        // VC does not have unsigned convert to double, so we
                        // implement it by adding 2^64 if the number is negative
                d1 = (double) lval1;
                if ((tree->gtFlags & GTF_UNSIGNED) && lval1 < 0)
                        d1 +=  4294967296.0 * 4294967296.0;
                goto CNS_DOUBLE;
#ifdef  DEBUG
            default:
                assert(!"BAD_TYP");
#endif
            }
            break;

        default:
            return tree;
        }

CNS_LONG:
        assert ((GenTree::s_gtNodeSizes[GT_CNS_LNG] == TREE_NODE_SZ_SMALL) ||
                (tree->gtFlags & GTF_NODE_LARGE)                            );

        tree->ChangeOper(GT_CNS_LNG);
        tree->gtLngCon.gtLconVal = lval1;
        tree->gtFlags           &= GTF_PRESERVE;
        goto DONE;

    /*-------------------------------------------------------------------------
     * Fold constant FLOAT binary operator
     */

    case TYP_FLOAT:

        // @TODO: Add these cases
        if (tree->gtOverflowEx()) return tree;

        f1 = op1->gtFltCon.gtFconVal;

        if (tree->gtOper == GT_CAST)
        {
            /* If not finite don't bother */
            if (!_finite(f1)) return tree;

            /* second operand is an INT */
            assert (op2->gtType == TYP_INT);
            i2 = op2->gtIntCon.gtIconVal;
        }
        else
        {
            /* second operand must be a FLOAT */
            assert (op2->gtType == TYP_FLOAT);
            f2 = op2->gtFltCon.gtFconVal;

            /* Special case - check if we have NaN operands
             * For comparissons if not an unordered operation always return 0
             * For unordered operations (i.e the GTF_CMP_NAN_UN flag is set)
             * the result is always true - return 1 */

            if (_isnan(f1) || _isnan(f2))
            {
#ifdef  DEBUG
                if  (verbose)
                    printf("Float operator(s) is NaN\n");
#endif
                if (tree->OperKind() & GTK_RELOP)
                    if (tree->gtFlags & GTF_CMP_NAN_UN)
                    {
                        /* Unordered comparisson with NaN always succeeds */
                        i1 = 1; goto FOLD_COND;
                    }
                    else
                    {
                        /* Normal comparisson with NaN always fails */
                        i1 = 0; goto FOLD_COND;
                    }
            }
        }

        switch (tree->gtOper)
        {
        case GT_EQ : i1 = (f1 == f2); goto FOLD_COND;
        case GT_NE : i1 = (f1 != f2); goto FOLD_COND;

        case GT_LT : i1 = (f1 <  f2); goto FOLD_COND;
        case GT_LE : i1 = (f1 <= f2); goto FOLD_COND;
        case GT_GE : i1 = (f1 >= f2); goto FOLD_COND;
        case GT_GT : i1 = (f1 >  f2); goto FOLD_COND;

        case GT_ADD: f1 += f2; break;
        case GT_SUB: f1 -= f2; break;
        case GT_MUL: f1 *= f2; break;

        case GT_DIV: if (!f2) return tree;
                     f1 /= f2; break;

        case GT_CAST:
            assert (genActualType((var_types)i2) == tree->gtType);
            switch ((var_types)i2)
            {
            case TYP_BYTE:
                i1 = (__int32)(signed   __int8 )f1; goto CNS_INT;

            case TYP_SHORT:
                i1 = (__int32)(         __int16)f1; goto CNS_INT;

            case TYP_CHAR:
                i1 = (__int32)(unsigned __int16)f1; goto CNS_INT;

            case TYP_UBYTE:
                i1 = (__int32)(unsigned __int8 )f1; goto CNS_INT;

            case TYP_INT:
                i1 =                   (__int32)f1; goto CNS_INT;

            case TYP_UINT:
                i1 =          (unsigned __int32)f1; goto CNS_INT;

            case TYP_LONG:
                lval1 =                (__int64)f1; goto CNS_LONG;

            case TYP_ULONG:
                lval1 =       (unsigned __int64)f1; goto CNS_LONG;

            case TYP_FLOAT:                         goto CNS_FLOAT;  // redundant cast

            case TYP_DOUBLE:  d1 =     (double )f1; goto CNS_DOUBLE;

#ifdef  DEBUG
            default:
                assert(!"BAD_TYP");
#endif
            }
            break;

        default:
            return tree;
        }

CNS_FLOAT:
        assert ((GenTree::s_gtNodeSizes[GT_CNS_FLT] == TREE_NODE_SZ_SMALL) ||
                (tree->gtFlags & GTF_NODE_LARGE)                            );

        tree->ChangeOper(GT_CNS_FLT);
        tree->gtFltCon.gtFconVal = f1;
        tree->gtFlags           &= GTF_PRESERVE;
        goto DONE;

    /*-------------------------------------------------------------------------
     * Fold constant DOUBLE binary operator
     */

    case TYP_DOUBLE:

        // @TODO: Add these cases
        if (tree->gtOverflowEx()) return tree;

        d1 = op1->gtDblCon.gtDconVal;

        if (tree->gtOper == GT_CAST)
        {
            /* If not finit don't bother */
            if (!_finite(d1)) return tree;

            /* second operand is an INT */
            assert (op2->gtType == TYP_INT);
            i2 = op2->gtIntCon.gtIconVal;
        }
        else
        {
            /* second operand must be a DOUBLE */
            assert (op2->gtType == TYP_DOUBLE);
            d2 = op2->gtDblCon.gtDconVal;

            /* Special case - check if we have NaN operands
             * For comparissons if not an unordered operation always return 0
             * For unordered operations (i.e the GTF_CMP_NAN_UN flag is set)
             * the result is always true - return 1 */

            if (_isnan(d1) || _isnan(d2))
            {
#ifdef  DEBUG
                if  (verbose)
                    printf("Double operator(s) is NaN\n");
#endif
                if (tree->OperKind() & GTK_RELOP)
                    if (tree->gtFlags & GTF_CMP_NAN_UN)
                    {
                        /* Unordered comparisson with NaN always succeeds */
                        i1 = 1; goto FOLD_COND;
                    }
                    else
                    {
                        /* Normal comparisson with NaN always fails */
                        i1 = 0; goto FOLD_COND;
                    }
            }
        }

        switch (tree->gtOper)
        {
        case GT_EQ : i1 = (d1 == d2); goto FOLD_COND;
        case GT_NE : i1 = (d1 != d2); goto FOLD_COND;

        case GT_LT : i1 = (d1 <  d2); goto FOLD_COND;
        case GT_LE : i1 = (d1 <= d2); goto FOLD_COND;
        case GT_GE : i1 = (d1 >= d2); goto FOLD_COND;
        case GT_GT : i1 = (d1 >  d2); goto FOLD_COND;

        case GT_ADD: d1 += d2; break;
        case GT_SUB: d1 -= d2; break;
        case GT_MUL: d1 *= d2; break;

        case GT_DIV: if (!d2) return tree;
                     d1 /= d2; break;

        case GT_CAST:
            assert (genActualType((var_types)i2) == tree->gtType);
            switch ((var_types)i2)
            {
            case TYP_BYTE:
                i1 = (__int32)(signed   __int8 )d1; goto CNS_INT;

            case TYP_SHORT:
                i1 = (__int32)(         __int16)d1; goto CNS_INT;

            case TYP_CHAR:
                i1 = (__int32)(unsigned __int16)d1; goto CNS_INT;

            case TYP_UBYTE:
                i1 = (__int32)(unsigned __int8 )d1; goto CNS_INT;

            case TYP_INT:
                i1 =                   (__int32)d1; goto CNS_INT;

            case TYP_UINT:
                i1 =          (unsigned __int32)d1; goto CNS_INT;

            case TYP_LONG:
                lval1 =                (__int64)d1; goto CNS_LONG;

            case TYP_ULONG:
                lval1 =       (unsigned __int64)d1; goto CNS_LONG;

            case TYP_FLOAT:   f1 =      (float )d1; goto CNS_FLOAT;

            case TYP_DOUBLE:                        goto CNS_DOUBLE; // redundant cast

#ifdef  DEBUG
            default:
                assert(!"BAD_TYP");
#endif
            }
            break;

        default:
            return tree;
        }

CNS_DOUBLE:
        assert ((GenTree::s_gtNodeSizes[GT_CNS_DBL] == TREE_NODE_SZ_SMALL) ||
                (tree->gtFlags & GTF_NODE_LARGE)                            );

        tree->ChangeOper(GT_CNS_DBL);
        tree->gtDblCon.gtDconVal = d1;
        tree->gtFlags           &= GTF_PRESERVE;
        goto DONE;

    default:
        /* not a foldable typ */
        return tree;
    }

    //-------------------------------------------------------------------------

DONE:

    /* Make sure no side effect flags are set on this constant node */

    //assert(~(gtFlags & GTF_SIDE_EFFECT));

    //if (gtFlags & GTF_SIDE_EFFECT)
//        assert(!"Found side effect");

    tree->gtFlags &= ~GTF_SIDE_EFFECT;

    return tree;
}

/*****************************************************************************
 *
 *  Create an assignment of the given value to a temp.
 */

GenTreePtr          Compiler::gtNewTempAssign(unsigned tmp, GenTreePtr val)
{
    GenTreePtr      dst;
    var_types       typ = genActualType(val->gtType);

    /* Create the temp target reference node */

    dst = gtNewLclvNode(tmp, typ); dst->gtFlags |= GTF_VAR_DEF;

    /* Create the assignment node */

    dst = gtNewOperNode(GT_ASG, typ, dst, val);

    /* Mark the expression as containing an assignment */

    dst->gtFlags |= GTF_ASG;

    return  dst;
}

/*****************************************************************************
 *
 *  If the field is a NStruct field of a simple type, then we can directly
 *  access it without using a helper call.
 *  This function returns NULL if the field is not a simple NStruct field
 *  Else it will create a tree to do the field access and return it.
 *  "assg" is 0 for ldfld, and the value to assign for stfld.
 */

GenTreePtr          Compiler::gtNewDirectNStructField (GenTreePtr   objPtr,
                                                       unsigned     fldIndex,
                                                       var_types    lclTyp,
                                                       GenTreePtr   assg)
{
    FIELD_HANDLE        fldHnd = eeFindField(fldIndex, info.compScopeHnd, 0);
    JIT_FIELDCATEGORY   fldNdc;

#ifdef NOT_JITC
    fldNdc = info.compCompHnd->getFieldCategory(fldHnd);
#else
    fldNdc = JIT_FIELDCATEGORY_UNKNOWN;
#endif

    /* Check if it is a simple type. If so, map it to "var_types" */

    var_types           type;

    switch(fldNdc)
    {
    // Most simple types - exact match

    case JIT_FIELDCATEGORY_I1_I1        : type = TYP_BYTE;      break;
    case JIT_FIELDCATEGORY_I2_I2        : type = TYP_SHORT;     break;
    case JIT_FIELDCATEGORY_I4_I4        : type = TYP_INT;       break;
    case JIT_FIELDCATEGORY_I8_I8        : type = TYP_LONG;      break;

    // These will need some extra work

    case JIT_FIELDCATEGORY_BOOLEAN_BOOL : type = TYP_BYTE;      break;
    case JIT_FIELDCATEGORY_CHAR_CHAR    : type = TYP_UBYTE;     break;

    // Others

    default     : //assert(fldNdc == JIT_FIELDCATEGORY_NORMAL ||
                  //       fldNdc == JIT_FIELDCATEGORY_UNKNOWN);

                                          type = TYP_UNDEF;     break;
    }

    if (type == TYP_UNDEF)
    {
        /* If the field is not NStruct (must be a COM object), or if it is
         * not of a simple type, we will simply use a helper call to
         * access it. So just return NULL
         */

        return NULL;
    }

    NO_WAY(!"I thought NStruct is now defunct?");

    /* Create the following tree :
     * GT_IND( GT_IND(obj + INDIR_OFFSET) + nativeFldOffs )
     */

    GenTreePtr      tree;

    /* Get the offset of the field in the real native struct */

    unsigned        fldOffs = eeGetFieldOffset(fldHnd);

    /* Get the real ptr from the proxy object */

    tree = gtNewOperNode(GT_ADD, TYP_REF,
                        objPtr,
                        gtNewIconNode(Info::compNStructIndirOffset));

    tree = gtNewOperNode(GT_IND, TYP_I_IMPL, tree);
    tree->gtFlags |= GTF_EXCEPT;

    /* Access the field using the real ptr */

    tree = gtNewOperNode(GT_ADD, TYP_I_IMPL,
                        tree,
                        gtNewIconNode(fldOffs));
    tree->gtFlags |= GTF_NON_GC_ADDR;

        /* Check that we used the right suffix (ie, the XX in ldfld.XX)
           to access the field */

    assert(genActualType(lclTyp) == genActualType(type));

    tree = gtNewOperNode(GT_IND, type, tree);

    /* Morph tree for some of the categories, and
       create the assignment node if needed */

    if (assg)
    {
        if (fldNdc == JIT_FIELDCATEGORY_BOOLEAN_BOOL)
        {
            // Need to noramlize the "bool"

            assg = gtNewOperNode(GT_NE, TYP_INT, assg, gtNewIconNode(0));
        }

        tree = gtNewAssignNode(tree, assg);
    }
    else
    {
        if (fldNdc == JIT_FIELDCATEGORY_BOOLEAN_BOOL)
        {
            // Need to noramlize the "bool"

            tree = gtNewOperNode(GT_NE, TYP_INT, tree, gtNewIconNode(0));
        }

        /* Dont need to do anything for JIT_FIELDCATEGORY_CHAR_CHAR, as
           we set the type to TYP_UBYTE, so it will be automatically
           expanded to 16/32 bits as needed.
         */
    }

    return tree;
}

/*****************************************************************************
 *
 *  Create a helper call to access a COM field (iff 'assg' is non-zero this is
 *  an assignment and 'assg' is the new value).
 */

GenTreePtr          Compiler::gtNewRefCOMfield(GenTreePtr   objPtr,
                                               unsigned     fldIndex,
                                               var_types    lclTyp,
                                               GenTreePtr   assg)
{
    /* See if we can directly access the NStruct field */

    GenTreePtr      ntree = gtNewDirectNStructField(objPtr,
                                                    fldIndex,
                                                    lclTyp,
                                                    assg);
    if (ntree)
        return ntree;

    /* If we cant access it directly, we need to call a helper function */

    GenTreePtr      args;
    int             CPX;

    if  (assg)
    {
        if      (genTypeSize(lclTyp) == sizeof(double))
            CPX = CPX_PUTFIELD64;
        else if (lclTyp == TYP_REF)
            CPX = CPX_PUTFIELDOBJ;
        else if (varTypeIsGC(lclTyp))
        {
            NO_WAY("stfld: fields cannot be byrefs");
        }
        else
            CPX = CPX_PUTFIELD32;

        args = gtNewOperNode(GT_LIST, TYP_VOID, assg, 0);

        /* The assignment call doesn't return a value */

        lclTyp = TYP_VOID;
    }
    else
    {
        if      (genTypeSize(lclTyp) == sizeof(double))
        {
            CPX = CPX_GETFIELD64;
        }
        else if (lclTyp == TYP_REF)
            CPX = CPX_GETFIELDOBJ;
        else if (varTypeIsGC(lclTyp))
        {
            NO_WAY("ldfld: fields cannot be byrefs");
        }
        else
        {
            CPX = CPX_GETFIELD32;
        }

        args = 0;
    }

    FIELD_HANDLE memberHandle = eeFindField(fldIndex, info.compScopeHnd, 0);

    args = gtNewOperNode(GT_LIST,
                         TYP_VOID,
                         gtNewIconEmbFldHndNode(memberHandle,
                                                fldIndex,
                                                info.compScopeHnd),
                         args);

    args = gtNewOperNode(GT_LIST, TYP_VOID, objPtr, args);

    return  gtNewHelperCallNode(CPX,
                                genActualType(lclTyp),
                                GTF_CALL_REGSAVE,
                                args);
}

/*****************************************************************************
/* creates a GT_COPYBLK which copies a block from 'src' to 'dest'.  'blkShape'
   is either a size or a class handle (GTF_ICON_CLASS_HDL bit tells which)  */

GenTreePtr Compiler::gtNewCpblkNode(GenTreePtr dest, GenTreePtr src, GenTreePtr blkShape)
{
    GenTreePtr op1;

    assert(genActualType(dest->gtType) == TYP_I_IMPL || dest->gtType  == TYP_BYREF);
    assert(genActualType( src->gtType) == TYP_I_IMPL ||  src->gtType  == TYP_BYREF);
#if TGT_IA64
    assert(genActualType(blkShape->gtType) == TYP_LONG);
#else
    assert(genActualType(blkShape->gtType) == TYP_INT);
#endif

    op1 = gtNewOperNode(GT_LIST,    TYP_VOID,   //      GT_COPYBLK
                        dest,        src);      //      /        \.
    op1 = gtNewOperNode(GT_COPYBLK, TYP_VOID,   // GT_LIST(op2)  [size/clsHnd]
                        op1,      blkShape);    //   /    \
                                                // [dest] [src]
    op1->gtFlags |= (GTF_EXCEPT | GTF_GLOB_REF);
    return(op1);
}

/*****************************************************************************
 *
 *  Return true if the given expression contains side effects.
 */

bool                Compiler::gtHasSideEffects(GenTreePtr tree)
{
    if  (tree->OperKind() & GTK_ASGOP)
        return  true;

    if  (tree->gtFlags & GTF_OTHER_SIDEEFF)
        return  true;

    switch (tree->gtOper)
    {
    case GT_CALL:

        /* Some helper calls are not side effects */

        if  (tree->gtCall.gtCallType == CT_HELPER)
        {
            if (tree->gtCall.gtCallMethHnd == eeFindHelper(CPX_ARRADDR_ST))
            {
            }
            else if (tree->gtCall.gtCallMethHnd == eeFindHelper(CPX_LONG_DIV) ||
                     tree->gtCall.gtCallMethHnd == eeFindHelper(CPX_LONG_MOD))
            {
                /* This is not a side effect if RHS is always non-zero */

                tree = tree->gtCall.gtCallArgs;
                assert(tree->gtOper == GT_LIST);
                tree = tree->gtOp.gtOp1;

                if  (tree->gtOper == GT_CNS_LNG && tree->gtLngCon.gtLconVal)
                    return  false;
            }
            else
                // ISSUE: Any other helpers may contain side effects?
                return  false;
        }

//      printf("Call with side effects:\n"); dsc->lpoCmp->gtDispTree(tree); printf("\n\n");

        return true;

    case GT_IND:

        // CONSIDER: If known to be non-null, it's not a side effect

        return  true;

    case GT_DIV:
    case GT_MOD:
    case GT_UDIV:
    case GT_UMOD:

        tree = tree->gtOp.gtOp2;

        if  (tree->gtOper == GT_CNS_INT && tree->gtIntCon.gtIconVal)
            return  false;
        if  (tree->gtOper == GT_CNS_LNG && tree->gtLngCon.gtLconVal)
            return  false;

        return true;
    }

    return  false;
}


/*****************************************************************************
 *
 *  Extracts side effects from the given expression
 *  and appends them to a given list (actually a GT_COMMA list)
 */

void                Compiler::gtExtractSideEffList(GenTreePtr expr, GenTreePtr * list)
{
    assert(expr); assert(expr->gtOper != GT_STMT);

    /* If no side effect in the expression return */

    if (!(expr->gtFlags & GTF_SIDE_EFFECT))
        return;

    genTreeOps      oper = expr->OperGet();
    unsigned        kind = expr->OperKind();
    GenTreePtr      op1  = expr->gtOp.gtOp1;
    GenTreePtr      op2  = expr->gtOp.gtOp2;

    /* NOTE - It may be that an indirection has the GTF_EXCEPT flag cleared so no side effect
     *      - What about range checks - are they marked as GTF_EXCEPT?
     * UNDONE: For removed range checks do not extract them
     */

    /* Look for side effects
     *  - Any assignment, GT_CALL, or operator that may throw
     *    (GT_IND, GT_DIV, GTF_OVERFLOW, etc)
     *  - Special case GT_ADDR which is a side effect */

    if ((kind & GTK_ASGOP) ||
        oper == GT_CALL    || oper == GT_BB_QMARK || oper == GT_BB_COLON ||
        expr->OperMayThrow())
    {
        /* Add the side effect to the list and return */

        *list = (*list == 0) ? expr : gtNewOperNode(GT_COMMA, TYP_VOID, expr, *list);

#ifdef  DEBUG
        if  (verbose && 0)
        {
            printf("Adding extracted side effects to the list:\n");
            gtDispTree(expr);
            printf("\n");
        }

#endif

        return;
    }

    if (kind & GTK_LEAF)
        return;

    assert(kind & GTK_SMPOP);

    /* @MIHAII - Special case - GT_ADDR of GT_IND nodes of TYP_STRUCT
     * have to be kept together
     * CONSIDER: - This is a hack, remove after we fold this special construct */

    if (oper == GT_ADDR)
    {
        assert(op1);
        if (op1->gtOper == GT_IND && op1->gtType == TYP_STRUCT)
        {
            *list = (*list == 0) ? expr : gtNewOperNode(GT_COMMA, TYP_VOID, expr, *list);

#ifdef  DEBUG
            if  (verbose)
                printf("Keep the GT_ADDR and GT_IND together:\n");
#endif
        }
        return;
    }

    /* Continue searching for side effects in the subtrees of the expression
     * NOTE: Be careful to preserve the right ordering - side effects are prepended
     * to the list */

    if (op2) gtExtractSideEffList(op2, list);
    if (op1) gtExtractSideEffList(op1, list);

#ifdef DEBUG
    /* Just to make sure side effects were not swapped */

    if (expr->gtFlags & GTF_REVERSE_OPS)
    {
        assert(op1 && op2);
        if (op1->gtFlags & GTF_SIDE_EFFECT)
            assert(!(op2->gtFlags & GTF_SIDE_EFFECT));
    }
#endif
}


/*****************************************************************************/

#if CSELENGTH

struct  treeRmvDsc
{
    GenTreePtr          trFirst;
#ifndef NDEBUG
    void    *           trSelf;
    Compiler*           trComp;
#endif
    unsigned            trPhase;
};

int                 Compiler::fgRemoveExprCB(GenTreePtr     tree,
                                             void         * p)
{
    treeRmvDsc  *   desc = (treeRmvDsc*)p;

    Assert(desc && desc->trSelf == desc, desc->trComp);

    if  (desc->trPhase == 1)
    {
        /* In the first  phase we mark all the nodes as dead */

        Assert((tree->gtFlags &  GTF_DEAD) == 0, desc->trComp);
                tree->gtFlags |= GTF_DEAD;
    }
    else
    {
        /* In the second phase we notice the first node */

        if  (!tree->gtPrev || !(tree->gtPrev->gtFlags & GTF_DEAD))
        {
            /* We've found the first node in the subtree */

            desc->trFirst = tree;

            return  -1;
        }
    }

    return  0;
}

/*****************************************************************************
 *
 *  For debugging only - displays a tree node list and makes sure all the
 *  links are correctly set.
 */

#ifdef  DEBUG

void                dispNodeList(GenTreePtr list, bool verbose)
{
    GenTreePtr      last = 0;
    GenTreePtr      next;

    if  (!list)
        return;

    for (;;)
    {
        next = list->gtNext;

        if  (verbose)
            printf("%08X -> %08X -> %08X\n", last, list, next);

        assert(!last || last->gtNext == list);

        assert(next == 0 || next->gtPrev == list);

        if  (!next)
            break;

        last = list;
        list = next;
    }

    fflush(stdout);
}

#endif

/*****************************************************************************
 *
 *  Given a subtree and the head of the tree node list that contains it,
 *  remove all the nodes in the subtree from the list.
 *
 *  When 'dead' is non-zero on entry, all the nodes in the subtree have
 *  already been marked with GTF_DEAD.
 */

void                Compiler::fgRemoveSubTree(GenTreePtr    tree,
                                              GenTreePtr    list,
                                              bool          dead)
{
    GenTreePtr      opr1;
    GenTreePtr      next;
    GenTreePtr      prev;

    assert(list && list->gtOper == GT_STMT);

#if 0
    printf("Remove subtree %08X from:\n", tree);
    gtDispTree(list);
    printf("\n");
    dispNodeList(list->gtStmt.gtStmtList, true);
    printf("\n\n");
#endif

    /* Are we just removing a leaf node? */

    if  (tree->OperIsLeaf())
    {
        opr1 = tree;
        goto RMV;
    }

    /* Special easy case: unary operator with a leaf sub-operand */

    if  (tree->OperKind() & GTK_SMPOP)
    {
        opr1 = tree->gtOp.gtOp1;

        if  (!tree->gtOp.gtOp2 && opr1->OperIsLeaf())
        {
            /* This is easy: the order is simply "prev -> opr1 -> tree -> next */

            assert(opr1->gtNext == tree);
            assert(tree->gtPrev == opr1);

            goto RMV;
        }
    }
    treeRmvDsc      desc;

    /* This is a non-trivial subtree, we'll remove it "the hard way" */

#ifndef NDEBUG
    desc.trFirst = 0;
    desc.trSelf  = &desc;
    desc.trComp  = this;
#endif

    /* First  phase: mark the nodes in the subtree as dead */

    if  (!dead)
    {
        desc.trPhase = 1;
        fgWalkTree(tree, fgRemoveExprCB, &desc);
    }

    /* Second phase: find the first node of the subtree within the global list */

    desc.trPhase = 2;
    fgWalkTree(tree, fgRemoveExprCB, &desc);

    /* The second phase should have located the first node */

    opr1 = desc.trFirst; assert(opr1);

RMV:

    /* At this point, our subtree starts at "opr1" and ends at "tree" */

    next = tree->gtNext;
    prev = opr1->gtPrev;

    /* Set the next node's prev field */

    next->gtPrev = prev;

    /* Is "opr1" the very first node in the tree list? */

    if  (prev == NULL)
    {
        /* Make sure the list indeed starts at opr1 */

        assert(list->gtStmt.gtStmtList == opr1);

        /* We have a new start for the list */

        list->gtStmt.gtStmtList = next;
    }
    else
    {
        /* Not the first node, update the previous node's next field */

        opr1->gtPrev->gtNext = next;
    }

#if 0
    printf("Subtree is gone:\n");
    dispNodeList(list%08X->gtStmt.gtStmtList, true);
    printf("\n\n\n");
#endif

}

#endif

/*
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          BasicBlock                                       XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


#if     MEASURE_BLOCK_SIZE
/* static  */
size_t              BasicBlock::s_Size;
/* static */
size_t              BasicBlock::s_Count;
#endif

#ifdef DEBUG
 // The max # of tree nodes in any BB
/* static */
unsigned            BasicBlock::s_nMaxTrees;
#endif


/*****************************************************************************
 *
 *  Allocate a basic block but don't append it to the current BB list.
 */

BasicBlock *        Compiler::bbNewBasicBlock(BBjumpKinds jumpKind)
{
    BasicBlock *    block;

    /* Allocate the block descriptor and zero it out */

    block = (BasicBlock *) compGetMem(sizeof(*block));

#if     MEASURE_BLOCK_SIZE
    BasicBlock::s_Count  += 1;
    BasicBlock::s_Size += sizeof(*block);
#endif

    // ISSUE: The following memset is pretty expensive - do something else?

    memset(block, 0, sizeof(*block));

    // scopeInfo needs to be able to differentiate between blocks which
    // correspond to some IL opcodes (and so may have some LocalVarInfo
    // boundaries), or have been inserted by the JIT
    // block->bbCodeSize = 0; // The above memset() does this

    /* Give the block a number, set the ancestor count and weight to 1 */

    block->bbNum      = ++fgBBcount;
    block->bbRefs     = 1;
    block->bbWeight   = 1;

    block->bbStkTemps = NO_BASE_TMP;

    /* Record the jump kind in the block */

    block->bbJumpKind = jumpKind;

    return block;
}


/*****************************************************************************
 *
 *  Find an unconditional jump block that follows the given one; if one isn't
 *  found, return 0.
 */

BasicBlock  *       BasicBlock::FindJump(bool allowThrow)
{
    BasicBlock *block = this;

    while   (block)
    {
        switch (block->bbJumpKind)
        {
        case BBJ_THROW:
            if  (!allowThrow) break;
            // fall through
        case BBJ_RET:
        case BBJ_RETURN:
        case BBJ_ALWAYS:

            /* Do not insert in front of catch handler */

            if  (block->bbNext && block->bbNext->bbCatchTyp)
                break;

            return  block;
        }

        block = block->bbNext;
    }

    return  block;
}


/*****************************************************************************
 *
 *  If the given block is an unconditional jump, return the (final) jump
 *  target (otherwise simply return the same block).
 */

/* static */
BasicBlock *        BasicBlock::JumpTarget()
{
    BasicBlock *block = this;
    int i = 0;

    while (block->bbJumpKind == BBJ_ALWAYS &&
           block->bbTreeList == 0)
    {
        if (i > 64)      // break infinite loops
            break;
        block = block->bbJumpDest;
        i++;
    }

    return block;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\gcencode.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          GCEncode                                         XX
XX                                                                           XX
XX   Logic to encode the JIT method header and GC pointer tables             XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#include "GCInfo.h"
#include "emit.h"

#include "malloc.h"     // for alloca

/*****************************************************************************/
#if TRACK_GC_REFS
/*****************************************************************************/

/*****************************************************************************/
#define REGEN_SHORTCUTS 0
// To Regenerate the compressed info header shortcuts, define REGEN_SHORTCUTS
// and use the following command line pipe/filter to give you the 128
// most useful encodings.
//
// find . -name regen.txt | xargs cat | sort | uniq -c | sort -r | head -128

#define REGEN_CALLPAT 0
// To Regenerate the compressed info header shortcuts, define REGEN_CALLPAT
// and use the following command line pipe/filter to give you the 80
// most useful encodings.
//
// find . -name regen.txt | xargs cat | sort | uniq -c | sort -r | head -80


#if REGEN_SHORTCUTS || REGEN_CALLPAT
static FILE* logFile = NULL;
CRITICAL_SECTION logFileLock;

static void regenLog(unsigned codeDelta,    unsigned argMask,
                     unsigned regMask,      unsigned argCnt,
                     unsigned byrefArgMask, unsigned byrefRegMask,
                     BYTE*    base,         unsigned enSize)
{
    CallPattern pat;

    pat.fld.argCnt    = (argCnt  < 0xff)   ? argCnt    : 0xff;
    pat.fld.regMask   = (regMask < 0xff)   ? regMask   : 0xff;
    pat.fld.argMask   = (argMask < 0xff)   ? argMask   : 0xff;
    pat.fld.codeDelta = (codeDelta < 0xff) ? codeDelta : 0xff;

    if (logFile == NULL)
    {
        logFile = fopen("regen.txt", "a");
        InitializeCriticalSection(&logFileLock);
    }

    assert(((enSize>0) && (enSize<256)) && ((pat.val & 0xffffff) != 0xffffff));

    EnterCriticalSection(&logFileLock);

    fprintf(logFile, "CallSite( 0x%08x, 0x%02x%02x, 0x",
            pat.val, byrefArgMask, byrefRegMask);

    while (enSize > 0)
    {
        fprintf(logFile, "%02x", *base++);
        enSize--;
    }
    fprintf(logFile, "),\n");
    fflush(logFile);

    LeaveCriticalSection(&logFileLock);
}

static void regenLog(unsigned encoding, InfoHdr* header, InfoHdr* state)
{
    if (logFile == NULL)
    {
        logFile = fopen("regen.txt", "a");
        InitializeCriticalSection(&logFileLock);
    }

    EnterCriticalSection(&logFileLock);

    fprintf(logFile, "InfoHdr( %2d, %2d, %1d, %1d, %1d,"
                             " %1d, %1d, %1d, %1d, %1d,"
                             " %1d, %1d, %1d, %1d, %1d,"
                             " %1d, %2d, %2d, %2d, %2d ), \n",
                     header->prologSize,
                     header->epilogSize,
                     header->epilogCount,
                     header->epilogAtEnd,
                     header->ediSaved,
                     header->esiSaved,
                     header->ebxSaved,
                     header->ebpSaved,
                     header->ebpFrame,
                     header->interruptible,
                     header->doubleAlign,
                     header->security,
                     header->handlers,
                     header->localloc,
                     header->editNcontinue,
                     header->varargs,
                     header->argCount,
                     header->frameSize,
                     (header->untrackedCnt<4) ? header->untrackedCnt : -1,
                     (header->varPtrTableSize==0) ? 0 : -1
            );
    fflush(logFile);

    LeaveCriticalSection(&logFileLock);

    if (state->isMatch(*header))
        return;

    char     sbuf[256];
    char*    sbufp = &sbuf[0];
    int      diffs = 0;

    sbufp += sprintf(sbufp, "InfoHdr(", (encoding & 0x7f));

    if (header->prologSize == state->prologSize)
        sbufp += sprintf(sbufp, " %2d,", header->prologSize);
    else
        sbufp += sprintf(sbufp, " XX,", diffs++);

    if (header->epilogSize == state->epilogSize)
        sbufp += sprintf(sbufp, " %2d,", header->epilogSize);
    else
        sbufp += sprintf(sbufp, " XX,", diffs++);

    if (header->epilogCount == state->epilogCount)
        sbufp += sprintf(sbufp, " %1d,", header->epilogCount);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->epilogAtEnd == state->epilogAtEnd)
        sbufp += sprintf(sbufp, " %d,", header->epilogAtEnd);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->ediSaved == state->ediSaved)
        sbufp += sprintf(sbufp, " %d,", header->ediSaved);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->esiSaved == state->esiSaved)
        sbufp += sprintf(sbufp, " %d,", header->esiSaved);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->ebxSaved == state->ebxSaved)
        sbufp += sprintf(sbufp, " %d,", header->ebxSaved);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->ebpSaved == state->ebpSaved)
        sbufp += sprintf(sbufp, " %d,", header->ebpSaved);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->ebpFrame == state->ebpFrame)
        sbufp += sprintf(sbufp, " %d,", header->ebpFrame);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->interruptible == state->interruptible)
        sbufp += sprintf(sbufp, " %d,", header->interruptible);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->doubleAlign == state->doubleAlign)
        sbufp += sprintf(sbufp, " %d,", header->doubleAlign);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->security == state->security)
        sbufp += sprintf(sbufp, " %d,", header->security);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->handlers == state->handlers)
        sbufp += sprintf(sbufp, " %d,", header->handlers);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->localloc == state->localloc)
        sbufp += sprintf(sbufp, " %d,", header->localloc);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->editNcontinue == state->editNcontinue)
        sbufp += sprintf(sbufp, " %d,", header->editNcontinue);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->varargs == state->varargs)
        sbufp += sprintf(sbufp, " %d,", header->varargs);
    else
        sbufp += sprintf(sbufp, " X,", diffs++);

    if (header->argCount == state->argCount)
        sbufp += sprintf(sbufp, " %2d,", header->argCount);
    else
        sbufp += sprintf(sbufp, " XX,", diffs++);

    if (header->frameSize == state->frameSize)
        sbufp += sprintf(sbufp, " %2d,", header->frameSize);
    else
        sbufp += sprintf(sbufp, " XX,", diffs++);

    if (header->untrackedCnt == state->untrackedCnt)
        sbufp += sprintf(sbufp, " %2d,", header->untrackedCnt);
    else if ((state->untrackedCnt == 0xffff) && (header->untrackedCnt > 3))
        sbufp += sprintf(sbufp, " %2d,", -1);
    else
        sbufp += sprintf(sbufp, " XX,", diffs++);

    if ((header->varPtrTableSize == 0) && (state->varPtrTableSize  == 0))
        sbufp += sprintf(sbufp, " %2d ", 0);
    else if ((state->varPtrTableSize  == 0xffff) && (header->varPtrTableSize != 0))
        sbufp += sprintf(sbufp, " %2d ", -1);
    else
        sbufp += sprintf(sbufp, " XX ", diffs++);

    sbufp += sprintf(sbufp, "), \n");

    *sbufp++ = 0;

    EnterCriticalSection(&logFileLock);

    fprintf(logFile, "InfoHdr( %2d, %2d, %1d, %1d, %1d,"
                             " %1d, %1d, %1d, %1d, %1d,"
                             " %1d, %1d, %1d, %1d, %1d,"
                             " %1d, %2d, %2d, %2d, %2d ), \n",
                     state->prologSize,
                     state->epilogSize,
                     state->epilogCount,
                     state->epilogAtEnd,
                     state->ediSaved,
                     state->esiSaved,
                     state->ebxSaved,
                     state->ebpSaved,
                     state->ebpFrame,
                     state->interruptible,
                     state->doubleAlign,
                     state->security,
                     state->handlers,
                     state->localloc,
                     state->editNcontinue,
                     state->varargs,
                     state->argCount,
                     state->frameSize,
                     (state->untrackedCnt<4) ? state->untrackedCnt : -1,
                     (state->varPtrTableSize==0) ? 0 : -1
            );

    fprintf(logFile, sbuf);
    fflush(logFile);

    LeaveCriticalSection(&logFileLock);
}
#endif

/*****************************************************************************
 *
 *  Given the four parameters return the index into the callPatternTable[]
 *  that is used to encoding these four items.  If an exact match cannot
 *  found then ignore the codeDelta and search the table again for a near
 *  match.
 *  Returns 0..79 for an exact match or
 *         (delta<<8) | (0..79) for a near match.
 *  A near match will be encoded using two bytes, the first byte will
 *  skip the adjustment delta that prevented an exact match and the
 *  rest of the delta plus the other three items are encoded in the
 *  second byte.
 */
int FASTCALL lookupCallPattern(unsigned argCnt,   unsigned regMask,
                               unsigned argMask,  unsigned codeDelta)
{
    if ((argCnt <= CP_MAX_ARG_CNT) && (argMask <= CP_MAX_ARG_MASK))
    {
        CallPattern pat;

        pat.fld.argCnt    = argCnt;
        pat.fld.regMask   = regMask;      // EBP,EBX,ESI,EDI
        pat.fld.argMask   = argMask;
        pat.fld.codeDelta = codeDelta;

        bool     codeDeltaOK = (pat.fld.codeDelta == codeDelta);
        unsigned bestDelta2  = 0xff;
        unsigned bestPattern = 0xff;
        unsigned patval      = pat.val;
        assert(sizeof(CallPattern) == sizeof(unsigned));

        unsigned *    curp = &callPatternTable[0];
        for (unsigned inx  = 0;
                      inx  < 80;
                      inx++,curp++)
        {
            unsigned curval = *curp;
            if ((patval == curval) && codeDeltaOK)
                return inx;

            if (((patval ^ curval) & 0xffffff) == 0)
            {
                unsigned delta2 = codeDelta - (curval >> 24);
                if (delta2 < bestDelta2)
                {
                   bestDelta2  = delta2;
                   bestPattern = inx;
                }
            }
        }

        if (bestPattern != 0xff)
        {
            return (bestDelta2 << 8) | bestPattern;
        }
    }
    return -1;
}



static bool initNeeded3(unsigned cur, unsigned tgt,
                        unsigned max, unsigned* hint)
{
    assert(cur != tgt);

    unsigned tmp = tgt;
    unsigned nib = 0;
    unsigned cnt = 0;

    while (tmp > max)
    {
        nib = tmp & 0x07;
        tmp >>= 3;
        if (tmp == cur)
        {
            *hint = nib;
            return false;
        }
        cnt++;
    }

    *hint = tmp;
    return true;
}

static bool initNeeded4(unsigned cur, unsigned tgt,
                        unsigned max, unsigned* hint)
{
    assert(cur != tgt);

    unsigned tmp = tgt;
    unsigned nib = 0;
    unsigned cnt = 0;

    while (tmp > max)
    {
        nib = tmp & 0x0f;
        tmp >>= 4;
        if (tmp == cur)
        {
            *hint = nib;
            return false;
        }
        cnt++;
    }

    *hint = tmp;
    return true;
}

static int bigEncoding3(unsigned cur, unsigned tgt, unsigned max)
{
    assert(cur != tgt);

    unsigned tmp = tgt;
    unsigned nib = 0;
    unsigned cnt = 0;

    while (tmp > max)
    {
        nib = tmp & 0x07;
        tmp >>= 3;
        if (tmp == cur)
            break;
        cnt++;
    }
    return cnt;
}

static int bigEncoding4(unsigned cur, unsigned tgt, unsigned max)
{
    assert(cur != tgt);

    unsigned tmp = tgt;
    unsigned nib = 0;
    unsigned cnt = 0;

    while (tmp > max)
    {
        nib = tmp & 0x0f;
        tmp >>= 4;
        if (tmp == cur)
            break;
        cnt++;
    }
    return cnt;
}

BYTE FASTCALL encodeHeaderNext(const InfoHdr& header, InfoHdr* state)
{
    BYTE encoding = 0xff;

    if (state->argCount != header.argCount)
    {
        // We have one-byte encodings for 0..8
        if (header.argCount <= SET_ARGCOUNT_MAX)
        {
            state->argCount = header.argCount;
            encoding = SET_ARGCOUNT + header.argCount;
            goto DO_RETURN;
        }
        else
        {
            unsigned hint;
            if (initNeeded4(state->argCount, header.argCount,
                            SET_ARGCOUNT_MAX, &hint))
            {
                assert(hint <= SET_ARGCOUNT_MAX);
                state->argCount = hint;
                encoding = SET_ARGCOUNT + hint;
                goto DO_RETURN;
            }
            else
            {
                assert(hint <= 0xf);
                state->argCount <<= 4;
                state->argCount  += hint;
                encoding = NEXT_FOUR_ARGCOUNT + hint;
                goto DO_RETURN;
            }
        }
    }

    if (state->frameSize != header.frameSize)
    {
        // We have one-byte encodings for 0..7
        if (header.frameSize <= SET_FRAMESIZE_MAX)
        {
            state->frameSize = header.frameSize;
            encoding = SET_FRAMESIZE + header.frameSize;
            goto DO_RETURN;
        }
        else
        {
            unsigned hint;
            if (initNeeded4(state->frameSize, header.frameSize,
                            SET_FRAMESIZE_MAX, &hint))
            {
                assert(hint <= SET_FRAMESIZE_MAX);
                state->frameSize = hint;
                encoding = SET_FRAMESIZE + hint;
                goto DO_RETURN;
            }
            else
            {
                assert(hint <= 0xf);
                state->frameSize <<= 4;
                state->frameSize  += hint;
                encoding = NEXT_FOUR_FRAMESIZE + hint;
                goto DO_RETURN;
            }
        }
    }

    if ((state->epilogCount != header.epilogCount) ||
        (state->epilogAtEnd != header.epilogAtEnd))
    {
        assert(header.epilogCount <= SET_EPILOGCNT_MAX);
        state->epilogCount = header.epilogCount;
        state->epilogAtEnd = header.epilogAtEnd;
        encoding = SET_EPILOGCNT + header.epilogCount*2;
        if (header.epilogAtEnd)
            encoding++;
        goto DO_RETURN;
    }

    if (state->varPtrTableSize != header.varPtrTableSize)
    {
        if (state->varPtrTableSize == 0)
        {
            state->varPtrTableSize = 0xffff;
            encoding = FLIP_VARPTRTABLESZ;
            goto DO_RETURN;
        }
        else if (header.varPtrTableSize == 0)
        {
            state->varPtrTableSize = 0;
            encoding = FLIP_VARPTRTABLESZ;
            goto DO_RETURN;
        }
    }

    if (state->untrackedCnt != header.untrackedCnt)
    {
        // We have one-byte encodings for 0..3
        if (header.untrackedCnt <= SET_UNTRACKED_MAX)
        {
            state->untrackedCnt = header.untrackedCnt;
            encoding = SET_UNTRACKED + header.untrackedCnt;
            goto DO_RETURN;
        }
        else if (state->untrackedCnt != 0xffff)
        {
            state->untrackedCnt = 0xffff;
            encoding = FFFF_UNTRACKEDCNT;
            goto DO_RETURN;
        }
    }

    if (state->epilogSize != header.epilogSize)
    {
        // We have one-byte encodings for 0..10
        if (header.epilogSize <= SET_EPILOGSIZE_MAX)
        {
            state->epilogSize = header.epilogSize;
            encoding = SET_EPILOGSIZE + header.epilogSize;
            goto DO_RETURN;
        }
        else
        {
            unsigned hint;
            if (initNeeded3(state->epilogSize, header.epilogSize,
                            SET_EPILOGSIZE_MAX, &hint))
            {
                assert(hint <= SET_EPILOGSIZE_MAX);
                state->epilogSize = hint;
                encoding = SET_EPILOGSIZE + hint;
                goto DO_RETURN;
            }
            else
            {
                assert(hint <= 0x7);
                state->epilogSize <<= 3;
                state->epilogSize  += hint;
                encoding = NEXT_THREE_EPILOGSIZE + hint;
                goto DO_RETURN;
            }
        }
    }

    if (state->prologSize != header.prologSize)
    {
        // We have one-byte encodings for 0..16
        if (header.prologSize <= SET_PROLOGSIZE_MAX)
        {
            state->prologSize = header.prologSize;
            encoding = SET_PROLOGSIZE + header.prologSize;
            goto DO_RETURN;
        }
        else
        {
            unsigned hint;
            assert(SET_PROLOGSIZE_MAX > 15);
            if (initNeeded3(state->prologSize, header.prologSize, 15, &hint))
            {
                assert(hint <= 15);
                state->prologSize = hint;
                encoding = SET_PROLOGSIZE + hint;
                goto DO_RETURN;
            }
            else
            {
                assert(hint <= 0x7);
                state->prologSize <<= 3;
                state->prologSize  += hint;
                encoding = NEXT_THREE_PROLOGSIZE + hint;
                goto DO_RETURN;
            }
        }
    }

    if (state->ediSaved != header.ediSaved)
    {
        state->ediSaved = header.ediSaved;
        encoding = FLIP_EDI_SAVED;
        goto DO_RETURN;
    }

    if (state->esiSaved != header.esiSaved)
    {
        state->esiSaved = header.esiSaved;
        encoding = FLIP_ESI_SAVED;
        goto DO_RETURN;
    }

    if (state->ebxSaved != header.ebxSaved)
    {
        state->ebxSaved = header.ebxSaved;
        encoding = FLIP_EBX_SAVED;
        goto DO_RETURN;
    }

    if (state->ebpSaved != header.ebpSaved)
    {
        state->ebpSaved = header.ebpSaved;
        encoding = FLIP_EBP_SAVED;
        goto DO_RETURN;
    }

    if (state->ebpFrame != header.ebpFrame)
    {
        state->ebpFrame = header.ebpFrame;
        encoding = FLIP_EBP_FRAME;
        goto DO_RETURN;
    }

    if (state->interruptible != header.interruptible)
    {
        state->interruptible = header.interruptible;
        encoding = FLIP_INTERRUPTIBLE;
        goto DO_RETURN;
    }

#if DOUBLE_ALIGN
    if (state->doubleAlign != header.doubleAlign)
    {
        state->doubleAlign = header.doubleAlign;
        encoding = FLIP_DOUBLE_ALIGN;
        goto DO_RETURN;
    }
#endif

    if (state->security != header.security)
    {
        state->security = header.security;
        encoding = FLIP_SECURITY;
        goto DO_RETURN;
    }

    if (state->handlers != header.handlers)
    {
        state->handlers = header.handlers;
        encoding = FLIP_HANDLERS;
        goto DO_RETURN;
    }

    if (state->localloc != header.localloc)
    {
        state->localloc = header.localloc;
        encoding = FLIP_LOCALLOC;
        goto DO_RETURN;
    }

    if (state->editNcontinue != header.editNcontinue)
    {
        state->editNcontinue = header.editNcontinue;
        encoding = FLIP_EDITnCONTINUE;
        goto DO_RETURN;
    }

    if (state->varargs != header.varargs)
    {
        state->varargs = header.varargs;
        encoding = FLIP_VARARGS;
        goto DO_RETURN;
    }

DO_RETURN:
    assert((encoding >= 0) && (encoding < 0x80));
    if (!state->isMatch(header))
        encoding |= 0x80;
    return encoding;
}

static int measureDistance(const InfoHdr& header, InfoHdr* p, int closeness)
{
    int distance = 0;

    if (p->untrackedCnt != header.untrackedCnt)
    {
        if (header.untrackedCnt > 3)
        {
            if (p->untrackedCnt != 0xffff)
                distance += 1;
        }
        else
        {
            distance += 1;
        }
        if (distance >= closeness) return distance;
    }

    if (p->varPtrTableSize != header.varPtrTableSize)
    {
        if (header.varPtrTableSize != 0)
        {
            if (p->varPtrTableSize != 0xffff)
                distance += 1;
        }
        else
        {
            assert(p->varPtrTableSize == 0xffff);
            distance += 1;
        }
        if (distance >= closeness) return distance;
    }

    if (p->frameSize != header.frameSize)
    {
        distance += 1;
        if (distance >= closeness) return distance;

        // We have one-byte encodings for 0..7
        if (header.frameSize > SET_FRAMESIZE_MAX)
        {
            distance += bigEncoding4(p->frameSize, header.frameSize,
                                     SET_FRAMESIZE_MAX);
            if (distance >= closeness) return distance;
        }
    }

    if (p->argCount != header.argCount)
    {
        distance += 1;
        if (distance >= closeness) return distance;

        // We have one-byte encodings for 0..8
        if (header.argCount > SET_ARGCOUNT_MAX)
        {
            distance += bigEncoding4(p->argCount, header.argCount,
                                     SET_ARGCOUNT_MAX);
            if (distance >= closeness) return distance;
        }
    }

    if (p->prologSize != header.prologSize)
    {
        distance += 1;
        if (distance >= closeness) return distance;

        // We have one-byte encodings for 0..16
        if (header.prologSize > SET_PROLOGSIZE_MAX)
        {
            assert(SET_PROLOGSIZE_MAX > 15);
            distance += bigEncoding3(p->prologSize, header.prologSize, 15);
            if (distance >= closeness) return distance;
        }
    }

    if (p->epilogSize != header.epilogSize)
    {
        distance += 1;
        if (distance >= closeness) return distance;
        // We have one-byte encodings for 0..10
        if (header.epilogSize > SET_EPILOGSIZE_MAX)
        {
            distance += bigEncoding3(p->epilogSize, header.epilogSize,
                                     SET_EPILOGSIZE_MAX);
            if (distance >= closeness) return distance;
        }
    }

    if ((p->epilogCount != header.epilogCount) ||
        (p->epilogAtEnd != header.epilogAtEnd))
    {
        distance += 1;
        if (distance >= closeness) return distance;
        assert(header.epilogCount <= SET_EPILOGCNT_MAX);
    }

    if (p->ediSaved != header.ediSaved)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->esiSaved != header.esiSaved)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->ebxSaved != header.ebxSaved)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->ebpSaved != header.ebpSaved)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->ebpFrame != header.ebpFrame)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->interruptible != header.interruptible)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

#if DOUBLE_ALIGN
    if (p->doubleAlign != header.doubleAlign)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }
#endif

    if (p->security != header.security)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->handlers != header.handlers)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->localloc != header.localloc)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->editNcontinue != header.editNcontinue)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    if (p->varargs != header.varargs)
    {
        distance += 1;
        if (distance >= closeness) return distance;
    }

    return distance;
}

static void initLookupTable()
{
    InfoHdr* p  = &infoHdrShortcut[0];
    int      lo = -1;
    int      hi = 0;
    int      n;

    for (n=0; n<128; n++, p++)
    {
        if (p->prologSize != lo)
        {
            if (p->prologSize < lo)
            {
                assert(p->prologSize == 0);
                hi = IH_MAX_PROLOG_SIZE;
            }
            else
                hi = p->prologSize;

            assert(hi <= IH_MAX_PROLOG_SIZE);

            while (lo < hi)
                infoHdrLookup[++lo] = n;

            if (lo == IH_MAX_PROLOG_SIZE)
                break;
        }
    }

    assert(lo == IH_MAX_PROLOG_SIZE);
    assert(infoHdrLookup[IH_MAX_PROLOG_SIZE] < 128);

    infoHdrLookup[++lo] = n+1;

#ifdef DEBUG
    //
    // We do some other DEBUG only validity checks here
    //
    assert(callCommonDelta[0] < callCommonDelta[1]);
    assert(callCommonDelta[1] < callCommonDelta[2]);
    assert(callCommonDelta[2] < callCommonDelta[3]);
    assert(sizeof(CallPattern) == sizeof(unsigned));
    unsigned maxMarks = 0;
    for (unsigned inx=0; inx < 80; inx++)
    {
        CallPattern pat;
        pat.val = callPatternTable[inx];

        assert(pat.fld.codeDelta <= CP_MAX_CODE_DELTA);
        if    (pat.fld.codeDelta == CP_MAX_CODE_DELTA)  maxMarks |= 0x01;

        assert(pat.fld.argCnt    <= CP_MAX_ARG_CNT);
        if    (pat.fld.argCnt    == CP_MAX_ARG_CNT)     maxMarks |= 0x02;

        assert(pat.fld.argMask   <= CP_MAX_ARG_MASK);
        if    (pat.fld.argMask   == CP_MAX_ARG_MASK)    maxMarks |= 0x04;
    }
    assert(maxMarks == 0x07);
#endif
}

BYTE FASTCALL encodeHeaderFirst(const InfoHdr& header, InfoHdr* state, int* more, int* s_cached)
{
    //
    // if infoHdrLookup[0] is equal to 0xff then
    // this is the first call and we must initialize
    // infoHdrLookup[] table
    //
    if (infoHdrLookup[0] == 0xff)
        initLookupTable();

    // First try the cached value for an exact match, if there is one
    //
    int      n = *s_cached;
    InfoHdr* p;

    if (n != -1)
    {
        p = &infoHdrShortcut[n];
        if (p->isMatch(header))
        {
            // exact match found
            *state = *p;
            *more  = 0;
            return n;
        }
    }

    // Next search the table for an exact match
    // Only search entries that have a matching prolog size
    // Note: lo and hi are saved here as they specify the
    // range of entries that have the correct prolog size
    //
    unsigned psz = header.prologSize;
    int      lo = 0;
    int      hi = 0;

    if (psz <= IH_MAX_PROLOG_SIZE)
    {
        lo = infoHdrLookup[psz];
        hi = infoHdrLookup[psz+1];
        p  = &infoHdrShortcut[lo];
        for (n=lo; n<hi; n++,p++)
        {
            assert(psz == p->prologSize);
            if (p->isMatch(header))
            {
                // exact match found
                *state    = *p;
                *s_cached = n;    // cache the value
                *more     = 0;
                return n;
            }
        }
    }

    //
    // no exact match in infoHdrShortcut[]
    //
    // find the nearest entry in the table
    //
    int nearest   = -1;
    int closeness = 255;   // (i.e. not very close)

    //
    // Calculate the minimum acceptable distance
    // if we find an entry that is at least this close
    // we will stop the search and use that value
    //
    int min_acceptable_distance = 1;

    if (header.frameSize > SET_FRAMESIZE_MAX)
    {
        ++min_acceptable_distance;
        if (header.frameSize > 32)
            ++min_acceptable_distance;
    }
    if (header.argCount > SET_ARGCOUNT_MAX)
    {
        ++min_acceptable_distance;
        if (header.argCount > 32)
            ++min_acceptable_distance;
    }

    // First try the cached value
    // and see if it meets the minimum acceptable distance
    //
    if (*s_cached != -1)
    {
        p = &infoHdrShortcut[*s_cached];
        int distance = measureDistance(header, p, closeness);
        assert(distance > 0);
        if (distance <= min_acceptable_distance)
        {
            *state = *p;
            *more  = min_acceptable_distance;
            return 0x80 | *s_cached;
        }
        else
        {
            closeness = distance;
            nearest   = *s_cached;
        }
    }

    // Then try the ones pointed to by [lo..hi),
    // (i.e. the ones that have the correct prolog size)
    //
    p = &infoHdrShortcut[lo];
    for (n=lo; n<hi; n++,p++)
    {
        if (n == *s_cached)
            continue;   // already tried this one
        int distance = measureDistance(header, p, closeness);
        assert(distance > 0);
        if (distance == min_acceptable_distance)
        {
            *state    = *p;
            *s_cached = n;     // Cache this value
            *more     = min_acceptable_distance;
            return 0x80 | n;
        }
        else if (distance < closeness)
        {
            closeness = distance;
            nearest   = n;
        }
    }

    int last = infoHdrLookup[IH_MAX_PROLOG_SIZE+1];
    assert(last <= 128);

    // Then try all the rest [0..last-1]
    p = &infoHdrShortcut[0];
    for (n=0; n<last; n++,p++)
    {
        if (n == *s_cached)
            continue;   // already tried this one
        if ((n>=lo) && (n<hi))
            continue;   // already tried these
        int distance = measureDistance(header, p, closeness);
        assert(distance > 0);
        if (distance == min_acceptable_distance)
        {
            *state    = *p;
            *s_cached = n;        // Cache this value
            *more     = min_acceptable_distance;
            return 0x80 | n;
        }
        else if (distance < closeness)
        {
            closeness = distance;
            nearest = n;
        }
    }

    //
    // If we reach here then there was no adjacent neighbor
    //  in infoHdrShortcut[], closeness indicate how many extra
    //  bytes we will need to encode this item.
    //
    assert((nearest >= 0) && (nearest <= 127));
    *state    = infoHdrShortcut[nearest];
    *s_cached = nearest;          // Cache this value
    *more     = closeness;
    return 0x80 | nearest;
}

/*****************************************************************************
 *
 *  Write the initial part of the method info block. This is called twice;
 *  first to compute the size needed for the info (mask=0), the second time
 *  to actually generate the contents of the table (mask=-1,dest!=NULL).
 */

size_t              Compiler::gcInfoBlockHdrSave(BYTE     * dest,
                                                 int        mask,
                                                 unsigned   methodSize,
                                                 unsigned   prologSize,
                                                 unsigned   epilogSize,
                                                 InfoHdr  * header,
                                                 int*       s_cached)
{
    size_t          size = 0;

#if TGT_x86

    size_t          sz;

    /* Can't create tables if we've not saved code */

    if  (!savCode) return 0;

#if VERIFY_GC_TABLES
    *castto(dest, unsigned short *)++ = 0xFEEF; size += sizeof(short);
#endif

    /* Write the method size first (using between 1 and 5 bytes) */

#ifdef  DEBUG
    if (verbose)
    {
        if (mask) printf("GCINFO: methodSize = %04X\n", methodSize);
        if (mask) printf("GCINFO: prologSize = %04X\n", prologSize);
        if (mask) printf("GCINFO: epilogSize = %04X\n", epilogSize);
    }
#endif

    sz    = encodeUnsigned(dest, methodSize);
    size += sz;
    dest += sz & mask;

    //
    // New style InfoBlk Header [briansul]
    //
    // Typically only uses one-byte to store everything.
    //

    if (mask==0)
    {
        memset(header, 0, sizeof(InfoHdr));
        *s_cached = -1;
    }

    header->prologSize  = prologSize;
    header->epilogSize  = epilogSize;
    header->epilogCount = getEmitter()->emitGetEpilogCnt();
    header->epilogAtEnd = getEmitter()->emitHasEpilogEnd();
    header->epilogCount = getEmitter()->emitGetEpilogCnt();
    header->epilogAtEnd = getEmitter()->emitHasEpilogEnd();

#if TGT_x86

    if (rsMaskModf & RBM_EDI)
        header->ediSaved = 1;
    if (rsMaskModf & RBM_ESI)
        header->esiSaved =  1;
    if (rsMaskModf & RBM_EBX)
        header->ebxSaved = 1;

#else

    assert(!"need non-x86 code");

#endif

    header->interruptible = genInterruptible;

#if TGT_x86

    if  (!genFPused)
    {
#if DOUBLE_ALIGN
        if  (genDoubleAlign)
        {
            header->ebpSaved = true;
            assert((rsMaskModf & RBM_EBP) == 0);
        }
#endif
        if (rsMaskModf & RBM_EBP)
        {
            header->ebpSaved = true;
        }
    }
    else
    {
        header->ebpSaved = true;
        header->ebpFrame = true;
    }

#endif

#if DOUBLE_ALIGN
    header->doubleAlign = genDoubleAlign;
#endif

#if SECURITY_CHECK
#if OPT_IL_JIT
    header->security = false;
#else
    header->security = opts.compNeedSecurityCheck;
#endif
#endif

    if (info.compXcptnsCount)
        header->handlers = true;
    else
        header->handlers = false;

    header->localloc = compLocallocUsed;

#ifdef OPT_IL_JIT
    header->varargs       = m_methodInfo->args.isVarArg();
    header->editNcontinue = false;
#else
    header->varargs       = info.compIsVarArgs;
    header->editNcontinue = opts.compDbgEnC;
#endif

    assert((compArgSize & 0x3) == 0);

#if USE_FASTCALL
    header->argCount  = (compArgSize - (rsCalleeRegArgNum * sizeof(void *))) / sizeof(void*);
#else
    header->argCount  = compArgSize/sizeof(void*);
#endif

    header->frameSize = compLclFrameSize / sizeof(int);

    if (mask==0)
        gcCountForHeader(&header->untrackedCnt, &header->varPtrTableSize);

    //
    // If the high-order bit of headerEncoding is set
    // then additional bytes will update the InfoHdr state
    // until the fully state is encoded
    //
    InfoHdr state;
    int more = 0;
    BYTE headerEncoding = encodeHeaderFirst(*header, &state, &more, s_cached);
    ++size;
    if (mask)
    {
#if REGEN_SHORTCUTS
        regenLog(headerEncoding, header, &state);
        bool first = true;
#endif
        *dest++ = headerEncoding;

        BYTE encoding = headerEncoding;
        while (encoding & 0x80)
        {
            encoding = encodeHeaderNext(*header, &state);
            *dest++ = encoding;
            ++size;
        }
    }
    else
    {
        size += more;
    }

    if (header->untrackedCnt > 3)
    {
        unsigned count = header->untrackedCnt;
        unsigned sz = encodeUnsigned(mask ? dest : NULL, count);
        size += sz;
        dest += (sz & mask);
    }

    if (header->varPtrTableSize != 0)
    {
        unsigned count = header->varPtrTableSize;
        unsigned sz = encodeUnsigned(mask ? dest : NULL, count);
        size += sz;
        dest += (sz & mask);
    }

    if (header->epilogCount)
    {
        /* Generate table unless one epilog at the end of the method */

        if  (header->epilogAtEnd == 0 ||
             header->epilogCount != 1)
        {
            unsigned    sz;

#if VERIFY_GC_TABLES
            *castto(dest, unsigned short *)++ = 0xFACE; size += sizeof(short);
#endif

            /* Simply write a sorted array of offsets using encodeUDelta */

            gcEpilogTable      = mask ? dest : NULL;
            gcEpilogPrevOffset = 0;

            sz = getEmitter()->emitGenEpilogLst(gcRecordEpilog, this);

            /* Add the size of the epilog table to the total size */

            size += sz;
            dest += (sz & mask);
        }
    }

#if DISPLAY_SIZES

    if (mask)
    {
        if (genInterruptible)
            genMethodICnt++;
        else
            genMethodNCnt++;
    }

#endif

#else

#pragma message("NOTE: GC table generation disabled for non-x86 targets")

#endif

    return  size;
}

/*****************************************************************************
 *
 *  Return the size of the pointer tracking tables.
 */

size_t              Compiler::gcPtrTableSize(const InfoHdr& header, unsigned codeSize)
{
    BYTE            temp[16+1];
#ifdef DEBUG
    temp[16] = 0xAB; // Set some marker
#endif

    /* Compute the total size of the tables */

    size_t size = gcMakeRegPtrTable(temp, 0, header, codeSize);

    assert(temp[16] == 0xAB); // Check that marker didnt get overwritten

    return size;
}

/*****************************************************************************
 * Encode the callee-saved registers into 3 bits.
 */

unsigned            gceEncodeCalleeSavedRegs(unsigned regs)
{
    unsigned    encodedRegs = 0;

#if TGT_x86
    if  (regs & RBM_EBX) encodedRegs |= 0x04;
    if  (regs & RBM_ESI) encodedRegs |= 0x02;
    if  (regs & RBM_EDI) encodedRegs |= 0x01;
#endif

    return encodedRegs;
}

/*****************************************************************************
 * Is the next entry for a byref pointer. If so, emit the prefix for the
 * interruptible encoding. Check only for pushes and registers
 */

inline
BYTE *              gceByrefPrefixI(Compiler::regPtrDsc * rpd, BYTE * dest)
{
    // For registers, we dont need a prefix if it is going dead.
    assert(rpd->rpdArg || rpd->rpdCompiler.rpdDel==0);

    if (!rpd->rpdArg || rpd->rpdArgType == Compiler::rpdARG_PUSH)
        if (rpd->rpdGCtypeGet() == GCT_BYREF)
            *dest++ = 0xBF;

    return dest;
}

/*****************************************************************************/

/* These functions are needed to work around a VC5.0 compiler bug */
/* DO NOT REMOVE, unless you are sure that the free build works   */
static  int         zeroFN() { return 0; }
static  int       (*zeroFunc)() = zeroFN;

/*****************************************************************************
 *  Modelling of the GC ptrs pushed on the stack
 */

typedef unsigned            pasMaskType;
#define BITS_IN_pasMask     (BITS_IN_BYTE * sizeof(pasMaskType))
#define HIGHEST_pasMask_BIT (((pasMaskType)0x1) << (BITS_IN_pasMask-1))

//-----------------------------------------------------------------------------

class   PendingArgsStack
{
public:

    PendingArgsStack            (unsigned   maxDepth, Compiler * pComp);

    void        pasPush         (GCtype     gcType);
    void        pasPop          (unsigned   count);
    void        pasKill         (unsigned   gcCount);

    unsigned    pasCurDepth     ()  { return pasDepth; }
    pasMaskType pasArgMask      ()  { assert(pasDepth <= BITS_IN_pasMask); return pasBottomMask; }
    pasMaskType pasByrefArgMask ()  { assert(pasDepth <= BITS_IN_pasMask); return pasByrefBottomMask; }
    bool        pasHasGCptrs    ();

    // Use these in the case where there actually are more ptrs than pasArgMask
    unsigned    pasEnumGCoffsCount();
    #define     pasENUM_START   (-1)
    #define     pasENUM_LAST    (-2)
    #define     pasENUM_END     (-3)
    unsigned    pasEnumGCoffs   (unsigned iter, unsigned * offs);

protected:

    unsigned    pasMaxDepth;

    unsigned    pasDepth;

    pasMaskType pasBottomMask;      // The first 32 args
    pasMaskType pasByrefBottomMask; // byref qualifier for pasBottomMask

    BYTE *      pasTopArray;        // More than 32 args are represented here
    unsigned    pasPtrsInTopArray;  // How many GCptrs here
};


//-----------------------------------------------------------------------------

PendingArgsStack::PendingArgsStack(unsigned maxDepth, Compiler * pComp) :
    pasMaxDepth(maxDepth), pasDepth(0),
    pasBottomMask(0), pasByrefBottomMask(0),
    pasTopArray(NULL), pasPtrsInTopArray(0)
{
    /* Do we need an array as well as the mask ? */

    if (pasMaxDepth > BITS_IN_pasMask)
        pasTopArray = (BYTE *)pComp->compGetMemA(pasMaxDepth - BITS_IN_pasMask);
}

//-----------------------------------------------------------------------------

void        PendingArgsStack::pasPush(GCtype gcType)
{
    assert(pasDepth < pasMaxDepth);

    if  (pasDepth < BITS_IN_pasMask)
    {
        /* Shift the mask */

        pasBottomMask       <<= 1;
        pasByrefBottomMask  <<= 1;

        if (needsGC(gcType))
        {
            pasBottomMask |= 1;

            if (gcType == GCT_BYREF)
                pasByrefBottomMask |= 1;
        }
    }
    else
    {
        /* Push on array */

        pasTopArray[pasDepth - BITS_IN_pasMask] = (BYTE)gcType;

        if (gcType)
            pasPtrsInTopArray++;
    }

    pasDepth++;
}

//-----------------------------------------------------------------------------

void        PendingArgsStack::pasPop(unsigned count)
{
    assert(pasDepth >= count);

    /* First pop from array (if applicable) */

    for (/**/; (pasDepth > BITS_IN_pasMask) && count; pasDepth--,count--)
    {
        unsigned    topIndex = pasDepth - BITS_IN_pasMask - 1;

        GCtype      topArg = (GCtype)pasTopArray[topIndex];

        if (needsGC(topArg))
            pasPtrsInTopArray--;
    }
    if (count == 0) return;

    /* Now un-shift the mask */

    assert(pasPtrsInTopArray == 0);
    assert(count <= BITS_IN_pasMask);

    if (count == BITS_IN_pasMask) // (x>>32) is a nop on x86. So special-case it
    {
        pasBottomMask       =
        pasByrefBottomMask  = 0;
        pasDepth            = 0;
    }
    else
    {
        pasBottomMask      >>= count;
        pasByrefBottomMask >>= count;
        pasDepth -= count;
    }
}

//-----------------------------------------------------------------------------
// Kill (but dont pop) the top 'gcCount' args

void        PendingArgsStack::pasKill(unsigned gcCount)
{
    assert(gcCount != 0);

    /* First kill args in array (if any) */

    for (unsigned curPos = pasDepth; (curPos > BITS_IN_pasMask) && gcCount; curPos--)
    {
        unsigned    curIndex = curPos - BITS_IN_pasMask - 1;

        GCtype      curArg = (GCtype)pasTopArray[curIndex];

        if (needsGC(curArg))
        {
            pasTopArray[curIndex] = GCT_NONE;
            pasPtrsInTopArray--;
            gcCount--;
        }
    }

    /* Now kill bits from the mask */

    assert(pasPtrsInTopArray == 0);
    assert(gcCount <= BITS_IN_pasMask);

    for (unsigned bitPos = 1; gcCount; bitPos<<=1)
    {
        assert(pasBottomMask != 0);

        if (pasBottomMask & bitPos)
        {
            pasBottomMask &= ~bitPos;
            pasByrefBottomMask &= ~bitPos;
            --gcCount;
        }
        else
        {
            assert(bitPos != HIGHEST_pasMask_BIT);
        }
    }
}

//-----------------------------------------------------------------------------
// Used for the case where there are more than BITS_IN_pasMask args on stack,
// but none are any pointers. May avoid reporting anything to GCinfo

bool        PendingArgsStack::pasHasGCptrs()
{
    if (pasDepth <= BITS_IN_pasMask)
        return pasBottomMask != 0;
    else
        return pasBottomMask != 0 || pasPtrsInTopArray != 0;
}

//-----------------------------------------------------------------------------
//  Iterates over mask and array to return total count.
//  Use only when you are going to emit a table of the offsets

unsigned    PendingArgsStack::pasEnumGCoffsCount()
{
    /* Should only be used in the worst case, when just the mask cant be used */

    assert(pasDepth > BITS_IN_pasMask && pasHasGCptrs());

    /* Count number of set bits in mask */

    unsigned count = 0;

    for(pasMaskType mask = 0x1, i = 0; i < BITS_IN_pasMask; mask<<=1, i++)
    {
        if (mask & pasBottomMask)
            count++;
    }

    return count + pasPtrsInTopArray;
}

//-----------------------------------------------------------------------------
//  Initalize enumeration by passing in iter=pasENUM_START.
//  Continue by passing in the return value as the new value of iter
//  End of enumeration when pasENUM_END is returned
//  If return value != pasENUM_END, *offs is set to the offset for GCinfo

unsigned    PendingArgsStack::pasEnumGCoffs(unsigned iter, unsigned * offs)
{
    if (iter == pasENUM_LAST) return pasENUM_END;

    unsigned i = (iter == pasENUM_START) ? pasDepth : iter;

    for(/**/; i > BITS_IN_pasMask; i--)
    {
        GCtype curArg = (GCtype)pasTopArray[i-BITS_IN_pasMask-1];
        if (needsGC(curArg))
        {
            unsigned    offset;

            offset  = (pasDepth - i) * sizeof(void*);
            if (curArg==GCT_BYREF)
                offset |= byref_OFFSET_FLAG;

            *offs = offset;
            return i - 1;
        }
    }

    if (!pasBottomMask) return pasENUM_END;

    // Have we already processed some of the bits in pasBottomMask ?

    i = (iter == pasENUM_START || iter >= BITS_IN_pasMask) ? 0      // no
                                                           : iter;  // yes

    for(pasMaskType mask = 0x1 << i; mask; i++, mask<<=1)
    {
        if (mask & pasBottomMask)
        {
            unsigned lvl = (pasDepth>BITS_IN_pasMask) ? (pasDepth-BITS_IN_pasMask) : 0; // How many in pasTopArray[]
            lvl += i;

            unsigned    offset;
            offset  =  lvl * sizeof(void*);
            if (mask & pasByrefBottomMask)
                offset |= byref_OFFSET_FLAG;

            *offs = offset;

            unsigned remMask = -(mask<<1);
            return ((pasBottomMask & remMask) ? (i + 1) : pasENUM_LAST);
        }
    }

    assert(!"Shouldnt reach here");
    return pasENUM_END;
}

/*****************************************************************************
 *
 *  Generate the register pointer map, and return its total size in bytes. If
 *  'mask' is 0, we don't actually store any data in 'dest' (except for one
 *  entry, which is never more than 10 bytes), so this can be used to merely
 *  compute the size of the table.
 */

#include "Endian.h"

size_t              Compiler::gcMakeRegPtrTable(BYTE *          dest,
                                                int             mask,
                                                const InfoHdr & header,
                                                unsigned        codeSize)
{
    unsigned        count;

    unsigned        varNum;
    LclVarDsc   *   varDsc;

    varPtrDsc   *   varTmp;

    unsigned        pass;

    size_t          totalSize  = 0;
    unsigned        lastOffset;

    bool            thisIsInUntracked = false;

#if TGT_x86

    /* Can't create tables if we've not saved code */

    if  (!savCode)
        return 0;

    /* The mask should be all 0's or all 1's */

    assert(mask == 0 || mask == -1);

    /* Start computing the total size of the table */

#if VERIFY_GC_TABLES
    if (mask)
    {
        *(short *)dest = (short)0xBEEF;
        dest += sizeof(short);
    }
    totalSize += sizeof(short);
#endif

    /**************************************************************************
     *
     *                      Untracked ptr variables
     *
     **************************************************************************
     */

    count = 0;
    for (pass = 0; pass < 2; pass++)
    {
        /* If pass==0, generate the count
         * If pass==1, write the table of untracked pointer variables.
         */

        if (pass==1)
        {
            assert(count == header.untrackedCnt);
            if (header.untrackedCnt==0)
                break;  // No entries, break exits the loop since pass==1
        }

        /* Count&Write untracked locals and non-enregistered args */

        for (varNum = 0, varDsc = lvaTable;
             varNum < lvaCount;
             varNum++  , varDsc++)
        {
            if  (varTypeIsGC(varDsc->TypeGet()))
            {
                /* Do we have an argument or local variable? */
                if  (!varDsc->lvIsParam)
                {
                    // If is is pinned, it must be an untracked local
                    assert(!varDsc->lvPinned || !varDsc->lvTracked);

                    if  (varDsc->lvTracked || !varDsc->lvOnFrame)
                        continue;
                }
                else
                {
                    /* Stack-passed arguments which are not enregistered
                     * are always reported in this "untracked stack
                     * pointers" section of the GC info even if lvTracked==true
                     */

                    /* Has this argument been enregistered? */
                    if  (varDsc->lvRegister)
                    {
                        /*
                           Special case: include the stack location of 'this'
                           for synchronized methods, so that runtime can find
                           'this' in case an exception goes by.
                         */
#if !USE_FASTCALL
                        if  (varNum != 0 || !(info.compFlags & FLG_SYNCH))
#endif
                            continue;
                    }
                    else
                    {
                        if  (!varDsc->lvOnFrame)
                        {
                            /* If this non-enregistered pointer arg is never
                             * used, we dont need to report it
                             */
                            assert(varDsc->lvRefCnt == 0);
                            continue;
                        }
#if USE_FASTCALL
                        else  if (varDsc->lvIsRegArg && varDsc->lvTracked)
                        {
                            /* If this register-passed arg is tracked, then
                             * it has been allocated space near the other
                             * pointer variables and we have accurate life-
                             * time info. It will be reported with
                             * gcVarPtrList in the "tracked-pointer" section
                             */

                            continue;
                        }
#endif
                    }
                }

                if (varDsc->lvIsThis)
                {
                    // Encoding of untracked variables does not support reporting
                    // "this". So report it as a tracked variable with a liveness
                    // extending over the entire method.

                    thisIsInUntracked = true;
                    continue;
                }

                if (pass==0)
                    count++;
                else
                {
                    int offset;
                    assert(pass==1);

                    offset = varDsc->lvStkOffs;

                    // The lower bits of the offset encode properties of the stk ptr

                    assert(~OFFSET_MASK % sizeof(offset) == 0);

                    if (varDsc->TypeGet() == TYP_BYREF)
                    {
                        // Or in byref_OFFSET_FLAG for 'byref' pointer tracking
                        offset |= byref_OFFSET_FLAG;
                    }

                    if (varDsc->lvPinned)
                    {
                        // Or in pinned_OFFSET_FLAG for 'pinned' pointer tracking
                        offset |= pinned_OFFSET_FLAG;
                    }

                    if (mask == 0)
                        totalSize  += encodeSigned(NULL, offset);
                    else
                    {
                        unsigned sz = encodeSigned(dest, offset);
                        dest      += sz;
                        totalSize += sz;
                    }
                }
            }

            if  (varDsc->lvType == TYP_STRUCT && varDsc->lvOnFrame)
            {
                assert(!varDsc->lvTracked);

                CLASS_HANDLE cls = lvaLclClass(varNum);
                assert(cls != 0);
                if (cls == REFANY_CLASS_HANDLE) // Is the an REFANY?
                {
                    if (pass==0)
                        count++;
                    else
                    {
                        assert(pass==1);
                        unsigned offset = varDsc->lvStkOffs;

                        offset |= byref_OFFSET_FLAG;     // indicate it is a byref GC pointer
                        if (mask == 0)
                            totalSize  += encodeSigned(NULL, offset);
                        else
                        {
                            unsigned sz = encodeSigned(dest, offset);
                            dest      += sz;
                            totalSize += sz;
                        }
                    }
                }
                else
                {
                    unsigned slots = roundUp(eeGetClassSize(cls), sizeof(void*)) / sizeof(void*);
                    bool* gcPtrs = (bool*) _alloca(slots*sizeof(bool));
                    eeGetClassGClayout(cls, gcPtrs);

                        // walk each member of the array
                    for (unsigned i = 0; i < slots; i++)
                    {
                        if (!gcPtrs[i])     // skip non-gc slots
                            continue;

                        if (pass==0)
                            count++;
                        else
                        {
                            assert(pass==1);

                            unsigned offset = varDsc->lvStkOffs + i * sizeof(void*);

                            if (mask == 0)
                                totalSize  += encodeSigned(NULL, offset);
                            else
                            {
                                unsigned sz = encodeSigned(dest, offset);
                                dest      += sz;
                                totalSize += sz;
                            }
                        }
                    }
                }
            }
        }

        /* Count&Write spill temps that hold pointers */

        for (TempDsc * tempItem = tmpListBeg();
             tempItem;
             tempItem = tmpListNxt(tempItem))
        {
            if  (varTypeIsGC(tempItem->tdTempType()))
            {
                if (pass==0)
                    count++;
                else
                {
                    int offset;
                    assert(pass==1);

                    offset = tempItem->tdTempOffs();

                    // @ToDo: Or in 0x01 if this spill temp is the
                    //        this pointer for the method

                    if (tempItem->tdTempType() == TYP_BYREF)
                    {
                        offset |= byref_OFFSET_FLAG;
                    }

                    if (mask == 0)
                    {
                        totalSize  += encodeSigned(NULL, offset);
                    }
                    else
                    {
                        unsigned sz = encodeSigned(dest, offset);
                        dest      += sz;
                        totalSize += sz;
                    }
                }
            }
        }
    }

#if VERIFY_GC_TABLES
    if (mask)
    {
        *(short *)dest = (short)0xCAFE;
        dest += sizeof(short);
    }
    totalSize += sizeof(short);
#endif

    /**************************************************************************
     *
     *  Generate the table of stack pointer variable lifetimes.
     *
     *  In the first pass we'll count the lifetime entries and note
     *  whether there are any that don't fit in a small encoding. In
     *  the second pass we actually generate the table contents.
     *
     **************************************************************************
     */

    // First we check for the most common case - no lifetimes at all.

    if  (header.varPtrTableSize == 0)
        goto DONE_VLT;

    count = 0;

    if (thisIsInUntracked)
    {
        count = 1;

        // Encoding of untracked variables does not support reporting
        // "this". So report it as a tracked variable with a liveness
        // extending over the entire method.

        assert(lvaTable[0].lvIsThis);
        unsigned    varOffs = lvaTable[0].lvStkOffs;

        /* For negative stack offsets we must reset the low bits,
         * take abs and then set them back */

        varOffs  = abs(varOffs);
        varOffs |= this_OFFSET_FLAG;
        if (lvaTable[0].TypeGet() == TYP_BYREF)
            varOffs |= byref_OFFSET_FLAG;

        size_t sz = 0;
        sz  = encodeUnsigned(mask?(dest+sz):NULL, varOffs);
        sz += encodeUDelta  (mask?(dest+sz):NULL, 0, 0);
        sz += encodeUDelta  (mask?(dest+sz):NULL, codeSize, 0);

        dest      += (sz & mask);
        totalSize += sz;
    }

    for (pass = 0; pass < 2; pass++)
    {
        /* If second pass, generate the count */

        if  (pass)
        {
            assert(header.varPtrTableSize > 0);
            assert(header.varPtrTableSize == count);
        }

        /* We'll use a delta encoding for the lifetime offsets */

        lastOffset = 0;

        for (varTmp = gcVarPtrList; varTmp; varTmp = varTmp->vpdNext)
        {
            unsigned        varOffs;
            unsigned        lowBits;

            unsigned        begOffs;
            unsigned        endOffs;

            assert(~OFFSET_MASK % sizeof(void*) == 0);

            /* Get hold of the variable's stack offset */

            lowBits  = varTmp->vpdVarNum & OFFSET_MASK;

            /* For negative stack offsets we must reset the low bits,
             * take abs and then set them back */

            varOffs  = abs(varTmp->vpdVarNum & ~OFFSET_MASK);
            varOffs |= lowBits;

            /* Compute the actual lifetime offsets */

            begOffs = varTmp->vpdBegOfs;
            endOffs = varTmp->vpdEndOfs;

            /* Special case: skip any 0-length lifetimes */

            if  (endOffs == begOffs)
                continue;

            /* Are we counting or generating? */

            if  (!pass)
            {
                count++;
            }
            else
            {
                size_t sz = 0;
                sz  = encodeUnsigned(mask?(dest+sz):NULL, varOffs);
                sz += encodeUDelta  (mask?(dest+sz):NULL, begOffs, lastOffset);
                sz += encodeUDelta  (mask?(dest+sz):NULL, endOffs, begOffs);

                dest      += (sz & mask);
                totalSize += sz;
            }

            /* The next entry will be relative to the one we just processed */

            lastOffset = begOffs;
        }
    }

DONE_VLT:

#if VERIFY_GC_TABLES
    if (mask)
    {
        *(short *)dest = (short)0xBABE;
        dest += sizeof(short);
    }
    totalSize += sizeof(short);
#endif


    /**************************************************************************
     *
     * Prepare to generate the pointer register/argument map
     *
     **************************************************************************
     */

    lastOffset = 0;

    if  (genInterruptible)
    {
        assert(genFullPtrRegMap);

        unsigned        ptrRegs = 0;

        regPtrDsc  *    genRegPtrTemp;

        /* Walk the list of pointer register/argument entries */

        for (genRegPtrTemp = gcRegPtrList;
             genRegPtrTemp;
             genRegPtrTemp = genRegPtrTemp->rpdNext)
        {
            BYTE     *      base = dest;

            unsigned        nextOffset;
            DWORD           codeDelta;

            nextOffset = genRegPtrTemp->rpdOffs;

  /*
      Encoding table for methods that are fully interruptible

      The encoding used is as follows:

      ptr reg dead    00RRRDDD    [RRR != 100]
      ptr reg live    01RRRDDD    [RRR != 100]

  non-ptr arg push    10110DDD                    [SSS == 110]
      ptr arg push    10SSSDDD                    [SSS != 110] && [SSS != 111]
      ptr arg pop     11CCCDDD    [CCC != 000] && [CCC != 110] && [CCC != 111]
      little skip     11000DDD    [CCC == 000]
      bigger skip     11110BBB                    [CCC == 110]

      The values used in the above encodings are as follows:

        DDD                 code offset delta from previous entry (0-7)
        BBB                 bigger delta 000=8,001=16,010=24,...,111=64
        RRR                 register number (EAX=000,ECX=001,EDX=010,EBX=011,
                              EBP=101,ESI=110,EDI=111), ESP=100 is reserved
        SSS                 argument offset from base of stack. This is
                              redundant for frameless methods as we can
                              infer it from the previous pushes+pops. However,
                              for EBP-methods, we only report GC pushes, and
                              so we need SSS
        CCC                 argument count being popped (includes only ptrs for EBP methods)

      The following are the 'large' versions:

        large delta skip        10111000 [0xB8] , encodeUnsigned(delta)

        large     ptr arg push  11111000 [0xF8] , encodeUnsigned(pushCount)
        large non-ptr arg push  11111001 [0xF9] , encodeUnsigned(pushCount)
        large     ptr arg pop   11111100 [0xFC] , encodeUnsigned(popCount)
        large         arg dead  11111101 [0xFD] , encodeUnsigned(popCount) for caller-pop args.
                                                    Any GC args go dead after the call,
                                                    but are still sitting on the stack

        this pointer prefix     10111100 [0xBC]   the next encoding is a ptr live
                                                    or a ptr arg push
                                                    and contains the this pointer

        interior or by-ref      10111111 [0xBF]   the next encoding is a ptr live
             pointer prefix                         or a ptr arg push
                                                    and contains an interior
                                                    or by-ref pointer


        The value 11111111 [0xFF] indicates the end of the table.
  */

            codeDelta = nextOffset - lastOffset; assert((int)codeDelta >= 0);

            // If the code delta is between 8 and (64+7),
            // generate a 'bigger delta' encoding

            if ((codeDelta >= 8) && (codeDelta <= (64+7)))
            {
                unsigned biggerDelta = ((codeDelta-8) & 0x38) + 8;
                *dest++ = 0xF0 | ((biggerDelta-8) >> 3);
                lastOffset += biggerDelta;
                codeDelta &= 0x07;
            }

            // If the code delta is still bigger than 7,
            // generate a 'large code delta' encoding

            if  (codeDelta > 7)
            {
                *dest++   = 0xB8;
                dest     += encodeUnsigned(dest, codeDelta);
                codeDelta = 0;

                /* Remember the new 'last' offset */

                lastOffset = nextOffset;
            }

           /* Is this a pointer argument or register entry? */

            if  (genRegPtrTemp->rpdArg)
            {
                if (genRegPtrTemp->rpdArgTypeGet() == rpdARG_KILL)
                {
                    if  (codeDelta)
                    {
                        /*
                            Use the small encoding:
                            little delta skip       11000DDD    [0xC0]
                         */

                        assert((codeDelta & 0x7) == codeDelta);
                        *dest++ = 0xC0 | (BYTE)codeDelta;

                        /* Remember the new 'last' offset */

                        lastOffset = nextOffset;
                    }

                    /* Caller-pop arguments are dead after call but are still
                       sitting on the stack */

                    *dest++  = 0xFD;
                    assert(genRegPtrTemp->rpdPtrArg != 0);
                    dest    += encodeUnsigned(dest, genRegPtrTemp->rpdPtrArg);
                }
                else if  (genRegPtrTemp->rpdPtrArg < 6 && genRegPtrTemp->rpdGCtypeGet())
                {
                    /* Is the argument offset/count smaller than 6 ? */

                    dest = gceByrefPrefixI(genRegPtrTemp, dest);

                    if ( genRegPtrTemp->rpdArgTypeGet() == rpdARG_PUSH ||
                        (genRegPtrTemp->rpdPtrArg!=0))
                    {
                        /*
                          Use the small encoding:

                            ptr arg push 10SSSDDD [SSS != 110] && [SSS != 111]
                            ptr arg pop  11CCCDDD [CCC != 110] && [CCC != 111]
                         */

                        bool isPop = genRegPtrTemp->rpdArgTypeGet() == rpdARG_POP;

                        *dest++ = 0x80 | (BYTE)codeDelta
                                       | genRegPtrTemp->rpdPtrArg << 3
                                       | isPop << 6;

                        /* Remember the new 'last' offset */

                        lastOffset = nextOffset;
                    }
                    else
                    {
                        assert(!"Check this");
                    }

                }
                else if (genRegPtrTemp->rpdGCtypeGet() == GCT_NONE)
                {
                    /*
                        Use the small encoding:
`                        non-ptr arg push 10110DDD [0xB0] (push of sizeof(int))
                     */

                    assert((codeDelta & 0x7) == codeDelta);
                    *dest++ = 0xB0 | (BYTE)codeDelta;
                    assert(!genFPused);

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;
                }
                else
                {
                    /* Will have to use large encoding;
                     *   first do the code delta
                     */

                    if  (codeDelta)
                    {
                        /*
                            Use the small encoding:
                            little delta skip       11000DDD    [0xC0]
                         */

                        assert((codeDelta & 0x7) == codeDelta);
                        *dest++ = 0xC0 | (BYTE)codeDelta;
                    }

                    /*
                        Now append a large argument record:

                            large ptr arg push  11111000 [0xF8]
                            large ptr arg pop   11111100 [0xFC]
                     */

                    bool isPop = genRegPtrTemp->rpdArgTypeGet() == rpdARG_POP;

                    dest = gceByrefPrefixI(genRegPtrTemp, dest);

                    *dest++  = 0xF8 | (isPop << 2);
                    dest    += encodeUnsigned(dest, genRegPtrTemp->rpdPtrArg);

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;
                }
            }
            else
            {
                unsigned    regMask;

                /* Record any registers that are becoming dead */

                regMask = genRegPtrTemp->rpdCompiler.rpdDel & ptrRegs;

                while (regMask)         // EAX,ECX,EDX,EBX,---,EBP,ESI,EDI
                {
                    unsigned    tmpMask;
                    regNumber   regNum;

                    /* Get hold of the next register bit */

                    tmpMask = genFindLowestReg(regMask); assert(tmpMask);

                    /* Remember the new state of this register */

                    ptrRegs&= ~tmpMask;

                    /* Figure out which register the next bit corresponds to */

                    regNum  = genRegNumFromMask(tmpMask); assert(regNum <= 7);

                    /* Reserve ESP, regNum==4 for future use */

                    assert(regNum != 4);

                    /*
                        Generate a small encoding:

                            ptr reg dead        00RRRDDD
                     */

                    assert((codeDelta & 0x7) == codeDelta);
                    *dest++ = 0x00 | regNum << 3
                                   | (BYTE)codeDelta;

                    /* Turn the bit we've just generated off and continue */

                    regMask -= tmpMask; // EAX,ECX,EDX,EBX,---,EBP,ESI,EDI

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;

                    /* Any entries that follow will be at the same offset */

                    codeDelta =  zeroFunc(); /* DO NOT REMOVE */
                }

                /* Record any registers that are becoming live */

                regMask = genRegPtrTemp->rpdCompiler.rpdAdd & ~ptrRegs;

                while (regMask)         // EAX,ECX,EDX,EBX,---,EBP,ESI,EDI
                {
                    unsigned    tmpMask;
                    regNumber   regNum;

                    /* Get hold of the next register bit */

                    tmpMask = genFindLowestReg(regMask); assert(tmpMask);

                    /* Remember the new state of this register */

                    ptrRegs |= tmpMask;

                    /* Figure out which register the next bit corresponds to */

                    regNum  = genRegNumFromMask(tmpMask); assert(regNum <= 7);

                    /*
                        Generate a small encoding:

                            ptr reg live        01RRRDDD
                     */

                    dest = gceByrefPrefixI(genRegPtrTemp, dest);

                    if (!thisIsInUntracked & genRegPtrTemp->rpdIsThis)
                    {
                        // Mark with 'this' pointer prefix
                        *dest++ = 0xBC;
                        // Can only have one bit set in regMask
                        assert(regMask == tmpMask);
                    }

                    assert((codeDelta & 0x7) == codeDelta);
                    *dest++ = 0x40 | regNum << 3
                                   | (BYTE)codeDelta;

                    /* Turn the bit we've just generated off and continue */

                    regMask -= tmpMask;    // EAX,ECX,EDX,EBX,---,EBP,ESI,EDI

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;

                    /* Any entries that follow will be at the same offset */

                    codeDelta =  zeroFunc(); /* DO NOT REMOVE */
                }
            }

            /* Keep track of the total amount of generated stuff */

            totalSize += dest - base;

            /* Go back to the buffer start if we're not generating a table */

            if  (!mask)
                dest = base;
        }

        /* Terminate the table with 0xFF */

        *dest = 0xFF; dest -= mask; totalSize++;
    }
    else if (genFPused)        // genInterruptible is false
    {
  /*
      Encoding table for methods with an EBP frame and
                         that are not fully interruptible

      The encoding used is as follows:

      this pointer encodings:

         01000000          this pointer in EBX
         00100000          this pointer in ESI
         00010000          this pointer in EDI

      tiny encoding:

         0bsdDDDD
                           requires code delta > 0 & delta < 16 (4-bits)
                           requires pushed argmask == 0

           where    DDDD   is code delta
                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer


      small encoding:

         1DDDDDDD bsdAAAAA

                           requires code delta     < 120 (7-bits)
                           requires pushed argmask <  64 (5-bits)

           where DDDDDDD   is code delta
                   AAAAA   is the pushed args mask
                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer

      medium encoding

         0xFD aaaaaaaa AAAAdddd bseDDDDD

                           requires code delta     <  512  (9-bits)
                           requires pushed argmask < 2048 (12-bits)

           where    DDDDD  is the upper 5-bits of the code delta
                     dddd  is the low   4-bits of the code delta
                     AAAA  is the upper 4-bits of the pushed arg mask
                 aaaaaaaa  is the low   8-bits of the pushed arg mask
                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        e  indicates that register EDI is a live pointer

      medium encoding with interior pointers

         0xF9 DDDDDDDD bsdAAAAAA iiiIIIII

                           requires code delta     < 256 (8-bits)
                           requires pushed argmask <  64 (5-bits)

           where  DDDDDDD  is the code delta
                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                    AAAAA  is the pushed arg mask
                      iii  indicates that EBX,EDI,ESI are interior pointers
                    IIIII  indicates that bits in the arg mask are interior
                           pointers

      large encoding

         0xFE [32-bit argMask] [dd...(24bits)...d] [bsdDDDDD]

                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                   dd...d  is the low  24-bits of the code delta
                    DDDDD  is the upper 5-bits of the code delta
                           requires code delta < 29-bits
                           requires pushed argmask < 32-bits


      large encoding  with interior pointers

         0xFA [32-bit argMask] [dd...(24bits)...d] [bsdDDDDD]
                               [II...(24bits)...I] [iiiIIIII]

                        b  indicates that register EBX is a live pointer
                        s  indicates that register ESI is a live pointer
                        d  indicates that register EDI is a live pointer
                   dd...d  is the low  24-bits of the code delta
                    DDDDD  is the upper 5-bits of the code delta
                      iii  indicates that EBX,EDI,ESI are interior pointers
                   II...I  specifies (for 29 bits) that bits in the
                            (32-bit) arg mask are interior pointers.
                           requires code delta      < 29-bits
                           requires pushed  argmask < 32-bits
                           requires pushed iArgmask < 29 bits


      huge encoding        This is the only encoding that supports
                           a pushed argmask which is greater than
                           32-bits.

         0xFB [0BSD0bsd][32-bit code delta]
              [32-bit table count][32-bit table size]
              [pushed ptr offsets table...]

                       b   indicates that register EBX is a live pointer
                       s   indicates that register ESI is a live pointer
                       d   indicates that register EDI is a live pointer
                       B   indicates that register EBX is an interior pointer
                       S   indicates that register ESI is an interior pointer
                       D   indicates that register EDI is an interior pointer
                       the list count is the number of entries in the list
                       the list size gives the byte-lenght of the list
                       the offsets in the list are variable-length
  */

#if USE_FASTCALL

        /* If "this" is enregistered, note it. We do this explicitly here as
           genFullPtrRegMap==false, and so we dont have any regPtrDsc's. */

        if (!info.compIsStatic && lvaTable[0].lvRegister)
        {
            assert(lvaIsThisArg(0));

            unsigned thisRegMask   = genRegMask(lvaTable[0].lvRegNum);
            unsigned thisPtrRegEnc = gceEncodeCalleeSavedRegs(thisRegMask) << 4;

            /* @TODO : If "this" is in a calle-trashed register, dont
               encode it as there is no encoding for it. If the encoding
               gets changed to allow it, will we also have to note when
               "this" goes dead - note that the CallDsc's dont indicate
               when a register goes dead.
               This shouldnt be too bad as if "this" is enregistered in
               a callee-trashed register, it cant be a synchronized method.
             */
            if (thisPtrRegEnc)
            {
                totalSize += 1;
                if (mask)
                    *dest++ = thisPtrRegEnc;
            }
        }
#endif

        CallDsc    *    call;

        assert(genFullPtrRegMap == false);

        /* Walk the list of pointer register/argument entries */

        for (call = gcCallDescList; call; call = call->cdNext)
        {
            BYTE    *   base = dest;
            unsigned    nextOffset;
            DWORD       val;

            /* Figure out the code offset of this entry */

            nextOffset = call->cdOffs;

            /* Compute the distance from the previous call */

            DWORD       codeDelta    = nextOffset - lastOffset;

            assert((int)codeDelta >= 0);

            /* Remember the new 'last' offset */

            lastOffset = nextOffset;

            /* Compute the register mask */

            unsigned gcrefRegMask = 0;
            unsigned byrefRegMask = 0;

            gcrefRegMask |= gceEncodeCalleeSavedRegs(call->cdGCrefRegs);
            byrefRegMask |= gceEncodeCalleeSavedRegs(call->cdByrefRegs);

            assert((gcrefRegMask & byrefRegMask) == 0);

            unsigned regMask = gcrefRegMask | byrefRegMask;

            bool byref = (byrefRegMask | call->cdByrefArgMask) != 0;

            /* Check for the really large argument offset case */
            /* The very rare Huge encodings */

            if  (call->cdArgCnt)
            {
                unsigned    argNum;
                DWORD       argCnt = call->cdArgCnt;
                DWORD       argBytes = 0;
                BYTE *      pArgBytes;

                if (mask != 0)
                {
                    *dest++ = 0xFB;
                    *dest++ = (byrefRegMask << 4) | regMask;
                    storeDWordSmallEndian(dest, &codeDelta);dest += sizeof(DWORD);
                    storeDWordSmallEndian(dest, &argCnt);   dest += sizeof(DWORD);
                    // skip the byte-size for now. Just note where it will go
                    pArgBytes = dest;                       dest += sizeof(DWORD);
                }

                for (argNum = 0; argNum < argCnt; argNum++)
                {
                    unsigned    eltSize;
                    eltSize = encodeUnsigned(dest, call->cdArgTable[argNum]);
                    argBytes += eltSize;
                    if (mask) dest += eltSize;
                }

                if (mask == 0)
                {
                    dest = base + 1 + 1 + 3*sizeof(DWORD) + argBytes;
                }
                else
                {
                    assert(dest == pArgBytes + sizeof(argBytes) + argBytes);
                    storeDWordSmallEndian(pArgBytes, &argBytes);
                }
            }

            /* Check if we can use a tiny encoding */
            else if ((codeDelta < 16) && (codeDelta != 0) && (call->cdArgMask == 0) && !byref)
            {
                *dest++ = (regMask << 4) | (BYTE)codeDelta;
            }

            /* Check if we can use the small encoding */
            else if ((codeDelta < 0x79) && (call->cdArgMask <= 0x1F) && !byref)
            {
                *dest++ = 0x80 | (BYTE)codeDelta;
                *dest++ = call->cdArgMask | (regMask << 5);
            }

            /* Check if we can use the medium encoding */
            else if  (codeDelta <= 0x01FF && call->cdArgMask <= 0x0FFF && !byref)
            {
                *dest++ = 0xFD;
                *dest++ = call->cdArgMask;
                *dest++ = ((call->cdArgMask >> 4) & 0xF0) | ((BYTE)codeDelta & 0x0F);
                *dest++ = (regMask << 5) | (BYTE)((codeDelta >> 4) & 0x1F);
            }

            /* Check if we can use the medium encoding with byrefs */
            else if  (codeDelta <= 0x0FF && call->cdArgMask <= 0x01F)
            {
                *dest++ = 0xF9;
                *dest++ = (BYTE)codeDelta;
                *dest++ = (     regMask << 5) | call->cdArgMask;
                *dest++ = (byrefRegMask << 5) | call->cdByrefArgMask;
            }

            /* We'll use the large encoding */
            else if (!byref)
            {
                *dest++ = 0xFE;

                val = call->cdArgMask;
                storeDWordSmallEndian(dest, &val);      dest += sizeof(DWORD);

                assert((codeDelta & 0xE0000000) == 0);
                val = (regMask << 29) | codeDelta;
                storeDWordSmallEndian(dest, &val);      dest += sizeof(DWORD);
            }

            /* We'll use the large encoding with byrefs */
            else
            {
                *dest++ = 0xFA;

                val = call->cdArgMask;
                storeDWordSmallEndian(dest, &val);      dest += sizeof(DWORD);

                assert((codeDelta & 0xE0000000) == 0);
                val = (regMask << 29) | codeDelta;
                storeDWordSmallEndian(dest, &val);      dest += sizeof(DWORD);

                assert((call->cdByrefArgMask & 0xE0000000) == 0);
                val = (byrefRegMask << 29) | call->cdByrefArgMask;
                storeDWordSmallEndian(dest, &val);      dest += sizeof(DWORD);
            }

            /* Keep track of the total amount of generated stuff */

            totalSize += dest - base;

            /* Go back to the buffer start if we're not generating a table */

            if  (!mask)
                dest = base;
        }

        /* Terminate the table with 0xFF */

        *dest = 0xFF; dest -= mask; totalSize++;
    }
    else // genInterruptible is false and we have an EBP-less frame
    {
        assert(genFullPtrRegMap);

        regPtrDsc  *    genRegPtrTemp;
        regNumber       thisRegNum = regNumber(0);
        unsigned        thisMask   = 0;
        unsigned        thisPrint  = 0;
        PendingArgsStack pasStk(getEmitter()->emitMaxStackDepth, this);

        /* Walk the list of pointer register/argument entries */

        for (genRegPtrTemp = gcRegPtrList;
             genRegPtrTemp;
             genRegPtrTemp = genRegPtrTemp->rpdNext)
        {

/*
 *    Encoding table for methods without an EBP frame and
 *     that are not fully interruptible
 *
 *               The encoding used is as follows:
 *
 *  push     000DDDDD                     ESP push one item with 5-bit delta
 *  push     00100000 [pushCount]         ESP push multiple items
 *  reserved 0010xxxx                     xxxx != 0000
 *  reserved 0011xxxx
 *  skip     01000000 [Delta]             Skip Delta, arbitrary sized delta
 *  skip     0100DDDD                     Skip small Delta, for call (DDDD != 0)
 *  pop      01CCDDDD                     ESP pop  CC items with 4-bit delta (CC != 00)
 *  call     1PPPPPPP                     Call Pattern, P=[0..79]
 *  call     1101pbsd DDCCCMMM            Call RegMask=pbsd,ArgCnt=CCC,
 *                                        ArgMask=MMM Delta=commonDelta[DD]
 *  call     1110pbsd [ArgCnt] [ArgMask]  Call ArgCnt,RegMask=pbsd,ArgMask
 *  call     11111000 [PBSDpbsd][32-bit delta][32-bit ArgCnt]
 *                    [32-bit PndCnt][32-bit PndSize][PndOffs...]
 *  iptr     11110000 [IPtrMask]          Arbitrary Interior Pointer Mask
 *  thisptr  111101RR                     This pointer is in Register RR
 *                                        00=EDI,01=ESI,10=EBX,11=EBP
 *  reserved 111100xx                     xx  != 00
 *  reserved 111110xx                     xx  != 00
 *  reserved 11111xxx                     xxx != 000 && xxx != 111(EOT)
 *
 *   The value 11111111 [0xFF] indicates the end of the table. (EOT)
 *
 *  An offset (at which stack-walking is performed) without an explicit encoding
 *  is assumed to be a trivial call-site (no GC registers, stack empty before and
 *  after) to avoid having to encode all trivial calls.
 *
 * Note on the encoding used for interior pointers
 *
 *   The iptr encoding must immediately preceed a call encoding.  It is used
 *   to transform a normal GC pointer addresses into an interior pointers for
 *   GC purposes.  The mask supplied to the iptr encoding is read from the
 *   least signicant bit to the most signicant bit. (i.e the lowest bit is
 *   read first)
 *
 *   p   indicates that register EBP is a live pointer
 *   b   indicates that register EBX is a live pointer
 *   s   indicates that register ESI is a live pointer
 *   d   indicates that register EDI is a live pointer
 *   P   indicates that register EBP is an interior pointer
 *   B   indicates that register EBX is an interior pointer
 *   S   indicates that register ESI is an interior pointer
 *   D   indicates that register EDI is an interior pointer
 *
 *   As an example the following sequence indicates that EDI.ESI and the
 *   second pushed pointer in ArgMask are really interior pointers.  The
 *   pointer in ESI in a normal pointer:
 *
 *   iptr 11110000 00010011           => read Interior Ptr, Interior Ptr,
 *                                       Normal Ptr, Normal Ptr, Interior Ptr
 *
 *   call 11010011 DDCCC011 RRRR=1011 => read EDI is a GC-pointer,
 *                                            ESI is a GC-pointer.
 *                                            EBP is a GC-pointer
 *                           MMM=0011 => read two GC-pointers arguments
 *                                         on the stack (nested call)
 *
 *   Since the call instruction mentions 5 GC-pointers we list them in
 *   the required order:  EDI, ESI, EBP, 1st-pushed pointer, 2nd-pushed pointer
 *
 *   And we apply the Interior Pointer mask mmmm=10011 to the five GC-pointers
 *   we learn that EDI and ESI are interior GC-pointers and that
 *   the second push arg is an interior GC-pointer.
 */

            BYTE    *       base = dest;

            bool            usePopEncoding;
            unsigned        regMask;
            unsigned        argMask;
            unsigned        byrefRegMask;
            unsigned        byrefArgMask;
            DWORD           callArgCnt;

            unsigned        nextOffset;
            DWORD           codeDelta;

            nextOffset = genRegPtrTemp->rpdOffs;

            /* Compute the distance from the previous call */

            codeDelta = nextOffset - lastOffset; assert((int)codeDelta >= 0);

#if REGEN_CALLPAT
            // Must initialize this flag to true when REGEN_CALLPAT is on
            usePopEncoding = true;
            unsigned origCodeDelta = codeDelta;
#endif

            if (!thisIsInUntracked & genRegPtrTemp->rpdIsThis)
            {
                unsigned  tmpMask = genRegPtrTemp->rpdCompiler.rpdAdd;

                /* tmpMask must have exactly one bit set */

                assert(tmpMask && ((tmpMask & (tmpMask-1)) == 0));

                thisRegNum  = genRegNumFromMask(tmpMask);
                switch (thisRegNum)
                {
                  case 0: // EAX
                  case 1: // ECX
                  case 2: // EDX
                  case 4: // ESP
                    break;
                  case 7: // EDI
                    *dest++ = 0xF4;  /* 11110100  This pointer is in EDI */
                    break;
                  case 6: // ESI
                    *dest++ = 0xF5;  /* 11110100  This pointer is in ESI */
                    break;
                  case 3: // EBX
                    *dest++ = 0xF6;  /* 11110100  This pointer is in EBX */
                    break;
                  case 5: // EBP
                    *dest++ = 0xF7;  /* 11110100  This pointer is in EBP */
                    break;
                }
            }

            /* Is this a stack pointer change or call? */

            if (genRegPtrTemp->rpdArg)
            {
                if (genRegPtrTemp->rpdArgTypeGet() == rpdARG_KILL)
                {
                    // kill 'rpdPtrArg' number of pointer variables in pasStk
                    pasStk.pasKill(genRegPtrTemp->rpdPtrArg);
                }
                    /* Is this a call site? */
                else if (genRegPtrTemp->rpdCall)
                {
                    /* This is a true call site */

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;

                    callArgCnt = genRegPtrTemp->rpdPtrArg;

                    unsigned gcrefRegMask = genRegPtrTemp->rpdCallGCrefRegs;

                    byrefRegMask = genRegPtrTemp->rpdCallByrefRegs;

                    assert((gcrefRegMask & byrefRegMask) == 0);

                    regMask = gcrefRegMask | byrefRegMask;

                    /* adjust argMask for this call-site */
                    pasStk.pasPop(callArgCnt);

                    /* Do we have to use the fat encoding */

                    if (pasStk.pasCurDepth() > BITS_IN_pasMask &&
                        pasStk.pasHasGCptrs())
                    {
                        /* use fat encoding:
                         *   11111000 [PBSDpbsd][32-bit delta][32-bit ArgCnt]
                         *            [32-bit PndCnt][32-bit PndSize][PndOffs...]
                         */

                        DWORD   pndCount = pasStk.pasEnumGCoffsCount();
                        DWORD   pndSize = 0;
                        BYTE *  pPndSize;

                        if (mask)
                        {
                           *dest++ = 0xF8;
                           *dest++ = (byrefRegMask << 4) | regMask;
                            storeDWordSmallEndian(dest, &codeDelta);    dest += sizeof(DWORD);
                            storeDWordSmallEndian(dest, &callArgCnt);   dest += sizeof(DWORD);
                            storeDWordSmallEndian(dest, &pndCount);     dest += sizeof(DWORD);
                            pPndSize = dest;                            dest += sizeof(DWORD); // Leave space for pndSize
                        }

                        unsigned offs, iter;

                        for(iter = pasStk.pasEnumGCoffs(pasENUM_START, &offs);
                            pndCount;
                            iter = pasStk.pasEnumGCoffs(iter, &offs), pndCount--)
                        {
                            unsigned eltSize = encodeUnsigned(dest, offs);

                            pndSize += eltSize;
                            if (mask) dest += eltSize;
                        }
                        assert(iter == pasENUM_END);

                        if (mask == 0)
                        {
                            dest = base + 2 + 4*sizeof(DWORD) + pndSize;
                        }
                        else
                        {
                            assert(pPndSize + sizeof(pndSize) + pndSize == dest);
                            storeDWordSmallEndian(pPndSize, &pndSize);
                        }

                        goto NEXT_RPD;
                    }

                    argMask = byrefArgMask = 0;

                    if (pasStk.pasHasGCptrs())
                    {
                        assert(pasStk.pasCurDepth() <= BITS_IN_pasMask);

                             argMask = pasStk.pasArgMask();
                        byrefArgMask = pasStk.pasByrefArgMask();
                    }

                    /* Shouldnt be reporting trivial call-sites */

                    assert(regMask || argMask || callArgCnt || pasStk.pasCurDepth());

                    // Emit IPtrMask if needed

#define CHK_NON_INTRPT_ESP_IPtrMask                                         \
                                                                            \
                    if (byrefRegMask || byrefArgMask)                       \
                    {                                                       \
                        *dest++ = 0xF0;                                     \
                        unsigned imask = (byrefArgMask << 4) | byrefRegMask;\
                        dest += encodeUnsigned(dest, imask);                \
                    }

                    /* When usePopEncoding is true:
                     *  this is not an interesting call site
                     *   because nothing is live here.
                     */
                    usePopEncoding = ((callArgCnt < 4) && (regMask == 0) && (argMask == 0));

                    if (!usePopEncoding)
                    {
                        int pattern = lookupCallPattern(callArgCnt, regMask,
                                                        argMask, codeDelta);
                        if (pattern != -1)
                        {
                            if (pattern > 0xff)
                            {
                                codeDelta = pattern >> 8;
                                pattern &= 0xff;
                                if (codeDelta >= 16)
                                {
                                    /* use encoding: */
                                    /*   skip 01000000 [Delta] */
                                    *dest++ = 0x40;
                                    dest += encodeUnsigned(dest, codeDelta);
                                    codeDelta = 0;
                                }
                                else
                                {
                                    /* use encoding: */
                                    /*   skip 0100DDDD  small delta=DDDD */
                                    *dest++ = 0x40 | (BYTE)codeDelta;
                                }
                            }

                            // Emit IPtrMask if needed
                            CHK_NON_INTRPT_ESP_IPtrMask;

                            assert((pattern >= 0) && (pattern < 80));
                            *dest++ = 0x80 | pattern;
                            goto NEXT_RPD;
                        }

                        /* See if we can use 2nd call encoding
                         *     1101RRRR DDCCCMMM encoding */

                        if ((callArgCnt <= 7) && (argMask <= 7))
                        {
                            unsigned inx;          // callCommonDelta[] index
                            unsigned maxCommonDelta = callCommonDelta[3];
                            assert(maxCommonDelta == 14); // @ToDo Remove

                            if (codeDelta > maxCommonDelta)
                            {
                                if (codeDelta > maxCommonDelta+15)
                                {
                                    /* use encoding: */
                                    /*   skip    01000000 [Delta] */
                                    *dest++ = 0x40;
                                    dest += encodeUnsigned(dest, codeDelta-maxCommonDelta);
                                }
                                else
                                {
                                    /* use encoding: */
                                    /*   skip 0100DDDD  small delta=DDDD */
                                    *dest++ = 0x40 | (BYTE)(codeDelta-maxCommonDelta);
                                }

                                codeDelta = maxCommonDelta;
                                inx = 3;
                                goto EMIT_2ND_CALL_ENCODING;
                            }

                            for (inx=0; inx<4; inx++)
                            {
                                if (codeDelta == callCommonDelta[inx])
                                {
EMIT_2ND_CALL_ENCODING:
                                    // Emit IPtrMask if needed
                                    CHK_NON_INTRPT_ESP_IPtrMask;

                                    *dest++ = 0xD0 | regMask;
                                    *dest++ =   (inx << 6)
                                              | (callArgCnt << 3)
                                              | argMask;
                                    goto NEXT_RPD;
                                }
                            }

                            unsigned minCommonDelta = callCommonDelta[0];
                            assert(minCommonDelta == 8); // @ToDo Remove

                            if ((codeDelta > minCommonDelta) && (codeDelta < maxCommonDelta))
                            {
                                assert((minCommonDelta+16) > maxCommonDelta);
                                /* use encoding: */
                                /*   skip 0100DDDD  small delta=DDDD */
                                *dest++ = 0x40 | (BYTE)(codeDelta-minCommonDelta);

                                codeDelta = minCommonDelta;
                                inx = 0;
                                goto EMIT_2ND_CALL_ENCODING;
                            }

                        }
                    }

                    if (codeDelta >= 16)
                    {
                        unsigned i = (usePopEncoding ? 15 : 0);
                        /* use encoding: */
                        /*   skip    01000000 [Delta]  arbitrary sized delta */
                        *dest++ = 0x40;
                        dest += encodeUnsigned(dest, codeDelta-i);
                        codeDelta = i;
                    }

                    if ((codeDelta > 0) || usePopEncoding)
                    {
                        if (usePopEncoding)
                        {
                            /* use encoding: */
                            /*   pop 01CCDDDD  ESP pop CC items, 4-bit delta */
                            if (callArgCnt || codeDelta)
                                *dest++ = (BYTE)(0x40 | (callArgCnt << 4) | codeDelta);
                            goto NEXT_RPD;
                        }
                        else
                        {
                            /* use encoding: */
                            /*   skip 0100DDDD  small delta=DDDD */
                            *dest++ = 0x40 | (BYTE)codeDelta;
                        }
                    }

                    //Emit IPtrMask if needed
                    CHK_NON_INTRPT_ESP_IPtrMask;

                    /* use encoding:                                   */
                    /*   call 1110RRRR [ArgCnt] [ArgMask]              */

                    *dest++ = 0xE0 | regMask;
                    dest   += encodeUnsigned(dest, callArgCnt);

                    dest   += encodeUnsigned(dest, argMask);
                }
                else
                {
                    /* This is a push or a pop site */

                    /* Remember the new 'last' offset */

                    lastOffset = nextOffset;

                    if  (genRegPtrTemp->rpdArgTypeGet() == rpdARG_POP)
                    {
                        /* This must be a gcArgPopSingle */

                        assert(genRegPtrTemp->rpdPtrArg == 1);

                        if (codeDelta >= 16)
                        {
                            /* use encoding: */
                            /*   skip    01000000 [Delta] */
                            *dest++ = 0x40;
                            dest += encodeUnsigned(dest, codeDelta-15);
                            codeDelta = 15;
                        }

                        /* use encoding: */
                        /*   pop1    0101DDDD  ESP pop one item, 4-bit delta */

                        *dest++ = 0x50 | (BYTE)codeDelta;

                        /* adjust argMask for this pop */
                        pasStk.pasPop(1);
                    }
                    else
                    {
                        /* This is a push */

                        if (codeDelta >= 32)
                        {
                            /* use encoding: */
                            /*   skip    01000000 [Delta] */
                            *dest++ = 0x40;
                            dest += encodeUnsigned(dest, codeDelta-31);
                            codeDelta = 31;
                        }

                        assert(codeDelta < 32);

                        /* use encoding: */
                        /*   push    000DDDDD ESP push one item, 5-bit delta */

                        *dest++ = (BYTE)codeDelta;

                        /* adjust argMask for this push */
                        pasStk.pasPush(genRegPtrTemp->rpdGCtypeGet());
                    }
                }
            }

            /*  We ignore the register live/dead information, since the
             *  rpdCallRegMask contains all the liveness information
             *  that we need
             */
NEXT_RPD:

            totalSize += dest - base;

            /* Go back to the buffer start if we're not generating a table */

            if  (!mask)
                dest = base;

#if REGEN_CALLPAT
            if ((mask==-1) && (usePopEncoding==false) && ((dest-base) > 0))
                regenLog(origCodeDelta, argMask, regMask, callArgCnt,
                         byrefArgMask, byrefRegMask, base, (dest-base));
#endif

        }

        /* Verify that we pop evet arg that was pushed and that argMask is 0 */

        assert(pasStk.pasCurDepth() == 0);

        /* Terminate the table with 0xFF */

        *dest = 0xFF; dest -= mask; totalSize++;
    }

#if VERIFY_GC_TABLES
    if (mask)
    {
        *(short *)dest = (short)0xBEEB;
        dest += sizeof(short);
    }
    totalSize += sizeof(short);
#endif

#if MEASURE_PTRTAB_SIZE

    if (mask)
        s_gcTotalPtrTabSize += totalSize;

#endif

#else

#pragma message("NOTE: GC table generation disabled for non-x86 targets")

#endif

    return  totalSize;
}

/*****************************************************************************/
#if DUMP_GC_TABLES
/*****************************************************************************
 *
 *  Dump the contents of a GC pointer table.
 */

#include "GCDump.h"

GCDump              gcDump;

#if VERIFY_GC_TABLES
const bool          verifyGCTables  = true;
#else
const bool          verifyGCTables  = false;
#endif

/*****************************************************************************
 * This is needed as GCDump.lib uses _ASSERTE() and we dont want to link in
 * UtilCode.lib
 */


#if defined(NOT_JITC)  // @TODO : This doesnt compile with jit\exe for some reason
#ifdef  DEBUG
#ifndef UNDER_CE_GUI

//int _DbgBreakCheck(LPCSTR szFile, int iLine, LPCSTR szExpr);

extern "C"
int __stdcall _DbgBreakCheck(const unsigned short * szFile, int iLine, const unsigned short * szExpr)
{
    //assertAbort(szExpr, NULL, szFile, iLine);

    wprintf(L"%s(%u) : Assertion failed '%s'\n", szFile, iLine, szExpr);
    DebugBreak();
    return false;
}

#endif
#endif
#endif

/*****************************************************************************
 *
 *  Dump the info block header.
 */

unsigned            Compiler::gcInfoBlockHdrDump(const BYTE *   table,
                                                 InfoHdr    *   header,
                                                 unsigned   *   methodSize)
{
    printf("\nMethod info block:\n");

    return gcDump.DumpInfoHdr(table, header, methodSize, verifyGCTables);
}

/*****************************************************************************/

unsigned            Compiler::gcDumpPtrTable(const BYTE *   table,
                                             const InfoHdr& header,
                                             unsigned       methodSize)
{
    printf("Pointer table:\n");

    return gcDump.DumpGCTable(table, header, methodSize, verifyGCTables);
}


/*****************************************************************************
 *
 *  Find all the live pointers in a stack frame.
 */

void                Compiler::gcFindPtrsInFrame(const void *infoBlock,
                                                const void *codeBlock,
                                                unsigned    offs)
{
    gcDump.DumpPtrsInFrame(infoBlock, codeBlock, offs, verifyGCTables);
}

#endif // DUMP_GC_TABLES

/*****************************************************************************/
#endif//TRACK_GC_REFS
/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\jit\ia64\flowgraph.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                          FlowGraph                                        XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#if     TGT_IA64
#include "PEwrite.h"
#endif

#include "malloc.h"     // for alloca

/*****************************************************************************/

void                Compiler::fgInit()
{
    impInit();

#if RNGCHK_OPT

    /* We don't have the dominator sets available yet */

    fgComputedDoms   = false;

    /* We don't know yet which loops will always execute calls */

    fgLoopCallMarked = false;

#endif

    /* We haven't encountered any outgoing arguments yet */

#if TGT_IA64
    genOutArgRegCnt    = 0;
#endif

    /* Statement list is not threaded yet */

    fgStmtListThreaded = false;

     // Initialize the logic for adding code. This is used to insert code such
     // as the code that raises an exception when an array range check fails.

    fgAddCodeList    = 0;
    fgAddCodeModf    = false;

    for (int i=0; i<ACK_COUNT; i++)
    {
        fgExcptnTargetCache[i] = NULL;
    }

    /* Keep track of the max count of pointer arguments */

    fgPtrArgCntCur   =
    fgPtrArgCntMax   = 0;
}

/*****************************************************************************
 *
 *  Create a basic block and append it to the current BB list.
 */

BasicBlock *        Compiler::fgNewBasicBlock(BBjumpKinds jumpKind)
{
    BasicBlock *    block;

    /* Allocate the block descriptor */

    block = bbNewBasicBlock(jumpKind);
    assert(block->bbJumpKind == jumpKind);

    /* Append the block to the end of the global basic block list */

    if  (fgFirstBB)
        fgLastBB->bbNext = block;
    else
        fgFirstBB        = block;

    fgLastBB = block;

    return block;
}

/*****************************************************************************
 *
 *  A helper to prepend a basic block with the given expression to the current
 *  method.
 */

BasicBlock  *       Compiler::fgPrependBB(GenTreePtr tree)
{
    BasicBlock  *   block;

    assert(tree && tree->gtOper != GT_STMT);

    /* Allocate the block descriptor */

    block = bbNewBasicBlock(BBJ_NONE);

    /* Make sure the block doesn't get thrown away! */

    block->bbFlags |= BBF_IMPORTED;

    /* Prepend the block to the global basic block list */

    block->bbNext = fgFirstBB;
                    fgFirstBB = block;

    /* Create a statement expression */

    tree = gtNewStmt(tree);

    /* Set up the linked list */

    tree->gtNext = 0;
    tree->gtPrev = tree;

    /* Store the statement in the block */

    block->bbTreeList = tree;

    return  block;
}

/*****************************************************************************
 *
 *  Insert the given statement at the start of the given basic block.
 */

void                Compiler::fgInsertStmtAtBeg(BasicBlock *block,
                                                GenTreePtr  stmt)
{
    GenTreePtr      list = block->bbTreeList;

    assert(stmt && stmt->gtOper == GT_STMT);

    /* In any case the new block will now be the first one of the block */

    block->bbTreeList = stmt;
    stmt->gtNext      = list;

    /* Are there any statements in the block? */

    if  (list)
    {
        GenTreePtr      last;

        /* There is at least one statement already */

        last = list->gtPrev; assert(last && last->gtNext == 0);

        /* Insert the statement in front of the first one */

        list->gtPrev  = stmt;
        stmt->gtPrev  = last;
    }
    else
    {
        /* The block was completely empty */

        stmt->gtPrev  = stmt;
    }
}

/*****************************************************************************
 *
 *  Insert the given statement at the end of the given basic block.
 */

void                Compiler::fgInsertStmtAtEnd(BasicBlock *block,
                                                GenTreePtr  stmt)
{
    GenTreePtr      list = block->bbTreeList;

    assert(stmt && stmt->gtOper == GT_STMT);

    if  (list)
    {
        GenTreePtr      last;

        /* There is at least one statement already */

        last = list->gtPrev; assert(last && last->gtNext == 0);

        /* Append the statement after the last one */

        last->gtNext = stmt;
        stmt->gtPrev = last;
        list->gtPrev = stmt;
    }
    else
    {
        /* The block is completely empty */

        block->bbTreeList = stmt;
        stmt->gtPrev      = stmt;
    }
}

/*****************************************************************************
 *
 *  Insert the given statement at the end of the given basic block, but before
 *  the GT_JTRUE if present
 */

void        Compiler::fgInsertStmtNearEnd(BasicBlock * block, GenTreePtr stmt)
{
    assert(stmt && stmt->gtOper == GT_STMT);

    if (block->bbJumpKind != BBJ_COND)
    {
        fgInsertStmtAtEnd(block, stmt);
        return;
    }

    GenTreePtr      list = block->bbTreeList;
    assert(list);

    GenTreePtr      last  = list->gtPrev;
    assert(last && last->gtNext == 0);
    assert(last->gtStmt.gtStmtExpr->gtOper == GT_JTRUE);

    /* Get the stmt before the GT_JTRUE */

    GenTreePtr      last2 = last->gtPrev;
    assert(last2 && (!last2->gtNext || last2->gtNext == last));

    stmt->gtNext = last;
    last->gtPrev = stmt;

    if (list == last)
    {
        /* There is only the GT_JTRUE in the block */

        assert(last2 == last);

        block->bbTreeList   = stmt;
        stmt->gtPrev        = last;
    }
    else
    {
        /* Append the statement before the GT_JTRUE */

        last2->gtNext       = stmt;
        stmt->gtPrev        = last2;
    }
}

/*****************************************************************************
 * Checks if a block is in the predecessor list of another
 * This is very helpful in keeping the predecessor list up to date because
 * we avoid expensive operations like memory allocation
 */
//_inline
bool                Compiler::fgIsPredForBlock(BasicBlock * block,
                                               BasicBlock * blockPred)
{
    flowList   *    pred;

    assert(block); assert(blockPred);

    for (pred = block->bbPreds; pred; pred = pred->flNext)
    {
        if (blockPred == pred->flBlock)
            return true;
    }

    return false;
}


/*****************************************************************************
 * Removes a block from the predecessor list
 */

//_inline
void                Compiler::fgRemovePred(BasicBlock * block,
                                           BasicBlock * blockPred)
{
    flowList   *    pred;

    assert(block); assert(blockPred);
    assert(fgIsPredForBlock(block, blockPred));

    /* Is this the first block in the pred list? */
    if  (blockPred == block->bbPreds->flBlock)
    {
        block->bbPreds = block->bbPreds->flNext;
        return;
    }

    assert(block->bbPreds);
    for (pred = block->bbPreds; pred->flNext; pred = pred->flNext)
    {
        if (blockPred == pred->flNext->flBlock)
        {
            pred->flNext = pred->flNext->flNext;
            return;
        }
    }
}

/*****************************************************************************
 * Replaces a block in the predecessor list
 */

//_inline
void                Compiler::fgReplacePred(BasicBlock * block,
                                            BasicBlock * oldPred,
                                            BasicBlock * newPred)
{
    flowList   *    pred;

    assert(block); assert(oldPred); assert(newPred);
    assert(fgIsPredForBlock(block, oldPred));

    for (pred = block->bbPreds; pred; pred = pred->flNext)
    {
        if (oldPred == pred->flBlock)
        {
            pred->flBlock = newPred;
            return;
        }
    }
}

/*****************************************************************************
 * Add blockPred to the predecessor list of block.
 * Note: a predecessor appears only once although it can have multiple jumps
 * to the block (e.g. switch, conditional jump to the following block, etc.).
 */

//_inline
void                Compiler::fgAddRefPred(BasicBlock * block,
                                           BasicBlock * blockPred,
                                           bool updateRefs,
                                           bool updatePreds)
{
    flowList   *    flow;

    if (updatePreds)
    {
        assert(!fgIsPredForBlock(block, blockPred) ||
               ((blockPred->bbJumpKind == BBJ_COND) && (blockPred->bbNext == blockPred->bbJumpDest)) ||
                (blockPred->bbJumpKind == BBJ_SWITCH));

        flow = (flowList *)compGetMem(sizeof(*flow));

#if     MEASURE_BLOCK_SIZE
        genFlowNodeCnt  += 1;
        genFlowNodeSize += sizeof(*flow);
#endif

        flow->flNext   = block->bbPreds;
        flow->flBlock  = blockPred;
        block->bbPreds = flow;
    }

    if (updateRefs)
        block->bbRefs++;
}

/*****************************************************************************
 *
 *  Function called to update the flow graph information such as bbNums, bbRefs
 *  predecessor list and dominators
 *  For efficiency reasons we can optionaly update only one component at a time,
 *  depending on the specific optimization we are targeting
 */

void                Compiler::fgAssignBBnums(bool updateNums,
                                             bool updateRefs,
                                             bool updatePreds,
                                             bool updateDoms)
{
    BasicBlock  *   block;
    unsigned        num;
    BasicBlock  *   bcall;

    assert(fgFirstBB);

    if (updateNums)
    {
        /* Walk the flow graph, reassign block numbers to keep them in ascending order */
        for (block = fgFirstBB, num = 0; block->bbNext; block = block->bbNext)
        {
            block->bbNum  = ++num;
        }

        /* Make sure to update fgLastBB */

        assert(block);
        block->bbNum  = ++num;
        fgLastBB = block;

        fgBBcount = num;
    }

    if  (updateRefs)
    {
        /* reset the refs count for each basic block */
        for (block = fgFirstBB, num = 0; block; block = block->bbNext)
        {
            block->bbRefs = 0;
        }

        /* the first block is always reacheable! */
        fgFirstBB->bbRefs = 1;
    }

    if  (updatePreds)
    {
        for (block = fgFirstBB, num = 0; block; block = block->bbNext)
        {
            /* CONSIDER: if we already have predecessors computed, free that memory */
            block->bbPreds = 0;
        }
    }

    if  (updateRefs || updatePreds)
    {
        for (block = fgFirstBB; block; block = block->bbNext)
        {
            switch (block->bbJumpKind)
            {
            case BBJ_COND:
            case BBJ_CALL:
            case BBJ_ALWAYS:
                fgAddRefPred(block->bbJumpDest, block, updateRefs, updatePreds);

                /* Is the next block reachable? */

                if  (block->bbJumpKind == BBJ_ALWAYS ||
                     block->bbJumpKind == BBJ_CALL    )
                    break;

                /* Unverified code may end with a conditional jump (dumb compiler) */

                if  (!block->bbNext)
                    break;

                /* Fall through, the next block is also reachable */

            case BBJ_NONE:
                fgAddRefPred(block->bbNext, block, updateRefs, updatePreds);
                break;

            case BBJ_RET:

                /* Connect end of filter to catch handler */

                if (block->bbFlags & BBF_ENDFILTER)
                {
                    fgAddRefPred(block->bbJumpDest, block, updateRefs, updatePreds);
                    break;
                }

                /*  UNDONE: Since it's not a trivial proposition to figure out
                    UNDONE: which blocks may call this one, we'll include all
                    UNDONE: blocks that end in calls (to play it safe).
                 */

                for (bcall = fgFirstBB; bcall; bcall = bcall->bbNext)
                {
                    if  (bcall->bbJumpKind == BBJ_CALL)
                    {
                        assert(bcall->bbNext);
                        fgAddRefPred(bcall->bbNext, block, updateRefs, updatePreds);
                    }
                }

                break;

            case BBJ_THROW:
            case BBJ_RETURN:
                break;

            case BBJ_SWITCH:

                unsigned        jumpCnt = block->bbJumpSwt->bbsCount;
                BasicBlock * *  jumpTab = block->bbJumpSwt->bbsDstTab;

                do
                {
                    fgAddRefPred(*jumpTab, block, updateRefs, updatePreds);
                }
                while (++jumpTab, --jumpCnt);

                break;
            }

            /* Is this block part of a 'try' statement? */

#if 0 // not necessary to allocate memory for these

            if  (block->bbFlags & BBF_HAS_HANDLER)
            {
                unsigned        XTnum;
                EHblkDsc *      HBtab;
                unsigned        blkNum = block->bbNum;

                for (XTnum = 0, HBtab = compHndBBtab;
                     XTnum < info.compXcptnsCount;
                     XTnum++  , HBtab++)
                {
                    /* Any handler may be jumped to from the try block */

                    if  (HBtab->ebdTryBeg->bbNum <= blkNum &&
                         HBtab->ebdTryEnd->bbNum >  blkNum)
                    {
                        fgAddRefPred(HBtab->ebdHndBeg, block, updateRefs, updatePreds);
                            /* same goes for filters */
                        if (HBtab->ebdFlags & JIT_EH_CLAUSE_FILTER)
                            fgAddRefPred(HBtab->ebdFilter, block, updateRefs, updatePreds);
                    }
                }
            }
#endif
        }
    }

    /* update the dominator set
     * UNDONE: currently we are restricted to 64 basic blocks - change that to 128 */

    if (updateDoms && (fgBBcount <= BLOCKSET_SZ))
    {
        flowList *      pred;
        bool            change;
        BLOCKSET_TP     newDom;

        fgComputedDoms = true;

        /* initialize dominator bit vectors to all blocks */

        for (block = fgFirstBB; block; block = block->bbNext)
        {
            if (block == fgFirstBB)
            {
                assert(block->bbNum == 1);
                block->bbDom = genBlocknum2bit(1);
            }
            else
            {
                block->bbDom = (BLOCKSET_TP)0 - 1;
            }
        }

        /* find dominators */

        do
        {
            change = false;

            for (block = fgFirstBB->bbNext; block; block = block->bbNext)
            {
                newDom = (BLOCKSET_TP)0 - 1;

                for (pred = block->bbPreds; pred; pred = pred->flNext)
                {
                    newDom &= pred->flBlock->bbDom;
                }

                newDom |= genBlocknum2bit(block->bbNum);

                if (newDom != block->bbDom)
                {
                    change = true;
                    block->bbDom = newDom;
                }
            }

        }
        while (change);
    }
}

/*****************************************************************************
 *
 *  The following helps find a basic block given its PC offset.
 */

void                Compiler::fgInitBBLookup()
{
    BasicBlock **   dscBBptr;
    BasicBlock  *   tmpBBdesc;

    /* Allocate the basic block table */

    dscBBptr =
    fgBBs = (BasicBlock **)compGetMemA(fgBBcount * sizeof(*fgBBs));

    /* Walk all the basic blocks, filling in the table */

    for (tmpBBdesc = fgFirstBB; tmpBBdesc; tmpBBdesc = tmpBBdesc->bbNext)
    {
        *dscBBptr++ = tmpBBdesc;
    }
    assert(dscBBptr == fgBBs + fgBBcount);
}


BasicBlock *        Compiler::fgLookupBB(unsigned addr)
{
    unsigned        lo;
    unsigned        hi;

    /* Do a binary search */

    for (lo = 0, hi = fgBBcount - 1;;)
    {
        unsigned    mid = (lo + hi) / 2;
        BasicBlock *dsc = fgBBs[mid];

        // We introduce internal blocks for BBJ_CALL. Skip over these.

        while (dsc->bbFlags & BBF_INTERNAL)
        {
            dsc = dsc->bbNext;
            mid++;

            // We skipped over too many. Do a linear search

            if (mid > hi)
            {
                for (unsigned i = 0; i < hi; i++)
                {
                    dsc = fgBBs[i];

                    if (!(dsc->bbFlags & BBF_INTERNAL) && (dsc->bbCodeOffs == addr))
                        return dsc;
                }
                assert(!"fgLookupBB() failed");
            }
        }

        unsigned    pos = dsc->bbCodeOffs;

#ifdef  DEBUG

if  (lo > hi)
    printf("ERROR: Couldn't find basic block at offset %04X\n", addr);

#endif

        assert(lo <= hi);

        if  (pos < addr)
        {
            lo = mid+1;
            continue;
        }

        if  (pos > addr)
        {
            hi = mid-1;
            continue;
        }

        return  dsc;
    }
}


/*****************************************************************************
 *
 *  The 'jump target' array uses the following flags to indicate the kind
 *  of a label is present.
 */

#define JT_NONE         0x01        // merely make sure this is an OK address
#define JT_JUMP         0x02        // 'normal' jump target
#define JT_MULTI        0x04        // target of multiple jumps

inline
void                Compiler::fgMarkJumpTarget(BYTE *jumpTarget, unsigned offs)
{
    /* Make sure we set JT_MULTI if target of multiple jumps */

    assert(JT_MULTI == JT_JUMP << 1);

    jumpTarget[offs] |= (jumpTarget[offs] & JT_JUMP) << 1 | JT_JUMP;
}

/*****************************************************************************
 *
 *  Walk the IL opcodes and for any jumps we find set the appropriate entry
 *  in the 'jumpTarget' table.
 *  Also sets lvAddrTaken in lvaTable[]
 */

void                Compiler::irFindJumpTargets(const BYTE * codeAddr,
                                        size_t       codeSize,
                                        BYTE *       jumpTarget)
{
    int             wideFlag = 0;

    const   BYTE *  codeBegp = codeAddr;
    const   BYTE *  codeEndp = codeAddr + codeSize;


    while (codeAddr < codeEndp)
    {
        OPCODE      opcode;
        unsigned    sz;

        opcode = OPCODE(getU1LittleEndian(codeAddr));
        codeAddr += sizeof(__int8);

DECODE_OPCODE:

        /* Get the size of additional parameters */

        sz = opcodeSizes[opcode];

        switch (opcode)
        {
              signed        jmpDist;
            unsigned        jmpAddr;

            // For CEE_SWITCH
            unsigned        jmpBase;
            unsigned        jmpCnt;

            case CEE_PREFIX1:
                opcode = OPCODE(getU1LittleEndian(codeAddr) + 256);
                codeAddr += sizeof(__int8);
                goto DECODE_OPCODE;

        /* Check for an unconditional jump opcode */

        case CEE_LEAVE:
        case CEE_LEAVE_S:
        case CEE_BR:
        case CEE_BR_S:

            /* Make sure we don't read past the end */

            if  (codeAddr + sz > codeEndp)
                goto TOO_FAR;

            goto BRANCH;

        /* Check for a conditional jump opcode */

        case CEE_BRFALSE:
        case CEE_BRFALSE_S:
        case CEE_BRTRUE:
        case CEE_BRTRUE_S:
        case CEE_BEQ:
        case CEE_BEQ_S:
        case CEE_BGE:
        case CEE_BGE_S:
        case CEE_BGE_UN:
        case CEE_BGE_UN_S:
        case CEE_BGT:
        case CEE_BGT_S:
        case CEE_BGT_UN:
        case CEE_BGT_UN_S:
        case CEE_BLE:
        case CEE_BLE_S:
        case CEE_BLE_UN:
        case CEE_BLE_UN_S:
        case CEE_BLT:
        case CEE_BLT_S:
        case CEE_BLT_UN:
        case CEE_BLT_UN_S:
        case CEE_BNE_UN:
        case CEE_BNE_UN_S:

            /* Make sure we don't read past the end */

            if  (codeAddr + sz >= codeEndp)
                goto TOO_FAR;

            goto BRANCH;

        BRANCH:

            assert(codeAddr + sz <= codeEndp);

            /* Compute the target address of the jump */

            jmpDist = (sz==1) ? getI1LittleEndian(codeAddr)
                              : getI4LittleEndian(codeAddr);
            jmpAddr = (codeAddr - codeBegp) + sz + jmpDist;

            /* Make sure the target address is reasonable */

            if  (jmpAddr >= codeSize)
            {
                BADCODE("code jumps to outer space");
            }

            /* Finally, set the 'jump target' flag */

            fgMarkJumpTarget(jumpTarget, jmpAddr);
            break;

        case CEE_ANN_DATA:
            assert(sz == 4);
            sz += getI4LittleEndian(codeAddr);
            break;

        case CEE_ANN_PHI:
            assert(sz == 0);
            codeAddr += getU1LittleEndian(codeAddr)*2 + 1;
            break;

        case CEE_SWITCH:

            // Make sure we don't go past the end reading the number of cases

            if  (codeAddr + sizeof(DWORD) > codeEndp)
                goto TOO_FAR;

            // Read the number of cases

            jmpCnt = getU4LittleEndian(codeAddr);
            codeAddr += sizeof(DWORD);

            // Find the end of the switch table

            jmpBase = (codeAddr - codeBegp) + jmpCnt*sizeof(DWORD);

            /* Make sure we have room for the switch table */

            if  (jmpBase >= codeSize)
                goto TOO_FAR;

            // jmpBase is also the target of the default case, so mark it

            fgMarkJumpTarget(jumpTarget, jmpBase);

            /* Process all the entries in the jump table */

            while (jmpCnt)
            {
                jmpAddr = jmpBase + getI4LittleEndian(codeAddr);
                codeAddr += 4;

                if  (jmpAddr >= codeSize)
                    BADCODE("jump target out of range");

                fgMarkJumpTarget(jumpTarget, jmpAddr);

                jmpCnt--;
            }

            /* We've now consumed the entire switch opcode */

            continue;

#ifdef DEBUG
        // make certain we did not forget any flow of control instructions
        // by checking the 'ctrl' field in opcode.def.  First filter out all
        // non-ctrl instructions
#       define BREAK(name)          case name: break;
#       define CALL(name)           case name: break;
#       define NEXT(name)           case name: if (opcode == CEE_LDARGA || opcode == CEE_LDARGA_S || \
                                                   opcode == CEE_LDLOCA || opcode == CEE_LDLOCA_S)   \
                                                    goto ADDR_TAKEN;                                 \
                                               else                                                  \
                                                    break;
#       define THROW(name)          case name: break;
#       define RETURN(name)         case name: break;
#       define META(name)
#       define BRANCH(name)
#       define COND_BRANCH(name)
#       define PHI(name)

#       define OPDEF(name,string,pop,push,oprType,opcType,l,s1,s2,ctrl) ctrl(name)
#       include "opcode.def"
#       undef OPDEF

#       undef PHI
#       undef BREAK
#       undef CALL
#       undef NEXT
#       undef THROW
#       undef RETURN
#       undef META
#       undef BRANCH
#       undef COND_BRANCH
        // These dont need any handling
        case CEE_VOLATILE:  // CTRL_META
        case CEE_UNALIGNED: // CTRL_META
        case CEE_TAILCALL:  // CTRL_META
            break;

        // what's left are forgotten ctrl instructions
        default:
            assert(!"Unrecognized control Opcode");
            break;
#else
        case CEE_LDARGA:
        case CEE_LDARGA_S:
        case CEE_LDLOCA:
        case CEE_LDLOCA_S: goto ADDR_TAKEN;
#endif

        ADDR_TAKEN:
            assert(sz == sizeof(BYTE) || sz == sizeof(WORD));
            unsigned varNum;
            varNum = sz == sizeof(BYTE) ? getU1LittleEndian(codeAddr)
                                        : getU2LittleEndian(codeAddr);
            if (opcode == CEE_LDLOCA || opcode == CEE_LDLOCA_S)
                varNum += info.compArgsCount;
            else
                varNum = impArgNum(varNum); // account for possible hidden param
            lvaTable[varNum].lvAddrTaken = 1;
            break;
        }

        /* Skip any operands this opcode may have */

        assert(sz >= 0); codeAddr += sz;
    }

    if  (codeAddr != codeEndp)
    {
    TOO_FAR:
        BADCODE("Code ends in the middle of an opcode, or"
                "there is a branch past the end of the method");
    }
}

/*****************************************************************************
 *
 *  Mark the target of a jump - this is used to discover loops by noticing
 *  backward jumps.
 */

void                Compiler::fgMarkJumpTarget(BasicBlock *srcBB,
                                               BasicBlock *dstBB)
{
    /* For now assume all backward jumps create loops */

    if  (srcBB->bbNum >= dstBB->bbNum)
        dstBB->bbFlags |= BBF_LOOP_HEAD;
}

/*****************************************************************************
 *
 *  Walk the IL opcodes to create the basic blocks.
 */

void                Compiler::fgFindBasicBlocks(const BYTE * codeAddr,
                                                size_t       codeSize,
                                                BYTE *       jumpTarget)
{
    int             wideFlag = 0;

    const   BYTE *  codeBegp = codeAddr;
    const   BYTE *  codeEndp = codeAddr + codeSize;

    unsigned        curBBoffs;

    BasicBlock  *   curBBdesc;

#if OPTIMIZE_QMARK
    unsigned        lastOp = CEE_NOP;
#endif

    bool            tailCall = false; // set by CEE_TAILCALL and cleared by CEE_CALLxxx

    /* Initialize the basic block list */

    fgFirstBB = 0;
    fgLastBB  = 0;
    fgBBcount = 0;

    /* Clear the beginning offset for the first BB */

    curBBoffs = 0;

#ifdef DEBUGGING_SUPPORT
    if (opts.compDbgCode && info.compLocalVarsCount>0)
    {
        compResetScopeLists();

        // Ignore scopes beginning at offset 0
        while (compGetNextEnterScope(0));
        while(compGetNextExitScope(0));
    }
#endif



    do
    {
        OPCODE      opcode;
        unsigned    sz;

        BBjumpKinds     jmpKind = BBJ_NONE;
        unsigned        jmpAddr;

        unsigned        bbFlags = 0;

        BBswtDesc   *   swtDsc = 0;

        unsigned        nxtBBoffs;

        opcode = OPCODE(getU1LittleEndian(codeAddr));
        codeAddr += sizeof(__int8);

DECODE_OPCODE:

        /* Get the size of additional parameters */

        sz = opcodeSizes[opcode];

        switch (opcode)
        {
            signed        jmpDist;

            case CEE_PREFIX1:
                opcode = OPCODE(getU1LittleEndian(codeAddr) + 256);
                codeAddr += sizeof(__int8);
                goto DECODE_OPCODE;

        /* Check to see if we have a jump/return opcode */

        case CEE_BRFALSE:
        case CEE_BRFALSE_S:
        case CEE_BRTRUE:
        case CEE_BRTRUE_S:

        case CEE_BEQ:
        case CEE_BEQ_S:
        case CEE_BGE:
        case CEE_BGE_S:
        case CEE_BGE_UN:
        case CEE_BGE_UN_S:
        case CEE_BGT:
        case CEE_BGT_S:
        case CEE_BGT_UN:
        case CEE_BGT_UN_S:
        case CEE_BLE:
        case CEE_BLE_S:
        case CEE_BLE_UN:
        case CEE_BLE_UN_S:
        case CEE_BLT:
        case CEE_BLT_S:
        case CEE_BLT_UN:
        case CEE_BLT_UN_S:
        case CEE_BNE_UN:
        case CEE_BNE_UN_S:

            jmpKind = BBJ_COND;
            goto JMP;


        case CEE_LEAVE:
        case CEE_LEAVE_S:

            // Assume we are jumping out of a finally-protected try. Else
            // we will bash the BasicBlock to BBJ_ALWAYS
            jmpKind = BBJ_CALL;
            goto JMP;


        case CEE_BR:
        case CEE_BR_S:
            jmpKind = BBJ_ALWAYS;
            goto JMP;

        JMP:

            /* Compute the target address of the jump */

            jmpDist = (sz==1) ? getI1LittleEndian(codeAddr)
                              : getI4LittleEndian(codeAddr);
            jmpAddr = (codeAddr - codeBegp) + sz + jmpDist;
            break;

        case CEE_ANN_DATA:
            assert(sz == 4);
            sz += getI4LittleEndian(codeAddr);
            break;

        case CEE_ANN_PHI:
            assert(sz == 0);
            codeAddr += getU1LittleEndian(codeAddr)*2 + 1;
            break;

        case CEE_SWITCH:
            {
                unsigned        jmpBase;
                unsigned        jmpCnt; // # of switch cases (excluding defualt)

                BasicBlock * *  jmpTab;
                BasicBlock * *  jmpPtr;

                /* Allocate the switch descriptor */

                swtDsc = (BBswtDesc *)compGetMem(sizeof(*swtDsc));

                /* Read the number of entries in the table */

                jmpCnt = getU4LittleEndian(codeAddr); codeAddr += 4;

                /* Compute  the base offset for the opcode */

                jmpBase = (codeAddr - codeBegp) + jmpCnt*sizeof(DWORD);;

                /* Allocate the jump table */

                jmpPtr =
                jmpTab = (BasicBlock **)compGetMem((jmpCnt+1)*sizeof(*jmpTab));

                /* Fill in the jump table */

                for (unsigned count = jmpCnt; count; count--)
                {
                    /* Store the target of the jump as a pointer [ISSUE: is this safe?]*/

                    jmpDist   = getI4LittleEndian(codeAddr);
                    codeAddr += 4;

//                  printf("table switch: target = %04X\n", jmpBase + jmpDist);
                    *jmpPtr++ = (BasicBlock*)(jmpBase + jmpDist);
                }

                /* Append the default label to the target table */

                *jmpPtr++ = (BasicBlock*)jmpBase;

                /* Make sure we found the right number of labels */

                assert(jmpPtr == jmpTab + jmpCnt + 1);

                /* Compute the size of the switch opcode operands */

                sz = sizeof(DWORD) + jmpCnt*sizeof(DWORD);

                /* Fill in the remaining fields of the switch descriptor */

                swtDsc->bbsCount  = jmpCnt + 1;
                swtDsc->bbsDstTab = jmpTab;

                /* This is definitely a jump */

                jmpKind = BBJ_SWITCH;
            }
            goto GOT_ENDP;

        case CEE_ENDFILTER:
            bbFlags |= (BBF_ENDFILTER | BBF_DONT_REMOVE);

            // Fall through
        case CEE_ENDFINALLY:
            jmpKind = BBJ_RET;
            break;

        case CEE_TAILCALL:
            tailCall = true;
            break;

        case CEE_CALL:
        case CEE_CALLVIRT:
        case CEE_CALLI:
            if (!tailCall)
                break;

            tailCall = false; // reset the flag

            /* For tail call, we just call CPX_TAILCALL, and it jumps to the
               target. So we dont need an epilog - just like CPX_THROW.
               Make the block BBJ_RETURN, but we will bash it to BBJ_THROW
               if the tailness of the call is satisfied.
               NOTE : The next instruction is guaranteed to be a CEE_RETURN
               and it will create another BasicBlock. But there may be an
               jump directly to that CEE_RETURN. If we want to avoid creating
               an unnecessary block, we need to check if the CEE_RETURN is
               the target of a jump.
             */

            // fall-through

        case CEE_JMP:
            /* These are equivalent to a return from the current method
               But instead of directly returning to the caller we jump and
               execute something else in between */
        case CEE_RET:
            jmpKind = BBJ_RETURN;
            break;

        case CEE_THROW:
        case CEE_RETHROW:
            jmpKind = BBJ_THROW;
            break;

#ifdef DEBUG
        // make certain we did not forget any flow of control instructions
        // by checking the 'ctrl' field in opcode.def. First filter out all
        // non-ctrl instructions
#       define BREAK(name)          case name: break;
#       define NEXT(name)           case name: break;
#       define CALL(name)
#       define THROW(name)
#       define RETURN(name)
#       define META(name)
#       define BRANCH(name)
#       define COND_BRANCH(name)
#       define PHI(name)

#       define OPDEF(name,string,pop,push,oprType,opcType,l,s1,s2,ctrl) ctrl(name)
#       include "opcode.def"
#       undef OPDEF

#       undef PHI
#       undef BREAK
#       undef CALL
#       undef NEXT
#       undef THROW
#       undef RETURN
#       undef META
#       undef BRANCH
#       undef COND_BRANCH

        // These ctrl-flow opcodes dont need any special handling
        case CEE_NEWOBJ:    // CTRL_CALL
        case CEE_VOLATILE:  // CTRL_META
        case CEE_UNALIGNED: // CTRL_META
            break;

        // what's left are forgotten instructions
        default:
            assert(!"Unrecognized control Opcode");
            break;
#endif
        }

        /* Jump over the operand */

        codeAddr += sz;

GOT_ENDP:

        /* Make sure a jump target isn't in the middle of our opcode */

        if  (sz)
        {
            unsigned offs = codeAddr - codeBegp - sz; // offset of the operand

            for (unsigned i=0; i<sz; i++, offs++)
            {
                if  (jumpTarget[offs] != 0)
                    BADCODE("jump into the middle of an opcode");
            }
        }

        assert(!tailCall || opcode == CEE_TAILCALL);

        /* Compute the offset of the next opcode */

        nxtBBoffs = codeAddr - codeBegp;

#ifdef  DEBUGGING_SUPPORT

        bool foundScope     = false;

        if (opts.compDbgCode && info.compLocalVarsCount>0)
        {
            while(compGetNextEnterScope(nxtBBoffs))  foundScope = true;
            while(compGetNextExitScope(nxtBBoffs))   foundScope = true;
        }
#endif

        /* Do we have a jump? */

        if  (jmpKind == BBJ_NONE)
        {
            /* No jump; make sure we don't fall off the end of the function */

            if  (codeAddr == codeEndp)
                BADCODE("missing return opcode");

            /* If a label follows this opcode, we'll have to make a new BB */

            assert(JT_NONE == 1);// needed for the "<=" below to work

            bool makeBlock = jumpTarget[nxtBBoffs] != 0;

#ifdef  DEBUGGING_SUPPORT
            if (!makeBlock && foundScope)
            {
                makeBlock = true;
#ifdef DEBUG
                if (verbose) printf("Splitting at BBoffs = %04u\n", nxtBBoffs);
#endif
            }
#endif
            if (!makeBlock)
                continue;
        }

        /* We need to create a new basic block */

        curBBdesc = fgNewBasicBlock(jmpKind);

        curBBdesc->bbFlags    = bbFlags;

        curBBdesc->bbCodeOffs = curBBoffs;
        curBBdesc->bbCodeSize = nxtBBoffs - curBBoffs;

        switch(jmpKind)
        {
            unsigned    ehNum;
            unsigned    encFinallys; // How many finallys enclose this "leave"

        case BBJ_CALL:

            /* Find all finally's which protect the current block but not the
               destination block. We will create BBJ_CALL blocks for these as
               we are implicitly supposed to call the finallys. For n finallys,
               we have n+1 blocks. '*' indicates BBF_INTERNAL blocks.
               --> BBJ_CALL(1), BBJ_CALL*(2), ... BBJ_CALL*(n), BBJ_ALWAYS*
            */

            for (ehNum = 0, encFinallys = 0; ehNum < info.compXcptnsCount; ehNum++)
            {
                JIT_EH_CLAUSE clause;
                eeGetEHinfo(ehNum, &clause);

                DWORD tryBeg = clause.TryOffset;
                DWORD tryEnd = clause.TryOffset+clause.TryLength;

                // Are we jumping out of a finally-protected try block

                if ((clause.Flags & JIT_EH_CLAUSE_FINALLY)   &&
                     jitIsBetween(curBBoffs, tryBeg, tryEnd) &&
                    !jitIsBetween(jmpAddr,   tryBeg, tryEnd))
                {
                    if (encFinallys == 0)
                    {
                        // For the first finally, we will use the BB created above
                    }
                    else
                    {
                        curBBdesc = fgNewBasicBlock(BBJ_CALL);

                        curBBdesc->bbFlags = BBF_INTERNAL;
                        curBBdesc->bbCodeOffs = curBBdesc->bbCodeSize = 0;
                    }

                    // Mark the offset of the finally to call
                    curBBdesc->bbJumpOffs = clause.HandlerOffset;

                    encFinallys++;
                }
            }

            // Now jump to target

            if (encFinallys == 0)
            {
                // "leave" used as a "br". Dont need to create a new block

                assert(curBBdesc->bbJumpKind == BBJ_CALL);
                curBBdesc->bbJumpKind = BBJ_ALWAYS; // Bash the bbJumpKind
            }
            else
            {
                // BBJ_CALL blocks can only fall-through. Insert a BBJ_ALWAYS
                // which can jump to the target
                curBBdesc = fgNewBasicBlock(BBJ_ALWAYS);
                curBBdesc->bbFlags = BBF_INTERNAL;
            }

            assert(curBBdesc->bbJumpKind == BBJ_ALWAYS);
            curBBdesc->bbJumpOffs = jmpAddr;
            break;

        case BBJ_SWITCH:
            curBBdesc->bbJumpSwt  = swtDsc;
            break;

        default:
            curBBdesc->bbJumpOffs = jmpAddr;
            break;
        }

//      printf("BB %08X at PC %u\n", curBBdesc, curBBoffs);

        /* Remember where the next BB will start */

        curBBoffs = nxtBBoffs;
    }
    while (codeAddr <  codeEndp);

    assert(codeAddr == codeEndp);

    /* Create the basic block lookup tables */

    fgInitBBLookup();

    /* Walk all the basic blocks, filling in the target addresses */

    for (curBBdesc = fgFirstBB;
         curBBdesc;
         curBBdesc = curBBdesc->bbNext)
    {
        switch (curBBdesc->bbJumpKind)
        {
        case BBJ_COND:
        case BBJ_CALL:
        case BBJ_ALWAYS:
            curBBdesc->bbJumpDest = fgLookupBB(curBBdesc->bbJumpOffs);
            curBBdesc->bbJumpDest->bbRefs++;
            fgMarkJumpTarget(curBBdesc, curBBdesc->bbJumpDest);

            /* Is the next block reachable? */

            if  (curBBdesc->bbJumpKind == BBJ_ALWAYS)
                break;

            /* Unverified code may end with a conditional jump (dumb compiler) */

            if  (!curBBdesc->bbNext)
                break;

            // Fall through, the next block is also reachable

        case BBJ_NONE:
            curBBdesc->bbNext->bbRefs++;
            break;

        case BBJ_RET:
        case BBJ_THROW:
        case BBJ_RETURN:
            break;

        case BBJ_SWITCH:

            unsigned        jumpCnt = curBBdesc->bbJumpSwt->bbsCount;
            BasicBlock * *  jumpPtr = curBBdesc->bbJumpSwt->bbsDstTab;

            do
            {
                *jumpPtr = fgLookupBB(*((unsigned*)jumpPtr));
                fgMarkJumpTarget(curBBdesc, *jumpPtr);
            }
            while (++jumpPtr, --jumpCnt);

            /* Default case of CEE_SWITCH (next block), is at end of jumpTab[] */

            assert(*(jumpPtr-1) == curBBdesc->bbNext);
            break;
        }
    }
}

/*****************************************************************************
 *
 *  Main entry point to discover the basic blocks for the current function.
 *
 *  Note that this code duplicates that found in the IL verifier.
 */

int                 Compiler::fgFindBasicBlocks()
{
    /* Allocate the 'jump target' vector */
    BYTE* jumpTarget = (BYTE *)compGetMemA(info.compCodeSize);
    memset(jumpTarget, 0, info.compCodeSize);

    /* Assume the IL opcodes are read-only */

    info.compBCreadOnly = true;

    /* Walk the IL opcodes to find all jump targets */

    irFindJumpTargets(info.compCode, info.compCodeSize, jumpTarget);

    /* Are there any exception handlers? */

    if  (info.compXcptnsCount)
    {
        unsigned        XTnum;

        /* Check and mark all the exception handlers */

        for (XTnum = 0; XTnum < info.compXcptnsCount; XTnum++)
        {
            JIT_EH_CLAUSE clause;
            eeGetEHinfo(XTnum, &clause);
            assert(clause.HandlerLength != -1); // @DEPRECATED

            //CONSIDER: simply ignore this entry and continue compilation

            if (clause.TryLength <= 0)
                NO_WAY("try block length <=0");

            //              printf("Mark 'try' block: [%02u..%02u]\n", hndBeg, hndEnd);

            /* Mark the 'try' block extent and the handler itself */

            if  (jumpTarget[clause.TryOffset + clause.TryLength        ] < JT_NONE)
                jumpTarget[clause.TryOffset + clause.TryLength        ] = JT_NONE;
            if  (jumpTarget[clause.TryOffset                           ] < JT_NONE)
                jumpTarget[clause.TryOffset                           ] = JT_NONE;
            if  (jumpTarget[clause.HandlerOffset                       ] < JT_NONE)
                jumpTarget[clause.HandlerOffset                       ] = JT_NONE;
            if  (jumpTarget[clause.HandlerOffset + clause.HandlerLength] < JT_NONE)
                jumpTarget[clause.HandlerOffset + clause.HandlerLength] = JT_NONE;
            if (clause.Flags & JIT_EH_CLAUSE_FILTER)
                if  (jumpTarget[clause.FilterOffset                    ] < JT_NONE)
                    jumpTarget[clause.FilterOffset                    ] = JT_NONE;
        }
    }

    /* Now create the basic blocks */

    fgFindBasicBlocks(info.compCode, info.compCodeSize, jumpTarget);

    /* Mark all blocks within 'try' blocks as such */

    if  (info.compXcptnsCount)
    {
        unsigned        XTnum;

        EHblkDsc *      handlerTab;

        /* Allocate the exception handler table */

        handlerTab   =
            compHndBBtab = (EHblkDsc *) compGetMem(info.compXcptnsCount *
            sizeof(*compHndBBtab));

        for (XTnum = 0; XTnum < info.compXcptnsCount; XTnum++)
        {
            JIT_EH_CLAUSE clause;
            eeGetEHinfo(XTnum, &clause);
            assert(clause.HandlerLength != -1); // @DEPRECATED

            BasicBlock  *   tryBegBB;
            BasicBlock  *   tryEndBB;
            BasicBlock  *   hndBegBB;
            BasicBlock  *   hndEndBB;
            BasicBlock  *   filtBB;

            if  (clause.TryOffset+clause.TryLength >= info.compCodeSize)
                NO_WAY("end of try block at/beyond end of method");
            if  (clause.HandlerOffset+clause.HandlerLength > info.compCodeSize)
                NO_WAY("end of hnd block beyond end of method");

            /* Convert the various addresses to basic blocks */

            tryBegBB    = fgLookupBB(clause.TryOffset);
            tryEndBB    = fgLookupBB(clause.TryOffset+clause.TryLength);
            hndBegBB    = fgLookupBB(clause.HandlerOffset);

            if (clause.HandlerOffset+clause.HandlerLength == info.compCodeSize)
                hndEndBB = NULL;
            else
            {
                hndEndBB= fgLookupBB(clause.HandlerOffset+clause.HandlerLength);
                hndEndBB->bbFlags   |= BBF_DONT_REMOVE;
            }

            if (clause.Flags & JIT_EH_CLAUSE_FILTER)
            {
                filtBB = handlerTab->ebdFilter = fgLookupBB(clause.FilterOffset);
                filtBB->bbCatchTyp = BBCT_FILTER;

                /* Remember the corresponding catch handler */

                filtBB->bbFilteredCatchHandler = hndBegBB;

                hndBegBB->bbCatchTyp = BBCT_FILTER_HANDLER;
            }
            else
            {
                handlerTab->ebdTyp = clause.ClassToken;

                if (clause.Flags & JIT_EH_CLAUSE_FAULT)
                {
                    hndBegBB->bbCatchTyp  = BBCT_FAULT;
                }
                else if (clause.Flags & JIT_EH_CLAUSE_FINALLY)
                {
                    hndBegBB->bbCatchTyp  = BBCT_FINALLY;
                }
                else
                {
                    hndBegBB->bbCatchTyp  = clause.ClassToken;

                    // These values should be non-zero value that will
                    // not colide with real tokens for bbCatchTyp
                    assert(clause.ClassToken != 0);
                    assert(clause.ClassToken != BBCT_FAULT);
                    assert(clause.ClassToken != BBCT_FINALLY);
                    assert(clause.ClassToken != BBCT_FILTER);
                    assert(clause.ClassToken != BBCT_FILTER_HANDLER);
                }
            }

            /* Append the info to the table of try block handlers */

            handlerTab->ebdFlags    = clause.Flags;
            handlerTab->ebdTryBeg   = tryBegBB;
            handlerTab->ebdTryEnd   = tryEndBB;
            handlerTab->ebdHndBeg   = hndBegBB;
            handlerTab->ebdHndEnd   = hndEndBB;
            handlerTab++;

            /* Mark the initial block as a 'try' block */

            tryBegBB->bbFlags |= BBF_IS_TRY;

            /* Prevent future optimizations of removing the first and last block
            * of a TRY block and the first block of an exception handler
            *
            * CONSIDER: Allow removing the last block of the try, but have to mark it
            * with a new flag BBF_END_TRY and when removing it propagate the flag to the
            * previous block and update the exception handler table */

            tryBegBB->bbFlags   |= BBF_DONT_REMOVE;
            tryEndBB->bbFlags   |= BBF_DONT_REMOVE;
            hndBegBB->bbFlags   |= BBF_DONT_REMOVE;

            if (clause.Flags & JIT_EH_CLAUSE_FILTER)
                filtBB->bbFlags |= BBF_DONT_REMOVE;

            /* Mark all BB's within the covered range */

            unsigned tryEndOffs = clause.TryOffset+clause.TryLength;

            for (BasicBlock * blk = tryBegBB;
            blk && (blk->bbCodeOffs < tryEndOffs);
            blk = blk->bbNext)
            {
                /* Mark this BB as belonging to a 'try' block */

                blk->bbFlags   |= BBF_HAS_HANDLER;

                // ISSUE: Will the following work correctly for nested try's?

                if (!blk->bbTryIndex)
                    blk->bbTryIndex = XTnum + 1;

#if 0
                printf("BB is [%02u..%02u], index is %02u, 'try' is [%02u..%02u]\n",
                    blk->bbCodeOffs,
                    blk->bbCodeOffs + blk->bbCodeSize,
                    XTnum+1,
                    clause.TryOffset,
                    clause.TryOffset+clause.TryLength);
#endif

                /* Note: the BB can't span the 'try' block */

                if (!(blk->bbFlags & BBF_INTERNAL))
                {
                    assert(clause.TryOffset <= blk->bbCodeOffs);
                    assert(clause.TryOffset+clause.TryLength >= blk->bbCodeOffs + blk->bbCodeSize ||
                        clause.TryOffset+clause.TryLength == clause.TryOffset);
                }
            }

        }
    }
    return  0;
}

/*****************************************************************************
 *  Returns the handler nesting levels of the block.
 *  *pFinallyNesting is set to the nesting level of the inner-most
 *      finally-protected try the block is in.
 */

unsigned            Compiler::fgHandlerNesting(BasicBlock * curBlock,
                                               unsigned   * pFinallyNesting)
{
    unsigned        curNesting; // How many handlers is the block in
    unsigned        tryFin;     // curNesting when we see innermost finally-protected try
    unsigned        XTnum;
    EHblkDsc *      HBtab;

    assert(!(curBlock->bbFlags & BBF_INTERNAL));

    /* We find the blocks's handler nesting level by walking over the
       complete exception table and find enclosing clauses.
       CONSIDER: Store the nesting level with the block */

    for (XTnum = 0, HBtab = compHndBBtab, curNesting = 0, tryFin = -1;
         XTnum < info.compXcptnsCount;
         XTnum++  , HBtab++)
    {
        assert(HBtab->ebdTryBeg && HBtab->ebdHndBeg);

        if ((HBtab->ebdFlags & JIT_EH_CLAUSE_FINALLY) &&
            jitIsBetween(curBlock->bbCodeOffs,
                         HBtab->ebdTryBeg->bbCodeOffs,
                         HBtab->ebdTryEnd ? HBtab->ebdTryEnd->bbCodeOffs : (IL_OFFSET)-1) &&
            tryFin == -1)
        {
            tryFin = curNesting;
        }
        else
        if (jitIsBetween(curBlock->bbCodeOffs,
                         HBtab->ebdHndBeg->bbCodeOffs,
                         HBtab->ebdHndEnd ? HBtab->ebdHndEnd->bbCodeOffs : (IL_OFFSET) -1))
        {
            curNesting++;
        }
    }

    if  (tryFin == -1)
        tryFin = curNesting;

    if  (pFinallyNesting)
        *pFinallyNesting = curNesting - tryFin;

    return curNesting;
}

/*****************************************************************************
 *
 *  Import the basic blocks of the procedure.
 */

void                    Compiler::fgImport()
{
    fgHasPostfix = false;

#if HOIST_THIS_FLDS
    if (opts.compMinOptim || opts.compDbgCode)
        optThisFldDont = true;
    else
        optHoistTFRinit();
#endif

    impImport(fgFirstBB);
}

/*****************************************************************************
 *
 *  Convert the given node into a call to the specified helper passing
 *  the given argument list.
 */

GenTreePtr          Compiler::fgMorphIntoHelperCall(GenTreePtr tree, int helper,
                                                    GenTreePtr args)
{
    tree->ChangeOper(GT_CALL);

    tree->gtFlags              &= (GTF_GLOB_EFFECT|GTF_PRESERVE);
    tree->gtFlags              |= GTF_CALL|GTF_CALL_REGSAVE;

    tree->gtCall.gtCallType     = CT_HELPER;
    tree->gtCall.gtCallMethHnd  = eeFindHelper(helper);
    tree->gtCall.gtCallArgs     = args;
    tree->gtCall.gtCallObjp     =
    tree->gtCall.gtCallVptr     = 0;
    tree->gtCall.gtCallMoreFlags = 0;
    tree->gtCall.gtCallCookie   = 0;

    /* NOTE: we assume all helper arguments are enregistered on RISC */

#if TGT_RISC
    genNonLeaf = true;
#endif

#if USE_FASTCALL

    /* Perform the morphing right here if we're using fastcall */

    tree->gtCall.gtCallRegArgs  = 0;
    tree = fgMorphArgs(tree);

#endif

//
//  ISSUE: Is the following needed? After all, we already have a call ...
//
//  if  (args)
//      tree->gtFlags      |= (args->gtFlags & GTF_GLOB_EFFECT);

    return tree;
}

/*****************************************************************************
 * This should not be referenced by anyone now. Set its values to garbage
 * to catch extra references
 */

inline
void                DEBUG_DESTROY_NODE(GenTreePtr tree)
{
#ifdef DEBUG
    // Store gtOper into gtRegNum to find out what this node was if needed
    tree->gtRegNum      = (regNumber) tree->gtOper;

    tree->gtOper        = GT_COUNT;
    tree->gtType        = TYP_UNDEF;
    tree->gtOp.gtOp1    =
    tree->gtOp.gtOp2    = NULL;
    tree->gtFlags       = 0xFFFFFFFF;
#endif
}

/*****************************************************************************
 *
 *  Morph a cast node (we perform some very simple transformations here).
 */

GenTreePtr          Compiler::fgMorphCast(GenTreePtr tree)
{
    GenTreePtr      oper;
    var_types       srct;
    var_types       dstt;

    int             CPX;

    assert(tree->gtOper == GT_CAST);

    /* The first  sub-operand is the thing being cast */

    oper = tree->gtOp.gtOp1;
    srct = oper->TypeGet();

    /* The second sub-operand yields the 'real' type */

    assert(tree->gtOp.gtOp2);
    assert(tree->gtOp.gtOp2->gtOper == GT_CNS_INT);

    dstt = (var_types)tree->gtOp.gtOp2->gtIntCon.gtIconVal;

#if TGT_IA64

    // ISSUE: Why do we keep getting double->double casts ?

    if  (srct == dstt)
        goto REMOVE_CAST;

#endif

    /* See if the cast has to be done in two steps.  R -> I */

    if (varTypeIsFloating(srct) && !varTypeIsFloating(dstt))
    {
            // We only have a double variant of the overflow instr, so we promote if it is a float
            // @TODO this eliminates the need for the FLT2INT to int helper, so remove it
        if (srct == TYP_FLOAT)
            oper = gtNewOperNode(GT_CAST, TYP_DOUBLE, oper, gtNewIconNode(TYP_DOUBLE));

            // do we need to do it in two steps R -> I, I -> smallType
        if (genTypeSize(dstt) < sizeof(void*))
        {
            oper = gtNewOperNode(GT_CALL, TYP_INT, oper, gtNewIconNode(TYP_INT));
            oper->ChangeOper(GT_CAST);
            oper->gtFlags |= (tree->gtFlags & (GTF_OVERFLOW|GTF_EXCEPT));
        }

        srct = oper->TypeGet();
    }

    /* Do we have to do two step I8 -> I -> Small Type? */

    else if (genActualType(srct) == TYP_LONG && dstt < TYP_INT)
    {
        oper = gtNewOperNode(GT_CAST, TYP_INT, oper, gtNewIconNode(TYP_INT));
        oper->gtFlags |= (tree->gtFlags & (GTF_OVERFLOW|GTF_EXCEPT));
        srct = oper->TypeGet();
    }
#if!TGT_IA64
    // Do we have to do two step U4/8 -> R4/8 ?
    else if ((tree->gtFlags & GTF_UNSIGNED) && varTypeIsFloating(dstt))
    {
        if (genActualType(srct) == TYP_LONG)
        {
            oper = fgMorphTree(oper);
            CPX = CPX_ULNG2DBL;
            goto CALL;
        }
        else
        {
            oper = gtNewOperNode(GT_CALL, TYP_LONG, oper, gtNewIconNode(TYP_ULONG));
            oper->ChangeOper(GT_CAST);
            oper->gtFlags |= (tree->gtFlags & (GTF_OVERFLOW|GTF_EXCEPT|GTF_UNSIGNED));
        }
        srct = oper->TypeGet();
    }
#endif

    /* remove pointless casts. (floating point casts truncate precision, however) */
    if (genTypeSize(srct) == genTypeSize(dstt) && !varTypeIsFloating(srct) && !varTypeIsFloating(dstt))
        {
                if (srct == dstt)                       // Certainly if they are identical it is pointless
                        goto REMOVE_CAST;

                if (tree->gtOverflow()) {
                                // if overlow, the sign vs unsigned must match
                        bool isSrcUnsigned = (tree->gtFlags & GTF_UNSIGNED) != 0;
                        if (varTypeIsUnsigned(dstt) == isSrcUnsigned)
                                goto REMOVE_CAST;
                        }
                else
                        if (genTypeSize(srct) >= sizeof(void*))         // exclude small types
                                goto REMOVE_CAST;
        }

    if (tree->gtOverflow())
    {
        /* There is no conversion to FP types, with overflow checks */

        assert(varTypeIsIntegral(dstt));

        /* Process the operand */

        tree->gtOp.gtOp1 = oper = fgMorphTree(oper);

        /* Reset call flag - DO NOT reset the exception flag */

        tree->gtFlags &= ~GTF_CALL;

        /* If the operand is a constant, we'll fold it */

        if  (oper->OperIsConst())
        {
            tree = gtFoldExprConst(tree);    // This may not fold the constant (NaN ...)
            if (tree->OperKind() & GTK_CONST)
                return tree;
            if (tree->gtOper != GT_CAST)
                return fgMorphTree(tree);
            assert(tree->gtOp.gtOp1 == oper); // unchanged
        }

        /* Just in case new side effects were introduced */

        tree->gtFlags |= (oper->gtFlags & GTF_GLOB_EFFECT);

        fgAddCodeRef(compCurBB, compCurBB->bbTryIndex, ACK_OVERFLOW, fgPtrArgCntCur);

        if (varTypeIsIntegral(srct))
        {
            /* We just need to check that the value fits into dstt, and
             * throw an expection if needed. No other work has to be done
             */

            return tree;
        }
        else
        {
            /* This must be conv.r8.i4 or conv.r8.i8 */

            assert(srct == TYP_DOUBLE);

            switch (dstt)
            {
                        case TYP_UINT:
                                CPX = CPX_DBL2UINT_OVF;
                                goto CALL;
            case TYP_INT:
                CPX = CPX_DBL2INT_OVF;
                goto CALL;
                        case TYP_ULONG:
                CPX = CPX_DBL2ULNG_OVF;
                goto CALL;
            case TYP_LONG:
                CPX = CPX_DBL2LNG_OVF;
                goto CALL;

            default:
                assert(!"Unexpected dstt");
            }
        }
    }

    /* Is this a cast of an integer to a long? */

    if  ((dstt == TYP_INT  || dstt == TYP_UINT ) &&
         genActualType(srct) == TYP_LONG && oper->gtOper == GT_AND)
    {
        /* Special case: (int)(long & small_lcon) */

        if  (oper->gtOper == GT_AND)
        {
            GenTreePtr      and1 = oper->gtOp.gtOp1;
            GenTreePtr      and2 = oper->gtOp.gtOp2;

            if  (and2->gtOper == GT_CNS_LNG)
            {
                unsigned __int64 lval = and2->gtLngCon.gtLconVal;

                if  (!(lval & ((__int64)0xFFFFFFFF << 32)))
                {
                    /* Change "(int)(long & lcon)" into "(int)long & icon" */

                    and2->gtOper             = GT_CNS_INT;
                    and2->gtType             = TYP_INT;
                    and2->gtIntCon.gtIconVal = (int)lval;

                    tree->gtOper             = GT_AND;
                    tree->gtOp.gtOp1         = gtNewCastNode(TYP_INT, and1, tree->gtOp.gtOp2);
                    tree->gtOp.gtOp2         = and2;

                    tree = fgMorphTree(tree);
                    return tree;
                }
            }
        }

        /* Try to narrow the operand of the cast */

        if  (opts.compFlags & CLFLG_TREETRANS)
        {
            if  (optNarrowTree(oper, TYP_LONG, TYP_INT, false))
            {
                DEBUG_DESTROY_NODE(tree);

                optNarrowTree(oper, TYP_LONG, TYP_INT,  true);
                oper = fgMorphTree(oper);
                return oper;
            }
            else
            {
//              printf("Could not narrow:\n"); gtDispTree(oper);
            }
        }
    }

    assert(tree->gtOper == GT_CAST);
    assert(!tree->gtOverflow());

    /* Process the operand */

    tree->gtOp.gtOp1 = oper = fgMorphTree(oper);

    /* Reset exception flags */

    tree->gtFlags &= ~(GTF_CALL | GTF_EXCEPT);

    /* Just in case new side effects were introduced */

    tree->gtFlags |= (oper->gtFlags & GTF_GLOB_EFFECT);

    /* If the operand is a constant, we'll fold it */

    if  (oper->OperIsConst())
    {
        tree = gtFoldExprConst(tree);    // This may not fold the constant (NaN ...)
        if (tree->OperKind() & GTK_CONST)
            return tree;
        if (tree->gtOper != GT_CAST)
                return fgMorphTree(tree);
        assert(tree->gtOp.gtOp1 == oper); // unchanged
    }

    /* The "real" type of the "oper" node might have changed during
     * its morphing by other casts */

    srct = oper->TypeGet();

    /* Are we casting pointers to int etc */

    if  (varTypeIsI(srct) && varTypeIsI(dstt))
        goto USELESS_CAST;

    /* Is this an integer cast? */

    if  (varTypeIsIntegral(srct) && varTypeIsIntegral(dstt))
    {
        /* Is this a narrowing cast? */

        if  (genTypeSize(srct) > genTypeSize(dstt))
        {
            /* Narrowing integer cast -- can we just bash the operand type? */

            switch (oper->gtOper)
            {
            case GT_IND:

                /* Merely bash the type of the operand and get rid of the cast */

                oper->gtType = dstt;
                goto USELESS_CAST;
            }

            // CONSIDER: Try to narrow the operand (e.g. change "int+int"
            // CONSIDER: to be "char + char").
        }
        else
        {
            /* This is a widening or equal cast */

            // Remove cast of integral types with the same length

            if (genTypeSize(srct) == genTypeSize(dstt))
            {
                // TYP_INT <--> TYP_UINT && TYP_LONG <-->TYP_ULONG are useless

                if (genTypeSize(srct) >= genTypeSize(TYP_I_IMPL))
                    goto USELESS_CAST;

                /* For smaller types, merely bash the type of the operand
                   and get rid of the cast */

                if  (oper->gtOper == GT_IND)
                {
                    oper->gtType = dstt;
                    goto USELESS_CAST;
                }
            }

            if (genActualType(dstt) != TYP_LONG)
            {
                /* Widening to a signed int type doesn't make sense
                   (eg. TYP_BYTE to TYP_SHORT, or TYP_UBYTE to TYP_SHORT). */

                if  (!varTypeIsUnsigned(dstt))
                    goto USELESS_CAST;

               /* Widening to an unsigned int makes sense only if the
                  source is signed. */

                if  (varTypeIsUnsigned(srct))
                    goto USELESS_CAST;
#ifndef _WIN64
                /* On 32 bit machines, widening to TYP_UINT, doesnt makes sense */
                if (dstt == TYP_UINT)
                    goto USELESS_CAST;
#endif
            }
        }
    }

#if!CPU_HAS_FP_SUPPORT

    /* Is the source or target a FP type? */

    if      (varTypeIsFloating(srct))
    {
        /* Cast from float/double */

        switch (dstt)
        {
        case TYP_BYTE:
        case TYP_SHORT:
        case TYP_CHAR:
        case TYP_UBYTE:
        case TYP_ULONG:
        case TYP_INT:
            CPX = (srct == TYP_FLOAT) ? CPX_R4_TO_I4
                                      : CPX_R8_TO_I4;
            break;

        case TYP_LONG:
            CPX = (srct == TYP_FLOAT) ? CPX_R4_TO_I8
                                      : CPX_R8_TO_I8;
            break;

        case TYP_FLOAT:
            assert(srct == TYP_DOUBLE);
            CPX = CPX_R8_TO_R4;
            break;

        case TYP_DOUBLE:
            assert(srct == TYP_FLOAT);
            CPX = CPX_R4_TO_R8;
            break;

#ifdef  DEBUG
        default:
            goto BAD_TYP;
#endif
        }

        goto CALL;
    }
    else if (varTypeIsFloating(dstt))
    {
        /* Cast  to  float/double */

        switch (srct)
        {
        case TYP_BYTE:
        case TYP_SHORT:
        case TYP_CHAR:
        case TYP_UBYTE:
        case TYP_ULONG:
        case TYP_INT:
            CPX = (dstt == TYP_FLOAT) ? CPX_I4_TO_R4
                                      : CPX_I4_TO_R8;
            break;

        case TYP_LONG:
            CPX = (dstt == TYP_FLOAT) ? CPX_I8_TO_R4
                                      : CPX_I8_TO_R8;
            break;

#ifdef  DEBUG
        default:
            goto BAD_TYP;
#endif
        }

        goto CALL;
    }

#else

    /* Check for "float -> int/long" and "double -> int/long" */

    switch (srct)
    {
        case TYP_FLOAT:
                assert(dstt == TYP_DOUBLE || dstt == TYP_FLOAT);                // Should have been morphed above
                break;
    case TYP_DOUBLE:
        switch (dstt)
        {
                case TYP_UINT:
                        CPX = CPX_DBL2UINT;
            goto CALL;
        case TYP_INT:
                        CPX = CPX_DBL2INT;
            goto CALL;
                case TYP_ULONG:
                        CPX = CPX_DBL2ULNG;
            goto CALL;
        case TYP_LONG:
                        CPX = CPX_DBL2LNG;
            goto CALL;
        }
        break;
    }

#endif

    return tree;

CALL:

#if USE_FASTCALL

    tree = fgMorphIntoHelperCall(tree, CPX, gtNewArgList(oper));

#else

    /* Update the current pushed argument size */

    fgPtrArgCntCur += genTypeStSz(srct);

    /* Remember the maximum value we ever see */

    if  (fgPtrArgCntMax < fgPtrArgCntCur)
         fgPtrArgCntMax = fgPtrArgCntCur;

    tree = fgMorphIntoHelperCall(tree, CPX, gtNewArgList(oper));

    fgPtrArgCntCur -= genTypeStSz(srct);

#endif

    return tree;

#if !   CPU_HAS_FP_SUPPORT

#ifdef  DEBUG

BAD_TYP:

#ifndef NOT_JITC
    printf("Constant cast from '%s' to '%s'\n", varTypeName(srct),
                                                varTypeName(dstt));
#endif

#endif

    assert(!"unhandled/unexpected FP cast");

#endif

REMOVE_CAST:
        oper = fgMorphTree(oper);

USELESS_CAST:

    /* Here we've eliminated the cast, so just return the "castee" */

    DEBUG_DESTROY_NODE(tree);
    return oper;
}

/*****************************************************************************
 *
 *  Convert a 'long' binary operator into a helper call.
 */

GenTreePtr          Compiler::fgMorphLongBinop(GenTreePtr tree, int helper)
{
#if USE_FASTCALL
    tree = fgMorphIntoHelperCall(tree, helper, gtNewArgList(tree->gtOp.gtOp2,
                                                            tree->gtOp.gtOp1));
#else
    tree->gtOp.gtOp2 = fgMorphTree(tree->gtOp.gtOp2);

    unsigned genPtrArgSave = fgPtrArgCntCur;

    fgPtrArgCntCur += genTypeStSz(tree->gtOp.gtOp2->gtType);

    tree->gtOp.gtOp1 = fgMorphTree(tree->gtOp.gtOp1);

    fgPtrArgCntCur += genTypeStSz(tree->gtOp.gtOp1->gtType);

    /* Remember the maximum value we ever see */

    if  (fgPtrArgCntMax < fgPtrArgCntCur)
         fgPtrArgCntMax = fgPtrArgCntCur;

    tree = fgMorphIntoHelperCall(tree, helper, gtNewArgList(tree->gtOp.gtOp2,
                                                            tree->gtOp.gtOp1));

    fgPtrArgCntCur = genPtrArgSave;
#endif

    return tree;
}

#if TGT_IA64
GenTreePtr          Compiler::fgMorphFltBinop(GenTreePtr tree, int helper)
{
    return  fgMorphIntoHelperCall(tree, helper, gtNewArgList(tree->gtOp.gtOp2,
                                                             tree->gtOp.gtOp1));
}
#endif
/*****************************************************************************
 *
 *  Morph an argument list; compute the pointer argument count in the process.
 *
 *  NOTE: This function can be called from any place in the JIT to perform re-morphing
 *  due to graph altering modifications such as copy / constant propagation
 */

GenTreePtr          Compiler::fgMorphArgs(GenTreePtr call)
{
    GenTreePtr      args;
    GenTreePtr      argx;

    unsigned        flags = 0;
    unsigned        genPtrArgCntSav = fgPtrArgCntCur;

#if USE_FASTCALL

    unsigned        begTab        = 0;
    unsigned        endTab        = 0;

    unsigned        i;

    unsigned        argRegNum     = 0;
    unsigned        argRegMask    = 0;

    unsigned        maxRealArgs   = MAX_REG_ARG;  // this is for IL where we need
                                                  // to reserve space for the objPtr
    GenTreePtr      tmpRegArgNext = 0;

    struct
    {
        GenTreePtr  node;
        GenTreePtr  parent;
        bool        needTmp;
    }
                    regAuxTab[MAX_REG_ARG],
                    regArgTab[MAX_REG_ARG];

    //memset(regAuxTab, 0, sizeof(regAuxTab));

#endif

    assert(call->gtOper == GT_CALL);

    /* Gross - we need to return a different node when hoisting nested calls */

#if USE_FASTCALL && !NST_FASTCALL

    GenTreePtr      cexp = call;

#define FGMA_RET    cexp

#else

#define FGMA_RET    call

#endif

    /* First we morph any subtrees (arguments, 'this' pointer, etc.)
     * While doing this we also notice how many register arguments we have
     * If this is a second time this function is called then we don't
     * have to recompute the register arguments, just morph them */

    argx = call->gtCall.gtCallObjp;
    if  (argx)
    {
        call->gtCall.gtCallObjp = argx = fgMorphTree(argx);
        flags |= argx->gtFlags;
#if USE_FASTCALL
        argRegNum++;

#if TGT_RISC && !STK_FASTCALL
        fgPtrArgCntCur++;
#endif

#else
        fgPtrArgCntCur++;
#endif
    }

    /* For indirect calls, the function pointer has to be evaluated last.
       It may cause registered args to be spilled. We just dont allow it
       to contain a call. The importer should spill such a pointer */

    assert(call->gtCall.gtCallType != CT_INDIRECT ||
           !(call->gtCall.gtCallAddr->gtFlags & GTF_CALL));

    /* Morph the user arguments */

    for (args = call->gtCall.gtCallArgs; args; args = args->gtOp.gtOp2)
    {
        args->gtOp.gtOp1 = fgMorphTree(args->gtOp.gtOp1);
        argx = args->gtOp.gtOp1;
        flags |= argx->gtFlags;

        /* Bash the node to TYP_I_IMPL so we dont report GC info
         * NOTE: We deffered this from the importer because of the inliner */

        if (argx->IsVarAddr())
            argx->gtType = TYP_I_IMPL;

#if USE_FASTCALL
        if  (argRegNum < MAX_REG_ARG && isRegParamType(genActualType(argx->TypeGet())) )
        {
            argRegNum++;

#if TGT_RISC && !STK_FASTCALL
            fgPtrArgCntCur += genTypeStSz(argx->gtType);
#endif
        }
        else
#endif
        {
            fgPtrArgCntCur += genTypeStSz(argx->gtType);
        }
    }

#if TGT_RISC && !NEW_CALLINTERFACE
    /* Reserve enough room for the resolve interface helper call */

    if  (call->gtFlags & GTF_CALL_INTF)
        fgPtrArgCntCur += 4;
#endif

    /* Remember the maximum value we ever see */

    if  (fgPtrArgCntMax < fgPtrArgCntCur)
         fgPtrArgCntMax = fgPtrArgCntCur;

    /* Remember the max. outgoing argument register count */

#if TGT_IA64
    if  (genOutArgRegCnt < argRegNum)
         genOutArgRegCnt = argRegNum;
#endif

    /* The call will pop all the arguments we pushed */

    fgPtrArgCntCur = genPtrArgCntSav;

    /* Update the 'side effect' flags value for the call */

    call->gtFlags |= (flags & GTF_GLOB_EFFECT);

#if TGT_RISC
    genNonLeaf = true;
#endif

#if  !  NST_FASTCALL

    /*
        We have to hoist any nested calls. Note that currently we don't expect
        the vtable pointer expression to contain calls.
     */

    assert(call->gtCall.gtCallVptr == NULL || !(call->gtCall.gtCallVptr->gtFlags & GTF_CALL));

    /* Do we have any nested calls? */

    if  (flags & GTF_CALL)
    {
        bool            foundSE;
        bool            hoistSE;

        GenTreePtr      thisx, thisl;
        GenTreePtr      nextx, nextl;
        GenTreePtr      lastx, lastl;

        GenTreePtr      hoistx = NULL;
        GenTreePtr      hoistl = NULL;

        bool            repeat = false;
        unsigned        pass   = 0;

        /*
            We do this in one or two passes: first we find the last argument
            that contains a call, since all preceding arguments with global
            effects need to be hoisted along with the call. We also look for
            any arguments that contains assignments - if those get moved, we
            have to move any other arguments that depend on the old value
            of the assigned variable.

            UNDONE: We actually don't the assignment part - it's kind of a
                    pain, and hopefully we can reuse some of the __fastcall
                    functionality for this later.

            UNDONE: If there are no calls beyond the very first argument,
                    we don't really need to do any hoisting.
         */

#ifdef  DEBUG
        if  (verbose)
        {
            printf("Call contains nested calls which will be hoisted:\n");
            gtDispTree(call);
            printf("\n");
        }
#endif

    HOIST_REP:

        thisx = thisl = call->gtCall.gtCallArgs;
        nextx = nextl = call->gtCall.gtCallObjp;
        lastx = lastl = call->gtCall.gtCallType == CT_INDIRECT ?
                        call->gtCall.gtCallAddr : NULL;

        /*
            Since there is at least one call remaining in the argument list,
            we certainly want to hoist any side effects we find (but we have
            not found any yet).
         */

        hoistSE = true;
        foundSE = false;

        for (;;)
        {
            GenTreePtr      argx;

            unsigned        tmpnum;
            GenTreePtr      tmpexp;

            /* Have we exhausted the current list? */

            if  (!thisx)
            {
                /* Move the remaining list(s) up */

                thisx = nextx;
                nextx = lastx;
                lastx = NULL;

                if  (!thisx)
                {
                    thisx = nextx;
                    nextx = NULL;
                }

                if  (!thisx)
                    break;
            }

            assert(thisx);

            /* Get hold of the argument value */

            argx = thisx;
            if  (argx->gtOper == GT_LIST)
            {
                /* This is a "regular" argument */

                argx = argx->gtOp.gtOp1;
            }
            else
            {
                /* This must be the object or function address argument */

                assert(thisx == call->gtCall.gtCallAddr ||
                       thisx == call->gtCall.gtCallObjp);
            }

            /* Is there a call in this argument? */

            if  (argx->gtFlags & GTF_CALL)
            {
                /* Have we missed any side effects? */

                if  (foundSE && !hoistSE)
                {
                    /* Rats, we'll have to perform a second pass */

                    assert(pass == 0);

                    /* We'll remember the last call we find */

                    hoistl = argx;
                    repeat = true;
                    goto NEXT_HOIST;
                }
            }
            else
            {
                /* Does this argument contain any side effects? */

                if  (!(argx->gtFlags & GTF_SIDE_EFFECT))
                    goto NEXT_HOIST;

                /* Are we currently hoisting side effects? */

                if  (!hoistSE)
                {
                    /* Merely remember that we have side effects and continue */

                    foundSE = true;
                    goto NEXT_HOIST;
                }
            }

            /* We arrive here if the current argument needs to be hoisted */

#ifdef  DEBUG
            if  (verbose)
            {
                printf("Hoisting argument value:\n");
                gtDispTree(argx);
                printf("\n");
            }
#endif

            /* Grab a temp for the argument value */

            tmpnum = lvaGrabTemp();

            /* Create the assignment of the argument value to the temp */

            tmpexp = gtNewTempAssign(tmpnum, argx);

            /* Append the temp to the list of hoisted expressions */

            hoistx = hoistx ? gtNewOperNode(GT_COMMA, TYP_VOID, hoistx, tmpexp)
                            : tmpexp;

            /* Create a copy of the temp to use in the argument list */

            tmpexp = gtNewLclvNode(tmpnum, genActualType(argx->TypeGet()));

            /* Replace the argument with the temp reference */

            if  (thisx->gtOper == GT_LIST)
            {
                /* This is a "regular" argument */

                assert(thisx->gtOp.gtOp1 == argx);
                       thisx->gtOp.gtOp1  = tmpexp;
            }
            else
            {
                /* This must be the object or function address argument */

                if  (call->gtCall.gtCallAddr == thisx)
                {
                     call->gtCall.gtCallAddr  = tmpexp;
                }
                else
                {
                    assert(call->gtCall.gtCallObjp == thisx);
                           call->gtCall.gtCallObjp  = tmpexp;
                }
            }

            /* Which pass are we performing? */

            if  (pass == 0)
            {
                /*
                    First pass - stop hoisting for now., hoping that this
                    is the last call. If we're wrong we'll have to go back
                    and perform a second pass.
                 */

                hoistSE = false;
                foundSE = false;
            }
            else
            {
                /*
                    Second pass - we're done if we just hoisted the last
                    call in the argument list (we figured out which was
                    the last one in the first pass). Otherwise we just
                    keep hoisting.
                 */

                if  (thisx == hoistl)
                    break;
            }

        NEXT_HOIST:

            /* Skip over the argument value we've just processed */

            thisx = (thisx->gtOper == GT_LIST) ? thisx->gtOp.gtOp2
                                               : NULL;
        }

        /* Do we have to perform a second pass? */

        if  (repeat)
        {
#if     TGT_IA64
            if  (pass)
            {
                printf("// WARNING: something weird happened when hosting nested calls!!!!\n");
            }
            else
#endif
            {
                assert(pass == 0); pass++;
                goto HOIST_REP;
            }
        }

        /* Did we hoist any expressions out of the call? */

        if  (hoistx)
        {
            /* Make sure we morph the hoisted expression */

//          hoistx = fgMorphTree(hoistx);  temporarily disabled due to hack above

            /*
                We'll replace the call node with a comma node that
                prefixes the call with the hoisted expression, for
                example:

                    f(a1,a2)    --->    (t1=a1,t2=a2),f(t1,t2)
             */

            cexp = gtNewOperNode(GT_COMMA, call->gtType, hoistx, call);

#ifdef  DEBUG
            if  (verbose)
            {
                printf("Hoisted expression list:\n");
                gtDispTree(hoistx);
                printf("\n");

                printf("Updated call expression:\n");
                gtDispTree(cexp);
                printf("\n");
            }
#endif
        }
    }

#endif

    /* This is the fastcall part - figure out which arguments go to registers */

#if USE_FASTCALL && !TGT_IA64

    /* Check if we need to compute the register arguments */

    if  (call->gtCall.gtCallRegArgs)
    {
        /* register arguments already computed */
        assert(argRegNum && argRegNum <= MAX_REG_ARG);
        call->gtCall.gtCallRegArgs = fgMorphTree(call->gtCall.gtCallRegArgs);
        return call;
    }
    else if (argRegNum == 0)
    {
        /* No register arguments - don't waste time with this function */

        return FGMA_RET;
    }
    else
    {
        /* First time we morph this function AND it has register arguments
         * Follow into the code below and do the 'defer or eval to temp' analysis */

        argRegNum = 0;
    }

    /* Process the 'this' argument value, if present */

    argx = call->gtCall.gtCallObjp;
    if  (argx)
    {
        assert(call->gtCall.gtCallType == CT_USER_FUNC);

        assert(varTypeIsGC(call->gtCall.gtCallObjp->gtType) ||
                           call->gtCall.gtCallObjp->gtType == TYP_I_IMPL);

        assert(argRegNum == 0);

        /* this is a register argument - put it in the table */
        regAuxTab[argRegNum].node    = argx;
        regAuxTab[argRegNum].parent  = 0;

        /* For now we can optimistically assume that we won't need a temp
         * for this argument, unless it has a GTF_ASG */

        //regAuxTab[argRegNum].needTmp = false;
        regAuxTab[argRegNum].needTmp = (argx->gtFlags & GTF_ASG) ? true : false;

        /* Increment the argument register count */
        argRegNum++;
    }

    if  (call->gtFlags & GTF_CALL_POP_ARGS)
    {
        assert(argRegNum < maxRealArgs);
            // No more register arguments for varargs (CALL_POP_ARGS)
        maxRealArgs = argRegNum;
            // Except for return arg buff
        if (call->gtFlags & GTF_CALL_RETBUFFARG)
            maxRealArgs++;
    }

    /* Process the user arguments */

    for (args = call->gtCall.gtCallArgs; args; args = args->gtOp.gtOp2)
    {
        /* If a non-register args calling convention, bail
         * NOTE: The this pointer is still passed in registers
         * UNDONE: If we change our mind about this we will likely have to add
         * the calling convention type to the GT_CALL node */

        argx = args->gtOp.gtOp1;

        if (argRegNum < maxRealArgs && isRegParamType(genActualType(argx->TypeGet())))
        {
            /* This is a register argument - put it in the table */

            regAuxTab[argRegNum].node    = argx;
            regAuxTab[argRegNum].parent  = args;
            regAuxTab[argRegNum].needTmp = false;

            /* If contains an assignment (GTF_ASG) then itself and everything before it
               (except constants) has to evaluate to temp since there may be other argumets
               that follow it and use the value (Can make a little optimization - this is not necessary
               if this is the last argument and everything before is constant)
               EXAMPLE: ArgTab is "a, a=5, a" -> the first two a's have to eval to temp
             */

            if (argx->gtFlags & GTF_ASG)
            {
                regAuxTab[argRegNum].needTmp = true;

                for(i = 0; i < argRegNum; i++)
                {
                    assert(regAuxTab[i].node);

                    if (regAuxTab[i].node->gtOper != GT_CNS_INT)
                    {
                        regAuxTab[i].needTmp = true;
                    }
                }
            }

            /* If contains a call (GTF_CALL) everything before the call with a GLOB_EFFECT
             * must eval to temp (this is because everything with SIDE_EFFECT has to be kept in the right
             * order since we will move the call to the first position
             */

            if (argx->gtFlags & GTF_CALL)
            {
                for(i = 0; i < argRegNum; i++)
                {
                    assert(regAuxTab[i].node);

                    if (regAuxTab[i].node->gtFlags & GTF_GLOB_EFFECT)
                    {
                        regAuxTab[i].needTmp = true;
                    }
                }
            }

            /* Increment the argument register count */

            argRegNum++;
        }
        else
        {
            /*
                Non-register argument -> all previous register arguments
                with side_efects must be evaluated to temps to maintain
                proper ordering.
             */

            for(i = 0; i < argRegNum; i++)
            {
                assert(regAuxTab[i].node);
                if (regAuxTab[i].node->gtFlags & GTF_SIDE_EFFECT)
                    regAuxTab[i].needTmp = true;
            }

            /* If the argument contains a call (GTF_CALL) it may affect previous
             * global references, so we cannot defer those, as their value might
             * have been changed by the call */

            if (argx->gtFlags & GTF_CALL)
            {
                for(i = 0; i < argRegNum; i++)
                {
                    assert(regAuxTab[i].node);
                    if (regAuxTab[i].node->gtFlags & GTF_GLOB_REF)
                        regAuxTab[i].needTmp = true;
                }
            }

            /* If the argument contains a assignment (GTF_ASG) - for example an x++
             * be conservative and assign everything to temps */

            if (argx->gtFlags & GTF_ASG)
            {
                for(i = 0; i < argRegNum; i++)
                {
                    assert(regAuxTab[i].node);
                    if (regAuxTab[i].node->gtOper != GT_CNS_INT)
                        regAuxTab[i].needTmp = true;
                }
            }
        }
    }

#if 0 // remove since we now pass the objptr first

    argx = call->gtCall.gtCallObjp;
    if  (argx)
    {
        assert(call->gtCall.gtCallType == CT_USER_FUNC);

        /* ObjPtr is passed last after everything else has been
         * pushed on the stack or allocated to registers */

        assert(maxRealArgs == MAX_REG_ARG - 1);
        assert(argRegNum < MAX_REG_ARG);
        assert((genActualType(argx->gtType) == TYP_REF)   ||
               (genActualType(argx->gtType) == TYP_BYREF)  );

        /* If contains a call (GTF_CALL) everything before the call with a GLOB_EFFECT
         * must eval to temp (because due to shuffling the call will go first) */

        if (argx->gtFlags & GTF_CALL)
        {
            for(i = 0; i < argRegNum; i++)
            {
                assert(regAuxTab[i].node);

                if (regAuxTab[i].node->gtFlags & GTF_GLOB_EFFECT)
                {
                    regAuxTab[i].needTmp = true;
                }
            }
        }

        /* This is a bit weird: Although the 'this' pointer is the last argument
         * we have to put it in the first position in the table since
         * the code below assigns arguments to registers in the table order */

        if (argRegNum > 0)
        {
            for(i = argRegNum - 1; i > 0; i--)
            {
                assert(regAuxTab[i].node);
                regAuxTab[i+1] = regAuxTab[i];
            }
            assert((i == 0) && regAuxTab[0].node);
            regAuxTab[1] = regAuxTab[0];
        }

        /* put it in the table - first position */
        regAuxTab[0].node    = argx;
        regAuxTab[0].parent  = 0;

        /* Since it's the last one no temp needed */

        regAuxTab[0].needTmp = false;

        /* Increment the argument register count */
        argRegNum++;
    }

#endif

    /* If no register arguments or "unmanaged call",  bail */

#if INLINE_NDIRECT
    if (!argRegNum || (call->gtFlags & GTF_CALL_UNMANAGED))
#else
    if (!argRegNum)
#endif
    {
        return FGMA_RET;
    }

#ifdef  DEBUG
    if  (verbose)
    {
        printf("\nMorphing register arguments:\n");
        gtDispTree(call);
        printf("\n");
    }
#endif

    /* Shuffle the register argument table - The idea is to move all "simple" arguments
     * (like constants and local vars) at the end of the table. This will prevent registers
     * from being spilled by the more complex arguments placed at the beginning of the table.
     */

    /* Set the beginning and end for the new argument table */

    assert(argRegNum <= MAX_REG_ARG);

    begTab = 0;
    endTab = argRegNum - 1;

    /* First take care of eventual constants and calls */

    for(i = 0; i < argRegNum; i++)
    {
        assert(regAuxTab[i].node);

        /* put constants at the end of the table */
        if (regAuxTab[i].node->gtOper == GT_CNS_INT)
        {
            assert(endTab >= 0);
            regArgTab[endTab] = regAuxTab[i];
            regAuxTab[i].node = 0;

            /* Encode the argument register in the register mask */
            argRegMask |= (unsigned short)genRegArgNum(i) << (4 * endTab);
            endTab--;
        }
        else if (regAuxTab[i].node->gtFlags & GTF_CALL)
        {
            /* put calls at the beginning of the table */
            assert(begTab >= 0);
            regArgTab[begTab] = regAuxTab[i];
            regAuxTab[i].node = 0;

            /* Encode the argument register in the register mask */
            argRegMask |= (unsigned short)genRegArgNum(i) << (4 * begTab);
            begTab++;
        }
    }

    /* Second, take care of temps and local vars - Temps should go in registers
     * before any local vars since this will give them a better chance to become
     * enregisterd (in the best case in the same arg register */

    for(i = 0; i < argRegNum; i++)
    {
        if (regAuxTab[i].node == 0) continue;

        if (regAuxTab[i].needTmp)
        {
            /* put temp arguments at the beginning of the table */
            assert(begTab >= 0);
            regArgTab[begTab] = regAuxTab[i];
            regAuxTab[i].node = 0;

            /* Encode the argument register in the register mask */
            argRegMask |= (unsigned short)genRegArgNum(i) << (4 * begTab);
            begTab++;
        }
        else if (regAuxTab[i].node->gtOper == GT_LCL_VAR)
        {
            /* put non-tmp local vars at the end of the table */
            assert(endTab >= 0);
            assert(regAuxTab[i].needTmp == false);

            regArgTab[endTab] = regAuxTab[i];
            regAuxTab[i].node = 0;

            /* Encode the argument register in the register mask */
            argRegMask |= (unsigned short)genRegArgNum(i) << (4 * endTab);
            endTab--;
        }
    }

    /* Finally take care of any other arguments left */

    for(i = 0; i < argRegNum; i++)
    {
        if (regAuxTab[i].node == 0) continue;

        assert (regAuxTab[i].node->gtOper != GT_LCL_VAR);
        assert (regAuxTab[i].node->gtOper != GT_CNS_INT);

        assert (!(regAuxTab[i].node->gtFlags & (GTF_CALL | GTF_ASG)));

        assert (begTab >= 0); assert (begTab < argRegNum);
        regArgTab[begTab] = regAuxTab[i];
        regAuxTab[i].node = 0;

        /* Encode the argument register in the register mask */
        argRegMask |= (unsigned short)genRegArgNum(i) << (4 * begTab);
        begTab++;
    }

    assert ((unsigned)(begTab - 1) == endTab);

    /* Save the argument register encoding mask in the call node */

    call->gtCall.regArgEncode = argRegMask;

    /* Go through the new register table and perform
     * the necessary changes to the tree */

    GenTreePtr      op1, defArg;

    assert(argRegNum <= MAX_REG_ARG);
    for(i = 0; i < argRegNum; i++)
    {
        assert(regArgTab[i].node);
        if (regArgTab[i].needTmp == true)
        {
            /* Create a temp assignment for the argument
             * Put the temp in the gtCallRegArgs list */

#ifdef  DEBUG
            if (verbose)
            {
                printf("Register argument with 'side effect'...\n");
                gtDispTree(regArgTab[i].node);
            }
#endif
            unsigned        tmp = lvaGrabTemp();

            op1 = gtNewTempAssign(tmp, regArgTab[i].node); assert(op1);

#ifdef  DEBUG
            if (verbose)
            {
                printf("Evaluate to a temp...\n");
                gtDispTree(op1);
            }
#endif
            /* Create a copy of the temp to go to the list of register arguments */

            defArg = gtNewLclvNode(tmp, genActualType(regArgTab[i].node->gtType));
        }
        else
        {
            /* No temp needed - move the whole node to the gtCallRegArgs list
             * In place of the old node put a gtNothing node */

            assert(regArgTab[i].needTmp == false);

#ifdef  DEBUG
            if (verbose)
            {
                printf("Defered register argument ('%s'), replace with NOP node...\n", getRegName((argRegMask >> (4*i)) & 0x000F));
                gtDispTree(regArgTab[i].node);
            }
#endif
            op1 = gtNewNothingNode(); assert(op1);

            /* The argument is defered and put in the register argument list */

            defArg = regArgTab[i].node;
        }

        /* mark this assignment as a register argument that is defered */
        op1->gtFlags |= GTF_REG_ARG;

        if (regArgTab[i].parent)
        {
            /* a normal argument from the list */
            assert(regArgTab[i].parent->gtOper == GT_LIST);
            assert(regArgTab[i].parent->gtOp.gtOp1 == regArgTab[i].node);

            regArgTab[i].parent->gtOp.gtOp1 = op1;
        }
        else
        {
            /* must be the gtCallObjp */
            assert(call->gtCall.gtCallObjp == regArgTab[i].node);

            call->gtCall.gtCallObjp = op1;
        }

        /* defered arg goes into the register argument list */

        if (!tmpRegArgNext)
            call->gtCall.gtCallRegArgs = tmpRegArgNext = gtNewOperNode(GT_LIST, TYP_VOID, defArg, 0);
        else
        {
            assert(tmpRegArgNext->gtOper == GT_LIST);
            assert(tmpRegArgNext->gtOp.gtOp1);
            tmpRegArgNext->gtOp.gtOp2 = gtNewOperNode(GT_LIST, TYP_VOID, defArg, 0);
            tmpRegArgNext = tmpRegArgNext->gtOp.gtOp2;
        }
    }

#ifdef DEBUG
    if (verbose)
    {
        printf("\nShuffled argument register table:\n");
        for(i = 0; i < argRegNum; i++)
        {
            printf("%s ", getRegName((argRegMask >> (4*i)) & 0x000F) );
        }
        printf("\n");
    }
#endif

#endif // USE_FASTCALL

    return FGMA_RET;
}

/*****************************************************************************
 *
 *  A little helper used to rearrange nested commutative operations. The
 *  effect is that nested commutative operations are transformed into a
 *  'left-deep' tree, i.e. into something like this:
 *
 *      (((a op b) op c) op d) op...
 */

#if REARRANGE_ADDS

void                Compiler::fgMoveOpsLeft(GenTreePtr tree)
{
    GenTreePtr      op1  = tree->gtOp.gtOp1;
    GenTreePtr      op2  = tree->gtOp.gtOp2;
    genTreeOps      oper = tree->OperGet();

    assert(GenTree::OperIsCommutative(oper));
    assert(oper == GT_ADD || oper == GT_XOR || oper == GT_OR ||
           oper == GT_AND || oper == GT_MUL);
    assert(!varTypeIsFloating(tree->TypeGet()) || !genOrder);
    assert(oper == op2->gtOper);

    // Commutativity doesnt hold if overflow checks are needed

    if (tree->gtOverflowEx() || op2->gtOverflowEx())
        return;

//  gtDispTree(tree);

    do
    {
        assert(!tree->gtOverflowEx() && !op2->gtOverflowEx());

        GenTreePtr      ad1 = op2->gtOp.gtOp1;
        GenTreePtr      ad2 = op2->gtOp.gtOp2;

        /* Change "(x op (y op z))" to "(x op y) op z" */
        /* ie.    "(op1 op (ad1 op ad2))" to "(op1 op ad1) op ad2" */

        GenTreePtr & new_op1    = op2;
        new_op1->gtOp.gtOp1     = op1;
        new_op1->gtOp.gtOp2     = ad1;

        /* Change the flags. */

        // Make sure we arent throwing away any flags
        assert((new_op1->gtFlags & ~(GTF_PRESERVE|GTF_GLOB_EFFECT|GTF_UNSIGNED)) == 0);
        new_op1->gtFlags        = (new_op1->gtFlags & GTF_PRESERVE) |
                                  (op1->gtFlags & GTF_GLOB_EFFECT)  |
                                  (ad1->gtFlags & GTF_GLOB_EFFECT);

        /* Retype new_op1 if it has not/become a GC ptr. */

        if      (varTypeIsGC(op1->TypeGet()))
        {
            assert(varTypeIsGC(tree->TypeGet()) && (op2->TypeGet() == TYP_I_IMPL || op2->TypeGet() == TYP_INT));
            new_op1->gtType = tree->gtType;
        }
        else if (varTypeIsGC(ad2->TypeGet()))
        {
            // Neither ad1 nor op1 are GC. So new_op1 isnt either
            assert(op1->gtType == TYP_I_IMPL && ad1->gtType == TYP_I_IMPL);
            new_op1->gtType = TYP_I_IMPL;
        }

        // Old assert - Dont know what it does. Goes off incorrectly sometimes
        // like when you have (int > (bool OR int) )
#if 0
        // Check that new expression new_op1 is typed correctly
        assert((varTypeIsIntegral(op1->gtType) && varTypeIsIntegral(ad1->gtType))
              == varTypeIsIntegral(new_op1->gtType));
#endif

        tree->gtOp.gtOp1 = new_op1;
        tree->gtOp.gtOp2 = ad2;

        /* If 'new_op1' is now the same nested op, process it recursively */

        if  ((ad1->gtOper == oper) && !ad1->gtOverflowEx())
            fgMoveOpsLeft(new_op1);

        /* If   'ad2'   is now the same nested op, process it
         * Instead of recursion, we set up op1 and op2 for the next loop.
         */

        op1 = new_op1;
        op2 = ad2;
    }
    while ((op2->gtOper == oper) && !op2->gtOverflowEx());

    return;
}

#endif

/*****************************************************************************
 *
 *  Create an array index / range check node.
 *  If tree!=NULL, that node will be reused.
 *  elemSize is the size of the array element, it only needs to be valid for type=TYP_STRUCT
 */

GenTreePtr              Compiler::gtNewRngChkNode(GenTreePtr    tree,
                                                  GenTreePtr    addr,
                                                  GenTreePtr    indx,
                                                  var_types     type,
                                                  unsigned      elemSize)
{
    GenTreePtr          temp = tree;
    bool                chkd = rngCheck;
#if CSE
    bool                nCSE = false;
#endif

    /* Did the caller supply a GT_INDEX node that is being morphed? */

    if  (tree)
    {
        assert(tree->gtOper == GT_INDEX);

#if SMALL_TREE_NODES && (RNGCHK_OPT || CSELENGTH)
        assert(tree->gtFlags & GTF_NODE_LARGE);
#endif

#if CSE
        if  ((tree->gtFlags & GTF_DONT_CSE  ) != 0)
            nCSE = true;
#endif

        if  ((tree->gtFlags & GTF_INX_RNGCHK) == 0)
            chkd = false;
    }
    else
    {
        tree = gtNewOperNode(GT_IND, type);
    }

    /* Remember if it is an object array */
    if (type == TYP_REF)
        tree->gtFlags |= GTF_IND_OBJARRAY;

    /* Morph "tree" into "*(array + elemSize*index + ARR_ELEM1_OFFS)" */

    if  (chkd)
    {
        /* Make sure we preserve the index value for range-checking */

        indx = gtNewOperNode(GT_NOP, TYP_INT, indx);
        indx->gtFlags |= GTF_NOP_RNGCHK;
    }

    if (type != TYP_STRUCT)
        elemSize = genTypeSize(type);

    /* Scale the index value if necessary */

    if  (elemSize > 1)
    {
        /* Multiply by the array element size */

        temp = gtNewIconNode(elemSize);
        indx = gtNewOperNode(GT_MUL, TYP_INT, indx, temp);
    }

    /* Add the first element's offset */

    if  (ARR_ELEM1_OFFS || OBJARR_ELEM1_OFFS)
    {
        // temp = gtNewIconNode((type == TYP_REF || type == TYP_STRUCT)?OBJARR_ELEM1_OFFS:ARR_ELEM1_OFFS);
        temp = gtNewIconNode((type == TYP_REF)?OBJARR_ELEM1_OFFS:ARR_ELEM1_OFFS);
        indx = gtNewOperNode(GT_ADD, TYP_INT, indx, temp);
    }

    /* Add the array address and the scaled index value */

    indx = gtNewOperNode(GT_ADD, TYP_REF, addr, indx);

    /* Indirect through the result of the "+" */

    tree->ChangeOper(GT_IND);
    tree->gtInd.gtIndOp1    = indx;
    tree->gtInd.gtIndOp2    = 0;
#if CSELENGTH
    tree->gtInd.gtIndLen    = 0;
#endif

    /* An indirection will cause a GPF if the address is null */

    tree->gtFlags   |= GTF_EXCEPT;

#if CSE
    if  (nCSE)
        tree->gtFlags   |= GTF_DONT_CSE;
#endif

    /* Is range-checking enabled? */

    if  (chkd)
    {
        /* Mark the indirection node as needing a range check */

        tree->gtFlags |= GTF_IND_RNGCHK;

#if CSELENGTH

        {
            /*
             *  Make a length operator on the array as a child of
             *  the GT_IND node, so it can be CSEd.
             */

            GenTreePtr      len;

            /* Create an explicit array length tree and mark it */

            tree->gtInd.gtIndLen = len = gtNewOperNode(GT_ARR_RNGCHK, TYP_INT);

            /*
                We point the array length node at the address node. Note
                that this is effectively a cycle in the tree but since
                it's always treated as a special case it doesn't cause
                any problems.
             */

            len->gtArrLen.gtArrLenAdr = addr;
            len->gtArrLen.gtArrLenCse = NULL;
        }

#endif

#if !RNGCHK_OPT

        tree->gtOp.gtOp2 = gtNewCodeRef(fgRngChkTarget(compCurBB));
#else

        if  (opts.compMinOptim || opts.compDbgCode)
        {
            /* Figure out where to jump to when the index is out of range */

            tree->gtInd.gtIndOp2 = gtNewCodeRef(fgRngChkTarget(compCurBB, fgPtrArgCntCur));
        }
        else
        {
            /*
                We delay this until after loop-oriented range check
                analysis. For now we merely store the current stack
                level in the tree node.
             */

            tree->gtInd.gtStkDepth = fgPtrArgCntCur;
        }
#endif

    }
    else
    {
        /* Mark the indirection node as not needing a range check */

        tree->gtFlags &= ~GTF_IND_RNGCHK;
    }

//  printf("Array expression at %s(%u):\n", __FILE__, __LINE__); gtDispTree(tree); printf("\n\n");

    return  tree;
}




/*****************************************************************************
 *
 *  Transform the given GT_LCLVAR tree for code generation.
 */

GenTreePtr          Compiler::fgMorphLocalVar(GenTreePtr tree, bool checkLoads)
{
    assert(tree->gtOper == GT_LCL_VAR);

    /* If not during the global morphing phase bail */

    if (!fgGlobalMorph)
        return tree;

    unsigned    flags   = tree->gtFlags;
    unsigned    lclNum  = tree->gtLclVar.gtLclNum;
    var_types   varType = lvaGetRealType(lclNum);

    if (checkLoads &&
        !(flags & GTF_VAR_DEF) &&
        varTypeIsIntegral(varType) &&
        genTypeSize(varType) < genTypeSize(TYP_I_IMPL))
    {
        /* Small variables are normalized on access. So insert a narrowing cast.
           @TODO: Instead of a cast, make genCodeForTree() and
           genMakeAddressable() handle GT_LCL_VAR of small type correctly.
           @CONSIDER : Normalize small vars on store instead (args would
           have to be done in the prolog). */

        tree = gtNewLargeOperNode(GT_CAST,
                                  TYP_INT,
                                  tree,
                                  gtNewIconNode((long)varType));
    }

#if COPY_PROPAG

    if (opts.compDbgCode || opts.compMinOptim)
        return tree;

    /* If no copy propagation candidates bail */

    if (optCopyAsgCount == 0)
        return tree;

    /* If this is a DEF break */

    if (flags & GTF_VAR_DEF)
        return tree;

    /* This is a USE - check to see if we have any copies of it
     * and replace it */

    unsigned   i;
    for(i = 0; i < optCopyAsgCount; i++)
    {
        if (lclNum == optCopyAsgTab[i].leftLclNum)
        {
            tree->gtLclVar.gtLclNum = optCopyAsgTab[i].rightLclNum;
#ifdef DEBUG
            if(verbose)
            {
                printf("Replaced copy of variable #%02u (copy = #%02u) at [%08X]:\n",
                        optCopyAsgTab[i].rightLclNum, optCopyAsgTab[i].leftLclNum, tree);
            }
#endif
            return tree;
        }
    }

#endif // COPY_PROPAG

    return tree;
}


/*****************************************************************************
 *
 *  Transform the given GT_FIELD tree for code generation.
 */

GenTreePtr          Compiler::fgMorphField(GenTreePtr tree)
{
    assert(tree->gtOper == GT_FIELD);
    assert(tree->gtFlags & GTF_GLOB_REF);

    FIELD_HANDLE    symHnd = tree->gtField.gtFldHnd; assert(symHnd > 0);
    unsigned        memOfs = eeGetFieldOffset(symHnd);

#if     TGT_RISC
#ifndef NOT_JITC

    /* With no VM the offset is a fake, make sure it's aligned */

    memOfs = memOfs & ~(genTypeSize(tree->TypeGet()) - 1);

#endif
#endif

    /* Is this an instance data member? */

    if  (tree->gtField.gtFldObj)
    {
        GenTreePtr      addr;

        if (tree->gtFlags & GTF_IND_TLS_REF)
            NO_WAY("instance field can not be a TLS ref.");

#if HOIST_THIS_FLDS

        addr = optHoistTFRupdate(tree);

        if  (addr->gtOper != GT_FIELD)
        {
            DEBUG_DESTROY_NODE(tree);
            assert(addr->gtOper == GT_LCL_VAR);
            return fgMorphSmpOp(addr);
        }

#endif

        /* We'll create the expression "*(objRef + mem_offs)" */

        GenTreePtr      objRef  = tree->gtField.gtFldObj;
        assert(varTypeIsGC(objRef->TypeGet()) || objRef->TypeGet() == TYP_I_IMPL);

        /* Is the member at a non-zero offset? */

        if  (memOfs == 0)
        {
            addr = objRef;
        }
        else
        {
            /* Add the member offset to the object's address */

            addr = gtNewOperNode(GT_ADD, objRef->TypeGet(), objRef,
                                 gtNewIconHandleNode(memOfs, GTF_ICON_FIELD_HDL));
        }

        /* Now we can create the 'non-static data member' node */

        tree->ChangeOper(GT_IND);
        tree->gtInd.gtIndOp1    = addr;
        tree->gtInd.gtIndOp2    = 0;

        /* An indirection will cause a GPF if the address is null */

        tree->gtFlags   |= GTF_EXCEPT;

        /* OPTIMIZATION - if the object is 'this' and it was not modified
         * in the method don't mark it as GTF_EXCEPT */

        if  (objRef->gtOper == GT_LCL_VAR)
        {
            /* check if is the 'this' pointer */

            if ((objRef->gtLclVar.gtLclNum == 0) && // this is always in local var #0
                !optThisPtrModified              && // make sure we didn't change 'this'
                !info.compIsStatic)                 // make sure this is a non-static method !
            {
                /* the object reference is the 'this' pointer
                 * remove the GTF_EXCEPT flag for this field */

                tree->gtFlags   &= ~GTF_EXCEPT;
            }
        }

        return fgMorphSmpOp(tree);
    }

    /* This is a static data member */

#if GEN_SHAREABLE_CODE

    GenTreePtr      call;

    /* Create the function call node */

    call = gtNewIconHandleNode(eeGetStaticBlkHnd(symHnd),
                               GTF_ICON_STATIC_HDL);

    call = gtNewHelperCallNode(CPX_STATIC_DATA,
                               TYP_INT,
                               GTF_CALL_REGSAVE|GTF_NON_GC_ADDR,
                               gtNewArgList(call));

    /* Add the member's offset if non-zero */

    if  (memOfs)
    {
        call = gtNewOperNode(GT_ADD,
                             TYP_INT, call,
                             gtNewIconNode(memOfs));

        /* The adjusted value is still a non-GC-pointer address */

        call->gtFlags |= GTF_NON_GC_ADDR;
    }

    /* Indirect through the result */

    tree->ChangeOper(GT_IND);
    tree->gtOp.gtOp1           = call;
    tree->gtOp.gtOp2           = 0;

    return fgMorphSmpOp(tree);

#else

    if (tree->gtFlags & GTF_IND_TLS_REF)
    {
        // Thread Local Storage static field reference
        //
        // Field ref is a TLS 'Thread-Local-Storage' reference
        //
        // Build this tree:  IND(*) #
        //                    |
        //                   ADD(I_IMPL)
        //                   / \
        //                  /  CNS(fldOffset)
        //                 /
        //                /
        //               /
        //             IND(I_IMPL) == [Base of this DLL's TLS]
        //              |
        //             ADD(I_IMPL)
        //             / \
        //            /   CNS(IdValue*4) or MUL
        //           /                      / \
        //          IND(I_IMPL)            /  CNS(4)
        //           |                    /
        //          CNS(TLS_HDL,0x2C)    IND
        //                                |
        //                               CNS(pIdAddr)
        //
        // # Denotes the orginal node
        //
        void **    pIdAddr   = NULL;
        unsigned    IdValue  = eeGetFieldThreadLocalStoreID(symHnd, &pIdAddr);

        //
        // If we can we access the TLS DLL index ID value directly
        // then pIdAddr will be NULL and
        //      IdValue will be the actual TLS DLL index ID
        //
        GenTreePtr dllRef = NULL;
        if (pIdAddr == NULL)
        {
            dllRef = gtNewIconNode(IdValue*4, TYP_INT);
        }
        else
        {
            dllRef = gtNewIconNode((long)pIdAddr, TYP_INT);
            dllRef->gtFlags |= GTF_NON_GC_ADDR;

            dllRef = gtNewOperNode(GT_IND, TYP_I_IMPL, dllRef);

            /* Multiply by 4 */

            dllRef = gtNewOperNode(GT_MUL, TYP_I_IMPL, dllRef, gtNewIconNode(4, TYP_INT));
        }
        dllRef->gtFlags |= GTF_NON_GC_ADDR;

        #define WIN32_TLS_SLOTS (0x2C) // Offset from fs:[0] where the pointer to the slots resides

        //
        // Mark this ICON as a TLS_HDL, codegen will use FS:[cns]
        //
        GenTreePtr tlsRef = gtNewIconHandleNode(WIN32_TLS_SLOTS, GTF_ICON_TLS_HDL);
        tlsRef->gtFlags |= GTF_NON_GC_ADDR;

        tlsRef = gtNewOperNode(GT_IND, TYP_I_IMPL, tlsRef);

        /* Add the dllRef */

        tlsRef = gtNewOperNode(GT_ADD, TYP_I_IMPL, tlsRef, dllRef);

        /* indirect to have tlsRef point at the base of the DLLs Thread Local Storage */

        tlsRef = gtNewOperNode(GT_IND, TYP_I_IMPL, tlsRef);

        unsigned fldOffset = eeGetFieldOffset(symHnd);
        if (fldOffset != 0)
        {
            GenTreePtr fldOffsetNode = gtNewIconNode(fldOffset, TYP_INT);
            fldOffsetNode->gtFlags |= GTF_NON_GC_ADDR;

            /* Add the TLS static field offset to the address */

            tlsRef = gtNewOperNode(GT_ADD, TYP_I_IMPL, tlsRef, fldOffsetNode);
        }

        //
        // Final indirect to get to actual value of TLS static field
        //
        tree->ChangeOper(GT_IND);
        tree->gtInd.gtIndOp1 = tlsRef;
        tree->gtInd.gtIndOp2  = NULL;

        assert(tree->gtFlags & GTF_IND_TLS_REF);
    }
    else
    {
        // Normal static field reference

        //
        // If we can we access the static's address directly
        // then pFldAddr will be NULL and
        //      fldAddr will be the actual address of the static field
        //
        void **  pFldAddr = NULL;
        void *    fldAddr = eeGetFieldAddress(symHnd, &pFldAddr);

        if (pFldAddr == NULL)
        {
            // @ToDo: Should really use fldAddr here
            tree->ChangeOper(GT_CLS_VAR);
            tree->gtClsVar.gtClsVarHnd = symHnd;
        }
        else
        {
            GenTreePtr addr = gtNewIconHandleNode((long)pFldAddr, GTF_ICON_STATIC_HDL);
            addr->gtFlags |= GTF_NON_GC_ADDR;

            addr = gtNewOperNode(GT_IND, TYP_I_IMPL, addr);
            addr->gtFlags |= GTF_NON_GC_ADDR;

            tree->ChangeOper(GT_IND);
            tree->gtInd.gtIndOp1  = addr;
            tree->gtInd.gtIndOp2  = NULL;
        }
    }

    return tree;

#endif
}

/*****************************************************************************
 *
 *  Transform the given GT_CALL tree for code generation.
 */

GenTreePtr          Compiler::fgMorphCall(GenTreePtr call)
{
    assert(call->gtOper == GT_CALL);

    if (!opts.compNeedSecurityCheck &&
        (call->gtCall.gtCallMoreFlags & GTF_CALL_M_CAN_TAILCALL))
    {
        compTailCallUsed = true;

        call->gtCall.gtCallMoreFlags &= ~GTF_CALL_M_CAN_TAILCALL;
        call->gtCall.gtCallMoreFlags |=  GTF_CALL_M_TAILCALL;

        // As we will acutally call CPX_TAILCALL, set the callTyp to TYP_VOID.
        // to avoid doing any extra work for the return value.
        var_types   callType = call->TypeGet();
        call->gtType = TYP_VOID;

        /* For tail call, we just call CPX_TAILCALL, and it jumps to the
           target. So we dont need an epilog - just like CPX_THROW. */

        assert(compCurBB->bbJumpKind == BBJ_RETURN);
        compCurBB->bbJumpKind = BBJ_THROW;

        /* For void calls, we would have created a GT_CALL in the stmt list.
           For non-void calls, we would have created a GT_RETURN(GT_CAST(GT_CALL)).
           For debuggable code, it would be an assignment of the call to a temp
           We want to get rid of any of this extra trees, and just leave
           the call */

#ifdef DEBUG
        GenTreePtr stmt = fgMorphStmt->gtStmt.gtStmtExpr;
        assert((stmt->gtOper == GT_CALL && stmt == call) ||
               (stmt->gtOper == GT_RETURN && (stmt->gtOp.gtOp1 == call ||
                                              stmt->gtOp.gtOp1->gtOp.gtOp1 == call)) ||
               (stmt->gtOper == GT_ASG && stmt->gtOp.gtOp2 == call));
        assert(fgMorphStmt->gtNext == NULL);
#endif

        call = fgMorphStmt->gtStmt.gtStmtExpr = fgMorphCall(call);

        /* For non-void calls, we return a place holder which will be
           used by the parents of this call */

        if (callType != TYP_VOID)
            call = gtNewZeroConNode(genActualType(callType));

        return call;
    }

    if  (getContextEnabled() &&
         (call->gtCall.gtCallType == CT_HELPER))
    {
        /* Transform the following wrap/unwrap sequences
           wrap(unwrap(op))     -> wrap(op)
           unwrap(wrap(op))     -> unwrap(op)
           wrap(wrap(op))       -> wrap(op)
           unwrap(unwrap(op))   -> unwrap(op)

         */

        unsigned helpNo = eeGetHelperNum(call->gtCall.gtCallMethHnd);

        if (helpNo == CPX_WRAP || helpNo == CPX_UNWRAP)
        {
            GenTreePtr arg;

            assert(call->gtCall.gtCallArgs->gtOper == GT_LIST);
            arg = call->gtCall.gtCallArgs->gtOp.gtOp1;

            assert(arg);

            while (arg->gtOper == GT_CALL && arg->gtCall.gtCallType == CT_HELPER &&
                   ((eeGetHelperNum(arg->gtCall.gtCallMethHnd) == CPX_WRAP) ||
                    (eeGetHelperNum(arg->gtCall.gtCallMethHnd) == CPX_UNWRAP)))
            {
                assert(arg->gtCall.gtCallArgs->gtOper == GT_LIST &&
                       arg->gtCall.gtCallArgs->gtOp.gtOp2 == 0);

                /* remove the nested helper call */

                call->gtCall.gtCallArgs->gtOp.gtOp1 = arg->gtCall.gtCallArgs->gtOp.gtOp1;

                arg = arg->gtCall.gtCallArgs->gtOp.gtOp1;
            }
        }
    }

#if USE_FASTCALL
#if !NEW_CALLINTERFACE

    if  ((call->gtFlags & GTF_CALL_INTF) && !getNewCallInterface())
    {
        /* morph interface calls into 'temp = call_intf , call'
         * and replace the vptr of the call with 'temp' */

        int             IHX;
        unsigned        intfID;
        unsigned        tnum;

        GenTreePtr      intfCall;
        GenTreePtr      intfArgList;

        unsigned        zero = 0;

        BOOL            trustedClass = TRUE;

#ifdef  NOT_JITC
        trustedClass = info.compCompHnd->getScopeAttribs(info.compScopeHnd) & FLG_TRUSTED;
#endif

        /* Call argument - the address of the object */

        intfArgList = gtNewArgList(call->gtCall.gtCallVptr);

        /* Get the interface ID */

        intfID = eeGetInterfaceID(call->gtCall.gtCallMethHnd);

        /* Call argument - the interface ID */

        intfArgList = gtNewOperNode(GT_LIST,
                                    TYP_VOID,
                                    gtNewIconNode(intfID, TYP_INT),
                                    intfArgList);

        /* Call argument - placeholder for the address of the 'guess' area
         * Later on in the code generator we will replace it with the
         * real address */

        intfArgList = gtNewOperNode(GT_LIST,
                                    TYP_VOID,
                                    gtNewIconNode(24, TYP_INT),
                                    intfArgList);

        /* Figure out the appropriate 'resolve interface' helper */

        if  (trustedClass)
        {
            if  (!vmSdk3_0)
                IHX = CPX_RES_IFC_TRUSTED;
            else
                IHX = CPX_RES_IFC_TRUSTED2;
        }
        else
        {
            IHX = CPX_RES_IFC;
        }

        /* Create the helper call node */

        intfCall = gtNewHelperCallNode(IHX,
                                       TYP_INT,
                                       GTF_CALL_REGSAVE|GTF_NON_GC_ADDR,
                                       intfArgList);


        /* Assign the result of the call to a temp */

        tnum     = lvaGrabTemp();
        intfCall = gtNewAssignNode(gtNewLclvNode(tnum, TYP_INT), intfCall);

        /* Bash the original call node to a GT_COMMA node. Replace the
           vptr with the temp. Also, un-mark the GTF_CALL_INTF flag */

        GenTreePtr origCall = call;
        origCall->gtCall.gtCallVptr = gtNewLclvNode(tnum, TYP_INT);

        origCall->gtFlags &= ~GTF_CALL_INTF;
        assert(origCall->gtFlags & GTF_CALL_VIRT);

        /* Now create the comma node */

        call = gtNewOperNode(GT_COMMA, origCall->gtType, intfCall, origCall);

        /* Re-morph this node */

        return fgMorphSmpOp(call);
    }

#endif //!NEW_CALLINTERFACE
#endif //USE_FASTCALL

    // For (final and private) functions which were called with
    // invokevirtual, but which we call directly, we need to dereference
    // the object pointer to check that it is not NULL. But not for "this"

#ifdef HOIST_THIS_FLDS // as optThisPtrModified is used

    if ((call->gtFlags & GTF_CALL_VIRT_RES) && call->gtCall.gtCallVptr)
    {
        GenTreePtr vptr = call->gtCall.gtCallVptr;

        assert((call->gtFlags & GTF_CALL_INTF) == 0);

        /* CONSIDER: we should directly check the 'objptr',
         * however this may be complictaed by the regsiter calling
         * convention and the fact that the morpher is re-entrant */

        if (vptr->gtOper == GT_IND)
        {
            if (vptr->gtInd.gtIndOp1                            &&
                !vptr->gtInd.gtIndOp2                           &&
                vptr->gtInd.gtIndOp1->gtOper == GT_LCL_VAR      &&
                vptr->gtInd.gtIndOp1->gtLclVar.gtLclNum == 0    &&
                !info.compIsStatic                              &&
                !optThisPtrModified)
            {
                call->gtFlags &= ~GTF_CALL_VIRT_RES;
                call->gtCall.gtCallVptr = NULL;
            }
        }
    }
#endif

#if INLINING

    /* See if this function call can be inlined */

    if  (!(call->gtFlags & (GTF_CALL_VIRT|GTF_CALL_INTF|GTF_CALL_TAILREC)))
    {
        inlExpPtr       expLst;
        METHOD_HANDLE   fncHandle = call->gtCall.gtCallMethHnd;

        /* Don't inline if not optimized code */

        if  (opts.compMinOptim || opts.compDbgCode)
            goto NOT_INLINE;

        /* Ignore tail-calls */

        if (call->gtCall.gtCallMoreFlags & GTF_CALL_M_TAILCALL)
            goto NOT_INLINE;

        /* Ignore helper calls */

        if  (call->gtCall.gtCallType == CT_HELPER)
            goto NOT_INLINE;

        /* Ignore indirect calls */
        if  (call->gtCall.gtCallType == CT_INDIRECT)
            goto NOT_INLINE;

        /* Cannot inline native or synchronized methods */

        if  (eeGetMethodAttribs(fncHandle) & (FLG_NATIVE|FLG_SYNCH))
            goto NOT_INLINE;

        /* Since the inliner is conceptually part of the morpher
         * and the morpher can be called later on during optimizations
         * e.g. after copy / constant prop, dead store removal
         * we should avoid inlining at that stage becuase we already filled in the
         * variable table */

        if  (!fgGlobalMorph)
            goto NOT_INLINE;


#ifdef  NOT_JITC

        const char *    methodName;
        const char *     className;

        methodName = eeGetMethodName(fncHandle, &className);

        if  (genInline)
        {
            /* Horible hack until the VM is fixed */

            if (!strcmp("GetType", methodName))
                goto NOT_INLINE;

            if (!strcmp("GetCaller", methodName))
                goto NOT_INLINE;

            if (!strcmp("GetDynamicModule", methodName))
                goto NOT_INLINE;

            if (!strcmp("Check", methodName))
                goto NOT_INLINE;

#ifdef DEBUG
            /* Check if we can inline this method */
            if  (excludeInlineMethod(methodName, className))
                goto NOT_INLINE;
#endif
        }
        else
        {
#ifdef DEBUG
            /* Check for conditional inlining of some methods only */
            if  (!includeInlineMethod(methodName, className))
#endif
                goto NOT_INLINE;
        }
#else
        //if  (!genInline)
            goto NOT_INLINE;
#endif

#if OPTIMIZE_TAIL_REC

        // UNDONE: Unfortunately, we do tail recursion after inlining,
        // UNDONE: which means that we might inline a tail recursive
        // UNDONE: call, which is almost always a bad idea. For now
        // UNDONE: we just use the following hack to check for calls
        // UNDONE: that look like they might be tail recursive.

        if  (opts.compFastCode && fgMorphStmt->gtNext == NULL)
        {
            if  (eeIsOurMethod(call->gtCall.gtCallMethHnd))
            {
                /*
                    The following is just a hack, of course (it doesn't
                    even check for non-void tail recursion - disgusting).
                 */

                if  (compCurBB->bbJumpKind == BBJ_NONE &&
                     compCurBB->bbNext)
                {
                    BasicBlock  *   bnext = compCurBB->bbNext;
                    GenTree     *   retx;

                    if  (bnext->bbJumpKind != BBJ_RETURN)
                        goto NOT_TAIL_REC;

                    assert(bnext->bbTreeList && bnext->bbTreeList->gtOper == GT_STMT);

                    retx = bnext->bbTreeList->gtStmt.gtStmtExpr; assert(retx);

                    if  (retx->gtOper != GT_RETURN)
                        goto NOT_TAIL_REC;
                    if  (retx->gtOp.gtOp1)
                        goto NOT_TAIL_REC;

                    goto NOT_INLINE;
                }
            }
        }

    NOT_TAIL_REC:

#endif

        /* Prevent recursive expansion */

        for (expLst = fgInlineExpList; expLst; expLst = expLst->ixlNext)
        {
            if  (expLst->ixlMeth == fncHandle)
                goto NOT_INLINE;
        }

        /* Try to inline the call to the method */

        GenTreePtr inlExpr;

        setErrorTrap()
        {
            inlExpr = impExpandInline(call, fncHandle);
        }
        impErrorTrap(info.compCompHnd)
        {
            inlExpr = 0;
        }
        endErrorTrap()

        if  (inlExpr)
        {
            /* For instance method calls we need to check for a null this pointer */

            if ((call->gtFlags & GTF_CALL_VIRT_RES) &&
                call->gtCall.gtCallVptr)
            {
                /* We need to access the vtable ptr to check for a NULL,
                 * so create a COMMA node */

                inlExpr = gtNewOperNode(GT_COMMA,
                                        inlExpr->gtType,
                                        gtUnusedValNode(call->gtCall.gtCallVptr),
                                        inlExpr);
            }

#ifdef  DEBUG
            if  (verbose || 0)
            {
                const char *    methodName;
                const char *     className;

                methodName = eeGetMethodName(fncHandle, &className);
                printf("Inlined call to '%s.%s':\n", className, methodName);
            }
#endif

            /* Prevent recursive inline expansion */

            inlExpLst   expDsc;

            expDsc.ixlMeth = fncHandle;
            expDsc.ixlNext = fgInlineExpList;
                             fgInlineExpList = &expDsc;

            /* Morph the inlined call */

            DEBUG_DESTROY_NODE(call);
            inlExpr = fgMorphTree(inlExpr);

            fgInlineExpList = expDsc.ixlNext;

            return inlExpr;
        }
    }

NOT_INLINE:

#endif

    /* Couldn't inline - remember that this BB contains method calls */

    /* If this is a 'regular' call, mark the basic block as
       having a call (for computing full interruptibility */

    if (call->gtCall.gtCallType == CT_USER_FUNC &&
        !(call->gtCall.gtCallMoreFlags & GTF_CALL_M_NOGCCHECK))
    {
        compCurBB->bbFlags |= BBF_HAS_CALL;
    }

#if     RET_64BIT_AS_STRUCTS

    /* Are we returning long/double as a struct? */

    if  (genTypeStSz(call->TypeGet()) > 1 && call->gtCall.gtCallType != CT_HELPER)
    {
        unsigned        tnum;
        GenTreePtr      temp;

//          printf("Call call before:\n"); gtDispTree(call);

        GenTreePtr      origCall    = call;
        var_types       type        = origCall->TypeGet();
        GenTreePtr      args        = origCall->gtCall.gtCallArgs;

        /* Bash the origCall to not return anything */

        origCall->gtType = TYP_VOID;

        /* Allocate a temp for the result */

        tnum = lvaGrabTemp();       // UNDONE: should reuse these temps!!!!

        /* Add "&temp" in front of the argument list */

        temp = gtNewLclvNode(tnum, type);
        temp = gtNewOperNode(GT_ADDR, TYP_INT, temp);

        origCall->gtCall.gtCallArgs = gtNewOperNode(GT_LIST,
                                                    TYP_VOID,
                                                    temp,
                                                    args);

        /* Change the original node into "call(...) , temp" */

        call = gtNewOperNode(GT_COMMA, type, origCall,
                                             gtNewLclvNode(tnum, type));

//          printf("Call call after:\n"); gtDispTree(call);

        return fgMorphSmpOp(call);
    }

#endif

    // NOTE: Swapped morphing of args with these two - is this OK?

    /* Process the function address, if indirect call */

    if (call->gtCall.gtCallType == CT_INDIRECT)
        call->gtCall.gtCallAddr = fgMorphTree(call->gtCall.gtCallAddr);

    /* Process the object's address, if non-static method call */

    if  (call->gtCall.gtCallVptr)
        call->gtCall.gtCallVptr = fgMorphTree(call->gtCall.gtCallVptr);

    /* Process the "normal" argument list */

    return fgMorphArgs(call);
}

/*****************************************************************************
 *
 *  Transform the given GTK_CONST tree for code generation.
 */

GenTreePtr          Compiler::fgMorphConst(GenTreePtr tree)
{
    assert(tree->OperKind() & GTK_CONST);

    /* Clear any exception flags or other unnecessary flags
     * that may have been set before folding this node to a constant */

    tree->gtFlags &= ~(GTF_SIDE_EFFECT | GTF_REVERSE_OPS);

    if  (tree->OperGet() != GT_CNS_STR)
        return tree;

    /* For string constant, make into a helper call */

    GenTreePtr      args;

    assert(tree->gtStrCon.gtScpHnd == info.compScopeHnd    ||
           (unsigned)tree->gtStrCon.gtScpHnd != 0xDDDDDDDD  );

#ifdef  NOT_JITC

    if (genStringObjects)
    {
        unsigned strHandle, *pStrHandle;
        strHandle = eeGetStringHandle(tree->gtStrCon.gtSconCPX,
                                      tree->gtStrCon.gtScpHnd,
                                      &pStrHandle);
        assert((!strHandle) != (!pStrHandle));

        // Can we access the string handle directly?

        if (strHandle)
            tree = gtNewIconNode(strHandle);
        else
        {
            tree = gtNewIconHandleNode((long)pStrHandle, GTF_ICON_STR_HDL);
            tree->gtFlags |= GTF_NON_GC_ADDR;
            tree = gtNewOperNode(GT_IND, TYP_I_IMPL, tree);
        }

        tree->gtFlags |= GTF_NON_GC_ADDR;
        tree = gtNewOperNode(GT_IND, TYP_REF, tree);
        return tree;
    }
    else
    {
        args = gtNewArgList(gtNewIconHandleNode(tree->gtStrCon.gtSconCPX,
                                                GTF_ICON_STR_HDL,
                                                tree->gtStrCon.gtSconCPX,
                                                tree->gtStrCon.gtScpHnd),
                            gtNewIconHandleNode((int)tree->gtStrCon.gtScpHnd,
                                                GTF_ICON_CLASS_HDL,
                                                THIS_CLASS_CP_IDX,
                                                tree->gtStrCon.gtScpHnd));
    }

#else // NOT_JITC

    if (genStringObjects)
    {
        tree = gtNewOperNode(GT_IND, TYP_REF,
                             gtNewIconNode(
                                eeGetStringHandle(tree->gtStrCon.gtSconCPX,
                                                  tree->gtStrCon.gtScpHnd,
                                                  NULL)));

        return tree;
    }
    else
    {
        args = gtNewArgList(gtNewIconHandleNode(tree->gtStrCon.gtSconCPX,
                                                GTF_ICON_STR_HDL,
                                                tree->gtStrCon.gtSconCPX,
                                                NULL),
                            gtNewIconHandleNode((int)tree->gtStrCon.gtScpHnd,
                                                GTF_ICON_CLASS_HDL,
                                                THIS_CLASS_CP_IDX,
                                                NULL));
    }

#endif // NOT_JITC

    /* Convert the string constant to a helper call */

    tree = fgMorphIntoHelperCall(tree, CPX_STRCNS, args);
    tree->gtType = TYP_REF;

#if !USE_FASTCALL
    /* for fastcall we already morphed all the arguments */
    tree = fgMorphTree(tree);
#endif

    return tree;
}

/*****************************************************************************
 *
 *  Transform the given GTK_LEAF tree for code generation.
 */

#if     TGT_IA64
extern  writePE *   genPEwriter;
#endif

GenTreePtr          Compiler::fgMorphLeaf(GenTreePtr tree)
{
    assert(tree->OperKind() & GTK_LEAF);

    switch(tree->OperGet())
    {

#if COPY_PROPAG

    case GT_LCL_VAR:
        tree = fgMorphLocalVar(tree, true);
        break;

#endif // COPY_PROPAG

        unsigned addr;

    case GT_FTN_ADDR:
        assert((SCOPE_HANDLE)tree->gtVal.gtVal2 == info.compScopeHnd  ||
                             tree->gtVal.gtVal2 != 0xDDDDDDDD          );

#if     TGT_IA64

        _uint64         offs;

        // This is obviously just a temp hack

        assert(sizeof(offs) == 8); offs = tree->gtVal.gtVal2;

        /* Grab the next available offset in the .sdata section */

        addr = genPEwriter->WPEsecNextOffs(PE_SECT_sdata);

        /* Output the function address (along with the appropriate fixup) */

        genPEwriter->WPEsecAddFixup(PE_SECT_sdata,
                                    PE_SECT_text,
                                    addr,
                                    true);

        genPEwriter->WPEsecAddData(PE_SECT_sdata, (BYTE*)&offs, sizeof(offs));

        /* The GP value will follow the function address */

        offs = 0;

        genPEwriter->WPEsecAddFixup(PE_SECT_sdata,
                                    PE_SECT_sdata,
                                    addr + 8,
                                    true);

        genPEwriter->WPEsecAddData(PE_SECT_sdata, (BYTE*)&offs, sizeof(offs));

        /* Record the address of the fnc descriptor in the node */

        tree->ChangeOper(GT_CNS_INT);
        tree->gtIntCon.gtIconVal = addr;

#else

        InfoAccessType accessType;

        addr = (unsigned)eeGetMethodPointer(
                                eeFindMethod(tree->gtVal.gtVal1,
                                             (SCOPE_HANDLE)tree->gtVal.gtVal2,
                                             0),
                                &accessType);

        tree->ChangeOper(GT_CNS_INT);
        tree->gtIntCon.gtIconVal = addr;

        switch(accessType)
        {
        case IAT_PPVALUE:
            tree = gtNewOperNode(GT_IND, TYP_I_IMPL, tree);
            tree->gtFlags |= GTF_NON_GC_ADDR;
            // Fall through
        case IAT_PVALUE:
            tree = gtNewOperNode(GT_IND, TYP_I_IMPL, tree);
            tree->gtFlags |= GTF_NON_GC_ADDR;
            // Fall through
        case IAT_VALUE:
            break;
        }

#endif

        break;

    case GT_ADDR:
        if (tree->gtOp.gtOp1->OperGet() == GT_LCL_VAR)
            tree->gtOp.gtOp1 = fgMorphLocalVar(tree->gtOp.gtOp1, false);

        /* CONSIDER : For GT_ADDR(GT_IND(ptr)) (typically created by
           CONSIDER : ldflda), we perform a null-ptr check on 'ptr'
           CONSIDER : during codegen. We could hoist these for
           CONSIDER : consecutive ldflda on the same object.
         */
        break;
    }

    return tree;
}

/*****************************************************************************
 *
 *  Transform the given GTK_SMPOP tree for code generation.
 */

GenTreePtr          Compiler::fgMorphSmpOp(GenTreePtr tree)
{
    assert(tree->OperKind() & GTK_SMPOP);

    GenTreePtr      op1              = tree->gtOp.gtOp1;
    GenTreePtr      op2              = tree->gtOp.gtOp2;

    /*-------------------------------------------------------------------------
     * First do any PRE-ORDER processing
     */

    switch(tree->OperGet())
    {
    case GT_JTRUE:
        assert(op1);
        assert(op1->OperKind() & GTK_RELOP);
        /* Mark the comparison node with GTF_JMP_USED so it knows that it does
           not need to materialize the result as a 0 or 1. */
        op1->gtFlags |= GTF_JMP_USED;
        break;

    case GT_QMARK:
        assert(op1->OperKind() & GTK_RELOP);
        assert(op1->gtFlags & GTF_QMARK_COND);
        assert(tree->gtFlags & GTF_OTHER_SIDEEFF);
        /* Mark the comparison node with GTF_JMP_USED so it knows that it does
           not need to materialize the result as a 0 or 1. */
        op1->gtFlags |= GTF_JMP_USED;
        break;

    case GT_INDEX:
        tree = gtNewRngChkNode(tree, op1, op2, tree->TypeGet(), tree->gtIndex.elemSize);
        return fgMorphSmpOp(tree);

    case GT_CAST:
        return fgMorphCast(tree);
    }

    /* Could this operator throw an exception? */

    if  (tree->OperMayThrow())
    {
        /* Mark the tree node as potentially throwing an exception */
        tree->gtFlags |= GTF_EXCEPT;
    }

    /*-------------------------------------------------------------------------
     * Process the first operand, if any
     */

    if  (op1)
    {
        tree->gtOp.gtOp1 = op1 = fgMorphTree(op1);

#if     CSELENGTH

        /* For GT_IND, the array length node might have been pointing
           to the array object which was a sub-tree of op1. As op1 might
           have just changed above, find out where to point to now. */

        if (tree->OperGet() == GT_IND               &&
            (tree->gtFlags & GTF_IND_RNGCHK)        &&
            tree->gtInd.gtIndLen->gtArrLen.gtArrLenAdr)
        {
            assert(op1->gtOper == GT_ADD && op1->gtType == TYP_REF);

            /* @TODO : We do this very badly now by searching for the
               array in op1. Need to do it in a better fashion, maybe
               like gtCloneExpr() does using gtCopyAddrVal */

            GenTreePtr addr = op1->gtOp.gtOp1;
                                                 // Array-object can be ...
            while (!(addr->OperKind() & GTK_LEAF) && // lcl var
                   (addr->gtOper != GT_IND)       && // GT_FIELD (morphed to GT_IND)
                   (addr->gtOper != GT_CALL))        // return value of call
            {
                assert(addr->gtType == TYP_REF);
                assert(addr->gtOper == GT_ADD || addr->gtOper == GT_LSH ||
                       addr->gtOper == GT_MUL || addr->gtOper == GT_COMMA);

                if  (addr->gtOp.gtOp2->gtType == TYP_REF)
                    addr = addr->gtOp.gtOp2;
                else
                    addr = addr->gtOp.gtOp1;
            }

            assert(addr->gtType == TYP_REF);
            tree->gtInd.gtIndLen->gtArrLen.gtArrLenAdr = addr;
        }
#endif

        /* Morphing along with folding and inlining may have changed the
         * side effect flags, so we have to reset them
         *
         * NOTE: Don't reset the exception flags on nodes that may throw */

        assert(tree->gtOper != GT_CALL);
        tree->gtFlags &= ~GTF_CALL;

        if  (!tree->OperMayThrow())
            tree->gtFlags &= ~GTF_EXCEPT;

        /* Propagate the new flags */

        tree->gtFlags |= (op1->gtFlags & GTF_GLOB_EFFECT);

        /* OPTIMIZATION:
         * Initially field accesses are marked as throwing an exception (the object may be null)
         * However, if the object is "this" and it is not modified during the method, then
         * we can remove the GTF_EXCEPT flag from the node (which we do when we hoist or morph
         * GT_FIELD to GT_IND) */

        //if  (!tree->OperMayThrow())
        //    tree->gtFlags &= ~GTF_EXCEPT | (op1->gtFlags & GTF_EXCEPT);
    }

    /*-------------------------------------------------------------------------
     * Process the second operand, if any
     */

    if  (op2)
    {
        //
        // For QMARK-COLON trees we clear any recorded copy assignments
        // before morphing the else node and again after
        // morphing the else node.
        // This is conservative and we may want to be more precise
        //
        bool isQmarkColon = (tree->OperGet() == GT_COLON);

        if (isQmarkColon)
            optCopyAsgCount = 0;

        tree->gtOp.gtOp2 = op2 = fgMorphTree(op2);
        tree->gtFlags |= (op2->gtFlags & GTF_GLOB_EFFECT);

        if (isQmarkColon)
            optCopyAsgCount = 0;
    }


DONE_MORPHING_CHILDREN:

    /*-------------------------------------------------------------------------
     * Now do POST-ORDER processing
     */

#if COPY_PROPAG

    /* If this is an assignment to a local variable kill that variable's entry
     * in the copy prop table - make sure to do this only during global morphing */

    if (fgGlobalMorph                          &&
        tree->OperKind() & GTK_ASGOP           &&
        tree->gtOp.gtOp1->gtOper == GT_LCL_VAR  )
    {
        unsigned  leftLclNum  = tree->gtOp.gtOp1->gtLclVar.gtLclNum;

        /* If we have a record in the table about this variable,    */
        /* then delete it since the information is no longer valid  */
        unsigned i = 0;
        while (i < optCopyAsgCount)
        {
            if (leftLclNum == optCopyAsgTab[i].leftLclNum  ||
                leftLclNum == optCopyAsgTab[i].rightLclNum  )
            {
#ifdef DEBUG
                if(verbose)
                {
                    printf("The assignment [%08X] removes copy propagation candidate: lcl #%02u = lcl #%02u\n",
                            tree, optCopyAsgTab[i].leftLclNum, optCopyAsgTab[i].rightLclNum);
                }
#endif
                assert(optCopyAsgCount > 0);

                optCopyAsgCount--;

                /*  Two cases to consider if i == optCopyAsgCount then the last entry
                 *  in the table is too be removed and that happens automatically when
                 *  optCopyAsgCount is decremented,
                 *  The other case is when i < optCopyAsgCount and here we overwrite the
                 *  i-th entry in the table with the data found at the end of the table
                 */
                if (i < optCopyAsgCount)
                {
                    optCopyAsgTab[i].rightLclNum = optCopyAsgTab[optCopyAsgCount].rightLclNum;
                    optCopyAsgTab[i].leftLclNum  = optCopyAsgTab[optCopyAsgCount].leftLclNum;
                }

                // We will have to redo the i-th iteration
                continue;
            }
            i++;
        }
    }
#endif

    /* Try to fold it, maybe we get lucky */

    tree = gtFoldExpr(tree);
    op1  = tree->gtOp.gtOp1;
    op2  = tree->gtOp.gtOp2;

    genTreeOps      oper    = tree->OperGet();
    var_types       typ     = tree->TypeGet();

    /*-------------------------------------------------------------------------
     * Perform the required oper-specific postorder morphing
     */

    switch (oper)
    {
        GenTreePtr      temp;
        GenTreePtr      addr;
        GenTreePtr      cns1, cns2;
        genTreeOps      cmop;
        unsigned        ival1, ival2;

#if COPY_PROPAG

    case GT_ASG:

        /* Check for local_A = local_B assignments and record them in a table */

        if (fgGlobalMorph                         &&  // the right phase?
            (optCopyAsgCount < MAX_COPY_PROP_TAB) &&  // room in the table?
            optIsCopyAsg(tree))                       // A copy assign?
        {
            /* Copy propagation candidate - record it in the table */

            unsigned  i;
            bool      recorded    = false;
            unsigned  leftLclNum  = tree->gtOp.gtOp1->gtLclVar.gtLclNum;
            unsigned  rightLclNum = tree->gtOp.gtOp2->gtLclVar.gtLclNum;

            /* First check if our right-hand side is already redefined */
            /* in the CopyAsgTab[], if so then use the redefined value */

            for(i = 0; i < optCopyAsgCount; i++)
            {
                if (rightLclNum == optCopyAsgTab[i].leftLclNum)
                {
                    rightLclNum = optCopyAsgTab[i].rightLclNum;
                    //
                    // We can't have more than one match so take an early exit
                    //
                    break;
                }
            }

            /* Next check if our left-hand side is already in the table   */
            /* and if so then replace the old definition with the new one */

            for(i = 0; i < optCopyAsgCount; i++)
            {
                if (leftLclNum == optCopyAsgTab[i].leftLclNum)
                {
                    optCopyAsgTab[i].rightLclNum = rightLclNum;
                    recorded = true;
                    break;
                }
            }

            if (!recorded)
            {
                optCopyAsgTab[optCopyAsgCount].leftLclNum  = leftLclNum;
                optCopyAsgTab[optCopyAsgCount].rightLclNum = rightLclNum;

                optCopyAsgCount++;
            }

            assert(optCopyAsgCount <= MAX_COPY_PROP_TAB);

#ifdef DEBUG
            if(verbose)
            {
                printf("Added copy propagation candidate [%08X]: lcl #%02u = lcl #%02u\n",
                        tree, leftLclNum, rightLclNum);
            }
#endif
        }

        break;
#endif

    case GT_EQ:
    case GT_NE:

        cns1 = tree->gtOp.gtOp2;

        if (false) // Cant do it because expr+/-icon1 may over/under-flow.
        {
            /* Check for "expr +/- icon1 ==/!= non-zero-icon2" */

            if  (cns1->gtOper == GT_CNS_INT && cns1->gtIntCon.gtIconVal != 0)
            {
                op1 = tree->gtOp.gtOp1;

                if  ((op1->gtOper == GT_ADD ||
                      op1->gtOper == GT_SUB) && op1->gtOp.gtOp2->gtOper == GT_CNS_INT)
                {
                    /* Got it; change "x+icon1==icon2" to "x==icon2-icon1" */

                    ival1 = op1->gtOp.gtOp2->gtIntCon.gtIconVal;
                    if  (op1->gtOper == GT_ADD)
                        ival1 = -ival1;

                    cns1->gtIntCon.gtIconVal += ival1;

                    tree->gtOp.gtOp1 = op1->gtOp.gtOp1;
                }

                goto COMPARE;
            }
        }

        /* Check for "relOp == 0/1". We can directly use relOp */

        if ((cns1->gtOper == GT_CNS_INT) &&
            (cns1->gtIntCon.gtIconVal == 0 || cns1->gtIntCon.gtIconVal == 1) &&
            (op1->OperIsCompare()))
        {
            if (cns1->gtIntCon.gtIconVal == 0)
                op1->gtOper = GenTree::ReverseRelop(op1->OperGet());

            assert((op1->gtFlags & GTF_JMP_USED) == 0);
            op1->gtFlags |= tree->gtFlags & GTF_JMP_USED;

            DEBUG_DESTROY_NODE(tree);
            return op1;
        }

        /* Check for comparisons with small longs that can be cast to int */

        if  (cns1->gtOper != GT_CNS_LNG)
            goto COMPARE;

        /* Are we comparing against a small const? */

        if  ((long)(cns1->gtLngCon.gtLconVal >> 32) != 0)
            goto COMPARE;

        /* Is the first comparand mask operation of type long ? */

        temp = tree->gtOp.gtOp1;
        if  (temp->gtOper != GT_AND)
        {
            /* Another interesting case: cast from int */

            if  (temp->gtOper             == GT_CAST &&
                 temp->gtOp.gtOp1->gtType == TYP_INT &&
                 !temp->gtOverflow()                  )
            {
                /* Simply make this into an integer comparison */

                tree->gtType     = TYP_INT;
                tree->gtOp.gtOp1 = temp->gtOp.gtOp1;
                tree->gtOp.gtOp2 = gtNewIconNode((int)cns1->gtLngCon.gtLconVal, TYP_INT);
            }

            goto COMPARE;
        }

        assert(temp->TypeGet() == TYP_LONG);

        /* Is the result of the mask effectively an INT ? */

        addr = temp->gtOp.gtOp2;
        if  (addr->gtOper != GT_CNS_LNG)
            goto COMPARE;
        if  ((long)(addr->gtLngCon.gtLconVal >> 32) != 0)
            goto COMPARE;

        /* Now we know that we can cast op1 of AND to int */

        /* Allocate a large node, might be bashed later (GT_IND) */

        temp->gtOp.gtOp1 = gtNewLargeOperNode(GT_CAST,
                                              TYP_INT,
                                              temp->gtOp.gtOp1,
                                              gtNewIconNode((long)TYP_INT,
                                                            TYP_INT));

        /* now replace the mask node (op2 of AND node) */

        assert(addr == temp->gtOp.gtOp2);

        ival1 = (long)addr->gtLngCon.gtLconVal;
        addr->ChangeOper(GT_CNS_INT);
        addr->gtType             = TYP_INT;
        addr->gtIntCon.gtIconVal = ival1;

        /* now bash the type of the AND node */

        temp->gtType = TYP_INT;

        /* finally we replace the comparand */

        ival1 = (long)cns1->gtLngCon.gtLconVal;
        cns1->ChangeOper(GT_CNS_INT);
        cns1->gtType = TYP_INT;

        assert(cns1 == tree->gtOp.gtOp2);
        cns1->gtIntCon.gtIconVal = ival1;

        goto COMPARE;

    case GT_LT:
    case GT_LE:
    case GT_GE:
    case GT_GT:

COMPARE:

#if !OPTIMIZE_QMARK
#error "Need OPTIMIZE_QMARK for use of comparison as value (of non-jump)"
#endif
        assert(tree->OperKind() & GTK_RELOP);

        /* Check if the result of the comparison is used for a jump
         * If not the only the int (i.e. 32 bit) case is handled in
         * the code generator through the "set" instructions
         * For the rest of the cases we have the simplest way is to
         * "simulate" the comparison with ?:
         *
         * CONSIDER: Maybe special code can be added to genTreeForLong/Float
         *           to handle these special cases (e.g. check the FP flags) */

        if ((genActualType(    op1->TypeGet()) == TYP_LONG ||
             varTypeIsFloating(op1->TypeGet()) == true       ) &&
            !(tree->gtFlags & GTF_JMP_USED))
        {
            /* We convert it to "(CMP_TRUE) ? (1):(0)" */

            op1             = tree;
            op1->gtFlags   |= GTF_JMP_USED | GTF_QMARK_COND;

            op2             = gtNewOperNode(GT_COLON, TYP_INT,
                                            gtNewIconNode(0),
                                            gtNewIconNode(1));

            tree            = gtNewOperNode(GT_QMARK, TYP_INT, op1, op2);
            tree->gtFlags |= GTF_OTHER_SIDEEFF;
        }
        break;


#if OPTIMIZE_QMARK

    case GT_QMARK:

        // Is we have (cond)?1:0, then we just return "cond" for TYP_INTs

        if (genActualType(op1->gtOp.gtOp1->gtType) != TYP_INT ||
            genActualType(typ)                     != TYP_INT)
            break;

        cns1 = op2->gtOp.gtOp1;
        cns2 = op2->gtOp.gtOp2;
        if (cns1->gtOper != GT_CNS_INT || cns1->gtOper != GT_CNS_INT)
            break;
        ival1 = cns1->gtIntCon.gtIconVal;
        ival2 = cns2->gtIntCon.gtIconVal;

        // Is one constant 0 and the other 1
        if ((ival1 | ival2) != 1 || (ival1 & ival2) != 0)
            break;

        // If the constants are {1, 0}, reverse the condition
        if (ival1 == 1)
            op1->gtOper = GenTree::ReverseRelop(op1->OperGet());

        // Unmark GTF_JMP_USED on the condition node so it knows that it
        // needs to materialize the result as a 0 or 1.
        assert(op1->gtFlags &   (GTF_QMARK_COND|GTF_JMP_USED));
               op1->gtFlags &= ~(GTF_QMARK_COND|GTF_JMP_USED);

        DEBUG_DESTROY_NODE(tree);
        DEBUG_DESTROY_NODE(op2);

        return op1;

#endif


    case GT_MUL:

#if!LONG_MATH_REGPARAM && !TGT_IA64

        if  (typ == TYP_LONG)
        {
            if  ((op1->gtOper             == GT_CAST &&
                  op2->gtOper             == GT_CAST &&
                  op1->gtOp.gtOp1->gtType == TYP_INT &&
                  op2->gtOp.gtOp1->gtType == TYP_INT))
            {
                /* For (long)int1 * (long)int2, we dont actually do the
                 * casts, and just multiply the 32 bit values, which will
                 * give us the 64 bit result in edx:eax (GTF_MUL_64RSLT)
                 */

                if (tree->gtOverflow())
                {
                    /* This can never overflow during long mul. */

                    tree->gtFlags &= ~GTF_OVERFLOW;
                }
            }
            else
            {
                int helper;

                if (tree->gtOverflow())
                {
                    if (tree->gtFlags & GTF_UNSIGNED)
                        helper = CPX_ULONG_MUL_OVF;
                    else
                        helper = CPX_LONG_MUL_OVF;
                }
                else
                {
                    helper = CPX_LONG_MUL;
                }

                tree = fgMorphLongBinop(tree, helper);
                return tree;
            }
        }
#endif // !LONG_MATH_REGPARAM

        cmop = oper;

        goto CM_OVF_OP;

    case GT_SUB:

        cmop = GT_NONE;         // ISSUE: is it safe to use 'GT_ADD' here?

        if (tree->gtOverflow()) goto CM_OVF_OP;

        /* Check for "op1 - cns2" , we change it to "op1 + (-cns2)" */

        if  (!op2->OperIsConst() || op2->gtType != TYP_INT)
            break;

        /* Negate the constant and change the node to be "+" */

        op2->gtIntCon.gtIconVal = -op2->gtIntCon.gtIconVal;

        tree->gtOper = oper = GT_ADD;

        // Fall through, since we now have a "+" node ...

    case GT_ADD:

CM_OVF_OP:

        if (tree->gtOverflow())
        {
            // Add the excptn-throwing basic block to jump to on overflow

            fgAddCodeRef(compCurBB, compCurBB->bbTryIndex, ACK_OVERFLOW, fgPtrArgCntCur);

            // We cant do any commutative morphing for overflow instructions

            break;
        }

        // CONSIDER: fgMorph ((x+icon1)+(y+icon2)) to ((x+y)+(icon1+icon2))
        // CONSIDER: and "((x+icon1)+icon2) to (x+(icon1+icon2)) - this
        // CONSIDER: always generates better code.

    case GT_OR:
    case GT_XOR:
    case GT_AND:

        cmop = oper;

        /* Commute any constants to the right */

        if  (op1->OperIsConst())
        {
            /* Any constant cases should have been folded earlier */
            assert(!op2->OperIsConst());

            /* Swap the operands */
            assert((tree->gtFlags & GTF_REVERSE_OPS) == 0);

            tree->gtOp.gtOp1 = op2;
            tree->gtOp.gtOp2 = op1;

            op1 = op2;
            op2 = tree->gtOp.gtOp2;
        }

        /* See if we can fold GT_MUL nodes. This could be done optionally but
           as GT_MUL nodes are used in all array accesses, this is done here */

        if (oper == GT_MUL && op2->gtOper == GT_CNS_INT)
        {
            assert(typ <= TYP_UINT);

            unsigned mult = op2->gtIntCon.gtIconVal;

            /* Weed out the trivial cases */

            if      (mult == 0)
            {
                