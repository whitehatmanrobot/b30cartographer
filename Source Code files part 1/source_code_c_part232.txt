                      );

    //
    // Render the Site
    //

    deltavpos = 
        RenderACUIStringToEditControl(Resources(),
                                      hwnd,
                                      IDC_SITE,
                                      IDC_ZONE,
                                      m_pszSite,
                                      deltavpos,
                                      FALSE,
                                      NULL,
                                      NULL,
                                      0,
                                      NULL);
    

    //
    // Render the ZONE
    //

    deltavpos = 
        RenderACUIStringToEditControl(Resources(),
                                      hwnd,
                                      IDC_ZONE,
                                      IDC_ENCLOSED,
                                      m_pszZone,
                                      deltavpos,
                                      FALSE,
                                      NULL,
                                      NULL,
                                      0,
                                      NULL);


    //
    // Render the Enclosed
    //

    deltavpos = 
        RenderACUIStringToEditControl(Resources(),
                                      hwnd,
                                      IDC_ENCLOSED,
                                      IDC_CHECKACTION,
                                      m_pszEnclosed,
                                      deltavpos,
                                      FALSE,
                                      NULL,
                                      NULL,
                                      0,
                                      NULL);

    //
    // Calculate the distances from the bottom of the bitmap to the top
    // of the separator and from the bottom of the separator to the bottom
    // of the dialog
    //

    bmptosep = CalculateControlVerticalDistance(hwnd,
                                                IDC_NOVERBMP,
                                                IDC_SEPARATORLINE);

    septodlg = CalculateControlVerticalDistanceFromDlgBottom(hwnd,
                                                             IDC_SEPARATORLINE);


    //
    // Render the CHECKACTION
    //

    hControl = GetDlgItem(hwnd, IDC_CHECKACTION);
    RebaseControlVertical(hwnd,
                          hControl,
                          NULL,
                          FALSE,
                          deltavpos,
                          0,
                          bmptosep,
                          &deltaheight);
    _ASSERTE(deltaheight == 0);


    //
    // Rebase the static line
    //

    hControl = GetDlgItem(hwnd, IDC_SEPARATORLINE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );

    //
    // Rebase the buttons
    //

    hControl = GetDlgItem(hwnd, IDYES);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDNO);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDMORE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );

    //
    // Resize the bitmap and the dialog rectangle if necessary
    //

    if ( deltavpos > 0 )
    {
        int cyupd;

        hControl = GetDlgItem(hwnd, IDC_NOVERBMP);
        GetWindowRect(hControl, &rect);

        cyupd = CalculateControlVerticalDistance(
                                                 hwnd,
                                                 IDC_NOVERBMP,
                                                 IDC_SEPARATORLINE
                                                 );

        cyupd -= bmptosep;

        SetWindowPos(
                     hControl,
                     NULL,
                     0,
                     0,
                     rect.right - rect.left,
                     (rect.bottom - rect.top) + cyupd,
                     SWP_NOZORDER | SWP_NOMOVE
                     );

        GetWindowRect(hwnd, &rect);

        cyupd = CalculateControlVerticalDistanceFromDlgBottom(
                                                              hwnd,
                                                              IDC_SEPARATORLINE
                                                              );

        cyupd = septodlg - cyupd;

        SetWindowPos(
                     hwnd,
                     NULL,
                     0,
                     0,
                     rect.right - rect.left,
                     (rect.bottom - rect.top) + cyupd,
                     SWP_NOZORDER | SWP_NOMOVE
                     );
    }

    //
    //  check for overridden button texts
    //
    this->SetupButtons(hwnd);

    //
    // Set focus to appropriate control
    //

    hControl = GetDlgItem(hwnd, IDYES);
    WszPostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM) hControl, (LPARAM) MAKEWORD(TRUE, 0));

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnYes, public
//
//  Synopsis:   process IDYES button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnYes (HWND hwnd)
{
    m_hrInvokeResult = S_OK;
    m_riih.ClearFlag();
    m_riih.AddFlag(COR_UNSIGNED_YES);

    //
    // If we always select it record that in the flag
    //
    if ( WszSendDlgItemMessage(
             hwnd,
             IDC_CHECKACTION,
             BM_GETCHECK,
             0,
             0
             ) == BST_CHECKED )
    {
        HRESULT hr = S_OK;
        EndDialog(hwnd, (int)m_hrInvokeResult);
        CConfirmationUI confirm(m_riih.Resources(), TRUE, m_riih.Zone(), hr);
        if(SUCCEEDED(hr)) {
            if(SUCCEEDED(confirm.InvokeUI(hwnd))) {
                m_riih.AddFlag(COR_UNSIGNED_ALWAYS);
            }
        }
    }
    else {
        EndDialog(hwnd, (int)m_hrInvokeResult);
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnNo, public
//
//  Synopsis:   process IDNO button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnNo (HWND hwnd)
{
    m_hrInvokeResult = TRUST_E_SUBJECT_NOT_TRUSTED;
    m_riih.ClearFlag();
    m_riih.AddFlag(COR_UNSIGNED_NO);

    //
    // If we always select it record that in the flag
    //
    if ( WszSendDlgItemMessage(
             hwnd,
             IDC_CHECKACTION,
             BM_GETCHECK,
             0,
             0
             ) == BST_CHECKED )
    {
        HRESULT hr = S_OK;
        EndDialog(hwnd, (int)m_hrInvokeResult);
        CConfirmationUI confirm(m_riih.Resources(), FALSE, m_riih.Zone(), hr);
        if(SUCCEEDED(hr)) {
            if(SUCCEEDED(confirm.InvokeUI(hwnd))) {
                m_riih.AddFlag(COR_UNSIGNED_ALWAYS);
            }
        }
    }
    else {
        EndDialog(hwnd, (int)m_hrInvokeResult);
    }
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CUnverifiedTrustUI::OnMore, public
//
//  Synopsis:   process the IDMORE button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CUnverifiedTrustUI::OnMore (HWND hwnd)
{
    //WinHelp(hwnd, "SECAUTH.HLP", HELP_CONTEXT, IDH_SECAUTH_SIGNED_N_INVALID);
    //ACUIViewHTMLHelpTopic(hwnd, "sec_signed_n_invalid.htm");
    HRESULT hr = E_FAIL;
    CLearnMoreUI more(m_riih.Resources(), hr);
    if(SUCCEEDED(hr))
        more.InvokeUI(hwnd);
        
    return( TRUE );
}


BOOL 
CUnverifiedTrustUI::ShowYes (LPWSTR* pText)
{
    BOOL result = TRUE;
    if ((m_riih.ProviderData()) &&
        (m_riih.ProviderData()->psPfns) &&
        (m_riih.ProviderData()->psPfns->psUIpfns) &&
        (m_riih.ProviderData()->psPfns->psUIpfns->psUIData))
    {
        if (m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pYesButtonText)
        {
            if(m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pYesButtonText[0] && pText)
                *pText = m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pYesButtonText;
        }
    }
    return result;
}

BOOL 
CUnverifiedTrustUI::ShowNo (LPWSTR* pText)
{
    BOOL result = TRUE;
    if ((m_riih.ProviderData()) &&
        (m_riih.ProviderData()->psPfns) &&
        (m_riih.ProviderData()->psPfns->psUIpfns) &&
        (m_riih.ProviderData()->psPfns->psUIpfns->psUIData))
    {
        if (m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pNoButtonText)
        {
            if(m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pNoButtonText[0] && pText)
                *pText = m_riih.ProviderData()->psPfns->psUIpfns->psUIData->pNoButtonText;
        }
    }
    return result;
}

BOOL
CUnverifiedTrustUI::ShowMore (LPWSTR* pText)
{
    return TRUE;
}


//*****************************************************************************
//*****************************************************************************


CLearnMoreUI::CLearnMoreUI (HINSTANCE hResources, HRESULT& rhr) : 
    IACUIControl(hResources),
    m_pszLearnMore(NULL)
{
    //
    // Add the first line that states the managed control
    // is not signed with authenticode.
    //

    
    rhr = FormatACUIResourceString(Resources(),
                                   IDS_LEARNMORE,
                                   NULL,
                                   &m_pszLearnMore);


    if(SUCCEEDED(rhr)) {
        m_pszContinueText = new WCHAR[50];
        if ( WszLoadString(hResources, 
                           IDS_CONTINUE_BUTTONTEXT, 
                           m_pszContinueText, 
                           50) == 0 )
        {
            rhr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLearnMoreUI::~CLearnMoreUI, public
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CLearnMoreUI::~CLearnMoreUI ()
{
    delete [] m_pszLearnMore;
    delete [] m_pszContinueText;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLearnMoreUI::InvokeUI, public
//
//  Synopsis:   invoke the UI
//
//  Arguments:  [hDisplay] -- parent window
//
//  Returns:    S_OK, user trusts the subject
//              TRUST_E_SUBJECT_NOT_TRUSTED, user does NOT trust the subject
//              Any other valid HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CLearnMoreUI::InvokeUI (HWND hDisplay)
{
    HRESULT hr = S_OK;

    //
    // Bring up the dialog
    //

    if ( WszDialogBoxParam(Resources(),
                           (LPWSTR) MAKEINTRESOURCEW(IDD_DIALOG_LEARNMORE),
                           hDisplay,
                           IACUIControl::ACUIMessageProc,
                           (LPARAM)this) == -1 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // The result has been stored as a member
    //

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLearnMoreUI::OnInitDialog, public
//
//  Synopsis:   dialog initialization
//
//  Arguments:  [hwnd]   -- dialog window
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if successful init, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CLearnMoreUI::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HWND hControl;
    int  deltavpos = 0;
    int  deltaheight;
 
    RECT rect;

    //
    // Render the Unsigned prompt
    //

    deltavpos = RenderACUIStringToEditControl(Resources(),
                                              hwnd,
                                              IDC_LEARNMORE,
                                              IDC_SEPARATORLINE,
                                              m_pszLearnMore,
                                              deltavpos,
                                              FALSE,
                                              NULL,
                                              NULL,
                                              0,
                                              NULL);


    //
    // The separator line
    //
    hControl = GetDlgItem(hwnd, IDC_SEPARATORLINE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );

    //
    // Rebase the buttons
    //

    hControl = GetDlgItem(hwnd, IDYES);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDNO);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDMORE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );


    //
    // Resize the bitmap and the dialog rectangle if necessary
    //

    if ( deltavpos > 0 )
    {
        GetWindowRect(hwnd, &rect);
        SetWindowPos(
                     hwnd,
                     NULL,
                     0,
                     0,
                     rect.right - rect.left,
                     (rect.bottom - rect.top) + deltavpos,
                     SWP_NOZORDER | SWP_NOMOVE
                     );
    }

    //
    //  check for overridden button texts
    //
    this->SetupButtons(hwnd);

    //
    // Set focus to appropriate control
    //
 
    hControl = GetDlgItem(hwnd, IDMORE);
    WszPostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM) hControl, (LPARAM) MAKEWORD(TRUE, 0));

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLearnMoreUI::OnYes, public
//
//  Synopsis:   process IDYES button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CLearnMoreUI::OnYes (HWND hwnd)
{
    EndDialog(hwnd, S_OK);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLearnMoreUI::OnNo, public
//
//  Synopsis:   process IDNO button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CLearnMoreUI::OnNo (HWND hwnd)
{
    EndDialog(hwnd, S_OK);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLearnMoreUI::OnMore, public
//
//  Synopsis:   process the IDMORE button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CLearnMoreUI::OnMore (HWND hwnd)
{
    EndDialog(hwnd, S_OK);
    return( TRUE );
}


BOOL 
CLearnMoreUI::ShowYes (LPWSTR* pText)
{
    return FALSE;
}

BOOL 
CLearnMoreUI::ShowNo (LPWSTR* pText)
{
    return FALSE;
}

BOOL
CLearnMoreUI::ShowMore (LPWSTR* pText)
{
    if(pText)
        *pText = m_pszContinueText;
    return TRUE;
}


//*****************************************************************************
//*****************************************************************************


CConfirmationUI::CConfirmationUI (HINSTANCE hResources, BOOL fAlwaysAllow, LPCWSTR wszZone, HRESULT& rhr) : 
    IACUIControl(hResources),
    m_pszConfirmation(NULL),
    m_pszConfirmationNext(NULL),
    m_hresult(S_OK)
{
    DWORD confirmationID;

    if(fAlwaysAllow) 
        confirmationID = IDS_CONFIRMATION_YES;
    else
        confirmationID = IDS_CONFIRMATION_NO;
    
	DWORD_PTR aMessageArgument[3];    
	aMessageArgument[0] = (DWORD_PTR) wszZone;

    rhr = FormatACUIResourceString(Resources(),
                                   confirmationID,
                                   aMessageArgument,
                                   &m_pszConfirmation);


    //
    // Add the first line that states the managed control
    // is not signed with authenticode.
    //
    if(SUCCEEDED(rhr)) {
        rhr = FormatACUIResourceString(Resources(),
                                       IDS_CONFIRMATION_NEXT,
                                       NULL,
                                       &m_pszConfirmationNext);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CConfirmationUI::~CConfirmationUI, public
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    (none)
//
//  Notes:
//
//----------------------------------------------------------------------------
CConfirmationUI::~CConfirmationUI ()
{
    delete [] m_pszConfirmation;
    delete [] m_pszConfirmationNext;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConfirmationUI::InvokeUI, public
//
//  Synopsis:   invoke the UI
//
//  Arguments:  [hDisplay] -- parent window
//
//  Returns:    S_OK when the user agrees
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CConfirmationUI::InvokeUI (HWND hDisplay)
{
    HRESULT hr = S_OK;

    //
    // Bring up the dialog
    //

    if ( WszDialogBoxParam(Resources(),
                           (LPWSTR) MAKEINTRESOURCEW(IDD_DIALOG_CONFIRMATION),
                           hDisplay,
                           IACUIControl::ACUIMessageProc,
                           (LPARAM)this) == -1 )
    {
        return( HRESULT_FROM_WIN32(GetLastError()) );
    }

    //
    // The result has been stored as a member
    //

    return( m_hresult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CConfirmationUI::OnInitDialog, public
//
//  Synopsis:   dialog initialization
//
//  Arguments:  [hwnd]   -- dialog window
//              [wParam] -- parameter 1
//              [lParam] -- parameter 2
//
//  Returns:    TRUE if successful init, FALSE otherwise
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CConfirmationUI::OnInitDialog(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    HWND hControl;
    int  deltavpos = 0;
    int  deltaheight;
 
    RECT rect;

    //
    // Render the Unsigned prompt
    //

    deltavpos = RenderACUIStringToEditControl(Resources(),
                                              hwnd,
                                              IDC_CONFIRMATION_TEXT1,
                                              IDC_CONFIRMATION_TEXT2,
                                              m_pszConfirmation,
                                              deltavpos,
                                              FALSE,
                                              NULL,
                                              NULL,
                                              0,
                                              NULL);


    deltavpos = RenderACUIStringToEditControl(Resources(),
                                              hwnd,
                                              IDC_CONFIRMATION_TEXT2,
                                              IDC_SEPARATORLINE,
                                              m_pszConfirmationNext,
                                              deltavpos,
                                              FALSE,
                                              NULL,
                                              NULL,
                                              0,
                                              NULL);


    //
    // The separator line
    //
    hControl = GetDlgItem(hwnd, IDC_SEPARATORLINE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );

    //
    // Rebase the buttons
    //

    hControl = GetDlgItem(hwnd, IDYES);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDNO);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );

    hControl = GetDlgItem(hwnd, IDMORE);
    RebaseControlVertical(hwnd, hControl, NULL, FALSE, deltavpos, 0, 0, &deltaheight);
    _ASSERTE( deltaheight == 0 );


    //
    // Resize the bitmap and the dialog rectangle if necessary
    //

    if ( deltavpos > 0 )
    {
        GetWindowRect(hwnd, &rect);
        SetWindowPos(hwnd,
                     NULL,
                     0,
                     0,
                     rect.right - rect.left,
                     (rect.bottom - rect.top) + deltavpos,
                     SWP_NOZORDER | SWP_NOMOVE
                     );
    }

    //
    //  check for overridden button texts
    //
    this->SetupButtons(hwnd);

    //
    // Set focus to appropriate control
    //
 
    hControl = GetDlgItem(hwnd, IDMORE);
    WszPostMessage(hwnd, WM_NEXTDLGCTL, (WPARAM) hControl, (LPARAM) MAKEWORD(TRUE, 0));

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CConfirmationUI::OnYes, public
//
//  Synopsis:   process IDYES button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CConfirmationUI::OnYes (HWND hwnd)
{
    EndDialog(hwnd, S_OK);
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CConfirmationUI::OnNo, public
//
//  Synopsis:   process IDNO button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CConfirmationUI::OnNo (HWND hwnd)
{
    EndDialog(hwnd, S_OK);
    m_hresult = E_FAIL;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CConfirmationUI::OnMore, public
//
//  Synopsis:   process the IDMORE button click
//
//  Arguments:  [hwnd] -- window handle
//
//  Returns:    TRUE
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CConfirmationUI::OnMore (HWND hwnd)
{
    EndDialog(hwnd, S_OK);
    return( TRUE );
}


BOOL 
CConfirmationUI::ShowYes (LPWSTR* pText)
{
    return TRUE;
}

BOOL 
CConfirmationUI::ShowNo (LPWSTR* pText)
{
    return TRUE;
}

BOOL
CConfirmationUI::ShowMore (LPWSTR* pText)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "mscorsec.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Security module\0"
#define VER_ORIGFILENAME_STR    "mscorsec.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\uicontrol.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************
#if !defined(__UICONTROL_H__)
#define __UICONTROL_H__

#include "acui.h"
#include "iih.h"


//
// CUnverifiedTrustUI class is used to invoke authenticode UI where the
// trust hierarchy for the signer has been NOT been successfully verified and
// the user has to make an override decision
//

class CUnverifiedTrustUI : public IACUIControl
{
public:
    //
    // Initialization
    //

    CUnverifiedTrustUI (CInvokeInfoHelper& riih, HRESULT& rhr);

    ~CUnverifiedTrustUI ();

    //
    // IACUIControl methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay);
    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam);
    virtual BOOL OnYes (HWND hwnd);
    virtual BOOL OnNo (HWND hwnd);
    virtual BOOL OnMore (HWND hwnd);
    virtual BOOL ShowYes(LPWSTR*);
    virtual BOOL ShowNo(LPWSTR*);
    virtual BOOL ShowMore(LPWSTR*);


private:

    //
    // Formatted strings for display
    //

    LPWSTR              m_pszNoAuthenticity;
    LPWSTR              m_pszSite;
    LPWSTR              m_pszZone;
    LPWSTR              m_pszEnclosed;
    LPWSTR              m_pszLink;

    //
    // Invoke Info Helper reference
    //

    CInvokeInfoHelper& m_riih;

    //
    // Invoke result
    //

    HRESULT             m_hrInvokeResult;

};


class CLearnMoreUI : public IACUIControl
{
public:

    //
    // Initialization
    //

    CLearnMoreUI(HINSTANCE hResources, HRESULT& rhr);
    ~CLearnMoreUI ();

    //
    // IACUIControl methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay);

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam);

    virtual BOOL OnYes (HWND hwnd);

    virtual BOOL OnNo (HWND hwnd);

    virtual BOOL OnMore (HWND hwnd);

    virtual BOOL ShowYes(LPWSTR*);
    virtual BOOL ShowNo(LPWSTR*);
    virtual BOOL ShowMore(LPWSTR*);

private:

    LPWSTR m_pszLearnMore;
    LPWSTR m_pszContinueText;
};

class CConfirmationUI : public IACUIControl
{
public:

    //
    // Initialization
    //

    CConfirmationUI(HINSTANCE hResources,  BOOL fAlwaysAllow, LPCWSTR wszZone, HRESULT& rhr);
    ~CConfirmationUI ();

    //
    // IACUIControl methods
    //

    virtual HRESULT InvokeUI (HWND hDisplay);

    virtual BOOL OnInitDialog (HWND hwnd, WPARAM wParam, LPARAM lParam);

    virtual BOOL OnYes (HWND hwnd);

    virtual BOOL OnNo (HWND hwnd);

    virtual BOOL OnMore (HWND hwnd);

    virtual BOOL ShowYes(LPWSTR*);
    virtual BOOL ShowNo(LPWSTR*);
    virtual BOOL ShowMore(LPWSTR*);

private:

    LPWSTR  m_pszConfirmation;
    LPWSTR  m_pszConfirmationNext;
    HRESULT m_hresult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsecr\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// 
//

#define IDD_DOWNLOADDIALOG              129
#define IDD_DIALOG_UNVERIFIED           130
#define IDD_DIALOG_CONFIRMATION         131
#define IDD_DIALOG_LEARNMORE            132

#define IDC_YESBUTTON                   133
#define IDC_NOBUTTON                    134
#define IDC_DIALOGTEXT                  135
#define IDC_ALWAYS                      136
#define IDC_SITETEXT                    137
#define IDC_LEARNTEXT                   138
#define IDC_QUESTIONTEXT                140

#define IDMORE                          151

#define IDC_SITE                        159
#define IDC_LINK                        160
#define IDC_ENCLOSED                    161
#define IDC_ZONE                        162
#define IDC_SEPARATORLINE               163
#define IDC_NOVERBMP                    164
#define IDC_NOAUTHENTICITY              165
#define IDC_TUIHAND                     166
#define IDC_CHECKACTION                 167
#define IDC_CONFIRMATION_TEXT1          168
#define IDC_CONFIRMATION_TEXT2          169
#define IDC_LEARNMORE                   170

#define IDS_NOAUTHENTICITY              223
#define IDS_SITE                        224
#define IDS_ZONE                        225
#define IDS_ENCLOSED                    226
#define IDS_UNKNOWN                     229
#define IDS_SECURITY                    230
#define IDS_CONFIRMATION_YES            231
#define IDS_CONFIRMATION_NO             232
#define IDS_CONFIRMATION_NEXT           233
#define IDS_LEARNMORE                   234
#define IDS_CONTINUE_BUTTONTEXT         235

#define IDB_BITMAP1                     300
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsec\iih.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//*****************************************************************************
#if !defined(__IIH_H__)
#define __IIH_H__

#include <wintrust.h>

extern void TUIGoLink(HWND hwndParent, WCHAR *pszWhere);
extern HRESULT ACUIMapErrorToString (HINSTANCE hResources, HRESULT hr, LPWSTR* ppsz);


#define _OFFSETOF(t,f)   ((DWORD)((DWORD_PTR)(&((t*)0)->f)))
#define _ISINSTRUCT(structtypedef, structpassedsize, member) \
                    ((_OFFSETOF(structtypedef, member) < structpassedsize) ? TRUE : FALSE)
#define MAX_LOADSTRING_BUFFER 8196


class IACUIControl;
//
// CInvokeInfoHelper is used to pull various pieces of information out
// of the ACUI_INVOKE_INFO data structure
//
class CInvokeInfoHelper
{
public:

    //
    // Initialization
    //

    CInvokeInfoHelper (
               PCRYPT_PROVIDER_DATA pData,
               LPCWSTR pSite,
               LPCWSTR pZone,
               LPCWSTR pHelpURL,
               HMODULE hResources,
               HRESULT& rhr
               );

    ~CInvokeInfoHelper ();

    //
    // Information Retrieval Methods
    //

    PCRYPT_PROVIDER_DATA ProviderData() { return(m_pData); }
    LPCWSTR ErrorStatement()            { return(m_pszErrorStatement); }
    LPCWSTR Site()                      { return(m_pszSite); }
    LPCWSTR Zone()                      { return(m_pszZone); }
    BOOL    GetFlag()                   { return m_dwFlag; }
    void    AddFlag(DWORD flag)         { m_dwFlag |= flag; }
    void    ClearFlag()                 { m_dwFlag = 0; }
    void    SetResult(HRESULT hr)       { m_hResult = hr; }

    HINSTANCE Resources()               { return m_hResources; }
    //
    // UI control management
    //

    inline VOID CallWebLink(HWND hwndParent, WCHAR *pszLink);
    inline VOID CallLink(HWND hwndParent);

private:

    //
    // Invoke Info holder
    //

    PCRYPT_PROVIDER_DATA    m_pData;
    
    HRESULT                 m_hResult;
    DWORD                   m_dwFlag;
    LPWSTR                  m_pszErrorStatement;
    LPCWSTR                 m_pszSite;
    LPCWSTR                 m_pszZone;
    LPCWSTR                 m_pszHelpURL;

    HINSTANCE               m_hResources;
    //
    // Private methods
    //

    HRESULT InitErrorStatement();
};

//
// Inline methods
//

inline VOID 
CInvokeInfoHelper::CallWebLink(HWND hwndParent, WCHAR* pszLink)
{ 
    TUIGoLink(hwndParent, pszLink); 
}

inline VOID
CInvokeInfoHelper::CallLink(HWND hwndParent)
{ 
    if(m_pszHelpURL)
        CallWebLink(hwndParent, (WCHAR*) m_pszHelpURL);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsn\cryptapis.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// ===========================================================================
// File: CryptApis.h
// 
// CryptoAPI entry points used for StrongName implementation. This file is
// included multiple times with different definitions of the DEFINE_IMPORT
// macro in order handle dynamically finding these entry points.
// ===========================================================================

#ifndef DEFINE_IMPORT
#error Must define DEFINE_IMPORT macro before including this file
#endif

// DEFINE_IMPORT parameters are:
//  1)  Function name (remember to add A to functions that take strings, don't
//      use W versions since they're unsupported on Win9X).
//  2)  Paranthesised argument types (return type is always assumed to be
//      BOOLEAN).
//  3)  TRUE if function is required, FALSE if it is optional (calls will not
//      fail because the function can't be found).

DEFINE_IMPORT(CryptAcquireContextA,     (HCRYPTPROV*, LPCSTR, LPCSTR, DWORD, DWORD),                TRUE)
DEFINE_IMPORT(CryptCreateHash,          (HCRYPTPROV, ALG_ID, HCRYPTKEY, DWORD, HCRYPTHASH*),        TRUE)
DEFINE_IMPORT(CryptDestroyHash,         (HCRYPTHASH),                                               TRUE)
DEFINE_IMPORT(CryptDestroyKey,          (HCRYPTKEY),                                                TRUE)
DEFINE_IMPORT(CryptEnumProvidersA,      (DWORD, DWORD*, DWORD, DWORD*, LPSTR, DWORD*),              FALSE)
DEFINE_IMPORT(CryptExportKey,           (HCRYPTKEY, HCRYPTKEY, DWORD, DWORD, BYTE*, DWORD*),        TRUE)
DEFINE_IMPORT(CryptGenKey,              (HCRYPTPROV, ALG_ID, DWORD, HCRYPTKEY*),                    TRUE)
DEFINE_IMPORT(CryptGetHashParam,        (HCRYPTHASH, DWORD, BYTE*, DWORD*, DWORD),                  TRUE)
DEFINE_IMPORT(CryptGetKeyParam,         (HCRYPTKEY, DWORD, BYTE*, DWORD*, DWORD),                   TRUE)
DEFINE_IMPORT(CryptGetProvParam,        (HCRYPTPROV, DWORD, BYTE*, DWORD*, DWORD),                  TRUE)
DEFINE_IMPORT(CryptGetUserKey,          (HCRYPTPROV, DWORD, HCRYPTKEY*),                            TRUE)
DEFINE_IMPORT(CryptHashData,            (HCRYPTHASH, BYTE*, DWORD, DWORD),                          TRUE)
DEFINE_IMPORT(CryptImportKey,           (HCRYPTPROV, BYTE*, DWORD, HCRYPTKEY, DWORD, HCRYPTKEY*),   TRUE)
DEFINE_IMPORT(CryptReleaseContext,      (HCRYPTPROV, DWORD),                                        TRUE)
DEFINE_IMPORT(CryptSignHashA,           (HCRYPTHASH, DWORD, LPCSTR, DWORD, BYTE*, DWORD*),          TRUE)
DEFINE_IMPORT(CryptVerifySignatureA,    (HCRYPTHASH, BYTE*, DWORD, HCRYPTKEY, LPCSTR, DWORD),       TRUE)

#undef DEFINE_IMPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsn\strongname.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: StrongName.cpp
// 
// Wrappers for signing and hashing functions needed to implement strong names
// ===========================================================================


#include <winwrap.h>
#include <windows.h>
#include <wincrypt.h>
#include <imagehlp.h>
#include <stddef.h>
#include <stdio.h>
#include <malloc.h>
#include <cor.h>
#include <metadata.h>

#include "safegetfilesize.h"

#define SNAPI_INTERNAL
#include "StrongName.h"


// The maximum length of CSP name we support (in characters).
#define SN_MAX_CSP_NAME 1024


// We cache a couple of things on a per thread basis: the last error encountered
// and (potentially) a CSP context. The following structure tracks these and is
// allocated lazily as needed.
struct SN_THREAD_CTX {
    DWORD       m_dwLastError;
    HCRYPTPROV  m_hProv;
};


// The TLS index at which we store the context above.
DWORD g_dwStrongNameTlsIndex = ~0;

// Critical section used to serialize some non-thread safe crytpo APIs.
CRITICAL_SECTION g_rStrongNameMutex;

// Flag indicating whether the OS supports the necessary crypto APIs. If this is
// FALSE all of our APIs will respond with CORSEC_E_CRYPTOAPI_CALL_FAILED.
BOOLEAN g_bStrongNamesSupported;

// Handles to libraries that are loaded dynamically.
HINSTANCE g_hAdvApiDll;

// Flag set to TRUE if we're running on NT/W2K or greater. If we are, we have
// access to some additional flags on the crypto APIs.
BOOLEAN g_bRunningOnW2K;

// Name of CSP to use. This is read from the registry at initialization time. If
// not found we look up a CSP by hashing and signing algorithms (see below) or
// use the default CSP.
CHAR g_szCSPName[SN_MAX_CSP_NAME + 1];

// Flag read from the registry at initialization time. Controls whether we use
// machine or user based key containers.
BOOLEAN g_bUseMachineKeyset;

// Algorithm IDs for hashing and signing. Like the CSP name, these values are
// read from the registry at initialization time.
ALG_ID g_uHashAlgId;
ALG_ID g_uSignAlgId;

// Flag indicating whether it's OK to cache the results of verifying an assembly
// whose file is accessible to users.
BOOLEAN g_fCacheVerify;

// Verification Skip Records
//
// These are entries in the registry (usually set up by SN) that control whether
// an assembly needs to pass signature verification to be considered valid (i.e.
// return TRUE from StrongNameSignatureVerification). This is useful during
// development when it's not feasible to fully sign each assembly on each build.
// Assemblies to be skipped can be specified by name and public key token, all
// assemblies with a given public key token or just all assemblies. Each entry
// can be further qualified by a list of user names to which the records
// applies. When matching against an entry, the most specific one wins.
//
// We read these entries at startup time and place them into a global, singly
// linked, NULL terminated list.

// Structure used to represent each record we find in the registry.
struct SN_VER_REC {
    SN_VER_REC     *m_pNext;                    // Pointer to next record (or NULL)
    WCHAR           m_wszAssembly[MAX_PATH + 1];// Assembly name/public key token as a string
    WCHAR          *m_mszUserList;              // Pointer to multi-string list of valid users (or NULL)
};

// Head of the list of entries we found in the registry during initialization.
SN_VER_REC *g_pVerificationRecords;


// We allow a special abbreviated form of the Microsoft public key (16 bytes
// long: 0 for both alg ids, 4 for key length and 4 bytes of 0 for the key
// itself). This allows us to build references to system libraries that are
// platform neutral (so a 3rd party can build mscorlib replacements). The
// special zero PK is just shorthand for the local runtime's real system PK,
// which is always used to perform the signature verification, so no security
// hole is opened by this. Therefore we need to store a copy of the real PK (for
// this platform) here.
BYTE g_rbMSPublicKey[] = 
{
    0,  36,   0,   0,   4, 128,   0,   0, 148,   0,   0,   0,   6,   2,   0,
    0,   0,  36,   0,   0,  82,  83,  65,  49,   0,   4,   0,   0,   1,   0,
    1,   0,   7, 209, 250,  87, 196, 174, 217, 240, 163,  46, 132, 170,  15,
  174, 253,  13, 233, 232, 253, 106, 236, 143, 135, 251,   3, 118, 108, 131,
   76, 153, 146,  30, 178,  59, 231, 154, 217, 213, 220, 193, 221, 154, 210,
   54,  19,  33,   2, 144,  11, 114,  60, 249, 128, 149, 127, 196, 225, 119,
   16, 143, 198,   7, 119,  79,  41, 232,  50,  14, 146, 234,   5, 236, 228,
  232,  33, 192, 165, 239, 232, 241, 100,  92,  76,  12, 147, 193, 171, 153,
   40,  93,  98,  44, 170, 101,  44,  29, 250, 214,  61, 116,  93, 111,  45,
  229, 241, 126,  94, 175,  15, 196, 150,  61,  38,  28, 138,  18,  67, 101,
   24,  32, 109, 192, 147,  52,  77,  90, 210, 147
};
#define SN_MS_KEY() ((PublicKeyBlob*)g_rbMSPublicKey)

BYTE g_rbMSPublicKeyToken[] = { 0xb0, 0x3f, 0x5f, 0x7f, 0x11, 0xd5, 0x0a, 0x3a };

BYTE g_rbNeutralPublicKey[] = { 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0 };

BYTE g_rbNeutralPublicKeyToken[] = { 0xb7, 0x7a, 0x5c, 0x56, 0x19, 0x34, 0xe0, 0x89 };

// Determine if the given public key blob is the neutral key.
#define SN_IS_NEUTRAL_KEY(_pk) (SN_SIZEOF_KEY(((PublicKeyBlob*)(_pk))->cbPublicKey) == sizeof(g_rbNeutralPublicKey) && \
                                memcmp((_pk), g_rbNeutralPublicKey, sizeof(g_rbNeutralPublicKey)) == 0)


// This library may be loaded on a system with insufficient crypto support to
// implement its functionality. To avoid triggering error dialogs complaining
// about missing DLLs or entry points, we load the needed DLLs dynamically. This
// is done during DllMain, but we don't report any errors at that stage. Instead
// we check at the entry to each of our APIs whether we found the needed support
// and return a special error (CORSEC_E_CRYPTOAPI_CALL_FAILED) if we did not.
// First define global variables to hold the dynamically determined entry points
// (prefix these variables to avoid names clashes when we are running on a
// system that does provide crypto support).
#define DEFINE_IMPORT(_func, _args, _reqd) BOOLEAN (*SN_##_func) _args = NULL;
#include "CryptApis.h"


// Debug logging.
#ifndef _DEBUG
#define Log TRUE ||
#define HexDump TRUE ||
#define DbgCount TRUE ||
#else
#include <stdarg.h>

BOOLEAN g_fLoggingInitialized = FALSE;
DWORD g_dwLoggingFlags = FALSE;

void Log(CHAR *szFormat, ...)
{
    if (g_fLoggingInitialized && !g_dwLoggingFlags)
        return;

    DWORD dwError = GetLastError();

    if (!g_fLoggingInitialized) {
        g_dwLoggingFlags = REGUTIL::GetConfigDWORD(L"MscorsnLogging", 0);
        g_fLoggingInitialized = TRUE;
    }

    if (!g_dwLoggingFlags) {
        SetLastError(dwError);
        return;
    }

    va_list     pArgs;
    CHAR        szBuffer[1024];
    static CHAR szPrefix[] = "SN: ";

    strcpy(szBuffer, szPrefix);

    va_start(pArgs, szFormat);
    vsprintf(&szBuffer[sizeof(szPrefix) - 1], szFormat, pArgs);
    va_end(pArgs);

    if (g_dwLoggingFlags & 1)
        printf("%s", szBuffer);
    if (g_dwLoggingFlags & 2)
    OutputDebugStringA(szBuffer);

    SetLastError(dwError);
}

void HexDump(BYTE  *pbData,
             DWORD  cbData)
{
    if (g_dwLoggingFlags == 0)
        return;

    DWORD dwRow, dwCol;
    char    szBuffer[4096];
    char   *szPtr = szBuffer;

#define SN_PUSH0(_fmt)          do { szPtr += sprintf(szPtr, _fmt); } while (false)
#define SN_PUSH1(_fmt, _arg1)   do { szPtr += sprintf(szPtr, _fmt, _arg1); } while (false)

    szBuffer[0] = '\0';

    for (dwRow = 0; dwRow < ((cbData + 15) / 16); dwRow++) {
        SN_PUSH1("%08X ", pbData + (16 * dwRow));
        for (dwCol = 0; dwCol < 16; dwCol++)
            if (((dwRow * 16) + dwCol) < cbData)
                SN_PUSH1("%02X ", pbData[(dwRow * 16) + dwCol]);
            else
                SN_PUSH0("   ");
        for (dwCol = 0; dwCol < 16; dwCol++)
            if (((dwRow * 16) + dwCol) < cbData) {
                unsigned char c = pbData[(dwRow * 16) + dwCol];
                if ((c >= 32) && (c <= 127))
                    SN_PUSH1("%c", c);
                else
                    SN_PUSH0(".");
            } else
                SN_PUSH0(" ");
        SN_PUSH0("\n");
    }

    _ASSERTE(szPtr < &szBuffer[sizeof(szBuffer)]);

    if (g_dwLoggingFlags & 1)
        printf("%s", szBuffer);
    if (g_dwLoggingFlags & 2)
        OutputDebugStringA(szBuffer);
}



void DbgCount(WCHAR *szCounterName)
{
    if (g_fLoggingInitialized && !(g_dwLoggingFlags & 4))
        return;

    DWORD dwError = GetLastError();

    if (!g_fLoggingInitialized) {
        g_dwLoggingFlags = REGUTIL::GetConfigDWORD(L"MscorsnLogging", 0);
        g_fLoggingInitialized = TRUE;
    }

    if (!(g_dwLoggingFlags & 4)) {
        SetLastError(dwError);
        return;
    }

    HKEY    hKey = NULL;
    DWORD   dwCounter = 0;
    DWORD   dwBytes;

    if (WszRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          SN_CONFIG_KEY_W L"\\Counters",
                          0,
                          NULL,
                          0,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hKey,
                          NULL) != ERROR_SUCCESS)
        goto End;

    WszRegQueryValueEx(hKey, szCounterName, NULL, NULL, (BYTE*)&dwCounter, &dwBytes);
    dwCounter++;
    WszRegSetValueEx(hKey, szCounterName, NULL, REG_DWORD, (BYTE*)&dwCounter, sizeof(DWORD));

 End:
    if (hKey)
        RegCloseKey(hKey);
    SetLastError(dwError);
}

#endif


// Size in bytes of strong name token.
#define SN_SIZEOF_TOKEN     8


// Context structure tracking information for a loaded assembly.
struct SN_LOAD_CTX {
    HANDLE              m_hFile;        // Open file handle
    HANDLE              m_hMap;         // Mapping file handle
    BYTE               *m_pbBase;       // Base address of mapped file
    DWORD               m_dwLength;     // Length of file in bytes
    IMAGE_NT_HEADERS   *m_pNtHeaders;   // Address of NT headers
    IMAGE_COR20_HEADER *m_pCorHeader;   // Address of COM+ 2.0 header
    BYTE               *m_pbSignature;  // Address of signature blob
    DWORD               m_cbSignature;  // Size of signature blob
    BOOLEAN             m_fReadOnly;    // File mapped for read-only access
    BOOLEAN             m_fPreMapped;   // File was already mapped for us
    SN_LOAD_CTX() { ZeroMemory(this, sizeof(*this)); }
};


// The actions that can be performed upon opening a CSP with LocateCSP.
#define SN_OPEN_CONTAINER   0
#define SN_IGNORE_CONTAINER 1
#define SN_CREATE_CONTAINER 2
#define SN_DELETE_CONTAINER 3
#define SN_HASH_SHA1_ONLY   4

// Macro to aid in setting flags for CryptAcquireContext based on container
// actions above.
#define SN_CAC_FLAGS(_act)                                                                      \
    (((_act) == SN_OPEN_CONTAINER ? 0 :                                                         \
      ((_act) == SN_HASH_SHA1_ONLY) || ((_act) == SN_IGNORE_CONTAINER) ? CRYPT_VERIFYCONTEXT :  \
      (_act) == SN_CREATE_CONTAINER ? CRYPT_NEWKEYSET :                                         \
      (_act) == SN_DELETE_CONTAINER ? CRYPT_DELETEKEYSET :                                      \
      0) |                                                                                      \
     (g_bUseMachineKeyset ? CRYPT_MACHINE_KEYSET : 0))


// Macro containing common code used at the start of most APIs.
#define SN_COMMON_PROLOG() do {                                 \
    if (!g_bStrongNamesSupported) {                             \
        SetStrongNameErrorInfo(CORSEC_E_CRYPTOAPI_CALL_FAILED); \
        return FALSE;                                           \
    }                                                           \
    SetStrongNameErrorInfo(S_OK);                               \
} while (0)


// Determine the size of a PublicKeyBlob structure given the size of the key
// portion.
#define SN_SIZEOF_KEY(_cbKey) (offsetof(PublicKeyBlob, PublicKey) + (_cbKey))


// Private routine prototypes.
SN_THREAD_CTX *GetThreadContext();
VOID SetStrongNameErrorInfo(DWORD dwStatus);
HCRYPTPROV LocateCSP(LPCWSTR    wszKeyContainer,
                     DWORD      dwAction,
                     ALG_ID     uHashAlgId = 0,
                     ALG_ID     uSignAlgId = 0);
VOID FreeCSP(HCRYPTPROV hProv);
HCRYPTPROV LookupCachedCSP();
VOID CacheCSP(HCRYPTPROV hProv);
BOOLEAN IsCachedCSP(HCRYPTPROV hProv);
BOOLEAN MyCryptEnumProviders(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags,
                             DWORD *pdwType, LPSTR szName, DWORD *pdwLength);
BOOLEAN LoadCryptoApis();
VOID UnloadCryptoApis();
BOOLEAN LoadAssembly(SN_LOAD_CTX *pLoadCtx, LPCWSTR szFilePath, BOOLEAN fRequireSignature = TRUE);
BOOLEAN UnloadAssembly(SN_LOAD_CTX *pLoadCtx);
VOID ReadRegistryConfig();
VOID ReadVerificationRecords();
SN_VER_REC *GetVerificationRecord(LPWSTR wszAssemblyName, PublicKeyBlob *pPublicKey);
BOOLEAN IsValidUser(WCHAR *mszUserList);
PublicKeyBlob *FindPublicKey(SN_LOAD_CTX   *pLoadCtx,
                             LPWSTR         wszAssemblyName,
                             DWORD          cchAssemblyName);
LPCWSTR GetKeyContainerName();
VOID FreeKeyContainerName(LPCWSTR wszKeyContainer);
BOOLEAN VerifySignature(SN_LOAD_CTX *pLoadCtx, DWORD dwInFlags, DWORD *pdwOutFlags);
BOOLEAN ComputeHash(SN_LOAD_CTX *pLoadCtx, HCRYPTHASH hHash);
IMAGE_NT_HEADERS *SN_ImageNtHeader(VOID *pvBase);
IMAGE_SECTION_HEADER *SN_ImageRvaToSection(IMAGE_NT_HEADERS *pNtHeaders,
                                           VOID             *pvBase,
                                           DWORD             dwRva);
PVOID SN_ImageRvaToVa(IMAGE_NT_HEADERS  *pNtHeaders,
                      VOID              *pvBase,
                      DWORD              dwRva);


// DLL entry point. Perform initialization/shutdown.
BOOL WINAPI DllMain(HINSTANCE   hDLL,
                    DWORD       dwReason,
                    LPVOID      pReserved)
{
    OSVERSIONINFOW  info;
    SN_VER_REC     *pVerRec, *pNextVerRec;
    SN_THREAD_CTX  *pThreadCtx;

    switch (dwReason) {

    case DLL_PROCESS_ATTACH:

        // Allocate a TLS index so we can store a per-thread error code.
        g_dwStrongNameTlsIndex = TlsAlloc();
        if (g_dwStrongNameTlsIndex == ~0)
            return FALSE;

        InitializeCriticalSection(&g_rStrongNameMutex);

        // Initialize Wsz wrappers.
        OnUnicodeSystem();

        // Dynamically load crypto APIs.
        g_bStrongNamesSupported = LoadCryptoApis();

        // Check whether we're running on NT/W2K or greater.
        info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
        if (WszGetVersionEx(&info))
            g_bRunningOnW2K = info.dwMajorVersion >= 5;
        else
            g_bRunningOnW2K = false; // This is the safest assumption, we can still make progress. 

        // Read CSP configuration info from the registry (if provided).
        ReadRegistryConfig();

        break;

    case DLL_PROCESS_DETACH:
        if (g_bStrongNamesSupported)
            UnloadCryptoApis();
        for (pVerRec = g_pVerificationRecords; pVerRec; pVerRec = pNextVerRec) {
            pNextVerRec = pVerRec->m_pNext;
            delete [] pVerRec->m_mszUserList;
            delete pVerRec;
        }
        DeleteCriticalSection(&g_rStrongNameMutex);
        TlsFree(g_dwStrongNameTlsIndex);
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        // Cleanup any TLS based storage we may have allocated.
        if (g_dwStrongNameTlsIndex != ~0)
            if (pThreadCtx = (SN_THREAD_CTX*)TlsGetValue(g_dwStrongNameTlsIndex)) {
                if (pThreadCtx->m_hProv)
                    SN_CryptReleaseContext(pThreadCtx->m_hProv, 0);                
                delete pThreadCtx;
            }
        break;

    default:
        _ASSERTE(FALSE);

    }

    return TRUE;
}


// Return last error.
SNAPI_(DWORD) StrongNameErrorInfo(VOID)
{
    SN_THREAD_CTX *pThreadCtx = GetThreadContext();
    if (pThreadCtx == NULL)
            return E_OUTOFMEMORY;
    return pThreadCtx->m_dwLastError;
}


// Free buffer allocated by routines below.
SNAPI_(VOID) StrongNameFreeBuffer(BYTE *pbMemory)            // [in] address of memory to free
{
    Log("StrongNameFreeBuffer(%08X)\n", pbMemory);
    if (pbMemory != g_rbMSPublicKey && pbMemory != g_rbNeutralPublicKey)
        delete [] pbMemory;
}


// Generate a new key pair for strong name use.
SNAPI StrongNameKeyGen(LPCWSTR  wszKeyContainer,    // [in] desired key container name, must be a non-empty string
                       DWORD    dwFlags,            // [in] flags (see below)
                       BYTE   **ppbKeyBlob,         // [out] public/private key blob
                       ULONG   *pcbKeyBlob)
{
    HCRYPTPROV  hProv = NULL;
    HCRYPTKEY   hKey = NULL;
    DWORD       dwKeySize;
    BOOLEAN     bTempContainer = FALSE;

    Log("StrongNameKeyGen(\"%S\", %08X, %08X, %08X)\n", wszKeyContainer, dwFlags, ppbKeyBlob, pcbKeyBlob);

    SN_COMMON_PROLOG();

    // Check to see if a temporary container name is needed.
    if (wszKeyContainer == NULL) {
        _ASSERTE(!(dwFlags & SN_LEAVE_KEY));
        wszKeyContainer = GetKeyContainerName();
        if (wszKeyContainer == NULL) {
            SetStrongNameErrorInfo(E_OUTOFMEMORY);
            return FALSE;
        }
        bTempContainer = TRUE;
    }

    // Open a CSP and container.
    hProv = LocateCSP(wszKeyContainer, SN_CREATE_CONTAINER);
    if (!hProv)
        goto Error;

    // Calculate a key size mask. The key size in bits is encoded in the upper
    // 16-bits of a DWORD (to be OR'd together with other flags for the
    // CryptGenKey call). We set a key size of 1024 in we're using the default
    // signing algorithm (RSA), otherwise we leave it at the default.
    if (g_uSignAlgId == CALG_RSA_SIGN)
        dwKeySize = 1024 << 16;
    else
        dwKeySize = 0;

    // Generate the new key pair, try for exportable first.
    if (!SN_CryptGenKey(hProv, AT_SIGNATURE, dwKeySize | CRYPT_EXPORTABLE, &hKey)) {
        Log("Couldn't create exportable key, trying for non-exportable: %08X\n", GetLastError());
        if (!SN_CryptGenKey(hProv, AT_SIGNATURE, dwKeySize, &hKey)) {
            Log("Couldn't create key pair: %08X\n", GetLastError());
            goto Error;
        }
    }

#ifdef _DEBUG
    if (g_szCSPName[0] == '\0') {
        ALG_ID  uAlgId;
        DWORD   dwAlgIdLen = sizeof(uAlgId);
        // Check that signature algorithm used was the one we expected.
        if (SN_CryptGetKeyParam(hKey, KP_ALGID, (BYTE*)&uAlgId, &dwAlgIdLen, 0)) {
            _ASSERTE(uAlgId == g_uSignAlgId);
        } else
            Log("Failed to get key params: %08X\n", GetLastError());
    }
#endif

    // If the user wants the key pair back, attempt to export it.
    if (ppbKeyBlob) {

        // Calculate length of blob first;
        if (!SN_CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, NULL, pcbKeyBlob)) {
            Log("Couldn't export key pair: %08X\n", GetLastError());
            goto Error;
        }

        // Allocate a buffer of the right size.
        *ppbKeyBlob = new BYTE[*pcbKeyBlob];
        if (*ppbKeyBlob == NULL) {
            SetLastError(E_OUTOFMEMORY);
            goto Error;
        }

        // Export the key pair.
        if (!SN_CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, *ppbKeyBlob, pcbKeyBlob)) {
            Log("Couldn't export key pair: %08X\n", GetLastError());
            delete[] *ppbKeyBlob;
            goto Error;
        }
    }

    // Destroy the key handle (but not the key pair itself).
    SN_CryptDestroyKey(hKey);
    hKey = NULL;

    // Release the CSP.
    FreeCSP(hProv);

    // If the user didn't explicitly want to keep the key pair around, delete the
    // key container.
    if (!(dwFlags & SN_LEAVE_KEY) && !bTempContainer)
        LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER);

    // Free temporary key container name if allocated.
    if (bTempContainer)
        FreeKeyContainerName(wszKeyContainer);

    return TRUE;

 Error:
    SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
    if (hKey)
        SN_CryptDestroyKey(hKey);
    if (hProv) {
        FreeCSP(hProv);
        if (!(dwFlags & SN_LEAVE_KEY) && !bTempContainer)
            LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER);
    }
    if (bTempContainer)
        FreeKeyContainerName(wszKeyContainer);
    return FALSE;
}


// Import key pair into a key container.
SNAPI StrongNameKeyInstall(LPCWSTR  wszKeyContainer,// [in] desired key container name, must be a non-empty string
                           BYTE    *pbKeyBlob,      // [in] public/private key pair blob
                           ULONG    cbKeyBlob)
{
    HCRYPTPROV  hProv = NULL;
    HCRYPTKEY   hKey = NULL;

    Log("StrongNameKeyInstall(\"%S\", %08X, %08X)\n", wszKeyContainer, pbKeyBlob, cbKeyBlob);

    SN_COMMON_PROLOG();

    // Open a CSP and container.
    hProv = LocateCSP(wszKeyContainer, SN_CREATE_CONTAINER);
    if (!hProv) {
        SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    // Import the key pair.
    if (!SN_CryptImportKey(hProv,
                           pbKeyBlob,
                           cbKeyBlob,
                           0, 0, &hKey)) {
        SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
        FreeCSP(hProv);
        return FALSE;
    }

    // Release the CSP.
    FreeCSP(hProv);

    return TRUE;
}


// Delete a key pair.
SNAPI StrongNameKeyDelete(LPCWSTR wszKeyContainer)  // [in] desired key container name
{
    HCRYPTPROV      hProv;

    Log("StrongNameKeyDelete(\"%S\")\n", wszKeyContainer);

    SN_COMMON_PROLOG();

    // Open and delete the named container.
    hProv = LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER);
    if (hProv) {
        // Returned handle isn't actually valid in the delete case, so we're
        // finished.
        return TRUE;
    } else {
        SetStrongNameErrorInfo(CORSEC_E_CONTAINER_NOT_FOUND);
        return FALSE;
    }
}


// Retrieve the public portion of a key pair.
SNAPI StrongNameGetPublicKey (LPCWSTR   wszKeyContainer,    // [in] desired key container name
                              BYTE     *pbKeyBlob,          // [in] public/private key blob (optional)
                              ULONG     cbKeyBlob,
                              BYTE    **ppbPublicKeyBlob,   // [out] public key blob
                              ULONG    *pcbPublicKeyBlob)
{
    HCRYPTPROV      hProv = NULL;
    HCRYPTKEY       hKey = NULL;
    DWORD           dwKeyLen;
    PublicKeyBlob  *pKeyBlob;
    DWORD           dwSigAlgIdLen;
    BOOLEAN         bTempContainer = FALSE;

    Log("StrongNameGetPublicKey(\"%S\", %08X, %08X, %08X, %08X)\n", wszKeyContainer, pbKeyBlob, cbKeyBlob, ppbPublicKeyBlob, pcbPublicKeyBlob);

    SN_COMMON_PROLOG();

    // If we're handed a platform neutral public key, just hand it right back to
    // the user. Well, hand back a copy at least.
    if (pbKeyBlob && cbKeyBlob && SN_IS_NEUTRAL_KEY((PublicKeyBlob*)pbKeyBlob)) {
        *pcbPublicKeyBlob = sizeof(g_rbNeutralPublicKey);
        *ppbPublicKeyBlob = g_rbNeutralPublicKey;
        return TRUE;
    }

    // Check to see if a temporary container name is needed.
    if (wszKeyContainer == NULL) {
        _ASSERTE(pbKeyBlob);
        wszKeyContainer = GetKeyContainerName();
        if (wszKeyContainer == NULL) {
            SetStrongNameErrorInfo(E_OUTOFMEMORY);
            return FALSE;
        }
        bTempContainer = TRUE;
    }

    // Open a CSP. Create a key container if a public/private key blob is
    // provided, otherwise we assume a key container already exists.
    if (pbKeyBlob)
        hProv = LocateCSP(wszKeyContainer, SN_CREATE_CONTAINER);
    else
        hProv = LocateCSP(wszKeyContainer, SN_OPEN_CONTAINER);
    if (!hProv)
        goto Error;

    // If a key blob was provided, import the key pair into the container.
    if (pbKeyBlob) {
        if (!SN_CryptImportKey(hProv,
                               pbKeyBlob,
                               cbKeyBlob,
                               0, 0, &hKey))
            goto Error;
    } else {
        // Else fetch the signature key pair from the container.
        if (!SN_CryptGetUserKey(hProv, AT_SIGNATURE, &hKey))
            goto Error;
    }

    // Determine the length of the public key part as a blob.
    if (!SN_CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, NULL, &dwKeyLen))
        goto Error;

    // And then the length of the PublicKeyBlob structure we return to the
    // caller.
    *pcbPublicKeyBlob = SN_SIZEOF_KEY(dwKeyLen);

    // Allocate a large enough buffer.
    *ppbPublicKeyBlob = new BYTE[*pcbPublicKeyBlob];
    if (*ppbPublicKeyBlob == NULL) {
        SetLastError(E_OUTOFMEMORY);
        goto Error;
    }

    pKeyBlob = (PublicKeyBlob*)*ppbPublicKeyBlob;

    // Extract the public part as a blob.
    if (!SN_CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, pKeyBlob->PublicKey, &dwKeyLen)) {
        delete[] *ppbPublicKeyBlob;
        goto Error;
    }

    // Extract key's signature algorithm and store it in the key blob.
    dwSigAlgIdLen = sizeof(pKeyBlob->SigAlgID);
    if (!SN_CryptGetKeyParam(hKey, KP_ALGID, (BYTE*)&pKeyBlob->SigAlgID, &dwSigAlgIdLen, 0)) {
        delete[] *ppbPublicKeyBlob;
        goto Error;
    }

    // Fill in the other public key blob fields.
    pKeyBlob->HashAlgID = g_uHashAlgId;
    pKeyBlob->cbPublicKey = dwKeyLen;
    
    SN_CryptDestroyKey(hKey);
    FreeCSP(hProv);

    // If the caller provided a key blob, delete the temporary key container we
    // created.
    if (pbKeyBlob && !bTempContainer)
        LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER);

    // Free temporary key container name if allocated.
    if (bTempContainer)
        FreeKeyContainerName(wszKeyContainer);

    return TRUE;

 Error:
    SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
    if (hKey)
        SN_CryptDestroyKey(hKey);
    if (hProv) {
        FreeCSP(hProv);
        if (pbKeyBlob && !bTempContainer)
            LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER);
    }
    if (bTempContainer)
        FreeKeyContainerName(wszKeyContainer);
    return FALSE;
}


// Hash and sign a manifest.
SNAPI StrongNameSignatureGeneration(LPCWSTR     wszFilePath,        // [in] valid path to the PE file for the assembly
                                    LPCWSTR     wszKeyContainer,    // [in] desired key container name
                                    BYTE       *pbKeyBlob,          // [in] public/private key blob (optional)
                                    ULONG       cbKeyBlob,
                                    BYTE      **ppbSignatureBlob,   // [out] signature blob
                                    ULONG      *pcbSignatureBlob)
{
    HCRYPTPROV      hProv = NULL;
    HCRYPTHASH      hHash = NULL;
    HCRYPTKEY       hKey;
    BOOLEAN         bImageLoaded = FALSE;
    BYTE           *pbSig = NULL;
    ULONG           cbSig;
    SN_LOAD_CTX     sLoadCtx;
    BOOLEAN         bTempContainer = FALSE;

    Log("StrongNameSignatureGeneration(\"%S\", \"%S\", %08X, %08X, %08X, %08X)\n", wszFilePath, wszKeyContainer, pbKeyBlob, cbKeyBlob, ppbSignatureBlob, pcbSignatureBlob);

    SN_COMMON_PROLOG();

    // Hack to support Cool. If we're just being called to determine signature
    // size and we don't have an input keypair or container just return a
    // standard size.
    if ((wszFilePath == NULL) &&
        (pbKeyBlob == NULL) &&
        (wszKeyContainer == NULL)) {
        *pcbSignatureBlob = 128;
        return TRUE;
    }

    // Check to see if a temporary container name is needed.
    if (wszKeyContainer == NULL) {
        _ASSERTE(pbKeyBlob);
        wszKeyContainer = GetKeyContainerName();
        if (wszKeyContainer == NULL) {
            SetStrongNameErrorInfo(E_OUTOFMEMORY);
            return FALSE;
        }
        bTempContainer = TRUE;
    }

    // Open a CSP. Create a key container if a public/private key blob is
    // provided, otherwise we assume a key container already exists.
    if (pbKeyBlob)
        hProv = LocateCSP(wszKeyContainer, SN_CREATE_CONTAINER);
    else
        hProv = LocateCSP(wszKeyContainer, SN_OPEN_CONTAINER);
    if (!hProv)
        goto Error;

    // If a key blob was provided, import the key pair into the container.
    if (pbKeyBlob) {
        if (!SN_CryptImportKey(hProv,
                               pbKeyBlob,
                               cbKeyBlob,
                               0, 0, &hKey))
            goto Error;
        // We don't need to keep the key object open (the key is found
        // implicitly by the signing code).
        SN_CryptDestroyKey(hKey);
    }

    // Create a hash object.
    if (!SN_CryptCreateHash(hProv, g_uHashAlgId, 0, 0, &hHash))
        goto Error;

    // Compute size of the signature blob.
    if (!SN_CryptSignHashA(hHash, AT_SIGNATURE, NULL, 0, NULL, &cbSig))
        goto Error;

    // If the caller only wants the size of the signature, return it now and
    // exit.
    if (wszFilePath == NULL) {
        *pcbSignatureBlob = cbSig;
        SN_CryptDestroyHash(hHash);
        FreeCSP(hProv);
        if (pbKeyBlob && !bTempContainer)
            LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER);
        if (bTempContainer)
            FreeKeyContainerName(wszKeyContainer);
        return TRUE;
    }

    // Map the assembly into memory.
    sLoadCtx.m_fReadOnly = FALSE;
    if (!LoadAssembly(&sLoadCtx, wszFilePath))
        goto Error;
    bImageLoaded = TRUE;

    // We set a bit in the header to indicate we're fully signing the assembly.
    sLoadCtx.m_pCorHeader->Flags |= COMIMAGE_FLAGS_STRONGNAMESIGNED;

    // Destroy the old hash object and create a new one
    // because CryptoAPI says you can't reuse a hash once you've signed it
    // Note that this seems to work with MS-based CSPs but breaks on
    // at least newer nCipher CSPs.
    if (hHash)
        SN_CryptDestroyHash(hHash);
    hHash = NULL;
    if (!SN_CryptCreateHash(hProv, g_uHashAlgId, 0, 0, &hHash))
        goto Error;

    // Compute a hash over the image.
    if (!ComputeHash(&sLoadCtx, hHash))
        goto Error;

    // Allocate the blob.
    pbSig = new BYTE[cbSig];
    if (pbSig == NULL) {
        SetLastError(E_OUTOFMEMORY);
        goto Error;
    }

    // Compute a signature blob over the hash of the manifest.
    if (!SN_CryptSignHashA(hHash, AT_SIGNATURE, NULL, 0, pbSig, &cbSig))
        goto Error;

    // Write the signature into file or return it to the user so they can do it.
    if (!ppbSignatureBlob)
        memcpy(sLoadCtx.m_pbSignature, pbSig, cbSig);

    // Unmap the image (automatically recalculates and updates the image
    // checksum).
    bImageLoaded = FALSE;
    if (!UnloadAssembly(&sLoadCtx))
        goto Error;

    SN_CryptDestroyHash(hHash);
    FreeCSP(hProv);

    // If a temporary key container was created, delete it now.
    if (pbKeyBlob && !bTempContainer)
        LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER);

    // Free temporary key container name if allocated.
    if (bTempContainer)
        FreeKeyContainerName(wszKeyContainer);

    if (ppbSignatureBlob) {
        *ppbSignatureBlob = pbSig;
        *pcbSignatureBlob = cbSig;
    }
    else
        delete[] pbSig;

    return TRUE;

 Error:
    SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
    if (pbSig)
        delete pbSig;
    if (bImageLoaded)
        UnloadAssembly(&sLoadCtx);
    if (hHash)
        SN_CryptDestroyHash(hHash);
    if (hProv) {
        FreeCSP(hProv);
        if (pbKeyBlob && !bTempContainer)
            LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER);
    }
    if (bTempContainer)
        FreeKeyContainerName(wszKeyContainer);
    return FALSE;
}


// Create a strong name token from an assembly file.
SNAPI StrongNameTokenFromAssembly(LPCWSTR   wszFilePath,            // [in] valid path to the PE file for the assembly
                                  BYTE    **ppbStrongNameToken,     // [out] strong name token 
                                  ULONG    *pcbStrongNameToken)
{
    return StrongNameTokenFromAssemblyEx(wszFilePath,
                                        ppbStrongNameToken,
                                         pcbStrongNameToken,
                                         NULL,
                                         NULL);
}

// Create a strong name token from an assembly file and additionally return the full public key.
SNAPI StrongNameTokenFromAssemblyEx(LPCWSTR   wszFilePath,            // [in] valid path to the PE file for the assembly
                                    BYTE    **ppbStrongNameToken,     // [out] strong name token 
                                    ULONG    *pcbStrongNameToken,
                                    BYTE    **ppbPublicKeyBlob,       // [out] public key blob
                                    ULONG    *pcbPublicKeyBlob)
{
    SN_LOAD_CTX     sLoadCtx;
    BOOLEAN         fMapped = FALSE;
    BOOLEAN         fSetErrorInfo = TRUE;
    PublicKeyBlob  *pPublicKey = NULL;

    Log("StrongNameTokenFromAssemblyEx(\"%S\", %08X, %08X, %08X, %08X)\n", wszFilePath, ppbStrongNameToken, pcbStrongNameToken, ppbPublicKeyBlob, pcbPublicKeyBlob);

    SN_COMMON_PROLOG();

    // Map the assembly into memory.
    sLoadCtx.m_fReadOnly = TRUE;
    if (!LoadAssembly(&sLoadCtx, wszFilePath))
        goto Error;
    fMapped = TRUE;

    // Read the public key used to sign the assembly from the assembly metadata.
    pPublicKey = FindPublicKey(&sLoadCtx, NULL, 0);
    if (pPublicKey == NULL)
        goto Error;

    // Unload the assembly.
    fMapped = FALSE;
    if (!UnloadAssembly(&sLoadCtx))
        goto Error;

    // Now we have a public key blob, we can call our more direct API to do the
    // actual work.
    if (!StrongNameTokenFromPublicKey((BYTE*)pPublicKey,
                                      SN_SIZEOF_KEY(pPublicKey->cbPublicKey),
                                      ppbStrongNameToken,
                                      pcbStrongNameToken)) {
        fSetErrorInfo = FALSE;
        goto Error;
    }

    if (pcbPublicKeyBlob)
        *pcbPublicKeyBlob = SN_SIZEOF_KEY(pPublicKey->cbPublicKey);
 
    // Return public key information.
    if (ppbPublicKeyBlob)
        *ppbPublicKeyBlob = (BYTE*)pPublicKey;
    else
        delete [] (BYTE*)pPublicKey;

    return TRUE;

 Error:
    if (fSetErrorInfo)
        SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
    if (pPublicKey)
        delete [] (BYTE*)pPublicKey;
    if (fMapped)
        UnloadAssembly(&sLoadCtx);
    return FALSE;
}



// Create a strong name token from a public key blob.
SNAPI StrongNameTokenFromPublicKey(BYTE    *pbPublicKeyBlob,        // [in] public key blob
                                   ULONG    cbPublicKeyBlob,
                                   BYTE   **ppbStrongNameToken,     // [out] strong name token 
                                   ULONG   *pcbStrongNameToken)
{
    HCRYPTPROV  hProv = NULL;
    HCRYPTHASH  hHash = NULL;
    DWORD       dwHashLen;
    DWORD       dwRetLen;
    BYTE       *pHash;
    DWORD       i;

    Log("StrongNameTokenFromPublicKey(%08X, %08X, %08X, %08X)\n", pbPublicKeyBlob, cbPublicKeyBlob, ppbStrongNameToken, pcbStrongNameToken);

    SN_COMMON_PROLOG();

    // Allocate a buffer for the output token.
    *ppbStrongNameToken = new BYTE[SN_SIZEOF_TOKEN];
    if (*ppbStrongNameToken == NULL) {
        SetStrongNameErrorInfo(E_OUTOFMEMORY);
        return FALSE;
    }
    *pcbStrongNameToken = SN_SIZEOF_TOKEN;

    // We cache a couple of common cases.
    if (SN_IS_NEUTRAL_KEY(pbPublicKeyBlob)) {
        memcpy(*ppbStrongNameToken, g_rbNeutralPublicKeyToken, SN_SIZEOF_TOKEN);
        return TRUE;
    }
    if (cbPublicKeyBlob == sizeof(g_rbMSPublicKey) &&
        memcmp(pbPublicKeyBlob, g_rbMSPublicKey, cbPublicKeyBlob) == 0) {
        memcpy(*ppbStrongNameToken, g_rbMSPublicKeyToken, SN_SIZEOF_TOKEN);
        return TRUE;
    }

    // Look for a CSP to hash the public key.
    hProv = LocateCSP(NULL, SN_HASH_SHA1_ONLY);
    if (!hProv)
        goto Error;

    // Create a hash object.
    if (!SN_CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash))
        goto Error;

    // Compute a hash over the public key.
    if (!SN_CryptHashData(hHash, pbPublicKeyBlob, cbPublicKeyBlob, 0))
        goto Error;

    // Get the length of the hash.
    dwRetLen = sizeof(dwHashLen);
    if (!SN_CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&dwHashLen, &dwRetLen, 0))
        goto Error;

    // Allocate a temporary block to hold the hash.
    pHash = (BYTE*)_alloca(dwHashLen);

    // Read the hash value.
    if (!SN_CryptGetHashParam(hHash, HP_HASHVAL, pHash, &dwHashLen, 0))
        goto Error;

    // We no longer need the hash object or the provider.
    SN_CryptDestroyHash(hHash);
    FreeCSP(hProv);

    // Take the last few bytes of the hash value for our token. (These are the
    // low order bytes from a network byte order point of view). Reverse the
    // order of these bytes in the output buffer to get host byte order.
    _ASSERTE(dwHashLen >= SN_SIZEOF_TOKEN);
    for (i = 0; i < SN_SIZEOF_TOKEN; i++)
        (*ppbStrongNameToken)[SN_SIZEOF_TOKEN - (i + 1)] = pHash[i + (dwHashLen - SN_SIZEOF_TOKEN)];

    return TRUE;

 Error:
    SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
    if (hHash)
        SN_CryptDestroyHash(hHash);
    if (hProv)
        FreeCSP(hProv);
    if (*ppbStrongNameToken)
        delete [] *ppbStrongNameToken;
    return FALSE;
}


// Verify a strong name/manifest against a public key blob.
SNAPI StrongNameSignatureVerificationEx(LPCWSTR     wszFilePath,        // [in] valid path to the PE file for the assembly
                                        BOOLEAN     fForceVerification, // [in] verify even if settings in the registry disable it
                                        BOOLEAN    *pfWasVerified)      // [out] set to false if verify succeeded due to registry settings
{
    DWORD dwOutFlags;
    BOOL bRet;
    bRet = StrongNameSignatureVerification(wszFilePath,
                                           SN_INFLAG_INSTALL|SN_INFLAG_ALL_ACCESS|(fForceVerification ? SN_INFLAG_FORCE_VER : 0),
                                           &dwOutFlags);
    if (bRet && pfWasVerified)
        *pfWasVerified = (dwOutFlags & SN_OUTFLAG_WAS_VERIFIED) != 0;
    return bRet;
}


// Verify a strong name/manifest against a public key blob.
SNAPI StrongNameSignatureVerification(LPCWSTR wszFilePath,      // [in] valid path to the PE file for the assembly
                                      DWORD   dwInFlags,        // [in] flags modifying behaviour
                                      DWORD  *pdwOutFlags)      // [out] additional output info
{
    SN_LOAD_CTX sLoadCtx;
    BOOLEAN     fMapped = FALSE;

    Log("StrongNameSignatureVerification(\"%S\", %08X, %08X, %08X)\n", wszFilePath, dwInFlags, pdwOutFlags);

    SN_COMMON_PROLOG();

    // Map the assembly into memory.
    sLoadCtx.m_fReadOnly = TRUE;
    if (!LoadAssembly(&sLoadCtx, wszFilePath))
        goto Error;
    fMapped = TRUE;

    // Go to common code to process the verification.
    if (!VerifySignature(&sLoadCtx, dwInFlags, pdwOutFlags))
        goto Error;

    // Unmap the image.
    fMapped = FALSE;
    if (!UnloadAssembly(&sLoadCtx))
        goto Error;

    return TRUE;

 Error:
    SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
    if (fMapped)
        UnloadAssembly(&sLoadCtx);
    return FALSE;
}


// Verify a strong name/manifest against a public key blob when the assembly is
// already memory mapped.
SNAPI StrongNameSignatureVerificationFromImage(BYTE     *pbBase,             // [in] base address of mapped manifest file
                                               DWORD     dwLength,           // [in] length of mapped image in bytes
                                               DWORD     dwInFlags,          // [in] flags modifying behaviour
                                               DWORD    *pdwOutFlags)        // [out] additional output info
{
    SN_LOAD_CTX sLoadCtx;
    BOOLEAN     fMapped = FALSE;

    Log("StrongNameSignatureVerificationFromImage(%08X, %08X, %08X, %08X)\n", pbBase, dwLength, dwInFlags, pdwOutFlags);

    SN_COMMON_PROLOG();

    // We don't need to map the image, it's already in memory. But we do need to
    // set up a load context for some of the following routines. LoadAssembly
    // copes with this case for us.
    sLoadCtx.m_pbBase = pbBase;
    sLoadCtx.m_dwLength = dwLength;
    sLoadCtx.m_fReadOnly = TRUE;
    if (!LoadAssembly(&sLoadCtx, NULL))
        goto Error;
    fMapped = TRUE;

    // Go to common code to process the verification.
    if (!VerifySignature(&sLoadCtx, dwInFlags, pdwOutFlags))
        goto Error;

    // Unmap the image.
    fMapped = FALSE;
    if (!UnloadAssembly(&sLoadCtx))
        goto Error;

    return TRUE;

 Error:
    SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
    if (fMapped)
        UnloadAssembly(&sLoadCtx);
    return FALSE;
}


// Verify that two assemblies differ only by signature blob.
SNAPI StrongNameCompareAssemblies(LPCWSTR   wszAssembly1,           // [in] file name of first assembly
                                  LPCWSTR   wszAssembly2,           // [in] file name of second assembly
                                  DWORD    *pdwResult)              // [out] result of comparison
{
    SN_LOAD_CTX sLoadCtx1;
    SN_LOAD_CTX sLoadCtx2;
    size_t      dwSkipOffsets[3];
    size_t      dwSkipLengths[3];
    BOOLEAN     bMappedAssem1 = FALSE;
    BOOLEAN     bMappedAssem2 = FALSE;
    BOOLEAN     bIdentical;
    BOOLEAN     bSkipping;
    DWORD       i, j;

    Log("StrongNameCompareAssemblies(\"%S\", \"%S\", %08X)\n", wszAssembly1, wszAssembly2, pdwResult);

    SN_COMMON_PROLOG();

    // Map each assembly.
    sLoadCtx1.m_fReadOnly = TRUE;
    if (!LoadAssembly(&sLoadCtx1, wszAssembly1))
        goto Error;
    bMappedAssem1 = TRUE;

    sLoadCtx2.m_fReadOnly = TRUE;
    if (!LoadAssembly(&sLoadCtx2, wszAssembly2))
        goto Error;
    bMappedAssem2 = TRUE;

    // If the files aren't even the same length then they must be different.
    if (sLoadCtx1.m_dwLength != sLoadCtx2.m_dwLength)
        goto ImagesDiffer;

    // Check that the signatures are located at the same offset and are the same
    // length in each assembly.
    if (sLoadCtx1.m_pCorHeader->StrongNameSignature.VirtualAddress !=
        sLoadCtx2.m_pCorHeader->StrongNameSignature.VirtualAddress)
        goto ImagesDiffer;
    if (sLoadCtx1.m_pCorHeader->StrongNameSignature.Size !=
        sLoadCtx2.m_pCorHeader->StrongNameSignature.Size)
        goto ImagesDiffer;

    // Set up list of image ranges to skip in the upcoming comparison.
    // First there's the signature blob.
    dwSkipOffsets[0] = sLoadCtx1.m_pbSignature - sLoadCtx1.m_pbBase;
    dwSkipLengths[0] = sLoadCtx1.m_cbSignature;

    // Then there's the checksum.
    if (sLoadCtx1.m_pNtHeaders->OptionalHeader.Magic != sLoadCtx2.m_pNtHeaders->OptionalHeader.Magic)
        goto ImagesDiffer;
    if (sLoadCtx1.m_pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
        dwSkipOffsets[1] = (BYTE*)&((IMAGE_NT_HEADERS32*)sLoadCtx1.m_pNtHeaders)->OptionalHeader.CheckSum - sLoadCtx1.m_pbBase;
    else if (sLoadCtx1.m_pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
        dwSkipOffsets[1] = (BYTE*)&((IMAGE_NT_HEADERS64*)sLoadCtx1.m_pNtHeaders)->OptionalHeader.CheckSum - sLoadCtx1.m_pbBase;
    else {
        SetLastError(CORSEC_E_INVALID_IMAGE_FORMAT);
        goto Error;
    }
    dwSkipLengths[1] = sizeof(DWORD);

    // Skip the COM+ 2.0 PE header extension flags field. It's updated by the
    // signing operation.
    dwSkipOffsets[2] = (BYTE*)&sLoadCtx1.m_pCorHeader->Flags - sLoadCtx1.m_pbBase;
    dwSkipLengths[2] = sizeof(DWORD);

    // Compare the two mapped images, skipping the ranges we defined above.
    bIdentical = TRUE;
    for (i = 0; i < sLoadCtx1.m_dwLength; i++) {

        // Determine if we're skipping the check on the current byte.
        bSkipping = FALSE;
        for (j = 0; j < (sizeof(dwSkipOffsets) / sizeof(dwSkipOffsets[0])); j++)
            if ((i >= dwSkipOffsets[j]) && (i < (dwSkipOffsets[j] + dwSkipLengths[j]))) {
                bSkipping = TRUE;
                break;
            }

        // Perform comparisons as desired.
        if (sLoadCtx1.m_pbBase[i] != sLoadCtx2.m_pbBase[i])
            if (bSkipping)
                bIdentical = FALSE;
            else
                goto ImagesDiffer;
    }

    // The assemblies are the same.
    *pdwResult = bIdentical ? SN_CMP_IDENTICAL : SN_CMP_SIGONLY;

    UnloadAssembly(&sLoadCtx1);
    UnloadAssembly(&sLoadCtx2);

    return TRUE;

 Error:
    SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
    if (bMappedAssem1)
        UnloadAssembly(&sLoadCtx1);
    if (bMappedAssem2)
        UnloadAssembly(&sLoadCtx2);
    return FALSE;

 ImagesDiffer:
    if (bMappedAssem1)
        UnloadAssembly(&sLoadCtx1);
    if (bMappedAssem2)
        UnloadAssembly(&sLoadCtx2);
    *pdwResult = SN_CMP_DIFFERENT;
    return TRUE;
}


// Compute the size of buffer needed to hold a hash for a given hash algorithm.
SNAPI StrongNameHashSize(ULONG  ulHashAlg,  // [in] hash algorithm
                         DWORD *pcbSize)    // [out] size of the hash in bytes
{
    HCRYPTPROV  hProv = NULL;
    HCRYPTHASH  hHash = NULL;
    DWORD       dwSize;

    Log("StrongNameHashSize(%08X, %08X)\n", ulHashAlg, pcbSize);

    SN_COMMON_PROLOG();

    // Default hashing algorithm ID if necessary.
    if (ulHashAlg == 0)
        ulHashAlg = CALG_SHA1;

    // Find a CSP supporting the required algorithm.
    hProv = LocateCSP(NULL, SN_IGNORE_CONTAINER, ulHashAlg);
    if (!hProv)
        goto Error;

    // Create a hash object.
    if (!SN_CryptCreateHash(hProv, ulHashAlg, 0, 0, &hHash))
        goto Error;

    // And ask for the size of the hash.
    dwSize = sizeof(DWORD);
    if (!SN_CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)pcbSize, &dwSize, 0))
        goto Error;

    // Cleanup and exit.
    SN_CryptDestroyHash(hHash);
    FreeCSP(hProv);

    return TRUE;

 Error:
    SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
    if (hHash)
        SN_CryptDestroyHash(hHash);
    if (hProv)
        FreeCSP(hProv);
    return FALSE;
}


// Compute the size that needs to be allocated for a signature in an assembly.
SNAPI StrongNameSignatureSize(BYTE    *pbPublicKeyBlob,    // [in] public key blob
                              ULONG    cbPublicKeyBlob,
                              DWORD   *pcbSize)            // [out] size of the signature in bytes
{
    PublicKeyBlob  *pPublicKey = (PublicKeyBlob*)pbPublicKeyBlob;
    ALG_ID          uHashAlgId;
    ALG_ID          uSignAlgId;
    HCRYPTPROV      hProv = NULL;
    HCRYPTHASH      hHash = NULL;
    HCRYPTKEY       hKey = NULL;
    LPCWSTR         wszKeyContainer;
    DWORD           dwKeyLen;
    DWORD           dwBytes;

    Log("StrongNameSignatureSize(%08X, %08X, %08X)\n", pbPublicKeyBlob, cbPublicKeyBlob, pcbSize);

    SN_COMMON_PROLOG();

    // Special case neutral key.
    if (SN_IS_NEUTRAL_KEY(pPublicKey))
        pPublicKey = SN_MS_KEY();

    // Determine hashing/signing algorithms.
    uHashAlgId = pPublicKey->HashAlgID;
    uSignAlgId = pPublicKey->SigAlgID;

    // Default hashing and signing algorithm IDs if necessary.
    if (uHashAlgId == 0)
        uHashAlgId = CALG_SHA1;
    if (uSignAlgId == 0)
        uSignAlgId = CALG_RSA_SIGN;

    // Create a temporary key container name.
    wszKeyContainer = GetKeyContainerName();
    if (wszKeyContainer == NULL) {
        SetStrongNameErrorInfo(E_OUTOFMEMORY);
        return FALSE;
    }

    // Find a CSP supporting the required algorithms and create a temporary key
    // container.
    hProv = LocateCSP(wszKeyContainer, SN_CREATE_CONTAINER, uHashAlgId, uSignAlgId);
    if (!hProv)
        goto Error;

    // Import the public key (we need to do this in order to determine the key
    // length reliably).
    if (!SN_CryptImportKey(hProv,
                           pPublicKey->PublicKey,
                           pPublicKey->cbPublicKey,
                           0, 0, &hKey))
        goto Error;

    // Query the key attributes (it's the length we're interested in).
    dwBytes = sizeof(dwKeyLen);
    if (!SN_CryptGetKeyParam(hKey, KP_KEYLEN, (BYTE*)&dwKeyLen, &dwBytes, 0))
        goto Error;

    // Delete the key container.
    if (LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER) == NULL) {
        SetLastError(CORSEC_E_CONTAINER_NOT_FOUND);
        goto Error;
    }

    // Recreate the container so we can create a temporary key pair.
    hProv = LocateCSP(wszKeyContainer, SN_CREATE_CONTAINER, uHashAlgId, uSignAlgId);
    if (!hProv)
        goto Error;

    // Create the temporary key pair.
    if (!SN_CryptGenKey(hProv, AT_SIGNATURE, dwKeyLen << 16, &hKey))
        goto Error;

    // Create a hash.
    if (!SN_CryptCreateHash(hProv, uHashAlgId, 0, 0, &hHash))
        goto Error;

    // Compute size of the signature blob.
    if (!SN_CryptSignHashA(hHash, AT_SIGNATURE, NULL, 0, NULL, pcbSize))
        goto Error;

    Log("Signature size for %08X key (%08X bits) is %08X bytes\n", uSignAlgId, dwKeyLen, *pcbSize);

    SN_CryptDestroyHash(hHash);
    SN_CryptDestroyKey(hKey);
    FreeCSP(hProv);
    FreeKeyContainerName(wszKeyContainer);

    return TRUE;

 Error:
    SetStrongNameErrorInfo(HRESULT_FROM_WIN32(GetLastError()));
    if (hHash)
        SN_CryptDestroyHash(hHash);
    if (hKey)
        SN_CryptDestroyKey(hKey);
    if (hProv)
        FreeCSP(hProv);
    FreeKeyContainerName(wszKeyContainer);
    return FALSE;
}


// Retrieve per-thread context, lazily allocating it if necessary.
SN_THREAD_CTX *GetThreadContext()
{
    SN_THREAD_CTX *pThreadCtx = (SN_THREAD_CTX*)TlsGetValue(g_dwStrongNameTlsIndex);
    if (pThreadCtx == NULL) {
        pThreadCtx = new SN_THREAD_CTX;
        if (pThreadCtx == NULL)
            return NULL;
        pThreadCtx->m_dwLastError = S_OK;
        pThreadCtx->m_hProv = NULL;
        TlsSetValue(g_dwStrongNameTlsIndex, pThreadCtx);
    }
    return pThreadCtx;
}


// Set the per-thread last error code.
VOID SetStrongNameErrorInfo(DWORD dwStatus)
{
    SN_THREAD_CTX *pThreadCtx = GetThreadContext();
    if (pThreadCtx == NULL)
        // We'll return E_OUTOFMEMORY when we attempt to get the error.
        return;
    pThreadCtx->m_dwLastError = dwStatus;
}


// Locate CSP based on criteria specified in the registry (CSP name etc).
// Optionally create or delete a named key container within that CSP.
HCRYPTPROV LocateCSP(LPCWSTR    wszKeyContainer,
                     DWORD      dwAction,
                     ALG_ID     uHashAlgId,
                     ALG_ID     uSignAlgId)
{
    DWORD           i;
    DWORD           dwType;
    CHAR            szName[SN_MAX_CSP_NAME + 1];
    DWORD           dwNameLength;
    HCRYPTPROV      hProv;
    BOOLEAN         bFirstAlg;
    BOOLEAN         bFoundHash;
    BOOLEAN         bFoundSign;
    PROV_ENUMALGS   rAlgs;
    CHAR           *szKeyContainer;
    HCRYPTPROV      hRetProv;
    DWORD           dwAlgsLen;

    // Convert the wide character container name to ANSI.
    if (wszKeyContainer) {
        szKeyContainer = (CHAR*)_alloca(wcslen(wszKeyContainer) + 1);
        sprintf(szKeyContainer, "%S", wszKeyContainer);
    }

    // If a CSP name has been provided (and we're not opening a CSP just to do a
    // SHA1 hash or a verification), open the CSP directly.
    if ((g_szCSPName[0] != '\0') &&
        (dwAction != SN_HASH_SHA1_ONLY) &&
        (uHashAlgId == 0) &&
        (uSignAlgId == 0)) {
        if (SN_CryptAcquireContextA(&hProv,
                                    wszKeyContainer ? szKeyContainer : NULL,
                                    g_szCSPName,
                                    PROV_RSA_FULL,
                                    SN_CAC_FLAGS(dwAction)))
            return (dwAction == SN_DELETE_CONTAINER) ? (HCRYPTPROV)~0 : hProv;
        else {
            Log("Failed to open CSP '%s': %08X\n", g_szCSPName, GetLastError());
            return NULL;
        }
    }

    // Set up hashing and signing algorithms to look for based upon input
    // parameters. Or if these haven't been supplied use the configured defaults
    // instead.
    if (uHashAlgId == 0)
        uHashAlgId = g_uHashAlgId;
    if (uSignAlgId == 0)
        uSignAlgId = g_uSignAlgId;

    // If default hashing and signing algorithms have been selected (SHA1 and
    // RSA), we select the default CSP for the RSA_FULL type. Otherwise, you just
    // get the first CSP that supports the algorithms you specified (with no
    // guarantee that the selected CSP is a default of any type). This is
    // because we have no way of forcing the enumeration to just give us default
    // CSPs.
    if (((uHashAlgId == CALG_SHA1) && (uSignAlgId == CALG_RSA_SIGN)) ||
        (dwAction == SN_HASH_SHA1_ONLY)) {
        Log("Attempting to open default provider\n");
        // If we're not trying to create/open/delete a key container, see if a
        // CSP is cached.
        if (wszKeyContainer == NULL && dwAction != SN_DELETE_CONTAINER) {
            if (hProv = LookupCachedCSP()) {
                Log("Found provider in cache\n");
                return hProv;
            }
        }
        if (SN_CryptAcquireContextA(&hProv,
                                    wszKeyContainer ? szKeyContainer : NULL,
                                    NULL,
                                    PROV_RSA_FULL,
                                    SN_CAC_FLAGS(dwAction))) {
            // If we're not trying to create/open/delete a key container, cache
            // the CSP returned.
            if (wszKeyContainer == NULL && dwAction != SN_DELETE_CONTAINER)
                CacheCSP(hProv);
            return (dwAction == SN_DELETE_CONTAINER) ? (HCRYPTPROV)~0 : hProv;
        } else {
            Log("Failed to open: %08X\n", GetLastError());
            return NULL;
        }
    }

    // Some crypto APIs are non thread safe (e.g. enumerating CSP
    // hashing/signing algorithms). Use a mutex to serialize these operations.
    EnterCriticalSection(&g_rStrongNameMutex);

    for (i = 0; ; i++) {

        // Enumerate all CSPs.
        dwNameLength = sizeof(szName);
        if (SN_CryptEnumProvidersA(i, 0, 0, &dwType, szName, &dwNameLength)) {

            // Open the currently selected CSP.
            Log("Considering CSP '%s'\n", szName);
            if (SN_CryptAcquireContextA(&hProv,
                                        NULL,
                                        szName,
                                        dwType,
                                        (g_bRunningOnW2K ? CRYPT_SILENT : 0) |
                                        CRYPT_VERIFYCONTEXT |
                                        (g_bUseMachineKeyset ? CRYPT_MACHINE_KEYSET : 0))) {

                // Enumerate all the algorithms the CSP supports.
                bFirstAlg = TRUE;
                bFoundHash = FALSE;
                bFoundSign = FALSE;
                for (;;) {

                    dwAlgsLen = sizeof(rAlgs);
                    if (SN_CryptGetProvParam(hProv,
                                             PP_ENUMALGS, (BYTE*)&rAlgs, &dwAlgsLen,
                                             bFirstAlg ? CRYPT_FIRST : 0)) {

                        if (rAlgs.aiAlgid == uHashAlgId)
                            bFoundHash = TRUE;
                        else if (rAlgs.aiAlgid == uSignAlgId)
                            bFoundSign = TRUE;

                        if (bFoundHash && bFoundSign) {

                            // Found a CSP that supports the required
                            // algorithms. Re-open the context with access to
                            // the required key container.
                            // Note that the wide string version of
                            // CryptAcquireContext doesn't exist on Win9X, so we
                            // convert the keycontainer name to ASCII first.

                            Log("CSP matches\n");

                            if (SN_CryptAcquireContextA(&hRetProv,
                                                        wszKeyContainer ? szKeyContainer : NULL,
                                                        szName,
                                                        dwType,
                                                        (g_bRunningOnW2K ? CRYPT_SILENT : 0) |
                                                        SN_CAC_FLAGS(dwAction))) {
                                SN_CryptReleaseContext(hProv, 0);
                                LeaveCriticalSection(&g_rStrongNameMutex);
                                return (dwAction == SN_DELETE_CONTAINER) ? (HCRYPTPROV)~0 : hRetProv;
                            } else {
                                Log("Failed to re-open for container: %08X\n", GetLastError());
                                break;
                            }
                        }

                        bFirstAlg = FALSE;

                    } else {
                        _ASSERTE(GetLastError() == ERROR_NO_MORE_ITEMS);
                        break;
                    }

                }

                SN_CryptReleaseContext(hProv, 0);

            } else
                Log("Failed to open CSP: %08X\n", GetLastError());

        } else if (GetLastError() == ERROR_NO_MORE_ITEMS)
            break;

    }

    LeaveCriticalSection(&g_rStrongNameMutex);

    // No matching CSP found.
    SetLastError(CORSEC_E_NO_SUITABLE_CSP);
    return NULL;
}


// Release a CSP acquired through LocateCSP.
VOID FreeCSP(HCRYPTPROV hProv)
{
    // If the CSP is the one currently cached, don't release it yet.
    if (!IsCachedCSP(hProv))
        SN_CryptReleaseContext(hProv, 0);
}


// Locate a cached CSP for this thread.
HCRYPTPROV LookupCachedCSP()
{
    SN_THREAD_CTX *pThreadCtx = GetThreadContext();
    if (pThreadCtx == NULL)
        return NULL;
    return pThreadCtx->m_hProv;
}


// Update the CSP cache for this thread (freeing any CSP displaced).
VOID CacheCSP(HCRYPTPROV hProv)
{
    SN_THREAD_CTX *pThreadCtx = GetThreadContext();
    if (pThreadCtx == NULL)
        return;
    if (pThreadCtx->m_hProv)
        SN_CryptReleaseContext(pThreadCtx->m_hProv, 0);
    pThreadCtx->m_hProv = hProv;
}


// Determine whether a given CSP is currently cached.
BOOLEAN IsCachedCSP(HCRYPTPROV hProv)
{
    SN_THREAD_CTX *pThreadCtx = GetThreadContext();
    if (pThreadCtx == NULL)
        return FALSE;
    return pThreadCtx->m_hProv == hProv;
}


// Simulate CryptEnumProviders on systems which don't have this function. This
// is done by picking the default provider for each provider type (we iterate
// from provider type 1 until we hit a provider type that's reported as invalid;
// not perfect, but it's a reasonable compromise).
BOOLEAN MyCryptEnumProviders(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags,
                             DWORD *pdwType, LPSTR szName, DWORD *pdwLength)
{
    HCRYPTPROV hProv;

    if (SN_CryptAcquireContextA(&hProv,
                                NULL,
                                NULL,
                                dwIndex + 1,
                                (g_bRunningOnW2K ? CRYPT_SILENT : 0) |
                                CRYPT_VERIFYCONTEXT |
                                (g_bUseMachineKeyset ? CRYPT_MACHINE_KEYSET : 0))) {

        if (SN_CryptGetProvParam(hProv, PP_NAME, (BYTE*)szName, pdwLength, 0)) {
            SN_CryptReleaseContext(hProv, 0);
            *pdwType = dwIndex + 1;
            return TRUE;
        }

        Log("Failed to determine provider name: %08X\n", GetLastError());
        return FALSE;

    } else if (GetLastError() == NTE_BAD_PROV_TYPE) {
        Log("Bad provider type: %u\n", dwIndex + 1);
        SetLastError(ERROR_NO_MORE_ITEMS);
        return FALSE;
    } else {
        Log("Failed to find a provider of type %u: %08X\n", dwIndex + 1, GetLastError());
        return FALSE;
    }
}


// Perform late binding to crypto DLLs and entry points needed by strong names.
BOOLEAN LoadCryptoApis()
{
    // Get the addresses of the crypto APIs. These all live in AdvApi32.dll.
    g_hAdvApiDll = WszLoadLibrary(L"AdvApi32.dll");
    if (g_hAdvApiDll == NULL) {
        Log("Couldn't get handle for AdvApi32.dll: %08X\n", GetLastError());
        return FALSE;
    }

#define DEFINE_IMPORT(_func, _args, _reqd)                          \
    *(FARPROC*)&SN_##_func = GetProcAddress(g_hAdvApiDll, #_func);  \
    if ((_reqd) && (SN_##_func == NULL)) {                          \
        Log("Couldn't resolve %s\n", #_func);                       \
        FreeLibrary(g_hAdvApiDll);                                  \
        return FALSE;                                               \
    }
#include "CryptApis.h"

    // If CryptEnumProviders wasn't found, substitute our own version.
    if (SN_CryptEnumProvidersA == NULL)
        SN_CryptEnumProvidersA = MyCryptEnumProviders;

    return TRUE;
}


// Release resources consumed by late binding.
VOID UnloadCryptoApis()
{
    // Don't do this: when called from DllMain PROCESS_DETACH this might not be
    // safe (especially on Win9x).
    //FreeLibrary(g_hAdvApiDll);
}


// Map an assembly into memory.
BOOLEAN LoadAssembly(SN_LOAD_CTX *pLoadCtx, LPCWSTR wszFilePath, BOOLEAN fRequireSignature)
{
    DWORD dwError = S_OK;

    // If a filename is not supplied, the image has already been mapped (and the
    // image base and length fields set up correctly).
    if (wszFilePath == NULL) {
        pLoadCtx->m_fPreMapped = TRUE;
    } else {

        pLoadCtx->m_hMap = INVALID_HANDLE_VALUE;
        pLoadCtx->m_pbBase = NULL;

        // Open the file for reading or writing.
        pLoadCtx->m_hFile = WszCreateFile(wszFilePath,
                                          GENERIC_READ | (pLoadCtx->m_fReadOnly ? 0 : GENERIC_WRITE),
                                          pLoadCtx->m_fReadOnly ? FILE_SHARE_READ : FILE_SHARE_WRITE,
                                          NULL,
                                          OPEN_EXISTING,
                                          0,
                                          NULL);
        if (pLoadCtx->m_hFile == INVALID_HANDLE_VALUE) {
            dwError = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

        pLoadCtx->m_dwLength = SafeGetFileSize(pLoadCtx->m_hFile, NULL);
        if (pLoadCtx->m_dwLength == 0xffffffff) {
            dwError = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

        // Create a mapping handle for the file.
        pLoadCtx->m_hMap = WszCreateFileMapping(pLoadCtx->m_hFile, NULL, pLoadCtx->m_fReadOnly ? PAGE_READONLY : PAGE_READWRITE, 0, 0, NULL);
        if (pLoadCtx->m_hMap == NULL) {
            dwError = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

        // And map it into memory.
        pLoadCtx->m_pbBase = (BYTE*)MapViewOfFile(pLoadCtx->m_hMap, pLoadCtx->m_fReadOnly ? FILE_MAP_READ : FILE_MAP_WRITE, 0, 0, 0);
        if (pLoadCtx->m_pbBase == NULL) {
            dwError = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }
    }

    // Locate standard NT image header.
    pLoadCtx->m_pNtHeaders = SN_ImageNtHeader(pLoadCtx->m_pbBase);
    if (pLoadCtx->m_pNtHeaders == NULL) {
        dwError = CORSEC_E_INVALID_IMAGE_FORMAT;
        goto Error;
    }

    // And then the COM+ extended header.
    DWORD dwCorHdrRVA;
    if (pLoadCtx->m_pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
        dwCorHdrRVA = ((IMAGE_NT_HEADERS32*)pLoadCtx->m_pNtHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress;
    else
        dwCorHdrRVA = ((IMAGE_NT_HEADERS64*)pLoadCtx->m_pNtHeaders)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress;
    pLoadCtx->m_pCorHeader = (IMAGE_COR20_HEADER*)
        SN_ImageRvaToVa(pLoadCtx->m_pNtHeaders,
                        pLoadCtx->m_pbBase, 
                        dwCorHdrRVA);
    if (pLoadCtx->m_pCorHeader == NULL) {
        dwError = CORSEC_E_INVALID_IMAGE_FORMAT;
        goto Error;
    }

    // Set up signature pointer (if we require it).
    if (fRequireSignature) {
        pLoadCtx->m_pbSignature = (BYTE*)SN_ImageRvaToVa(pLoadCtx->m_pNtHeaders,
                                                         pLoadCtx->m_pbBase,
                                                         pLoadCtx->m_pCorHeader->StrongNameSignature.VirtualAddress);
        pLoadCtx->m_cbSignature = pLoadCtx->m_pCorHeader->StrongNameSignature.Size;
        if (pLoadCtx->m_pbSignature == NULL || pLoadCtx->m_cbSignature == 0) {
            dwError = CORSEC_E_MISSING_STRONGNAME;
            goto Error;
        }
    }

    return TRUE;

 Error:
    if (!pLoadCtx->m_fPreMapped) {
    if (pLoadCtx->m_pbBase)
        UnmapViewOfFile(pLoadCtx->m_pbBase);
    if (pLoadCtx->m_hMap != INVALID_HANDLE_VALUE)
        CloseHandle(pLoadCtx->m_hMap);
        if (pLoadCtx->m_hFile != INVALID_HANDLE_VALUE)
            CloseHandle(pLoadCtx->m_hFile);
    }
    SetLastError(dwError);
    return FALSE;
}


// Unload an assembly loaded with LoadAssembly (recomputing checksum if
// necessary).
BOOLEAN UnloadAssembly(SN_LOAD_CTX *pLoadCtx)
{
    BOOLEAN             bResult = TRUE;
    DWORD               dwOldCheckSum;
    DWORD               dwCheckSum;
    IMAGE_NT_HEADERS   *pNtHeaders;

    if (!pLoadCtx->m_fReadOnly) {

        // We late bind CheckSumMappedFile to avoid bringing in IMAGEHLP unless
        // we need to.
        HMODULE hLibrary = WszLoadLibrary(L"imagehlp.dll");
        if (hLibrary) {
            IMAGE_NT_HEADERS *(*SN_CheckSumMappedFile)(BYTE*, DWORD, DWORD*, DWORD*);

            if ((*(FARPROC*)&SN_CheckSumMappedFile = GetProcAddress(hLibrary, "CheckSumMappedFile"))) {

                pNtHeaders = SN_CheckSumMappedFile(pLoadCtx->m_pbBase,
                                                   pLoadCtx->m_dwLength,
                                                   &dwOldCheckSum,
                                                   &dwCheckSum);
                if (pNtHeaders != NULL) {
                    if (pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
                        ((IMAGE_NT_HEADERS32*)pNtHeaders)->OptionalHeader.CheckSum = dwCheckSum;
                    else
                        if (pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
                            ((IMAGE_NT_HEADERS64*)pNtHeaders)->OptionalHeader.CheckSum = dwCheckSum;
                } else
                    bResult = FALSE;
            } else
                bResult = FALSE;

            FreeLibrary(hLibrary);

        } else
            bResult = FALSE;

        if (!pLoadCtx->m_fPreMapped && !FlushViewOfFile(pLoadCtx->m_pbBase, 0))
            bResult = FALSE;
    }

    if (!pLoadCtx->m_fPreMapped) {
    if (!UnmapViewOfFile(pLoadCtx->m_pbBase))
        bResult = FALSE;

    if (!CloseHandle(pLoadCtx->m_hMap))
        bResult = FALSE;

        if (!CloseHandle(pLoadCtx->m_hFile))
            bResult = FALSE;
    }

    return bResult;
}


// Reads CSP configuration info (name of CSP to use, IDs of hashing/signing
// algorithms) from the registry.
VOID ReadRegistryConfig()
{
    HKEY    hKey;
    DWORD   dwLength;

    // Initialize all settings to their default values, in case they've not been
    // specified in the registry.
    g_szCSPName[0] = '\0';
    g_bUseMachineKeyset = TRUE;
    g_uHashAlgId = CALG_SHA1;
    g_uSignAlgId = CALG_RSA_SIGN;
    g_pVerificationRecords = NULL;
    g_fCacheVerify = TRUE;

    // Open the configuration key in the registry.
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, SN_CONFIG_KEY, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
        return;

    // Read the preferred CSP name.
    dwLength = sizeof(g_szCSPName) ;   
    // If the registry key value is too long, that means it is invalid.
    VERIFY(RegQueryValueExA(hKey, SN_CONFIG_CSP, NULL, NULL, 
    	         (BYTE*)g_szCSPName, &dwLength) != ERROR_MORE_DATA);
    g_szCSPName[sizeof(g_szCSPName) - 1] = '\0';   // make sure the string is NULL-terminated
    	         
    Log("Preferred CSP name: '%s'\n", g_szCSPName);

    // Read the machine vs user key container flag.
    DWORD dwUseMachineKeyset = TRUE;
    dwLength = sizeof(dwUseMachineKeyset);
    RegQueryValueExA(hKey, SN_CONFIG_MACHINE_KEYSET, NULL, NULL, (BYTE*)&dwUseMachineKeyset, &dwLength);
    Log("Use machine keyset: %s\n", dwUseMachineKeyset ? "TRUE" : "FALSE");
    g_bUseMachineKeyset = (BOOLEAN)dwUseMachineKeyset;

    // Read the hashing algorithm ID.
    dwLength = sizeof(g_uHashAlgId);
    RegQueryValueExA(hKey, SN_CONFIG_HASH_ALG, NULL, NULL, (BYTE*)&g_uHashAlgId, &dwLength);
    Log("Hashing algorithm: %08X\n", g_uHashAlgId);

    // Read the signing algorithm ID.
    dwLength = sizeof(g_uSignAlgId);
    RegQueryValueExA(hKey, SN_CONFIG_SIGN_ALG, NULL, NULL, (BYTE*)&g_uSignAlgId, &dwLength);
    Log("Signing algorithm: %08X\n", g_uSignAlgId);

    // Read the OK to cache verifications flag.
    DWORD dwCacheVerify = TRUE;
    dwLength = sizeof(dwCacheVerify);
    RegQueryValueExA(hKey, SN_CONFIG_CACHE_VERIFY, NULL, NULL, (BYTE*)&dwCacheVerify, &dwLength);
    Log("OK to cache verifications: %s\n", dwCacheVerify ? "TRUE" : "FALSE");
    g_fCacheVerify = (BOOLEAN)dwCacheVerify;

    // Read verify disable records.
    ReadVerificationRecords();

    RegCloseKey(hKey);
}


// Read verification records from the registry during startup.
VOID ReadVerificationRecords()
{
    HKEY            hKey;
    FILETIME        sFiletime;
    DWORD           i;
    WCHAR           wszSubKey[MAX_PATH + 1];
    DWORD           cchSubKey;
    HKEY            hSubKey;
    WCHAR          *mszUserList;
    DWORD           cbUserList;
    SN_VER_REC     *pVerRec;

    // Open the verification subkey in the registry.
    if (WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, SN_CONFIG_KEY_W L"\\" SN_CONFIG_VERIFICATION_W, 0, KEY_READ, &hKey) != ERROR_SUCCESS)
        return;

    // Assembly specific records are represented as subkeys of the key we've
    // just opened.
    for (i = 0; ; i++) {

        // Get the name of the next subkey.
        cchSubKey = MAX_PATH + 1;
        if (WszRegEnumKeyEx(hKey, i, wszSubKey, &cchSubKey, NULL, NULL, NULL, &sFiletime) != ERROR_SUCCESS)
            break;

        // Open the subkey.
        if (WszRegOpenKeyEx(hKey, wszSubKey, 0, KEY_READ, &hSubKey) == ERROR_SUCCESS) {

            // Read a list of valid users, if supplied.
            mszUserList = NULL;
            if ((WszRegQueryValueEx(hSubKey, SN_CONFIG_USERLIST_W, NULL, NULL, NULL, &cbUserList) == ERROR_SUCCESS) &&
                (cbUserList > 0)) {
                mszUserList = new WCHAR[cbUserList / sizeof(WCHAR)];
                if (mszUserList)
                    WszRegQueryValueEx(hSubKey, SN_CONFIG_USERLIST_W, NULL, NULL, (BYTE*)mszUserList, &cbUserList);
            }

            // We've found a valid entry, add it to the global list.
            // @TODO: out of memory case ignored
            if (pVerRec = new SN_VER_REC) {
                pVerRec->m_mszUserList = mszUserList;
                wcsncpy(pVerRec->m_wszAssembly, wszSubKey, 
                	              NumItems(pVerRec->m_wszAssembly) - 1);
                pVerRec->m_wszAssembly[NumItems(pVerRec->m_wszAssembly) - 1] =  L'\0';
                pVerRec->m_pNext = g_pVerificationRecords;
                g_pVerificationRecords = pVerRec;
                Log("Verification record for '%S' found in registry\n", wszSubKey);
            }
            else
                delete[] mszUserList;

            RegCloseKey(hSubKey);
        }
    }

    RegCloseKey(hKey);
}


// See if there's a verification records for the given assembly.
SN_VER_REC *GetVerificationRecord(LPWSTR wszAssemblyName, PublicKeyBlob *pPublicKey)
{
    SN_VER_REC *pVerRec;
    SN_VER_REC *pWildcardVerRec = NULL;
    LPWSTR         pwszAssembly = NULL;
    BYTE       *pbToken;
    DWORD       cbToken;
    WCHAR       wszStrongName[(SN_SIZEOF_TOKEN * 2) + 1];
    DWORD       i;

    // Compress the public key to make for a shorter assembly name.
    if (!StrongNameTokenFromPublicKey((BYTE*)pPublicKey,
                                      SN_SIZEOF_KEY(pPublicKey->cbPublicKey),
                                      &pbToken,
                                      &cbToken))
        return NULL;

    if (cbToken > SN_SIZEOF_TOKEN)
        return NULL;

    // Turn the token into hex.
    for (i = 0; i < cbToken; i++) {
        static WCHAR wszHex[] = L"0123456789ABCDEF";
        wszStrongName[(i * 2) + 0] = wszHex[(pbToken[i] >> 4)];
        wszStrongName[(i * 2) + 1] = wszHex[(pbToken[i] & 0x0F)];
    }
    wszStrongName[i * 2] = L'\0';
    delete[] pbToken;

    // Build the full assembly name.

    size_t nLen = wcslen(wszAssemblyName) + wcslen(L",") + wcslen(wszStrongName);
    pwszAssembly = (LPWSTR)_alloca((nLen +1)*sizeof(WCHAR)); // +1 for NULL
    if (pwszAssembly == NULL)
            return NULL;

    wcscpy(pwszAssembly, wszAssemblyName);
    wcscat(pwszAssembly, L",");
    wcscat(pwszAssembly, wszStrongName);

    // Iterate over global list of verification records.
    for (pVerRec = g_pVerificationRecords; pVerRec; pVerRec = pVerRec->m_pNext) {
        // Look for matching assembly name.
        if (!_wcsicmp(pwszAssembly, pVerRec->m_wszAssembly)) {
            // Check current user against allowed user name list.
            if (IsValidUser(pVerRec->m_mszUserList))
                return pVerRec;
            else
                return NULL;
        } else if (!wcscmp(L"*,*", pVerRec->m_wszAssembly)) {
            // Found a wildcard record, it'll do if we don't find something more
            // specific.
            if (pWildcardVerRec == NULL)
                pWildcardVerRec = pVerRec;
        } else if (!wcsncmp(L"*,", pVerRec->m_wszAssembly, 2)) {
            // Found a wildcard record (with a specific strong name). If the
            // strong names match it'll do unless we find something more
            // specific (it overrides "*,*" wildcards though).
            if (!_wcsicmp(wszStrongName, &pVerRec->m_wszAssembly[2]))
                pWildcardVerRec = pVerRec;
        }
    }

    // No match on specific assembly name, see if there's a wildcard entry.
    if (pWildcardVerRec)
        // Check current user against allowed user name list.
        if (IsValidUser(pWildcardVerRec->m_mszUserList))
            return pWildcardVerRec;
        else
            return NULL;

    return NULL;
}


// Check current user name against a multi-string user name list. Return true if
// the name is found (or the list is empty).
BOOLEAN IsValidUser(WCHAR *mszUserList)
{
    HANDLE          hToken;
    DWORD           dwRetLen;
    VOID           *pvBuffer;
    TOKEN_USER     *pUser;
    WCHAR           wszUser[1024];
    WCHAR           wszDomain[1024];
    DWORD           cchUser;
    DWORD           cchDomain;
    SID_NAME_USE    eSidUse;
    WCHAR          *wszUserEntry;

    // Empty list implies no user name checking.
    if (mszUserList == NULL)
        return TRUE;

    // Get current user name. Don't cache this to avoid threading/impersonation
    // problems.
    // First look to see if there's a security token on the current thread
    // (maybe we're impersonating). If not, we'll get the token from the
    // process.
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_READ, FALSE, &hToken))
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken)) {
            Log("Failed to find a security token, error %08X\n", GetLastError());
            return FALSE;
        }

    // Get the user SID. (Calculate buffer size first).
    if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &dwRetLen) &&
        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        Log("Failed to calculate token information buffer size, error %08X\n", GetLastError());
        CloseHandle(hToken);
        return FALSE;
    }

    pvBuffer = (BYTE*)_alloca(dwRetLen);

    if (!GetTokenInformation(hToken, TokenUser, pvBuffer, dwRetLen, &dwRetLen)) {
        Log("Failed to acquire token information, error %08X\n", GetLastError());
        CloseHandle(hToken);
        return FALSE;
    }

    pUser = (TOKEN_USER*)pvBuffer;

    // Get the user and domain names.
    cchUser = sizeof(wszUser) / sizeof(WCHAR);
    cchDomain = sizeof(wszDomain) / sizeof(WCHAR);
    if (!WszLookupAccountSid(NULL, pUser->User.Sid,
                             wszUser, &cchUser,
                             wszDomain, &cchDomain,
                             &eSidUse)) {
        Log("Failed to lookup account information, error %08X\n", GetLastError());
        CloseHandle(hToken);
        return FALSE;
    }

    CloseHandle(hToken);

    // Concatenate user and domain name to get a fully qualified account name.
    if (((wcslen(wszUser) + wcslen(wszDomain) + 2) * sizeof(WCHAR)) > sizeof(wszDomain)) {
        Log("Fully qualified account name was too long\n");
        return FALSE;
    }
    wcscat(wszDomain, L"\\");
    wcscat(wszDomain, wszUser);
    Log("Current username is '%S'\n", wszDomain);

    // Check current user against each name in the multi-string (packed
    // list of nul terminated strings terminated with an additional nul).
    wszUserEntry = mszUserList;
    while (*wszUserEntry) {
        if (!_wcsicmp(wszDomain, wszUserEntry))
            return TRUE;
        wszUserEntry += wcslen(wszUserEntry) + 1;
    }

    // No user name match, fail search.
    Log("No username match\n");
    return FALSE;
}


// Locate the public key blob located within the metadata of an assembly file
// and return a copy (use delete to deallocate). Optionally get the assembly
// name as well.
PublicKeyBlob *FindPublicKey(SN_LOAD_CTX   *pLoadCtx,
                             LPWSTR         wszAssemblyName,
                             DWORD          cchAssemblyName)
{
    BYTE                   *pMetaData;
    HRESULT                 hr;
    IMDInternalImport      *pMetaDataImport = NULL;
    PublicKeyBlob          *pKey;
    DWORD                   dwKeyLen;
    mdAssembly              mdAssembly;
    BYTE                   *pKeyCopy = NULL;
    LPCSTR                  szAssemblyName;
    HMODULE                 hLibrary = NULL;
    HRESULT                 (*GetMetaDataInternalInterface)(LPVOID, ULONG, DWORD, REFIID, void**);
    DWORD                   dwError;

    // Locate the COM+ meta data within the header.
    pMetaData = (BYTE*)SN_ImageRvaToVa(pLoadCtx->m_pNtHeaders, pLoadCtx->m_pbBase, pLoadCtx->m_pCorHeader->MetaData.VirtualAddress);

    // Open a metadata scope on the memory directly.
    // We late bind the metadata function to avoid having a direct dependence on
    // mscoree.dll unless we absolutely need to.
    if ((hLibrary = WszLoadLibrary(L"mscoree.dll")) == NULL) {
        Log("WszLoadLibrary(\"mscoree.dll\") failed with %08x\n", GetLastError());
        goto Error;
    }

    if ((*(FARPROC*)&GetMetaDataInternalInterface = GetProcAddress(hLibrary, "GetMetaDataInternalInterface")) == NULL) {
        Log("Couldn't find GetMetaDataInternalInterface() in mscoree.dll\n");
        SetLastError(CORSEC_E_INVALID_IMAGE_FORMAT);
        goto Error;
    }        

    if (FAILED(hr = GetMetaDataInternalInterface(pMetaData,
                                                 pLoadCtx->m_pCorHeader->MetaData.Size,
                                                 ofRead,
                                                 IID_IMDInternalImport,
                                                 (void**)&pMetaDataImport))) {
        Log("GetMetaDataInternalInterface() failed with %08x\n", hr);
        SetLastError(CORSEC_E_INVALID_IMAGE_FORMAT);
        goto Error;
    }

    // Determine the metadata token for the assembly from the scope.
    if (FAILED(hr = pMetaDataImport->GetAssemblyFromScope(&mdAssembly))) {
        Log("pMetaData->GetAssemblyFromScope() failed with %08x\n", hr);
        SetLastError(CORSEC_E_INVALID_IMAGE_FORMAT);
        goto Error;
    }

    // Read the public key location from the assembly properties (it's known as
    // the originator property).
    pMetaDataImport->GetAssemblyProps(mdAssembly,           // [IN] The Assembly for which to get the properties
                                      (const void **)&pKey, // [OUT] Pointer to the Originator blob
                                      &dwKeyLen,            // [OUT] Count of bytes in the Originator Blob
                                      NULL,                 // [OUT] Hash Algorithm
                                      &szAssemblyName,      // [OUT] Buffer to fill with name
                                      NULL,                 // [OUT] Assembly MetaData
                                      NULL);                // [OUT] Flags

    if (dwKeyLen == 0) {
        Log("No public key stored in metadata\n");
        SetLastError(CORSEC_E_MISSING_STRONGNAME);
        goto Error;
    }

    // Make a copy of the key blob (because we're going to close the metadata
    // scope).
    pKeyCopy = new BYTE[dwKeyLen];
    if (pKeyCopy == NULL) {
        SetLastError(E_OUTOFMEMORY);
        goto Error;
    }
    memcpy(pKeyCopy, pKey, dwKeyLen);

    // Copy the assembly name as well (if it was asked for). We also convert
    // from UTF8 to UNICODE while we're at it.
    if (wszAssemblyName)
        if (!WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, szAssemblyName, -1, wszAssemblyName, cchAssemblyName))
			goto Error;

    pMetaDataImport->Release();

    return (PublicKeyBlob*)pKeyCopy;

 Error:
    dwError = GetLastError();
    if (pKeyCopy)
        delete [] pKeyCopy;
    if (pMetaDataImport)
        pMetaDataImport->Release();
    if (hLibrary)
        FreeLibrary(hLibrary);
    SetLastError(dwError);
    return NULL;
}


// Create a temporary key container name likely to be unique to this process and
// thread. Any existing container with the same name is deleted.
LPCWSTR GetKeyContainerName()
{
    static LONG lCount = 0;
    LPWSTR      wszKeyContainer;

    // Name is of form '__MSCORSN__<pid>_<count>__' where <pid> is the current process
    // ID and <count> is a 32-bit, monotonically increasing count (both as 8
    // digit hex numbers).
    wszKeyContainer = new WCHAR[sizeof("__MSCORSN__12345678_12345678__")];
    if (wszKeyContainer == NULL)
        return NULL;

    swprintf(wszKeyContainer,
             L"__MSCORSN__%08X_%08X__",
             GetCurrentProcessId(),
             InterlockedIncrement(&lCount));

    // Delete any stale container with the same name.
    LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER);

    Log("Creating temporary key container name '%S'\n", wszKeyContainer);

    return wszKeyContainer;
}


// Free resources allocated by GetKeyContainerName and delete the named
// container.
VOID FreeKeyContainerName(LPCWSTR wszKeyContainer)
{
    // Delete the temporary container.
    LocateCSP(wszKeyContainer, SN_DELETE_CONTAINER);

    // Free the name.
    delete [] (WCHAR*)wszKeyContainer;
}


// The common code used to verify a signature (taking into account whether skip
// verification is enabled for the given assembly).
BOOLEAN VerifySignature(SN_LOAD_CTX *pLoadCtx, DWORD dwInFlags, DWORD *pdwOutFlags)
{
    PublicKeyBlob  *pPublicKey = NULL;
    ALG_ID          uHashAlgId;
    ALG_ID          uSignAlgId;
    HCRYPTPROV      hProv = NULL;
    HCRYPTHASH      hHash = NULL;
    HCRYPTKEY       hKey = NULL;
    WCHAR           wszAssemblyName[MAX_PATH + 1];
    SN_VER_REC     *pVerRec = NULL;
    DWORD           dwError;

    // At least one access flag should have been specified.
    _ASSERTE(dwInFlags & (SN_INFLAG_ADMIN_ACCESS|SN_INFLAG_USER_ACCESS|SN_INFLAG_ALL_ACCESS));

    if (pdwOutFlags)
        *pdwOutFlags = 0;

    // Read the public key used to sign the assembly from the assembly metadata.
    // Also get the assembly name, we might need this if we fail the
    // verification and need to look up a verification disablement entry.
    pPublicKey = FindPublicKey(pLoadCtx,
                               wszAssemblyName,
                               sizeof(wszAssemblyName) / sizeof(WCHAR));
    if (pPublicKey == NULL)
        goto Error;

    // If this isn't the first time we've been called for this assembly and we
    // know it was fully signed and we're confident it couldn't have been
    // tampered with in the meantime, we can just skip the verification.
    if (!(dwInFlags & SN_INFLAG_FORCE_VER) &&
        !(dwInFlags & SN_INFLAG_INSTALL) &&
        (pLoadCtx->m_pCorHeader->Flags & COMIMAGE_FLAGS_STRONGNAMESIGNED) &&
        ((dwInFlags & SN_INFLAG_ADMIN_ACCESS) || g_fCacheVerify)) {
        Log("Skipping verification due to cached result\n");
        DbgCount(dwInFlags & SN_INFLAG_RUNTIME ? L"RuntimeSkipCache" : L"FusionSkipCache");
        delete [] (BYTE*)pPublicKey;
        return TRUE;
    }

    // If we're not forcing verification, let's see if there's a skip
    // verification entry for this assembly. If there is we can skip all the
    // hard work and just lie about the strong name now. The exception is if the
    // assembly is marked as fully signed, in which case we have to force a
    // verification to see if they're telling the truth.
    if (!(dwInFlags & SN_INFLAG_FORCE_VER) &&
        !(pLoadCtx->m_pCorHeader->Flags & COMIMAGE_FLAGS_STRONGNAMESIGNED) &&
        (pVerRec = GetVerificationRecord(wszAssemblyName, pPublicKey))) {
        Log("Skipping verification due to registry entry\n");
        DbgCount(dwInFlags & SN_INFLAG_RUNTIME ? L"RuntimeSkipDelay" : L"FusionSkipDelay");
        delete [] (BYTE*)pPublicKey;
        return TRUE;
    }

    uHashAlgId = pPublicKey->HashAlgID;
    uSignAlgId = pPublicKey->SigAlgID;

    // Default hashing and signing algorithm IDs if necessary.
    if (uHashAlgId == 0)
        uHashAlgId = CALG_SHA1;
    if (uSignAlgId == 0)
        uSignAlgId = CALG_RSA_SIGN;

    // Find a CSP supporting the required algorithms.
    hProv = LocateCSP(NULL, SN_IGNORE_CONTAINER, uHashAlgId, uSignAlgId);
    if (!hProv)
        goto Error;

    // Import the public key used to check the signature. If we're handed the
    // ECMA key, we translate it to the real (MS) key at this point.
    BYTE   *pbRealPublicKey = pPublicKey->PublicKey;
    DWORD   cbRealPublicKey = pPublicKey->cbPublicKey;
    if (SN_IS_NEUTRAL_KEY(pPublicKey)) {
        pbRealPublicKey = SN_MS_KEY()->PublicKey;
        cbRealPublicKey = SN_MS_KEY()->cbPublicKey;
    }
    if (!SN_CryptImportKey(hProv,
                           pbRealPublicKey,
                           cbRealPublicKey,
                           0, 0, &hKey))
        goto Error;

    // Create a hash object.
    if (!SN_CryptCreateHash(hProv, uHashAlgId, 0, 0, &hHash))
        goto Error;

    // Compute a hash over the image.
    if (!ComputeHash(pLoadCtx, hHash))
        goto Error;

    // Verify the hash against the signature.
    DbgCount(dwInFlags & SN_INFLAG_RUNTIME ? L"RuntimeVerify" : L"FusionVerify");
    if (SN_CryptVerifySignatureA(hHash, pLoadCtx->m_pbSignature, pLoadCtx->m_cbSignature, hKey, NULL, 0)) {
        Log("Verification succeeded (for real)\n");
        if (pdwOutFlags)
            *pdwOutFlags |= SN_OUTFLAG_WAS_VERIFIED;
    } else {
        Log("Verification failed\n");
        SetLastError(CORSEC_E_INVALID_STRONGNAME);
        goto Error;
    }

    SN_CryptDestroyHash(hHash);
    SN_CryptDestroyKey(hKey);
    FreeCSP(hProv);
    delete [] (BYTE*)pPublicKey;

    return TRUE;

 Error:
    dwError = GetLastError();
    if (pPublicKey)
        delete [] (BYTE*)pPublicKey;
    if (hKey)
        SN_CryptDestroyKey(hKey);
    if (hHash)
        SN_CryptDestroyHash(hHash);
    if (hProv)
        FreeCSP(hProv);
    SetLastError(dwError);
    return FALSE;
}


// Compute a hash over the elements of an assembly manifest file that should
// remain static (skip checksum, Authenticode signatures and strong name
// signature blob).
BOOLEAN ComputeHash(SN_LOAD_CTX *pLoadCtx, HCRYPTHASH hHash)
{
    union {
        IMAGE_NT_HEADERS32  m_32;
        IMAGE_NT_HEADERS64  m_64;
    }                       sHeaders;
    IMAGE_SECTION_HEADER   *pSections;
    ULONG                   i;
    BYTE                   *pbSig = pLoadCtx->m_pbSignature;
    DWORD                   cbSig = pLoadCtx->m_cbSignature;

#define SN_HASH(_start, _length) do { if (!SN_CryptHashData(hHash, (_start), (_length), 0)) return FALSE; } while (false)

    // Hash the DOS header if it exists.
    if ((BYTE*)pLoadCtx->m_pNtHeaders != pLoadCtx->m_pbBase)
        SN_HASH(pLoadCtx->m_pbBase, (DWORD)((BYTE*)pLoadCtx->m_pNtHeaders - pLoadCtx->m_pbBase));

    // Add image headers minus the checksum and security data directory.
    if (pLoadCtx->m_pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        sHeaders.m_32 = *((IMAGE_NT_HEADERS32*)pLoadCtx->m_pNtHeaders);
        sHeaders.m_32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
        sHeaders.m_32.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = 0;
        sHeaders.m_32.OptionalHeader.CheckSum = 0;
        SN_HASH((BYTE*)&sHeaders.m_32, sizeof(sHeaders.m_32));
    } else if (pLoadCtx->m_pNtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        sHeaders.m_64 = *((IMAGE_NT_HEADERS64*)pLoadCtx->m_pNtHeaders);
        sHeaders.m_64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress = 0;
        sHeaders.m_64.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY].Size = 0;
        sHeaders.m_64.OptionalHeader.CheckSum = 0;
        SN_HASH((BYTE*)&sHeaders.m_64, sizeof(sHeaders.m_64));
    } else {
        SetLastError(CORSEC_E_INVALID_IMAGE_FORMAT);
        return FALSE;
    }

    // Then the section headers.
    pSections = IMAGE_FIRST_SECTION(pLoadCtx->m_pNtHeaders);
    SN_HASH((BYTE*)pSections, pLoadCtx->m_pNtHeaders->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER));

    // Finally, add data from each section.
    for (i = 0; i < pLoadCtx->m_pNtHeaders->FileHeader.NumberOfSections; i++) {
        BYTE   *pbData = pLoadCtx->m_pbBase + pSections[i].PointerToRawData;
        DWORD   cbData = pSections[i].SizeOfRawData;

        // We need to exclude the strong name signature blob from the hash. The
        // blob could intersect the section in a number of ways.

        if ((pbSig + cbSig) <= pbData || pbSig >= (pbData + cbData))
            // No intersection at all. Hash all data.
            SN_HASH(pbData, cbData);
        else if (pbSig == pbData && cbSig == cbData)
            // Signature consumes entire block. Hash no data.
            ;
        else if (pbSig == pbData)
            // Signature at start. Hash end.
            SN_HASH(pbData + cbSig, cbData - cbSig);
        else if ((pbSig + cbSig) == (pbData + cbData))
            // Signature at end. Hash start.
            SN_HASH(pbData, cbData - cbSig);
        else {
            // Signature in the middle. Hash head and tail.
            SN_HASH(pbData, (DWORD)(pbSig - pbData));
            SN_HASH(pbSig + cbSig, (DWORD)(cbData - (pbSig + cbSig - pbData)));
        }
    }

#ifdef _DEBUG
    BYTE   *pbHash;
    DWORD   cbHash;
    DWORD   dwRetLen = sizeof(cbHash);
    if (SN_CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&cbHash, &dwRetLen, 0)) {
        pbHash = (BYTE*)_alloca(cbHash);
        if (SN_CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &cbHash, 0)) {
            Log("Computed Hash Value (%u bytes):\n", cbHash);
            HexDump(pbHash, cbHash);
        } else
            Log("CryptGetHashParam() failed with %08X\n", GetLastError());
    } else
        Log("CryptGetHashParam() failed with %08X\n", GetLastError());
#endif

    return TRUE;
}


// Inlined IMAGEHLP routine so we can avoid early binding to that DLL.
IMAGE_NT_HEADERS *SN_ImageNtHeader(VOID *pvBase)
{
    IMAGE_NT_HEADERS *pNtHeaders = NULL;
    if (pvBase != NULL && pvBase != (VOID*)-1) {
        __try {
            if ((((IMAGE_DOS_HEADER*)pvBase)->e_magic == IMAGE_DOS_SIGNATURE) &&
                ((DWORD)((IMAGE_DOS_HEADER*)pvBase)->e_lfanew < 0x10000000)) { // 256 MB
                pNtHeaders = (IMAGE_NT_HEADERS*)((BYTE*)pvBase + ((IMAGE_DOS_HEADER*)pvBase)->e_lfanew);
                if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE)
                    pNtHeaders = NULL;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            pNtHeaders = NULL;
        }
    }
    return pNtHeaders;
}

// Inlined IMAGEHLP routine so we can avoid early binding to that DLL.
IMAGE_SECTION_HEADER *SN_ImageRvaToSection(IMAGE_NT_HEADERS *pNtHeaders,
                                           VOID             *pvBase,
                                           DWORD             dwRva)
{
    DWORD                   i;
    IMAGE_SECTION_HEADER   *pNtSection;

    pNtSection = IMAGE_FIRST_SECTION(pNtHeaders);
    for (i = 0; i < pNtHeaders->FileHeader.NumberOfSections; i++) {
        if (dwRva >= pNtSection->VirtualAddress &&
            dwRva < pNtSection->VirtualAddress + pNtSection->SizeOfRawData)
            return pNtSection;
        pNtSection++;
    }

    return NULL;
}


// Inlined IMAGEHLP routine so we can avoid early binding to that DLL.
PVOID SN_ImageRvaToVa(IMAGE_NT_HEADERS  *pNtHeaders,
                      VOID              *pvBase,
                      DWORD              dwRva)
{
    IMAGE_SECTION_HEADER *pNtSection = SN_ImageRvaToSection(pNtHeaders,
                                                            pvBase,
                                                            dwRva);
    if (pNtSection != NULL) {
        return (PVOID)((BYTE*)pvBase +
                       (dwRva - pNtSection->VirtualAddress) +
                       pNtSection->PointerToRawData);
    } else
        return NULL;
}


SNAPI_(DWORD) GetHashFromAssemblyFile(LPCSTR szFilePath, // [IN] location of file to be hashed
                                      unsigned int *piHashAlg, // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                                      BYTE   *pbHash,    // [OUT] hash buffer
                                      DWORD  cchHash,    // [IN]  max size of buffer
                                      DWORD  *pchHash)   // [OUT] length of hash byte array
{
    // Convert filename to wide characters and call the W version of this
    // function.
    MAKE_WIDEPTR_FROMANSI(wszFilePath, szFilePath);
    return GetHashFromAssemblyFileW(wszFilePath, piHashAlg, pbHash, cchHash, pchHash);
}
    
SNAPI_(DWORD) GetHashFromAssemblyFileW(LPCWSTR wszFilePath, // [IN] location of file to be hashed
                                       unsigned int *piHashAlg, // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                                       BYTE   *pbHash,    // [OUT] hash buffer
                                       DWORD  cchHash,    // [IN]  max size of buffer
                                       DWORD  *pchHash)   // [OUT] length of hash byte array
{
    SN_LOAD_CTX     sLoadCtx;
    BYTE           *pbMetaData;
    DWORD           cbMetaData;
    HRESULT         hr;

    sLoadCtx.m_fReadOnly = TRUE;
    if (!LoadAssembly(&sLoadCtx, wszFilePath, FALSE))
        return HRESULT_FROM_WIN32(GetLastError());

    pbMetaData = (BYTE*)SN_ImageRvaToVa(sLoadCtx.m_pNtHeaders,
                                        sLoadCtx.m_pbBase,
                                        sLoadCtx.m_pCorHeader->MetaData.VirtualAddress);
    if (pbMetaData == NULL) {
        UnloadAssembly(&sLoadCtx);
        return E_INVALIDARG;
    }
    cbMetaData = sLoadCtx.m_pCorHeader->MetaData.Size;

    hr = GetHashFromBlob(pbMetaData, cbMetaData, piHashAlg, pbHash, cchHash, pchHash);

    UnloadAssembly(&sLoadCtx);

    return hr;
}
    
SNAPI_(DWORD) GetHashFromFile(LPCSTR szFilePath, // [IN] location of file to be hashed
                              unsigned int *piHashAlg, // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                              BYTE   *pbHash,    // [OUT] hash buffer
                              DWORD  cchHash,    // [IN]  max size of buffer
                              DWORD  *pchHash)   // [OUT] length of hash byte array
{
    HANDLE hFile = CreateFileA(szFilePath,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return HRESULT_FROM_WIN32(GetLastError());

    HRESULT hr = GetHashFromHandle(hFile, piHashAlg, pbHash, cchHash, pchHash);
    CloseHandle(hFile);
    return hr;
}

SNAPI_(DWORD) GetHashFromFileW(LPCWSTR wszFilePath, // [IN] location of file to be hashed
                               unsigned int *piHashAlg, // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                               BYTE   *pbHash,    // [OUT] hash buffer
                               DWORD  cchHash,    // [IN]  max size of buffer
                               DWORD  *pchHash)   // [OUT] length of hash byte array
{
    HANDLE hFile = WszCreateFile(wszFilePath,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                 NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return HRESULT_FROM_WIN32(GetLastError());

    HRESULT hr = GetHashFromHandle(hFile, piHashAlg, pbHash, cchHash, pchHash);
    CloseHandle(hFile);
    return hr;
}

SNAPI_(DWORD) GetHashFromHandle(HANDLE hFile,      // [IN] handle of file to be hashed
                                unsigned int *piHashAlg, // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                                BYTE   *pbHash,    // [OUT] hash buffer
                                DWORD  cchHash,    // [IN]  max size of buffer
                                DWORD  *pchHash)   // [OUT] length of hash byte array
{
    DWORD dwFileLen = SafeGetFileSize(hFile, 0);
    if (dwFileLen == 0xffffffff)
        return HRESULT_FROM_WIN32(GetLastError());

    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF)
        return HRESULT_FROM_WIN32(GetLastError());
    
    DWORD dwResultLen;
    PBYTE pbBuffer = new BYTE[dwFileLen];
    if (!pbBuffer)
        return E_OUTOFMEMORY;

    HRESULT hr;
    if (ReadFile(hFile, pbBuffer, dwFileLen, &dwResultLen, NULL))
        hr = GetHashFromBlob(pbBuffer, dwResultLen, piHashAlg, pbHash, cchHash, pchHash);
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    delete[] pbBuffer;
    return hr;
}

SNAPI_(DWORD) GetHashFromBlob(BYTE   *pbBlob,       // [IN] pointer to memory block to hash
                              DWORD  cchBlob,       // [IN] length of blob
                              unsigned int *piHashAlg,  // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                              BYTE   *pbHash,       // [OUT] hash buffer
                              DWORD  cchHash,       // [IN]  max size of buffer
                              DWORD  *pchHash)      // [OUT] length of hash byte array
{
    if (!piHashAlg || !pbHash || !pchHash)
        return E_INVALIDARG;

    if (!(*piHashAlg))
        *piHashAlg = CALG_SHA1;

    HRESULT    hr = S_OK;
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    DWORD      dwCount = sizeof(DWORD);

    *pchHash = cchHash;

    if ((!SN_CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
        (!SN_CryptCreateHash(hProv, *piHashAlg, 0, 0, &hHash)) ||
        (!SN_CryptHashData(hHash, pbBlob, cchBlob, 0)) ||
        (!SN_CryptGetHashParam(hHash, HP_HASHVAL, pbHash, pchHash, 0)))
        hr = HRESULT_FROM_WIN32(GetLastError());

    if (hHash)
        SN_CryptDestroyHash(hHash);
    if (hProv)
        SN_CryptReleaseContext(hProv, 0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsecr\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "mscorsecr.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Security resource module\0"
#define VER_ORIGFILENAME_STR    "mscorsecr.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsvc\wdlldata.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#define DllRegisterServer PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllMain PrxDllMain

#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsn\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "mscorsn.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Strong Name Support\0"
#define VER_ORIGFILENAME_STR    "mscorsn.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsvc\corsvcimpl.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include <objbase.h>
#include <unknwn.h>

#include "service.h"
#include "corsvc.h"
#include "utilcode.h"
#include "utsem.h"
#include "IPCManagerInterface.h"
#include "corsvcpriv.h"

#ifdef _DEBUG

#define RELEASE(iptr)               \
    {                               \
        _ASSERTE((iptr));           \
        (iptr)->Release();          \
        iptr = NULL;                \
    }

#else

#define RELEASE(iptr)               \
    (iptr)->Release();

#endif

//////////////////////////////////////////////////////////////////////////////
// Forward declarations of proxy-defined code
////
extern "C"
{
    BOOL WINAPI PrxDllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved);
    STDAPI PrxDllRegisterServer(void);      // Proxy registration code
    STDAPI PrxDllUnregisterServer(void);    // Proxy unregistration code
}

//////////////////////////////////////////////////////////////////////////////
// Pass-through to the proxy-defined DllMain code
////
BOOL WINAPI UserDllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    return (PrxDllMain(hInstance, dwReason, lpReserved));
}

//////////////////////////////////////////////////////////////////////////////
// Pass-through to the proxy-defined registration code
////
STDAPI UserDllRegisterServer(void)
{
    HRESULT hr = S_OK;

    // Cannot perform any service-related stuff if we're on Win9x
    if (!bIsRunningOnWinNT)
    {
        return (PrxDllRegisterServer());
    }

    // Add LocalService entry in AppID key
    {
        LPWSTR pszCORSvcClsid;
        RPC_STATUS stat = UuidToString((GUID *)&CLSID_CORSvc, &pszCORSvcClsid);

        if (stat == RPC_S_OK)
        {
            // Calculate the string length needed for the key name
            DWORD cbLocalServiceKey = (sizeof(SZ_APPID_KEY) - sizeof(WCHAR))
                                      + sizeof(WCHAR) /*'\'*/
                                      + sizeof(WCHAR) /*'{'*/
                                      + (wcslen(pszCORSvcClsid) * sizeof(WCHAR))
                                      + sizeof(WCHAR) /*'}'*/
                                      + sizeof(WCHAR) /*NULL*/;

            for (LPWSTR ch = pszCORSvcClsid; *ch; ch++)
            {
                *ch = towupper(*ch);
            }

            // Allocate memory
            LPWSTR pszAppIdEntry = (LPWSTR)_alloca(cbLocalServiceKey);

            // Construct string
            wcscpy(pszAppIdEntry, SZ_APPID_KEY);
            wcscat(pszAppIdEntry, L"\\{");
            wcscat(pszAppIdEntry, pszCORSvcClsid);
            wcscat(pszAppIdEntry, L"}");

            // Deallocate uuid string
            RpcStringFree(&pszCORSvcClsid);

            // Create the key
            HKEY hkAppIdEntry;
            DWORD dwDisp;
            LONG res = WszRegCreateKeyEx(HK_APPID_ROOT, pszAppIdEntry, 0, NULL,
                                         REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                         NULL, &hkAppIdEntry, &dwDisp);

            // If the key doesn't already exist, then add the LocalService value
            if (res == ERROR_SUCCESS)
            {
                // Set the "LocalService" value to the name of the service
                res = WszRegSetValueEx(hkAppIdEntry, L"LocalService", 0, REG_SZ,
                                       (LPBYTE)SZ_SVC_NAME, sizeof(SZ_SVC_NAME));

                // Value creation failed
                if (res != ERROR_SUCCESS)
                {
                    hr = HRESULT_FROM_WIN32(res);
                }

                else
                {
                    // Set the default value to the display name so that
                    // dcomcnfg displays the name rather than the CLSID
                    res = WszRegSetValueEx(hkAppIdEntry, NULL, 0, REG_SZ,
                                           (LPBYTE)SZ_SVC_DISPLAY_NAME,
                                           sizeof(SZ_SVC_DISPLAY_NAME));

                    if (res != ERROR_SUCCESS)
                    {
                        hr = HRESULT_FROM_WIN32(res);
                    }
                }

                RegCloseKey(hkAppIdEntry);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(res);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    // Add the AppID value in the CLSID key
    {
        LPWSTR pszCORSvcClsid;
        RPC_STATUS stat = UuidToString((GUID *)&CLSID_CORSvc, &pszCORSvcClsid);

        if (stat == RPC_S_OK)
        {
            // Calculate the string length needed for the key name
            DWORD cbClsidKey = (sizeof(SZ_CLSID_KEY) - sizeof(WCHAR))
                               + sizeof(WCHAR) /*'\'*/
                               + sizeof(WCHAR) /*'{'*/
                               + (wcslen(pszCORSvcClsid) * sizeof(WCHAR))
                               + sizeof(WCHAR) /*'}'*/
                               + sizeof(WCHAR) /*NULL*/;

            for (LPWSTR ch = pszCORSvcClsid; *ch; ch++)
            {
                *ch = towupper(*ch);
            }

            // Allocate memory for buffers
            LPWSTR pszCLSIDEntry = (LPWSTR)_alloca(cbClsidKey);

            // Construct string
            wcscpy(pszCLSIDEntry, SZ_CLSID_KEY);
            wcscat(pszCLSIDEntry, L"\\{");
            wcscat(pszCLSIDEntry, pszCORSvcClsid);
            wcscat(pszCLSIDEntry, L"}");

            // Create the key
            HKEY hkAppIdEntry;
            DWORD dwDisp;
            LONG res = WszRegCreateKeyEx(HK_CLSID_ROOT, pszCLSIDEntry, 0, NULL,
                                         REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                         NULL, &hkAppIdEntry, &dwDisp);

            // If the key doesn't already exist, then add the LocalService value
            if (res == ERROR_SUCCESS)
            {
                // re-use buffer for string containing only the CLSID
                wcscpy(pszCLSIDEntry, L"{");
                wcscat(pszCLSIDEntry, pszCORSvcClsid);
                wcscat(pszCLSIDEntry, L"}");

                // Set the "LocalService" value to the name of the service
                res = WszRegSetValueEx(hkAppIdEntry, L"AppID", 0, REG_SZ,
                                       (LPBYTE)pszCLSIDEntry,
                                       (wcslen(pszCLSIDEntry) + 1/*(NULL)*/) * sizeof(WCHAR));

                // Value creation failed
                if (res != ERROR_SUCCESS)
                {
                    hr = HRESULT_FROM_WIN32(res);
                }

                RegCloseKey(hkAppIdEntry);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(res);
            }

            // Deallocate uuid string
            RpcStringFree(&pszCORSvcClsid);
        }
        else
            hr = E_FAIL;
    }

    return (PrxDllRegisterServer());
}

//////////////////////////////////////////////////////////////////////////////
// Pass-through to the proxy-defined unregistration code
////
STDAPI UserDllUnregisterServer(void)
{
    HRESULT hr = S_OK;

    // Cannot perform any service-related stuff if we're on Win9x
    if (!bIsRunningOnWinNT)
    {
        return (PrxDllUnregisterServer());
    }

    // Delete LocalService entry in AppID
    {
        LPWSTR pszCORSvcClsid;
        RPC_STATUS stat = UuidToString((GUID *)&CLSID_CORSvc, &pszCORSvcClsid);

        if (stat == RPC_S_OK)
        {
            // Calculate the string length needed for the key name
            DWORD cbLocalServiceKey = (sizeof(SZ_APPID_KEY) - sizeof(WCHAR))
                                      + sizeof(WCHAR) /*'\'*/
                                      + sizeof(WCHAR) /*'{'*/
                                      + (wcslen(pszCORSvcClsid) * sizeof(WCHAR))
                                      + sizeof(WCHAR) /*'}'*/
                                      + sizeof(WCHAR) /*NULL*/;

            // Allocate memory
            LPWSTR pszAppIdEntry = (LPWSTR)_alloca(cbLocalServiceKey);

            // Construct string
            wcscpy(pszAppIdEntry, SZ_APPID_KEY);
            wcscat(pszAppIdEntry, L"\\{");
            wcscat(pszAppIdEntry, pszCORSvcClsid);
            wcscat(pszAppIdEntry, L"}");

            // Deallocate uuid string
            RpcStringFree(&pszCORSvcClsid);

            // Open the key
            HKEY hkAppIdEntry;
            LONG res = WszRegOpenKeyEx(HK_APPID_ROOT, pszAppIdEntry, 0, KEY_READ | KEY_WRITE, &hkAppIdEntry);

            // If the open succeeded, then delete the value entry then delete the key
            if (res == ERROR_SUCCESS)
            {
                // Set the "LocalService" value to the name of the service
                res = WszRegDeleteValue(hkAppIdEntry, L"LocalService");

                RegCloseKey(hkAppIdEntry);

                // Now delete key
                res = WszRegDeleteKey(HK_APPID_ROOT, pszAppIdEntry);

                // AppId key deletion failed
                if (res != ERROR_SUCCESS)
                {
                    hr = HRESULT_FROM_WIN32(res);
                }
            }
        }

        // UuidToString failed
        else
            hr = E_FAIL;
    }

    // Delete CLSID key
    {
        LPWSTR pszCORSvcClsid;
        RPC_STATUS stat = UuidToString((GUID *)&CLSID_CORSvc, &pszCORSvcClsid);

        if (stat == RPC_S_OK)
        {
            // Calculate the string length needed for the key name
            DWORD cbClsidKey = (sizeof(SZ_CLSID_KEY) - sizeof(WCHAR))
                               + sizeof(WCHAR) /*'\'*/
                               + sizeof(WCHAR) /*'{'*/
                               + (wcslen(pszCORSvcClsid) * sizeof(WCHAR))
                               + sizeof(WCHAR) /*'}'*/
                               + sizeof(WCHAR) /*NULL*/;

            for (LPWSTR ch = pszCORSvcClsid; *ch; ch++)
            {
                *ch = towupper(*ch);
            }

            // Allocate memory for buffer
            LPWSTR pszCLSIDEntry = (LPWSTR)_alloca(cbClsidKey);

            // Construct string
            wcscpy(pszCLSIDEntry, SZ_CLSID_KEY);
            wcscat(pszCLSIDEntry, L"\\{");
            wcscat(pszCLSIDEntry, pszCORSvcClsid);
            wcscat(pszCLSIDEntry, L"}");

            // Delete the key
            LONG res = WszRegDeleteKey(HK_CLSID_ROOT, pszCLSIDEntry);

            // Deallocate uuid string
            RpcStringFree(&pszCORSvcClsid);
        }
        else
            hr = E_FAIL;
    }

    hr = PrxDllUnregisterServer();
    return (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ? S_OK : hr);
}


//////////////////////////////////////////////////////////////////////////////
// Needed for the IPCMan code - does nothing
////
STDMETHODIMP_(HINSTANCE) GetModuleInst(void)
{
    return ((HINSTANCE)0);
}

// ****************************************************************************
// Classes:
// ****************************************************************************

// ----------------------------------------------------------------------------
// ClassFactory: only knows how to create CCORSvc instances
// ----------------------------------------------------------------------------

class CClassFactory : public IClassFactory
{
public:
    // ------------------------------------------------------------------------
    // IUnknown
    STDMETHODIMP    QueryInterface (REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef(void)  { return 1;};
    STDMETHODIMP_(ULONG) Release(void) { return 1;}

    // ------------------------------------------------------------------------
    // IClassFactory
    STDMETHODIMP    CreateInstance (LPUNKNOWN punkOuter, REFIID iid, void **ppv);
    STDMETHODIMP    LockServer (BOOL fLock) { return E_FAIL;};

    // ------------------------------------------------------------------------
    // Ctor
    CClassFactory() : m_bIsInited(FALSE) {}

    // ------------------------------------------------------------------------
    // Other
    STDMETHODIMP    Init();
    STDMETHODIMP    Terminate();
    STDMETHODIMP_(BOOL) IsInited() { return m_bIsInited; }

private:
    DWORD m_dwRegister;
    BOOL m_bIsInited;
};


// ----------------------------------------------------------------------------
// Service class: implements ICORSvcDbgInfo
// ----------------------------------------------------------------------------
class CCORSvc : public ICORSvcDbgInfo
{
    friend struct NotifyThreadProcData;

private:

    // This is a handle to the file mapping of the shared data
    static HANDLE                 m_hEventBlock;

    // This is a pointer to shared memory block containing event queue data
    static ServiceEventBlock *m_pEventBlock;

    // This is the global service data structures lock.
    HANDLE                        m_hSvcLock;

    // This contains all the information required to monitor a particular
    // process.
    struct tProcInfo
    {
        DWORD                     dwProcId;       // Target Process ID
        ICORSvcDbgNotify          *pINotify;      // INotify DCOM Interface
        ServiceIPCControlBlock    *pIPCBlock;     // The IPC block
        IPCWriterInterface        *pIPCWriter;    // The IPC block manager
    };

    // This is the array of processes that are currently being monitored
    CDynArray<tProcInfo>          m_arrProcInfo;

    LONG                          m_cRef;         // Ref counting for COM
    BOOL                          m_bIsInited;    // Is the service inited
    BOOL                          m_fStopped;

	SECURITY_ATTRIBUTES           m_SAAllAccess;

public:
    // ------------------------------------------------------------------------
    // IUnknown
    STDMETHODIMP    QueryInterface (REFIID iid, void **ppv);

    STDMETHODIMP_(ULONG) AddRef(void)
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release(void)
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            return 0;
        }

        return 1;
    }

    // ------------------------------------------------------------------------
    // ICORSvcDbgInfo
    STDMETHODIMP RequestRuntimeStartupNotification(
        /*[in]*/ UINT_PTR procId,
        /*[in]*/ ICORSvcDbgNotify *pINotify);

    STDMETHODIMP CancelRuntimeStartupNotification(
        /*[in]*/ UINT_PTR procId,
        /*[in]*/ ICORSvcDbgNotify *pINotify);

    // ------------------------------------------------------------------------
    // constructors/destructors and helper methods
    CCORSvc() : m_hSvcLock(NULL), m_arrProcInfo(), m_cRef(0),
                m_bIsInited(FALSE), m_fStopped(FALSE)
    {
    }

    ~CCORSvc(){}
    
    // Starts the service
    STDMETHODIMP_(void) ServiceStart();

    // Stops the service
    STDMETHODIMP_(void) ServiceStop();

    // Initializes the object (inits the data structures and locks)
    STDMETHODIMP Init();

    // Shuts down
    STDMETHODIMP Terminate();

    // Returns true if the object has been initialized properly
    STDMETHODIMP_(BOOL) IsInited() { return m_bIsInited; }

    // Tells the main service thread that it should shut down
    STDMETHODIMP SignalStop();

    // Spun up threads call this guy
    STDMETHODIMP NotifyThreadProc(ServiceEvent *pEvent, tProcInfo *pInfo);

private:
    // Cancels a notification event, and allows the runtime to continue
    STDMETHODIMP CancelNotify(ServiceEvent *pEvent);

    // Adds a process to the end of a list
    STDMETHODIMP AddProcessToList(DWORD dwProcId, ICORSvcDbgNotify *pINotify,
                            ServiceIPCControlBlock *pIPCBlock,
                            IPCWriterInterface *pIPCWriter);

    // Removes a process from the list
    STDMETHODIMP DeleteProcessFromList(tProcInfo *pInfo);

    // Returns NULL if not found
    tProcInfo   *FindProcessEntry(DWORD dwProcId);

    // This will allocate and return a world SID
    STDMETHODIMP GetWorldSid(PSID *ppSid);

    // This will create an ACL with an ACE associated with the given SID which
    // is assigned the access in dwAccessDesired
    STDMETHODIMP CreateAclWithSid(PACL *ppAcl, PSID pSid, DWORD dwAccessDesired);

    // This will create an ACL with an ACE associated with the given SID which
    // is assigned the access in dwAccessDesired
    STDMETHODIMP ModifyAclWithSid(PACL pAcl, PSID pSid, DWORD dwAccessDesired,
                                  PACL *ppNewAcl);

    // This will initialize a given pre-allocated security descriptor with
    // the Dacl provided.
    STDMETHODIMP InitSDWithDacl(SECURITY_DESCRIPTOR *pSD, PACL pDacl);
    
    // This will initialize a given pre-allocated security attributes struct with
    // the security descriptor provided
    void InitSAWithSD(SECURITY_ATTRIBUTES *pSA, SECURITY_DESCRIPTOR *pSD);
};

// This is a handle to the file mapping of the shared data
HANDLE             CCORSvc::m_hEventBlock = INVALID_HANDLE_VALUE;

// This is a pointer to shared memory block containing event queue data
ServiceEventBlock *CCORSvc::m_pEventBlock = NULL;


// ****************************************************************************
// Globals:
// ****************************************************************************
CClassFactory   *g_pClassFactory = NULL;
CCORSvc         *g_pCORSvc       = NULL;

// ****************************************************************************
// ClassFactory-related Functions:
// ****************************************************************************

// ----------------------------------------------------------------------------
// Function: CClassFactory::QueryInterface
// ----------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void** ppv)
{
    if (ppv == NULL)
        return E_INVALIDARG;

    if (riid == IID_IClassFactory || riid == IID_IUnknown)
    {
        *ppv = (IClassFactory *) this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}  // CClassFactory::QueryInterface

// ---------------------------------------------------------------------------
// Function: CClassFactory::CreateInstance
// ---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void** ppv)
{
    LPUNKNOWN   punk;
    HRESULT     hr;

    *ppv = NULL;

    if (punkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    punk = (LPUNKNOWN)g_pCORSvc;

    hr = punk->QueryInterface(riid, ppv);

    return hr;
}  // CClassFactory::CreateInstance

// ---------------------------------------------------------------------------
// Function: CClassFactory::Init
// ---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::Init()
{
    HRESULT hr;

    // initialize COM for free-threading
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        // initialize security layer with our choices
        hr = CoInitializeSecurity(NULL,
                                  -1,
                                  NULL,
                                  NULL,
                                  RPC_C_AUTHN_LEVEL_NONE,
                                  RPC_C_IMP_LEVEL_IDENTIFY,
                                  NULL,
                                  0,
                                  NULL);

        // register the class-object with OLE
        hr = CoRegisterClassObject(CLSID_CORSvc,
                                   this,
                                   CLSCTX_LOCAL_SERVER,
                                   REGCLS_MULTIPLEUSE,
                                   &m_dwRegister);

        if (FAILED(hr))
        {
            m_dwRegister = 0;
            AddToMessageLogHR(L"CORSvc: CoRegisterClassObject", hr);
        }
    }

    else
    {
        AddToMessageLogHR(L"CORSvc: CoInitializeEx", hr);
    }

    if (SUCCEEDED(hr))
        m_bIsInited = TRUE;

    return (SUCCEEDED(hr) ? S_OK : hr);
}

// ---------------------------------------------------------------------------
// Function: CClassFactory::Terminate
// ---------------------------------------------------------------------------
STDMETHODIMP CClassFactory::Terminate()
{
    HRESULT hr = S_OK;

    if (m_dwRegister)
    {
        hr = CoRevokeClassObject(m_dwRegister);
    }

    // Unload COM Services
    CoUninitialize();

    return (SUCCEEDED(hr) ? S_OK : hr);
}

// ***************************************************************************
// CCORSvc-related Functions:
// ***************************************************************************

// ---------------------------------------------------------------------------
// Function: CCORSvc::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::QueryInterface(REFIID riid, void** ppv)
{
    if (ppv == NULL)
        return E_INVALIDARG;

    if (riid == IID_IUnknown)
    {
        *ppv = (IUnknown *) this;
        AddRef();
        return S_OK;
    }

    if (riid == IID_ICORSvcDbgInfo)
    {
        *ppv = (ICORSvcDbgInfo *) this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}  // CCORSvc::QueryInterface

// ---------------------------------------------------------------------------
// Initializes the global variables and then calls CORSvc's main method
// ---------------------------------------------------------------------------
STDMETHODIMP_(void) ServiceStart (DWORD dwArgc, LPWSTR *lpszArgv)
{
    HRESULT hr = E_FAIL;

    g_pCORSvc = new CCORSvc();
    g_pClassFactory = new CClassFactory();

    if (!g_pCORSvc || !g_pClassFactory)
        goto ErrExit;

    //
    // Initialization
    //

    // report the status to the service control manager.
    if (ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000))
    {
        // Initialize the service object
        hr = g_pCORSvc->Init();
    
        if (FAILED(hr))
        {
            ReportStatusToSCMgr(SERVICE_ERROR_CRITICAL, NO_ERROR, 0);
            goto ErrExit;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrExit;
    }

    // report the status to the service control manager.
    if (ReportStatusToSCMgr(SERVICE_START_PENDING, NO_ERROR, 3000))
    {
        // Initialize the class factory
        hr = g_pClassFactory->Init();
    
        if (FAILED(hr))
        {
            ReportStatusToSCMgr(SERVICE_ERROR_CRITICAL, NO_ERROR, 0);
            goto ErrExit;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrExit;
    }

    if (SUCCEEDED(hr))
    {
        // report the status to the service control manager,
        // indicating that the service has successfully started
        if (!ReportStatusToSCMgr(SERVICE_RUNNING, NO_ERROR, 3000))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto ErrExit;
        }
    }

    // Call the main service method.  This will not return until the
    // service has been requested to stop.
    g_pCORSvc->ServiceStart();

ErrExit:
    if (FAILED(hr))
    {
        if (g_pClassFactory)
        {
            if (g_pClassFactory->IsInited())
                g_pClassFactory->Terminate();

            delete g_pClassFactory;
        }

        if (g_pCORSvc)
        {
            if (g_pCORSvc->IsInited())
                g_pCORSvc->Terminate();

            delete g_pCORSvc;
        }

        ReportStatusToSCMgr(SERVICE_ERROR_CRITICAL, NO_ERROR, 0);
    }
}

// ---------------------------------------------------------------------------
// This just passes right through to a method call on the service object
// ---------------------------------------------------------------------------
VOID ServiceStop()
{
    // 10 Seconds just to be safe, since main thread could be busy elsewhere
    ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 10000);

    // Signal the service thread to terminate
    g_pCORSvc->SignalStop();
}

// ---------------------------------------------------------------------------
// This just notifies the main service thread to shutdown
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::SignalStop()
{
    //
    // Put a stop event in the queue
    //

    // Wait on the semaphore
    WaitForSingleObject(m_pEventBlock->hFreeEventSem, INFINITE);

    // Take the service lock
    WaitForSingleObjectEx(m_pEventBlock->hSvcLock, INFINITE, FALSE);

    // Get an event from the free list
    ServiceEvent *pEvent = m_pEventBlock->GetFreeEvent();
    _ASSERTE(pEvent);

    // Indicate the type of event
    pEvent->eventType = stopService;

    // Put the event in the queue
    m_pEventBlock->QueueEvent(pEvent);

    // Release the lock
    ReleaseMutex(m_pEventBlock->hSvcLock);

    // Indicate there's an event to service
    SetEvent(m_pEventBlock->hDataAvailableEvt);

    return (S_OK);
}

// ---------------------------------------------------------------------------
// For each time a runtime starts up and must notify a client, the service
// spins up a new thread to handle this so that the service may continue
// to operate without waiting for the client to return from notifications.
//
STDMETHODIMP CCORSvc::NotifyThreadProc(ServiceEvent *pEvent, tProcInfo *pInfo)
{
    // Notify the client that the runtime is starting
    HRESULT hr = pInfo->pINotify->NotifyRuntimeStartup(pInfo->dwProcId);

    // Make sure that the debugging services don't get confused
    // if someone tries to attach later on.
    pInfo->pIPCBlock->bNotifyService = FALSE;

    // Duplicate the continue event handle into this process
    HANDLE hRTProc = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pInfo->dwProcId);

    // If we successfully opened the process handle
    if (hRTProc != NULL)
    {
        HANDLE hContEvt;
        BOOL fRes = DuplicateHandle(
            hRTProc, pEvent->eventData.runtimeStartedData.hContEvt,
            GetCurrentProcess(), &hContEvt, 0, FALSE, DUPLICATE_SAME_ACCESS);

        // If handle was successfully duplicated to this process
        if (fRes)
        {
            // Notify the runtime that it is free to continue
            SetEvent(hContEvt);

            CloseHandle(hContEvt);
        }

        CloseHandle(hRTProc);
    }

    // Take the service lock
    WaitForSingleObjectEx(m_pEventBlock->hSvcLock, INFINITE, FALSE);

    // Now remove this guy from the list
    hr = DeleteProcessFromList(pInfo);

    // Return the event to the free list
    m_pEventBlock->FreeEvent(pEvent);

    // Release the lock
    ReleaseMutex(m_pEventBlock->hSvcLock);

    // V on the semaphore
    ReleaseSemaphore(m_pEventBlock->hFreeEventSem, 1, NULL);

    return (hr);
}

struct NotifyThreadProcData
{
    CCORSvc::tProcInfo *pInfo;
    ServiceEvent       *pEvent;
    CCORSvc            *pSvc;
};

// ---------------------------------------------------------------------------
// This is just a wrapper to a call to a member function.
//
DWORD WINAPI NotifyThreadProc(LPVOID pvData)
{
    // Forward the call on to an instance method
    NotifyThreadProcData *pData = (NotifyThreadProcData *)pvData;
    HRESULT hr = pData->pSvc->NotifyThreadProc(pData->pEvent, pData->pInfo);

    // Free the data
    delete pvData;

    // Return non-zero for failure
    return (FAILED(hr));
}

// ---------------------------------------------------------------------------
// This is executed when the client has cancelled a notification request
// but the runtime was already trying to notify the service.  Just let the
// runtime continue.
//
STDMETHODIMP CCORSvc::CancelNotify(ServiceEvent *pEvent)
{
    // Duplicate the continue event handle into this process
    HANDLE hRTProc = OpenProcess(
        PROCESS_DUP_HANDLE, FALSE, pEvent->eventData.runtimeStartedData.dwProcId);

    // If we successfully opened the process handle
    if (hRTProc != NULL)
    {
        HANDLE hContEvt;
        BOOL fRes = DuplicateHandle(
            hRTProc, pEvent->eventData.runtimeStartedData.hContEvt,
            GetCurrentProcess(), &hContEvt, 0, FALSE, DUPLICATE_SAME_ACCESS);

        // If handle was successfully duplicated to this process
        if (fRes)
        {
            // Notify the runtime that it is free to continue
            SetEvent(hContEvt);

            CloseHandle(hContEvt);
        }

        CloseHandle(hRTProc);
    }

    // Take the service lock
    WaitForSingleObjectEx(m_pEventBlock->hSvcLock, INFINITE, FALSE);

    // Return the event to the free list
    m_pEventBlock->FreeEvent(pEvent);

    // Release the lock
    ReleaseMutex(m_pEventBlock->hSvcLock);

    // V on the semaphore
    ReleaseSemaphore(m_pEventBlock->hFreeEventSem, 1, NULL);

    return (S_OK);
}

// ---------------------------------------------------------------------------
//
//  FUNCTION: ServiceStart
//
//  PURPOSE: Actual code of the service
//           that does the work.
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
STDMETHODIMP_(void) CCORSvc::ServiceStart()
{
    //
    // Main Service Loop
    //

    while (true)
    {
        // Wait for an event in the queue.
        DWORD dwWaitRes = WaitForSingleObjectEx(
            m_pEventBlock->hDataAvailableEvt, INFINITE, FALSE);

        // Check for error
        if (dwWaitRes == WAIT_FAILED || dwWaitRes == WAIT_ABANDONED)
        {
            ReportStatusToSCMgr(SERVICE_ERROR_CRITICAL, NO_ERROR, 0);
            ServiceStop();

            return;
        }

        while (true)
        {
            // Take the service lock
            WaitForSingleObjectEx(m_pEventBlock->hSvcLock, INFINITE, FALSE);

            // Get a pointer to the event
            ServiceEvent *pEvent = m_pEventBlock->DequeueEvent();

            // Release the lock
            ReleaseMutex(m_pEventBlock->hSvcLock);

            if (!pEvent)
                break;

            ////////////////////////////////////
            // Notification of a runtime load
            if (pEvent->eventType == runtimeStarted)
            {
                // Take the service lock
                WaitForSingleObjectEx(m_pEventBlock->hSvcLock, INFINITE, FALSE);

                DWORD dwProcId = pEvent->eventData.runtimeStartedData.dwProcId;
                tProcInfo *pInfo = FindProcessEntry(dwProcId);

                // Release the lock
                ReleaseMutex(m_pEventBlock->hSvcLock);

                // The client cancelled before notification could occur
                if (!pInfo)
                    CancelNotify(pEvent);

                // Structure for the ThreadProc argument
                NotifyThreadProcData *pData = new NotifyThreadProcData;

                // If out of memory, need to fail
                // Insert an event to shut down the service
                if (!pData)
                    SignalStop();
                
                else
                {
                    // Fill out the data
                    pData->pEvent = pEvent;
                    pData->pInfo = pInfo;
                    pData->pSvc = this;

                    //
                    // Start up a new thread to handle the notification so that
                    // the service can not be hung by a misbehaved client.
                    //

                    DWORD  dwThreadId;
                    HANDLE hThread = CreateThread(
                        NULL, 0, (LPTHREAD_START_ROUTINE)(::NotifyThreadProc),
                        (LPVOID)pData, 0, &dwThreadId);

                    // If the thread create failed, insert an event to shut
                    // down the service
                    if (hThread == NULL)
                        SignalStop();

                    // Free the thread handle
                    else
                        CloseHandle(hThread);
                }
            }

            /////////////////////////////////
            // Request to stop the service
            else if (pEvent->eventType == stopService)
            {
                if (m_fStopped == FALSE)
                {
                    // Take the service lock and hold it so no one else can
                    // try and notify the service of runtime startup
                    WaitForSingleObjectEx(m_pEventBlock->hSvcLock, INFINITE,
                                          FALSE);
                }

                m_fStopped = TRUE;

                // Return the event to the free list
                m_pEventBlock->FreeEvent(pEvent);

                // V on the semaphore
                ReleaseSemaphore(m_pEventBlock->hFreeEventSem, 1, NULL);
            }

            ////////////////////////
            // Invalid event type
            else
            {
                ReportStatusToSCMgr(SERVICE_ERROR_CRITICAL, NO_ERROR, 0);
                ServiceStop();
                return;
            }
        }

        // Stop the service after 
        if (m_fStopped)
        {
            ServiceStop();

            // Release the lock that was held
            ReleaseMutex(m_pEventBlock->hSvcLock);

            return;
        }

    }
}

//
// ---------------------------------------------------------------------------
//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//    
STDMETHODIMP_(void) CCORSvc::ServiceStop()
{
    // Let the service control manager that we are stopping
    if (!ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 3000))
    {
        AddToMessageLog(L"CORSvc: ReportStatusToSCMgr");
    }

    // Clean up the CORSvc object
    VERIFY(SUCCEEDED(g_pCORSvc->Terminate()));
    delete g_pCORSvc;

    // Let the service control manager that we are stopping
    if (!ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 3000))
    {
        AddToMessageLog(L"CORSvc: ReportStatusToSCMgr");
    }

    // Clean up the class factory
    VERIFY(SUCCEEDED(g_pClassFactory->Terminate()));
    delete g_pClassFactory;

    // Let the service control manager that we are stopped
    if (!ReportStatusToSCMgr(SERVICE_STOPPED, NO_ERROR, 0))
    {
        AddToMessageLog(L"CORSvc: ReportStatusToSCMgr");
    }
}

// ---------------------------------------------------------------------------
// Function: CCORSvc::Init
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::Init()
{
    LPSECURITY_ATTRIBUTES pSA = NULL;
    HRESULT hr;
    
    //
    // Do various security-related operations becuase of the inter-process
    // communication
    //
    if (RunningOnWinNT())
    {    
        ///////////////////////////////////////////////////////
        // Create a "World" access SECURITY_ATTRIBUTES struct
        //
        {
            // Get the "World" group sid
            PSID pSidWorld;
            hr = GetWorldSid(&pSidWorld);

            if (FAILED(hr))
                return (hr);

            // Create an access control list with generic_all access for this sid
            PACL pAclWorldGeneric = NULL;
            hr = CreateAclWithSid(&pAclWorldGeneric, pSidWorld, GENERIC_READ | GENERIC_WRITE);

            if (FAILED(hr))
            {
                FreeSid(pSidWorld);
                return (hr);
            }

            // Clean up a bit
            FreeSid(pSidWorld);

            // Allocate the security descriptor
            SECURITY_DESCRIPTOR *pSDWorldGeneric =
                (SECURITY_DESCRIPTOR*) malloc(SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (pSDWorldGeneric == NULL)
                return (E_OUTOFMEMORY);

            // Initialize the descriptor
            hr = InitSDWithDacl(pSDWorldGeneric, pAclWorldGeneric);

            if (FAILED(hr))
            {
                free ((void *)pSDWorldGeneric);
                return (hr);
            }

            // Initialize the security_attributes struct
            InitSAWithSD(&m_SAAllAccess, pSDWorldGeneric);

            // For use below
            pSA = &m_SAAllAccess;
        }

        /////////////////////////////////////////////////////////////////////
        // Now grant PROCESS_DUP_HANDLE access for this process to "World"
        //
        {
            // Get the "World" group sid
            PSID pSidWorld;
            hr = GetWorldSid(&pSidWorld);

            if (FAILED(hr))
                return (hr);

            HANDLE hProc = GetCurrentProcess();
            _ASSERTE(hProc);

            // Get the DACL for this process
            PACL                 pDaclProc;
            PSECURITY_DESCRIPTOR pSD;
            DWORD dwRes = GetSecurityInfo(hProc, SE_KERNEL_OBJECT,
                                          DACL_SECURITY_INFORMATION, NULL,
                                          NULL, &pDaclProc, NULL, &pSD);

            if (dwRes != ERROR_SUCCESS)
            {
                FreeSid(pSidWorld);
                return (HRESULT_FROM_WIN32(dwRes));
            }

            // Add PROCESS_DUP_HANDLE access for "World" group to the Dacl
            PACL pNewDacl;
            hr = ModifyAclWithSid(pDaclProc, pSidWorld, PROCESS_DUP_HANDLE, &pNewDacl);

            if (dwRes != ERROR_SUCCESS)
            {
                FreeSid(pSidWorld);
                return (HRESULT_FROM_WIN32(dwRes));
            }

            // Clean up a bit
            FreeSid(pSidWorld);

            // Set the new Dacl into the process info
            dwRes = SetSecurityInfo(hProc, SE_KERNEL_OBJECT, 
                                    DACL_SECURITY_INFORMATION, NULL, NULL, 
                                    pNewDacl, NULL);

            if (dwRes != ERROR_SUCCESS)
                return (HRESULT_FROM_WIN32(dwRes));
        }
    }

    ////////////////////////////////////////////////
    // Create shared memory block for event queue
    //
	m_hEventBlock = WszCreateFileMapping(
          INVALID_HANDLE_VALUE,
          pSA,
          PAGE_READWRITE,
          0,
          sizeof(ServiceEventBlock),
          SERVICE_MAPPED_MEMORY_NAME);

	DWORD dwFileMapErr = GetLastError();

    // If the map failed in any way
    if (m_hEventBlock == NULL || dwFileMapErr == ERROR_ALREADY_EXISTS)
        return (HRESULT_FROM_WIN32(dwFileMapErr));

    // Get a pointer valid in this process
	m_pEventBlock = (ServiceEventBlock *) MapViewOfFile(
		m_hEventBlock,
		FILE_MAP_ALL_ACCESS,
		0, 0, 0);

    // Check for failure
    if (m_pEventBlock == NULL)
    {
        // Close the mapping
        CloseHandle(m_hEventBlock);
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    ////////////////////////////////////////////
    // Now initialize the memory block's data
    //
    // initializing handles for error handling
    m_pEventBlock->hDataAvailableEvt = INVALID_HANDLE_VALUE;
    m_pEventBlock->hSvcLock = INVALID_HANDLE_VALUE;
    m_pEventBlock->hFreeEventSem = INVALID_HANDLE_VALUE;
    	
    // Create the event to signifiy that data is available
    m_pEventBlock->hDataAvailableEvt =
        WszCreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_pEventBlock->hDataAvailableEvt == NULL)
        goto ErrExit;

    // Now create the lock for accessing the service data
    m_pEventBlock->hSvcLock = WszCreateMutex(NULL, FALSE, NULL);
    if (m_pEventBlock->hSvcLock == NULL)
        goto ErrExit;

    // Create the semaphore that keeps count of the number of free events
    m_pEventBlock->hFreeEventSem =
        WszCreateSemaphore(NULL, MAX_EVENTS, MAX_EVENTS, NULL);
    if (m_pEventBlock->hFreeEventSem == NULL)
        goto ErrExit;

    // Value of the service's procid for others to use with duphandle
    m_pEventBlock->dwServiceProcId = GetCurrentProcessId();

    // Initialize the queues
    m_pEventBlock->InitQueues();

    // Indicate success
    m_bIsInited = TRUE;
    return (S_OK);
ErrExit:
	// save error code to avoid error code overwritting in following call to WIN32 API
	// the first error code which caused us to exit is more interesting.
        hr = HRESULT_FROM_WIN32(GetLastError());	

	 // we don't need to close hFreeEventSem because if we succeeded in
	 // creating it we can't reach error handling code here
        if(INVALID_HANDLE_VALUE != m_pEventBlock->hDataAvailableEvt) {
        	CloseHandle(m_pEventBlock->hDataAvailableEvt);
	       m_pEventBlock->hDataAvailableEvt = INVALID_HANDLE_VALUE;
        }

        if(INVALID_HANDLE_VALUE != m_pEventBlock->hSvcLock) {
             CloseHandle(m_pEventBlock->hSvcLock);
             m_pEventBlock->hSvcLock = INVALID_HANDLE_VALUE;
        }
        
        UnmapViewOfFile(m_pEventBlock);
        CloseHandle(m_hEventBlock);
        m_pEventBlock = NULL;
        m_hEventBlock = INVALID_HANDLE_VALUE;        
        return hr;	
}

// ---------------------------------------------------------------------------
// Function: CCORSvc::Terminate
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::Terminate()
{
    // Notify each client that the service has stopped.
    while (m_arrProcInfo.Count() > 0)
    {
        tProcInfo *pInfo = m_arrProcInfo.Get(0);

        // Indicate no notification required
        pInfo->pIPCBlock->bNotifyService = FALSE;

        // Notify the client that the service has terminated
        pInfo->pINotify->NotifyServiceStopped();

        // Delete the process info and entries in the handle array
        // Don't need to take lock here since there should be no process
        // trying to notify the service by this point
        DeleteProcessFromList(pInfo);
    }

    // Close the data available handle
    CloseHandle(m_pEventBlock->hDataAvailableEvt);

    // Close the shared memory
    UnmapViewOfFile(m_pEventBlock);
    CloseHandle(m_hEventBlock);

    // Free the security stuff
    SECURITY_DESCRIPTOR *pSD =
        (SECURITY_DESCRIPTOR *)m_SAAllAccess.lpSecurityDescriptor;

    if (pSD != NULL)
    {
        free ((void *)pSD);
        pSD = NULL;
    }

    return (S_OK);
}

// ---------------------------------------------------------------------------
// Function: CCORSvc::DeleteProcess
//
// Deletes the entries from the parallel arrays
// ---------------------------------------------------------------------------
CCORSvc::tProcInfo *CCORSvc::FindProcessEntry(DWORD dwProcId)
{
    // Find the entry
    for (int i = 0; i < m_arrProcInfo.Count(); i++)
    {
        tProcInfo *pCur = m_arrProcInfo.Get(i);

        // Found it
        if (pCur->dwProcId == dwProcId)
            return (pCur);
    }

    // Didn't find it.
    return (NULL);
}
// ---------------------------------------------------------------------------
// Function: CCORSvc::AddProcessToList
//
// This will add the arguments to all of the object's simultaneous arrays.
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::AddProcessToList(DWORD dwProcId,
                                 ICORSvcDbgNotify *pINotify,
                                 ServiceIPCControlBlock *pIPCBlock,
                                 IPCWriterInterface *pIPCWriter)
{
    // Add an entry for the info
    tProcInfo *pInfo = m_arrProcInfo.Append();
    if (!pInfo)
    {
        return (E_OUTOFMEMORY);
    }

    // Save the process information
    pInfo->dwProcId = dwProcId;

    // Save the DCOM Interface
    pINotify->AddRef();
    pInfo->pINotify = pINotify;

    // Save the IPC block pointer
    pInfo->pIPCBlock = pIPCBlock;

    // Save the IPC writer interface
    pInfo->pIPCWriter = pIPCWriter;

    // Indicate success
    return (S_OK);
}

// ---------------------------------------------------------------------------
// Function: CCORSvc::DeleteProcessFromList using a tProcInfo pointer
//
// Deletes the entries from the parallel arrays
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::DeleteProcessFromList(tProcInfo *pInfo)
{
    // Delete the IPC Writer object
    pInfo->pIPCWriter->Terminate();
    delete pInfo->pIPCWriter;

    // Release the DCOM interface
    pInfo->pINotify->Release();
    pInfo->pINotify = NULL;

    // Delete it from the actual list
    m_arrProcInfo.Delete(m_arrProcInfo.ItemIndex(pInfo));

    return (S_OK);
}

// ---------------------------------------------------------------------------
// Function: CCORSvc::RequestRuntimeStartupNotification
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::RequestRuntimeStartupNotification(UINT_PTR procId,
                                          ICORSvcDbgNotify *pINotify)
{
    HRESULT                 hr              = S_OK;
    IPCWriterInterface     *pIPCWriter      = NULL;
    ServiceIPCControlBlock *pIPCBlock       = NULL;
    HINSTANCE           hinstEE             = 0;

    // Make sure we have a valid DCOM interface pointer
    if (!pINotify)
        return (E_INVALIDARG);

    // If the service is shutting down
    if (m_fStopped)
        return (E_FAIL);

    //////////////////////////
    // Check for duplicates
    //

    // Take the service lock
    WaitForSingleObjectEx(m_pEventBlock->hSvcLock, INFINITE, FALSE);

    // See if it already exists
    tProcInfo *pInfo = FindProcessEntry((DWORD)procId);

    // Release the lock, we'll take it again later
    ReleaseMutex(m_pEventBlock->hSvcLock);

    // Duplicate?
    if (pInfo != NULL)
        return (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS));

    // Validate the process id
    HANDLE hProc = OpenProcess(PROCESS_DUP_HANDLE, FALSE, procId);
    if (hProc == NULL)
        return (HRESULT_FROM_WIN32(GetLastError()));
    else
        CloseHandle(hProc);

    /////////////////////////////////
    // Create the shared IPC block
    //

    // Create writer
    pIPCWriter = new IPCWriterInterface();
    if (!pIPCWriter)
    {
        hr = E_OUTOFMEMORY;
        goto ErrExit;
    }

    hr = pIPCWriter->Init();
    if (FAILED(hr))    
        goto ErrExit;
    
    // Create the shared memory block
    hr = pIPCWriter->CreatePrivateBlockOnPid(procId, TRUE, &hinstEE);
    if (FAILED(hr))
        goto ErrExit;

    // Get the IPC block pertaining to the service
    pIPCBlock = pIPCWriter->GetServiceBlock();

    /////////////////////////////////
    // Add the process to the list
    //

    // Take the service lock so we can add the element to the list
    WaitForSingleObjectEx(m_pEventBlock->hSvcLock, INFINITE, FALSE);

    if (!m_fStopped)
    {
        // Now add to the list
        hr = AddProcessToList((DWORD)procId, pINotify, pIPCBlock, pIPCWriter);

        if (FAILED(hr))
        {
            // Release the lock, now that the main service thread completed the request
            ReleaseMutex(m_pEventBlock->hSvcLock);
            goto ErrExit;
        }

        //////////////////////////////////
        // Start monitoring the process
        //
        pIPCBlock->bNotifyService = TRUE;
    }

    // Release the lock, now that the main service thread completed the request
    ReleaseMutex(m_pEventBlock->hSvcLock);

ErrExit:
    if (FAILED(hr))
    {
        if (pIPCWriter)
        {
            pIPCWriter->Terminate();
            delete pIPCWriter;
        }
    }

    return (hr);
}

// ---------------------------------------------------------------------------
// Function: CCORSvc::CancelRuntimeStartupNotification
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::CancelRuntimeStartupNotification(
    /*[in]*/ UINT_PTR dwProcId,
    /*[in]*/ ICORSvcDbgNotify *pINotify)
{
    // Take the service lock
    WaitForSingleObjectEx(m_pEventBlock->hSvcLock, INFINITE, FALSE);

    // Search for entry
    tProcInfo *pInfo = FindProcessEntry((DWORD)dwProcId);

    // Fail if not found
    if (!pInfo)
    {
        // Release the lock, we'll take it again later
        ReleaseMutex(m_pEventBlock->hSvcLock);

        return (E_INVALIDARG);
    }

    // Set the bool to false
    pInfo->pIPCWriter->GetServiceBlock()->bNotifyService = FALSE;

    // Delete the process info and entries in the handle array
    DeleteProcessFromList(pInfo);

    // Release the lock
    ReleaseMutex(m_pEventBlock->hSvcLock);

    return (S_OK);
}

// ---------------------------------------------------------------------------
// This will allocate and return a world SID
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::GetWorldSid(PSID *ppSid)
{
    // Create a SID for "World"
    SID_IDENTIFIER_AUTHORITY sidAuthWorld = SECURITY_WORLD_SID_AUTHORITY;

    if (!AllocateAndInitializeSid(&sidAuthWorld, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, ppSid))
    {
        return(HRESULT_FROM_WIN32(GetLastError()));
    }

    return (S_OK);
}

// ---------------------------------------------------------------------------
// This will create an ACL with an ACE associated with the given SID which
// is assigned the access in dwAccessDesired
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::CreateAclWithSid(PACL *ppAcl, PSID pSid,
                                       DWORD dwAccessDesired)
{
    return (ModifyAclWithSid(NULL, pSid, dwAccessDesired, ppAcl));
}

// ---------------------------------------------------------------------------
// This will create an ACL with an ACE associated with the given SID which
// is assigned the access in dwAccessDesired
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::ModifyAclWithSid(PACL pAcl, PSID pSid,
                                       DWORD dwAccessDesired, PACL *ppNewAcl)
{
    _ASSERTE(pSid != NULL);
    *ppNewAcl = NULL;

    // Used to build an ACL by adding entries
    EXPLICIT_ACCESS acc;

    // Initialize the struct
    acc.grfAccessPermissions = dwAccessDesired;
    acc.grfAccessMode = GRANT_ACCESS;
    acc.grfInheritance = NO_PROPAGATE_INHERIT_ACE;

    // Initialize the trustee
    acc.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    acc.Trustee.pMultipleTrustee = NULL;
    acc.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    acc.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    acc.Trustee.ptstrName = (LPTSTR)pSid;

    // This should add an ACE to the ACL (which is null), creating a new ACL
    DWORD dwRes = SetEntriesInAcl(1, &acc, pAcl, ppNewAcl);

    if (dwRes != ERROR_SUCCESS)
        return (HRESULT_FROM_WIN32(dwRes));

    return (S_OK);
}

// ---------------------------------------------------------------------------
// This will initialize a given pre-allocated security descriptor with
// the Dacl provided.
// ---------------------------------------------------------------------------
STDMETHODIMP CCORSvc::InitSDWithDacl(SECURITY_DESCRIPTOR *pSD,
                                     PACL pDacl)
{
    // Initialize the security descriptor
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        return(HRESULT_FROM_WIN32(GetLastError()));

    // Insert the ACL into the descriptor
    if (!SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE))
        return(HRESULT_FROM_WIN32(GetLastError()));

    return (S_OK);
}

// ---------------------------------------------------------------------------
// This will initialize a given pre-allocated security attributes struct with
// the security descriptor provided
// ---------------------------------------------------------------------------
void CCORSvc::InitSAWithSD(SECURITY_ATTRIBUTES *pSA, SECURITY_DESCRIPTOR *pSD)
{
    pSA->nLength = sizeof(SECURITY_ATTRIBUTES);
    pSA->lpSecurityDescriptor = pSD;
    pSA->bInheritHandle = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorveh\classfactory.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ClassFactory.h
//
// Class factories are used by the pluming in COM to activate new objects.  
// This module contains the class factory code to instantiate the debugger
// objects described in <cordb.h>.
//
//*****************************************************************************
#ifndef __ClassFactory__h__
#define __ClassFactory__h__

//#include <cordb.h>						// Public header definitions.


// This typedef is for a function which will create a new instance of an object.
typedef HRESULT (* PFN_CREATE_OBJ)(REFIID riid, void **ppvObject);

//*****************************************************************************
// This structure is used to declare a global list of coclasses.  The class
// factory object is created with a pointer to the correct one of these, so
// that when create instance is called, it can be created.
//*****************************************************************************
struct COCLASS_REGISTER
{
	const GUID *pClsid;					// Class ID of the coclass.
	LPCWSTR		szProgID;				// Prog ID of the class.
	PFN_CREATE_OBJ pfnCreateObject;		// Creation function for an instance.
};



//*****************************************************************************
// One class factory object satifies all of our clsid's, to reduce overall 
// code bloat.
//*****************************************************************************
class CClassFactory :
	public IClassFactory
{
	CClassFactory() { }						// Can't use without data.
	
public:
	CClassFactory(const COCLASS_REGISTER *pCoClass)
		: m_cRef(1), m_pCoClass(pCoClass)
	{ }

	
	//
	// IUnknown methods.
	//

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        REFIID		riid,
        void		**ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return (InterlockedIncrement((long *) &m_cRef));
	}
    
    virtual ULONG STDMETHODCALLTYPE Release()
	{
		long		cRef = InterlockedDecrement((long *) &m_cRef);
		if (cRef <= 0)
			delete this;
		return (cRef);
	}


	//
	// IClassFactory methods.
	//

    virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
        IUnknown	*pUnkOuter,
        REFIID		riid,
        void		**ppvObject);
    
    virtual HRESULT STDMETHODCALLTYPE LockServer( 
        BOOL		fLock);


private:
	DWORD		m_cRef;						// Reference count.
	const COCLASS_REGISTER *m_pCoClass;		// The class we belong to.
};



#endif // __ClassFactory__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsvc\service.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "winwrap.h"
#include "utilcode.h"
#include "wchar.h"
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>

#include "service.h"
#include "resource.h"

// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
BOOL                    bIsRunningOnWinNT   = FALSE;
BOOL                    bIsRunningOnWinNT5  = FALSE;
BOOL                    bDebug              = FALSE;
WCHAR                   szErr[256];
HANDLE                  g_hThisInst         = INVALID_HANDLE_VALUE;

extern "C"
{
    VOID WINAPI ServiceMain(DWORD dwArgc, LPWSTR *lpszArgv);
    VOID WINAPI ServiceCtrl(DWORD dwCtrlCode);
    BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved);
    STDAPI DllRegisterServer(void);
    STDAPI DllUnregisterServer(void);
}

//////////////////////////////////////////////////////////////////////////////
// Internal function prototypes
////
LPWSTR GetLastErrorText(LPWSTR lpszBuf, DWORD dwSize);

//
//  FUNCTION: ServiceMain
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
VOID WINAPI ServiceMain(DWORD dwArgc, LPWSTR *lpszArgv)
{
    if (dwArgc == 1 && _wcsicmp(lpszArgv[0], L"-debug") == 0)
    {
        bDebug = TRUE;
    }

    // register our service control handler:
    if (bIsRunningOnWinNT && !bDebug)
    {
        sshStatusHandle = RegisterServiceCtrlHandler(SZ_SVC_NAME, ServiceCtrl);

        if (!sshStatusHandle)
            return;
    }

    // SERVICE_STATUS members that don't change in example
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;

    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
                            SERVICE_START_PENDING, // service state
                            NO_ERROR,              // exit code
                            3000))                 // wait hint
    {
        return;
    }

    // Your defined function
    ServiceStart(dwArgc, lpszArgv);

    return;
}



//
//  FUNCTION: ServiceCtrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI ServiceCtrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch (dwCtrlCode)
    {
    // Stop the service.
    //
    // SERVICE_STOP_PENDING should be reported before
    // setting the Stop Event - hServerStopEvent - in
    // ServiceStop().  This avoids a race condition
    // which may result in a 1053 - The Service did not respond...
    // error.
    case SERVICE_CONTROL_STOP:
        ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);
        ServiceStop();
        return;

        // Update the service status.
    case SERVICE_CONTROL_INTERROGATE:
        break;

        // invalid control code
    default:
        break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
}

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;

    if (bIsRunningOnWinNT && !bDebug) // when debugging we don't report to the SCM
    {
        if (dwCurrentState == SERVICE_START_PENDING)
        {
            ssStatus.dwControlsAccepted = 0;
        }
        else
        {
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
        }

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ((dwCurrentState == SERVICE_RUNNING) || (dwCurrentState == SERVICE_STOPPED))
        {
            ssStatus.dwCheckPoint = 0;
        }
        else
        {
            ssStatus.dwCheckPoint = dwCheckPoint++;
        }


        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus(sshStatusHandle, &ssStatus)))
        {
            AddToMessageLog(SZ_SVC_NAME L"failure: SetServiceStatus");
        }
    }

    return fResult;
}

//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPWSTR lpszMsg)
{
    return;
    /*
    WCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPWSTR  lpszStrings[2];


    if (!bIsRunningOnWinNT)
    {
        dwErr = GetLastError();

        // Use event logging to log the error.
        //
        hEventSource = WszRegisterEventSource(NULL, SZSERVICENAME);

        _stprintf(szMsg, L"%s error: %d", SZSERVICENAME, dwErr);
        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        if (hEventSource != NULL)
        {
            WszReportEvent(hEventSource, // handle of event source
                        EVENTLOG_ERROR_TYPE,  // event type
                        0,                    // event category
                        0,                    // event ID
                        NULL,                 // current user's SID
                        2,                    // strings in lpszStrings
                        0,                    // no bytes of raw data
                        (const WCHAR **)lpszStrings,          // array of error strings
                        NULL);                // no raw data

            (VOID) DeregisterEventSource(hEventSource);
        }
    }
    */
}



//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLogHR(LPWSTR lpszMsg, HRESULT hr)
{
    return;
    /*
    WCHAR   szMsg[1024];
    HANDLE  hEventSource;
    LPWSTR  lpszStrings[2];


    if (!bIsRunningOnWinNT)
    {
        // Use event logging to log the error.
        hEventSource = RegisterEventSource(NULL, SZSERVICENAME);

        _stprintf(szMsg, L"%s error: %8x (HRESULT)", SZSERVICENAME, hr);
        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        if (hEventSource != NULL)
        {
            WszReportEvent(hEventSource, // handle of event source
                        EVENTLOG_ERROR_TYPE,  // event type
                        0,                    // event category
                        0,                    // event ID
                        NULL,                 // current user's SID
                        2,                    // strings in lpszStrings
                        0,                    // no bytes of raw data
                        (const WCHAR **)lpszStrings,          // array of error strings
                        NULL);                // no raw data

            DeregisterEventSource(hEventSource);
        }
    }
    */
}



//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPWSTR GetLastErrorText(LPWSTR lpszBuf, DWORD dwSize)
{
    DWORD dwRet;
    LPWSTR lpszTemp = NULL;

    dwRet = WszFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                             NULL,
                             GetLastError(),
                             LANG_NEUTRAL,
                             (LPWSTR)&lpszTemp,
                             0,
                             NULL);

    // supplied buffer is not long enough
    if (!dwRet || ((long)dwSize < (long)dwRet+14))
        lpszBuf[0] = L'\0';
    else
    {
        size_t lpszTempLen = wcslen(lpszTemp);
        _ASSERTE(lpszTempLen >= 2);

        if (lpszTempLen >= 2)
        {
            lpszTemp[wcslen(lpszTemp)-2] = L'\0';  //remove cr and newline character
            swprintf(lpszBuf, L"%s (0x%x)", lpszTemp, GetLastError());
        }
        else
            swprintf(lpszBuf, L"Unknown error.");
    }

    if (lpszTemp)
        LocalFree((HLOCAL) lpszTemp);

    return lpszBuf;
}

// ---------------------------------------------------------------------------
// %%Function: DllRegisterServer
// ---------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    return S_OK;

#if 0
    HRESULT hr = S_OK;


    // The very first step to registering should be to unregister, since someone
    // might be trying to register the same service with a dll in a different
    // location, and so unregistering should remove all keys related to the old
    // service and start with a clean slate
    {
        DllUnregisterServer();
    }

    // The service does not run on WinNT 4
    if (bIsRunningOnWinNT && !bIsRunningOnWinNT5)
    {
        return (S_FALSE);
    }

    // If not on NT, then there is no service manager
    if (!bIsRunningOnWinNT)
    {
        return UserDllRegisterServer();
    }

    // First, make the svchost entry
    {
        LPWSTR pszValue = NULL;
        DWORD cbValue = 0;
        DWORD cbData = 0;

        HKEY hkSvchost;
        DWORD dwDisp;
        LONG res = WszRegCreateKeyEx(HK_SVCHOST_ROOT, SZ_SVCHOST_KEY, 0, NULL,
                                     REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                     NULL, &hkSvchost, &dwDisp);

        if (res == ERROR_SUCCESS)
        {
            // If the key already exists, then perhaps so does the Svchost value - check and get
            if (dwDisp == REG_OPENED_EXISTING_KEY)
            {
                // First query to see if it exists
                DWORD dwType;
                res = WszRegQueryValueEx(hkSvchost, SZ_SVCGRP_VAL_NAME, NULL, &dwType, NULL, &cbData);

                // If the value already exists, grab it and put it in buffer big enough to have this
                // service added on to the end.
                if (res == ERROR_SUCCESS && dwType == REG_MULTI_SZ)
                {
                    // Get the multi-string
                    cbValue = cbData + sizeof(SZ_SVC_NAME);
                    pszValue = (LPWSTR)_alloca(cbValue);
                    res = WszRegQueryValueEx(hkSvchost, SZ_SVCGRP_VAL_NAME, NULL, &dwType, (LPBYTE) pszValue, &cbData);
                }
            }

            // If a value doesn't already exist, use default
            if (!pszValue)
            {
                cbValue = sizeof(SZ_SVC_NAME L"\0");
                pszValue = SZ_SVC_NAME L"\0";
            }
            else
            {
                // Check to see if this service has already been registered
                LPWSTR pszSvcName;
                BOOL bIsThere = FALSE;
                for (pszSvcName = pszValue; *pszSvcName; pszSvcName += wcslen(pszSvcName) + 1)
                {
                    if (wcscmp(pszSvcName, SZ_SVC_NAME) == 0)
                    {
                        bIsThere = TRUE;
                        break;
                    }
                }

                // If it is not already in the string, must add it to the end
                if (!bIsThere)
                {
                    // Append this service to the end, compensating for double null termination
                    LPWSTR szStr = (LPWSTR)((LPBYTE)pszValue + cbData - sizeof(WCHAR));
                    wcscpy(szStr, SZ_SVC_NAME);
                    *((LPWSTR)((LPBYTE)pszValue + cbValue - sizeof(WCHAR))) = L'\0';
                }

                // If it is in the string, no need to add it - we're already registered
                else
                {
                    pszValue = NULL;
                    cbValue = 0;
                }
            }

            if (pszValue)
            {
                res = WszRegSetValueEx(hkSvchost, SZ_SVCGRP_VAL_NAME, NULL, REG_MULTI_SZ, (LPBYTE)pszValue, cbValue);

                // Check for failure
                if (res != ERROR_SUCCESS)
                {
                    hr = HRESULT_FROM_WIN32(res);
                }
            }

            RegCloseKey(hkSvchost);
        }
    }

    // Make sure we're succeeding at this point
    if (FAILED(hr))
    {
        // Try to undo what we've done so far
        DllUnregisterServer();

        // Return the bad error code.
        return (hr);
    }

    // Register the service
    {
        SC_HANDLE   schService;
        SC_HANDLE   schSCManager;

        WCHAR szDllPath[MAX_PATH + 1];

        if (WszGetModuleFileName((HMODULE)g_hThisInst, szDllPath, MAX_PATH) == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        else
        {
            // Try and create the service
            LPWSTR pszImagePath = SZ_SVCHOST_BINARY_PATH L" -k " SZ_SVCGRP_VAL_NAME;

            schSCManager = OpenSCManager(NULL,                   // machine (NULL == local)
                                         NULL,                   // database (NULL == default)
                                         SC_MANAGER_ALL_ACCESS); // access required 
            if (schSCManager)
            {
                schService = CreateService(schSCManager,               // SCManager database
                                           SZ_SVC_NAME,             // name of service
                                           SZ_SVC_DISPLAY_NAME,     // name to display
                                           SERVICE_ALL_ACCESS,         // desired access
                                           SERVICE_WIN32_SHARE_PROCESS,// service type
                                           SERVICE_DISABLED ,       // start type
                                           SERVICE_ERROR_NORMAL,       // error control type
                                           pszImagePath,               // service's binary
                                           NULL,                       // no load ordering group
                                           NULL,                       // no tag identifier
                                           NULL,                       // dependencies
                                           NULL,                       // LocalSystem account
                                           NULL);                      // no password

                // Service was successfully added
                if (schService != NULL)
                {
                    // Change the description of the entry.  This is only supported
                    // on Win2k so we bind to the entry point dynamically.  Hard to
                    // believe, but the original svc host didn't support this.
                    if (bIsRunningOnWinNT)
                    {
                        typedef BOOL (WINAPI *pfnCONFIG)(
                                          SC_HANDLE hService,  // handle to service
                                          DWORD dwInfoLevel,   // information level
                                          LPVOID lpInfo);      // new data
                        pfnCONFIG pfn = 0;

                        HINSTANCE hMod = WszLoadLibrary(L"ADVAPI32.DLL");
                        if (hMod)
                        {
                            SERVICE_DESCRIPTION sDescription;
                            WCHAR   rcDesc[256];
                            if (LoadStringRC(IDS_GENERAL_SVC_DESCRIPTION, rcDesc, 
                                             NumItems(rcDesc), true) == S_OK)
                            {
                                sDescription.lpDescription = rcDesc;
                                pfn = (pfnCONFIG) GetProcAddress(hMod, "ChangeServiceConfig2W");
                                if (pfn)
                                    (*pfn)(schService, SERVICE_CONFIG_DESCRIPTION, &sDescription);
                            }
                            FreeLibrary(hMod);
                        }
                    }

                    // Try and add parameters key and ServiceDll value
                    HKEY hkSvcParam;
                    DWORD dwDisp;
                    LPWSTR pszParam = SZ_SERVICES_KEY L"\\" SZ_SVC_NAME L"\\Parameters";
                    LONG res = WszRegCreateKeyEx(HK_SERVICES_ROOT, pszParam, 0, NULL,
                                                 REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                                 NULL, &hkSvcParam, &dwDisp);

                    // Key creation succeeded
                    if (res == ERROR_SUCCESS)
                    {
                        // Set the "ServiceDll" value to the path to this dll
                        res = WszRegSetValueEx(hkSvcParam, L"ServiceDll", 0, REG_EXPAND_SZ,
                                               (LPBYTE)szDllPath, (wcslen(szDllPath) + 1) * sizeof(WCHAR));

                        // Value creation failed
                        if (res != ERROR_SUCCESS)
                        {
                            hr = HRESULT_FROM_WIN32(res);
                        }

                        RegCloseKey(hkSvcParam);
                    }

                    // Key creation failed
                    else
                    {
                        hr = HRESULT_FROM_WIN32(res);
                    }

                    CloseServiceHandle(schService);
                }

                // Service addition was unsuccessful
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());

                    if (hr == HRESULT_FROM_WIN32(ERROR_SERVICE_EXISTS))
                        hr = S_OK;
                }

                CloseServiceHandle(schSCManager);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

        }
    }

    // If the process has failed thus far, no point in calling the
    // user's portion of the code
    if (FAILED(hr))
    {
        // Try to undo what we've done so far
        DllUnregisterServer();

        // Return the bad error code.
        return (hr);
    }

    // Everything is going to plan, continue
    else
        return (UserDllRegisterServer());
#endif // 0
}  // DllRegisterServer

// ---------------------------------------------------------------------------
// %%Function: DllUnregisterServer
// ---------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    return NOERROR;

#if 0
    HRESULT hr = S_OK;

    // The service does not run on WinNT 4
    if (bIsRunningOnWinNT && !bIsRunningOnWinNT5)
    {
        return (S_FALSE);
    }

    // If not on NT, then there is no service manager
    if (!bIsRunningOnWinNT)
    {
        return UserDllUnregisterServer();
    }

    // Delete the svchost entry
    {
        LPWSTR pszValue = NULL;
        DWORD cbValue = 0;
        DWORD cbData = 0;

        HKEY hkSvchost;
        LONG res = WszRegOpenKeyEx(HK_SVCHOST_ROOT, SZ_SVCHOST_KEY, 0, KEY_ALL_ACCESS, &hkSvchost);

        if (res == ERROR_SUCCESS)
        {
            // First query to see if it exists
            DWORD dwType;
            res = WszRegQueryValueEx(hkSvchost, SZ_SVCGRP_VAL_NAME, NULL, &dwType, NULL, &cbData);

            // If the value already exists, grab it and put it in buffer
            if (res == ERROR_SUCCESS)
            {
                if (dwType == REG_MULTI_SZ)
                {
                    // Get the multi-string
                    cbValue = cbData;
                    pszValue = (LPWSTR)_alloca(cbValue);
                    res = WszRegQueryValueEx(hkSvchost, SZ_SVCGRP_VAL_NAME, NULL, &dwType, (LPBYTE) pszValue, &cbData);

                    // If value exists, then remove service listing if it has one
                    if (res == ERROR_SUCCESS)
                    {
                        // Check to see if this service is registered
                        LPWSTR pszSvcName;
                        for (pszSvcName = pszValue; *pszSvcName; pszSvcName += wcslen(pszSvcName) + 1)
                        {
                            if (wcscmp(pszSvcName, SZ_SVC_NAME) == 0)
                            {
                                // Found it, so remove the string
                                size_t cchSvcName = wcslen(pszSvcName);
                                memcpy((PVOID)pszSvcName,
                                       (PVOID)(pszSvcName + cchSvcName + 1),
                                       cbData - ((size_t)(pszSvcName + cchSvcName + 1) - (size_t)pszValue));

                                cbValue -= sizeof(SZ_SVC_NAME);

                                // If this was the only service, then there's just a null in the string, and we should
                                // just delete the value
                                if (pszValue[0] == '\0')
                                {
                                    res = WszRegDeleteValue(hkSvchost, SZ_SVCGRP_VAL_NAME);
                                }
                                // Otherwise, set the new string value
                                else
                                {
                                    res = WszRegSetValueEx(hkSvchost, SZ_SVCGRP_VAL_NAME, NULL, REG_MULTI_SZ,
                                                           (LPBYTE)pszValue, cbValue);
                                }

                                // Check for failure
                                if (res != ERROR_SUCCESS)
                                {
                                    hr = HRESULT_FROM_WIN32(res);
                                }

                                break;
                            }
                        }
                    }
                }
            }

            RegCloseKey(hkSvchost);
        }
    }

    // Delete the service
    {
        SC_HANDLE   schService;
        SC_HANDLE   schSCManager;

        // Try and open the service
        LPWSTR pszImagePath = SZ_SVCHOST_BINARY_PATH L" -k " SZ_SVC_NAME;

        schSCManager = OpenSCManager(NULL,                   // machine (NULL == local)
                                     NULL,                   // database (NULL == default)
                                     SC_MANAGER_ALL_ACCESS); // access required 
        if (schSCManager)
        {
            schService = OpenService(schSCManager, SZ_SVC_NAME, DELETE | SERVICE_STOP);

            // Service was successfully opened for deletion
            if (schService != NULL)
            {
                SERVICE_STATUS servStatus;
                ControlService(schService, SERVICE_CONTROL_STOP, &servStatus);

                BOOL bRes = DeleteService(schService);

                if (!bRes)
                    hr = HRESULT_FROM_WIN32(GetLastError());

                CloseServiceHandle(schService);
            }

            CloseServiceHandle(schSCManager);
        }

        // Service manager open was unsuccessful
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return (UserDllUnregisterServer());
#endif // 0
}  // DllUnregisterServer


//*****************************************************************************
// Handle lifetime of loaded library.
//*****************************************************************************
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        {
            // Save the module handle.
            g_hThisInst = (HMODULE)hInstance;

            // Init unicode wrappers.
            OnUnicodeSystem();

            // Only report to the service manager when running under WinNT
            bIsRunningOnWinNT = RunningOnWinNT();
            bIsRunningOnWinNT5 = RunningOnWinNT5();
        }
        break;

    case DLL_PROCESS_DETACH:
        {
        }
        break;

    case DLL_THREAD_DETACH:
        {
        }
        break;
    }

    return(UserDllMain(hInstance, dwReason, lpReserved));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsvc\service.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma once

//////////////////////////////////////////////////////////////////////////////
// TODO: change to desired strings
////
// internal name of the service
#define SZ_SVC_NAME             L"CORRTSvc"
// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES          L""
// the name of the group of services this service belongs to
#define SZ_SVCGRP_VAL_NAME      L"CORSvcs"
// the service's display name
#define SZ_SVC_DISPLAY_NAME     L".NET Framework Support Service"
// the string version of the uuid of the service
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// These should not have to change
////
#define SZ_SVCHOST_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost"
#define HK_SVCHOST_ROOT HKEY_LOCAL_MACHINE
#define SZ_SVCHOST_BINARY_PATH L"%WinDIR%\\System32\\svchost.exe"

#define SZ_SERVICES_KEY L"System\\CurrentControlSet\\Services"
#define HK_SERVICES_ROOT HKEY_LOCAL_MACHINE

#define SZ_APPID_KEY L"APPID"
#define HK_APPID_ROOT HKEY_CLASSES_ROOT

#define SZ_CLSID_KEY L"CLSID"
#define HK_CLSID_ROOT HKEY_CLASSES_ROOT
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Is set to true if running on NT
////
extern BOOL bIsRunningOnWinNT;

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
// TODO: You define these functions, which are appropriately called after
//       the generic svchost code is run
////
// Code you need to run for various Dll events in addition to the service
BOOL WINAPI UserDllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved);
// Additional registration code
STDAPI      UserDllRegisterServer(void);     
// Additional unregistration code
STDAPI      UserDllUnregisterServer(void);   

//////////////////////////////////////////////////////////////////////////////
//// TODO: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID ServiceStart(DWORD dwArgc, LPWSTR *lpszArgv);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
void AddToMessageLog(LPWSTR lpszMsg);
void AddToMessageLogHR(LPWSTR lpszMsg, HRESULT hr);
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorveh\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//	stdafx.cpp
//
//	Host for precompiled header.
//
//*****************************************************************************
#include "stdafx.h"						// Precompiled header key.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsvchost\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <wchar.h>

extern "C" void WINAPI ServiceMain(DWORD dwArgc, LPWSTR *lpszArgv);

void __cdecl wmain(int argc, wchar_t **argv)
{
    ServiceMain(argc, argv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsvc\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "mscorsvc.dll"
#define VER_FILEDESCRIPTION_STR ".NET Framework Support Service\0"
#define VER_ORIGFILENAME_STR    "mscorsvc.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorveh\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled header file.
//*****************************************************************************
#pragma once

#include "winwrap.h"                    // Windows wrappers.
#include "utilcode.h"					// Helper code.
#include "VEHandler.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorsvchost\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "mscorsvchost.exe"
#define VER_FILEDESCRIPTION_STR ".NET Framework support service\0"
#define VER_ORIGFILENAME_STR    "mscorsvchost.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorveh\makefile.inc ===
!if "$(LINKONLY)" == "1"

RegisterThisDll: $(CORLIBS)\mscorveh.lib 
	regsvr32 /s /c $(CORLIBS)\mscorveh.dll

!else

RegisterThisDll: 

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorveh\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR    "mscorveh.dll"
#define VER_FILEDESCRIPTION_STR ".NET Runtime verification event handler\0"
#define VER_ORIGFILENAME_STR    "mscorveh.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorveh\vehandler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: VEHandler.h - header file for Verifier Events Handler
//
//*****************************************************************************

#ifndef VEHANDLER_H_
#define VEHANDLER_H_

//#include <winwrap.h>
//#include <Windows.h>

#include <UtilCode.h>
#include <PostError.h>

#ifdef _DEBUG
#define LOGGING
#endif

#include <Log.h>
#include <CorError.h>

#include "cor.h"

#include "cordebug.h"

#include <cordbpriv.h>
//#include <DbgIPCEvents.h>

#include "IVEHandler.h"

#undef ASSERT
#define CRASH(x)  _ASSERTE(!x)
#define ASSERT(x) _ASSERTE(x)
#define PRECONDITION _ASSERTE
#define POSTCONDITION _ASSERTE


/* ------------------------------------------------------------------------- *
 * Forward class declarations
 * ------------------------------------------------------------------------- */

class VEHandlerBase;
class VEHandlerClass;

/* ------------------------------------------------------------------------- *
 * Typedefs
 * ------------------------------------------------------------------------- */

#define COM_METHOD	HRESULT STDMETHODCALLTYPE

typedef void* REMOTE_PTR;
typedef HRESULT (*REPORTFCTN)(LPCWSTR, VEContext, HRESULT);

/* ------------------------------------------------------------------------- *
 * Base class
 * ------------------------------------------------------------------------- */
HRESULT DefltProcTheMessage( // Return status.
    LPCWSTR     szMsg,                  // Error message.
	VEContext	Context,				// Error context (offset,token)
    HRESULT     dwHelpContext);         // HRESULT for the message.

class VEHandlerClass : public IVEHandler
{
public: 
    SIZE_T      m_refCount;
	REPORTFCTN  m_fnReport;

    VEHandlerClass() { m_refCount=0; m_fnReport=DefltProcTheMessage; }
    virtual ~VEHandlerClass() { }

    //-----------------------------------------------------------
    // IUnknown support
    //-----------------------------------------------------------
    ULONG STDMETHODCALLTYPE AddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE Release() 
    {
        long        refCount = InterlockedDecrement((long *) &m_refCount);
        if (refCount == 0) delete this;
        return (refCount);
    }

	COM_METHOD QueryInterface(REFIID id, void **pInterface)
	{
		if (id == IID_IVEHandler)
			*pInterface = (IVEHandler*)this;
		else if (id == IID_IUnknown)
			*pInterface = (IUnknown*)(IVEHandler*)this;
		else
		{
			*pInterface = NULL;
			return E_NOINTERFACE;
		}

		AddRef();
		return S_OK;
	}
    //-----------------------------------------------------------
    // IVEHandler support
    //-----------------------------------------------------------
	COM_METHOD	SetReporterFtn(__int64 lFnPtr);

	COM_METHOD VEHandler(HRESULT VECode, VEContext Context, SAFEARRAY *psa);

    static COM_METHOD CreateObject(REFIID id, void **object)
    {
        if (id != IID_IUnknown && id != IID_IVEHandler)
            return (E_NOINTERFACE);

        VEHandlerClass *veh = new VEHandlerClass();

        if (veh == NULL)
            return (E_OUTOFMEMORY);

        *object = (IVEHandler*)veh;
        veh->AddRef();

        return (S_OK);
    }
};

#endif /* VEHANDLER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\mscorveh\vehandler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// VEHandler.cpp
//
// Dll* routines for entry points, and support for COM framework.  The class
// factory and other routines live in this module.
//
//*****************************************************************************
//#include <crtwrap.h>
#include "stdafx.h"
#include "VEHandler.h"
#include <ivehandler_i.c>

#define REGISTER_CLASS_HERE
#ifdef REGISTER_CLASS_HERE
#include "ClassFactory.h"
#include "Mscoree.h"

// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();

//********** Globals. *********************************************************
static const LPCWSTR g_szCoclassDesc    = L"Common Language Runtime verification event handler";
static const LPCWSTR g_szProgIDPrefix   = L"CLR";
static const LPCWSTR g_szThreadingModel = L"Both";
const int       g_iVersion = 1;         // Version of coclasses.
HINSTANCE       g_hInst;                // Instance handle to this piece of code.

// This map contains the list of coclasses which are exported from this module.
const COCLASS_REGISTER g_CoClasses[] =
{
//  pClsid              szProgID            pfnCreateObject
    &CLSID_VEHandlerClass, L"VEHandler",      VEHandlerClass::CreateObject,     
    NULL,               NULL,               NULL
};


//********** Locals. **********************************************************
STDAPI DllUnregisterServer(void);


//********** Code. ************************************************************


//*****************************************************************************
// The main dll entry point for this module.  This routine is called by the
// OS when the dll gets loaded.  Control is simply deferred to the main code.
//*****************************************************************************
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Save off the instance handle for later use.
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInst = hInstance;

        // Init the Win32 wrappers.
        OnUnicodeSystem();
    }

    return TRUE;
}


//*****************************************************************************
// Register the class factories for the main debug objects in the API.
//*****************************************************************************
STDAPI DllRegisterServer(void)
{
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    WCHAR       rcModule[_MAX_PATH];    // This server's module name.
    HRESULT     hr = S_OK;

    // Init the Win32 wrappers.
    OnUnicodeSystem();

    // Erase all doubt from old entries.
    DllUnregisterServer();

    // Get the filename for this module.
    DWORD ret;
    VERIFY(ret = WszGetModuleFileName(GetModuleInst(), rcModule, NumItems(rcModule)));
    if(!ret)
    	return E_UNEXPECTED;

    // Get the version of the runtime
    WCHAR       rcVersion[_MAX_PATH];
    DWORD       lgth;
    IfFailRet(GetCORSystemDirectory(rcVersion, NumItems(rcVersion), &lgth));

    // For each item in the coclass list, register it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        // Register the class with default values.
        if (FAILED(hr = REGUTIL::RegisterCOMClass(
                *pCoClass->pClsid, 
                g_szCoclassDesc, 
                g_szProgIDPrefix,
                g_iVersion, 
                pCoClass->szProgID, 
                g_szThreadingModel, 
                rcModule,
                GetModuleInst(),
                NULL,
                rcVersion,
                true,
                false)))
        {
            DllUnregisterServer();
            break;
        }
    }
    return (hr);
}


//*****************************************************************************
// Remove registration data from the registry.
//*****************************************************************************
STDAPI DllUnregisterServer(void)
{
    const COCLASS_REGISTER *pCoClass;   // Loop control.

    // For each item in the coclass list, unregister it.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        REGUTIL::UnregisterCOMClass(*pCoClass->pClsid, g_szProgIDPrefix,
                    g_iVersion, pCoClass->szProgID, true);
    }
    return (S_OK);
}


//*****************************************************************************
// Called by COM to get a class factory for a given CLSID.  If it is one we
// support, instantiate a class factory object and prepare for create instance.
//*****************************************************************************
STDAPI DllGetClassObjectInternal(               // Return code.
    REFCLSID    rclsid,                 // The class to desired.
    REFIID      riid,                   // Interface wanted on class factory.
    LPVOID FAR  *ppv)                   // Return interface pointer here.
{
    CClassFactory *pClassFactory;       // To create class factory object.
    const COCLASS_REGISTER *pCoClass;   // Loop control.
    HRESULT     hr = CLASS_E_CLASSNOTAVAILABLE;

    // Scan for the right one.
    for (pCoClass=g_CoClasses;  pCoClass->pClsid;  pCoClass++)
    {
        if (*pCoClass->pClsid == rclsid)
        {
            // Allocate the new factory object.
            pClassFactory = new CClassFactory(pCoClass);
            if (!pClassFactory)
                return (E_OUTOFMEMORY);

            // Pick the v-table based on the caller's request.
            hr = pClassFactory->QueryInterface(riid, ppv);

            // Always release the local reference, if QI failed it will be
            // the only one and the object gets freed.
            pClassFactory->Release();
            break;
        }
    }
    return (hr);
}



//*****************************************************************************
//
//********** Class factory code.
//
//*****************************************************************************


//*****************************************************************************
// QueryInterface is called to pick a v-table on the co-class.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::QueryInterface( 
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;

    // Avoid confusion.
    *ppvObject = NULL;

    // Pick the right v-table based on the IID passed in.
    if (riid == IID_IUnknown)
        *ppvObject = (IUnknown *) this;
    else if (riid == IID_IClassFactory)
        *ppvObject = (IClassFactory *) this;

    // If successful, add a reference for out pointer and return.
    if (*ppvObject)
    {
        hr = S_OK;
        AddRef();
    }
    else
        hr = E_NOINTERFACE;
    return (hr);
}


//*****************************************************************************
// CreateInstance is called to create a new instance of the coclass for which
// this class was created in the first place.  The returned pointer is the
// v-table matching the IID if there.
//*****************************************************************************
HRESULT STDMETHODCALLTYPE CClassFactory::CreateInstance( 
    IUnknown    *pUnkOuter,
    REFIID      riid,
    void        **ppvObject)
{
    HRESULT     hr;

    // Avoid confusion.
    *ppvObject = NULL;
    _ASSERTE(m_pCoClass);

    // Aggregation is not supported by these objects.
    if (pUnkOuter)
        return (CLASS_E_NOAGGREGATION);

    // Ask the object to create an instance of itself, and check the iid.
    hr = (*m_pCoClass->pfnCreateObject)(riid, ppvObject);
    return (hr);
}


HRESULT STDMETHODCALLTYPE CClassFactory::LockServer( 
    BOOL        fLock)
{
    return (S_OK);
}

//*****************************************************************************
// This helper provides access to the instance handle of the loaded image.
//*****************************************************************************
HINSTANCE GetModuleInst()
{
    return g_hInst;
}
#endif //REGISTER_CLASS_HERE

//*****************************************************************************
// Create, fill out and set an error info object.  Note that this does not fill
// out the IID for the error object; that is done elsewhere.
//*****************************************************************************
HRESULT DefltProcTheMessage( // Return status.
    LPCWSTR     szMsg,                  // Error message.
    VEContext   Context,                // Error context (offset,token)
    HRESULT     hrRpt)                  // HRESULT for the message
{
    WCHAR* wzMsg;
#ifdef DO_IT_THE_SOPHISTICATED_WAY
    CComPtr<ICreateErrorInfo> pICreateErr;// Error info creation Iface pointer.
    CComPtr<IErrorInfo> pIErrInfo;      // The IErrorInfo interface.
    HRESULT     hr;                     // Return status.
    DWORD       dwHelpContext;          // Help context.

    // Get the help context from the low word of the HRESULT.
    dwHelpContext = LOWORD(hrRpt);

    // Get the ICreateErrorInfo pointer.
    if (FAILED(hr = CreateErrorInfo(&pICreateErr)))
        return (hr);

    // Set message text description.
    if (FAILED(hr = pICreateErr->SetDescription((LPWSTR) szMsg)))
        return (hr);

    // Set the help file and help context.
//@todo: we don't have a help file yet.
    if (FAILED(hr = pICreateErr->SetHelpFile(L"complib.hlp")) ||
        FAILED(hr = pICreateErr->SetHelpContext(dwHelpContext)))
        return (hr);

    // Get the IErrorInfo pointer.
    if (FAILED(hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PVOID *) &pIErrInfo)))
        return (hr);

    // Save the error and release our local pointers.
    SetErrorInfo(0L, pIErrInfo);
    return (S_OK);
#else
    if(szMsg)
    {
        wzMsg = new WCHAR[lstrlenW(szMsg)+256];
        lstrcpyW(wzMsg,szMsg);
        // include token and offset from Context
        if(Context.Token) swprintf(&wzMsg[lstrlenW(wzMsg)],L" [token:0x%08X]",Context.Token);
        if(Context.uOffset) swprintf(&wzMsg[lstrlenW(wzMsg)],L" [at:0x%X]",Context.uOffset);
        swprintf(&wzMsg[lstrlenW(wzMsg)],L" [hr:0x%08X]",hrRpt);
        wprintf(L"%s\n", wzMsg);
    }
    return S_OK;
#endif
}

COM_METHOD  VEHandlerClass::SetReporterFtn(__int64 lFnPtr)
{
    m_fnReport = lFnPtr ? reinterpret_cast<REPORTFCTN>(lFnPtr) 
                         : DefltProcTheMessage;
    return S_OK;
}

//*****************************************************************************
// The Verification Event Handler itself. Declared in VEHandler.h as virtual, may be overridden
//*****************************************************************************
COM_METHOD VEHandlerClass::VEHandler(HRESULT hrRpt,
                                 VEContext Context,
                                 SAFEARRAY *psa)
{
// The following code is copied from Utilcode\PostError.cpp with minor additions
    WCHAR       rcBuf[1024];             // Resource string.
    WCHAR       rcMsg[1024];             // Error message.
    va_list     marker,pval;             // User text.
    HRESULT     hr;
    VARIANT     *pVar,Var;
    ULONG       nVars,i,lVar,j,l,k;
    WCHAR       *pWsz[1024], *pwsz; // is more than 1024 string arguments likely?

    // Return warnings without text.
    if (!FAILED(hrRpt))
        return (hrRpt);
    memset(pWsz,0,sizeof(pWsz));
    // Convert safearray of variants into va_list
    if(psa && (nVars = psa->rgsabound[0].cElements))
    {
        _ASSERTE(psa->fFeatures & FADF_VARIANT);
        _ASSERTE(psa->cDims == 1);
        marker = (va_list)(new char[nVars*sizeof(double)]); // double being the largest variant element
        for(i=0,pVar=(VARIANT *)(psa->pvData),pval=marker; i < nVars; pVar++,i++)
        {
            memcpy(&Var,pVar,sizeof(VARIANT));
            switch(Var.vt)
            {
                case VT_I1:
                case VT_UI1:    lVar = 1; break;

                case VT_I2:
                case VT_UI2:    lVar = 2; break;

                case VT_R8:
                case VT_CY:
                case VT_DATE:   lVar = 8; break;

                case VT_BYREF|VT_I1:
                case VT_BYREF|VT_UI1: // it's ASCII string, convert it to UNICODE
                    lVar = 4;
                    l = strlen((char *)(Var.pbVal))+1;
                    pwsz = new WCHAR[l];
                    for(j=0; j<l; j++) pwsz[j] = Var.pbVal[j];
                    for(k=0; pWsz[k]; k++);
                    pWsz[k] = pwsz;
                    Var.piVal = (short *)pwsz;
                    break;

                default:        lVar = 4; break;
            }
            memcpy(pval,&(Var.bVal),lVar);
            pval += (lVar + sizeof(int) - 1) & ~(sizeof(int) - 1); //From STDARG.H: #define _INTSIZEOF(n)
        }
    }
    else
        marker = NULL;

    // If this is one of our errors, then grab the error from the rc file.
    if (HRESULT_FACILITY(hrRpt) == FACILITY_URT)
    {
        hr = LoadStringRC(LOWORD(hrRpt), rcBuf, NumItems(rcBuf), true);
        if (hr == S_OK)
        {
            // Format the error.
            _vsnwprintf(rcMsg, NumItems(rcMsg), rcBuf, marker);
            rcMsg[NumItems(rcMsg) - 1] = 0;
        }
    }
    // Otherwise it isn't one of ours, so we need to see if the system can
    // find the text for it.
    else
    {
        if (WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                0, hrRpt, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                rcMsg, NumItems(rcMsg), 0))
        {
            hr = S_OK;

            // System messages contain a trailing \r\n, which we don't want normally.
            int iLen = lstrlenW(rcMsg);
            if (iLen > 3 && rcMsg[iLen - 2] == '\r' && rcMsg[iLen - 1] == '\n')
                rcMsg[iLen - 2] = '\0';
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    if(marker) delete marker;

    // If we failed to find the message anywhere, then issue a hard coded message.
    if (FAILED(hr))
    {
        swprintf(rcMsg, L"Internal error: 0x%08x", hrRpt);
        DEBUG_STMT(DbgWriteEx(rcMsg));
    }

    // delete WCHAR buffers allocated above (if any)
    for(k=0; pWsz[k]; k++) delete pWsz[k];

#ifdef DO_IT_THE_SOPHISTICATED_WAY
    long        *pcRef;                 // Ref count in tls.
    // Check for an old message and clear it.  Our public entry points do not do
    // a SetErrorInfo(0, 0) because it takes too long.
    IErrorInfo  *pIErrInfo;
    if (GetErrorInfo(0, &pIErrInfo) == S_OK)
        pIErrInfo->Release();
    // Turn the error into a posted error message.  If this fails, we still
    // return the original error message since a message caused by our error
    // handling system isn't going to give you a clue about the original error.
    VERIFY((hr = FillErrorInfoMy(rcMsg, LOWORD(hrRpt))) == S_OK);

    // Indicate in tls that an error occured.
    if ((pcRef = (long *) TlsGetValue(g_iTlsIndex)) != 0)
        *pcRef |= 0x80000000;
    return (hrRpt);
#else
    return (m_fnReport(rcMsg, Context,hrRpt) == S_OK ? S_OK : E_FAIL);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\corshim.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//========================================================================
// More convenient names for integer types of a guaranteed size.
//========================================================================

#ifndef _CORSHIM_H_
#define _CORSHIM_H_

typedef unsigned __int64 UINT64;
typedef __int64 INT64;

#ifndef _BASETSD_H_
typedef unsigned __int32 UINT32;
typedef unsigned __int16 UINT16;
typedef unsigned __int8  UINT8;
typedef __int32 INT32;
typedef __int16 INT16;
typedef __int8  INT8;
#endif

typedef struct ModuleList {
	HINSTANCE hMod;
	ModuleList *Next;

	ModuleList(HINSTANCE h, ModuleList *n)
	{
		hMod = h;
		Next = n;
	}

}ModuleList;

HINSTANCE LoadLibraryWrapper(LPCWSTR lpFileName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

#define _CRTIMP 
#include <winwrap.h>                    // Windows wrappers.
#include <utilcode.h>

#include <ole2.h>						// OLE definitions
#include "oledb.h"						// OLE DB headers.
#include "oledberr.h"					// OLE DB Error messages.
#include "msdadc.h"						// Data type conversion service.

#define _COMPLIB_GUIDS_


#define _WIN32_WINNT 0x0400
#define _ATL_FREE_THREADED
#undef _WINGDI_


#include "Intrinsic.h"					// Functions to make intrinsic.


// Helper function returns the instance handle of this module.
HINSTANCE GetModuleInst();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\makefile.inc ===
!if "$(OS)" == "Windows_NT"
SYSTEMDIR=$(WINDIR)\system32
!else
SYSTEMDIR=$(WINDIR)\system
!endif

MSCOREE_TARGET=$(SYSTEMDIR)\mscoree.dll

!if "$(TARGETCOMPLUS)" != ""
SYM_TARGET1=$(TARGETCOMPLUS)\symwrtr.dll
SYM_TARGET2=$(TARGETCOMPLUS)\diasymreader.dll
SYM_TARGET3=$(TARGETCOMPLUS)\msdia70.dll
SYM_TARGET4=$(TARGETCOMPLUS)\mscoree.tlb
!else
SYM_TARGET1=$(CORENV)\bin\i386\symwrtr.dll
SYM_TARGET2=$(CORENV)\bin\i386\diasymreader.dll
SYM_TARGET3=$(CORENV)\bin\i386\msdia70.dll
SYM_TARGET4=$(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscoree.tlb
!endif

!if "$(LINKONLY)" == "1"

PlaceDll:
!if "$(TARGETCOMPLUS)" != ""
        binplace -e -r $(SYSTEMDIR) -p placefil.txt $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscoree.dll $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscoree.pdb
!endif

RegisterThisDll: $(MSCOREE_TARGET)
        regsvr32 /s /c $(MSCOREE_TARGET)
        regsvr32 /s /c $(SYM_TARGET1)
        regsvr32 /s /c $(SYM_TARGET2)
        regsvr32 /s /c $(SYM_TARGET3)
                regtlb $(SYM_TARGET4)

!if "$(TARGETCOMPLUS)" != ""
        -mkdir $(TARGETCOMPLUS)\sdk\lib
        copy $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscoree.lib $(TARGETCOMPLUS)\sdk\lib
!endif

CopyAdditionalBits:
        copy /y $(TARGETPATH)\mscorrc.reg $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)
        copy /y $(TARGETPATH)\mscorrc.reg $(TARGETCOMPLUS)
	copy /y UpgradePolicy.vrg $(TARGETCOMPLUS)
!else

PlaceDll:
RegisterThisDll:
CopyAdditionalBits:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\shimpolicy.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// ShimPolicy.cpp
// 
//*****************************************************************************
//
// Uses policy in registry to determine which installed version to load.
//

#include "stdafx.h"
#include "shimpolicy.h"

HRESULT Version::ToString(LPWSTR buffer,
                          DWORD length)
{
    WCHAR number[20];
    DWORD index = 0;
    *buffer = L'\0';
    for(DWORD i = 0; i < VERSION_SIZE; i++) {
        LPWSTR ptr = Wszltow((LONG) m_Number[i], number, 10);
        if(i != 0 &&
           index + 1 < length) {
            wcscat(buffer, L".");
            index += 1;
        }

        DWORD size = wcslen(ptr) + 1;
        if(index + size < length) {
            wcscat(buffer, ptr);
            index += size;
        }
        else 
            return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    return S_OK;
}

HRESULT Version::SetVersionNumber(LPCWSTR stringValue,
                                  DWORD* number)
{
     
    HRESULT hr = S_OK;

    if(stringValue == NULL)
        return E_POINTER;

    DWORD length = wcslen(stringValue);
    // 256 digits is more then enough. If there are that many then
    // we were feed a bad policy
    if(length > MAX_PATH) return HRESULT_FROM_WIN32(ERROR_BAD_LENGTH);


    // Copy off the string because we are modifing it.
    WCHAR* buffer = (WCHAR*) alloca((length+1) * sizeof(WCHAR));
    wcscpy(buffer, stringValue);

    DWORD numberIndex = 0;
    WCHAR* pSeparator = buffer;
    WCHAR* pNumber;
    for (DWORD j = 0; j < VERSION_SIZE;  j++)
    {
        pNumber = pSeparator;
        pSeparator = wcschr(pNumber, L'.');
        if(pSeparator == NULL) {
            if(j != VERSION_SIZE - 1) return E_FAIL;
        }
        else {
            *pSeparator++ = L'\0';
        }

        // Invalid numbers are going to be zero. Not
        // great.
        hr = SetIndex(numberIndex, (WORD) _wtoi(pNumber));
        if(FAILED(hr)) return hr;
        numberIndex += 1;
    }

    if(number != NULL) *number = numberIndex;
    return hr;

}

// dwPolicyMapping must be the complete size of the data from the registry.
HRESULT VersionPolicy::AddToVersionPolicy(LPCWSTR wszPolicyBuildNumber, 
                                          LPCWSTR wszPolicyMapping, 
                                          DWORD  dwPolicyMapping)
{
    if(dwPolicyMapping == 0 ||
       wszPolicyMapping == NULL ||
       wszPolicyBuildNumber ==  NULL)
        return E_FAIL;

    DWORD sln = wcslen(wszPolicyBuildNumber);
    Version version;
    Version startVersion;
    Version endVersion;

    DWORD returnedValues;
    HRESULT hr = version.SetVersionNumber(wszPolicyBuildNumber,
                                          &returnedValues);
    if(SUCCEEDED(hr) && returnedValues != VERSION_SIZE) 
        return E_FAIL;
    IfFailRet(hr);
    
    VersionNode* pNode = new VersionNode(version);
    if(pNode == NULL) {
        hr = E_OUTOFMEMORY;
        IfFailGo(hr);
    }

    // Setup the buffer and make sure we are terminated.
    WCHAR* buffer = (WCHAR*) alloca((dwPolicyMapping+1) * sizeof(WCHAR));
    wcsncpy(buffer, wszPolicyMapping, dwPolicyMapping);
    buffer[dwPolicyMapping] = L'\0';

    // Check to see if the policy contains a range by searching for '-'
    WCHAR* range = wcschr(buffer, L'-');
    if(range != NULL) {
        *range++ = L'\0';
        hr = endVersion.SetVersionNumber(range,
                                         &returnedValues);
        if(SUCCEEDED(hr) && returnedValues != VERSION_SIZE) 
            hr = E_FAIL;
        IfFailGo(hr);
        

        pNode->SetEnd(endVersion);
    }        
     
    hr = startVersion.SetVersionNumber(buffer,
                                       &returnedValues);
    if(SUCCEEDED(hr) && returnedValues != VERSION_SIZE) 
        hr = E_FAIL;
    IfFailGo(hr);
    
    pNode->SetStart(startVersion);
 ErrExit:
    if(SUCCEEDED(hr)) 
        AddVersion(pNode);
    else if(pNode)
        delete pNode;

    return hr;
}

HRESULT VersionPolicy::BuildPolicy(HKEY hKey)
{
    DWORD type;
    HKEY userKey = NULL;
    
    //
    // If version not found, enumerate Values under the key and apply correct policy
    // Query Registry to get max lengths for values under userKey
    //
    DWORD numValues, maxValueNameLength, maxValueDataLength;
    if((WszRegQueryInfoKey(hKey, 
                           NULL, NULL, NULL, 
                           NULL, NULL, NULL, 
                           &numValues, 
                           &maxValueNameLength, 
                           &maxValueDataLength, 
                           NULL, NULL)  == ERROR_SUCCESS))
    {
        LPWSTR wszValueName = (WCHAR*) alloca(sizeof(WCHAR) * (maxValueNameLength + 1));
        LPWSTR wszValueData = (WCHAR*) alloca(sizeof(WCHAR) * (maxValueDataLength + 1));
            
        //
        // Enumerate Values under hKey and add policy info after sorting buildnumbers
        // in decending order
        //
        for(unsigned int i = 0;  i < numValues; i++)
        {
            
            DWORD valueNameLength = maxValueNameLength + 1;
            // valueDataLength needs to be the size in bytes of the buffer.
            DWORD valueDataLength = (maxValueDataLength + 1)*sizeof(WCHAR);
            if((WszRegEnumValue(hKey, 
                                numValues - i - 1, 
                                wszValueName, 
                                &valueNameLength, 
                                NULL, 
                                &type,
                                (BYTE*)wszValueData, 
                                &valueDataLength) == ERROR_SUCCESS) &&
               type == REG_SZ && valueDataLength > 0)
            {
                AddToVersionPolicy(wszValueName, 
                                   wszValueData, 
                                   valueDataLength); // Ignore bad values
            }
        }
    }
    return S_OK;
}

// Returns: S_OK if it found the version in the registry or E_FAIL
//          if it does not exist
HRESULT VersionPolicy::InstallationExists(LPCWSTR version)
{
    HRESULT hr = E_FAIL;
    Version v;
    DWORD fields;
    v.SetVersionNumber(version,
                       &fields);
    if(fields != VERSION_SIZE)
        return hr;

    VersionNode  sMatch(v);
    VersionNode* pValue;
    for(pValue = m_pList; pValue != NULL; pValue = pValue->m_next)
    {
        if(pValue->CompareVersion(&sMatch) == 0)
            return S_OK;
    }
    return hr;
}

// Returns: S_OK if it found a version, S_FALSE if no policy matched
//          or an error.
HRESULT VersionPolicy::ApplyPolicy(LPCWSTR wszRequestedVersion,
                                   LPWSTR* pwszVersion)
{

    if(wszRequestedVersion == NULL) return E_FAIL;

    // Remove any non numeric headers like 'v'.
    while(*wszRequestedVersion != NULL && !iswdigit(*wszRequestedVersion))
        wszRequestedVersion++;

    DWORD fields = 0;
    Version v;
    HRESULT hr = v.SetVersionNumber(wszRequestedVersion,
                                    &fields);
    if(FAILED(hr)) return hr;
    
    VersionNode* pValue;
    VersionNode* pMatch = NULL;
    for(pValue = m_pList; pValue != NULL; pValue = pValue->m_next)
    {
        // If there is a range then see if it is within the range.
        // The upper and lower numbers are part of the range.
        if(pValue->HasEnding()) {
            if(pValue->CompareStart(&v) >= 0 &&
               pValue->CompareEnd(&v) <= 0)
            {
                pMatch = pValue;
                break;
            }
        }
        // If it is an exact match then just compare the start
        else if(pValue->CompareStart(&v) == 0)
        {
            pMatch = pValue;
            break;
        }
    }

    if(pMatch) {
        DWORD dwVersion =  VERSION_TEXT_SIZE + 1; // add in the initial v
        WCHAR* result = new WCHAR[dwVersion]; 
        *result = L'v';
        hr = pMatch->ToString(result+1,
                              dwVersion);
        if(SUCCEEDED(hr)) {
            *pwszVersion = result;
        }
    }
    else 
        hr = S_FALSE;
    
    return hr;

}
#ifdef _DEBUG
HRESULT VersionPolicy::Dump()
{
    HRESULT hr = S_OK;
    VersionNode* ptr = m_pList;
    while(ptr != NULL) {
        WCHAR value[VERSION_TEXT_SIZE];
        
        hr = ptr->m_Version.ToString(value, VERSION_TEXT_SIZE);
        if(FAILED(hr)) return hr;
        wprintf(L"Version: %s = ", value);

        hr = ptr->m_Start.ToString(value, VERSION_TEXT_SIZE);
        if(FAILED(hr)) return hr;
        wprintf(L"%s", value);
        if(ptr->HasEnding()) {
            hr = ptr->m_End.ToString(value, VERSION_TEXT_SIZE);
            if(FAILED(hr)) return hr;

            wprintf(L" - %s\n", value);
        }
        else
            wprintf(L"\n");

        ptr = ptr->m_next;
    }            
    return hr;
}
#endif

HRESULT FindStandardVersionByKey(HKEY hKey,
                                 LPCWSTR pwszRequestedVersion,
                                 LPWSTR *pwszVersion)
{
    HRESULT hr = E_FAIL;
    LPWSTR ret = NULL;
    DWORD type;
    HKEY userKey = NULL;
    
    if ((WszRegOpenKeyEx(hKey, pwszRequestedVersion, 0, KEY_READ, 
                         &userKey) == ERROR_SUCCESS))
    {
        //
        // find the first one
        //
        DWORD numValues, maxValueNameLength, maxValueDataLength;
        if((WszRegQueryInfoKey(userKey, 
                               NULL, NULL, NULL, 
                               NULL, NULL, NULL, 
                               &numValues, 
                               &maxValueNameLength, 
                               &maxValueDataLength, 
                               NULL, NULL)  == ERROR_SUCCESS))
        {
            LPWSTR wszValueName = (WCHAR*) alloca(sizeof(WCHAR) * (maxValueNameLength + 1));
            LPWSTR wszHighestName = (WCHAR*) alloca(sizeof(WCHAR) * (maxValueNameLength + 1));
            DWORD  dwHighestLength = 0;
            
            DWORD  dwValueData = 0;
            DWORD level = 0;
            for(unsigned int i = 0;  i < numValues; i++)
            {
                DWORD valueNameLength = maxValueNameLength + 1;
                DWORD dwValueDataSize = sizeof(DWORD);
                if((WszRegEnumValue(userKey, 
                                    numValues - i - 1, 
                                    wszValueName, 
                                    &valueNameLength, 
                                    NULL, 
                                    &type,
                                    (BYTE*)&dwValueData, 
                                    &dwValueDataSize) == ERROR_SUCCESS) &&
                   type == REG_DWORD && dwValueData > level && valueNameLength > 0)
                {
                    level = dwValueData;
                    dwHighestLength = valueNameLength;
                    wcsncpy(wszHighestName, wszValueName, dwHighestLength);
                    wszHighestName[dwHighestLength] = L'\0';
                }
            }

            if(dwHighestLength != 0) {
                WCHAR* result = new WCHAR[dwHighestLength + 1];
                wcsncpy(result, wszHighestName, dwHighestLength);
                result[dwHighestLength] = L'\0';
                *pwszVersion = result;
                hr =  S_OK;
            }
                
        }
        RegCloseKey(userKey);
    }
    return hr;
}
//
// This function searches for "\\Software\\Microsoft\\.NETFramework\\Policy\\Standards"
// which is a global override
//
HRESULT FindStandardVersionValue(HKEY hKey, 
                                 LPCWSTR pwszRequestedVersion,
                                 LPWSTR *pwszVersion)
{
    HKEY userKey=NULL;
    LPWSTR ret = NULL;
    HRESULT lResult = E_FAIL;
    
    if ((WszRegOpenKeyEx(hKey, SHIM_STANDARDS_REGISTRY_KEY, 0, KEY_READ, &userKey) == ERROR_SUCCESS))
    {
        lResult = FindStandardVersionByKey(userKey,
                                           pwszRequestedVersion,
                                           pwszVersion);
        RegCloseKey(userKey);
    }
    
    return lResult;
}

HRESULT FindStandardVersion(LPCWSTR wszRequiredVersion,
                            LPWSTR* pwszPolicyVersion)
{
    if(SUCCEEDED(FindStandardVersionValue(HKEY_CURRENT_USER, 
                                          wszRequiredVersion,
                                          pwszPolicyVersion)))
        return S_OK;

    if(SUCCEEDED(FindStandardVersionValue(HKEY_LOCAL_MACHINE, 
                                          wszRequiredVersion,
                                          pwszPolicyVersion)))
        return S_OK;

    return E_FAIL;
}


HRESULT FindOverrideVersionByKey(HKEY userKey,
                                 LPWSTR *pwszVersion)
{
    HRESULT hr = E_FAIL;
    LPWSTR ret = NULL;
    DWORD size;
    DWORD type;

    if((WszRegQueryValueEx(userKey, L"Version", 0, &type, 0, &size) == ERROR_SUCCESS) &&
       type == REG_SZ && size > 0) 
    {
        //
        //  This means the version override was found. 
        //  Immediately return the version without probing further.
        //
        ret = new WCHAR [size + 1];
        LONG lResult = WszRegQueryValueEx(userKey, L"Version", 0, 0, (LPBYTE) ret, &size);
        _ASSERTE(lResult == ERROR_SUCCESS);
        *pwszVersion = ret;
        hr = S_OK;
    }

    return hr;
}

                            
HRESULT FindMajorMinorNode(HKEY key,
                           LPCWSTR wszMajorMinor, 
                           DWORD majorMinorLength, 
                           LPWSTR *overrideVersion)
{
    HRESULT lResult;
    int cmp = -1;
    HKEY userKey=NULL;

    //
    // Not Cached look in the registry
    //
    DWORD keylength = majorMinorLength                + // for MajorMinor
                      SHIM_POLICY_REGISTRY_KEY_LENGTH + // for "S\M\COMPlus\Policy"
                      1;                                // for \0

    LPWSTR wszMajorMinorRegKey = (WCHAR*) alloca(sizeof(WCHAR) * (keylength + 1));

    // Construct the string for opening registry key.
    wcscpy(wszMajorMinorRegKey, SHIM_POLICY_REGISTRY_KEY);
    wcscat(wszMajorMinorRegKey, wszMajorMinor);

    //
    // Try to open key "\\Software\\Microsoft\\.NETFramework\\Policy\\Major.Minor" 
    //
    if ((WszRegOpenKeyEx(key, wszMajorMinorRegKey, 0, KEY_READ, &userKey) == ERROR_SUCCESS)) {
        lResult = FindOverrideVersionByKey(userKey, overrideVersion);   
        RegCloseKey(userKey);
    }
    else
        lResult = E_FAIL;

    return lResult;
}

//
// This function searches for "\\Software\\Microsoft\\.NETFramework\\Policy\\Version
// which is a global override
//

HRESULT FindOverrideVersionValue(HKEY hKey, 
                                 LPWSTR *pwszVersion)
{
    HKEY userKey=NULL;
    LPWSTR ret = NULL;
    HRESULT lResult = E_FAIL;
    
    if ((WszRegOpenKeyEx(hKey, SHIM_POLICY_REGISTRY_KEY, 0, KEY_READ, &userKey) == ERROR_SUCCESS))
    {
        lResult = FindOverrideVersionByKey(userKey,
                                           pwszVersion);
        RegCloseKey(userKey);
    }
    
    return lResult;
}

HRESULT FindOverrideVersion(LPCWSTR wszRequiredVersion,
                            LPWSTR* pwszPolicyVersion)
{
    // 1) check the policy key to see if there is an override of the form "version"="v1.x86chk" 
    
    if(SUCCEEDED(FindOverrideVersionValue(HKEY_CURRENT_USER, pwszPolicyVersion)))
        return S_OK;

    if(SUCCEEDED(FindOverrideVersionValue(HKEY_LOCAL_MACHINE, pwszPolicyVersion)))
        return S_OK;

    // 2) check the version subdirectories to see if there is an override of the form "version"="v1.x86chk" 
    // Find out if we have policy override for a specific Major.Minor version of the runtime
    // Split Version into Major.Minor and Build.Revision
    HRESULT hr = E_FAIL;
    LPWSTR overrideVersion = NULL;

    LPWSTR pSep = wcschr(wszRequiredVersion, L'.');
    if (!pSep) return hr;
    
    pSep = wcschr(pSep + 1, L'.');
    if(!pSep) return hr;
        
    _ASSERTE(pSep > wszRequiredVersion);
    
    DWORD length = pSep - wszRequiredVersion;
    LPWSTR wszMajorMinor = (WCHAR*)_alloca(sizeof(WCHAR) * (length + 2));

    // For legacy reasons we always have a v at the front of the requested
    // version. The ECMA standard key (1.0.0) does not have the v and we 
    // need to put one on.
    if(*wszRequiredVersion == L'v' || *wszRequiredVersion == L'V') {
        wcsncpy(wszMajorMinor, wszRequiredVersion, length);
    }
    else {
        wcscpy(wszMajorMinor, L"v");
        wcsncat(wszMajorMinor, wszRequiredVersion, length);
        length += 1;
    }
    wszMajorMinor[length] = L'\0';


    // Legacy lookup in the key based on the major and minor number.
    if(SUCCEEDED(FindMajorMinorNode(HKEY_CURRENT_USER, 
                                    wszMajorMinor, 
                                    length, 
                                    &overrideVersion)) &&
       overrideVersion != NULL) 
    {
        hr = S_OK;
        *pwszPolicyVersion = overrideVersion;
    }
    else {
        if(SUCCEEDED(FindMajorMinorNode(HKEY_LOCAL_MACHINE, 
                                        wszMajorMinor, 
                                        length, 
                                        &overrideVersion)) &&
           overrideVersion != NULL) {
            hr = S_OK;
            *pwszPolicyVersion = overrideVersion;
        }
    }
    
    return hr;
}


HRESULT FindInstallationInRegistry(HKEY hKey,
                                   LPCWSTR wszRequestedVersion)
{
    HRESULT hr = E_FAIL;
    HKEY userKey;
    VersionPolicy policy;

    if ((WszRegOpenKeyEx(hKey, SHIM_UPGRADE_REGISTRY_KEY, 0, KEY_READ, &userKey) == ERROR_SUCCESS))
    {
        hr = policy.BuildPolicy(userKey);
        if(SUCCEEDED(hr)) {
            hr = policy.InstallationExists(wszRequestedVersion);
        }
        RegCloseKey(userKey);
    }

    return hr;
}
                                   
HRESULT FindVersionFromPolicy(HKEY hKey, 
                              LPCWSTR wszRequestedVersion,
                              LPWSTR* pwszPolicyVersion)
{
    HRESULT hr = E_FAIL;
    HKEY userKey;
    VersionPolicy policy;

    if ((WszRegOpenKeyEx(hKey, SHIM_UPGRADE_REGISTRY_KEY, 0, KEY_READ, &userKey) == ERROR_SUCCESS))
    {
        hr = policy.BuildPolicy(userKey);
        if(SUCCEEDED(hr)) {
            hr = policy.ApplyPolicy(wszRequestedVersion,
                                    pwszPolicyVersion);
        }
        RegCloseKey(userKey);
    }

    return hr;
}

// Returns S_OK: if the requested Version will result in a version being found.
//               If the answer should include policy overrides and standards
//               then fUsePolicy should be true.
HRESULT FindInstallation(LPCWSTR wszRequestedVersion, BOOL fUsePolicy)
{
    _ASSERTE(!"You are probably not going to get what you expect");
    
    HKEY machineKey = NULL;
    HRESULT hr = E_FAIL;
    _ASSERTE(wszRequestedVersion);

    if(fUsePolicy) {
        LPWSTR wszPolicyVersion = NULL;
        hr = FindVersionUsingPolicy(wszRequestedVersion, &wszPolicyVersion);
        if(wszPolicyVersion != NULL) {
            delete [] wszPolicyVersion;
            hr = S_OK;
        }
        return hr;
    }

    // Was the request upgraded.
    if(FindInstallationInRegistry(HKEY_CURRENT_USER,
                                  wszRequestedVersion) != S_OK)
        hr = FindInstallationInRegistry(HKEY_LOCAL_MACHINE,
                                        wszRequestedVersion);
    
    return hr;
}

LPWSTR GetConfigString(LPCWSTR name, BOOL fSearchRegistry);

HRESULT IsRuntimeVersionInstalled(LPCWSTR wszRequestedVersion)
{
    LPWSTR rootPath = GetConfigString(L"InstallRoot", true);
    if(!rootPath) return S_FALSE;

    WCHAR path[_MAX_PATH+1];
    WCHAR thedll[]=L"\\mscorwks.dll";
    DWORD dwRoot = wcslen(rootPath);
    if (wszRequestedVersion &&
        dwRoot + wcslen(wszRequestedVersion) + wcslen(thedll) < _MAX_PATH) 
    {
        wcscpy(path, rootPath);
        if(rootPath[dwRoot-1] != L'\\')
            wcscat(path, L"\\");
        wcscat(path, wszRequestedVersion);
        wcscat(path, thedll);
    }
    else
    {
        delete[] rootPath;
        return S_FALSE;
    }


    HRESULT hr=S_FALSE;
    WIN32_FIND_DATA data;
    HANDLE find = WszFindFirstFile(path, &data);
    if (find != INVALID_HANDLE_VALUE)
    {
        hr=S_OK;
        FindClose(find);
        delete[] rootPath;
        return S_OK;
    };
    delete[] rootPath;
    return S_FALSE;
}


HRESULT FindVersionUsingUpgradePolicy(LPCWSTR wszRequestedVersion, 
                                                LPWSTR* pwszPolicyVersion)
{
    HRESULT hr = S_OK;

    hr = FindVersionFromPolicy(HKEY_CURRENT_USER,
                                                wszRequestedVersion,
                                                pwszPolicyVersion);

    if (S_OK != hr)
        hr = FindVersionFromPolicy(HKEY_LOCAL_MACHINE,
                                                 wszRequestedVersion,
                                                 pwszPolicyVersion);

    return hr;
}// FindVersionUsingUpgradePolicy
                                                

HRESULT FindVersionUsingPolicy(LPCWSTR wszRequestedVersion, 
                                                LPWSTR* pwszPolicyVersion)
{
    HKEY machineKey = NULL;
    HRESULT hr = S_FALSE;
    _ASSERTE(wszRequestedVersion);

    if(SUCCEEDED(FindOverrideVersion(wszRequestedVersion, pwszPolicyVersion))) {
        return S_OK;
    }
    else {
        LPWSTR wszStandard = NULL;
        // Next, is the request a standard? When the string matches a standard
        // we simply substitue the standard for the request. This has the side
        // effect of making any string a standard if it is placed in the standard
        // table.
        if(FAILED(FindStandardVersion(wszRequestedVersion,
                                      &wszStandard)) &&
           wszStandard != NULL) {
            delete wszStandard;
            wszStandard = NULL;
        }
        
        // Found a standard so it now is the request.
        if(wszStandard != NULL)
            wszRequestedVersion = wszStandard;

        
        // Was the request upgraded.
        if(FindVersionFromPolicy(HKEY_CURRENT_USER,
                                                wszRequestedVersion,
                                                pwszPolicyVersion) != S_OK)
                hr = FindVersionFromPolicy(HKEY_LOCAL_MACHINE,
                                                        wszRequestedVersion,
                                                        pwszPolicyVersion);

        // If we did not find a policy to upgrade it and we have a standard
        // just use the standard. If we do not use it then delete it.
        if(*pwszPolicyVersion == NULL && wszStandard != NULL) {
            *pwszPolicyVersion = wszStandard;
            hr = S_OK;
        }
        else if(wszStandard != NULL)
            delete wszStandard;
        
        // If we did not get an answer then return failure.
        if(*pwszPolicyVersion == NULL)
            hr = E_FAIL;
        
#ifdef _DEBUG
    //if(SUCCEEDED(hr)) policy.Dump();
#endif

    }

    return hr;
}


HRESULT BuildMajorMinorStack(HKEY policyHive, VersionStack* pStack)
{
    _ASSERTE(pStack);
    HRESULT hr = S_OK;
    
    // 
    // Query Registry to get max length for values under userKey
    //
    DWORD numSubKeys, maxKeyLength;
    if((WszRegQueryInfoKey(policyHive, 
                           NULL, NULL, NULL, 
                           &numSubKeys, &maxKeyLength, 
                           NULL, NULL, NULL,
                           NULL, NULL, NULL) == ERROR_SUCCESS))
    {
        LPWSTR wszKeyName = (WCHAR*) alloca(sizeof(WCHAR) * (maxKeyLength + 1));
        //
        // Enumerate Keys under Policy and add Major.Minor in decending order
        // in decending order
        //
        for(unsigned int j = 0;  j < numSubKeys; j++)
        {
            DWORD keyLength = maxKeyLength + 1;
            FILETIME fileTime;
            
            if((WszRegEnumKeyEx(policyHive, numSubKeys - j - 1, 
                                wszKeyName, 
                                &keyLength, 
                                NULL, NULL, NULL,
                                &fileTime) == ERROR_SUCCESS) &&
               keyLength > 0)
            {
                LPWSTR name = new WCHAR[keyLength+1];
                if(name == NULL) return E_OUTOFMEMORY;
                wcsncpy(name, wszKeyName, keyLength);
                name[keyLength] = L'\0';
                pStack->AddVersion(name);
            }   
        }
    }

    return hr;
}
    
HRESULT FindLatestBuild(HKEY hKey, LPWSTR keyName, LPWSTR* pwszLatestVersion)
{
    HRESULT hr = S_OK;
    WCHAR* wszMaxValueName = NULL;
    DWORD  dwMaxValueName = 0;
    int    MaxValue = 0;

    DWORD numValues, maxValueNameLength, maxValueDataLength;
    if((WszRegQueryInfoKey(hKey, 
                           NULL, NULL, NULL, 
                           NULL, NULL, NULL, 
                           &numValues, 
                           &maxValueNameLength, 
                           &maxValueDataLength, 
                           NULL, NULL)  == ERROR_SUCCESS))
    {
        WCHAR* wszValueName = (WCHAR*) alloca(sizeof(WCHAR) * (maxValueNameLength + 1));

        wszMaxValueName = (WCHAR*) alloca(sizeof(WCHAR) * (maxValueNameLength + 1));
        wszMaxValueName[0] = L'\0';
        
        for(unsigned int i = 0;  i < numValues; i++)
        {
            DWORD valueNameLength = maxValueNameLength + 1;
            DWORD cbData = _MAX_PATH;
            BYTE  pbData[_MAX_PATH*3];
            if((WszRegEnumValue(hKey, 
                                numValues - i - 1, 
                                wszValueName, 
                                &valueNameLength, 
                                NULL, 
                                NULL,
                                pbData, 
                                &cbData) == ERROR_SUCCESS) &&
               valueNameLength > 0)
            {
                
                wszValueName[valueNameLength] = L'\0';
                int i = _wtoi(wszValueName);
                if(i > MaxValue) {
                    MaxValue = i;
                    wcsncpy(wszMaxValueName, wszValueName, valueNameLength);
                    wszMaxValueName[valueNameLength] = L'\0';
                    dwMaxValueName = valueNameLength;
                }
            }
        }
    }

    if(pwszLatestVersion && wszMaxValueName != NULL && dwMaxValueName > 0) {
        *pwszLatestVersion = new WCHAR[dwMaxValueName + 1];
        if(pwszLatestVersion == NULL)
            return E_OUTOFMEMORY;
        wcscpy((*pwszLatestVersion), wszMaxValueName);
    }
    else {
        hr = S_FALSE;
    }
    return hr;
}

HRESULT FindLatestVersion(LPWSTR* pwszLatestVersion)
{
    HRESULT hr = S_OK;
    HKEY    pKey;
    VersionStack sStack;
    
    if(pwszLatestVersion == NULL) return E_POINTER;

    if ((WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         SHIM_POLICY_REGISTRY_KEY, 
                         0, KEY_READ, &pKey) == ERROR_SUCCESS))
    {
        
        hr = BuildMajorMinorStack(pKey, &sStack);
        if(SUCCEEDED(hr)) 
        {
            LPWSTR keyName = sStack.Pop();
            while(keyName != NULL) 
            {
                HKEY userKey;
                if((WszRegOpenKeyEx(pKey,
                                    keyName,
                                    0,
                                    KEY_READ,
                                    &userKey) == ERROR_SUCCESS))
                {
                    LPWSTR pBuild = NULL;
                    hr = FindLatestBuild(userKey, keyName, &pBuild);
                    RegCloseKey(userKey);
                    if(pBuild) {
                        DWORD length = wcslen(pBuild) + wcslen(keyName) + 2; // period and null
                        *pwszLatestVersion = new WCHAR[length];
                        wcscpy(*pwszLatestVersion, keyName);
                        wcscat(*pwszLatestVersion, L".");
                        wcscat(*pwszLatestVersion, pBuild);
                        delete [] pBuild;
                    }
                    if(FAILED(hr) || hr == S_OK) break; // Failed badly or found a version
                }

                delete [] keyName;
                keyName = sStack.Pop();
            }
        }
    }

    if(pKey)
        RegCloseKey(pKey);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\shim.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Shim.cpp
//
//*****************************************************************************
#include "stdafx.h"                     // Standard header.
#define INIT_GUIDS

#define _CorExeMain XXXX  //HACK: Prevent _CorExeMain prototype from colliding with our auto-generated prototype
#define _CorExeMain2 XXXX
#include <cor.h>
#undef _CorExeMain
#undef _CorExeMain2

#include <mscoree.h>
#include <corperm.h>
#include <perfcounterdefs.h>
#include <corshim.h>
#include <resource.h>
#include <corcompile.h>
#include <gchost.h>
#include <ivalidator.h>
#include <__file__.ver>
#include <shlwapi.h>

#include "strongnamecache.h"
#include "xmlparser.h"
#include "xmlreader.h"
#include "shimpolicy.h"
#include "mdfileformat.h"
#include "corpriv.h"
#include "sxshelpers.h"

#include "msg.h"
#include "winsafer.h"

#define REPORTEVENTDLL L"advapi32.dll"
#define REPORTEVENTFUNCNAME "ReportEventW"
typedef BOOL (WINAPI *REPORTEVENTFUNC)( HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCTSTR *lpStrings, LPVOID lpRawData );

class RuntimeRequest;

CCompRC* g_pResourceDll = NULL;  // MUI Resource string
HINSTANCE       g_hShimMod = NULL;//the shim's instance handle
HINSTANCE       g_hMod = NULL;    //instance handle of the real DLL
HINSTANCE       g_hFusionMod = NULL;    //instance handle of the fusion DLL
ULONG           g_numLoaded = 0;  //# of times we've loaded this (for proper cleanup)
HINSTANCE       g_hStrongNameMod = NULL;   // instance handle of the real mscorsn DLL
ULONG           g_numStrongNameLoaded = 0; // # of times we've loaded this
BOOL            g_UseLocalRuntime=-1; 

BOOL            g_bSingleProc = FALSE;
ModuleList*     g_pLoadedModules = NULL;

BOOL            g_fSetDefault = FALSE; // Remove this when the Ex version replaces CorBindToRuntime().
BOOL            g_fInstallRootSet = TRUE;
int             g_StartupFlags = STARTUP_CONCURRENT_GC;

LPCWSTR         g_pHostConfigFile = NULL; // Remember a base system configuration file passed in by the host.
DWORD           g_dwHostConfigFile = 0;

RuntimeRequest* g_PreferredVersion = NULL;

#define ERROR_BUF_LEN 256

BYTE g_pbMSPublicKey[] = 
{
    0,  36,   0,   0,   4, 128,   0,   0, 148,   0,   0,   0,   6,   2,   0,
    0,   0,  36,   0,   0,  82,  83,  65,  49,   0,   4,   0,   0,   1,   0,
    1,   0,   7, 209, 250,  87, 196, 174, 217, 240, 163,  46, 132, 170,  15,
  174, 253,  13, 233, 232, 253, 106, 236, 143, 135, 251,   3, 118, 108, 131,
   76, 153, 146,  30, 178,  59, 231, 154, 217, 213, 220, 193, 221, 154, 210,
   54,  19,  33,   2, 144,  11, 114,  60, 249, 128, 149, 127, 196, 225, 119,
   16, 143, 198,   7, 119,  79,  41, 232,  50,  14, 146, 234,   5, 236, 228,
  232,  33, 192, 165, 239, 232, 241, 100,  92,  76,  12, 147, 193, 171, 153,
   40,  93,  98,  44, 170, 101,  44,  29, 250, 214,  61, 116,  93, 111,  45,
  229, 241, 126,  94, 175,  15, 196, 150,  61,  38,  28, 138,  18,  67, 101,
   24,  32, 109, 192, 147,  52,  77,  90, 210, 147
};
ULONG g_cbMSPublicKey = sizeof(g_pbMSPublicKey);

BYTE g_pbMSStrongNameToken[] = 
{ 0xB0, 0x3F, 0x5F, 0x7F, 0x11, 0xD5, 0x0A, 0x3A };

ULONG g_cbMSStrongNameToken = sizeof(g_pbMSStrongNameToken);

StrongNameCacheEntry g_MSStrongNameCacheEntry (g_cbMSPublicKey, 
                                               g_pbMSPublicKey,
                                               g_cbMSStrongNameToken,
                                               g_pbMSStrongNameToken,
                                               0);

BYTE g_pbECMAPublicKey[] = 
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
ULONG g_cbECMAPublicKey = sizeof(g_pbECMAPublicKey);

BYTE g_pbECMAStrongNameToken[] = 
{ 0xB7, 0x7A, 0x5C, 0x56, 0x19, 0x34, 0xE0, 0x89 };

ULONG g_cbECMAStrongNameToken = sizeof(g_pbECMAStrongNameToken);

StrongNameCacheEntry g_ECMAStrongNameCacheEntry (g_cbECMAPublicKey, 
                                                 g_pbECMAPublicKey,
                                                 g_cbECMAStrongNameToken,
                                                 g_pbECMAStrongNameToken,
                                                 0);


// Foward references for functions defined in this file
LPWSTR GetConfigString(LPCWSTR name, BOOL fSearchRegistry);
HRESULT GetRealDll(HINSTANCE* pInstance);
HRESULT GetInstallation(BOOL fShowErrorDialog, 
                                    HMODULE* ppResult,
                                    BOOL fBeLiberalIfFail=FALSE);
static BOOL ShouldConvertVersionToV1(LPCWSTR lpVersion);



//-------------------------------------------------------------------
// CLSID's version and hMod cacheing 
//-------------------------------------------------------------------
template <class T>
class SORTEDARRAY
{
public:
    SORTEDARRAY() { m_Arr = NULL; m_ulArrLen = 0; m_ulCount = 0; m_ulOffset = 0; 
                    m_Mux = WszCreateMutex(NULL,FALSE,NULL);};
    ~SORTEDARRAY() {
        if(m_Arr) {
            for(ULONG i=0; i < m_ulCount; i++) {
                if(m_Arr[i+m_ulOffset]) delete m_Arr[i+m_ulOffset];
            }
            delete [] m_Arr;
        }
        CloseHandle(m_Mux);
    };
    void RESET() {
        WaitForSingleObject(m_Mux,INFINITE);
        if(m_Arr) {
            for(ULONG i=0; i < m_ulCount; i++) {
                if(m_Arr[i+m_ulOffset]) delete m_Arr[i+m_ulOffset];
            }
            m_ulCount = 0;
            m_ulOffset= 0;
        }
        ReleaseMutex(m_Mux);
    };
    void PUSH(T *item) 
    {
        if(item)
        {
            WaitForSingleObject(m_Mux,INFINITE);
            if(m_ulCount+m_ulOffset >= m_ulArrLen)
            {
                if(m_ulOffset)
                {
                    memcpy(m_Arr,&m_Arr[m_ulOffset],m_ulCount*sizeof(T*));
                    m_ulOffset = 0;
                }
                else
                {
                    m_ulArrLen += 1024;
                    T** tmp = new T*[m_ulArrLen];
                    if(tmp)
                    {
                        if(m_Arr)
                        {
                            memcpy(tmp,m_Arr,m_ulCount*sizeof(T*));
                            delete [] m_Arr;
                        }
                        m_Arr = tmp;
                    }
                    else // allocation failed -- don't insert new item
                    {
                        m_ulArrLen -= 1024;
                        ReleaseMutex(m_Mux);
                        return;
                    }
                }
            }
            if(m_ulCount)
            {
                // find  1st arr.element > item
                unsigned jj = m_ulOffset;
                T** low = &m_Arr[m_ulOffset];
                T** high = &m_Arr[m_ulOffset+m_ulCount-1];
                T** mid;
            
                if(item->ComparedTo(*high) > 0) mid = high+1;
                else if(item->ComparedTo(*low) < 0) mid = low;
                else for(;;) 
                {
                    mid = &low[(high - low) >> 1];
            
                    int cmp = item->ComparedTo(*mid);
            
                    if (mid == low)
                    {
                        if(cmp > 0) mid++;
                        break;
                    }
            
                    if (cmp > 0) low = mid;
                    else        high = mid;
                }

                /////////////////////////////////////////////
                 memmove(mid+1,mid,(BYTE*)&m_Arr[m_ulOffset+m_ulCount]-(BYTE*)mid);
                *mid = item;
            }
            else m_Arr[m_ulOffset+m_ulCount] = item;
            m_ulCount++;
            ReleaseMutex(m_Mux);
        }
    };
    ULONG COUNT() { return m_ulCount; };
    T* POP() 
    {
        T* ret = NULL;
        WaitForSingleObject(m_Mux,INFINITE);
        if(m_ulCount)
        {
            ret = m_Arr[m_ulOffset++];
            m_ulCount--;
        }
        ReleaseMutex(m_Mux);
        return ret;
    };
    T* PEEK(ULONG idx) { return (idx < m_ulCount) ? m_Arr[m_ulOffset+idx] : NULL; };
    T* FIND(T* item)
    {
        T* ret = NULL;
        WaitForSingleObject(m_Mux,INFINITE);
        if(m_ulCount)
        {
            T** low = &m_Arr[m_ulOffset];
            T** high = &m_Arr[m_ulOffset+m_ulCount-1];
            T** mid;
            if(item->ComparedTo(*high) == 0) 
                ret = *high;
            else
            {
                for(;;) 
                {
                    mid = &low[(high - low) >> 1];
                    int cmp = item->ComparedTo(*mid);
                    if (cmp == 0) { ret = *mid; break; }
                    if (mid == low)  break;
                    if (cmp > 0) low = mid;
                    else        high = mid;
                }
            }
        }
        ReleaseMutex(m_Mux);
        return ret;
    };
private:
    T** m_Arr;
    ULONG       m_ulCount;
    ULONG       m_ulOffset;
    ULONG       m_ulArrLen;
    HANDLE      m_Mux;
};

class ClsVerMod
{
public:
    IID         m_clsid;
    void*       m_pv;

    ClsVerMod()
    {
        memset(&m_clsid,0,sizeof(IID));
        m_pv = NULL;
    };
    ClsVerMod(REFCLSID rclsid, void* pv)
    {
        m_clsid = rclsid;
        m_pv  = pv;
    };

    int ComparedTo(ClsVerMod* pCVM) 
    { 
        return memcmp(&m_clsid,&(pCVM->m_clsid),sizeof(IID)); 
    };
};
typedef SORTEDARRAY<ClsVerMod> ClsVerModList;
ClsVerModList* g_pCVMList = NULL;

// Runtimes are found using different pieces of information. The information and 
// the result (see lpVersionToLoad) are kept in the request object.
class RuntimeRequest
{
private:
    LPCWSTR lpVersionToLoad;            // This version we will load
    LPCWSTR lpDefaultVersion;           // Version that overrides everything except the configuration file
    LPCWSTR lpDefaultApplicationName;   // The name of the application (if null then we use the process image)
    LPCWSTR lpHostConfig;               // The host configuration file name.
    LPCWSTR lpAppConfig;                // The host configuration file name.
    LPCWSTR lpImageVersion;             // The configuration file can state what a new image's
                                        // version is. Compilers use this to control the version
                                        // number emitted to the file.
    BOOL    fSupportedRuntimeSafeMode;  // Are the supported runtime tag(s) in safemode
    BOOL    fRequiredRuntimeSafeMode;   // Is the required runtime tag in safemode
    BOOL    fLatestVersion;             // Are we allowed to look for the latest version of the runtime.
                                        // This is only allowed for COM objects and legacy applications.
    LPCWSTR lpBuildFlavor;              // Workstation or Server
    DWORD   dwStartupFlags;             // Start up flags (concurrency, multi-domain etc)
    LPWSTR* pwszSupportedVersions;      // Supported versions of the runtime that are mentioned in the configuration file
    DWORD   dwSupportedVersions;        //    Number of versions

    void CopyString(LPCWSTR* ppData, LPCWSTR value, BOOL fCopy)
    {
        if((*ppData) != NULL) {
            delete [] (*ppData);
            *ppData = NULL;
        }
        if(fCopy && value != NULL) {
            (*ppData) = new WCHAR[wcslen(value)+1];
            wcscpy((*(WCHAR**)ppData), value);
        }
        else 
            (*ppData) = value;
    }

    void CleanSupportedVersionsArray();

public:
    RuntimeRequest() : 
        lpVersionToLoad(NULL),
        lpDefaultApplicationName(NULL),
        lpHostConfig(NULL),
        lpAppConfig(NULL),
        lpDefaultVersion(NULL),
        fSupportedRuntimeSafeMode(FALSE),
        fRequiredRuntimeSafeMode(FALSE),
        lpImageVersion(NULL),
        lpBuildFlavor(NULL),
        fLatestVersion(FALSE),
        dwStartupFlags(STARTUP_CONCURRENT_GC),
        pwszSupportedVersions(NULL),
        dwSupportedVersions(0)
    {}

    ~RuntimeRequest() 
    {
        if(lpDefaultApplicationName != NULL) delete [] lpDefaultApplicationName;
        if(lpHostConfig != NULL) delete [] lpHostConfig;
        if(lpAppConfig != NULL) delete [] lpAppConfig;
        if(lpDefaultVersion != NULL) delete [] lpDefaultVersion;
        if(lpVersionToLoad != NULL) delete [] lpVersionToLoad;
        if(lpImageVersion != NULL) delete [] lpImageVersion;
        if(lpBuildFlavor != NULL) delete [] lpBuildFlavor;
        CleanSupportedVersionsArray();
    }

    // Field methods
    LPCWSTR GetDefaultApplicationName() { return lpDefaultApplicationName; }
    void SetDefaultApplicationName(LPCWSTR value, BOOL fCopy) { CopyString(&lpDefaultApplicationName, value, fCopy); }

    LPCWSTR GetHostConfig() { return lpHostConfig; }
    void SetHostConfig(LPCWSTR value, BOOL fCopy) { CopyString(&lpHostConfig, value, fCopy); }

    LPCWSTR GetAppConfig() { return lpAppConfig; }
    void SetAppConfig(LPCWSTR value, BOOL fCopy) { CopyString(&lpAppConfig, value, fCopy); }
    
    LPCWSTR GetDefaultVersion() { return lpDefaultVersion; }
    void SetDefaultVersion(LPCWSTR value, BOOL fCopy) { CopyString(&lpDefaultVersion, value, fCopy); }

    LPCWSTR GetVersionToLoad() { return lpVersionToLoad; }
    void SetVersionToLoad(LPCWSTR value, BOOL fCopy) { CopyString(&lpVersionToLoad, value, fCopy); }

    LPCWSTR GetImageVersion() { return lpImageVersion; }
    void SetImageVersion(LPCWSTR value, BOOL fCopy) { CopyString(&lpImageVersion, value, fCopy); }

    LPCWSTR GetBuildFlavor() { return lpBuildFlavor; }
    void SetBuildFlavor(LPCWSTR value, BOOL fCopy) { CopyString(&lpBuildFlavor, value, fCopy); }

    BOOL GetSupportedRuntimeSafeMode() { return fSupportedRuntimeSafeMode; }
    void SetSupportedRuntimeSafeMode(BOOL value) { fSupportedRuntimeSafeMode = value; }

    BOOL GetRequiredRuntimeSafeMode() { return fRequiredRuntimeSafeMode; }
    void SetRequiredRuntimeSafeMode(BOOL value) { fRequiredRuntimeSafeMode = value; }

    BOOL GetLatestVersion() { return fLatestVersion; }
    void SetLatestVersion(BOOL value) { fLatestVersion = value; }

    DWORD StartupFlags() { return dwStartupFlags; }
    void SetStartupFlags(DWORD value) { dwStartupFlags = value; }

    //------------------------------------------------------------------------------
    static LPWSTR BuildRootPath();
    BOOL FindSupportedInstalledRuntime(LPWSTR* version);

    DWORD GetSupportedVersionsSize() { return dwSupportedVersions; }
    LPWSTR* GetSupportedVersions() { return pwszSupportedVersions; }
    void SetSupportedVersions(LPWSTR* pSupportedVersions, DWORD nSupportedVersions, BOOL fCopy);
        
    HRESULT ComputeVersionString(BOOL fShowErrorDialog);
    HRESULT GetRuntimeVersion();
    HRESULT LoadVersionedRuntime(LPWSTR rootPath, 
                                 LPWSTR fullPath,        // Allows bypassing of above arguments
                                 BOOL* pLoaded); 
    HRESULT RequestRuntimeDll(BOOL fShowErrorDialog, BOOL* pLoaded);
    HRESULT FindVersionedRuntime(BOOL fShowErrorDialog, BOOL* pLoaded);
    HRESULT NoSupportedVersion(BOOL fShowErrorDialog);
    void VerifyRuntimeVersionToLoad();

};

void RuntimeRequest::CleanSupportedVersionsArray()
{
    if (pwszSupportedVersions == NULL || dwSupportedVersions == 0)
        return;

    for (DWORD i=0; i < dwSupportedVersions; i++ )
        delete[] pwszSupportedVersions[i];
    delete[] pwszSupportedVersions;

    pwszSupportedVersions = NULL;
    dwSupportedVersions = 0;
}

BOOL RuntimeRequest::FindSupportedInstalledRuntime(LPWSTR* version)
{

    LPWSTR* pVersions  = pwszSupportedVersions;
    DWORD   dwVersions = dwSupportedVersions;
    BOOL    fSafeMode  = fSupportedRuntimeSafeMode;

    LPWSTR policyVersion = NULL;
    LPWSTR versionToUse;
    for (DWORD i = 0; i < dwVersions; i++)
    {
        if (ShouldConvertVersionToV1(pVersions[i]))
            versionToUse = V1_VERSION_NUM;
        else
            versionToUse = pVersions[i];

        if(SUCCEEDED(FindStandardVersion(pVersions[i], &policyVersion)) &&
           policyVersion != NULL)
            versionToUse = policyVersion;
        
        if (IsRuntimeVersionInstalled(versionToUse)==S_OK)
        {
            if(version)
            {
                *version = new WCHAR[wcslen(versionToUse) + 1];
                wcscpy(*version, versionToUse);
            }
            if(policyVersion) delete[] policyVersion;
            return TRUE;
        };
        if(policyVersion) {
            delete[] policyVersion;
            policyVersion = NULL;
        }
    }
    return FALSE;
}

HINSTANCE GetModuleInst()
{
    return g_hShimMod;
}

HINSTANCE GetResourceInst()
{
    HINSTANCE hInstance;
    if(SUCCEEDED(g_pResourceDll->LoadMUILibrary(&hInstance)))
        return hInstance;
    else
        return GetModuleInst();
}

HRESULT FindVersionForCLSID(REFCLSID rclsid, LPWSTR* version, BOOL fListedVersion);

StrongNameTokenFromPublicKeyCache g_StrongNameFromPublicKeyMap;
BOOL StrongNameTokenFromPublicKeyCache::s_IsInited = FALSE;

//-------------------------------------------------------------------
// Gets a value of an environment variable
//-------------------------------------------------------------------

LPWSTR EnvGetString(LPCWSTR name)
{
    WCHAR buff[64];
    if(wcslen(name) > 64 - 1 - 8) 
        return(0);
    wcscpy(buff, L"COMPlus_");
    wcscpy(&buff[8], name);

    int len = WszGetEnvironmentVariable(buff, 0, 0);
    if (len == 0)
        return(0);

    LPWSTR ret = new WCHAR [len];
    _ASSERTE(ret != NULL);
    if (!ret)
        return(NULL);

    WszGetEnvironmentVariable(buff, ret, len);
    return(ret);
}

/**************************************************************/
LPWSTR GetConfigString(LPCWSTR name, BOOL fSearchRegistry)
{
    HRESULT lResult;
    HKEY userKey = NULL;
    HKEY machineKey = NULL;
    DWORD type;
    DWORD size;
    LPWSTR ret = NULL;

    
    ret = EnvGetString(name);   // try getting it from the environment first
    if (ret != 0) {
        if (*ret != 0) 
        {
            return(ret);
        }
        delete [] ret;
    }

    if (fSearchRegistry){
        if ((WszRegOpenKeyEx(HKEY_CURRENT_USER, FRAMEWORK_REGISTRY_KEY_W, 0, KEY_READ, &userKey) == ERROR_SUCCESS) &&
            (WszRegQueryValueEx(userKey, name, 0, &type, 0, &size) == ERROR_SUCCESS) &&
            type == REG_SZ && size > 1) 
        {
            ret = new WCHAR [size + 1];
            if (!ret)
                goto ErrExit;
            lResult = WszRegQueryValueEx(userKey, name, 0, 0, (LPBYTE) ret, &size);
            _ASSERTE(lResult == ERROR_SUCCESS);
            goto ErrExit;
        }

        if ((WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, FRAMEWORK_REGISTRY_KEY_W, 0, KEY_READ, &machineKey) == ERROR_SUCCESS) &&
            (WszRegQueryValueEx(machineKey, name, 0, &type, 0, &size) == ERROR_SUCCESS) &&
            type == REG_SZ && size > 1) 
        {
            ret = new WCHAR [size + 1];
            if (!ret)
                goto ErrExit;
            lResult = WszRegQueryValueEx(machineKey, name, 0, 0, (LPBYTE) ret, &size);
            _ASSERTE(lResult == ERROR_SUCCESS);
            goto ErrExit;
        }

    ErrExit:
        if (userKey)
            RegCloseKey(userKey);
        if (machineKey)
            RegCloseKey(machineKey);
    }

    return(ret);
}

HRESULT RuntimeRequest::GetRuntimeVersion()
{
    LPCWSTR sConfig;
    if (GetHostConfig())
        sConfig = GetHostConfig();
    else if (GetAppConfig())
        sConfig = GetAppConfig();
    else
        return S_OK;

    LPWSTR  sVersion = NULL;        // Version number for the runtime
    LPWSTR  sImageVersion = NULL;   // Version number to be burnt into each image
    LPWSTR  sBuildFlavor = NULL;    // Type of runtime to load
    BOOL    bSupportedRuntimeSafeMode = FALSE;  // Does the startup tag have safemode?
    BOOL    bRequiredRuntimeSafeMode = FALSE;   // Does the required runtime tag have safemode?
    LPWSTR* pSupportedVersions = NULL;
    DWORD   nSupportedVersions = 0;

    // Get Version and SafeMode from .config file
    HRESULT hr = XMLGetVersionWithSupported(sConfig, 
                                            &sVersion, 
                                            &sImageVersion, 
                                            &sBuildFlavor, 
                                            &bSupportedRuntimeSafeMode,
                                            &bRequiredRuntimeSafeMode,
                                            &pSupportedVersions,
                                            &nSupportedVersions);
    if(SUCCEEDED(hr))
    {
#ifdef _DEBUG
        SetSupportedVersions(pSupportedVersions, nSupportedVersions, TRUE); 
#endif
        SetSupportedVersions(pSupportedVersions, nSupportedVersions, FALSE); 
  
        if(sVersion != NULL && nSupportedVersions == 0)
            SetVersionToLoad(sVersion, FALSE);
        if(sImageVersion != NULL)
            SetImageVersion(sImageVersion, FALSE);
        if(sBuildFlavor != NULL)
            SetBuildFlavor(sBuildFlavor, FALSE);
        SetRequiredRuntimeSafeMode(bRequiredRuntimeSafeMode);
        SetSupportedRuntimeSafeMode(bSupportedRuntimeSafeMode);

    }

    return hr;
}

//-------------------------------------------------------------------
// Returns the handle to the appropriate version of the runtime.
//
// It is possible for this function to return NULL if the runtime cannot
// be found or won't load. If the caller can deal with this in a friendly way,
// it should do so.
//-------------------------------------------------------------------

//#define _MSCOREE L"MscoreePriv.dll"      // Name hardcoded???
static DWORD  g_flock = 0;
static LPWSTR g_FullPath = NULL;
static LPWSTR g_BackupPath = NULL;
static LPWSTR g_Version = NULL;
static LPWSTR g_ImageVersion = NULL;
static LPWSTR g_Directory = NULL;
static LPWSTR g_FullStrongNamePath = NULL;

static void ClearGlobalSettings()
{
    if(g_FullPath) {
        delete[] g_FullPath;
        g_FullPath = NULL;
    }
    
    if(g_BackupPath) {
        delete[] g_BackupPath;
        g_BackupPath = NULL;
    }
    
    if(g_pHostConfigFile) {
        delete [] g_pHostConfigFile;
        g_pHostConfigFile = NULL;
    }
    
    if(g_Version) {
        delete[] g_Version;
        g_Version = NULL;
    }
    
    if(g_ImageVersion) {
        delete[] g_ImageVersion;
        g_ImageVersion = NULL;
    }
    
    if(g_Directory) {
        delete[] g_Directory;
        g_Directory = NULL;
    }
}

void BuildDirectory(LPCWSTR path, LPCWSTR version, LPCWSTR imageVersion)
{
    _ASSERTE(g_Directory == NULL);
    _ASSERTE(path != NULL);
    _ASSERTE(wcslen(path) < MAX_PATH);
    
    LPWSTR pSep = wcsrchr(path, L'\\');
    _ASSERTE(pSep);
    DWORD lgth = (DWORD)(pSep-path+2);
    LPWSTR directory = new WCHAR[lgth];
    if(directory == NULL)
        return;
    wcsncpy(directory, path, lgth);
    directory[lgth-1] = L'\0';

    g_Directory = directory;

    if(version) {
        lgth = (DWORD)(wcslen(version) + 1);
        g_Version = new WCHAR[lgth];
        if(g_Version == NULL) return;
        
        wcscpy(g_Version, version);
    }

    if(imageVersion) {
        lgth = (DWORD)(wcslen(imageVersion) + 1);
        g_ImageVersion = new WCHAR[lgth];
        if(g_ImageVersion == NULL) return;
        
        wcscpy(g_ImageVersion, imageVersion);
    }
}

// Make the complete name given all parameters
LPWSTR MakeQualifiedName(LPWSTR rootPath, LPCWSTR version, LPCWSTR buildFlavor, DWORD* dwStartFlags)
{
    LPCWSTR corName = L"mscor.dll";
    LPWSTR  flavor = (LPWSTR) buildFlavor;

    if (!flavor || *flavor == L'\0') { // If buildflavor not found use default
        flavor = (WCHAR*) alloca(sizeof(WCHAR) * 4);
        wcscpy(flavor, L"wks");
    }
    else if (g_bSingleProc) {            //If we are running SingleProc, always load WKS

        // If we asked for a server but we are on a uni-proc machine then
        // turn off concurrent gc
        if (_wcsnicmp(L"svr", flavor, 3) == 0 && g_fSetDefault) {
            (*dwStartFlags) &= ~STARTUP_CONCURRENT_GC;
        }
        
        flavor = (WCHAR*) alloca(sizeof(WCHAR) * 4);
        wcscpy(flavor, L"wks");
    }

    DWORD lgth = (rootPath ? (wcslen(rootPath) + 1) : 0) 
        + (version ? (wcslen(version)) : 0) 
        + (corName ? (wcslen(corName) + 1 ) : 0)
        + (flavor ? wcslen(flavor) : 0)
        + 1;
    
    LPWSTR fullPath = new WCHAR [lgth];   
    if(fullPath == NULL) return NULL;

    wcscpy(fullPath, L"");

    if (rootPath) {
      wcscpy(fullPath, rootPath);
      //Dont add the additional \ if already present
      if(*(fullPath + (wcslen(fullPath) - 1)) != '\\')
          wcscat(fullPath, L"\\");
    }
    
    if (version) {
        wcscat(fullPath, version);
    }
        
    //Dont add the additional \ if already present
    if(*(fullPath + (wcslen(fullPath) - 1)) != '\\')
        wcscat(fullPath, L"\\");
    
    if (corName) {
        LPWSTR filename = (LPWSTR) alloca(sizeof(WCHAR) * (wcslen(corName) + 1));
        LPWSTR ext = (LPWSTR) alloca(sizeof(WCHAR) * (wcslen(corName) + 1));
        
        SplitPath(corName, NULL, NULL, filename, ext);
        if (filename) {
            wcscat(fullPath, filename);
        }
        if (flavor) {
            wcscat(fullPath, flavor);
        }
        if (ext) {
            wcscat(fullPath, ext);
        }
    }
    wcscat(fullPath, L"\x0");
    return fullPath;
}

HRESULT GetInstallation(BOOL fShowErrorDialog, HMODULE* ppResult, BOOL fBeLiberalIfFail)
{
    _ASSERTE(ppResult);

    HRESULT hr = S_OK;
    if(g_hMod != NULL) {
        *ppResult = g_hMod;
        return S_OK;
    }
    else if(g_FullPath == NULL)
    {
        RuntimeRequest sRealVersion;
        hr = sRealVersion.RequestRuntimeDll((!fBeLiberalIfFail)&&fShowErrorDialog, NULL);

        // Try and spin up v1
        if (FAILED(hr) && fBeLiberalIfFail)
        {
            RuntimeRequest sVersion;
            sVersion.SetDefaultVersion(V1_VERSION_NUM, TRUE);
            hr = sVersion.RequestRuntimeDll(FALSE, NULL);
        }

        // That failed... try and spin up Everett
        // @TODO - Replace VER_SBSFILEVERSION_WSTR with a constant once we
        // figure out what build # we'll be shipping (we can do this in Whidbey)
        if (FAILED(hr) && fBeLiberalIfFail)
        {
            RuntimeRequest sVersion;
            sVersion.SetDefaultVersion(L"v"VER_SBSFILEVERSION_WSTR, TRUE);
            hr = sVersion.RequestRuntimeDll(FALSE, NULL);
        }
       

        if(FAILED(hr)) 
        {
            if (fShowErrorDialog  && fBeLiberalIfFail)
            {
                LPWSTR runtimes[3];
                runtimes[0]=(LPWSTR)sRealVersion.GetVersionToLoad();
                runtimes[1]=(LPWSTR)V1_VERSION_NUM;
                runtimes[2]=(LPWSTR)L"v"VER_SBSFILEVERSION_WSTR;
                sRealVersion.SetSupportedVersions(runtimes[0]?runtimes:runtimes+1,
                                                  runtimes[0]?3:2,TRUE);
                sRealVersion.NoSupportedVersion(TRUE);
            }
            return hr;
        }

        if(g_FullPath == NULL)
        {
            // this is an error
            _ASSERTE(!"The path must be set before getting the runtime's handle");
            return E_FAIL;
        }
    }

    if(g_hMod == NULL) {
        HMODULE hMod = LoadLibraryWrapper(g_FullPath);
        if(hMod != NULL) 
            InterlockedExchangePointer(&(g_hMod), hMod);
        else if(g_BackupPath) {
            hMod = LoadLibraryWrapper(g_BackupPath);
            if(hMod != NULL)
                InterlockedExchangePointer(&(g_hMod), hMod);
        }
    
        if(hMod == NULL) {
            hr = CLR_E_SHIM_RUNTIMELOAD;
            if (fShowErrorDialog && !(REGUTIL::GetConfigDWORD(L"NoGuiFromShim", FALSE))){
                UINT last = SetErrorMode(0);
                SetErrorMode(last);     //Set back to previous value
                if (!(last & SEM_FAILCRITICALERRORS)){   //Display Message box only if FAILCRITICALERRORS set
                    WCHAR errorBuf[ERROR_BUF_LEN]={0};                     
                    WCHAR errorCaption[ERROR_BUF_LEN]={0};
                    
                    //Get error string from resource
                    UINT uResourceID = g_fInstallRootSet ? SHIM_PATHNOTFOUND : SHIM_INSTALLROOT; 
                    VERIFY(WszLoadString(GetResourceInst(), uResourceID, errorBuf, ERROR_BUF_LEN) > 0);
                    VERIFY(WszLoadString(GetResourceInst(), SHIM_INITERROR, errorCaption, ERROR_BUF_LEN) > 0);
                    
                    CQuickBytes qbError;
                    size_t iLen = wcslen(g_FullPath) + wcslen(errorBuf) + 1;
                    LPWSTR errorStr = (LPWSTR) qbError.Alloc(iLen * sizeof(WCHAR)); 
                    if(errorStr!=NULL) {
                        _snwprintf(errorStr, iLen, errorBuf, g_FullPath);
                        WszMessageBoxInternal(NULL, errorStr, errorCaption, MB_OK | MB_ICONSTOP);                                                                
                    }
                }
            }
        }
        else {
            BOOL (STDMETHODCALLTYPE * pRealMscorFunc)();
            *((VOID**)&pRealMscorFunc) = GetProcAddress(hMod, "SetLoadedByMscoree");
            if (pRealMscorFunc) pRealMscorFunc();
        }
    }

    if(SUCCEEDED(hr)) 
        *ppResult = g_hMod;
    return hr;
}

HRESULT VerifyDirectory(IMAGE_NT_HEADERS *pNT, IMAGE_DATA_DIRECTORY *dir) 
{
    // Under CE, we have no NT header.
    if (pNT == NULL)
        return S_OK;

    if (dir->VirtualAddress == NULL && dir->Size == NULL)
        return S_OK;

    // @TODO: need to use 64 bit version??
    IMAGE_SECTION_HEADER* pCurrSection = IMAGE_FIRST_SECTION(pNT);
    // find which section the (input) RVA belongs to
    ULONG i;
    for(i = 0; i < pNT->FileHeader.NumberOfSections; i++)
    {
        if(dir->VirtualAddress >= pCurrSection->VirtualAddress &&
           dir->VirtualAddress < pCurrSection->VirtualAddress + pCurrSection->SizeOfRawData)
            return S_OK;
        pCurrSection++;
    }

    return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
}

// These two functions are used to convert Virtual Addresses to Offsets to the top of
// the PE
PIMAGE_SECTION_HEADER Shim_RtlImageRvaToSection(PIMAGE_NT_HEADERS NtHeaders,
                                                       ULONG Rva)
{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData)
            return NtSection;
        
        ++NtSection;
    }

    return NULL;
}

DWORD Shim_RtlImageRvaToOffset(PIMAGE_NT_HEADERS NtHeaders,
                                       ULONG Rva)
{
    PIMAGE_SECTION_HEADER NtSection = Shim_RtlImageRvaToSection(NtHeaders,
                                                               Rva);

    if (NtSection)
        return ((Rva - NtSection->VirtualAddress) +
                NtSection->PointerToRawData);
    else
        return NULL;
}



LPCWSTR GetPERuntimeVersion(PBYTE hndle, DWORD dwFileSize, BOOL fFileMapped)
{
    IMAGE_DOS_HEADER *pDOS = (IMAGE_DOS_HEADER*)hndle;
    IMAGE_NT_HEADERS *pNT;
    int nOffset = 0;
    
    if ((pDOS->e_magic != IMAGE_DOS_SIGNATURE) ||
        (pDOS->e_lfanew == 0))
        return NULL;
        
    // If the file was mapped by LoadLibrary(), this verification
    // has already been done
    if ((!fFileMapped) &&
        ( (dwFileSize < sizeof(IMAGE_DOS_HEADER) + sizeof(IMAGE_NT_HEADERS)) ||
          (dwFileSize - sizeof(IMAGE_NT_HEADERS) < (DWORD) pDOS->e_lfanew) ))
        return NULL;

    pNT = (IMAGE_NT_HEADERS*) (pDOS->e_lfanew + hndle);

    if ((pNT->Signature != IMAGE_NT_SIGNATURE) ||
        (pNT->FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER) ||
        (pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC))
        return NULL;

    IMAGE_DATA_DIRECTORY *entry 
      = &pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER];
    
    if (entry->VirtualAddress == 0 || entry->Size == 0
        || entry->Size < sizeof(IMAGE_COR20_HEADER))
        return NULL;

    //verify RVA and size of the COM+ header
    if(FAILED(VerifyDirectory(pNT, entry)))
        return NULL;


    IMAGE_COR20_HEADER* pCOR = NULL;
    // We'll need to figure out the Virtual Address offsets if the OS didn't map
    // this file into memory
    if (!fFileMapped)
    {
        nOffset = Shim_RtlImageRvaToOffset(pNT, entry->VirtualAddress);
        if (nOffset == NULL)
            return NULL;
        pCOR = (IMAGE_COR20_HEADER *) (nOffset + hndle);    
    }
    else
        pCOR = (IMAGE_COR20_HEADER *) (entry->VirtualAddress + hndle);

    if(pCOR->MajorRuntimeVersion < COR_VERSION_MAJOR) 
        return NULL;

    if(FAILED(VerifyDirectory(pNT, &pCOR->MetaData)))
        return NULL;

    LPWSTR wideVersion = NULL;
    LPCSTR pVersion = NULL;
    PVOID pMetaData = NULL;

    // We'll need to figure out the Virtual Address offsets if the OS didn't map
    // this file into memory
    if (!fFileMapped)
    {
        nOffset = Shim_RtlImageRvaToOffset(pNT, pCOR->MetaData.VirtualAddress);
        if (nOffset == NULL)
            return NULL;
        pMetaData = nOffset + hndle;    
    }
    else
        pMetaData = hndle + pCOR->MetaData.VirtualAddress;

    if(FAILED(GetImageRuntimeVersionString(pMetaData, &pVersion)))
        return NULL;


    DWORD bytes = WszMultiByteToWideChar(CP_UTF8,
                                         MB_ERR_INVALID_CHARS,
                                         pVersion,
                                         -1,
                                         NULL,
                                         0);
    if( bytes ) {
        wideVersion = new WCHAR[bytes];
        if (!wideVersion)
            return NULL;
        
        bytes = WszMultiByteToWideChar(CP_UTF8,
                                       MB_ERR_INVALID_CHARS,
                                       pVersion,
                                       -1,
                                       wideVersion,
                                       bytes);
        
    }
        
    return wideVersion;
} // GetPERuntimeVersion
    
LPCWSTR GetProcessVersion()
{
    PBYTE hndle = (PBYTE) WszGetModuleHandle(NULL);
    return GetPERuntimeVersion(hndle, 0, TRUE);
} // GetProcessVersion


STDAPI GetFileVersion(LPCWSTR szFilename,
                      LPWSTR szBuffer,
                      DWORD  cchBuffer,
                      DWORD* dwLength)
{
    LPCWSTR pVersion = NULL; 
    OnUnicodeSystem();

    if (! (szFilename && dwLength) )
        return E_POINTER;

    HRESULT hr = S_OK;
    HANDLE hFile = WszCreateFile(szFilename,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_FLAG_SEQUENTIAL_SCAN,
                                 NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        goto ErrExit;

    DWORD dwFileSize = SafeGetFileSize(hFile, 0);
        
    HANDLE hMap = WszCreateFileMapping(hFile,
                                       NULL,
                                       PAGE_READONLY,
                                       0,
                                       0,
                                       NULL);
    // We can close the file handle now, because CreateFileMapping
    // will hold the file open if needed
    CloseHandle(hFile);

    if (hMap == NULL)
        goto ErrExit;

    // <TODO> Map only what we need to map </TODO>
    PBYTE hndle = (PBYTE)MapViewOfFile(hMap,
                                       FILE_MAP_READ,
                                       0,
                                       0,
                                       0);
    CloseHandle(hMap);

    if (!hndle)
        goto ErrExit;

    pVersion = GetPERuntimeVersion(hndle, dwFileSize, FALSE);
    UnmapViewOfFile(hndle);

    DWORD lgth = 0;
    if (pVersion) {
        lgth = (DWORD)(wcslen(pVersion) + 1);
        *dwLength = lgth;
        if(lgth > cchBuffer)
            IfFailGo(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
        else {
            if (!szBuffer)
                IfFailGo(E_POINTER);
            else
                wcsncpy(szBuffer, pVersion, lgth);
        }
    }
    else
        IfFailGo(COR_E_BADIMAGEFORMAT);
    
    delete[] pVersion;
    return S_OK;

 ErrExit:
    if (pVersion)
        delete[] pVersion;

    if (SUCCEEDED(hr)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hr))
            hr = COR_E_BADIMAGEFORMAT;
    }

    return hr;
} // GetFileVersion

// LoadVersionedRuntime caches the loaded module, so that
// we don't load different versions in the same process.
//
HRESULT RuntimeRequest::LoadVersionedRuntime(LPWSTR rootPath, 
                                             LPWSTR fullPath,        // Allows bypassing of above arguments
                                             BOOL* pLoaded) 
{
    HRESULT hr = S_OK;

    // pLoaded is set to true only when this call is responsible for the load library
    if (g_FullPath) return hr;

    while(1) {
        if(::InterlockedExchange ((long*)&g_flock, 1) == 1) 
            for(unsigned i = 0; i < 10000; i++);
        else
            break;
    }
    
    if (g_FullPath == NULL) {
        LPWSTR CLRFullPath;
        LPWSTR CLRBackupPath;
        // If a full path was not given, create it from the partial path arguments
        if (fullPath == NULL)
        {
            OSVERSIONINFOW   sVer={0};
            sVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            WszGetVersionEx(&sVer);
            
            // If we are running on less then Win 2000 we do not support 'svr'
            if(GetBuildFlavor() != NULL &&
               (sVer.dwPlatformId != VER_PLATFORM_WIN32_NT ||
                sVer.dwMajorVersion < 5) &&
               _wcsnicmp(L"svr", GetBuildFlavor(), 3) == 0) {
                SetBuildFlavor(L"wks", TRUE);
            }
            
            // Create the path to the server
            DWORD dwStartupFlags = StartupFlags();
            fullPath = MakeQualifiedName(rootPath, GetVersionToLoad(), GetBuildFlavor(), &dwStartupFlags);
            if(fullPath == NULL) 
            {
                hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
                goto ErrExit;
            }
            
            // If we are on a single proc. machine the flags may have STARTUP_CONCURRENT_GC turned off.
            SetStartupFlags(dwStartupFlags);
            
            // If we are looking for a server build, use the workstation version
            // as a backup just in case the server build is not available.
            if(GetBuildFlavor() != NULL && _wcsnicmp(L"svr", GetBuildFlavor(), 3) == 0) {
                
                // The flags should not change twice. The machine is still either a single_proc or multi_proc,
                // it has not changed.
                dwStartupFlags = StartupFlags();
                CLRBackupPath = MakeQualifiedName(rootPath, GetDefaultVersion(), NULL, &dwStartupFlags);
                _ASSERTE(dwStartupFlags == StartupFlags());
                
                // We need to guarantee that g_BackupPath is < or <= MAX_PATH: we make this assumption all over this file
                if ((CLRBackupPath != NULL) && (wcslen(CLRBackupPath) >= MAX_PATH)) {
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
                    goto ErrExit;
                }
                g_BackupPath = CLRBackupPath;
            }
            
            CLRFullPath = fullPath;
        }
        else
        {
            CLRFullPath = new WCHAR[wcslen(fullPath)+1];
            wcscpy (CLRFullPath, fullPath);
        }
        
        if(pLoaded) *pLoaded = TRUE;
        
        // Retain the host configuration file as well
        if(GetHostConfig()) {
            g_dwHostConfigFile = wcslen(GetHostConfig()) + 1;
            g_pHostConfigFile = (LPCWSTR) new WCHAR[g_dwHostConfigFile];
            wcscpy((WCHAR*) g_pHostConfigFile, GetHostConfig());
        }
        
        // Remember the Startup flags
        g_StartupFlags = StartupFlags();
        
        // We need to guarantee that g_FullPath is < or <= MAX_PATH: we make this assumption all over this file
        if ((CLRFullPath != NULL) && (wcslen(CLRFullPath) >= MAX_PATH)) {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto ErrExit;
        }
        
        BuildDirectory(CLRFullPath, GetVersionToLoad(), GetImageVersion());
        g_FullPath = CLRFullPath;
    }

 ErrExit:
    ::InterlockedExchange( (long*) &g_flock, 0);
    return hr;
}

static BOOL UseLocalRuntime()
{
    if(g_UseLocalRuntime==-1)
    {
        WCHAR szFileName[_MAX_PATH+7];
        DWORD length = WszGetModuleFileName(g_hShimMod, szFileName, _MAX_PATH);
        if (length>0)
        {
            wcscpy(szFileName+length,L".local");
            if (WszGetFileAttributes(szFileName)!=0xFFFFFFFF)
                g_UseLocalRuntime = 1;
        }
        if(g_UseLocalRuntime == -1)
            g_UseLocalRuntime = 0;
    }
    return g_UseLocalRuntime;
}

HRESULT RuntimeRequest::NoSupportedVersion(BOOL fShowErrorDialog)
{

    HRESULT hr = CLR_E_SHIM_RUNTIMELOAD;
    if (fShowErrorDialog && !(REGUTIL::GetConfigDWORD(L"NoGuiFromShim", FALSE)))
    {
        UINT last = SetErrorMode(0);
        SetErrorMode(last);     //Set back to previous value
        if (!(last & SEM_FAILCRITICALERRORS)){   //Display Message box only if FAILCRITICALERRORS set
            WCHAR errorBuf[ERROR_BUF_LEN*2]={0};                     
            WCHAR errorCaption[ERROR_BUF_LEN]={0};
            
            //Get error string from resource
            VERIFY(WszLoadString(GetResourceInst(), SHIM_NOVERSION, errorBuf, ERROR_BUF_LEN*2) > 0);
            VERIFY(WszLoadString(GetResourceInst(), SHIM_INITERROR, errorCaption, ERROR_BUF_LEN) > 0);
            
            LPWSTR wszVersionList = NULL;
            CQuickBytes qbVerList;
            if (dwSupportedVersions)
            {
                DWORD nTotalLen=0;
                for (DWORD i=0;i < dwSupportedVersions;i++)
                    nTotalLen += wcslen(pwszSupportedVersions[i]) + 4;
                
                wszVersionList = (LPWSTR) qbVerList.Alloc(nTotalLen*sizeof(WCHAR));
                if(wszVersionList)
                {
                    wszVersionList[0] = L'\0';
                    for (i = 0; i < dwSupportedVersions; i++)
                    {
                        wcscat(wszVersionList, pwszSupportedVersions[i]);
                        if(i+1 < dwSupportedVersions)
                            wcscat(wszVersionList,L"\r\n  ");
                    }
                }
                else
                    wszVersionList=L"";
            }
            else
                wszVersionList=(LPWSTR)GetVersionToLoad();
            
            CQuickBytes qbError;
            LPWSTR errorStr = NULL;
            size_t iLen = 0;
            if(wszVersionList) {
                iLen = wcslen(wszVersionList) + wcslen(errorBuf) + 1;
                errorStr = (LPWSTR) qbError.Alloc(iLen * sizeof(WCHAR)); 

                if(errorStr!=NULL) {
                    _snwprintf(errorStr, iLen, errorBuf, wszVersionList);
                    WszMessageBoxInternal(NULL, errorStr, errorCaption, MB_OK | MB_ICONSTOP);                                                                
                }
            }
            
        }
    }
    return hr;
}

void RuntimeRequest::SetSupportedVersions(LPWSTR* pSupportedVersions, DWORD nSupportedVersions, BOOL fCopy)
{ 
    CleanSupportedVersionsArray();
    
    if(fCopy) {
        dwSupportedVersions = nSupportedVersions;
        if(dwSupportedVersions) {
            pwszSupportedVersions = new LPWSTR[dwSupportedVersions];
            for(DWORD i = 0; i < dwSupportedVersions; i++) {
                if(pSupportedVersions[i] != NULL) {
                    DWORD size = wcslen(pSupportedVersions[i]) + 1;
                    pwszSupportedVersions[i] = new WCHAR[size];
                    wcscpy(pwszSupportedVersions[i], pSupportedVersions[i]);
                }
                else 
                    pwszSupportedVersions[i] = NULL;
            }
        }
    }
    else {
        pwszSupportedVersions = pSupportedVersions;
        dwSupportedVersions = nSupportedVersions;
    }
}

        
HRESULT RuntimeRequest::ComputeVersionString(BOOL fShowErrorDialog)
{
    HRESULT hr = S_OK;

    // Darwin installs of the runtime are a special case. 
    // The local version is the empty string.
    if (UseLocalRuntime())
    {
        SetVersionToLoad(L"", TRUE);
        SetSupportedRuntimeSafeMode(TRUE);
        SetRequiredRuntimeSafeMode(TRUE);
        return S_FALSE;
    };


    // If no host.config, make an app.config from win32 manifest information
    // or barring that process name.
    if(!GetHostConfig() && !GetAppConfig()) {

        DWORD len = 0;

        CQuickString sFileName;
        sFileName.ReSize(_MAX_PATH + 9);

        // First get the application name, this is either passed in from the host
        // or we get it from the image
        LPWSTR name = (LPWSTR) GetDefaultApplicationName();
        if (name == NULL) {
            WszGetModuleFileName(NULL, sFileName.String(), sFileName.MaxSize()); // get name of file used to create process
            name = sFileName.String();
        }

        
        CQuickString sPathName;
        CQuickString sConfigName;

        // Next check the Win32 information to see if we have a config file
        do {
            hr = GetConfigFileFromWin32Manifest(sConfigName.String(),
                                                sConfigName.MaxSize(),
                                                &len);
            if(FAILED(hr)) {
                if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                    sConfigName.ReSize(len);
                    hr = GetConfigFileFromWin32Manifest(sConfigName.String(),
                                                        sConfigName.MaxSize(),
                                                        &len);
                }
                if(FAILED(hr)) break;
            }
            
            hr = GetApplicationPathFromWin32Manifest(sPathName.String(),
                                                     sPathName.MaxSize(),
                                                     &len);
            if(FAILED(hr)) {
                if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                    sPathName.ReSize(len);
                    hr = GetApplicationPathFromWin32Manifest(sPathName.String(),
                                                             sPathName.MaxSize(),
                                                             &len);
                }
                if(FAILED(hr)) break;
            }
            
        } while(FALSE);
        
        if(FAILED(hr) || sConfigName.Size() == 0) 
        {
            // No Win32 configuration file, create one from the
            // application name by adding on .config to the 
            // end of the name.
            hr = S_OK;

            WCHAR tail[] = L".config";
            DWORD dwTail = sizeof(tail)/sizeof(WCHAR);
            len = wcslen(name);
            sConfigName.ReSize(len + dwTail);
            wcscpy(sConfigName.String(), name);
            wcscat(sConfigName.String(), tail);
        }
        else if (sPathName.Size() != 0) { 
            if(PathIsRelative(sConfigName.String())) {
                CQuickString sResult;
                sResult.ReSize(sConfigName.Size() + sPathName.Size());
                LPWSTR path = PathCombine(sResult.String(), sPathName.String(), sConfigName.String());
                if(path != NULL) {
                    DWORD length = wcslen(path) + 1;
                    sConfigName.ReSize(length);
                    wcscpy(sConfigName.String(), path);
                }
            }
        }    
        
        if(sConfigName.Size()) 
            SetAppConfig(sConfigName.String(), TRUE);
    }


    // Get the default values
    RuntimeRequest* alternativeVersion = g_PreferredVersion;
    if(alternativeVersion && (! (GetHostConfig() || GetAppConfig()) )) {
        if (alternativeVersion->GetHostConfig())
            SetHostConfig(alternativeVersion->GetHostConfig(), TRUE);
        else if (alternativeVersion->GetAppConfig())
            SetAppConfig(alternativeVersion->GetAppConfig(), TRUE);
    }


    // A. Determine the version to run
    do {
        // Sequence:
        //    1 - Supported Version from the config file
        //    2 - Required Version from the config file
        //    3 - Default version passed in from the host bind
        //    4 - Environment value
        //    5 - Ambient version set through the host bind
        //    6 - Version from the PE image file-name provided
        //    7 - Version from this process image
        
        // Start by loading the configuration file, if any
        /*hr = */GetRuntimeVersion();
        
        // 1 - If we have supported versions then check
        if(dwSupportedVersions != 0) {
            SetLatestVersion(FALSE);  // if they mention supported runtimes we do not default to the latest
            LPWSTR version = NULL;
            if (FindSupportedInstalledRuntime(&version)) {
                SetVersionToLoad(version, FALSE);
                break;
            }
            // Couldn't find one of these... fail
            break;
        }

        // 2 - Required runtime was obtained while getting the configuration file
        //     We can just leave if we have found one.
        if(GetVersionToLoad() != NULL) {

            // Make sure it's ok
            VerifyRuntimeVersionToLoad();            

            // Remap to standards
            LPWSTR policyVersion = NULL;
            if (SUCCEEDED(FindStandardVersion(GetVersionToLoad(), &policyVersion)) &&
                                    policyVersion != NULL)
            {                                    
                SetVersionToLoad(policyVersion,  FALSE);
            }
            break;
        }

        // 3. Host Supplied default version
        if (GetDefaultVersion())
        {
            SetVersionToLoad(GetDefaultVersion(), TRUE);
            VerifyRuntimeVersionToLoad(); 
            break;
        }
    
        // 4. Ambient value set by the host   
        if(alternativeVersion && alternativeVersion->GetDefaultVersion()) {
            SetVersionToLoad(alternativeVersion->GetDefaultVersion(), TRUE);
            VerifyRuntimeVersionToLoad(); 
            break;
        }

        // 5. Environment (Environment and Registry)
        SetVersionToLoad(GetConfigString(L"Version", FALSE), FALSE);
        if(GetVersionToLoad()) {
            VerifyRuntimeVersionToLoad(); 
            break;
        }

        // 6 & 7. The meta data version from an executable name or finally the process name.
        LPCWSTR exeFileName = GetDefaultApplicationName();
        if (exeFileName) {
            DWORD len = 0;
            if (GetFileVersion(exeFileName, NULL, 0, &len) == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
            {
                LPWSTR lpVersionName = (LPWSTR) alloca(len * sizeof(WCHAR));
                if (SUCCEEDED(GetFileVersion(exeFileName, lpVersionName, len, &len)))
                    SetVersionToLoad(lpVersionName, TRUE);
            }
        }
        else
        {
            LPCWSTR wszProcessVersion = GetProcessVersion();
            if (wszProcessVersion != NULL)
                SetVersionToLoad(wszProcessVersion, FALSE);
        }

        // If we were able to read something from the PE header...
        if (GetVersionToLoad())
        {
            VerifyRuntimeVersionToLoad(); 
            // Map to a standard
            LPWSTR policyVersion=NULL;
            if (SUCCEEDED(FindStandardVersion(GetVersionToLoad(), &policyVersion)))
                    SetVersionToLoad(policyVersion, FALSE);
                    
            // See if this version exists....
            if (IsRuntimeVersionInstalled(GetVersionToLoad())!=S_OK)
            {
                // Ok, this version doesn't exist. Try and find a compatible version
                LPWSTR upgradePolicyVersion = NULL;
                if (SUCCEEDED(FindVersionUsingUpgradePolicy(GetVersionToLoad(), &upgradePolicyVersion)) && upgradePolicyVersion != NULL)
                    SetVersionToLoad(upgradePolicyVersion, FALSE);
            }
        }
    } while (FALSE);

    // Verify the version results:  // Note: The version cannot be a relative path. 
    // It can only be a single directory. Remove any directory separator from the name.
    LPCWSTR versionTail = GetVersionToLoad();
    if(versionTail) {
        LPWSTR pSep = wcsrchr(versionTail, L'\\');
        if(pSep) 
            versionTail = ++pSep;
        pSep = wcsrchr(versionTail, L'/');
        if(pSep)
            versionTail = ++pSep;

        // ".." is not allowed
        while(*versionTail == L'.')
            versionTail++;

        if(versionTail != GetVersionToLoad() ) {
            if (*versionTail) 
                SetVersionToLoad(versionTail, TRUE);
            else 
                SetVersionToLoad(NULL, TRUE);
        }

    }

    // B. Check the Image version
    // Sequence:
    //    1 - Configuration file
    //    2 - Default image version passed in from the host
    //    3 - ambient image version set by the host.
    //
    // 1 & 2
    // The image version was either set prior to this method or
    // it was overriden by reading the configuration file.
    if(GetImageVersion() == NULL && alternativeVersion) {
        // 3
        if(alternativeVersion->GetImageVersion()) 
            SetImageVersion(alternativeVersion->GetImageVersion(), TRUE);
    }

    // C. The Build Flavor
    // Sequence:
    //    1 - Configuration file
    //    2 - Default build flavor passed in from the host
    //    3 - Environment 
    //    4 - ambient build flavor set by the host.
    //
    // 1 & 2
    // The build flavor was either set prior to this method or
    // it was overriden by reading the configuration file.
    if(GetBuildFlavor() == NULL) {
        // 3 - Note: Do not Search Registry for Flavor
        SetBuildFlavor(GetConfigString(L"BuildFlavor", FALSE), FALSE); 
        // 4 - ambient value
        if(GetBuildFlavor() == NULL &&
           alternativeVersion != NULL &&
           alternativeVersion->GetBuildFlavor() != NULL)
            SetBuildFlavor(alternativeVersion->GetBuildFlavor(), TRUE);
    }

    if(GetVersionToLoad() == NULL) {
        if(GetLatestVersion()) {
            LPWSTR latestVersion = NULL;
            //@TODO: add this back in
            hr = FindLatestVersion(&latestVersion);
            if(SUCCEEDED(hr)) SetVersionToLoad(latestVersion, FALSE);
        }
    }

    // Dev machines require that we look at the override key
    
    LPWSTR overrideVersion = NULL;
    if (GetVersionToLoad() != NULL &&
        SUCCEEDED(FindOverrideVersion(GetVersionToLoad(), &overrideVersion))) {
        SetVersionToLoad(overrideVersion, FALSE);
    }
    
    if(FAILED(hr) || GetVersionToLoad() == NULL || IsRuntimeVersionInstalled(GetVersionToLoad())!=S_OK) 
        return NoSupportedVersion(fShowErrorDialog);

    return hr;
}

LPWSTR RuntimeRequest::BuildRootPath()
{
    WCHAR szFileName[_MAX_PATH];
    DWORD length = WszGetModuleFileName(g_hShimMod, szFileName, _MAX_PATH);
    LPWSTR rootPath = UseLocalRuntime() ? NULL : GetConfigString(L"InstallRoot", TRUE);
    
    if (!rootPath || *rootPath == L'\x0')
    {
        g_fInstallRootSet = FALSE;
        //
        // If rootPath is null make rootpath = dir of mscoree.dll
        //    
        if (length)
        {
            LPWSTR pSep = wcsrchr(szFileName, L'\\');
            if (pSep)
            {
                _ASSERTE(pSep > szFileName);
                length = pSep - szFileName;
                rootPath = new WCHAR[length + 1];
                wcsncpy(rootPath, szFileName, length);
                rootPath[length] = L'\x0';
            }
            
        }
    }
    return rootPath;
}

HRESULT RuntimeRequest::FindVersionedRuntime(BOOL fShowErrorDialog, BOOL* pLoaded)
{
    HRESULT hr = S_OK;
    LPWSTR pFileName = NULL;

    if(g_FullPath) return S_OK;

    OnUnicodeSystem();

    LPWSTR rootPath = BuildRootPath();
    
    WCHAR errorBuf[ERROR_BUF_LEN] ={0};
    WCHAR errorCaption[ERROR_BUF_LEN] ={0};
    if(rootPath == NULL) {
        //Check for Install Root. 
        if (fShowErrorDialog && !(REGUTIL::GetConfigDWORD(L"NoGuiFromShim", FALSE))) {             
            UINT last = SetErrorMode(0);
            SetErrorMode(last);     //Set back to previous value
            if (!(last & SEM_FAILCRITICALERRORS)){ // Display Message box only if FAILCRITICALERRORS set
                VERIFY(WszLoadString(GetResourceInst(), SHIM_INSTALLROOT, errorBuf, ERROR_BUF_LEN) > 0 ); 
                VERIFY(WszLoadString(GetResourceInst(), SHIM_INITERROR, errorCaption, ERROR_BUF_LEN) > 0 );
                WszMessageBoxInternal(NULL, errorBuf, errorCaption, MB_OK | MB_ICONSTOP);
            }
        }
        hr = CLR_E_SHIM_INSTALLROOT;
    }
    else {
        
        // Compute the version that will load from the root path.
        hr = ComputeVersionString(fShowErrorDialog);

        // @TODO. In certain cases we can have multiple versions and we need to try
        //        each one.
        if(SUCCEEDED(hr)) 
            hr = LoadVersionedRuntime(rootPath, 
                                      NULL,
                                      pLoaded);
        if(FAILED(hr))
            hr = CLR_E_SHIM_RUNTIMELOAD;
    }

    //
    //  Cleanup strings.
    //
    if(rootPath) delete [] rootPath;

    return hr;
}

HRESULT RuntimeRequest::RequestRuntimeDll(BOOL fShowErrorDialog, BOOL* pLoaded)
{
    if (g_FullPath != NULL)
        return S_OK;

    BOOL Loaded = FALSE;
    HRESULT hr = FindVersionedRuntime(fShowErrorDialog, &Loaded);
    if(SUCCEEDED(hr) && Loaded)
        InterlockedIncrement((LPLONG)&g_numLoaded);

    if(pLoaded) *pLoaded = Loaded;
    return hr;
}

void RuntimeRequest::VerifyRuntimeVersionToLoad()
{
    if (ShouldConvertVersionToV1(GetVersionToLoad()))
        SetVersionToLoad(V1_VERSION_NUM, TRUE);
}// VerifyRuntimeToLoadVersion


static void VerifyVersionInput(RuntimeRequest* pReq, LPCWSTR lpVersion)
{
    if (ShouldConvertVersionToV1(lpVersion))
        pReq->SetDefaultVersion(V1_VERSION_NUM, TRUE);
    else
        pReq->SetDefaultVersion(lpVersion, TRUE);

    return;
}// VerifyVersionInput


static BOOL ShouldConvertVersionToV1(LPCWSTR lpVersion)
{
    BOOL fConvert = FALSE;

    if(lpVersion != NULL) {
        if(wcsstr(lpVersion, L"1.0.3705") != NULL)
        {
            if(*lpVersion == L'v' || 
               *lpVersion == L'V' ||
               wcscmp(lpVersion, L"1.0.3705.0") == 0 ||
               wcscmp(lpVersion, L"1.0.3705") == 0)
                fConvert = TRUE;
        }
        else if(wcsstr(lpVersion, L"1.0.3300") != NULL)
        {
            if(*lpVersion == L'v' || 
               *lpVersion == L'V' ||
               wcscmp(lpVersion, L"1.0.3300.0") == 0 ||
               wcscmp(lpVersion, L"1.0.3300") == 0)
                fConvert = TRUE;
                
        }

        // Revisit this decision
        else if(wcsncmp(lpVersion,L"v1.0",4)==0)
            fConvert = TRUE;
    }

    return fConvert;
}


HRESULT GetQualifiedStrongName()
{
    if(g_FullStrongNamePath) 
        return S_OK;

    HRESULT hr;
    HINSTANCE hInst;
    hr = GetRealDll(&hInst);
    if(FAILED(hr)) return hr;

    LPWSTR fullStrongNamePath = new WCHAR[wcslen(g_Directory) + 12];
    if (fullStrongNamePath == NULL)
        return E_OUTOFMEMORY;

    wcscpy(fullStrongNamePath, g_Directory);
    wcscat(fullStrongNamePath, L"mscorsn.dll");

    LPWSTR oldPath = (LPWSTR)InterlockedCompareExchangePointer((PVOID *)&g_FullStrongNamePath, fullStrongNamePath, NULL);
    //  Another thread already created the full strong name path
    if( oldPath != NULL)  
        delete [] fullStrongNamePath;
    
    return hr;
}

HRESULT GetDirectoryLocation(LPCWSTR lpVersion, LPWSTR outStr, DWORD dwLength)
{
    RuntimeRequest sVersion;
    VerifyVersionInput(&sVersion, lpVersion);
    sVersion.SetLatestVersion(TRUE);
    HRESULT hr = sVersion.FindVersionedRuntime(FALSE, NULL);
    if(SUCCEEDED(hr)) 
    {
        if(g_Directory == NULL) 
            hr = CLR_E_SHIM_RUNTIMELOAD;
        else {
            DWORD lgth = wcslen(g_Directory) + 1;
            if(lgth > dwLength) 
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            else 
                CopyMemory(outStr, g_Directory, lgth*sizeof(WCHAR));
        }       
    } 
    return hr;
}
    
HRESULT GetRealDll(HINSTANCE* pInstance,
                   BOOL fShowErrorDialog)
{
    _ASSERTE(pInstance);

    RuntimeRequest sVersion;
    sVersion.SetLatestVersion(TRUE);
    HRESULT hr = sVersion.RequestRuntimeDll(fShowErrorDialog, NULL);
    
    if(SUCCEEDED(hr))
        hr = GetInstallation(fShowErrorDialog, pInstance);
    return hr;
}

HRESULT GetRealDll(HINSTANCE* pInstance)
{
    return GetRealDll(pInstance, TRUE);
}



HRESULT GetRealStrongNameDll(HINSTANCE* phMod)
{
    _ASSERTE(phMod);
    if (g_hStrongNameMod != NULL)
    {
        *phMod = g_hStrongNameMod;
        return S_OK;
    }

    HRESULT hr = GetQualifiedStrongName();
    if(SUCCEEDED(hr)) {
        g_hStrongNameMod = WszLoadLibrary(g_FullStrongNamePath);
        *phMod = g_hStrongNameMod;

        if (!g_hStrongNameMod)
        {
#ifdef _DEBUG
            wprintf(L"%s not found\n", g_FullStrongNamePath);
#endif
            hr = CLR_E_SHIM_INSTALLCOMP;
        }
        else 
            InterlockedIncrement((LPLONG)&g_numStrongNameLoaded);
        
    }
    return hr;

}


STDAPI CorBindToRuntimeByPath(LPCWSTR swzFullPath, BOOL *pBindSuccessful)
{
    OnUnicodeSystem();
    
    g_fSetDefault = TRUE;
    RuntimeRequest sVersion;
    sVersion.SetStartupFlags(STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST);
    return (sVersion.LoadVersionedRuntime(NULL, (LPWSTR) swzFullPath,  pBindSuccessful));
}


STDAPI CorBindToRuntime(LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv)
{

    g_fSetDefault = TRUE;
    
    DWORD flags = STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST;
    return CorBindToRuntimeEx(pwszVersion, pwszBuildFlavor,  flags, rclsid, riid, ppv);
}

STDAPI CorBindToRuntimeHostInternal(BOOL fUseLatest, LPCWSTR pwszVersion, LPCWSTR pwszImageVersion, 
                                    LPCWSTR pwszBuildFlavor, LPCWSTR pwszHostConfigFile, 
                                    VOID* pReserved, DWORD flags, 
                                    REFCLSID rclsid, REFIID riid, 
                                    LPVOID FAR *ppv)
{

    if (g_FullPath == NULL && flags & STARTUP_LOADER_SETPREFERENCE)
    {
        if(g_PreferredVersion != NULL) 
            return E_INVALIDARG;

        // do not do anything, just set overrides for GetRealDll
        RuntimeRequest* pRequest = new RuntimeRequest();
        if(pRequest == NULL) return E_OUTOFMEMORY;

        pRequest->SetImageVersion(pwszImageVersion, TRUE);
        VerifyVersionInput(pRequest, pwszVersion);
        pRequest->SetLatestVersion(fUseLatest);
        pRequest->SetBuildFlavor(pwszBuildFlavor, TRUE);
        pRequest->SetHostConfig(pwszHostConfigFile, TRUE);
        pRequest->SetStartupFlags((DWORD) flags);
        pRequest->SetSupportedRuntimeSafeMode((flags & STARTUP_LOADER_SAFEMODE) != 0 ? TRUE : FALSE);

        InterlockedExchangePointer(&(g_PreferredVersion), pRequest);
        return S_OK;
    }

    RuntimeRequest sRequest;

    sRequest.SetImageVersion(pwszImageVersion, TRUE);
    VerifyVersionInput(&sRequest, pwszVersion);
    sRequest.SetLatestVersion(fUseLatest);
    sRequest.SetBuildFlavor(pwszBuildFlavor, TRUE);
    sRequest.SetHostConfig(pwszHostConfigFile, TRUE);
    sRequest.SetStartupFlags((DWORD) flags);

    BOOL fRequestedSafeMode = (flags & STARTUP_LOADER_SAFEMODE) != 0 ? TRUE : FALSE;
    sRequest.SetSupportedRuntimeSafeMode(fRequestedSafeMode);

    BOOL Loaded = FALSE;
    HRESULT hr = S_OK;

    if (g_FullPath == NULL) 
    {
        OnUnicodeSystem();
        hr = sRequest.RequestRuntimeDll(TRUE, &Loaded);
    }

    if(SUCCEEDED(hr)) 
    {
        HMODULE hMod = NULL;
        hr = GetInstallation(TRUE, &hMod);
        if(SUCCEEDED(hr)) {
            HRESULT (STDMETHODCALLTYPE * pDllGetClassObject)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv) = 
                (HRESULT (STDMETHODCALLTYPE *)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv))GetProcAddress(hMod, "DllGetClassObjectInternal");

            if (pDllGetClassObject==NULL && GetLastError()==ERROR_PROC_NOT_FOUND)
                 pDllGetClassObject=(HRESULT (STDMETHODCALLTYPE *)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv))GetProcAddress(hMod, "DllGetClassObject");

            if (pDllGetClassObject) {
                IClassFactory *pFactory = NULL;
                hr = pDllGetClassObject(rclsid, IID_IClassFactory, (void**)&pFactory);              //Get ClassFactory to return instance of interface
                if (SUCCEEDED(hr)){                                                                 //Check if we got Class Factory
                    hr = pFactory->CreateInstance(NULL, riid, ppv);                                 //Create instance of required interface
                    pFactory->Release();                                                            //Release IClassFactory
                }
            }
            else {
                hr = CLR_E_SHIM_RUNTIMEEXPORT;
            }
        }
    }
    
    // Return S_FALSE when this call did not load the library
    if(hr == S_OK && Loaded == FALSE) hr = S_FALSE;
    return hr;
}

STDAPI CorBindToRuntimeEx(LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor, DWORD flags, REFCLSID rclsid, 
                          REFIID riid, LPVOID FAR *ppv)
{
    return CorBindToRuntimeHostInternal(TRUE,
                                        pwszVersion,
                                        NULL,
                                        pwszBuildFlavor,
                                        NULL,
                                        NULL,
                                        flags,
                                        rclsid,
                                        riid,
                                        ppv);
}

STDAPI CorBindToRuntimeByCfg(IStream* pCfgStream, DWORD reserved, DWORD flags, REFCLSID rclsid,REFIID riid, LPVOID FAR* ppv)
{
    /// reserved might become bAsyncStream
    HRESULT hr = S_OK;
    if (pCfgStream==NULL||ppv==NULL)    
        return E_POINTER;

    LPWSTR wszVersion=NULL;
    LPWSTR wszImageVersion=NULL;
    LPWSTR wszBuildFlavor=NULL;
    BOOL bSafeMode;

    hr=XMLGetVersionFromStream(pCfgStream, 
                               reserved, &wszVersion, 
                               &wszImageVersion, 
                               &wszBuildFlavor, 
                               &bSafeMode,
                               NULL);
    if (SUCCEEDED(hr))
        hr = CorBindToRuntimeHostInternal(FALSE, wszVersion, wszImageVersion, wszBuildFlavor, NULL, NULL,
                                          bSafeMode ? flags|STARTUP_LOADER_SAFEMODE : flags, 
                                          rclsid, riid, ppv);
    
    if (wszVersion)
        delete[] wszVersion;
    if(wszImageVersion)
        delete[] wszImageVersion;
    if (wszBuildFlavor)
        delete[] wszBuildFlavor;
    return hr;
}

STDAPI CorBindToRuntimeHost(LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor, LPCWSTR pwszHostConfigFile, 
                            VOID* pReserved, DWORD flags, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv)
{
  return CorBindToRuntimeHostInternal(FALSE, pwszVersion, NULL, 
                                      pwszBuildFlavor, pwszHostConfigFile, 
                                      pReserved, flags, 
                                      rclsid, riid, 
                                      ppv);
}

//Returns a version of the runtime from an ini file. If no version info found in the ini file 
//returns the default version
STDAPI CorBindToCurrentRuntime(LPCWSTR pwszFileName, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv)
{
    BOOL Loaded = FALSE;
    HRESULT hr = S_OK;

    if (g_FullPath == NULL) {
        OnUnicodeSystem();
        
        HINSTANCE hMod = NULL;
        RuntimeRequest sVersion;
        sVersion.SetHostConfig(pwszFileName, TRUE);
        sVersion.SetLatestVersion(TRUE);
        hr = sVersion.RequestRuntimeDll(TRUE, &Loaded);
    }

    if(SUCCEEDED(hr))
    {
        HMODULE hMod = NULL;
        hr = GetInstallation(TRUE, &hMod);
        if(SUCCEEDED(hr)) {

            HRESULT (STDMETHODCALLTYPE * pDllGetClassObject)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv) = 
                (HRESULT (STDMETHODCALLTYPE *)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv))GetProcAddress(hMod, "DllGetClassObjectInternal");

            if (pDllGetClassObject==NULL && GetLastError()==ERROR_PROC_NOT_FOUND)
                 pDllGetClassObject=(HRESULT (STDMETHODCALLTYPE *)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv))GetProcAddress(hMod, "DllGetClassObject");

            if (pDllGetClassObject){
                IClassFactory *pFactory = NULL;
                hr = pDllGetClassObject(rclsid, IID_IClassFactory, (void**)&pFactory);              //Get ClassFactory to return instance of interface
                if (SUCCEEDED(hr)){                                                                 //Check if we got Class Factory
                    hr = pFactory->CreateInstance(NULL, riid, ppv);                                 //Create instance of required interface
                    pFactory->Release();                                                            //Release IClassFactory
                }
            }
            else {
                hr = CLR_E_SHIM_RUNTIMEEXPORT;
            }
        }
    }

    // Return S_FALSE when this call did not load the library
    if(hr == S_OK && Loaded == FALSE) hr = S_FALSE;
    return hr;
}

// Returns the image version that was established when the runtime was started.
// This API is designed for unmanaged compiler to get access to the version
// information that should be emitted into the metadata signature. Starts the
// runtime.
STDAPI GetCORRequiredVersion(LPWSTR pbuffer, DWORD cchBuffer, DWORD* dwlength)
{
    HRESULT hr;
    OnUnicodeSystem();

    if(dwlength == NULL)
        return E_POINTER;

    HMODULE hMod;
    hr = GetInstallation(TRUE, &hMod);
    DWORD lgth = 0;
    if(SUCCEEDED(hr)) {
        if(g_ImageVersion) {
            lgth = (DWORD)(wcslen(g_ImageVersion) + 1);
            if(lgth > cchBuffer) 
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            else 
                wcsncpy(pbuffer, g_ImageVersion, lgth);
        }
        else 
            hr = GetCORVersion(pbuffer, cchBuffer, &lgth);
    }
    *dwlength = lgth;
    return hr;
}

STDAPI GetCORVersion(LPWSTR szBuffer, 
                     DWORD cchBuffer,
                     DWORD* dwLength)
{
    HRESULT hr = S_OK;
    OnUnicodeSystem();

    if(!dwLength)
        return E_POINTER;

    if(!g_hMod) {
        RuntimeRequest sVersion;
        sVersion.SetLatestVersion(TRUE);
        hr = sVersion.RequestRuntimeDll(TRUE, NULL);
        if(FAILED(hr)) return hr;
    }

    DWORD lgth = 0;
    if(SUCCEEDED(hr)) {
        if(g_Version) {
            lgth = (DWORD)(wcslen(g_Version) + 1);
            if(lgth > cchBuffer) 
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            else 
                wcsncpy(szBuffer, g_Version, lgth);
        }
    }
    *dwLength = lgth;
    return hr;
}

STDAPI GetRequestedRuntimeInfo(LPCWSTR pExe, 
                               LPCWSTR pwszVersion,
                               LPCWSTR pConfigurationFile, 
                               DWORD startupFlags,
                               DWORD reserved, 
                               LPWSTR pDirectory, 
                               DWORD dwDirectory, 
                               DWORD *dwDirectoryLength, 
                               LPWSTR pVersion, 
                               DWORD cchBuffer, 
                               DWORD* dwlength)
{

    HRESULT hr = S_OK;

    DWORD pathLength = 0;
    DWORD versionLength = 0;
    LPCWSTR szRootPath = NULL;

    OnUnicodeSystem();

    RuntimeRequest sVersion;
    if(pExe)
        sVersion.SetDefaultApplicationName(pExe, TRUE);
    if(pConfigurationFile)
        sVersion.SetAppConfig(pConfigurationFile, TRUE);
    if(pwszVersion)
        VerifyVersionInput(&sVersion, pwszVersion);

    sVersion.SetStartupFlags(startupFlags);

    hr = sVersion.ComputeVersionString(TRUE);
    if(SUCCEEDED(hr))
    {
        szRootPath = sVersion.BuildRootPath();
        LPCWSTR szRealV = sVersion.GetVersionToLoad();
        
        // See if they gave us enough buffer space
        if(szRealV) 
            pathLength = (DWORD)(wcslen(szRealV) + 1);

        if(pathLength > cchBuffer) 
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        else if(pVersion && pathLength > 0)
            wcsncpy(pVersion, szRealV, pathLength);

        if(szRootPath)
            versionLength = (DWORD) wcslen(szRootPath) + 1;

        if(versionLength > dwDirectory)
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        else if(pDirectory && versionLength > 0)
            wcsncpy(pDirectory, szRootPath, versionLength);
            
    }
    if(dwlength)
        *dwlength = pathLength;
    if(dwDirectoryLength)
        *dwDirectoryLength = versionLength;

    if(szRootPath != NULL) delete [] szRootPath;

    return hr;
}



// This function will determine which version of the runtime the
// specified assembly exe requests
STDAPI GetRequestedRuntimeVersion(LPWSTR pExe,
                                  LPWSTR pVersion, /* out */ 
                                  DWORD  cchBuffer,
                                  DWORD* dwlength)
{
    DWORD lgth = 0;
    HRESULT hr = S_OK;

    OnUnicodeSystem();

    if (dwlength == NULL)
        return E_POINTER;


    RuntimeRequest sVersion;
    sVersion.SetDefaultApplicationName(pExe, TRUE);
    hr = sVersion.ComputeVersionString(FALSE);

    if (FAILED(hr))
    {
        // Ok, we failed, because we couldn't find a version of the runtime that existed on the machine
        // that the app wanted. Still, let's return the version that the app really wants.

        // We determined a version to load... big deal if it doesn't exist.
        if (sVersion.GetVersionToLoad() != NULL)
            hr = S_OK;


        // We weren't able to find a version to load. Let's grab a supported runtime instead.
        else if (sVersion.GetSupportedVersionsSize() > 0)
        {
            LPWSTR policyVersion = NULL;
            LPWSTR versionToUse = NULL;
            LPWSTR* supportedVersions = sVersion.GetSupportedVersions();

            if(sVersion.GetSupportedRuntimeSafeMode() == FALSE &&
               SUCCEEDED(FindStandardVersion(supportedVersions[0], &policyVersion)) &&
               policyVersion != NULL)
                versionToUse = policyVersion;
            else 
                versionToUse = supportedVersions[0];

            sVersion.SetVersionToLoad(versionToUse, TRUE);

            if (policyVersion)
                delete[] policyVersion;

            hr = S_OK;    
        }
    }



    
    if(SUCCEEDED(hr))
    {
        LPCWSTR szRealV = sVersion.GetVersionToLoad();
        
        // See if they gave us enough buffer space
        lgth = (DWORD)(wcslen(szRealV) + 1);
        if(lgth > cchBuffer) 
            hr =  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        else 
            wcsncpy(pVersion, szRealV, lgth);
    }
    *dwlength = lgth;
    return hr;
} // GetRequestedRuntimeVersion

// This function will determine which version of the runtime the
// specified shim hosted COM object requests
//
// All lengths include the NULL character

STDAPI GetRequestedRuntimeVersionForCLSID(REFCLSID rclsid,
                                          LPWSTR pVersion, /* out */ 
                                          DWORD  cchBuffer, 
                                          DWORD* dwlength, /* out */
                                          CLSID_RESOLUTION_FLAGS dwResolutionFlags) 
{
    HRESULT hr = S_OK;
    RuntimeRequest sVersion;
    DWORD lgth = 0;
    LPCWSTR szVersion = NULL;
    LPWSTR szRealV = NULL;
    HKEY hCLSID = NULL;

    OnUnicodeSystem();

    if (dwlength == NULL)
        return E_POINTER;

    // Check to see that the CLSID is registered

    WCHAR wszCLSID[64];
    WCHAR wszKeyName[128];
    DWORD type;
    DWORD size;

    if (GuidToLPWSTR(rclsid, wszCLSID, NumItems(wszCLSID)) == 0)
    {
        hr = E_INVALIDARG;
        goto ErrExit;
    }
    // Our buffer should be big enough....
    _ASSERTE((wcslen(L"CLSID\\") + wcslen(wszCLSID) + wcslen(L"\\InprocServer32")) < NumItems(wszKeyName));
    
    wcscpy(wszKeyName, L"CLSID\\");
    wcscat(wszKeyName, wszCLSID);
    wcscat(wszKeyName, L"\\InprocServer32");
    
    if ((WszRegOpenKeyEx(HKEY_CLASSES_ROOT, wszKeyName, 0, KEY_READ, &hCLSID) != ERROR_SUCCESS) ||
        (WszRegQueryValueEx(hCLSID, NULL, 0, &type, 0, &size) != ERROR_SUCCESS) || 
        type != REG_SZ || size == 0) 
    {
        hr = REGDB_E_CLASSNOTREG;
        goto ErrExit;
    }

    switch(dwResolutionFlags)
    {
        case CLSID_RESOLUTION_REGISTERED:
        
            // Try to find the version in the activation context or the registry
            hr = FindVersionForCLSID(rclsid, &szRealV, TRUE);

            // Make sure we don't leak memory
            _ASSERT(SUCCEEDED(hr) || szRealV == NULL);

            if(SUCCEEDED(hr) && szRealV != NULL) 
                szVersion = szRealV;

            if (SUCCEEDED(hr))
                break;

            // Fall through if we failed the FindVersionForCLSID call
                        
        case CLSID_RESOLUTION_DEFAULT:
        
            // We allow latest version for COM
            sVersion.SetLatestVersion(TRUE);
            hr = sVersion.ComputeVersionString(TRUE);
            szVersion = sVersion.GetVersionToLoad();
            break;
            
         default:   
            // We don't understand/support this value
            hr = E_INVALIDARG;
            goto ErrExit;
    }
    
    if(SUCCEEDED(hr))
    {
        // See if they gave us enough buffer space
        _ASSERTE(szVersion != NULL);
        lgth = (DWORD) (wcslen(szVersion) + 1);
        if(lgth > cchBuffer) 
            hr =  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        else 
            wcsncpy(pVersion, szVersion, lgth);
        
    }
    *dwlength = lgth;

ErrExit:

    if(hCLSID != NULL)
        RegCloseKey(hCLSID);

    if(szRealV)
        delete[] szRealV; 

    return hr;

} // GetRequestedRuntimeVersionForCLSID



static
HRESULT CopySystemDirectory(WCHAR* pPath,
                            LPWSTR pbuffer, 
                            DWORD  cchBuffer,
                            DWORD* dwlength)
{
    HRESULT hr = S_OK;
    if(pPath == NULL) 
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    DWORD dwPath = wcslen(pPath);
    LPWSTR pSep = wcsrchr(pPath, L'\\');
    if(pSep) {
        dwPath = (DWORD)(pSep-pPath+1);
        pPath[dwPath] = L'\0';
    }

    dwPath++; // Add back in the null
    *dwlength = dwPath;
    if(dwPath > cchBuffer)
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    else {
        CopyMemory(pbuffer, 
                   pPath,
                   dwPath*sizeof(WCHAR));
    }
    return hr;
}

    
STDAPI GetCORSystemDirectory(LPWSTR pbuffer, 
                             DWORD  cchBuffer,
                             DWORD* dwlength)
{
    HRESULT hr;

    if(dwlength == NULL)
        return E_POINTER;

    WCHAR pPath[MAX_PATH];
    DWORD dwPath = MAX_PATH;
    if(g_hMod) {
        dwPath = WszGetModuleFileName(g_hMod, pPath, dwPath);
        if(dwPath == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (SUCCEEDED(hr)) // GetLastError doesn't always do what we'd like
                hr = E_FAIL;
            return (hr);
        }
        else 
            return CopySystemDirectory(pPath, pbuffer, cchBuffer, dwlength);
    }

    RuntimeRequest sVersion;
    sVersion.SetLatestVersion(TRUE);
    hr = sVersion.RequestRuntimeDll(TRUE, NULL);
    if(FAILED(hr)) return hr;

    if(g_FullPath) {
        DWORD attr = WszGetFileAttributes(g_FullPath);
        if(attr != 0xFFFFFFFF) {
            // We are expecting g_FullPath to be no more than MAX_PATH
            // This assert enforces the check at the end of LoadVersionedRuntime
            _ASSERTE(wcslen(g_FullPath) < MAX_PATH);
            
            wcscpy(pPath, g_FullPath);
            return CopySystemDirectory(pPath, pbuffer, cchBuffer, dwlength);
        }
    }
     
    if(g_BackupPath) {
        DWORD attr = WszGetFileAttributes(g_BackupPath);
        if(attr != 0xFFFFFFFF) {
            // We are expecting g_FullPath to be no more than MAX_PATH
            // This assert enforces the check at the end of LoadVersionedRuntime
            _ASSERTE(wcslen(g_BackupPath) < MAX_PATH);
            
            wcscpy(pPath, g_BackupPath);
            return CopySystemDirectory(pPath, pbuffer, cchBuffer, dwlength);
        }
    }
    
    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
}

int STDMETHODCALLTYPE GetStartupFlags()
{
    return g_StartupFlags;
}

// Returns the number of characters copied (including the NULL)
STDAPI GetHostConfigurationFile(LPWSTR pName, DWORD* pdwName)
{
    if(pdwName == NULL) return E_POINTER;

    if(g_pHostConfigFile) {
        if(*pdwName < g_dwHostConfigFile) {
            *pdwName = g_dwHostConfigFile;
            return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        else {
            if(pName == NULL) return E_POINTER;
            memcpy(pName, g_pHostConfigFile, sizeof(WCHAR)*g_dwHostConfigFile);
            *pdwName = g_dwHostConfigFile;
        }
    }

    return S_OK;
}

STDAPI GetRealProcAddress(LPCSTR pwszProcName, VOID** ppv)
{
    if(!ppv) {
        return E_POINTER;
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealDll(&hReal);
    if(SUCCEEDED(hr)) {
        *ppv = GetProcAddress(hReal, pwszProcName);
        if(*ppv == NULL) hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

STDAPI LoadLibraryWithPolicyShim(LPCWSTR szDllName, LPCWSTR szVersion,  BOOL bSafeMode, HMODULE *phModDll)
{
    LPWSTR szRealV=NULL;
    LPWSTR szReqlV=NULL;

    RuntimeRequest sVersion;
    VerifyVersionInput(&sVersion, szVersion);
    sVersion.SetSupportedRuntimeSafeMode(bSafeMode);
    sVersion.SetLatestVersion(TRUE);
    HRESULT hr = sVersion.ComputeVersionString(TRUE);
    if(SUCCEEDED(hr))
    {
        hr = LoadLibraryShim(szDllName, sVersion.GetVersionToLoad(), NULL, phModDll);
    };
    return hr;
}

typedef HRESULT(*PFNRUNDLL32API)(HWND, HINSTANCE, LPWSTR, INT);

// ---------------------------------------------------------------------------
// LoadLibraryShim
// ---------------------------------------------------------------------------
STDAPI LoadLibraryShim(LPCWSTR szDllName, LPCWSTR szVersion, LPVOID pvReserved, HMODULE *phModDll)
{
    if (szDllName == NULL)
        return E_POINTER;

    HRESULT hr;
    HMODULE hModDll;

    WCHAR szDllPath[MAX_PATH]; 
    DWORD ccPath;
    if (UseLocalRuntime())    
        szVersion=NULL;

    if(szVersion) {
        LPWSTR rootPath = GetConfigString(L"InstallRoot", TRUE);

        wcscpy(szDllPath, L"");
        DWORD dwLength = (rootPath == NULL ? 0 : wcslen(rootPath));
        // Check the total length we need to enforce
        if (dwLength + wcslen(szVersion) + 3 >= MAX_PATH) {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            delete [] rootPath;
            goto exit;
        }
        if(rootPath) {            
            wcscat(szDllPath, rootPath);
            delete [] rootPath;
        }
        wcscat(szDllPath, L"\\");
        wcscat(szDllPath, szVersion);
        wcscat(szDllPath, L"\\");
        ccPath = wcslen(szDllPath) + 1;
    }
    else {
        WCHAR dir[MAX_PATH];
        if(FAILED(hr = GetDirectoryLocation(NULL, dir, MAX_PATH)))
            goto exit;
        ccPath = wcslen(dir) + 1;
        if(ccPath >= MAX_PATH) {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
            goto exit;
        }
        CopyMemory(szDllPath, dir, sizeof(WCHAR) * ccPath);
    }

    DWORD dllLength = wcslen(szDllName);
    if(ccPath+dllLength >= MAX_PATH) {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto exit;
    }
    wcscat(szDllPath, szDllName);
    
    hModDll = LoadLibraryWrapper(szDllPath);

    if (!hModDll) {
        hr = E_HANDLE;
        goto exit;
    }

    hr = S_OK;
    *phModDll = hModDll;
    
exit:
    return hr;
}

typedef HRESULT(*PFCREATEASSEMBLYNAMEOBJECT)(LPASSEMBLYNAME*, LPCWSTR, DWORD, LPVOID);
// ---------------------------------------------------------------------------
// RunDll32Shim
// ---------------------------------------------------------------------------
STDAPI RunDll32ShimW(HWND hwnd, HINSTANCE hinst, LPCWSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;
    
    PFNRUNDLL32API pfnRunDll32API = NULL;
    PFCREATEASSEMBLYNAMEOBJECT pfCreateAssemblyNameObject;

    HMODULE hModDll = NULL;
    
    IAssemblyName *pName = NULL;
    
    LPWSTR pszBeginName = NULL, pszEndName = NULL,
        pszAPI = NULL, pszCmd = NULL;

    WCHAR szDllName[MAX_PATH], *szCmdLine = NULL;
    
    DWORD ccCmdLine = 0, cbDllName = MAX_PATH * sizeof(WCHAR), 
        dwVerHigh = 0, dwVerLow = 0;
    
    
    // Get length of cmd line.
    ccCmdLine = (lpszCmdLine ? wcslen(lpszCmdLine) : 0);
    if (!ccCmdLine)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
        
    // Allocate and make local copy.
    szCmdLine = new WCHAR[ccCmdLine + 1];
    if (!szCmdLine)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    memcpy(szCmdLine, lpszCmdLine, (ccCmdLine + 1) * sizeof(WCHAR));

    // Parse out the assembly name which is scoped by the first quoted string.
    pszBeginName = wcschr(szCmdLine, L'\"');
    if(!pszBeginName) {
        hr = E_INVALIDARG;
        goto exit;
    }
        
    pszEndName   = wcschr(pszBeginName + 1, L'\"');    
    if (!pszEndName)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Null terminate the name.
    *pszEndName = L'\0';
    
    // Get api string stripping leading ws.
    pszAPI = pszEndName+1;
    while (*pszAPI && (*pszAPI == L' ' || *pszAPI == L'\t'))
        pszAPI++;    
    
    // Get cmd string, null terminating api string.
    pszCmd = pszAPI+1;
    while (*pszCmd && !(*pszCmd == L' ' || *pszCmd == L'\t'))
        pszCmd++;
    *pszCmd = L'\0';
    pszCmd++;

    // Convert unicode api to ansi api for GetProcAddress
    long cAPI = wcslen(pszAPI);
    cAPI = (long)((cAPI + 1) * 2 * sizeof(char));
    LPSTR szAPI = (LPSTR) alloca(cAPI);
    if (!WszWideCharToMultiByte(CP_ACP, 0, pszAPI, -1, szAPI, cAPI-1, NULL, NULL))
    {
        hr = E_FAIL;
        goto exit;
    }

    if (FAILED(hr = LoadLibraryShim(L"Fusion.dll", NULL, NULL, &g_hFusionMod)))
        goto exit;
        
    // Get the proc address for CreateAssemblyName from fusion
    pfCreateAssemblyNameObject = (PFCREATEASSEMBLYNAMEOBJECT) GetProcAddress(g_hFusionMod, "CreateAssemblyNameObject");
    if (!pfCreateAssemblyNameObject)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Create a name object.
    if (FAILED(hr = (pfCreateAssemblyNameObject)(&pName, pszBeginName+1, 
        CANOF_PARSE_DISPLAY_NAME, NULL)))
        goto exit;

    // Get the dll name.
    if (FAILED(hr = pName->GetName(&cbDllName, szDllName)))
        goto exit;

    // Get the dll version.
    if (FAILED(hr = pName->GetVersion(&dwVerHigh, &dwVerLow)))
        goto exit;

    // Get the dll hmod
    if (FAILED(hr = LoadLibraryShim(szDllName, NULL, NULL, &hModDll)))
        goto exit;
        
    // Get the proc address.
    pfnRunDll32API = (PFNRUNDLL32API) GetProcAddress(hModDll, szAPI);
    if (!pfnRunDll32API)
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    // Run the proc.
    hr = pfnRunDll32API(hwnd, hinst, pszCmd, nCmdShow);

exit:
    // Release name object. 
    if (pName)
        pName->Release();

    // Free allocated cmd line.
    if (szCmdLine)
        delete [] szCmdLine;
        
    return hr;
}


HRESULT (STDMETHODCALLTYPE* g_DllUnregisterServer)() = NULL;
STDAPI DllUnregisterServer(void)
{
    if (g_DllUnregisterServer){
        return (*g_DllUnregisterServer)();
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_DllUnregisterServer = (HRESULT (STDMETHODCALLTYPE *)())(GetProcAddress(hReal, "DllUnregisterServerInternal"));
        
        if (g_DllUnregisterServer) {
            return (*g_DllUnregisterServer)();
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    
    return hr; 
}

HRESULT (STDMETHODCALLTYPE* g_MetaDataGetDispenser)(REFCLSID, REFIID, LPVOID FAR *) = NULL;
STDAPI MetaDataGetDispenser(            // Return HRESULT
    REFCLSID    rclsid,                 // The class to desired.
    REFIID      riid,                   // Interface wanted on class factory.
    LPVOID FAR  *ppv)                   // Return interface pointer here.
{
    if (g_MetaDataGetDispenser){
        return (*g_MetaDataGetDispenser)(rclsid, riid, ppv);
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_MetaDataGetDispenser = (HRESULT (STDMETHODCALLTYPE *)(REFCLSID, REFIID, LPVOID FAR *))
            GetProcAddress(hReal, "MetaDataGetDispenser");
        if (g_MetaDataGetDispenser){
            return (*g_MetaDataGetDispenser)(rclsid, riid, ppv);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

HRESULT (STDMETHODCALLTYPE* g_CoInitializeEE)(DWORD) = NULL;
STDAPI CoInitializeEE(DWORD fFlags)
{
    if (g_CoInitializeEE){
        return (*g_CoInitializeEE)(fFlags);
    }
    HINSTANCE hReal;    
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_CoInitializeEE = (HRESULT (STDMETHODCALLTYPE *)(DWORD))GetProcAddress(hReal, "CoInitializeEE");
        if (g_CoInitializeEE){
            return (*g_CoInitializeEE)(fFlags);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

VOID (STDMETHODCALLTYPE* g_CoUninitializeEE)(BOOL) = NULL;
STDAPI_(void) CoUninitializeEE(BOOL fFlags)
{
    if (g_CoUninitializeEE){
        (*g_CoUninitializeEE)(fFlags);
        return;
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_CoUninitializeEE = (VOID (STDMETHODCALLTYPE *)(BOOL))GetProcAddress(hReal, "CoUninitializeEE");
        if (g_CoUninitializeEE){
            (*g_CoUninitializeEE)(fFlags);
        }
    }
    else{
        return;
    }
}

HRESULT (STDMETHODCALLTYPE* g_CoInitializeCor)(DWORD) = NULL;
STDAPI CoInitializeCor(DWORD fFlags)
{
    if (g_CoInitializeCor){
        return (*g_CoInitializeCor)(fFlags);
    }
    HINSTANCE hReal;
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_CoInitializeCor = (HRESULT (STDMETHODCALLTYPE *)(DWORD))GetProcAddress(hReal, "CoInitializeCor");
        if (g_CoInitializeCor){
            return (*g_CoInitializeCor)(fFlags);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

VOID (STDMETHODCALLTYPE* g_CoUninitializeCor)() = NULL;
STDAPI_(void) CoUninitializeCor(VOID)
{
    if (g_CoUninitializeCor){
        (*g_CoUninitializeCor)();
        return;
    }
    HINSTANCE hReal;    
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_CoUninitializeCor = (VOID (STDMETHODCALLTYPE *)(VOID))GetProcAddress(hReal, "CoUninitializeCor");
        if (g_CoUninitializeCor){
            (*g_CoUninitializeCor)();
        }
    }
    else{
        return;
    }
}

HRESULT (STDMETHODCALLTYPE* g_GetMetaDataPublicInterfaceFromInternal)(void *, REFIID, void **) = NULL;
STDAPI GetMetaDataPublicInterfaceFromInternal(
    void        *pv,                    // [IN] Given interface.
    REFIID      riid,                   // [IN] desired interface.
    void        **ppv)                  // [OUT] returned interface
{
    if (g_GetMetaDataPublicInterfaceFromInternal){
        return (*g_GetMetaDataPublicInterfaceFromInternal)(pv, riid, ppv);
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetMetaDataPublicInterfaceFromInternal = (HRESULT (STDMETHODCALLTYPE *)(void*, REFIID, void**))GetProcAddress(hReal, "GetMetaDataPublicInterfaceFromInternal");
        if (g_GetMetaDataPublicInterfaceFromInternal){
            return (*g_GetMetaDataPublicInterfaceFromInternal)(pv, riid, ppv);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

HRESULT (STDMETHODCALLTYPE* g_GetMetaDataInternalInterfaceFromPublic)(void *, REFIID, void **) = NULL;
STDAPI  GetMetaDataInternalInterfaceFromPublic(
    void        *pv,                    // [IN] Given interface.
    REFIID      riid,                   // [IN] desired interface
    void        **ppv)                  // [OUT] returned interface
{
    if (g_GetMetaDataInternalInterfaceFromPublic){
        return (*g_GetMetaDataInternalInterfaceFromPublic)(pv, riid, ppv);
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetMetaDataInternalInterfaceFromPublic = (HRESULT (STDMETHODCALLTYPE *)(void*, REFIID, void**))GetProcAddress(hReal, "GetMetaDataInternalInterfaceFromPublic");
        if (g_GetMetaDataInternalInterfaceFromPublic){
            return (*g_GetMetaDataInternalInterfaceFromPublic)(pv, riid, ppv);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

HRESULT (STDMETHODCALLTYPE* g_GetMetaDataInternalInterface)(LPVOID, ULONG, DWORD, REFIID, void **) = NULL;
STDAPI GetMetaDataInternalInterface(
    LPVOID      pData,                  // [IN] in memory metadata section
    ULONG       cbData,                 // [IN] size of the metadata section
    DWORD       flags,                  // [IN] MDInternal_OpenForRead or MDInternal_OpenForENC
    REFIID      riid,                   // [IN] desired interface
    void        **ppv)                  // [OUT] returned interface
{
    if (g_GetMetaDataInternalInterface){
        return (*g_GetMetaDataInternalInterface)(pData, cbData, flags, riid, ppv);
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetMetaDataInternalInterface = (HRESULT (STDMETHODCALLTYPE *)(LPVOID, ULONG, DWORD, REFIID, void **))GetProcAddress(hReal, "GetMetaDataInternalInterface");
        if (g_GetMetaDataInternalInterface){
            return (*g_GetMetaDataInternalInterface)(pData, cbData, flags, riid, ppv);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

void (* g_InitErrors)(DWORD*) = NULL;
void InitErrors(DWORD *piTlsIndex)
{
    if (g_InitErrors){
        (*g_InitErrors)(piTlsIndex);
        return;
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_InitErrors = (void (*)(DWORD*))GetProcAddress(hReal, (LPCSTR)17);
        if (g_InitErrors){
            (*g_InitErrors)(piTlsIndex);
        }
    }
    else{
        return;
    }
}

HRESULT (_cdecl* g_PostError)(HRESULT, ...) = NULL;
HRESULT _cdecl PostError(               // Returned error.
    HRESULT     hrRpt,                  // Reported error.
    ...)                                // Error arguments.
{
    if (g_PostError){
        va_list argPtr;
        va_start(argPtr, hrRpt);
        return (*g_PostError)(hrRpt, argPtr);
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_PostError = (HRESULT (_cdecl *)(HRESULT, ...))GetProcAddress(hReal, (LPCSTR)18);
        if (g_PostError){
            va_list argPtr;
            va_start(argPtr, hrRpt);
            return (*g_PostError)(hrRpt, argPtr);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

long * (*g_InitSSAutoEnterThread)() = NULL;
long * InitSSAutoEnterThread()
{
    if (g_InitSSAutoEnterThread){
        return (*g_InitSSAutoEnterThread)();
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_InitSSAutoEnterThread = (long * (*)())GetProcAddress(hReal, (LPCSTR)19);
        if (g_InitSSAutoEnterThread){
            return (*g_InitSSAutoEnterThread)();
        }
        return NULL;
    }
    else{
        return NULL;
    }
}

void (*g_UpdateError)() = NULL;
void UpdateError()
{
    if (g_UpdateError){
        (*g_UpdateError)();
        return;
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_UpdateError = (void (*)())GetProcAddress(hReal, (LPCSTR)20);
        if (g_UpdateError){
            (*g_UpdateError)();
        }
        return ;
    }
    else{
        return ;
    }
}

HRESULT (* g_LoadStringRC)(UINT, LPWSTR, int, int) = NULL;
HRESULT LoadStringRC(UINT iResourceID, LPWSTR szBuffer, int iMax, int bQuiet)
{
    if (g_LoadStringRC){
        return (*g_LoadStringRC)(iResourceID, szBuffer, iMax, bQuiet);
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_LoadStringRC = (HRESULT (*)(UINT, LPWSTR, int, int))GetProcAddress(hReal, (LPCSTR)22);
        if (g_LoadStringRC){
            return (*g_LoadStringRC)(iResourceID, szBuffer, iMax, bQuiet);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

HRESULT (STDMETHODCALLTYPE* g_ReOpenMetaDataWithMemory)(void *, LPCVOID, ULONG) = NULL;
STDAPI ReOpenMetaDataWithMemory(
    void        *pUnk,                  // [IN] Given scope. public interfaces
    LPCVOID     pData,                  // [in] Location of scope data.
    ULONG       cbData)                 // [in] Size of the data pointed to by pData.
{
    if (g_ReOpenMetaDataWithMemory){
        return (*g_ReOpenMetaDataWithMemory)(pUnk, pData, cbData);
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_ReOpenMetaDataWithMemory = (HRESULT (STDMETHODCALLTYPE *)(void *, LPCVOID, ULONG))GetProcAddress(hReal, (LPCSTR)23);
        if (g_ReOpenMetaDataWithMemory){
            return (*g_ReOpenMetaDataWithMemory)(pUnk, pData, cbData);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}
  
HRESULT (STDMETHODCALLTYPE* g_TranslateSecurityAttributes)(CORSEC_PSET*, BYTE**, DWORD*, BYTE**, DWORD*, DWORD*) = NULL;
HRESULT STDMETHODCALLTYPE
TranslateSecurityAttributes(CORSEC_PSET    *pPset,
                            BYTE          **ppbOutput,
                            DWORD          *pcbOutput,
                            BYTE          **ppbNonCasOutput,
                            DWORD          *pcbNonCasOutput,
                            DWORD          *pdwErrorIndex)
{
    if (g_TranslateSecurityAttributes){
        return (g_TranslateSecurityAttributes)(pPset, ppbOutput, pcbOutput, ppbNonCasOutput, pcbNonCasOutput, pdwErrorIndex);
    }
    HINSTANCE hReal;  
    
    HRESULT hr = GetInstallation(TRUE, &hReal);
    if (SUCCEEDED(hr)) {
        g_TranslateSecurityAttributes = (HRESULT (STDMETHODCALLTYPE *)(CORSEC_PSET*, BYTE**, DWORD*, BYTE**, DWORD*, DWORD*))GetProcAddress(hReal, "TranslateSecurityAttributes");
        if (g_TranslateSecurityAttributes){
            return (*g_TranslateSecurityAttributes)(pPset, ppbOutput, pcbOutput, ppbNonCasOutput, pcbNonCasOutput, pdwErrorIndex);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

HRESULT (STDMETHODCALLTYPE* g_GetPermissionRequests)(LPCWSTR, BYTE**, DWORD*, BYTE**, DWORD*, BYTE**, DWORD*);
HRESULT STDMETHODCALLTYPE
GetPermissionRequests(LPCWSTR   pwszFileName,
                      BYTE    **ppbMinimal,
                      DWORD    *pcbMinimal,
                      BYTE    **ppbOptional,
                      DWORD    *pcbOptional,
                      BYTE    **ppbRefused,
                      DWORD    *pcbRefused)
{
    if (g_GetPermissionRequests){
        return (*g_GetPermissionRequests)(pwszFileName, ppbMinimal, pcbMinimal, ppbOptional, pcbOptional, ppbRefused, pcbRefused);
    }

    HINSTANCE hReal;  
    HRESULT hr = GetInstallation(TRUE, &hReal);
    if (SUCCEEDED(hr)) {
        g_GetPermissionRequests = (HRESULT (STDMETHODCALLTYPE*)(LPCWSTR, BYTE**, DWORD*, BYTE**, DWORD*, BYTE**, DWORD*))GetProcAddress(hReal, "GetPermissionRequests");
        if (g_GetPermissionRequests){
            return (*g_GetPermissionRequests)(pwszFileName, ppbMinimal, pcbMinimal, ppbOptional, pcbOptional, ppbRefused, pcbRefused);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}


HRESULT (STDMETHODCALLTYPE* g_ClrCreateManagedInstance)(LPCWSTR, REFIID, LPVOID FAR *) = NULL;
STDAPI ClrCreateManagedInstance(LPCWSTR pTypeName, REFIID riid, void **ppObject)
{
    if (g_ClrCreateManagedInstance){
        return (*g_ClrCreateManagedInstance)(pTypeName, riid, ppObject);
    }
    HINSTANCE hReal; 

    // We pass TRUE into GetInstallation... this will cause us to be 'liberal' when picking a runtime if we're
    // unable to find a version to load.
    //
    // Why? Well, we expect the runtime to already be loaded when this function is called. However, in v1, 
    // we didn't require the runtime to be loaded and instead just spun up v1. We need to copy this behavior in
    // Everett, so we'll spin up v1 if we can't figure out what runtime to load.
    //
    // In addition, in v1, Managed Custom Actions in Installer packages created by VS7 didn't load the 
    // runtime when they called this function, and there is the possiblity that v1 doesn't exist the machine.
    //
    // The v1 installer will throw up a really ugly error message that gives no clue as to what the real problem
    // is. We want the managed custom action to still run. So, we'll also try and load Everett if v1 is unavailable.
    
    HRESULT hr = GetInstallation(TRUE, &hReal, TRUE);
    if (SUCCEEDED(hr)) {
        g_ClrCreateManagedInstance = (HRESULT (STDMETHODCALLTYPE *)(LPCWSTR, REFIID, LPVOID FAR *))GetProcAddress(hReal, "ClrCreateManagedInstance");
        if (g_ClrCreateManagedInstance){
            return (*g_ClrCreateManagedInstance)(pTypeName, riid, ppObject);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE  EEDllGetClassObjectFromClass(LPCWSTR pReserved,
                                                        LPCWSTR typeName,
                                                        REFIID riid,
                                                        LPVOID FAR *ppv)
{
    return E_NOTIMPL;
}

ICorCompileInfo * (*g_GetCompileInfo)() = NULL;
ICorCompileInfo *GetCompileInfo()
{
    if (g_GetCompileInfo){
        return (*g_GetCompileInfo)();
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetCompileInfo = (ICorCompileInfo * (*)())GetProcAddress(hReal, "GetCompileInfo");
        if (g_GetCompileInfo){
            return (*g_GetCompileInfo)();
        }
    }
    return NULL;
}

void (STDMETHODCALLTYPE* g_CoEEShutDownCOM)() = NULL;
STDAPI_(void) CoEEShutDownCOM(void)
{
    if (g_CoEEShutDownCOM){
        (*g_CoEEShutDownCOM)();
        return;
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_CoEEShutDownCOM = (void (STDMETHODCALLTYPE *)())GetProcAddress(hReal, "CoEEShutDownCOM");
        if (g_CoEEShutDownCOM){
            (*g_CoEEShutDownCOM)();
        }
    }
    return;
}

HRESULT (STDMETHODCALLTYPE* g_RuntimeOpenImage)(LPCWSTR, HCORMODULE*) = NULL;
STDAPI STDMETHODCALLTYPE RuntimeOpenImage(LPCWSTR pszFileName, HCORMODULE* hHandle)
{
    if (g_RuntimeOpenImage == NULL) {
        HINSTANCE hReal;  
        if (SUCCEEDED(GetRealDll(&hReal)))
            g_RuntimeOpenImage = (HRESULT (STDMETHODCALLTYPE *)(LPCWSTR, HCORMODULE*))GetProcAddress(hReal, "RuntimeOpenImage");

        if(g_RuntimeOpenImage == NULL)
            return CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return (*g_RuntimeOpenImage)(pszFileName, hHandle);
}

HRESULT (STDMETHODCALLTYPE* g_RuntimeReleaseHandle)(HCORMODULE) = NULL;
STDAPI STDMETHODCALLTYPE RuntimeReleaseHandle(HCORMODULE hHandle)
{
    if (g_RuntimeReleaseHandle == NULL) {
        HINSTANCE hReal;  
        if (SUCCEEDED(GetRealDll(&hReal)))
            g_RuntimeReleaseHandle = (HRESULT (STDMETHODCALLTYPE *)(HCORMODULE))GetProcAddress(hReal, "RuntimeReleaseHandle");

        if(g_RuntimeReleaseHandle == NULL)
            return CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return (*g_RuntimeReleaseHandle)(hHandle);
}

CorLoadFlags (STDMETHODCALLTYPE* g_RuntimeImageType)(HCORMODULE) = NULL;
CorLoadFlags STDMETHODCALLTYPE RuntimeImageType(HCORMODULE hHandle)
{
    if (g_RuntimeImageType == NULL) {
        HINSTANCE hReal;  
        if (SUCCEEDED(GetRealDll(&hReal)))
            g_RuntimeImageType = (CorLoadFlags (STDMETHODCALLTYPE *)(HCORMODULE))GetProcAddress(hReal, "RuntimeImageType");
        
        if(g_RuntimeImageType == NULL)
            return CorLoadUndefinedMap;
    }
    return (*g_RuntimeImageType)(hHandle);
}

HRESULT (STDMETHODCALLTYPE* g_RuntimeOSHandle)(HCORMODULE, HMODULE*) = NULL;
HRESULT STDMETHODCALLTYPE RuntimeOSHandle(HCORMODULE hHandle, HMODULE* hModule)
{
    if (g_RuntimeOSHandle == NULL) {
        HINSTANCE hReal;  
        if (SUCCEEDED(GetRealDll(&hReal)))
            g_RuntimeOSHandle = (HRESULT (STDMETHODCALLTYPE *)(HCORMODULE, HMODULE*))GetProcAddress(hReal, "RuntimeOSHandle");
        
        if(g_RuntimeOSHandle == NULL)
            return CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return (*g_RuntimeOSHandle)(hHandle, hModule);
}

HRESULT (STDMETHODCALLTYPE* g_RuntimeReadHeaders)(PBYTE, IMAGE_DOS_HEADER**,
                                                  IMAGE_NT_HEADERS**, IMAGE_COR20_HEADER**,
                                                  BOOL, DWORD) = NULL;
HRESULT STDMETHODCALLTYPE RuntimeReadHeaders(PBYTE hAddress, IMAGE_DOS_HEADER** ppDos,
                                             IMAGE_NT_HEADERS** ppNT, IMAGE_COR20_HEADER** ppCor,
                                             BOOL fDataMap, DWORD dwLength)
{
    if (g_RuntimeReadHeaders == NULL) {
        HINSTANCE hReal;  
        if (SUCCEEDED(GetRealDll(&hReal)))
            g_RuntimeReadHeaders = (HRESULT (STDMETHODCALLTYPE *)(PBYTE, IMAGE_DOS_HEADER**,
                                                                  IMAGE_NT_HEADERS**, IMAGE_COR20_HEADER**,
                                                                  BOOL, DWORD))GetProcAddress(hReal, "RuntimeReadHeaders");
        
        if(g_RuntimeReadHeaders == NULL)
            return CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return (*g_RuntimeReadHeaders)(hAddress, ppDos, ppNT, ppCor, fDataMap, dwLength);
}

void (STDMETHODCALLTYPE* g_CorMarkThreadInThreadPool)() = NULL;
void STDMETHODCALLTYPE CorMarkThreadInThreadPool()
{
    if (g_CorMarkThreadInThreadPool){
        (*g_CorMarkThreadInThreadPool)();
        return;
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_CorMarkThreadInThreadPool = (void (STDMETHODCALLTYPE *)())GetProcAddress(hReal, "CorMarkThreadInThreadPool");
        if (g_CorMarkThreadInThreadPool){
            (*g_CorMarkThreadInThreadPool)();
        }
    }
    return;
}

int (STDMETHODCALLTYPE* g_CoLogCurrentStack)(WCHAR*, BOOL) = NULL;
int STDMETHODCALLTYPE CoLogCurrentStack(WCHAR * pwsz, BOOL fDumpStack) 
{
    if (g_CoLogCurrentStack){
        return (*g_CoLogCurrentStack)(pwsz, fDumpStack);
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_CoLogCurrentStack = (int (STDMETHODCALLTYPE *)(WCHAR*, BOOL))GetProcAddress(hReal, "CoLogCurrentStack");
        if (g_CoLogCurrentStack){
            return (*g_CoLogCurrentStack)(pwsz, fDumpStack);
        }
    }
    return 0;
}

void STDMETHODCALLTYPE ReleaseFusionInterfaces(HMODULE hCallingMod)
{
    // Don't release if this isn't called by the vm's fusion.dll.
    if (g_hMod) {
        if(!g_hFusionMod) {
            LPWSTR directory = NULL;
            WCHAR place[MAX_PATH];
            DWORD size = MAX_PATH;
            LPWSTR pSep = NULL;
            if(WszGetModuleFileName(g_hMod, place, size)) {
                pSep = wcsrchr(place, L'\\');
                if(pSep) *(++pSep) = '\0';
                directory = place;
            }
            else 
                directory = g_Directory;
            
            if (directory) {
                // We are expecting directory to be no more than MAX_PATH
                // This assert enforces the check at the end of LoadVersionedRuntime
                _ASSERTE(wcslen(directory) < MAX_PATH);
                wchar_t wszFusionPath[MAX_PATH+11];
                wcscpy(wszFusionPath, directory);
                wcscat(wszFusionPath, L"Fusion.dll");
                
                g_hFusionMod = WszGetModuleHandle(wszFusionPath);
            }
        }

        if (hCallingMod == g_hFusionMod) {

            void (STDMETHODCALLTYPE* pReleaseFusionInterfaces)();
            
            pReleaseFusionInterfaces = (void (STDMETHODCALLTYPE *)())GetProcAddress(g_hMod, "ReleaseFusionInterfaces");
            if (pReleaseFusionInterfaces){
                (*pReleaseFusionInterfaces)();
            }
        }
        return;
    }
}

extern "C" __declspec(dllexport) INT32 __stdcall ND_RU1(VOID *psrc, INT32 ofs)
{
    return (INT32) *( (UINT8*)(ofs + (BYTE*)psrc) );
}

extern "C" __declspec(dllexport) INT32 __stdcall ND_RI2(VOID *psrc, INT32 ofs)
{
    return (INT32) *( (INT16*)(ofs + (BYTE*)psrc) );
}

extern "C" __declspec(dllexport) INT32 __stdcall ND_RI4(VOID *psrc, INT32 ofs)
{
    return (INT32) *( (INT32*)(ofs + (BYTE*)psrc) );
}

extern "C" __declspec(dllexport) INT64 __stdcall ND_RI8(VOID *psrc, INT32 ofs)
{
    return (INT64) *( (INT64*)(ofs + (BYTE*)psrc) );
}

extern "C" __declspec(dllexport) VOID __stdcall ND_WU1(VOID *psrc, INT32 ofs, UINT8 val)
{
    *( (UINT8*)(ofs + (BYTE*)psrc) ) = val;
}


extern "C" __declspec(dllexport) VOID __stdcall ND_WI2(VOID *psrc, INT32 ofs, INT16 val)
{
    *( (INT16*)(ofs + (BYTE*)psrc) ) = val;
}


extern "C" __declspec(dllexport) VOID __stdcall ND_WI4(VOID *psrc, INT32 ofs, INT32 val)
{
    *( (INT32*)(ofs + (BYTE*)psrc) ) = val;
}


extern "C" __declspec(dllexport) VOID __stdcall ND_WI8(VOID *psrc, INT32 ofs, INT64 val)
{
    *( (INT64*)(ofs + (BYTE*)psrc) ) = val;
}

extern "C" __declspec(dllexport) VOID __stdcall ND_CopyObjSrc(LPBYTE source, int ofs, LPBYTE dst, int cb)
{
    CopyMemory(dst, source + ofs, cb);
}

extern "C" __declspec(dllexport) VOID __stdcall ND_CopyObjDst(LPBYTE source, LPBYTE dst, int ofs, int cb)
{
    CopyMemory(dst + ofs, source, cb);
}

VOID (*g_LogHelp_LogAssert)(LPCSTR, int, LPCSTR) = NULL;
VOID LogHelp_LogAssert( LPCSTR szFile, int iLine, LPCSTR expr)
{
    if (g_LogHelp_LogAssert){
        (*g_LogHelp_LogAssert)(szFile, iLine, expr);
        return;
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_LogHelp_LogAssert = (VOID (*)(LPCSTR, int, LPCSTR))GetProcAddress(hReal, "LogHelp_LogAssert");
        if (g_LogHelp_LogAssert){
            (*g_LogHelp_LogAssert)(szFile, iLine, expr);
        }
    }
    return;
}

BOOL (*g_LogHelp_NoGuiOnAssert)() = NULL;
BOOL LogHelp_NoGuiOnAssert()
{
    if (g_LogHelp_NoGuiOnAssert){
        return (*g_LogHelp_NoGuiOnAssert)();
    }
    HINSTANCE hReal;      
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_LogHelp_NoGuiOnAssert = (BOOL (*)())GetProcAddress(hReal, "LogHelp_NoGuiOnAssert");
        if (g_LogHelp_NoGuiOnAssert){
            return (*g_LogHelp_NoGuiOnAssert)();
        }
    }
    return false;
}

VOID (*g_LogHelp_TerminateOnAssert)() = NULL;
VOID LogHelp_TerminateOnAssert()
{
    if (g_LogHelp_TerminateOnAssert){
        (*g_LogHelp_TerminateOnAssert)();
        return ;
    }
    HINSTANCE hReal;      
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_LogHelp_TerminateOnAssert = (VOID (*)())GetProcAddress(hReal, "LogHelp_TerminateOnAssert");
        if (g_LogHelp_TerminateOnAssert){
            (*g_LogHelp_TerminateOnAssert)();
        }
    }
    return ;
}

Perf_Contexts *(* g_GetPrivateContextsPerfCounters)() = NULL;
Perf_Contexts *GetPrivateContextsPerfCounters()
{
    if (g_GetPrivateContextsPerfCounters){
        return (*g_GetPrivateContextsPerfCounters)();
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetPrivateContextsPerfCounters = (Perf_Contexts * (*)())GetProcAddress(hReal, "GetPrivateContextsPerfCounters");
        if (g_GetPrivateContextsPerfCounters){
            return (*g_GetPrivateContextsPerfCounters)();
        }
    }
    return NULL;
}

Perf_Contexts *(*g_GetGlobalContextPerfCounters)() = NULL;
Perf_Contexts *GetGlobalContextsPerfCounters()
{
    if (g_GetGlobalContextPerfCounters){
        return (*g_GetGlobalContextPerfCounters)();
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetGlobalContextPerfCounters = (Perf_Contexts * (*)())GetProcAddress(hReal, "GetGlobalContextsPerfCounters");
        if (g_GetGlobalContextPerfCounters){
            return (*g_GetGlobalContextPerfCounters)();
        }
    }
    return NULL;
}

HRESULT (STDMETHODCALLTYPE* g_EEDllRegisterServer)(HMODULE) = NULL;
STDAPI EEDllRegisterServer(HMODULE hMod)
{
    if (g_EEDllRegisterServer){
        return (*g_EEDllRegisterServer)(hMod);
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_EEDllRegisterServer = (HRESULT (STDMETHODCALLTYPE *)(HMODULE))GetProcAddress(hReal, "EEDllRegisterServer");
        if (g_EEDllRegisterServer){
            return (*g_EEDllRegisterServer)(hMod);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

HRESULT (STDMETHODCALLTYPE* g_EEDllUnregisterServer)(HMODULE) = NULL;
STDAPI EEDllUnregisterServer(HMODULE hMod)
{
    if (g_EEDllUnregisterServer){
        (*g_EEDllUnregisterServer)(hMod);
    }
    HINSTANCE hReal;  
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_EEDllUnregisterServer = (HRESULT (STDMETHODCALLTYPE *)(HMODULE))GetProcAddress(hReal, "EEDllUnregisterServer");
        if (g_EEDllUnregisterServer){
            return (*g_EEDllUnregisterServer)(hMod);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

void (STDMETHODCALLTYPE* g_CorExitProcess)(int) = NULL;
extern "C" void STDMETHODCALLTYPE CorExitProcess(int exitCode)
{
    if (g_CorExitProcess){
        (*g_CorExitProcess)(exitCode);
    }

    HINSTANCE hReal;  
    if(g_hMod) {
        HRESULT hr = GetRealDll(&hReal, FALSE);
        if (SUCCEEDED(hr)) {
            g_CorExitProcess = (void (STDMETHODCALLTYPE *)(int))GetProcAddress(hReal, "CorExitProcess");
            if (g_CorExitProcess){
                (*g_CorExitProcess)(exitCode);
            }
        }
    }
    return;
}

// Mscorsn entrypoints.

DWORD (__stdcall* g_StrongNameErrorInfo)() = NULL;
extern "C" DWORD __stdcall StrongNameErrorInfo()
{
    if (g_StrongNameErrorInfo){
        return (*g_StrongNameErrorInfo)();
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameErrorInfo = (DWORD (__stdcall *)())GetProcAddress(hReal, "StrongNameErrorInfo");
        if (g_StrongNameErrorInfo){
            return (*g_StrongNameErrorInfo)();
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

VOID (__stdcall* g_StrongNameFreeBuffer)(BYTE *) = NULL;
VOID StrongNameFreeBufferHelper (BYTE *pbMemory)
{
    if (g_StrongNameFreeBuffer){
        (*g_StrongNameFreeBuffer)(pbMemory);
        return;
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameFreeBuffer = (VOID (__stdcall *)(BYTE *))GetProcAddress(hReal, "StrongNameFreeBuffer");
        if (g_StrongNameFreeBuffer){
            (*g_StrongNameFreeBuffer)(pbMemory);
        }
    }
}

extern "C" VOID __stdcall StrongNameFreeBuffer(BYTE *pbMemory)
{
    // ShouldFreeBuffer determines if the cache allocated the buffer 
    // and as a side effect frees the buffer.
    if (g_StrongNameFromPublicKeyMap.ShouldFreeBuffer (pbMemory)) 
        return;

    // Buffer was not allocated by the cache, let the StrongNameDll handle it.
    StrongNameFreeBufferHelper(pbMemory);
}

BOOL (__stdcall* g_StrongNameKeyGen)(LPCWSTR, DWORD, BYTE **, ULONG *) = NULL;
extern "C" DWORD __stdcall StrongNameKeyGen(LPCWSTR wszKeyContainer,
                                            DWORD   dwFlags,
                                            BYTE  **ppbKeyBlob,
                                            ULONG  *pcbKeyBlob)
{
    if (g_StrongNameKeyGen){
        return (*g_StrongNameKeyGen)(wszKeyContainer, dwFlags, ppbKeyBlob, pcbKeyBlob);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameKeyGen = (BOOL (__stdcall *)(LPCWSTR, DWORD, BYTE **, ULONG *))GetProcAddress(hReal, "StrongNameKeyGen");
        if (g_StrongNameKeyGen){
            return (*g_StrongNameKeyGen)(wszKeyContainer, dwFlags, ppbKeyBlob, pcbKeyBlob);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameKeyInstall)(LPCWSTR, BYTE *, ULONG) = NULL;
extern "C" DWORD __stdcall StrongNameKeyInstall(LPCWSTR wszKeyContainer,
                                                BYTE   *pbKeyBlob,
                                                ULONG   cbKeyBlob)
{
    if (g_StrongNameKeyInstall){
        return (*g_StrongNameKeyInstall)(wszKeyContainer, pbKeyBlob, cbKeyBlob);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameKeyInstall = (BOOL (__stdcall *)(LPCWSTR, BYTE *, ULONG))GetProcAddress(hReal, "StrongNameKeyInstall");
        if (g_StrongNameKeyInstall){
            return (*g_StrongNameKeyInstall)(wszKeyContainer, pbKeyBlob, cbKeyBlob);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameKeyDelete)(LPCWSTR) = NULL;
extern "C" DWORD __stdcall StrongNameKeyDelete(LPCWSTR wszKeyContainer)
{
    if (g_StrongNameKeyDelete){
        return (*g_StrongNameKeyDelete)(wszKeyContainer);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameKeyDelete = (BOOL (__stdcall *)(LPCWSTR))GetProcAddress(hReal, "StrongNameKeyDelete");
        if (g_StrongNameKeyDelete){
            return (*g_StrongNameKeyDelete)(wszKeyContainer);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameGetPublicKey)(LPCWSTR, BYTE *, ULONG, BYTE **, ULONG *) = NULL;
extern "C" DWORD __stdcall StrongNameGetPublicKey(LPCWSTR   wszKeyContainer,
                                                  BYTE     *pbKeyBlob,
                                                  ULONG     cbKeyBlob,
                                                  BYTE    **ppbPublicKeyBlob,
                                                  ULONG    *pcbPublicKeyBlob)
{
    if (g_StrongNameGetPublicKey){
        return (*g_StrongNameGetPublicKey)(wszKeyContainer, pbKeyBlob, cbKeyBlob, ppbPublicKeyBlob, pcbPublicKeyBlob);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameGetPublicKey = (BOOL (__stdcall *)(LPCWSTR, BYTE *, ULONG, BYTE **, ULONG *))GetProcAddress(hReal, "StrongNameGetPublicKey");
        if (g_StrongNameGetPublicKey){
            return (*g_StrongNameGetPublicKey)(wszKeyContainer, pbKeyBlob, cbKeyBlob, ppbPublicKeyBlob, pcbPublicKeyBlob);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameSignatureGeneration)(LPCWSTR, LPCWSTR, BYTE *, ULONG, BYTE **, ULONG *) = NULL;
extern "C" DWORD __stdcall StrongNameSignatureGeneration(LPCWSTR    wszFilePath,
                                                         LPCWSTR    wszKeyContainer,
                                                         BYTE      *pbKeyBlob,
                                                         ULONG      cbKeyBlob,
                                                         BYTE     **ppbSignatureBlob,
                                                         ULONG     *pcbSignatureBlob)
{
    if (g_StrongNameSignatureGeneration){
        return (*g_StrongNameSignatureGeneration)(wszFilePath, wszKeyContainer, pbKeyBlob, cbKeyBlob, ppbSignatureBlob, pcbSignatureBlob);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameSignatureGeneration = (BOOL (__stdcall *)(LPCWSTR, LPCWSTR, BYTE *, ULONG, BYTE **, ULONG *))GetProcAddress(hReal, "StrongNameSignatureGeneration");
        if (g_StrongNameSignatureGeneration){
            return (*g_StrongNameSignatureGeneration)(wszFilePath, wszKeyContainer, pbKeyBlob, cbKeyBlob, ppbSignatureBlob, pcbSignatureBlob);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameTokenFromAssembly)(LPCWSTR, BYTE **, ULONG *) = NULL;
extern "C" DWORD __stdcall StrongNameTokenFromAssembly(LPCWSTR  wszFilePath,
                                                       BYTE   **ppbStrongNameToken,
                                                       ULONG   *pcbStrongNameToken)
{
    if (g_StrongNameTokenFromAssembly){
        return (*g_StrongNameTokenFromAssembly)(wszFilePath, ppbStrongNameToken, pcbStrongNameToken);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameTokenFromAssembly = (BOOL (__stdcall *)(LPCWSTR, BYTE **, ULONG *))GetProcAddress(hReal, "StrongNameTokenFromAssembly");
        if (g_StrongNameTokenFromAssembly){
            return (*g_StrongNameTokenFromAssembly)(wszFilePath, ppbStrongNameToken, pcbStrongNameToken);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameTokenFromAssemblyEx)(LPCWSTR, BYTE **, ULONG *, BYTE **, ULONG *) = NULL;
extern "C" DWORD __stdcall StrongNameTokenFromAssemblyEx(LPCWSTR    wszFilePath,
                                                         BYTE     **ppbStrongNameToken,
                                                         ULONG     *pcbStrongNameToken,
                                                         BYTE     **ppbPublicKeyBlob,
                                                         ULONG     *pcbPublicKeyBlob)
{
    if (g_StrongNameTokenFromAssemblyEx){
        return (*g_StrongNameTokenFromAssemblyEx)(wszFilePath, ppbStrongNameToken, pcbStrongNameToken, ppbPublicKeyBlob, pcbPublicKeyBlob);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameTokenFromAssemblyEx = (BOOL (__stdcall *)(LPCWSTR, BYTE **, ULONG *, BYTE **, ULONG *))GetProcAddress(hReal, "StrongNameTokenFromAssemblyEx");
        if (g_StrongNameTokenFromAssemblyEx){
            return (*g_StrongNameTokenFromAssemblyEx)(wszFilePath, ppbStrongNameToken, pcbStrongNameToken, ppbPublicKeyBlob, pcbPublicKeyBlob);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameTokenFromPublicKey)(BYTE *, ULONG, BYTE **, ULONG *) = NULL;
BOOL StrongNameTokenFromPublicKeyHelper (BYTE    *pbPublicKeyBlob,
                                         ULONG    cbPublicKeyBlob,
                                         BYTE   **ppbStrongNameToken,
                                         ULONG   *pcbStrongNameToken)
{
    if (g_StrongNameTokenFromPublicKey){
        return (*g_StrongNameTokenFromPublicKey)(pbPublicKeyBlob, cbPublicKeyBlob, ppbStrongNameToken, pcbStrongNameToken);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameTokenFromPublicKey = (BOOL (__stdcall *)(BYTE *, ULONG, BYTE **, ULONG *))GetProcAddress(hReal, "StrongNameTokenFromPublicKey");
        if (g_StrongNameTokenFromPublicKey){
            return (*g_StrongNameTokenFromPublicKey)(pbPublicKeyBlob, cbPublicKeyBlob, ppbStrongNameToken, pcbStrongNameToken);
        }
    }
    return FALSE;
}

#ifdef _DEBUG
BOOL CheckStrongNameCorrectness (BYTE    *pbPublicKeyBlob,
                                  ULONG    cbPublicKeyBlob,
                                  BYTE   **ppbStrongNameToken,
                                  ULONG   *pcbStrongNameToken)
{
    BOOL fRetVal = TRUE;
    BYTE *_pbStrongNameToken;
    ULONG _cbStrongNameToken;

    // Get the strongname token from the StrongNameDll
    if (!StrongNameTokenFromPublicKeyHelper (pbPublicKeyBlob, cbPublicKeyBlob, &_pbStrongNameToken, &_cbStrongNameToken))
        fRetVal = FALSE;
    else 
        if (*pcbStrongNameToken != _cbStrongNameToken)
            fRetVal = FALSE;
        else
            if (0 != memcmp (*ppbStrongNameToken, _pbStrongNameToken, *pcbStrongNameToken))
                fRetVal = FALSE;
    if (_pbStrongNameToken != NULL)
        StrongNameFreeBuffer (_pbStrongNameToken);

    return fRetVal;
}
#endif

extern "C" DWORD __stdcall StrongNameTokenFromPublicKey(BYTE    *pbPublicKeyBlob,
                                                        ULONG    cbPublicKeyBlob,
                                                        BYTE   **ppbStrongNameToken,
                                                        ULONG   *pcbStrongNameToken)
{
  if (g_StrongNameFromPublicKeyMap.FindEntry (pbPublicKeyBlob, cbPublicKeyBlob, ppbStrongNameToken, pcbStrongNameToken))
  {
      _ASSERTE (CheckStrongNameCorrectness(pbPublicKeyBlob, cbPublicKeyBlob, ppbStrongNameToken, pcbStrongNameToken));
      return TRUE;
  }

  BOOL retVal = StrongNameTokenFromPublicKeyHelper (pbPublicKeyBlob, cbPublicKeyBlob, ppbStrongNameToken, pcbStrongNameToken);
  if (retVal)
      g_StrongNameFromPublicKeyMap.AddEntry (pbPublicKeyBlob, cbPublicKeyBlob, ppbStrongNameToken, pcbStrongNameToken, STRONG_NAME_TOKEN_ALLOCATED_BY_STRONGNAMEDLL);
  return retVal;
}

BOOL (__stdcall* g_StrongNameSignatureVerification)(LPCWSTR, DWORD, DWORD *) = NULL;
extern "C" DWORD __stdcall StrongNameSignatureVerification(LPCWSTR wszFilePath, DWORD dwInFlags, DWORD *pdwOutFlags)
{
    if (g_StrongNameSignatureVerification){
        return (*g_StrongNameSignatureVerification)(wszFilePath, dwInFlags, pdwOutFlags);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameSignatureVerification = (BOOL (__stdcall *)(LPCWSTR, DWORD, DWORD *))GetProcAddress(hReal, "StrongNameSignatureVerification");
        if (g_StrongNameSignatureVerification){
            return (*g_StrongNameSignatureVerification)(wszFilePath, dwInFlags, pdwOutFlags);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameSignatureVerificationEx)(LPCWSTR, BOOLEAN, BOOLEAN *) = NULL;
extern "C" DWORD __stdcall StrongNameSignatureVerificationEx(LPCWSTR    wszFilePath,
                                                             BOOLEAN    fForceVerification,
                                                             BOOLEAN   *pfWasVerified)
{
    if (g_StrongNameSignatureVerificationEx){
        return (*g_StrongNameSignatureVerificationEx)(wszFilePath, fForceVerification, pfWasVerified);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameSignatureVerificationEx = (BOOL (__stdcall *)(LPCWSTR, BOOLEAN, BOOLEAN *))GetProcAddress(hReal, "StrongNameSignatureVerificationEx");
        if (g_StrongNameSignatureVerificationEx){
            return (*g_StrongNameSignatureVerificationEx)(wszFilePath, fForceVerification, pfWasVerified);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameSignatureVerificationFromImage)(BYTE *, DWORD, DWORD, DWORD *) = NULL;
extern "C" DWORD __stdcall StrongNameSignatureVerificationFromImage(BYTE      *pbBase,
                                                                    DWORD      dwLength,
                                                                    DWORD      dwInFlags,
                                                                    DWORD     *pdwOutFlags)
{
    if (g_StrongNameSignatureVerificationFromImage){
      return (*g_StrongNameSignatureVerificationFromImage)(pbBase, dwLength, dwInFlags, pdwOutFlags);
    }
  
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameSignatureVerificationFromImage = (BOOL (__stdcall *)(BYTE *, DWORD, DWORD, DWORD *))GetProcAddress(hReal, "StrongNameSignatureVerificationFromImage");
        if (g_StrongNameSignatureVerificationFromImage){
            return (*g_StrongNameSignatureVerificationFromImage)(pbBase, dwLength, dwInFlags, pdwOutFlags);
        }  
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameCompareAssemblies)(LPCWSTR, LPCWSTR, DWORD *) = NULL;
extern "C" DWORD __stdcall StrongNameCompareAssemblies(LPCWSTR   wszAssembly1,
                                                       LPCWSTR   wszAssembly2,
                                                       DWORD    *pdwResult)
{
    if (g_StrongNameCompareAssemblies){
        return (*g_StrongNameCompareAssemblies)(wszAssembly1, wszAssembly2, pdwResult);
    }
  
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameCompareAssemblies = (BOOL (__stdcall *)(LPCWSTR, LPCWSTR, DWORD *))GetProcAddress(hReal, "StrongNameCompareAssemblies");
        if (g_StrongNameCompareAssemblies){
            return (*g_StrongNameCompareAssemblies)(wszAssembly1, wszAssembly2, pdwResult);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameHashSize)(ULONG, DWORD *) = NULL;
extern "C" DWORD __stdcall StrongNameHashSize(ULONG  ulHashAlg,
                                              DWORD *pcbSize)
{
    if (g_StrongNameHashSize){
        return (*g_StrongNameHashSize)(ulHashAlg, pcbSize);
    }
  
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameHashSize = (BOOL (__stdcall *)(ULONG, DWORD *))GetProcAddress(hReal, "StrongNameHashSize");
        if (g_StrongNameHashSize){
            return (*g_StrongNameHashSize)(ulHashAlg, pcbSize);
        }
    }
    return FALSE;
}

BOOL (__stdcall* g_StrongNameSignatureSize)(BYTE *, ULONG, DWORD *) = NULL;
extern "C" DWORD __stdcall StrongNameSignatureSize(BYTE    *pbPublicKeyBlob,
                                                   ULONG    cbPublicKeyBlob,
                                                   DWORD   *pcbSize)
{
    if (g_StrongNameSignatureSize){
        return (*g_StrongNameSignatureSize)(pbPublicKeyBlob, cbPublicKeyBlob, pcbSize);
    }
  
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_StrongNameSignatureSize = (BOOL (__stdcall *)(BYTE *, ULONG, DWORD *))GetProcAddress(hReal, "StrongNameSignatureSize");
        if (g_StrongNameSignatureSize){
            return (*g_StrongNameSignatureSize)(pbPublicKeyBlob, cbPublicKeyBlob, pcbSize);
        }
    }
    return FALSE;
}

DWORD (__stdcall* g_GetHashFromAssemblyFile)(LPCSTR, unsigned int *, BYTE *, DWORD, DWORD *) = NULL;
extern "C" DWORD __stdcall GetHashFromAssemblyFile(LPCSTR szFilePath,
                                                   unsigned int *piHashAlg,
                                                   BYTE   *pbHash,
                                                   DWORD  cchHash,
                                                   DWORD  *pchHash)
{
    if (g_GetHashFromAssemblyFile){
        return (*g_GetHashFromAssemblyFile)(szFilePath, piHashAlg, pbHash, cchHash, pchHash);
    }
  
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetHashFromAssemblyFile = (DWORD (__stdcall *)(LPCSTR, unsigned int *, BYTE *, DWORD, DWORD *))GetProcAddress(hReal, "GetHashFromAssemblyFile");
        if (g_GetHashFromAssemblyFile){
            return (*g_GetHashFromAssemblyFile)(szFilePath, piHashAlg, pbHash, cchHash, pchHash);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

DWORD (__stdcall* g_GetHashFromAssemblyFileW)(LPCWSTR, unsigned int *, BYTE *, DWORD, DWORD *) = NULL;
extern "C" DWORD __stdcall GetHashFromAssemblyFileW(LPCWSTR wszFilePath,
                                                    unsigned int *piHashAlg,
                                                    BYTE   *pbHash,
                                                    DWORD  cchHash,
                                                    DWORD  *pchHash)
{
    if (g_GetHashFromAssemblyFileW){
        return (*g_GetHashFromAssemblyFileW)(wszFilePath, piHashAlg, pbHash, cchHash, pchHash);
    }
  
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetHashFromAssemblyFileW = (DWORD (__stdcall *)(LPCWSTR, unsigned int *, BYTE *, DWORD, DWORD *))GetProcAddress(hReal, "GetHashFromAssemblyFileW");
        if (g_GetHashFromAssemblyFileW){
            return (*g_GetHashFromAssemblyFileW)(wszFilePath, piHashAlg, pbHash, cchHash, pchHash);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

DWORD (__stdcall* g_GetHashFromFile)(LPCSTR, unsigned int *, BYTE *, DWORD, DWORD *) = NULL;
extern "C" DWORD __stdcall GetHashFromFile(LPCSTR szFilePath,
                                           unsigned int *piHashAlg,
                                           BYTE   *pbHash,
                                           DWORD  cchHash,
                                           DWORD  *pchHash)
{
    if (g_GetHashFromFile){
        return (*g_GetHashFromFile)(szFilePath, piHashAlg, pbHash, cchHash, pchHash);
    }
  
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetHashFromFile = (DWORD (__stdcall *)(LPCSTR, unsigned int *, BYTE *, DWORD, DWORD *))GetProcAddress(hReal, "GetHashFromFile");
        if (g_GetHashFromFile){
            return (*g_GetHashFromFile)(szFilePath, piHashAlg, pbHash, cchHash, pchHash);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

DWORD (__stdcall* g_GetHashFromFileW)(LPCWSTR, unsigned int *, BYTE *, DWORD, DWORD *) = NULL;
extern "C" DWORD __stdcall GetHashFromFileW(LPCWSTR wszFilePath,
                                            unsigned int *piHashAlg,
                                            BYTE   *pbHash,
                                            DWORD  cchHash,
                                            DWORD  *pchHash)
{
    if (g_GetHashFromFileW){
        return (*g_GetHashFromFileW)(wszFilePath, piHashAlg, pbHash, cchHash, pchHash);
    }
  
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetHashFromFileW = (DWORD (__stdcall *)(LPCWSTR, unsigned int *, BYTE *, DWORD, DWORD *))GetProcAddress(hReal, "GetHashFromFileW");
        if (g_GetHashFromFileW){
            return (*g_GetHashFromFileW)(wszFilePath, piHashAlg, pbHash, cchHash, pchHash);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

DWORD (__stdcall* g_GetHashFromHandle)(HANDLE, unsigned int *, BYTE *, DWORD, DWORD *) = NULL;
extern "C" DWORD __stdcall GetHashFromHandle(HANDLE hFile,
                                             unsigned int *piHashAlg,
                                             BYTE   *pbHash,
                                             DWORD  cchHash,
                                             DWORD  *pchHash)
{
    if (g_GetHashFromHandle){
        return (*g_GetHashFromHandle)(hFile, piHashAlg, pbHash, cchHash, pchHash);
    }
  
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetHashFromHandle = (DWORD (__stdcall *)(HANDLE, unsigned int *, BYTE *, DWORD, DWORD *))GetProcAddress(hReal, "GetHashFromHandle");
        if (g_GetHashFromHandle){
            return (*g_GetHashFromHandle)(hFile, piHashAlg, pbHash, cchHash, pchHash);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

DWORD (__stdcall* g_GetHashFromBlob)(BYTE *, DWORD, unsigned int *, BYTE *, DWORD, DWORD *) = NULL;
extern "C" DWORD __stdcall GetHashFromBlob(BYTE   *pbBlob,
                                           DWORD  cchBlob,
                                           unsigned int *piHashAlg,
                                           BYTE   *pbHash,
                                           DWORD  cchHash,
                                           DWORD  *pchHash)
{
    if (g_GetHashFromBlob){
        return (*g_GetHashFromBlob)(pbBlob, cchBlob, piHashAlg, pbHash, cchHash, pchHash);
    }
    
    HINSTANCE hReal;
    HRESULT hr = GetRealStrongNameDll(&hReal);
    if (SUCCEEDED(hr)) {
        g_GetHashFromBlob = (DWORD (__stdcall *)(BYTE *, DWORD, unsigned int *, BYTE *, DWORD, DWORD *))GetProcAddress(hReal, "GetHashFromBlob");
        if (g_GetHashFromBlob){
            return (*g_GetHashFromBlob)(pbBlob, cchBlob, piHashAlg, pbHash, cchHash, pchHash);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

//   CallFunctionShim was added for C#. They need to call a specific method that is side-by-side with the runtime.
extern "C" HRESULT __stdcall 
CallFunctionShim(LPCWSTR szDllName, LPCSTR szFunctionName, LPVOID lpvArgument1, LPVOID lpvArgument2, LPCWSTR szVersion, LPVOID pvReserved)
{
    HRESULT hr = NOERROR;
    HMODULE hmod = NULL;
    HRESULT (__stdcall * pfn)(LPVOID,LPVOID) = NULL;

    // Load library
    hr = LoadLibraryShim(szDllName, szVersion, pvReserved, &hmod);
    if (FAILED(hr)) return hr;
    
    // Find function.
    pfn = (HRESULT (__stdcall *)(LPVOID,LPVOID))GetProcAddress(hmod, szFunctionName);
    if (pfn == NULL)
        return HRESULT_FROM_WIN32(GetLastError());
    
    // Call it.
    return pfn(lpvArgument1, lpvArgument2);
}

//-------------------------------------------------------------------
// DllCanUnloadNow
//-------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    //!! Do not trigger a GetRealDll() here! Ole can call this at any time
    //!! and we don't want to commit to a selection here!
  if (g_pLoadedModules){
      for(ModuleList *pTemp = g_pLoadedModules; pTemp != NULL; pTemp = pTemp->Next){
        HRESULT (STDMETHODCALLTYPE* pDllCanUnloadNow)() = (HRESULT (STDMETHODCALLTYPE* )())GetProcAddress(pTemp->hMod, "DllCanUnloadNowInternal");
        if (pDllCanUnloadNow){
            if((*pDllCanUnloadNow)() != S_OK)
                goto retFalse;
        }
        else
            goto retFalse;
      }
  }
  return S_OK;
retFalse:
  return S_FALSE;
  // Need to thunk over and return whatever mscoree does 
  // If mscoree not loaded return S_OK
}  

//-------------------------------------------------------------------
// ReserveMemoryFor3gb
//
// Optionally reserve some amount of memory in 3gb processes for
// testing purposes. Also, in 3gb processes, try to reserve the
// pages at the 2gb boundary to help avoid any potential corner cases
// with datastructures spanning the boundary.
//-------------------------------------------------------------------
static void ReserveMemoryFor3gb(void)
{
    // Lets see if we've got an address space bigger than 2GB...
    MEMORYSTATUS hMemStat;
    hMemStat.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus(&hMemStat);

    if (hMemStat.dwTotalVirtual > 0x80000000)
    {
        // Cool, 3GB address space. We're assuming that >2GB = 3GB, of course, but that's okay for now.
        // Allocate low memory based on this registry key.
        size_t c = REGUTIL::GetConfigDWORD(L"3gbEatMem", 0);

        // We only get the high 16 bits from the config word.
        c <<= 16;

        if (c > 0)
        {
            // Some DLL's are lame. They don't like to be relocated above 2gb. Lets preload some of those loosers now...
            WszLoadLibrary(L"user32.dll");
            
            LPVOID lpWalk_Mem = NULL;
            MEMORY_BASIC_INFORMATION mbi;

            // Walk until we have seen all our regions.
            while (VirtualQuery(lpWalk_Mem, &mbi, sizeof(mbi)))
            {
                // Update the mem-walking Ptr.
                lpWalk_Mem = (LPVOID)(mbi.RegionSize + (size_t)mbi.BaseAddress);

                // Correct the data to be a 64k region edge.
                mbi.BaseAddress = (LPVOID)(((size_t)mbi.BaseAddress + 0xFFFF) & 0xFFFF0000);

                // If the region starts above our peak, stop
                if ((size_t)mbi.BaseAddress >= c)
                    break;

                // Make regionsize match 64k
                mbi.RegionSize = mbi.RegionSize & 0xFFFF0000;

                // If the region overflows our peak, change the regionsize.
                mbi.RegionSize = (((size_t)mbi.BaseAddress + mbi.RegionSize) > c ? (c - (size_t)mbi.BaseAddress) & 0xFFFF0000 : (size_t)mbi.RegionSize);

                // If block is free, an allocatable region, and not the first region, allocate it.
                if ((mbi.RegionSize) && (mbi.State == MEM_FREE) && (mbi.BaseAddress))
                {
                    VirtualAlloc(mbi.BaseAddress, mbi.RegionSize, MEM_RESERVE, PAGE_NOACCESS);
                }
            }
        }

        // Now, try to reserve the two pages at the 2gb boundary.
        DWORD dontReserve = REGUTIL::GetConfigDWORD(L"3gbDontReserveBoundary", 0);

        if (!dontReserve)
        {
            // VirtualAlloc works in 64k regions, so we take 2gb-64k for the first address, and we reserve 64k at a
            // time. Note also that we don't really care if these fail. That means someone already has the memory. Now,
            // that memory might get released at some point, and we might allocate it later, but there's no good way to
            // guard against that without hacking up all of our allocators to try to avoid this region.
            void *before = VirtualAlloc((void*)(0x80000000 - 0x10000), 0x10000, MEM_RESERVE, PAGE_NOACCESS);
            void *after = VirtualAlloc((void*)0x80000000, 0x10000, MEM_RESERVE, PAGE_NOACCESS);
        }
    }
}

//-------------------------------------------------------------------
// DllMain
//-------------------------------------------------------------------
BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwReason, LPVOID lpReserved)
{

    g_hShimMod = (HINSTANCE)hInstance;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        if(g_pCVMList == NULL) g_pCVMList = new ClsVerModList;
#ifdef _X86_
        // Check to see if we are running on 386 systems. If yes return false 
        SYSTEM_INFO sysinfo;
        GetSystemInfo(&sysinfo);

        if (sysinfo.dwProcessorType == PROCESSOR_INTEL_386 || sysinfo.wProcessorLevel == 3 )
            return FALSE;           // If the processor is 386 return false

        if (sysinfo.dwNumberOfProcessors == 1)
            g_bSingleProc = TRUE;

        OnUnicodeSystem();

        ReserveMemoryFor3gb();

        g_pResourceDll = new CCompRC(L"mscoreer.dll");
        if(g_pResourceDll == NULL)
            return FALSE;

        g_pResourceDll->SetResourceCultureCallbacks(GetMUILanguageName,
                                                    GetMUILanguageID,
                                                    GetMUIParentLanguageName);

#endif // _X86_
    }
    else
    if (dwReason == DLL_PROCESS_DETACH)
    {
        if(g_pCVMList)
        {
            while (ClsVerMod* pCVM = g_pCVMList->POP()) 
            {
                delete pCVM;
            }
            delete g_pCVMList;
            g_pCVMList = NULL;
        }
   
        if(g_FullPath) {
            delete[] g_FullPath;
            g_FullPath = NULL;
        }
        ClearGlobalSettings();

        g_hMod = NULL;

        if (g_FullStrongNamePath) {
            delete[] g_FullStrongNamePath;
            g_FullStrongNamePath = NULL;
        }

        for (;g_pLoadedModules != NULL;) {
            ModuleList *pTemp = g_pLoadedModules->Next;
            delete g_pLoadedModules;
            g_pLoadedModules = pTemp;
        }

        if(g_PreferredVersion != NULL) {
            delete g_PreferredVersion;
            g_PreferredVersion = NULL;
        }
        // Avoid the wrath of mem leak. Eagerly cleanup the entries. Destructor also
        // does the cleanup if for some reason this is not called.
        g_StrongNameFromPublicKeyMap.CleanupCachedEntries ();

        if(g_pResourceDll) delete g_pResourceDll;

#ifdef _DEBUG
        // Initialize Unicode wrappers
        OnUnicodeSystem();

#ifdef SHOULD_WE_CLEANUP
        BOOL fForceNoShutdownCleanup = REGUTIL::GetConfigDWORD(L"ForceNoShutdownCleanup", 0);
        BOOL fShutdownCleanup = REGUTIL::GetConfigDWORD(L"ShutdownCleanup", 0);
        // See if we have any open locks that would prevent us from cleaning up
        if (fShutdownCleanup && !fForceNoShutdownCleanup)
            DbgAllocReport("Mem Leak info coming from Shim.cpp");
#endif /* SHOULD_WE_CLEANUP */
#endif // _DEBUG

    }

    return TRUE;
}

inline BOOL ModuleIsInRange(HINSTANCE hMod,ModuleList *pHead,ModuleList *pLastElement=NULL)
{
    for(ModuleList *pData = pHead;pData!=pLastElement;pData=pData->Next)
    {
        if(pData->hMod==hMod)
            return TRUE;
    }
    return FALSE;
}

// hMod - the HINSTANCE to add to the list.
// pHead - can be NULL (empty list)
// PRECONDITION: The ModuleList from pHead on does not contain hMod.
// POSTCONDITION: AddModule will add hMod to the list in a thread-safe manner.
//                            if another thread beats AddModule, hMod will not be added.
HRESULT AddModule(HINSTANCE hMod,ModuleList *pHead)
{
    BOOL bDone = FALSE;
    ModuleList *pData = new ModuleList(hMod,pHead);

    if(pData==NULL)
    {
        return E_OUTOFMEMORY;
    }
    
    do
    {
        pData->Next = pHead;                
        ModuleList *pModuleDataValue = (ModuleList *)
            InterlockedCompareExchangePointer((PVOID *)&g_pLoadedModules,
            pData,pHead);

        if(pModuleDataValue!=pHead)
        {
            // The list changed.  Search from the new head
            // up to the old head to see if our module was
            // already added.
            pHead = g_pLoadedModules;
            if(ModuleIsInRange(pData->hMod,pHead,pData->Next))
            {
                delete pData;
                bDone = TRUE;
            }       
        }
        else
        {
            bDone = TRUE;
        }
    }
    while(!bDone);      

    return S_OK;
}

//------------------------------------------------------------------------------------------------------------------
// LoadLibraryWrapper: If loading the module succeeded adds the module to the global loaded modules list
//------------------------------------------------------------------------------------------------------------------
HINSTANCE LoadLibraryWrapper(LPCWSTR lpFileName){
    HINSTANCE hMod = WszLoadLibraryEx(lpFileName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    if (hMod)
    {
        ModuleList *pHead = g_pLoadedModules;
        if( !ModuleIsInRange(hMod,pHead) ) 
            AddModule(hMod,pHead);
    }
    return hMod;
}

HRESULT FindVersionForCLSID(REFCLSID rclsid, LPWSTR* lpVersion, BOOL fListedVersion)
{
    HRESULT hr  = S_OK;

    // Attempt and determine the version from the environment.
    *lpVersion = GetConfigString(L"Version", FALSE);
    if (!*lpVersion && fListedVersion)
    {
        // Attempt and determine the version througn the win32 SxS app context.
        hr = FindShimInfoFromWin32(rclsid, FALSE, lpVersion, NULL, NULL);
        if (FAILED(hr))
        {
            // Attempt to determine the version from the registry. If
            // this fails then version will be null which fine.
            // Later on we will search for a runtime iff version is null.
            hr = FindRuntimeVersionFromRegistry(rclsid, lpVersion, fListedVersion);
        }
    }

    return hr;
}// FindVersionForCLSID


STDAPI FindServerUsingCLSID(REFCLSID rclsid, HINSTANCE *hMod)
{
    WCHAR szID[64];
    WCHAR keyname[128];
    HKEY userKey = NULL;
    DWORD type;
    DWORD size;
    HRESULT lResult = E_FAIL;
    LPWSTR lpVersion = NULL;
    LPWSTR path = NULL;
    WCHAR dir[_MAX_PATH];
    LPWSTR serverName = NULL;
    HRESULT hr = S_OK;

    OnUnicodeSystem();
    
    GuidToLPWSTR(rclsid, szID, NumItems(szID));

    if (g_FullPath == NULL)
    {
        hr = FindVersionForCLSID(rclsid, &lpVersion, FALSE);
    }
    _ASSERTE(SUCCEEDED(hr) || lpVersion == NULL);
    hr = GetDirectoryLocation(lpVersion, dir, _MAX_PATH);
    IfFailGo(hr);
    
    wcscpy(keyname, L"CLSID\\");
    wcscat(keyname, szID);
    wcscat(keyname, L"\\Server");
    
    if ((WszRegOpenKeyEx(HKEY_CLASSES_ROOT, keyname, 0, KEY_READ, &userKey) == ERROR_SUCCESS) &&
        (WszRegQueryValueEx(userKey, NULL, 0, &type, 0, &size) == ERROR_SUCCESS) &&
        type == REG_SZ && size > 0) {
        
        serverName = new WCHAR[size + 1];
        if (!serverName) {
            lResult = E_OUTOFMEMORY;
            goto ErrExit;
        }
        
        lResult = WszRegQueryValueEx(userKey, NULL, 0, 0, (LPBYTE)serverName, &size);
        _ASSERTE(lResult == ERROR_SUCCESS);
    
        path = new WCHAR[_MAX_PATH + size + 1];
        if (!path) {
            lResult = E_OUTOFMEMORY;
            goto ErrExit;
        }

        wcscpy(path, dir);
        wcscat(path, serverName);
    
        *hMod = LoadLibraryWrapper(path);
        if(*hMod == NULL) {
            lResult = HRESULT_FROM_WIN32(GetLastError());
            goto ErrExit;
        }
    }

 ErrExit:
    
    if(serverName)
        delete [] serverName;

    if(path)
        delete [] path;

    if (lpVersion)
        delete [] lpVersion;

    if(userKey)
        RegCloseKey(userKey);

    if (*hMod){
        return S_OK; 
    }
    else
        return E_FAIL;
}
   
//-------------------------------------------------------------------
// DllGetClassObject
//-------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv)
{

    HINSTANCE hMod = NULL;
    HRESULT hr = S_OK;
    
    ClsVerMod *pCVM=NULL, *pCVMdummy = NULL;
    HRESULT (STDMETHODCALLTYPE * pDllGetClassObject)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);

    pDllGetClassObject = NULL;
    if(g_pCVMList)
    {
        if((pCVMdummy = new ClsVerMod(rclsid,NULL)))
        {
            pCVM = g_pCVMList->FIND(pCVMdummy);
            if(pCVM && pCVM->m_pv)
            {
                pDllGetClassObject = (HRESULT (STDMETHODCALLTYPE *)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv))pCVM->m_pv;
            }
        }
    }
    
    if(pDllGetClassObject == NULL)
    {
        if(FAILED(FindServerUsingCLSID(rclsid, &hMod)) || hMod == NULL)
        {
            hr = GetRealDll(&hMod); 
        }
        if(SUCCEEDED(hr))
        {
            pDllGetClassObject = (HRESULT (STDMETHODCALLTYPE *)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv))GetProcAddress(hMod, "DllGetClassObjectInternal");

            if (pDllGetClassObject==NULL && GetLastError()==ERROR_PROC_NOT_FOUND)
                pDllGetClassObject=(HRESULT (STDMETHODCALLTYPE *)(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv))GetProcAddress(hMod, "DllGetClassObject");
            if(g_pCVMList)
            {
                if(pCVM == NULL)
                {
                    if(pCVMdummy)
                    {
                        pCVMdummy->m_pv = (void*)pDllGetClassObject;
                        g_pCVMList->PUSH(pCVMdummy);
                        pCVMdummy = NULL; // to avoid deletion on exit
                    }
                }
                else
                    pCVM->m_pv = (void*)pDllGetClassObject;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pDllGetClassObject ? pDllGetClassObject(rclsid, riid, ppv)
                                : CLR_E_SHIM_RUNTIMEEXPORT;
    }
    if(pCVMdummy) delete pCVMdummy;
    return hr;
}


STDAPI DllRegisterServer()
{
    HINSTANCE hMod;
    HRESULT hr = GetRealDll(&hMod);
    if(SUCCEEDED(hr)) 
    {
        DWORD lgth;
        WCHAR directory[_MAX_PATH];
        hr = GetCORSystemDirectory(directory, NumItems(directory), &lgth);
        if(SUCCEEDED(hr)) {
            HRESULT (STDMETHODCALLTYPE * pDllRegisterServerInternal)(HINSTANCE,LPCTSTR) = (HRESULT (STDMETHODCALLTYPE *)(HINSTANCE, LPCTSTR))GetProcAddress(hMod, "DllRegisterServerInternal");
        if(pDllRegisterServerInternal) {
                return pDllRegisterServerInternal(g_hShimMod, directory);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
        }
    }
    return hr;
}

HRESULT (STDMETHODCALLTYPE * pGetAssemblyMDImport)(LPCWSTR szFileName, REFIID riid, LPVOID FAR *ppv) = NULL;
STDAPI GetAssemblyMDImport(LPCWSTR szFileName, REFIID riid, LPVOID FAR *ppv)
{
    if (pGetAssemblyMDImport)
        return pGetAssemblyMDImport(szFileName, riid, ppv);

    HINSTANCE hMod;
    HRESULT hr = GetRealDll(&hMod);
    if(SUCCEEDED(hr)) 
    {
        pGetAssemblyMDImport = (HRESULT (STDMETHODCALLTYPE *)(LPCWSTR szFileName, REFIID riid, LPVOID FAR *ppv))GetProcAddress(hMod, "GetAssemblyMDImport");
        if (pGetAssemblyMDImport){
            return pGetAssemblyMDImport(szFileName, riid, ppv);
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return hr;
}

BOOL (STDMETHODCALLTYPE * g_pCorDllMain)(
                                     HINSTANCE   hInst,                  // Instance handle of the loaded module.
                                     DWORD       dwReason,               // Reason for loading.
                                     LPVOID      lpReserved              // Unused.
                                     );

BOOL STDMETHODCALLTYPE _CorDllMain(     // TRUE on success, FALSE on error.
    HINSTANCE   hInst,                  // Instance handle of the loaded module.
    DWORD       dwReason,               // Reason for loading.
    LPVOID      lpReserved              // Unused.
    )
{
    
    if(g_pCorDllMain) 
    {
        return g_pCorDllMain(hInst, dwReason, lpReserved);
    }
    HINSTANCE hReal;
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) 
    {
        *((VOID**)&g_pCorDllMain) = GetProcAddress(hReal, "_CorDllMain");
        if(g_pCorDllMain) {
            return g_pCorDllMain(
                             hInst,                  // Instance handle of the loaded module.
                             dwReason,               // Reason for loading.
                             lpReserved              // Unused.
                             );
        }
        hr = CLR_E_SHIM_RUNTIMEEXPORT;
    }
    return FALSE;
}



//*****************************************************************************
// This entry point is called from the native entry piont of the loaded 
// executable image.  The command line arguments and other entry point data
// will be gathered here.  The entry point for the user image will be found
// and handled accordingly.
// Under WinCE, there are a couple of extra parameters because the hInst is not
// the module's base load address and the others are not available elsewhere.
//*****************************************************************************
__int32 STDMETHODCALLTYPE _CorExeMain(  // Executable exit code.
                                     )
{
    HINSTANCE hReal;
    HRESULT hr = GetInstallation(TRUE, &hReal);
    if (SUCCEEDED(hr)) 
    {
        __int32 (STDMETHODCALLTYPE * pRealFunc)();
        *((VOID**)&pRealFunc) = GetProcAddress(hReal, "_CorExeMain");
        if(pRealFunc) {
            return pRealFunc();
        }
    }
    return hr;
}


__int32 STDMETHODCALLTYPE _CorExeMain2( // Executable exit code.
    PBYTE   pUnmappedPE,                // -> memory mapped code
    DWORD   cUnmappedPE,                // Size of memory mapped code
    LPWSTR  pImageNameIn,               // -> Executable Name
    LPWSTR  pLoadersFileName,           // -> Loaders Name
    LPWSTR  pCmdLine)                   // -> Command Line
{
    HINSTANCE hReal;
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) 
    {
        __int32 (STDMETHODCALLTYPE * pRealFunc)(
            PBYTE   pUnmappedPE,                // -> memory mapped code
            DWORD   cUnmappedPE,                // Size of memory mapped code
            LPWSTR  pImageNameIn,               // -> Executable Name
            LPWSTR  pLoadersFileName,           // -> Loaders Name
            LPWSTR  pCmdLine);                  // -> Command Line
        *((VOID**)&pRealFunc) = GetProcAddress(hReal, "_CorExeMain2");
        if(pRealFunc) {
            return pRealFunc(
                             pUnmappedPE,                // -> memory mapped code
                             cUnmappedPE,                // Size of memory mapped code
                             pImageNameIn,               // -> Executable Name
                             pLoadersFileName,           // -> Loaders Name
                             pCmdLine);                  // -> Command Line
        }
    }
    return -1;
}


__int32 STDMETHODCALLTYPE _CorClassMain(// Exit code.
    LPWSTR  entryClassName)             // Class name to execute.
{
    HINSTANCE hReal;
    HRESULT hr = GetRealDll(&hReal);
    if (SUCCEEDED(hr)) 
    {
        __int32 (STDMETHODCALLTYPE * pRealFunc)(LPWSTR entryClassName);

        *((VOID**)&pRealFunc) = GetProcAddress(hReal, "_CorExeMain");
        if(pRealFunc) {
            return pRealFunc(entryClassName);
        }
    }
    return -1;
}

StrongNameTokenFromPublicKeyCache::StrongNameTokenFromPublicKeyCache ()
{
#ifdef _DEBUG
    for (DWORD i=GetFirstPublisher(); i<MAX_CACHED_STRONG_NAMES; i++)
    {
        m_Entry[i] = NULL;
    }
#endif

    if (!StrongNameTokenFromPublicKeyCache::IsInited())
    {
        m_dwNumEntries = 2;
        m_Entry[0] = &g_MSStrongNameCacheEntry;
        m_Entry[1] = &g_ECMAStrongNameCacheEntry;
        m_spinLock = 0;
        StrongNameTokenFromPublicKeyCache::s_IsInited = TRUE;
    }

#ifdef _DEBUG
    // For debug builds exercise the AddEntry code path. After adding the 
    // Microsoft's strongname from StrongNameDll the code path to FindEntry 
    // is same in debug and non-debug builds.
    m_dwNumEntries = 0;
    m_Entry[0] = NULL;
    m_Entry[1] = NULL;
    m_holderThreadId = 0;
#endif

}

StrongNameTokenFromPublicKeyCache::~StrongNameTokenFromPublicKeyCache ()
{
    CleanupCachedEntries ();
}

void StrongNameTokenFromPublicKeyCache::CleanupCachedEntries ()
{
    if (!StrongNameTokenFromPublicKeyCache::IsInited())
        return;

    EnterSpinLock ();
    
    for (DWORD idx=GetFirstPublisher(); idx<GetNumPublishers(); idx++)
    {
        _ASSERTE (m_Entry [idx]);
        if (m_Entry [idx]->m_fCreationFlags & STRONG_NAME_ENTRY_ALLOCATED_BY_SHIM)
        {
            _ASSERTE (m_Entry [idx]->m_fCreationFlags & STRONG_NAME_ENTRY_ALLOCATED_BY_SHIM);
            _ASSERTE (m_Entry [idx]->m_fCreationFlags & ~STRONG_NAME_TOKEN_ALLOCATED_BY_STRONGNAMEDLL);
            
            _ASSERTE (m_Entry [idx]->m_pbStrongName);
            delete [] m_Entry [idx]->m_pbStrongName;
            _ASSERTE (m_Entry [idx]->m_pbStrongNameToken);
            delete [] m_Entry [idx]->m_pbStrongNameToken;
            
            delete m_Entry [idx];
        }
    }
    m_dwNumEntries = 0;
    StrongNameTokenFromPublicKeyCache::s_IsInited = FALSE;

    LeaveSpinLock();
}

BOOL StrongNameTokenFromPublicKeyCache::FindEntry (BYTE    *pbPublicKeyBlob,
                                                   ULONG    cbPublicKeyBlob,
                                                   BYTE   **ppbStrongNameToken,
                                                   ULONG   *pcbStrongNameToken)
{
    _ASSERTE (StrongNameTokenFromPublicKeyCache::IsInited());
    
    EnterSpinLock ();
    
    for (DWORD idx=GetFirstPublisher(); idx<GetNumPublishers(); idx++)
    {
        _ASSERTE (m_Entry [idx]);
        if (m_Entry [idx]->m_cbStrongName == cbPublicKeyBlob)
        {
            if (0 == memcmp (m_Entry [idx]->m_pbStrongName, pbPublicKeyBlob, cbPublicKeyBlob))
            {
                // Found the public key in the cache. Lookup the token and return.
                *ppbStrongNameToken = m_Entry [idx]->m_pbStrongNameToken;
                *pcbStrongNameToken = m_Entry [idx]->m_cbStrongNameToken;
                LeaveSpinLock ();
                return TRUE;
            }
        }
    }
    
    LeaveSpinLock ();

    // Didn't find it in the cache. Return false. We would add it once the StrongNameDll finds it.
    return FALSE;
}

BOOL StrongNameTokenFromPublicKeyCache::ShouldFreeBuffer  (BYTE *pbMemory)
{
    _ASSERTE (StrongNameTokenFromPublicKeyCache::IsInited());

    EnterSpinLock ();

    // We delete publisher entries only in the destructor.
    // So if this buffer pointer is one of our entries then 
    // don't bother deleteing. 
    for (DWORD i=GetFirstPublisher(); i<GetNumPublishers(); i++)
    {
        _ASSERTE (m_Entry [i]);
        if ((m_Entry [i]->m_pbStrongNameToken == pbMemory) || (m_Entry [i]->m_pbStrongName == pbMemory))
        {
            // Its a buffer allocated by the cache. Don't delete.
            LeaveSpinLock();
            return TRUE;
        }
    }

    LeaveSpinLock();

    // The buffer pointer is not allocated by the cache. Let the StrongNameDll handle it.
    return FALSE;
}

void StrongNameTokenFromPublicKeyCache::AddEntry  (BYTE    *pbPublicKeyBlob,
                                                   ULONG    cbPublicKeyBlob,
                                                   BYTE   **ppbStrongNameToken,
                                                   ULONG   *pcbStrongNameToken,
                                                   BOOL     fCreationFlags)
{
    EnterSpinLock ();
    
    _ASSERTE (StrongNameTokenFromPublicKeyCache::IsInited());
    
    // We assume that this entry is not already in the Cache.
    // In the worst case we have duplicates which is ok...

    BYTE* _pbPublicKeyBlob = new BYTE [cbPublicKeyBlob];
    BYTE* _pbStrongNameToken = new BYTE [*pcbStrongNameToken];

    if ((NULL == _pbPublicKeyBlob) || (NULL == _pbStrongNameToken))
    {
        if (_pbPublicKeyBlob)
            delete[] _pbPublicKeyBlob;
        if(_pbStrongNameToken)
            delete[] _pbStrongNameToken;
        // Uh-oh out of memory. Give up on caching
        LeaveSpinLock();
        return;
    }

    // Can we add the new entry into the cache? idx is 0-based so check for idx+1
    DWORD idx = GetNewPublisher();
    if ((idx+1) > MAX_CACHED_STRONG_NAMES)
    {
        // Out of cache entries...Don't bother growing the cache.
        delete [] _pbPublicKeyBlob;
        delete [] _pbStrongNameToken;
        LeaveSpinLock();
        return;
    }
    
    memcpy (_pbPublicKeyBlob, pbPublicKeyBlob, cbPublicKeyBlob);
    memcpy (_pbStrongNameToken, *ppbStrongNameToken, *pcbStrongNameToken);

    _ASSERTE (fCreationFlags & STRONG_NAME_TOKEN_ALLOCATED_BY_STRONGNAMEDLL);

    // Free the buffer allocated by the StrongNameDll.
    StrongNameFreeBufferHelper (*ppbStrongNameToken);

    // Swtich pointers such that the returned buffer points to the one in the cache.
    *ppbStrongNameToken = _pbStrongNameToken;

    // Set the flags to indicate that we have allocated the buffer 
    // and free'd the StrongNameDll's buffers
    m_Entry [idx] = new StrongNameCacheEntry (cbPublicKeyBlob, 
                                              _pbPublicKeyBlob, 
                                              *pcbStrongNameToken, 
                                              _pbStrongNameToken, 
                                              STRONG_NAME_ENTRY_ALLOCATED_BY_SHIM
                                              );
    LeaveSpinLock ();
}


//----------------------------------------
// _CorValidateImage && _CorImageUnloading
//
// _CorValidateImage is called by the loader early in the load process on Whistler (NT 5.1) and
// later platforms.  The purpose is to enable verified execution from the beginning ... we can
// get control BEFORE any native code runs.
//
// On all architectures, _CorValidateImage will replace the DLL/EXE entry point
// with a pseudo-RVA that refers to _CorDllMain/_CorExeMain.  
//
// On 64-bit architectures, IL_ONLY EXEs and DLLs and will be rewritten in-place; changed from
// pe32 to pe32+ format.
//
// NB.  The loader has a reqirement that these routines do NOT cause other dlls to be loaded
// or initialized.  The "or initialized" requirement is subtle.  Various kernel32 calls
// can cause seemingly unrelated dlls to be inited.  (e.g. We used to have a call to 
// GetProcAddress("mscoree.dll","_CorValidateImage" in here that would cause MSVCR70.DLL to
// be inited, and then unloaded in error.)
//
// No real reason why any of these routine should change, but should anyone ever need to change
// these, suggest discussing with an NT loader person.

#ifndef STATUS_INVALID_IMAGE_FORMAT
#define STATUS_INVALID_IMAGE_FORMAT ((HRESULT)0xC000007BL)
#endif

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS              ((HRESULT)0x00000000L)
#endif

//----------------------------------------------------------------------------
// This routine converts a PE32 header to a PE32+ header in place.  The image
// must be an IL_ONLY image.  
//
#ifdef _WIN64

static
HRESULT PE32ToPE32Plus(PBYTE pImage) {
    IMAGE_DOS_HEADER *pDosHeader = (IMAGE_DOS_HEADER*)pImage;
    IMAGE_NT_HEADERS32 *pHeader32 = (IMAGE_NT_HEADERS32*) (pImage + pDosHeader->e_lfanew);
    IMAGE_NT_HEADERS64 *pHeader64 = (IMAGE_NT_HEADERS64*) pHeader32;

    _ASSERTE(&pHeader32->OptionalHeader.Magic == &pHeader32->OptionalHeader.Magic);
    _ASSERTE(pHeader32->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC);

    // Move the data directory and section headers down 16 bytes.
    PBYTE pEnd32 = (PBYTE) (IMAGE_FIRST_SECTION(pHeader32)
                            + pHeader32->FileHeader.NumberOfSections);
    PBYTE pStart32 = (PBYTE) &pHeader32->OptionalHeader.DataDirectory[0];
    PBYTE pStart64 = (PBYTE) &pHeader64->OptionalHeader.DataDirectory[0];
    _ASSERTE(pStart64 - pStart32 == 16);

    if ( (pEnd32 - pImage) + 16 /* delta in headers */ + 16 /* label descriptor */ > 4096 ) {
        // This should never happen.  An IL_ONLY image should at most 3 sections.  
        _ASSERTE(!"_CORValidateImage(): Insufficent room to rewrite headers as PE32+");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    memmove(pStart64, pStart32, pEnd32 - pStart32);

    // Move the tail fields in reverse order.
    pHeader64->OptionalHeader.NumberOfRvaAndSizes = pHeader32->OptionalHeader.NumberOfRvaAndSizes;
    pHeader64->OptionalHeader.LoaderFlags = pHeader32->OptionalHeader.LoaderFlags;
    pHeader64->OptionalHeader.SizeOfHeapCommit = pHeader32->OptionalHeader.SizeOfHeapCommit;
    pHeader64->OptionalHeader.SizeOfHeapReserve = pHeader32->OptionalHeader.SizeOfHeapReserve;
    pHeader64->OptionalHeader.SizeOfStackCommit = pHeader32->OptionalHeader.SizeOfStackCommit;
    pHeader64->OptionalHeader.SizeOfStackReserve = pHeader32->OptionalHeader.SizeOfStackReserve;

    // One more field that's not the same
    pHeader64->OptionalHeader.ImageBase = pHeader32->OptionalHeader.ImageBase;

    // The optional header changed size.
    pHeader64->FileHeader.SizeOfOptionalHeader += 16;
    pHeader64->OptionalHeader.Magic = IMAGE_NT_OPTIONAL_HDR64_MAGIC;

    // Several directorys can now be nuked.
    pHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = 0;
    pHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size = 0;
    pHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress = 0;
    pHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size = 0;
    pHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = 0;
    pHeader64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = 0;

    // Great.  Now just have to make a new slot for the entry point.
    PBYTE pEnd64 = (PBYTE) (IMAGE_FIRST_SECTION(pHeader64) + pHeader64->FileHeader.NumberOfSections);
    pHeader64->OptionalHeader.AddressOfEntryPoint = (ULONG) (pEnd64 - pImage);
    // This will get filled in shortly ...

    return STATUS_SUCCESS;
}


STDAPI _CorValidateImage(PVOID *ImageBase, LPCWSTR FileName) {
    //@TODO TLS callbacks are still a security threat here
    // Verify that it's one of our headers.
    PBYTE pImage = (PBYTE) *ImageBase;
    HRESULT hr = STATUS_SUCCESS;

    IMAGE_DOS_HEADER *pDosHeader = (IMAGE_DOS_HEADER*)pImage;
    IMAGE_NT_HEADERS64 *pHeader64 = (IMAGE_NT_HEADERS64*) (pImage + pDosHeader->e_lfanew);

    PPLABEL_DESCRIPTOR ppLabelDescriptor;

    // If we get this far, we're going to modify the image.
    DWORD oldProtect;
    if (!VirtualProtect(pImage, 4096, PAGE_READWRITE, &oldProtect)) {
        // This is bad.  Not going to be able to update header.
        _ASSERTE(!"_CorValidateImage(): VirtualProtect() change image header to R/W failed.\n");
        return GetLastError();
    }

    if (pHeader64->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        // A PE32! Needs to be re-written.
        IMAGE_NT_HEADERS32 *pHeader32 = (IMAGE_NT_HEADERS32*) (pHeader64);
        IMAGE_COR20_HEADER *pComPlusHeader = (IMAGE_COR20_HEADER*) (pImage + 
                pHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress);
        _ASSERTE(pComPlusHeader->Flags &  COMIMAGE_FLAGS_ILONLY);
        hr = PE32ToPE32Plus(pImage);
        if (FAILED(hr)) goto exit;
    }

    // OK.  We have a valid PE32+ image now.  Just have to whack the starting address.
    _ASSERTE(pHeader64->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC);

    ppLabelDescriptor = (PPLABEL_DESCRIPTOR) (pImage + pHeader64->OptionalHeader.AddressOfEntryPoint);
    if (pHeader64->FileHeader.Characteristics & IMAGE_FILE_DLL) {
        *ppLabelDescriptor = *(PPLABEL_DESCRIPTOR)_CorDllMain;
    } else {
        *ppLabelDescriptor = *(PPLABEL_DESCRIPTOR)_CorExeMain;
    }

exit:
    DWORD junk;
    if (!VirtualProtect(pImage, 4096, oldProtect, &junk)) {
        _ASSERTE(!"_CorValidateImage(): VirtualProtect() reset image header failed.\n");
        return GetLastError();
    }
    return hr;
}

#else

int ascii_stricmp (const char * dst, const char * src) {
    int f, l;

    do {
        if ( ((f = (unsigned char)(*(dst++))) >= 'A') &&
             (f <= 'Z') )
            f -= 'A' - 'a';
        if ( ((l = (unsigned char)(*(src++))) >= 'A') &&
             (l <= 'Z') )
            l -= 'A' - 'a';
    } while ( f && (f == l) );

    return(f - l);
}

void WhistlerMscoreeRefCountWorkAround() {

    OSVERSIONINFOW osVersionInfo={0};
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    WszGetVersionEx(&osVersionInfo);

    if (osVersionInfo.dwMajorVersion == 5 
        && osVersionInfo.dwMinorVersion == 1
        && osVersionInfo.dwBuildNumber < 2491) {

        // We're on Whistler w/ a loader bug that gets the refcount on mscoree wrong.
        HMODULE hMod = LoadLibraryA("mscoree.dll");
    }
}

void WhistlerBeta2LoaderBugWorkAround(PBYTE pImage) {

    OSVERSIONINFOW osVersionInfo={0};
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    WszGetVersionEx(&osVersionInfo);

    if (osVersionInfo.dwMajorVersion == 5 
        && osVersionInfo.dwMinorVersion == 1
        && osVersionInfo.dwBuildNumber <= 2473) {

        // We're on Whistler w/ a loader bug that ignores imports other than mscoree.  This
        // isn't good for IJW images.  As a workaround (huge kludge), walk the IAT, and do a LL on 
        // each entry other than mscoree that we find there.
        // 
        IMAGE_DOS_HEADER *pDosHeader = (IMAGE_DOS_HEADER*)pImage;
        IMAGE_NT_HEADERS32 *pHeader32 = (IMAGE_NT_HEADERS32*) (pImage + pDosHeader->e_lfanew);
        DWORD ImportTableRVA = pHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
        if (ImportTableRVA == 0)
            return;     // Zapped images may have no ImportTable.

        IMAGE_IMPORT_DESCRIPTOR *pImageImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*) (pImage + ImportTableRVA);

        while (pImageImportDescriptor->Name != 0) {

            // If it's not mscoree, do a LL to bump it's refcount.
            LPCSTR pImageName = (LPCSTR) pImage + pImageImportDescriptor->Name;
            if (ascii_stricmp(pImageName, "mscoree.dll") != 0) {
                HMODULE hMod = LoadLibraryA(pImageName);
            }
            pImageImportDescriptor++;
        }
    }
}

BOOL
GetDirectory(IMAGE_NT_HEADERS32 *pHeader32, DWORD index, DWORD *RVA, DWORD *Size) {
    *RVA = pHeader32->OptionalHeader.DataDirectory[index].VirtualAddress;
    *Size = pHeader32->OptionalHeader.DataDirectory[index].Size;
    if (*RVA != 0 && *RVA != -1 && *Size != 0)
        return TRUE;
    else
        return FALSE;
}

DWORD
ValidateILOnlyDirectories(IMAGE_NT_HEADERS32 *pNT)
{

    _ASSERTE(pNT);

    #ifndef IMAGE_DIRECTORY_ENTRY_COMHEADER
    #define IMAGE_DIRECTORY_ENTRY_COMHEADER 14
    #endif

    #ifndef CLR_MAX_RVA
    #define CLR_MAX_RVA 0x80000000L
    #endif

    // See if the bitmap's i'th bit 0 ==> 1st bit, 1 ==> 2nd bit...
    #define IS_SET_DWBITMAP(bitmap, i) ( ((i) > 31) ? 0 : ((bitmap) & (1 << (i))) )

    PIMAGE_FILE_HEADER pFH = (PIMAGE_FILE_HEADER) &(pNT->FileHeader);
    PIMAGE_OPTIONAL_HEADER pOH = (PIMAGE_OPTIONAL_HEADER) &(pNT->OptionalHeader);
    PIMAGE_SECTION_HEADER pSH = (PIMAGE_SECTION_HEADER) ( (PBYTE)pOH + pFH->SizeOfOptionalHeader);

    DWORD ImageLength = pOH->SizeOfImage;
    DWORD nEntries = pOH->NumberOfRvaAndSizes;
    
    // Construct a table of allowed directories
    //
    // IMAGE_DIRECTORY_ENTRY_IMPORT     1   Import Directory
    // IMAGE_DIRECTORY_ENTRY_RESOURCE   2   Resource Directory
    // IMAGE_DIRECTORY_ENTRY_SECURITY   4   Security Directory
    // IMAGE_DIRECTORY_ENTRY_BASERELOC  5   Base Relocation Table
    // IMAGE_DIRECTORY_ENTRY_DEBUG      6   Debug Directory
    // IMAGE_DIRECTORY_ENTRY_IAT        12  Import Address Table
    //
    // IMAGE_DIRECTORY_ENTRY_COMHEADER  14  COM+ Data
    //
    // Construct a 0 based bitmap with these bits.
    static DWORD s_dwAllowedBitmap = 
        ((1 << (IMAGE_DIRECTORY_ENTRY_IMPORT   )) |
         (1 << (IMAGE_DIRECTORY_ENTRY_RESOURCE )) |
         (1 << (IMAGE_DIRECTORY_ENTRY_SECURITY )) |
         (1 << (IMAGE_DIRECTORY_ENTRY_BASERELOC)) |
         (1 << (IMAGE_DIRECTORY_ENTRY_DEBUG    )) |
         (1 << (IMAGE_DIRECTORY_ENTRY_IAT      )) |
         (1 << (IMAGE_DIRECTORY_ENTRY_COMHEADER)));

    for (DWORD dw = 0; dw < nEntries; dw++)
    {
        // Check for the existance of the directory
        if ((pOH->DataDirectory[dw].VirtualAddress != 0)
            || (pOH->DataDirectory[dw].Size != 0))
        {
            // Is it unexpected?
            if (!IS_SET_DWBITMAP(s_dwAllowedBitmap, dw))
                return STATUS_INVALID_IMAGE_FORMAT;

            // Is it's addressing to high?
            if ((pSH[dw].VirtualAddress & CLR_MAX_RVA) || (pSH[dw].SizeOfRawData & CLR_MAX_RVA) || ((pSH[dw].VirtualAddress + pSH[dw].SizeOfRawData) & CLR_MAX_RVA))
                return STATUS_INVALID_IMAGE_FORMAT;
            
            // Is it's addressing overflowing the image?
            if ((pSH[dw].VirtualAddress + pSH[dw].SizeOfRawData) > ImageLength)
                return STATUS_INVALID_IMAGE_FORMAT;
        }
    }
    return STATUS_SUCCESS;
}


DWORD
ValidateILOnlyImage(IMAGE_NT_HEADERS32 *pNT, PBYTE pImage) {

    // We don't care about the import stub, but we do care about the import table.  It must contain
    // only mscoree.  Anything else must fail to load so that you can't have a rogue dll with an
    // dllinit routine that runs before we apply our security policy.

    DWORD ImportTableRVA, ImportTableSize;
    DWORD BaseRelocRVA, BaseRelocSize;
    DWORD IATRVA, IATSize;

    if (ValidateILOnlyDirectories(pNT) != STATUS_SUCCESS)
        return STATUS_INVALID_IMAGE_FORMAT;

    if (!GetDirectory(pNT, IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportTableRVA, &ImportTableSize))
        return STATUS_INVALID_IMAGE_FORMAT;

    if (!GetDirectory(pNT, IMAGE_DIRECTORY_ENTRY_BASERELOC, &BaseRelocRVA, &BaseRelocSize))
        return STATUS_INVALID_IMAGE_FORMAT;

    if (!GetDirectory(pNT, IMAGE_DIRECTORY_ENTRY_IAT, &IATRVA, &IATSize))
        return STATUS_INVALID_IMAGE_FORMAT;

    // There should be space for atleast 2 entries.
    // The second one being a null entry.
    if (ImportTableSize < 2*sizeof(IMAGE_IMPORT_DESCRIPTOR))
        return STATUS_INVALID_IMAGE_FORMAT;

    PIMAGE_IMPORT_DESCRIPTOR pID = (PIMAGE_IMPORT_DESCRIPTOR) (pImage + ImportTableRVA);

    // Entry 1 must be all nulls.
    if (pID[1].OriginalFirstThunk != 0
        || pID[1].TimeDateStamp != 0
        || pID[1].ForwarderChain != 0
        || pID[1].Name != 0
        || pID[1].FirstThunk != 0)
        return STATUS_INVALID_IMAGE_FORMAT;

    // In entry zero, ILT, Name, IAT must be be non-null.  Forwarder, DateTime should be NULL.
    if (   pID[0].OriginalFirstThunk == 0
        || pID[0].TimeDateStamp != 0
        || (pID[0].ForwarderChain != 0 && pID[0].ForwarderChain != -1)
        || pID[0].Name == 0
        || pID[0].FirstThunk == 0)
        return STATUS_INVALID_IMAGE_FORMAT;

    // FirstThunk must be same as IAT
    if (pID[0].FirstThunk != IATRVA)
        return STATUS_INVALID_IMAGE_FORMAT;

    // We don't need to validate the ILT or the startup thunk, as they are being bypassed.

    // Name must refer to mscoree.
    LPCSTR pImportName = (LPCSTR) (pImage + pID[0].Name);
    if (ascii_stricmp(pImportName, "mscoree.dll") != 0) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    // Make sure the name is within the image.
    if (pID[0].Name > pNT->OptionalHeader.SizeOfImage)
        return STATUS_INVALID_IMAGE_FORMAT;

    // Should have a base reloc directory ... relocs should not be stripped.
    if (pNT->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED) {
        return STATUS_INVALID_IMAGE_FORMAT;
    }
    // Must have one Base Reloc, It must be a HIGHLOW reloc for the first entry in the IAT.
    if (BaseRelocSize != 0xC || BaseRelocRVA == 0)
        return STATUS_INVALID_IMAGE_FORMAT;

    IMAGE_BASE_RELOCATION *pIBR = (IMAGE_BASE_RELOCATION*) (pImage + BaseRelocRVA);
    if (pIBR->SizeOfBlock != 0xC)
        return STATUS_INVALID_IMAGE_FORMAT;

    // First fixup must be HIGHLOW @ EntryPoint + 2.  
    // Second fixup must be of type IMAGE_REL_BASED_ABSOLUTE (skipped).
    USHORT *pFixups = (USHORT *)(pIBR + 1);
    if (   pFixups[0] >> 12 != IMAGE_REL_BASED_HIGHLOW
        || pIBR->VirtualAddress + (pFixups[0] & 0xfff) != pNT->OptionalHeader.AddressOfEntryPoint + 2
        || pFixups[1] >> 12 != IMAGE_REL_BASED_ABSOLUTE)
        return STATUS_INVALID_IMAGE_FORMAT;

    return STATUS_SUCCESS;
}



// 32-bit _CorValidateImage
#define STATUS_ERROR 0xC0000000
#define STATUS_ACCESS_DISABLED_BY_POLICY_PATH 0xC0000362L

DWORD
SaferValidate(LPCWSTR FileName) {

    // If advapi is not loaded, assume that SAFER policy is not being applied.
    HMODULE hMod = WszGetModuleHandle(L"advapi32.dll");
    if (hMod == NULL)
        return STATUS_SUCCESS;    

    typedef BOOL (WINAPI *PFNSAFERIDENTIFYLEVEL) (
        DWORD dwNumProperties,
        PSAFER_CODE_PROPERTIES pCodeProperties,
        SAFER_LEVEL_HANDLE *pLevelHandle,
        LPVOID lpReserved);

    typedef BOOL (WINAPI *PFNSAFERGETLEVELINFORMATION) (
        SAFER_LEVEL_HANDLE LevelHandle,
        SAFER_OBJECT_INFO_CLASS dwInfoType,
        LPVOID lpQueryBuffer,
        DWORD dwInBufferSize,
        LPDWORD lpdwOutBufferSize);

    typedef BOOL (WINAPI *PFNSAFERCLOSELEVEL) (SAFER_LEVEL_HANDLE hLevelHandle);

    typedef BOOL (WINAPI *PFNSAFERRECORDEVENTLOGENTRY) (
        SAFER_LEVEL_HANDLE hLevel,
        LPCWSTR szTargetPath,
        LPVOID lpReserved);


    PFNSAFERIDENTIFYLEVEL pfnSaferIdentifyLevel;
    PFNSAFERGETLEVELINFORMATION pfnSaferGetLevelInformation;
    PFNSAFERCLOSELEVEL pfnSaferCloseLevel;
    PFNSAFERRECORDEVENTLOGENTRY pfnSaferRecordEventLogEntry;

    pfnSaferIdentifyLevel = (PFNSAFERIDENTIFYLEVEL) GetProcAddress(hMod, "SaferIdentifyLevel");
    pfnSaferGetLevelInformation = (PFNSAFERGETLEVELINFORMATION) GetProcAddress(hMod, "SaferGetLevelInformation");
    pfnSaferCloseLevel = (PFNSAFERCLOSELEVEL) GetProcAddress(hMod, "SaferCloseLevel");
    pfnSaferRecordEventLogEntry = (PFNSAFERRECORDEVENTLOGENTRY) GetProcAddress(hMod, "SaferRecordEventLogEntry");

    if (pfnSaferIdentifyLevel == 0 
        || pfnSaferGetLevelInformation == 0
        || pfnSaferCloseLevel == 0
        || pfnSaferRecordEventLogEntry == 0)
        return STATUS_SUCCESS;

    DWORD rc;
    SAFER_LEVEL_HANDLE Level = NULL;
    DWORD dwSaferLevelId = SAFER_LEVELID_DISALLOWED;
    DWORD dwOutBuffSize = 0;

    SAFER_CODE_PROPERTIES CodeProps = {0};
    CodeProps.cbSize = sizeof(SAFER_CODE_PROPERTIES);
    CodeProps.dwCheckFlags = SAFER_CRITERIA_IMAGEPATH | SAFER_CRITERIA_IMAGEHASH;
    CodeProps.ImagePath = FileName;

    if (pfnSaferIdentifyLevel(1, &CodeProps, &Level, NULL)) {
       if (pfnSaferGetLevelInformation(Level, 
                                     SaferObjectLevelId, 
                                     (void*)&dwSaferLevelId, 
                                     sizeof(DWORD), 
                                     &dwOutBuffSize)) {

           if (dwSaferLevelId == SAFER_LEVELID_DISALLOWED) {

               //
               // Per SAFER rules, the code was disallowed from executing
               // so log an entry into the system event log.
               //

               pfnSaferRecordEventLogEntry(Level, FileName, NULL);
               SetLastError(ERROR_ACCESS_DISABLED_BY_POLICY);
               rc = STATUS_ACCESS_DISABLED_BY_POLICY_PATH;
           } else {
               rc = STATUS_SUCCESS;
           }
       } else {
           rc = STATUS_ERROR | GetLastError(); // Get from handled failed!
       }
       pfnSaferCloseLevel(Level);
    } else {
       rc = STATUS_ERROR | GetLastError();    // Identify level failed!
    }
    return rc;
}


STDAPI 
_CorValidateImage(PVOID *ImageBase, LPCWSTR FileName) {
    //@TODO: Figure out what's up -- winnt.h (HRESULT) and ntdef.h (NTSTATUS) seem incompatible.

    PBYTE pImage = (PBYTE) *ImageBase;

    IMAGE_DOS_HEADER *pDosHeader = (IMAGE_DOS_HEADER*)pImage;
    IMAGE_NT_HEADERS32 *pHeader32 = (IMAGE_NT_HEADERS32*) (pImage + pDosHeader->e_lfanew);

    _ASSERTE(pHeader32->OptionalHeader.NumberOfRvaAndSizes > IMAGE_DIRECTORY_ENTRY_COMHEADER);
    _ASSERTE(pHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress != 0);
    if(pHeader32->OptionalHeader.NumberOfRvaAndSizes <= IMAGE_DIRECTORY_ENTRY_COMHEADER)
        return STATUS_INVALID_IMAGE_FORMAT;

    IMAGE_COR20_HEADER *pComPlusHeader = (IMAGE_COR20_HEADER*) (pImage + 
                pHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COMHEADER].VirtualAddress);

    if (pComPlusHeader->MajorRuntimeVersion < 2) {
        _ASSERTE(!"Trying to load file with CLR version < 2.");
        return STATUS_INVALID_IMAGE_FORMAT;
    }

    WhistlerMscoreeRefCountWorkAround();

    // If it's not ILONLY, work-around for early Whislter builds that didn't add-ref dependent dlls.
    if ((pComPlusHeader->Flags & COMIMAGE_FLAGS_ILONLY)  == 0) {
        // SAFER Validation
        if ((pHeader32->FileHeader.Characteristics & IMAGE_FILE_DLL) == 0) {
            DWORD hr = SaferValidate(FileName);
            if (!SUCCEEDED(hr))
                return hr;
        }
        WhistlerBeta2LoaderBugWorkAround(pImage);
    } else {
        DWORD hr = ValidateILOnlyImage(pHeader32, pImage);
        if (!SUCCEEDED(hr))
            return hr;
    }

    // We must verify that the TLS callback function array is empty.  The loader calls it BEFORE it 
    // calls DLL-main.  If it's non-null, then we would have a way to run unmanaged code before
    // verification and our security policies are applied.  If we ever do want to support
    // this field in a mixed-mode image, we could do so by saving the first directory entry 
    // somewhere else in the image, overwriting it with our own ... and then doing necessary validation inside our
    // routine before chaining to the original.

    DWORD dTlsHeader = pHeader32->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress;
    if (dTlsHeader != 0) {
        IMAGE_TLS_DIRECTORY *pTlsDirectory = (IMAGE_TLS_DIRECTORY*)(pImage + dTlsHeader);
        DWORD dTlsCallbackTable = pTlsDirectory->AddressOfCallBacks;
        if (*((DWORD*)(dTlsCallbackTable)) != 0) {
            return STATUS_INVALID_IMAGE_FORMAT;
        }
        DWORD hr = SaferValidate(FileName);
        if (!SUCCEEDED(hr))
            return hr;
    }
        
    // If we get this far, we're going to modify the image.
    DWORD oldProtect;
    if (!VirtualProtect(pImage, 4096, PAGE_READWRITE, &oldProtect)) {
        // This is bad.  Not going to be able to update header.
        _ASSERTE(!"_CorValidateImage(): VirtualProtect() change image header to R/W failed.\n");
        return STATUS_ERROR | GetLastError();
    }

    // OK.  We have a valid PE32 image now.  Just have to whack the starting address.
    if (pHeader32->FileHeader.Characteristics & IMAGE_FILE_DLL) {
        pHeader32->OptionalHeader.AddressOfEntryPoint = (DWORD) ((PBYTE)_CorDllMain - pImage);
    } else {
        pHeader32->OptionalHeader.AddressOfEntryPoint = (DWORD) ((PBYTE)_CorExeMain - pImage);
    }

//exit:
    DWORD junk;
    if (!VirtualProtect(pImage, 4096, oldProtect, &junk)) {
        _ASSERTE(!"_CorValidateImage(): VirtualProtect() reset image header failed.\n");
        return STATUS_ERROR | GetLastError();
    }

    return STATUS_SUCCESS;
}

#endif


//*****************************************************************************
// A matching entry point for _CorValidateImage.  Called when the file is 
// unloaded.  
//*****************************************************************************
STDAPI_(VOID) 
_CorImageUnloading(PVOID ImageBase) {

}


DWORD g_dwNumPerfCounterDllOpened = 0;
HMODULE g_hPerfCounterDllMod = NULL;

typedef DWORD(*PFNOPENPERFCOUNTERS)(LPWSTR);
typedef DWORD(*PFNCOLLECTPERFCOUNTERS)(LPWSTR, LPVOID *, LPDWORD, LPDWORD);
typedef DWORD(*PFNCLOSEPERFCOUNTERS)(void);

PFNOPENPERFCOUNTERS g_pfnOpenPerfCounters = NULL;
PFNCOLLECTPERFCOUNTERS g_pfnCollectPerfCounters = NULL;
PFNCLOSEPERFCOUNTERS g_pfnClosePerfCounters = NULL;

// Perf Mon guarantees that since the access to theseentry points is via the registry
// the open routine won't be called by multiple callers. So we don't have to worry about synchronization.
DWORD OpenCtrs(LPWSTR sz)
{
    // If the entry points are not defined then load the perf counter dll
    if (g_dwNumPerfCounterDllOpened == 0)
    {
        RuntimeRequest sVersion;
        sVersion.SetLatestVersion(TRUE);
        HRESULT hr = sVersion.FindVersionedRuntime(FALSE, NULL);

        if(FAILED(hr)) 
            return ERROR_FILE_NOT_FOUND;
        
        LPWSTR fullPerfCounterDllPath = new WCHAR[wcslen(g_Directory) + wcslen(L"CorperfmonExt.dll") + 1];
        if (fullPerfCounterDllPath == NULL)
            return ERROR_NOT_ENOUGH_MEMORY;
        
        wcscpy(fullPerfCounterDllPath, g_Directory);
        wcscat(fullPerfCounterDllPath, L"CorperfmonExt.dll");

        g_hPerfCounterDllMod = WszLoadLibraryEx (fullPerfCounterDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        
        delete [] fullPerfCounterDllPath;
        
        if (!g_hPerfCounterDllMod) 
            return ERROR_FILE_NOT_FOUND;
        
        g_pfnOpenPerfCounters = (PFNOPENPERFCOUNTERS)GetProcAddress(g_hPerfCounterDllMod, "OpenCtrs");
        g_pfnCollectPerfCounters = (PFNCOLLECTPERFCOUNTERS)GetProcAddress(g_hPerfCounterDllMod, "CollectCtrs");
        g_pfnClosePerfCounters = (PFNCLOSEPERFCOUNTERS)GetProcAddress(g_hPerfCounterDllMod, "CloseCtrs");

        if (!g_pfnOpenPerfCounters || !g_pfnCollectPerfCounters || !g_pfnClosePerfCounters) 
        {
            FreeLibrary(g_hPerfCounterDllMod);
            return ERROR_FILE_NOT_FOUND;
        }
        
        // Now just plug this into the real perf counter dll
        DWORD status = g_pfnOpenPerfCounters(sz);
        if (status == ERROR_SUCCESS) 
            g_dwNumPerfCounterDllOpened++;
        return status;
    }
    else
    {
        // Don't call the open ctrs routine multiple times. Just ref count it.
        g_dwNumPerfCounterDllOpened++;
        return ERROR_SUCCESS;
    }
}

DWORD CollectCtrs(LPWSTR szQuery, LPVOID * ppData, LPDWORD lpcbBytes, LPDWORD lpcObjectTypes)
{
    _ASSERTE (g_pfnCollectPerfCounters && "CollectCtrs entry point not initialized!");
    return g_pfnCollectPerfCounters(szQuery, ppData, lpcbBytes, lpcObjectTypes);
}

DWORD CloseCtrs (void)
{
    // No need for synchronization because access is via registry
    g_dwNumPerfCounterDllOpened--;
    if (g_dwNumPerfCounterDllOpened == 0)
    {
        _ASSERTE (g_pfnClosePerfCounters && "CloseCtrs entry point not initialized!");
        g_pfnClosePerfCounters();
        FreeLibrary (g_hPerfCounterDllMod);
    }
    
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\shimpolicy.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _SHIMPOLICY_H_
#define _SHIMPOLICY_H_

/*****************************************************************************
 **                                                                         **
 ** ShimPolicy.h - general header for the shim policy manager               **
 **    The standard table is found at:                                      **
 **       \\Software\\Microsoft\\.NETFramework\\Policy\\Standards           **
 **                                                                         **
 **       Contains keys based on every unique standard                      **
 **           ..\\[standard-name]                                           **
 **                                                                         **
 **       Every standard key can have multiple DWORD entries of the form:   **
 **                  "[arbitrary-string]"=[DWORD]                           **
 **                                                                         **
 **           Each standard contains a list of acceptable versions where    **
 **           every version is a DWORD. The Value-Name is the version       **
 **           name and the DWORD value is the priority of the version.      **
 **           e.g. for the ECMA spec there could be an entry.               **
 **               "v1.0.3705"   1                                           **
 **                                                                         **
 **      Installation programs for a version can enter as many              **
 **      unique values into the table as they want. The lifetime            **
 **      of every key and value is bound to the installation that added it. **
 **                           ***                                           **
 **                                                                         **
 **    The policy table is found at: (the upgrade key contains a list of    **
 **    strings indicating the upgrade. Each installation is ties the life-  **
 **    time of the key to the installation)                                 **
 **       \\Software\\Microsoft\\.NETFramework\\Policy\\Upgrades            **
 **       "[Major.Minor.Build]"="[Major.Minor.Build]-[Major.Minor.Build]"   **
 **       eg. "1.0.4030" = "1.0.3076-1.0.4030"                              **
 **                                                                         **
 **                                                                         **
 **                           ***                                           **
 **                                                                         **
 **    Version specific informations is found under the key:                **
 **       \\Software\\Microsoft\\.NETFramework\\Policy\v[Major].[Minor]     **
 **       eg.  v1.0                                                         **
 **                                                                         **
 **                           ***                                           **
 **                                                                         **
 **    Version information is strings of the form. This is here only for    **
 **    informational purposes. It is no longer used by the shim.            **
 **       [Build] = "[Build];[Build]-[Build]"                               **
 **       eg. 3705 = "2311-3705"                                            **
 **                                                                         **
 **                           ***                                           **
 **                                                                         **
 **    Overrides look like:                                                 **
 **       "version"="v1.x86chk"                                             **
 **                                                                         **
 **                           ***                                           **
 **                                                                         **
 **    Overrides can be found at:                                           **
 **       \\Software\\Microsoft\\.NETFramework\\Policy\\                    **
 **       \\Software\\Microsoft\\.NETFramework\\Policy\\[Major].[Minor]     **
 **                                                                         **
 **                           ***                                           **
 **                                                                         **
 **                                                                         **
 *****************************************************************************/

#ifndef lengthof
#define lengthof(x) (sizeof(x)/sizeof(x[0]))
#endif
                                             

// Shim policy registry key hangs off of .NETFramework registry key.
static WCHAR SHIM_POLICY_REGISTRY_KEY[] = {FRAMEWORK_REGISTRY_KEY_W L"\\Policy\\"};
#define SHIM_POLICY_REGISTRY_KEY_LENGTH (lengthof(SHIM_POLICY_REGISTRY_KEY) - 1)

static WCHAR SHIM_UPGRADE_REGISTRY_KEY[] = {FRAMEWORK_REGISTRY_KEY_W L"\\Policy\\Upgrades"};
#define SHIM_UPGRADE_REGISTRY_KEY_LENGTH (lengthof(SHIM_UPGRADE_REGISTRY_KEY) - 1)

static WCHAR SHIM_STANDARDS_REGISTRY_KEY[] = {FRAMEWORK_REGISTRY_KEY_W L"\\Policy\\Standards"};
#define SHIM_STANDARDS_REGISTRY_KEY_LENGTH (lengthof(SHIM_STANDARDS_REGISTRY_KEY) - 1)

class VersionPolicy;
class VersionNode;

class Version {

#define VERSION_SIZE 3
#define VERSION_TEXT_SIZE 6 * VERSION_SIZE

    WORD m_Number[VERSION_SIZE];
    friend class VersionNode;

public:
    
    Version()
    {
        ZeroMemory(m_Number, sizeof(WORD) * VERSION_SIZE);
    }

    HRESULT ToString(LPWSTR buffer,
                     DWORD length);
    DWORD Entries()
    {
        return VERSION_SIZE;
    }
    
    HRESULT SetIndex(DWORD i, WORD v)
    {
        if(i < VERSION_SIZE) {
            m_Number[i] = v;
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    static long Compare(Version* left, Version* right)
    {
        _ASSERTE(left != NULL);
        _ASSERTE(right != NULL);

        DWORD size = left->Entries();
        _ASSERTE(size == right->Entries());

        long result = 0;
        for(DWORD i = 0; i < size; i++) {
            result = ((long) left->m_Number[i]) - ((long) right->m_Number[i]);
            if(result != 0)
                break;
        }
        return result;
    }

    HRESULT SetVersionNumber(LPCWSTR stringValue,
                             DWORD* number); // returns the number of values in the string

};


class VersionNode 
{
    typedef enum {
        EMPTY      = 0x0,
        END_NUMBER = 0x1
    } VERSION_MODE;

    Version m_Version;
    Version m_Start;
    Version m_End;
    VersionNode *m_next;
    DWORD m_flag;
    friend class VersionPolicy;
public:

    VersionNode() :
        m_next(NULL),
        m_flag(0)
    { }

    VersionNode(Version v) :
        m_Version(v),
        m_next(NULL),
        m_flag(0)
    {
    }

    void SetVersion(Version v)
    {
        m_Version = v;
    }

    void SetStart(Version v)
    {
        m_Start = v;
    }

    void SetEnd(Version v)
    {
        m_End = v;
        m_flag |= END_NUMBER;
    }

    HRESULT ToString(LPWSTR buffer, DWORD length)
    {
        return m_Version.ToString(buffer, length);
    }

    long CompareStart(Version* v)
    {
        _ASSERTE(v);
        return Version::Compare(v, &m_Start);
    }

    long CompareEnd(Version* v)
    {
        _ASSERTE(v);
        return Version::Compare(v, &m_End);
    }

    long CompareVersion(VersionNode* node)
    {
        _ASSERTE(node);
        return Version::Compare(&(node->m_Version), &m_Version);
    }

    BOOL HasEnding()
    {
        return (m_flag & END_NUMBER) != 0 ? TRUE : FALSE;
    }
};

class VersionPolicy
{
    VersionNode* m_pList;

public:
    VersionPolicy() :
    m_pList(NULL)
    { }

    ~VersionPolicy()
    {
        VersionNode* ptr = m_pList;
        while(ptr != NULL) {
            VersionNode* remove = ptr;
            ptr = ptr->m_next;
            remove->m_next = NULL;
            delete remove;
        }
        m_pList = NULL;
    }

    HRESULT BuildPolicy(HKEY hKey);

    HRESULT InstallationExists(LPCWSTR version);

    HRESULT ApplyPolicy(LPCWSTR wszRequestedVersion,
                        LPWSTR* pwszVersion);

    HRESULT AddToVersionPolicy(LPCWSTR wszPolicyBuildNumber, 
                               LPCWSTR wszPolicyMapping, 
                               DWORD  dwPolicyMapping);

#ifdef _DEBUG
    HRESULT Dump();
#endif

    VersionNode* FindEntry(Version v);

    void AddVersion(VersionNode* pNode)
    {
        if(m_pList == NULL) 
            m_pList = pNode;
        else {
            VersionNode** ptr;
            for (ptr = &m_pList; 
                 *ptr && 
                     Version::Compare(&(pNode->m_Version), &((*ptr)->m_Version)) < 0; 
                 ptr = &((*ptr)->m_next));

            pNode->m_next = *ptr;
            *ptr = pNode;
        }
    }
    
    VersionNode* RemoveVersion(VersionNode* pNode)
    {
        VersionNode** ptr = &m_pList;
        for (; *ptr != NULL && *ptr != pNode; ptr = &((*ptr)->m_next));

        if(*ptr != NULL) {
            *ptr = (*ptr)->m_next;
            (*ptr)->m_next = NULL;
        }
        return *ptr;
    }
};

class VersionStack;
class VersionStackEntry
{
    friend VersionStack;
    LPWSTR m_keyName;
    VersionStackEntry* m_next;

    VersionStackEntry(LPWSTR pwszKey) :
        m_keyName(pwszKey),
        m_next(NULL)
    {}

    ~VersionStackEntry()
    {
        if(m_keyName != NULL) {
            delete [] m_keyName;
            m_keyName = NULL;
        }
        m_next = NULL;
    }
};   


class VersionStack
{
    VersionStackEntry* m_pList;

public:
    VersionStack() :
        m_pList(NULL)
    {}

    ~VersionStack()
    {
        VersionStackEntry* ptr = m_pList;
        while(ptr != NULL) {
            VersionStackEntry* remove = ptr;
            ptr = ptr->m_next;
            delete remove;
        }
        m_pList = NULL;
    }

    void AddVersion(LPWSTR keyName) 
    {
        VersionStackEntry* pEntry = new VersionStackEntry(keyName);
        if(m_pList == NULL) 
            m_pList = pEntry;
        else {
            VersionStackEntry** ptr;
            for(ptr = &m_pList;
                *ptr && 
                    wcscmp(pEntry->m_keyName, (*ptr)->m_keyName) < 0;
                ptr = &((*ptr)->m_next));
            pEntry->m_next = *ptr;
            *ptr = pEntry;
        }
    }

    LPWSTR Pop()
    {
        VersionStackEntry* top = m_pList;
        if(top == NULL)
            return NULL;
        else {
            m_pList = top->m_next;
            LPWSTR returnKey = top->m_keyName;
            top->m_keyName = NULL;
            delete top;
            return returnKey;
        }
    }
};
HRESULT IsRuntimeVersionInstalled(LPCWSTR wszRequestedVersion);

HRESULT FindInstallationInRegistry(HKEY hKey,
                                   LPCWSTR wszRequestedVersion);
HRESULT FindOverrideVersion(HKEY userKey,
                            LPWSTR *pwszVersion);
HRESULT FindMajorMinorNode(HKEY key,
                           LPCWSTR wszMajorMinor, 
                           DWORD majorMinorLength, 
                           LPWSTR *overrideVersion);
HRESULT FindOverrideVersionValue(HKEY hKey, 
                                 LPWSTR *pwszVersion);
HRESULT FindOverrideVersion(LPCWSTR wszRequiredVersion,
                            LPWSTR* pwszPolicyVersion);
HRESULT FindVersionUsingUpgradePolicy(LPCWSTR wszRequestedVersion, 
                                                LPWSTR* pwszPolicyVersion);
HRESULT FindVersionUsingPolicy(LPCWSTR wszRequestedVersion, 
                               LPWSTR* pwszPolicyVersion);
HRESULT FindLatestVersion(LPWSTR *pwszLatestVersion);

HRESULT FindStandardVersion(LPCWSTR wszRequiredVersion,
                            LPWSTR* pwszPolicyVersion);

HRESULT FindInstallation(LPCWSTR wszRequestedVersion, 
                         BOOL fUsePolicy);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\xmlstream.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// XMLStream.cpp
// 
//*****************************************************************************
//
// Lite weight xml stream reader
//

#include "stdafx.h"
#include <mscoree.h>
#include <xmlparser.hpp>
#include <objbase.h>
#include <mscorcfg.h>
#include <shlwapi.h>

class XMLParserShimFileStream : public _unknown<IStream, &IID_IStream>
{
public:
    XMLParserShimFileStream()  
    { 
        hFile = INVALID_HANDLE_VALUE;
        read = true;
    }

    ~XMLParserShimFileStream() 
    { 
		close();
    }

    bool close()
    {
        if ( hFile != INVALID_HANDLE_VALUE)
            ::CloseHandle(hFile);

        return TRUE; 
    }

    bool open(PCWSTR name, bool read = true)
    {
        if ( ! name ) {
            return false; 
        }
        if (read)
        {
            hFile = ::WszCreateFile( 
                name,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
        }
        else
        {
            hFile = ::WszCreateFile(
                name,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
        }
        return (hFile == INVALID_HANDLE_VALUE) ? false : true;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read( 
        /* [out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead)
    {   
        if (!read) return E_FAIL;

        DWORD len;
        BOOL rc = ReadFile(
            hFile,  // handle of file to read 
            pv, // address of buffer that receives data  
            cb, // number of bytes to read 
            &len,   // address of number of bytes read 
            NULL    // address of structure for data 
           );
        if (pcbRead)
            *pcbRead = len;
        return (rc) ? S_OK : E_FAIL;
    }
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write( 
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten)
    {
        if (read) return E_FAIL;

        BOOL rc = WriteFile(
            hFile,  // handle of file to write 
            pv, // address of buffer that contains data  
            cb, // number of bytes to write 
            pcbWritten, // address of number of bytes written 
            NULL    // address of structure for overlapped I/O  
           );

        return (rc) ? S_OK : E_FAIL;
    }

    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Seek( 
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition) {

      /*        UNUSED(dlibMove);
        UNUSED(dwOrigin);
        UNUSED(plibNewPosition);
      */
        return E_NOTIMPL; 
    }
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        /* [in] */ ULARGE_INTEGER libNewSize) { 
      //UNUSED(libNewSize);
        return E_NOTIMPL; }
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopyTo( 
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten) { 
      /*
        UNUSED(pstm);
        UNUSED(cb);
        UNUSED(pcbRead);
        UNUSED(pcbWritten);
      */
        return E_NOTIMPL; 
    }
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ DWORD grfCommitFlags) { 
      //    UNUSED(grfCommitFlags);
        return E_NOTIMPL; 
    }
    
    virtual HRESULT STDMETHODCALLTYPE Revert( void) { return E_NOTIMPL; }
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) { 
      /*    UNUSED(libOffset);
        UNUSED(cb);
        UNUSED(dwLockType);
      */
        return E_NOTIMPL; 
    }
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType) { 
      /*    UNUSED(libOffset);
        UNUSED(cb);
        UNUSED(dwLockType); 
      */
        return E_NOTIMPL; 
    }
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag) { 
      /*
        UNUSED(pstatstg);
        UNUSED(grfStatFlag);
      */
        return E_NOTIMPL; 
    }
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm) { 
      //    UNUSED(ppstm);  
        return E_NOTIMPL; 
    }
private:
    HANDLE hFile;
    bool read;
};

STDAPI CreateConfigStream(LPCWSTR pszFileName, IStream** ppStream)
{
	if(ppStream == NULL) return E_POINTER;
	if (!UrlIsW(pszFileName,URLIS_URL))
	{
		XMLParserShimFileStream *ptr = new XMLParserShimFileStream();
		if(ptr == NULL) return E_OUTOFMEMORY;
		if(ptr->open(pszFileName)) 
        {
			ptr->AddRef(); // refCount = 1;
			*ppStream = ptr;
			return S_OK;
		}
		else 
        {
			delete ptr;
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		return URLOpenBlockingStream(NULL,pszFileName,ppStream,0,NULL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\strongnamecache.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _STRONGNAMECACHE_H_
#define _STRONGNAMECACHE_H_

#define MAX_CACHED_STRONG_NAMES 10

#define STRONG_NAME_CREATION_FLAGS_MASK 0x00000003
#define STRONG_NAME_ENTRY_ALLOCATED_BY_SHIM 0x00000001
#define STRONG_NAME_TOKEN_ALLOCATED_BY_STRONGNAMEDLL 0x00000002

class StrongNameCacheEntry
{
public:
    StrongNameCacheEntry (ULONG cbStrongName, BYTE *pbStrongName, ULONG cbStrongNameToken, BYTE *pbStrongNameToken, BOOL fCreationFlags)
    {
        m_cbStrongName = cbStrongName;
        m_pbStrongName = pbStrongName;
        m_cbStrongNameToken = cbStrongNameToken;
        m_pbStrongNameToken = pbStrongNameToken;
        m_fCreationFlags = fCreationFlags;
    }
    
    ULONG m_cbStrongName;
    BYTE *m_pbStrongName;
    ULONG m_cbStrongNameToken;
    BYTE *m_pbStrongNameToken;
    BOOL  m_fCreationFlags;
};

class StrongNameTokenFromPublicKeyCache
{
public:
    // Given a public key, find the strong name token. Return 
    // FALSE if the pair is not found in the cache.
    BOOL FindEntry (BYTE    *pbPublicKeyBlob,
                    ULONG    cbPublicKeyBlob,
                    BYTE   **ppbStrongNameToken,
                    ULONG   *pcbStrongNameToken
                    );

    // Add the strong name and strongname token pair to the cache.
    // Does not check for duplicates so use the return value of FindEntry 
    // to decide wheather to add or not. 
    void AddEntry  (BYTE    *pbPublicKeyBlob,
                    ULONG    cbPublicKeyBlob,
                    BYTE   **ppbStrongNameToken,
                    ULONG   *pcbStrongNameToken,
                    BOOL     fCreationFlags
                    );
    // Returns FALSE if the buffer was not allocated by the cache. use this
    // return value to determine whether to call the FreeBuffer on the StrongNameDll.
    // Return TRUE if the buffer was allocated by the cache but doesn't delete.
    BOOL ShouldFreeBuffer (BYTE* pbMemory);

    // Get existing number of Publisher's in our cache
    DWORD GetNumPublishers () 
    {
        _ASSERTE (SpinLockHeldByCurrentThread());

        _ASSERTE (m_dwNumEntries <= MAX_CACHED_STRONG_NAMES); 
        return m_dwNumEntries; 
    };
    
    // Get the first publisher index. Always 0
    DWORD GetFirstPublisher () { return 0; };
    
    // Get a new publisher. Returns the index into the array of publishers.
    // Publishers,once added are never removed. i.e. the cache entry doesn't timeout
    // Make sure that we always handout unique indices.
    DWORD GetNewPublisher  () 
    { 
        _ASSERTE (SpinLockHeldByCurrentThread());

        if (m_dwNumEntries < MAX_CACHED_STRONG_NAMES)
        {
            // We have room to grow, return the 0-based index and increment the count.
            return m_dwNumEntries++;
        }

        // The caller should check before using the index.
        return MAX_CACHED_STRONG_NAMES;
    };

    // ctor, Initializes the Cache map with Microsoft's public key and token.
    StrongNameTokenFromPublicKeyCache ();

    // dtor. cleans up the allocated cache entries if not already done so.
    ~StrongNameTokenFromPublicKeyCache ();

    // Eagerly cleanup the entries. 
    void CleanupCachedEntries ();

    // Static to make sue that only one instance of the cache is created.
    // @TODO: make constructor private to enforce this.
    static BOOL IsInited () { return s_IsInited; };
    
    void EnterSpinLock () 
    { 
        while (1)
        {
            if (InterlockedExchange ((LPLONG)&m_spinLock, 1) == 1)
                ::Sleep (5); // @TODO: Spin here first...
            else
            {
#ifdef _DEBUG
                m_holderThreadId = ::GetCurrentThreadId();
#endif // _DEBUG
                return;
            }
        }
    }

    void LeaveSpinLock () 
    { 
#ifdef _DEBUG
        m_holderThreadId = 0;
#endif // _DEBUG
        InterlockedExchange ((LPLONG)&m_spinLock, 0); 
    }

#ifdef _DEBUG 
    BOOL SpinLockHeldByCurrentThread() 
    {
        return m_holderThreadId == ::GetCurrentThreadId();
    }
#endif // _DEBUG

private:
    static BOOL           s_IsInited;
    DWORD                 m_dwNumEntries;
    StrongNameCacheEntry *m_Entry [ MAX_CACHED_STRONG_NAMES ];
    DWORD                 m_spinLock;
#ifdef _DEBUG
    DWORD                 m_holderThreadId;
#endif // _DEBUG
};

#endif //_STRONGNAMECACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\xmlreader.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 **                                                                         **
 ** Xmlreader.h - general header for the shim parser                        **
 **                                                                         **
 *****************************************************************************/


#ifndef _XMLREADER_H_
#define _XMLREADER_H_

#include <corerror.h>

#define STARTUP_FOUND EMAKEHR(0xffff)           // This does not leak out of the shim so we can set it to anything
HRESULT 
XMLGetVersion(LPCWSTR filename, 
              LPWSTR* pVersion, 
              LPWSTR* pImageVersion, 
              LPWSTR* pBuildFlavor, 
              BOOL* bSafeMode,
              BOOL *bRequiredTagSafeMode);

HRESULT 
XMLGetVersionFromStream(IStream* pCfgStream, 
                        DWORD dwReserved, 
                        LPWSTR* pVersion, 
                        LPWSTR* pImageVersion, 
                        LPWSTR* pBuildFlavor, 
                        BOOL *bSafeMode, 
                        BOOL *bRequiredTagSafeMode);

HRESULT 
XMLGetVersionWithSupported(PCWSTR filename, 
                           LPWSTR* pVersion, 
                           LPWSTR* pImageVersion, 
                           LPWSTR* pBuildFlavor, 
                           BOOL *bSafeMode,
                           BOOL *bRequiredTagSafeMode,
                           LPWSTR** pwszSupportedVersions, 
                           DWORD* nSupportedVersions);

HRESULT 
XMLGetVersionWithSupportedFromStream(IStream* pCfgStream, 
                                     DWORD dwReserved, 
                                     LPWSTR* pVersion, 
                                     LPWSTR* pImageVersion, 
                                     LPWSTR* pBuildFlavor, 
                                     BOOL *bSafeMode,
                                     BOOL *bRequiredTagSafeMode,
                                     LPWSTR** pwszSupportedVersions, 
                                     DWORD* nSupportedVersions);
 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shimr\makefile.inc ===
!if "$(OS)" == "Windows_NT"
SYSTEMDIR=$(WINDIR)\system32
!else
SYSTEMDIR=$(WINDIR)\system
!endif

!ifdef PASS0ONLY
msg.rc : msg.mc
        $(MESSAGE_COMPILER) -U msg.mc
!else

PlaceDll:
!if "$(LINKONLY)" == "1"
!if "$(TARGETCOMPLUS)" != ""
        binplace -e -r $(SYSTEMDIR)\mui -p placefil.txt $(TARGETPATH)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscoreer.dll 
!endif
!endif

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\xmlreader.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// XMLReader.cpp
// 
//*****************************************************************************
//
// Lite weight xmlreader  
//

#include "stdafx.h"
#include <mscoree.h>
#include <xmlparser.hpp>
#include <objbase.h>
#include <mscorcfg.h>
#include "xmlreader.h"

#define ISWHITE(ch) ((ch) >= 0x09 && (ch) <= 0x0D || (ch) == 0x20)

#define VERARRAYGRAN  4

class ShimFactory : public _unknown<IXMLNodeFactory, &IID_IXMLNodeFactory>
{

public:
    ShimFactory();
    ~ShimFactory();
    HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);

    HRESULT STDMETHODCALLTYPE BeginChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);

    HRESULT STDMETHODCALLTYPE EndChildren( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ BOOL fEmptyNode,
        /* [in] */ XML_NODE_INFO* __RPC_FAR pNodeInfo);
    
    HRESULT STDMETHODCALLTYPE Error( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ HRESULT hrErrorCode,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
    {
      /* 
         UNUSED(pSource);
         UNUSED(hrErrorCode);
         UNUSED(cNumRecs);
         UNUSED(apNodeInfo);
      */
        return hrErrorCode;
    }
    
    WCHAR* ReleaseVersion()
    {
        WCHAR* version = pVersion;
        pVersion = NULL;
        return version;
    }

    DWORD ReleaseSupportedVersionArray(WCHAR*** pArray)
    {
        if(pArray)
        { 
            *pArray=ppSupportedVersions;
            ppSupportedVersions=NULL;
        }
        return nSupportedVersions;
    }

    WCHAR* ReleaseImageVersion()
    {
        WCHAR* version = pImageVersion;
        pImageVersion = NULL;
        return version;
    }

    BOOL IsSafeMode() { return bIsSafeMode; }
    BOOL IsRequiredRuntimeSafeMode() { return bIsRequiredRuntimeSafeMode; }

    HRESULT STDMETHODCALLTYPE CreateNode( 
        /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
        /* [in] */ PVOID pNodeParent,
        /* [in] */ USHORT cNumRecs,
        /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo);

private:
    HRESULT CopyVersion(LPCWSTR version, DWORD dwVersion);
    HRESULT CopyImageVersion(LPCWSTR version, DWORD dwVersion);
    HRESULT GetSafeMode(LPCWSTR version);
    HRESULT GetRequiredRuntimeSafeMode(LPCWSTR version);
    HRESULT AddSupportedVersion(LPCWSTR version);

    WCHAR* pVersion;
    WCHAR* pImageVersion;
    BOOL   bIsSafeMode;
    BOOL   bIsRequiredRuntimeSafeMode;
    BOOL   fConfiguration;
    BOOL   fStartup;
    DWORD  nSupportedVersions;
    WCHAR** ppSupportedVersions;
    DWORD  nLevel;
    DWORD  tElement;
};

ShimFactory::ShimFactory() 
{
    pVersion = NULL;
    pImageVersion = NULL;
    bIsSafeMode = FALSE;
    bIsRequiredRuntimeSafeMode = FALSE;
    fConfiguration=FALSE;
    fStartup = FALSE;
    tElement = 0;
    nSupportedVersions=0;
    ppSupportedVersions=NULL;
    nLevel=0;
}

ShimFactory::~ShimFactory() 
{
    if(pVersion != NULL) {
        delete [] pVersion;
    }
    if(pImageVersion != NULL) {
        delete [] pImageVersion;
    }
    if(ppSupportedVersions)
    {
        for (DWORD i=0;i<nSupportedVersions;i++)
            delete[] ppSupportedVersions[i];

        delete[] ppSupportedVersions;
    }
}

HRESULT ShimFactory::CopyVersion(LPCWSTR version, DWORD dwVersion)
{
    if (pVersion)
        delete[] pVersion;
    pVersion = new WCHAR[dwVersion+1];
    if(pVersion == NULL) return E_OUTOFMEMORY;
    wcsncpy(pVersion, version, dwVersion);
    pVersion[dwVersion]=L'\0';
    return S_OK;
}

HRESULT ShimFactory::CopyImageVersion(LPCWSTR imageVersion, DWORD dwImageVersion)
{
    if (pImageVersion)
        delete[] pImageVersion;
    pImageVersion = new WCHAR[dwImageVersion+1];
    if(pImageVersion == NULL) return E_OUTOFMEMORY;
    wcsncpy(pImageVersion, imageVersion, dwImageVersion);
    pImageVersion[dwImageVersion]=L'\0';
    return S_OK;
}


HRESULT ShimFactory::GetSafeMode(LPCWSTR val)
{
    if (wcscmp(val, L"true") == 0)
        bIsSafeMode = TRUE;
    else 
        bIsSafeMode = FALSE;
    return S_OK;
}

HRESULT ShimFactory::GetRequiredRuntimeSafeMode(LPCWSTR val)
{
    if (wcscmp(val, L"true") == 0)
        bIsRequiredRuntimeSafeMode = TRUE;
    else 
        bIsRequiredRuntimeSafeMode = FALSE;
    return S_OK;
}

HRESULT ShimFactory::AddSupportedVersion(LPCWSTR version)
{
    if ((nSupportedVersions % VERARRAYGRAN)==0)
    {
        //reallocate
        WCHAR** pNewPtr=new WCHAR*[nSupportedVersions+VERARRAYGRAN];
        if(pNewPtr == NULL)
            return E_OUTOFMEMORY;
        if (ppSupportedVersions)
        {
            memcpy(pNewPtr,ppSupportedVersions,nSupportedVersions*sizeof(WCHAR*));
            memset(pNewPtr+nSupportedVersions,0,VERARRAYGRAN*sizeof(WCHAR*));
            delete[] ppSupportedVersions;
        }
        ppSupportedVersions=pNewPtr;
    }
    ppSupportedVersions[nSupportedVersions]=new WCHAR[wcslen(version)+1];
    if (ppSupportedVersions[nSupportedVersions]==NULL)
        return E_OUTOFMEMORY;
    wcscpy(ppSupportedVersions[nSupportedVersions],version);
    nSupportedVersions++;
    return S_OK;
};

HRESULT STDMETHODCALLTYPE ShimFactory::NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt)
{

    UNUSED(pSource);
    UNUSED(iEvt);
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ShimFactory::BeginChildren( 
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
    UNUSED(pSource);
    UNUSED(pNodeInfo); 

    if (nLevel==1&&wcscmp(pNodeInfo->pwcText, L"configuration") == 0) 
        fConfiguration = TRUE;
    if (nLevel==2&&fConfiguration&&wcscmp(pNodeInfo->pwcText, L"startup") == 0) 
        fStartup = TRUE;

    return S_OK;

}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ShimFactory::EndChildren( 
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmptyNode,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo)
{
    UNUSED(pSource);
    UNUSED(fEmptyNode);
    UNUSED(pNodeInfo);
    if (pNodeInfo->dwType == XML_ELEMENT)
        nLevel--;
    if ( fEmptyNode ) { 

    }
    else {
        if (fStartup && wcscmp(pNodeInfo->pwcText, L"startup") == 0) {
            fStartup = FALSE;
            tElement=0;
            fConfiguration=FALSE;
            return STARTUP_FOUND;
        }
    }
    return S_OK;
}
//---------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE ShimFactory::CreateNode( 
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO* __RPC_FAR * __RPC_FAR apNodeInfo)
{
    if (apNodeInfo[0]->dwType == XML_ELEMENT)  
        nLevel++;

    HRESULT hr = S_OK;
    WCHAR  wstr[128]; 
    DWORD  dwSize = 128;
    WCHAR* pString = wstr;
    DWORD  i; 
    DWORD  tAttribute=0;

    // Unique tags
    static enum {
        tVersion = 1,
        tImageVersion,
        tRequiredRuntimeSafeMode,
        tSafeMode,
        tRequiredVersion,
        tSupportedVersion,
        tStartup
    };

    UNUSED(pSource);
    UNUSED(pNode);
    UNUSED(apNodeInfo);
    UNUSED(cNumRecs);

    for( i = 0; i < cNumRecs; i++) { 
        if(apNodeInfo[i]->dwType == XML_ELEMENT ||
           apNodeInfo[i]->dwType == XML_ATTRIBUTE ||
           apNodeInfo[i]->dwType == XML_PCDATA) {

            DWORD lgth = apNodeInfo[i]->ulLen;
            WCHAR *ptr = (WCHAR*) apNodeInfo[i]->pwcText;
            // Trim the value
            for(;*ptr && ISWHITE(*ptr) && lgth>0; ptr++, lgth--);
            while( lgth > 0 && ISWHITE(ptr[lgth-1]))
                   lgth--;

            if ( (lgth+1) > dwSize ) {
                dwSize = lgth+1;
                pString = (WCHAR*) alloca(sizeof(WCHAR) * dwSize);
            }
            
            wcsncpy(pString, ptr, lgth);
            pString[lgth] = L'\0';
            
            switch(apNodeInfo[i]->dwType) {
            case XML_ELEMENT : 
                tElement=0;
                if(fStartup == TRUE) {
                    
                    if(wcscmp(pString, L"requiredRuntime") == 0)
                    {
                        tElement = tRequiredVersion;
                        break;
                    }
                    
                    if(wcscmp(pString, L"supportedRuntime") == 0) {
                        tElement=tSupportedVersion;
                        break;
                    }
                }
                if(wcscmp(pString, L"startup") == 0) {
                    fStartup = TRUE;
                    tElement=tStartup;
                    break ; 
                }
                break;

            case XML_ATTRIBUTE : 
                if(fStartup == TRUE) 
                {
                    tAttribute=0;
                    if(((tElement==tRequiredVersion) || (tElement==tSupportedVersion)) && wcscmp(pString, L"version") == 0)
                    {
                        tAttribute = tVersion;
                        break;
                    }

                    if((tElement==tRequiredVersion) && wcscmp(pString, L"imageVersion") == 0)
                    {
                        tAttribute = tImageVersion;
                        break;
                    }

                    if(wcscmp(pString, L"safemode") == 0)
                    {
                        if(tElement==tRequiredVersion) 
                        {
                            tAttribute=tRequiredRuntimeSafeMode;
                            break;
                        }

                        if(tElement==tStartup)
                        {
                            tAttribute=tSafeMode;
                            break;
                        }
                
                    }
                }
                break;
            case XML_PCDATA:
                if(fStartup == TRUE) 
                {
                    if ((tElement==tSupportedVersion) && (tAttribute == tVersion)) {
                        hr=AddSupportedVersion(pString);
                        break;
                    }

                    if((tElement == tRequiredVersion) && ((cNumRecs == 1) || tAttribute == tVersion)) {
                        hr = CopyVersion(pString, lgth);
                        break;
                    }

                    switch(tAttribute) {
                    case tRequiredRuntimeSafeMode:
                        hr = GetRequiredRuntimeSafeMode(pString);
                        break;
                    case tSafeMode:
                        hr = GetSafeMode(pString);
                        break;
                    case tImageVersion:
                        hr = CopyImageVersion(pString, lgth);
                        break;
                    default:
                        break;
                    }
                }
                break ;     
            default: 
                break;
            } // end of switch
        }
    }

    return hr;  
}

LPWSTR GetShimInfoFromConfigFile(LPCWSTR name, LPCWSTR wszFileName){
    _ASSERTE(name);
    return NULL; 
}

STDAPI GetXMLElement(LPCWSTR wszFileName, LPCWSTR pwszTag) {
    return E_FAIL;
}

STDAPI GetXMLElementAttribute(LPCWSTR pwszAttributeName, LPWSTR pbuffer, DWORD cchBuffer, DWORD* dwLen){
    return E_FAIL;
}

HRESULT GetXMLObject(IXMLParser **ppv)
{

    if(ppv == NULL) return E_POINTER;
    IXMLParser *pParser = new XMLParser();
    if(pParser == NULL) return E_OUTOFMEMORY;

    pParser->AddRef();
    *ppv = pParser;
    return S_OK;
}

HRESULT XMLGetVersionFromStream(IStream* pStream, 
                                DWORD reserved, 
                                LPWSTR* pVersion, 
                                LPWSTR* pImageVersion, 
                                LPWSTR* pBuildFlavor, 
                                BOOL* bSafeMode,
                                BOOL* bRequiredRuntimeSafeMode)
{
    return XMLGetVersionWithSupportedFromStream(pStream,
                                                reserved,
                                                pVersion,
                                                pImageVersion,
                                                pBuildFlavor,
                                                bSafeMode,
                                                bRequiredRuntimeSafeMode,
                                                NULL,NULL);
}

HRESULT XMLGetVersionWithSupportedFromStream(IStream* pStream, 
                                             DWORD reserved, 
                                             LPWSTR* pVersion, 
                                             LPWSTR* pImageVersion, 
                                             LPWSTR* pBuildFlavor, 
                                             BOOL* bSafeMode,
                                             BOOL* bRequiredRuntimeSafeMode,
                                             LPWSTR** ppwszSupportedVersions, DWORD* pnSupportedVersions)
{  
    if(pVersion == NULL) return E_POINTER;

    HRESULT        hr = S_OK;  
    IXMLParser     *pIXMLParser = NULL;
    ShimFactory    *factory = NULL; 

    hr = GetXMLObject(&pIXMLParser);
    if(FAILED(hr)) goto Exit;

    factory = new ShimFactory();
    if ( ! factory) { 

        hr = E_OUTOFMEMORY; 
        goto Exit; 
    }
    factory->AddRef(); // RefCount = 1 

    hr = pIXMLParser->SetInput(pStream); // filestream's +1
    if ( ! SUCCEEDED(hr)) 
        goto Exit;

    hr = pIXMLParser->SetFactory(factory); // factory's RefCount=2
    if ( ! SUCCEEDED(hr)) 
        goto Exit;

    hr = pIXMLParser->Run(-1);
    if(SUCCEEDED(hr) || hr == STARTUP_FOUND) {
        if (pVersion)
            *pVersion  = factory->ReleaseVersion();
        if (bSafeMode)
            *bSafeMode = factory->IsSafeMode();
        if (bRequiredRuntimeSafeMode)
            *bRequiredRuntimeSafeMode = factory->IsRequiredRuntimeSafeMode();
        if (pBuildFlavor)
            *pBuildFlavor = NULL;
        if(pImageVersion)
            *pImageVersion = factory->ReleaseImageVersion();
        if(pnSupportedVersions)
        {
            *pnSupportedVersions=factory->ReleaseSupportedVersionArray(ppwszSupportedVersions);
        }
        hr = S_OK; 
    }
Exit:  

    if (hr == XML_E_MISSINGROOT || hr == E_PENDING)
        hr=S_OK;

    if (pIXMLParser) { 
        pIXMLParser->Release();
        pIXMLParser= NULL ; 
    }
    if ( factory) {
        factory->Release();
        factory=NULL;
    }
    return hr;  
}


HRESULT XMLGetVersion(PCWSTR filename, 
                      LPWSTR* pVersion, 
                      LPWSTR* pImageVersion, 
                      LPWSTR* pBuildFlavor, 
                      BOOL* bSafeMode,
                      BOOL* bRequiredRuntimeSafeMode)
    
{
    return XMLGetVersionWithSupported(filename,
                                      pVersion,
                                      pImageVersion,
                                      pBuildFlavor,
                                      bSafeMode,
                                      bRequiredRuntimeSafeMode,
                                      NULL,NULL);
}

HRESULT XMLGetVersionWithSupported(PCWSTR filename, 
                                   LPWSTR* pVersion, 
                                   LPWSTR* pImageVersion, 
                                   LPWSTR* pBuildFlavor, 
                                   BOOL* bSafeMode,
                                   BOOL* bRequiredRuntimeSafeMode,
                                   LPWSTR** ppwszSupportedVersions, DWORD* pnSupportedVersions)
{
    if(pVersion == NULL) return E_POINTER;

    HRESULT        hr = S_OK;  
    IStream        *pFile = NULL;

    hr = CreateConfigStream(filename, &pFile);
    if(FAILED(hr)) goto Exit;

    hr = XMLGetVersionWithSupportedFromStream(pFile, 
                                              0, pVersion, 
                                              pImageVersion, 
                                              pBuildFlavor, 
                                              bSafeMode,
                                              bRequiredRuntimeSafeMode,
                                              ppwszSupportedVersions, pnSupportedVersions);
Exit:  
    if ( pFile) {
        pFile->Release();
        pFile=NULL;
    }

    return hr;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\winsafer.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    winsafer.h

Abstract:

    This file implements the publicly exported functions, data types,
    data structures, and definitions usable by programs that directly
    interact with the Windows SAFER APIs.

--*/

#ifndef _WINSAFER_H
#define _WINSAFER_H

#include <guiddef.h>        
#include <wincrypt.h>      

#ifdef __cplusplus
extern "C" {
#endif

//
// Opaque datatype for representing handles to Safer objects.
//

DECLARE_HANDLE(SAFER_LEVEL_HANDLE);


//
// Constants to represent scope with SaferCreateLevel and others.
//

#define SAFER_SCOPEID_MACHINE  1
#define SAFER_SCOPEID_USER     2


//
// Pre-defined levels that can be used with SaferCreateLevel
//

#define SAFER_LEVELID_FULLYTRUSTED 0x40000
#define SAFER_LEVELID_NORMALUSER   0x20000
#define SAFER_LEVELID_CONSTRAINED  0x10000
#define SAFER_LEVELID_UNTRUSTED    0x01000 
#define SAFER_LEVELID_DISALLOWED   0x00000

//
// Flags to use when creating/opening a Level with SaferCreateLevel
//

#define SAFER_LEVEL_OPEN   1


//
// Maximum string size.
//

#define SAFER_MAX_FRIENDLYNAME_SIZE 256
#define SAFER_MAX_DESCRIPTION_SIZE  256
#define SAFER_MAX_HASH_SIZE         64

//
// Flags to use with SaferComputeTokenFromLevel.
//

#define SAFER_TOKEN_NULL_IF_EQUAL   0x00000001
#define SAFER_TOKEN_COMPARE_ONLY    0x00000002
#define SAFER_TOKEN_MAKE_INERT      0x00000004
#define SAFER_TOKEN_WANT_FLAGS      0x00000008

//
// Flags for specifying what criteria within SAFER_CODE_PROPERTIES to evaluate
// when finding code identity with SaferIdentifyLevel.
//

#define SAFER_CRITERIA_IMAGEPATH    0x00001
#define SAFER_CRITERIA_IMAGEHASH    0x00004
#define SAFER_CRITERIA_AUTHENTICODE 0x00008
#define SAFER_CRITERIA_URLZONE      0x00010
#define SAFER_CRITERIA_IMAGEPATH_NT 0x01000

//
// Code image information structure passed to SaferIdentifyLevel.
//

#include <pshpack8.h>

typedef struct _SAFER_CODE_PROPERTIES
{

    //
    // Must be initialized to be the size of this structure,
    // for the purposes of future/backwards compatibility.
    //
    
    DWORD cbSize;

    //
    // Must be initialized to the types of criteria that should
    // be considered when evaluating this structure.  This can be
    // a combination of the SAFER_CRITERIA_xxxx flags.  If not enough
    // of the structure elements needed to evaluate the criteria
    // types indicated were supplied, then some of those criteria
    // flags may be silently ignored.  Specifying 0 for this value
    // will cause the entire structure's contents to be ignored.
    //

    DWORD dwCheckFlags;

    //
    // Optionally specifies the fully-qualified path and filename
    // to be used for discrimination checks based on the path.
    // The ImagePath will additionally be used to open and read the
    // file to identify any other discrimination criteria that was
    // unsupplied in this structure.
    //
    
    LPCWSTR ImagePath;

    //
    // Optionally specifies a file handle that has been opened to
    // code image with at least GENERIC_READ access.  The handle will
    // be used instead of explicitly opening the file again to compute
    // other discrimination criteria that was unsupplied in this structure.
    //
    
    HANDLE hImageFileHandle;

    //
    // Optionally specifies the pre-determined Internet Explorer
    // security zone.  These enums are defined within urlmon.h
    // For example: URLZONE_LOCAL_MACHINE, URLZONE_INTRANET,
    //   URLZONE_TRUSTED, URLZONE_INTERNET, or URLZONE_UNTRUSTED.
    //
    
    DWORD UrlZoneId;

    //
    // Optionally specifies the pre-computed hash of the image.
    // The supplied hash is interpreted as being valid if ImageSize
    // is non-zero and dwImageHashSize is non-zero and HashAlgorithm
    // represents a valid hashing algorithm from wincrypt.h
    //
    // If the supplied hash fails to meet the conditions above, then
    // the hash will be automatically computed against:
    //      1) by using ImageSize and pByteBlock if both are non-zero.
    //      2) by using hImageFileHandle if it is non-null.
    //      3) by attempting to open ImagePath if it is non-null.
    //
    
    BYTE ImageHash[SAFER_MAX_HASH_SIZE];
    DWORD dwImageHashSize;
    LARGE_INTEGER ImageSize;
    ALG_ID HashAlgorithm;

    //
    // Optionally specifies a memory block of memory representing
    // the image for which the trust is being requested for.  When
    // this member is specified, ImageSize must also be supplied.
    //
    
    LPBYTE pByteBlock;

    //
    // Optionally gives the arguments used for Authenticode signer
    // certificate verification.  These arguments are supplied to the
    // WinVerifyTrust() API and control the user-interface prompting
    // to accept untrusted certificates.
    //
    
    HWND hWndParent;
    DWORD dwWVTUIChoice;

} SAFER_CODE_PROPERTIES, *PSAFER_CODE_PROPERTIES;

#include <poppack.h>


//
// Masks for the per-identity WinSafer flags
//

#define SAFER_POLICY_JOBID_MASK       0xFF000000
#define SAFER_POLICY_JOBID_CONSTRAINED           0x04000000
#define SAFER_POLICY_JOBID_UNTRUSTED             0x03000000
#define SAFER_POLICY_ONLY_EXES                   0x00010000  
#define SAFER_POLICY_SANDBOX_INERT               0x00020000
#define SAFER_POLICY_UIFLAGS_MASK                0x000000FF 
#define SAFER_POLICY_UIFLAGS_INFORMATION_PROMPT  0x00000001
#define SAFER_POLICY_UIFLAGS_OPTION_PROMPT       0x00000002


//
// Information classes on the overall policy that can be queried
// with SaferSet/GetPolicyInformation and set at different
// policy scopes based on access of the caller.
//

typedef enum _SAFER_POLICY_INFO_CLASS
{

    //
    // Accesses the list of all Levels defined in a policy.
    // The corresponding data element is a buffer that is filled
    // with multiple DWORDs, each representing the LevelIds that
    // are defined within this scope.
    //
    
    SaferPolicyLevelList = 1,

    //
    // for transparent enforcement of policy in the execution
    // framework -- will be used by native code execution but can
    // be used by any policy enforcement environment.
    // Corresponding data element is a DWORD holding a Boolean value.
    //
    
    SaferPolicyEnableTransparentEnforcement,

    //
    // Returns the name of the Level that has been designed
    // as the default level within the specified scope.
    // The corresponding data element is a single DWORD buffer
    // representing the LevelId of the default Level.  If no
    // level has been configured to be the default, then the
    // GetInfo API will return FALSE and GetLastError will
    // return ERROR_NOT_FOUND.
    //
    
    SaferPolicyDefaultLevel,

    //
    // Returns whether Code Identities or Default Level within the
    // user scope can be considered during identification.
    //
    
    SaferPolicyEvaluateUserScope,
    
    //
    // Control Flags for for safer policy scope.
    //
    
    SaferPolicyScopeFlags

} SAFER_POLICY_INFO_CLASS;


//
// Enumerations used for retrieving specific information about a
// single authorization Level via SaferGet/SetInformationFromLevel.
//

typedef enum _SAFER_OBJECT_INFO_CLASS 
{

    SaferObjectLevelId = 1,               // get: DWORD
    SaferObjectScopeId,                   // get: DWORD
    SaferObjectFriendlyName,              // get/set: LPCWSTR 
    SaferObjectDescription,               // get/set: LPCWSTR
    SaferObjectBuiltin,                   // get: DWORD boolean

    SaferObjectDisallowed,                // get: DWORD boolean
    SaferObjectDisableMaxPrivilege,       // get: DWORD boolean
    SaferObjectInvertDeletedPrivileges,   // get: DWORD boolean
    SaferObjectDeletedPrivileges,         // get: TOKEN_PRIVILEGES
    SaferObjectDefaultOwner,              // get: TOKEN_OWNER
    SaferObjectSidsToDisable,             // get: TOKEN_GROUPS
    SaferObjectRestrictedSidsInverted,    // get: TOKEN_GROUPS
    SaferObjectRestrictedSidsAdded,       // get: TOKEN_GROUPS

    //
    // To enumerate all identities, call GetInfo with
    //      SaferObjectAllIdentificationGuids.
    //
    
    SaferObjectAllIdentificationGuids,    // get: SAFER_IDENTIFICATION_GUIDS

    //
    // To create a new identity, call SetInfo with
    //      SaferObjectSingleIdentification with a new
    //      unique GUID that you have generated.
    // To get details on a single identity, call GetInfo with
    //      SaferObjectSingleIdentification with desired GUID.
    // To modify details of a single identity, call SetInfo with
    //      SaferObjectSingleIdentification with desired info and GUID.
    // To delete an identity, call SetInfo with
    //      SaferObjectSingleIdentification with the
    //      header.dwIdentificationType set to 0.
    //
    
    SaferObjectSingleIdentification,      // get/set: SAFER_IDENTIFICATION_*

    SaferObjectExtendedError              // get: DWORD dwError

} SAFER_OBJECT_INFO_CLASS;


//
// Structures and enums used by the SaferGet/SetLevelInformation APIs.
//

#include <pshpack8.h>

typedef enum _SAFER_IDENTIFICATION_TYPES 
{

    SaferIdentityDefault,
    SaferIdentityTypeImageName = 1,
    SaferIdentityTypeImageHash,
    SaferIdentityTypeUrlZone,
    SaferIdentityTypeCertificate

} SAFER_IDENTIFICATION_TYPES;

typedef struct _SAFER_IDENTIFICATION_HEADER 
{

    //
    // indicates the type of the structure, one of SaferIdentityType*
    //
    
    SAFER_IDENTIFICATION_TYPES dwIdentificationType;

    //
    // size of the whole structure, not just the common header.
    //

    DWORD cbStructSize;

    //
    // the unique GUID of the Identity in question.
    //

    GUID IdentificationGuid;

    //
    // last change of this identification.
    //

    FILETIME lastModified;

} SAFER_IDENTIFICATION_HEADER, *PSAFER_IDENTIFICATION_HEADER;

typedef struct _SAFER_PATHNAME_IDENTIFICATION
{
    //
    // header.dwIdentificationType must be SaferIdentityTypeImageName
    // header.cbStructSize must be sizeof(SAFER_PATHNAME_IDENTIFICATION)
    //
    
    SAFER_IDENTIFICATION_HEADER header;

    //
    // user-entered description
    //
    
    WCHAR Description[SAFER_MAX_DESCRIPTION_SIZE];

    //
    // filepath or name, possibly with vars
    //
    
    PWCHAR ImageName;

    //
    // any combo of SAFER_POL_SAFERFLAGS_*
    //
    
    DWORD dwSaferFlags;

} SAFER_PATHNAME_IDENTIFICATION, *PSAFER_PATHNAME_IDENTIFICATION;

typedef struct _SAFER_HASH_IDENTIFICATION
{

    //
    // header.dwIdentificationType must be SaferIdentityTypeImageHash
    // header.cbStructSize must be sizeof(SAFER_HASH_IDENTIFICATION)
    //
    
    SAFER_IDENTIFICATION_HEADER header;

    //
    // user-entered friendly name, initially from file's resources.
    //
    WCHAR Description[SAFER_MAX_DESCRIPTION_SIZE];

    //
    // user-entered description.
    //

    WCHAR FriendlyName[SAFER_MAX_FRIENDLYNAME_SIZE];

    //
    // amount of ImageHash actually used, in bytes (MD5 is 16 bytes).
    //

    DWORD HashSize;

    //
    // computed hash data itself.
    //

    BYTE ImageHash[SAFER_MAX_HASH_SIZE];

    //
    // algorithm in which the hash was computed (CALG_MD5, etc).
    //

    ALG_ID HashAlgorithm;

    //
    // size of the original file in bytes.
    //

    LARGE_INTEGER ImageSize;

    //
    // any combo of SAFER_POL_SAFERFLAGS_*
    //

    DWORD dwSaferFlags;

} SAFER_HASH_IDENTIFICATION, *PSAFER_HASH_IDENTIFICATION;

typedef struct _SAFER_URLZONE_IDENTIFICATION
{

    //
    // header.dwIdentificationType must be SaferIdentityTypeUrlZone
    // header.cbStructSize must be sizeof(SAFER_URLZONE_IDENTIFICATION)
    //
    
    SAFER_IDENTIFICATION_HEADER header;

    //
    // any single URLZONE_* from urlmon.h
    //

    DWORD UrlZoneId;

    //
    // any combo of SAFER_POLICY_*
    //

    DWORD dwSaferFlags;

} SAFER_URLZONE_IDENTIFICATION, *PSAFER_URLZONE_IDENTIFICATION;


#include <poppack.h>

//
// Functions related to querying and setting the global policy
// controls to disable transparent enforcement, and perform level
// enumeration operations.
//

WINADVAPI
BOOL WINAPI
SaferGetPolicyInformation(
    IN DWORD                   dwScopeId,
    IN SAFER_POLICY_INFO_CLASS SaferPolicyInfoClass,
    IN DWORD                   InfoBufferSize,
    IN OUT PVOID               InfoBuffer,
    IN OUT PDWORD              InfoBufferRetSize,
    IN LPVOID                  lpReserved
    );

WINADVAPI
BOOL WINAPI
SaferSetPolicyInformation(
    IN DWORD                   dwScopeId,
    IN SAFER_POLICY_INFO_CLASS SaferPolicyInfoClass,
    IN DWORD                   InfoBufferSize,
    IN PVOID                   InfoBuffer,
    IN LPVOID                  lpReserved
    );

//
// Functions to open or close a handle to a Safer Level.
//

WINADVAPI
BOOL WINAPI
SaferCreateLevel(
    IN  DWORD                dwScopeId,
    IN  DWORD                dwLevelId,
    IN  DWORD                OpenFlags,
    OUT SAFER_LEVEL_HANDLE * pLevelHandle,
    IN  LPVOID               lpReserved
    );

WINADVAPI
BOOL WINAPI
SaferCloseLevel(
    IN SAFER_LEVEL_HANDLE hLevelHandle
    );

WINADVAPI
BOOL WINAPI
SaferIdentifyLevel(
    IN  DWORD                    dwNumProperties,
    IN  PSAFER_CODE_PROPERTIES   pCodeProperties,
    OUT SAFER_LEVEL_HANDLE     * pLevelHandle,
    IN  LPVOID                   lpReserved
    );

WINADVAPI
BOOL WINAPI
SaferComputeTokenFromLevel(
    IN  SAFER_LEVEL_HANDLE LevelHandle,
    IN  HANDLE             InAccessToken   OPTIONAL,
    OUT PHANDLE            OutAccessToken,
    IN  DWORD              dwFlags,
    IN  LPVOID             lpReserved
    );

WINADVAPI
BOOL WINAPI
SaferGetLevelInformation(
        IN  SAFER_LEVEL_HANDLE      LevelHandle,
        IN  SAFER_OBJECT_INFO_CLASS dwInfoType,
        OUT LPVOID                  lpQueryBuffer     OPTIONAL,
        IN  DWORD                   dwInBufferSize,
        OUT LPDWORD                 lpdwOutBufferSize
        );

WINADVAPI
BOOL WINAPI
SaferSetLevelInformation(
    IN SAFER_LEVEL_HANDLE      LevelHandle,
    IN SAFER_OBJECT_INFO_CLASS dwInfoType,
    IN LPVOID                  lpQueryBuffer,
    IN DWORD                   dwInBufferSize
    );

//
// This function performs logging of messages to the Application 
// event log.  This is called by the hooks within CreateProcess, 
// ShellExecute and cmd when a lower trust evaluation result occurs.
//

WINADVAPI
BOOL WINAPI
SaferRecordEventLogEntry(
    IN SAFER_LEVEL_HANDLE hLevel,
    IN LPCWSTR            szTargetPath,
    IN LPVOID             lpReserved
    );



#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shim\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS		VS_FF_DEBUG
#else
#define VER_FILEFLAGS		VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE		VFT_DLL
#define VER_INTERNALNAME_STR	"MSCOREE.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Execution Engine\0"
#define VER_ORIGFILENAME_STR    "mscoree.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shimr\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define SHIM_INSTALLROOT                1
#define SHIM_INITERROR                  2
#define SHIM_PATHNOTFOUND				3
#define SHIM_LATESTVERSION				4
#define SHIM_NOVERSION                  5
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\shimr\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "MSCOREER.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Execution Engine\0"
#define VER_ORIGFILENAME_STR    "mscoreer.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\cx86def.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/*                                 cx86def.h                              */
/***************************************************************************/
/* this make the x86def.h file availble for direct use in C routines */

/* AUTHOR: Vance Morrison
   DATE:  3/17/97		
   MODIFIED: George Bosworth
   DATE:  6/15/98  */
/***************************************************************************/

#ifndef cx86def_h
#define cx86def_h 1

#ifdef x86def_h
#error "Can not include both x86def.h and cx86def.h
#endif

#undef Fjit_pass
#ifdef FjitCompile
#define Fjit_pass compile
#endif
#ifdef FjitMap
#define Fjit_pass map
#endif

#ifndef Fjit_pass
#error "Either FjitCompile or FjitMap must be defined
#endif

#define expNum(val)			(val)
#define expBits(exp, width, pos) 	(/*_ASSERTE((exp) < (1 << width)), */ (exp) << pos)
#define expMap(exp, map)  		(/*_ASSERTE((exp) < 32), */((char*) map)[exp])
#define expOr2(exp1, exp2)  		((exp1) | (exp2))
#define expOr3(exp1, exp2, exp3) 	((exp1) | (exp2) | (exp3))
#define expOr4(exp1, exp2, exp3, exp4)	((exp1) | (exp2) | (exp3) | (exp4))

	// Convention outPtr is the output pointer

#ifdef FjitCompile // output the instructions
#define cmdNull() 	  			0
#define cmdByte(exp)			   	(*((unsigned char*&)(outPtr))++ = (unsigned char)(exp))
#define cmdWord(exp)  				(*((unsigned short*&) (outPtr))++ = (exp))
#define cmdDWord(exp)				(*((unsigned int *&)(outPtr))++ = (exp))
#endif //FjitCompile

#ifdef FjitMap	// size the instructions, do not ouput them
#define cmdNull() 	  			
#define cmdByte(exp)			   	(outPtr += 1)
#define cmdWord(exp)  				(outPtr += 2)
#define cmdDWord(exp)				(outPtr += 4)
#endif FjitMap

#define cmdBlock2(cmd0, cmd1) 			(cmd0, cmd1)
#define cmdBlock3(cmd0, cmd1, cmd2) 		(cmd0, cmd1, cmd2)
#define cmdBlock4(cmd0, cmd1, cmd2, cmd3) 	(cmd0, cmd1, cmd2, cmd3)
#define cmdReloc(type, exp)			_ASSERTE(0)

/***
#define x86_sib cx86_sib
#define x86_mod cx86_mod
#define x86_16bit cx86_16bit
#define x86_mod_disp32 cx86_mod_disp32
#define x86_mod_ind cx86_mod_ind
#define x86_mod_ind_disp8 cx86_mod_ind_disp8
#define x86_mod_ind_disp32 cx86_mod_ind_disp32
#define x86_mod_reg cx86_mod_reg
#define x86_mod_base_scale cx86_mod_base_scale
#define x86_mod_base_scale_disp8 cx86_mod_base_scale_disp8
#define x86_mod_base_scale_disp32 cx86_mod_base_scale_disp32
#define x86_mov_reg cx86_mov_reg
#define x86_mov_reg_imm cx86_mov_reg_imm
#define x86_mov_mem_imm cx86_mov_mem_imm
#define x86_movsx cx86_movsx
#define x86_movzx cx86_movzx
#define x86_lea cx86_lea
#define x86_uarith cx86_uarith
#define x86_inc_dec cx86_inc_dec
#define x86_barith cx86_barith
#define x86_barith_imm cx86_barith_imm
#define x86_shift_imm cx86_shift_imm
#define x86_shift_cl cx86_shift_cl
#define x86_push cx86_push
#define x86_pop cx86_pop
#define x86_jmp_large cx86_jmp_large
#define x86_jmp_small cx86_jmp_small
#define x86_jmp_reg cx86_jmp_reg
#define x86_jmp_cond_small cx86_jmp_cond_small
#define x86_jmp_cond_large cx86_jmp_cond_large
#define x86_call cx86_call
#define x86_call_reg cx86_call_reg
#define x86_ret cx86_ret
***/

#include "x86def.h"

/***
#undef x86_sib
#undef x86_mod
#undef x86_16bit
#undef x86_mod_disp32
#undef x86_mod_ind
#undef x86_mod_ind_disp8
#undef x86_mod_ind_disp32
#undef x86_mod_reg
#undef x86_mod_base_scale
#undef x86_mod_base_scale_disp8
#undef x86_mod_base_scale_disp32
#undef x86_mov_reg
#undef x86_mov_reg_imm
#undef x86_mov_mem_imm
#undef x86_movsx
#undef x86_movzx
#undef x86_lea
#undef x86_uarith
#undef x86_inc_dec
#undef x86_barith
#undef x86_barith_imm
#undef x86_shift_imm
#undef x86_shift_cl
#undef x86_push
#undef x86_pop
#undef x86_jmp_large
#undef x86_jmp_small
#undef x86_jmp_reg
#undef x86_jmp_cond_small
#undef x86_jmp_cond_large
#undef x86_call
#undef x86_call_reg
#undef x86_ret


#undef expVar
#undef expNum
#undef expBits
#undef expMap
#undef expOr2
#undef expOr3
#undef expOr4
#undef cmdNull
#undef cmdByte
#undef cmdWord
#undef cmdDWord
#undef cmdBlock2
#undef cmdBlock3
#undef cmdBlock4
#undef cmdReloc
***/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\wcelink\makefile.inc ===
COM99_SRC=..\..

HDR_TGT=$(COM99_SRC)\OptJit\MetaDataHeaders

WCELINK_HEADERS=$(COM99_SRC)\inc\MetaData.h \
                $(COM99_SRC)\inc\CompLib.h \
                $(COM99_SRC)\inc\CrtWrap.h \
                $(COM99_SRC)\inc\DebugMacros.h \
                $(COM99_SRC)\inc\DebugStructs.h \
                $(COM99_SRC)\inc\SymbolRegStructs.h \
                $(COM99_SRC)\inc\SymbolTableStructs.h \
                $(COM99_SRC)\inc\UtilCode.h \
                $(COM99_SRC)\inc\WinWrap.h \
                $(COM99_SRC)\inc\icmprecs.h \
                $(COM99_SRC)\inc\rotate.h \
                $(COM99_SRC)\complib\stgdb\LiteWeightStgdb.h \
                $(COM99_SRC)\complib\stgdb\StgPooli.h \
                $(COM99_SRC)\complib\stgdb\stgpool.h \
                $(COM99_SRC)\MD\inc\MetaModel.h \
                $(COM99_SRC)\MD\inc\MetaModelRO.h \
                $(COM99_SRC)\MD\inc\MetaModelRW.h \

WCELINK_LIBS = \
                $(CORLIBS)\mdruntime.lib \
                $(CORLIBS)\RuntimeStub.lib\
                $(CORLIBS)\utilcode.lib

# Also consider these
#               $(CORLIBS)\cee.lib \
#               $(CORLIBS)\corslog.lib \
#               $(CORLIBS)\corsce.lib \
#               $(CORLIBS)\mdcompiler.lib \
#               $(CORLIBS)\reg.lib \

Create_WCELink: $(WCELINK_LIBS)
        lib /nologo /out:$(CORLIBS)\wcelink.lib $(WCELINK_LIBS) -debugtype:cv
#       FOR %f IN ( $(WCELINK_HEADERS) ) DO COPY %f $(HDR_TGT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\dlls\wcelink\nothing.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
void Place_Holder_For_Build_System()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\fjit.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "jitpch.h"
#pragma hdrstop

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            FJit.cpp                                       XX
XX                                                                           XX
XX   The functionality needed for the FAST JIT DLL.                          XX
XX   Includes the DLL entry point                                            XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/
//@TODO: clean up all of these includes and get properly set up for WinCE

#include "new.h"                // for placement new
#include "fjit.h"
#include <stdio.h>

#define DEBUGGER_PROBLEM_FIXED
//#define NON_RELOCATABLE_CODE  // uncomment to generate relocatable code

#include "openum.h"

#ifdef LOGGING
ConfigMethodSet fJitCodeLog(L"JitCodeLog");
char *opname[] =
{
#undef OPDEF
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,flow) s,
#include "opcode.def"
#undef OPDEF
};
#endif //LOGGING

#undef DECLARE_DATA

#define USE_EH_ENCODER
#include "EHEncoder.cpp"
#undef USE_EH_ENCODER

#define CODE_EXPANSION_RATIO 10
#define ROUND_TO_PAGE(x) ( (((x) + PAGE_SIZE - 1)/PAGE_SIZE) * PAGE_SIZE)

/* the jit helpers that we call at runtime */
BOOL FJit_HelpersInstalled;
unsigned __int64 (__stdcall *FJit_pHlpLMulOvf) (unsigned __int64 val1, unsigned __int64 val2);
float (jit_call *FJit_pHlpFltRem) (float divisor, float dividend);
double (jit_call *FJit_pHlpDblRem) (double divisor, double dividend);

void (jit_call *FJit_pHlpRngChkFail) (unsigned tryIndex);
void (jit_call *FJit_pHlpOverFlow) (unsigned tryIndex);
void (jit_call *FJit_pHlpInternalThrow) (CorInfoException throwEnum);
CORINFO_Object (jit_call *FJit_pHlpArrAddr_St) (CORINFO_Object elem, int index, CORINFO_Object array);
void (jit_call *FJit_pHlpInitClass) (CORINFO_CLASS_HANDLE cls);
CORINFO_Object (jit_call *FJit_pHlpNewObj) (CORINFO_METHOD_HANDLE constructor);
void (jit_call *FJit_pHlpThrow) (CORINFO_Object obj);
void (jit_call *FJit_pHlpRethrow) ();
void (jit_call *FJit_pHlpPoll_GC) ();
void (jit_call *FJit_pHlpMonEnter) (CORINFO_Object obj);
void (jit_call *FJit_pHlpMonExit) (CORINFO_Object obj);
void (jit_call *FJit_pHlpMonEnterStatic) (CORINFO_METHOD_HANDLE method);
void (jit_call *FJit_pHlpMonExitStatic) (CORINFO_METHOD_HANDLE method);
CORINFO_Object (jit_call *FJit_pHlpChkCast) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls);
void (jit_call *FJit_pHlpAssign_Ref_EAX)(); // *EDX = EAX, inform GC
BOOL (jit_call *FJit_pHlpIsInstanceOf) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls);
CORINFO_Object (jit_call *FJit_pHlpNewArr_1_Direct) (CORINFO_CLASS_HANDLE cls, unsigned cElem);
CORINFO_Object (jit_call *FJit_pHlpBox) (CORINFO_CLASS_HANDLE cls);
void* (jit_call *FJit_pHlpUnbox) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls);
void* (jit_call *FJit_pHlpGetField32) (CORINFO_Object*, CORINFO_FIELD_HANDLE);
__int64 (jit_call *FJit_pHlpGetField64) (CORINFO_Object*, CORINFO_FIELD_HANDLE);
void* (jit_call *FJit_pHlpGetField32Obj) (CORINFO_Object*, CORINFO_FIELD_HANDLE);
void (jit_call *FJit_pHlpSetField32) (CORINFO_Object*, CORINFO_FIELD_HANDLE , __int32);
void (jit_call *FJit_pHlpSetField64) (CORINFO_Object*, CORINFO_FIELD_HANDLE , __int64 );
void (jit_call *FJit_pHlpSetField32Obj) (CORINFO_Object*, CORINFO_FIELD_HANDLE , LPVOID);
void* (jit_call *FJit_pHlpGetFieldAddress) (CORINFO_Object*, CORINFO_FIELD_HANDLE);

void (jit_call *FJit_pHlpGetRefAny) (CORINFO_CLASS_HANDLE cls, void* refany);
void (jit_call *FJit_pHlpEndCatch) ();
void (jit_call *FJit_pHlpPinvokeCalli) ();
void (jit_call *FJit_pHlpTailCall) ();
void (jit_call *FJit_pHlpBreak) ();
CORINFO_MethodPtr* (jit_call *FJit_pHlpEncResolveVirtual) (CORINFO_Object*, CORINFO_METHOD_HANDLE );

#define New(var, exp) \
    if ((var = new exp) == NULL) \
        RaiseException(SEH_NO_MEMORY,EXCEPTION_NONCONTINUABLE,0,NULL);

// This is a filter that checks to see whether we got an access violation (this
// is the only exception that the jitcompile method expects and is prepared to handle)
// For all other exceptions, perform the cleanup and continue search
int CheckIfHandled(int ExceptionCode, int expectedException, FJitContext** pFjitData)
{
    if (ExceptionCode == expectedException)
        return EXCEPTION_EXECUTE_HANDLER;
    // do the cleanup
    if (*pFjitData != NULL)
    {
        (*pFjitData)->ReleaseContext();
        *pFjitData = NULL;
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

/*****************************************************************************/
/* this routine insures that a float is truncated to float precision.  
   We do this by forcing the memory spill  */ 

float truncateToFloat(float f) {
	return(f);
}

/*****************************************************************************
 * Disassemble and dump the Fjited code
 */


#ifdef _DEBUG

#include "msdis.h"
#include "disx86.h"


void disAsm(const void * codeBlock, size_t codeSize, bool printIt)
{
    DIS * pdis = NULL;
#ifdef _X86_
    pdis = DIS::PdisNew(DIS::distX86);
#else
    return;
#endif

    if (pdis == NULL)
    {
        _ASSERTE(!"out of memory in disassembler?");
        return;
    }

    LOGMSG((logCallback, LL_INFO1000, "FJitted method to %08Xh size=%08Xh\n", codeBlock, codeSize));
    LOGMSG((logCallback, LL_INFO1000, "--------------------------\n"));

    const void *curCode = codeBlock;
    DIS::ADDR   curAddr = (DIS::ADDR)codeBlock;
    size_t      curOffs = 0;

    while(curOffs < codeSize)
    {
        size_t cb = pdis->CbDisassemble(curAddr, curCode, codeSize - curOffs);
        //_ASSERTE(cb);
        if (cb) {
            if (printIt)
            {
                char sz[256];
#ifndef _WIN64
                if (pdis->CchFormatInstr(sz, sizeof(sz)))
#endif
                    LOGMSG((logCallback, LL_INFO1000, "%08Xh(%03X)      %s\n", (unsigned)curAddr, curOffs, sz));
            }
        }
        else
            cb = 1;

        curCode  = cb + (const char *)curCode;
        curAddr += cb;
        curOffs += cb;
    }

    delete pdis;
}

#endif // _DEBUG

/*****************************************************************************/
BOOL WINAPI     DllMain(HANDLE hInstance, DWORD dwReason, LPVOID pvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {

        // do any initialization here

        //@TODO: get from parameters the size of code cache to use
        unsigned int cache_len = 100*4096;

        //allocate the code cache
        if(!FJit::Init(cache_len)) {
            //@TODO: return an error
            _ASSERTE(0);
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        // do any finalization here

        // free the code cache
        FJit::Terminate();
    }
    return TRUE;
}

FJit* ILJitter = 0;     // The one and only instance of this JITer

/*****************************************************************************/
/* FIX, really the ICorJitCompiler should be done as a COM object, this is just
   something to get us going */

extern "C" 
ICorJitCompiler* __stdcall getJit()
{
    static char FJitBuff[sizeof(FJit)];
    if (ILJitter == 0)
    {
        // no need to check for out of memory, since caller checks for return value of NULL
        ILJitter = new(FJitBuff) FJit();
        _ASSERTE(ILJitter != NULL);
    }
    return(ILJitter);
}

FJit::FJit() {
}

FJit::~FJit() {
}

/* TODO: eliminate this method when the FJit_EETwain is moved into the same dll as fjit */
FJit_Encode* __stdcall FJit::getEncoder() {
    FJit_Encode* encoder;
    New(encoder, FJit_Encode());
    return encoder;
}

static unsigned gFjittedMethodNumber = 0;
#ifdef _DEBUG
static ConfigMethodSet fJitBreak(L"JitBreak");
static ConfigMethodSet fJitDisasm(L"JitDisasm");
#endif

/*****************************************************************************
 *  The main JIT function
 */
    //Note: this assumes that the code produced by fjit is fully relocatable, i.e. requires
    //no fixups after it is generated when it is moved.  In particular it places restrictions
    //on the code sequences used for static and non virtual calls and for helper calls among
    //other things,i.e. that pc relative instructions are not used for references to things outside of the
    //jitted method, and that pc relative instructions are used for all references to things
    //within the jitted method.  To accomplish this, the fjitted code is always reached via a level
    //of indirection.
CorJitResult __stdcall FJit::compileMethod (
            ICorJitInfo*               compHnd,            /* IN */
            CORINFO_METHOD_INFO*        info,               /* IN */
            unsigned                flags,              /* IN */
            BYTE **                 entryAddress,       /* OUT */
            ULONG  *                nativeSizeOfCode    /* OUT */
            )
{
#if defined(_DEBUG) || defined(LOGGING)
            // make a copy of the ICorJitInfo vtable so that I can log mesages later
    // this was made non-static due to a VC7 bug
    static void* ijitInfoVtable = *((void**) compHnd);
    logCallback = (ICorJitInfo*) &ijitInfoVtable;
#endif

    if(!FJit::GetJitHelpers(compHnd)) return CORJIT_INTERNALERROR;

#if defined(_DEBUG) || defined(LOGGING)
    szDebugMethodName = compHnd->getMethodName(info->ftn, &szDebugClassName);
#endif

    // NOTE: should the properties of the FJIT change such that it
    // would have to pay attention to specific IL sequence points or
    // local variable liveness ranges for debugging purposes, we would
    // query the Runtime and Debugger for such information here,

    FJitContext* fjitData=NULL;
    CorJitResult ret = CORJIT_INTERNALERROR;
    unsigned char* savedCodeBuffer;
    unsigned savedCodeBufferCommittedSize;
    unsigned int codeSize;
    unsigned actualCodeSize;

#ifdef _DEBUG
    if (fJitBreak.contains(szDebugMethodName, szDebugClassName, PCCOR_SIGNATURE(info->args.sig)))
		_ASSERTE(!"JITBreak");
#endif

#ifndef _WIN64 // ia64 xcompiler reports: error C2712: Cannot use __try in functions that require object unwinding
    __try{
#endif
        fjitData = FJitContext::GetContext(this, compHnd, info, flags);

        _ASSERTE(fjitData); // if GetContext fails for any reason it throws an exception

        _ASSERTE(fjitData->opStack_len == 0);  // stack must be balanced at beginning of method

        codeSize = ROUND_TO_PAGE(info->ILCodeSize * CODE_EXPANSION_RATIO);  // HACK a large value for now
    #ifdef LOGGING
	codeLog = fJitCodeLog.contains(szDebugMethodName, szDebugClassName, PCCOR_SIGNATURE(info->args.sig));
        if (codeLog)
            codeSize = ROUND_TO_PAGE(info->ILCodeSize * 64);  
    #endif
        BOOL jitRetry;  // this is set to false unless we get an exception because of underestimation of code buffer size
        do {    // the following loop is expected to execute only once, except when we underestimate the size of the code buffer,
                // in which case, we try again with a larger codeSize
            if (codeSize < MIN_CODE_BUFFER_RESERVED_SIZE)
            {
                if (codeSize > fjitData->codeBufferCommittedSize) 
                {
                    if (fjitData->codeBufferCommittedSize > 0)
                    {
                        unsigned AdditionalMemorySize = codeSize - fjitData->codeBufferCommittedSize;
                        if (AdditionalMemorySize > PAGE_SIZE) {
                            unsigned char* additionalMemory = (unsigned char*) VirtualAlloc(fjitData->codeBuffer+fjitData->codeBufferCommittedSize+PAGE_SIZE,
                                                                                            AdditionalMemorySize-PAGE_SIZE,
                                                                                            MEM_COMMIT,
                                                                                            PAGE_EXECUTE_READWRITE);
                            if (additionalMemory == NULL) 
                                return CORJIT_OUTOFMEM;
                            _ASSERTE(additionalMemory == fjitData->codeBuffer+fjitData->codeBufferCommittedSize+PAGE_SIZE);
                        }
                        // recommit the guard page
                        VirtualAlloc(fjitData->codeBuffer + fjitData->codeBufferCommittedSize,
                                     PAGE_SIZE,
                                     MEM_COMMIT,
                                     PAGE_EXECUTE_READWRITE);
            
                        fjitData->codeBufferCommittedSize = codeSize;
                    }
                    else { /* first time codeBuffer being initialized */
                        fjitData->codeBuffer = (unsigned char*)VirtualAlloc(fjitData->codeBuffer,
                                                            codeSize,
                                                            MEM_COMMIT,
                                                            PAGE_EXECUTE_READWRITE);
                        if (fjitData->codeBuffer == NULL)
                            return CORJIT_OUTOFMEM;
                        else 
                            fjitData->codeBufferCommittedSize = codeSize;
                    }
                    _ASSERTE(codeSize == fjitData->codeBufferCommittedSize);
                    unsigned char* guardPage = (unsigned char*)VirtualAlloc(fjitData->codeBuffer + codeSize,
                                                            PAGE_SIZE,
                                                            MEM_COMMIT,
                                                            PAGE_READONLY); 
                    if (guardPage == NULL) 
                        return CORJIT_OUTOFMEM;
        
                }
            }
            else
            { // handle larger than MIN_CODE_BUFFER_RESERVED_SIZE methods
                savedCodeBuffer = fjitData->codeBuffer;
                savedCodeBufferCommittedSize = fjitData->codeBufferCommittedSize;
                fjitData->codeBuffer = (unsigned char*)VirtualAlloc(NULL,
                                                                    codeSize,
                                                                    MEM_RESERVE | MEM_COMMIT,
                                                                    PAGE_EXECUTE_READWRITE);
                if (fjitData->codeBuffer)
                    fjitData->codeBufferCommittedSize = codeSize;
                else
                    return CORJIT_OUTOFMEM;
            }



            unsigned char*  entryPoint;

            actualCodeSize = codeSize;
#ifndef _WIN64 // ia64 xcompiler reports: error C2712: Cannot use __try in functions that require object unwinding
            __try 
            {
#endif
                ret = jitCompile(fjitData, &entryPoint,&actualCodeSize); 
                jitRetry = false;
#ifndef _WIN64 // ia64 xcompiler reports: error C2712: Cannot use __try in functions that require object unwinding
            }
            __except(CheckIfHandled(GetExceptionCode(),SEH_ACCESS_VIOLATION,&fjitData))
                    
            {  
                // we underestimated the buffer size required, so free this and allocate a larger one
                    // check if this was a large method
                if (codeSize >= MIN_CODE_BUFFER_RESERVED_SIZE)
                {
                    VirtualFree(fjitData->codeBuffer,
                                fjitData->codeBufferCommittedSize,
                                MEM_DECOMMIT);
                    VirtualFree(fjitData->codeBuffer,
                                0,
                                MEM_RELEASE);
                    fjitData->codeBuffer = savedCodeBuffer;
                    fjitData->codeBufferCommittedSize = savedCodeBufferCommittedSize;
                }
                codeSize += codeSize; // try again with double the codeSize
                // The following release and get can be optimized, but since this is so rare, we don't bother doing it
                fjitData->ReleaseContext();
                fjitData = FJitContext::GetContext(this, compHnd, info, flags);
                _ASSERTE(fjitData);
                jitRetry = true;
            }
#endif
        } while (jitRetry);
#ifndef _WIN64 // ia64 xcompiler reports: error C2712: Cannot use __try in functions that require object unwinding
    }
    // @TODO: The following is not quite safe if we have resumable exceptions. Should have a try/finally 
    // to do the cleanup
    __except(CheckIfHandled(GetExceptionCode(), SEH_NO_MEMORY, &fjitData))
    {
        
        ret = CORJIT_OUTOFMEM; // no need to clean up here, since we always do it if ret != CORJIT_OK
                            // also, if the exception is not handled, then the filter does the cleanup
    }
#endif

    if (ret != CORJIT_OK)
    {
        if (fjitData)
            fjitData->ReleaseContext();
        return(ret);
    }

    *nativeSizeOfCode = actualCodeSize;

    //_ASSERTE(fjitData->opStack_len == 0);  // stack must be balanced at end of method
#ifndef NON_RELOCATABLE_CODE
    fjitData->fixupTable->resolve(fjitData->mapping, fjitData->codeBuffer); 
#endif
    // Report debugging information. 
    if (flags & CORJIT_FLG_DEBUG_INFO)
        reportDebuggingData(fjitData,&info->args);

#ifdef _DEBUG
    // Display the generated code
    if (0 && fJitDisasm.contains(szDebugMethodName, szDebugClassName, PCCOR_SIGNATURE(fjitData->methodInfo->args.sig)))
    {
        LOGMSG((compHnd, LL_INFO1000, "Assembly dump of '%s::%s' \n", 
            szDebugClassName, szDebugMethodName));
        disAsm(fjitData->codeBuffer, actualCodeSize, true);
        fjitData->displayGCMapInfo();
    }
#endif

    /* write the EH info */
    //@TODO: this should be compacted, but that requires the rest of the EE to not
    //directly access the EHInfor ptr in the method header
    unsigned exceptionCount = info->EHcount;
    FJit_Encode* mapping = fjitData->mapping;
    unsigned char* EHBuffer=NULL;
    unsigned EHbuffer_len=0;
    if (exceptionCount) 
    {
       // compress the EH info, allocate space, and copy it
        // allocate space to hold the (uncompressed) exception count and all the clauses
        // this is guaranteed to hold the compressed form
        unsigned sUncompressedEHInfo = sizeof(CORINFO_EH_CLAUSE)*exceptionCount + sizeof(unsigned int);
        if (fjitData->EHBuffer_size < sUncompressedEHInfo) {
            delete [] fjitData->EHBuffer;
            fjitData->EHBuffer_size = sUncompressedEHInfo;
            fjitData->EHBuffer  = new unsigned char[sUncompressedEHInfo];
            if (fjitData->EHBuffer == NULL)
            {
                fjitData->ReleaseContext();
                return CORJIT_OUTOFMEM;
            }
            
        }
        EHBuffer = fjitData->EHBuffer;
        unsigned char* EHBufferPtr;
        // reserve space in beginning to encode size of compressed EHinfo
        EHBufferPtr = EHBuffer+2;   // enough for 16K compressed EHinfo
        EHEncoder::encode(&EHBufferPtr,exceptionCount);
        //EHBuffer += sizeof(unsigned int);
        CORINFO_EH_CLAUSE clause;
        for (unsigned except = 0; except < exceptionCount; except++) 
        {
            compHnd->getEHinfo(info->ftn, except, &clause);
            clause.TryLength = mapping->pcFromIL(clause.TryOffset + clause.TryLength);
            clause.TryOffset = mapping->pcFromIL(clause.TryOffset);
            clause.HandlerLength = mapping->pcFromIL(clause.HandlerOffset+clause.HandlerLength);
            clause.HandlerOffset = mapping->pcFromIL(clause.HandlerOffset);
            if (clause.Flags & CORINFO_EH_CLAUSE_FILTER)
                clause.FilterOffset = mapping->pcFromIL(clause.FilterOffset);
            EHEncoder::encode(&EHBufferPtr,clause);
        }
        EHbuffer_len = (unsigned)(EHBufferPtr - EHBuffer);
        _ASSERTE(EHbuffer_len < 0x10000);
        *(short*)EHBuffer = (short)EHbuffer_len;
    }

    /* write the header and IL/PC map (gc info) */
    /* note, we do this after the EH info since we compress the mapping and the EH info needs
       to use the mapping */
    //@TODO: we should compact Fjit_hdrInfo and then copy
    unsigned char* hdr;
    unsigned hdr_len;

    //compute the total size needed
#ifdef _DEBUG
    //add the il to pc map at end of hdr
    hdr_len = sizeof(Fjit_hdrInfo)
        + fjitData->compressGCHdrInfo()
        + fjitData->mapping->compressedSize();
#else
    hdr_len = sizeof(Fjit_hdrInfo)
        + fjitData->compressGCHdrInfo();
#endif _DEBUG

    unsigned char *pCodeBlock, *pEhBlock;
    pCodeBlock = fjitData->codeBuffer; 
    BYTE* startAddress = (BYTE*) compHnd->alloc(actualCodeSize,
                                                &pCodeBlock,
                                                EHbuffer_len,
                                                &pEhBlock,
                                                hdr_len,
                                                &hdr);
    if ((HRESULT)startAddress == E_FAIL) {
        fjitData->ReleaseContext();
        return CORJIT_OUTOFMEM;
    }
    //memcpy(pCodeBlock,fjitData->codeBuffer,actualCodeSize);
#ifdef NON_RELOCATABLE_CODE
    fjitData->fixupTable->adjustMap((int) pCodeBlock - (int) fjitData->codeBuffer);
    fjitData->fixupTable->resolve(fjitData->mapping, pCodeBlock); 
#endif
    memcpy(pEhBlock,EHBuffer,EHbuffer_len);
#ifdef DEBUGGER_PROBLEM_FIXED
    *entryAddress = startAddress; 
#else
    *entryAddress = (unsigned char*) pCodeBlock;
#endif

    hdr = pEhBlock+EHbuffer_len;


    //move the pieces into it
    _ASSERTE(hdr_len);
    memcpy(hdr, &fjitData->mapInfo, sizeof(Fjit_hdrInfo));
    hdr += sizeof(Fjit_hdrInfo);
    hdr_len -= sizeof(Fjit_hdrInfo);
    _ASSERTE(hdr_len);
    memcpy(hdr, fjitData->gcHdrInfo, fjitData->gcHdrInfo_len);
    hdr += fjitData->gcHdrInfo_len;
    hdr_len -= fjitData->gcHdrInfo_len;
#ifdef _DEBUG
    //add il to pc map at end of hdr
    _ASSERTE(hdr_len);
    if(!fjitData->mapping->compress(hdr, hdr_len)) {
        _ASSERTE(!"did't fit in buffer");
    }
    hdr_len -= fjitData->mapping->compressedSize();
#endif _DEBUG
    _ASSERTE(!hdr_len); 


#ifdef _DEBUG
    if (codeSize < MIN_CODE_BUFFER_RESERVED_SIZE)
    {
        for (unsigned i=0; i< PAGE_SIZE; i++)
            *(fjitData->codeBuffer + i) = 0xCC;
    }
#endif

    // check if this was a large method
    if (codeSize >= MIN_CODE_BUFFER_RESERVED_SIZE)
    {
        VirtualFree(fjitData->codeBuffer,
                    fjitData->codeBufferCommittedSize,
                    MEM_DECOMMIT);
        VirtualFree(fjitData->codeBuffer,
                    0,
                    MEM_RELEASE);
        fjitData->codeBuffer = savedCodeBuffer;
        fjitData->codeBufferCommittedSize = savedCodeBufferCommittedSize;
    }

#ifdef LOGGING
    if (codeLog) {
        LOGMSG((compHnd, LL_INFO1000, "Fjitted '%s::%s' at addr %#x to %#x header %#x\n", 
            szDebugClassName,
            szDebugMethodName,
            (unsigned int) pCodeBlock,
            (unsigned int) pCodeBlock + actualCodeSize,
            hdr_len));
    }
#endif //LOGGING

    fjitData->ReleaseContext();
    return CORJIT_OK;

}


BOOL FJit::Init(unsigned int cache_len)
{
    FJit_HelpersInstalled = false;
    if (!FJitContext::Init()) return FALSE;
    return TRUE;
}

void FJit::Terminate() {
    FJitContext::Terminate();
    if (ILJitter) ILJitter->~FJit();
    ILJitter = NULL;
}


/* grab and remember the jitInterface helper addresses that we need at runtime */
BOOL FJit::GetJitHelpers(ICorJitInfo* jitInfo) {

    if (FJit_HelpersInstalled) return true;

    FJit_pHlpLMulOvf = (unsigned __int64 (__stdcall *) (unsigned __int64 val1, unsigned __int64 val2))
        (jitInfo->getHelperFtn(CORINFO_HELP_LMUL_OVF));
    if (!FJit_pHlpLMulOvf) return false;

    FJit_pHlpFltRem = (float (jit_call *) (float divisor, float dividend))
        (jitInfo->getHelperFtn(CORINFO_HELP_FLTREM));
    if (!FJit_pHlpFltRem) return false;

    FJit_pHlpDblRem = (double (jit_call *) (double divisor, double dividend))
        (jitInfo->getHelperFtn(CORINFO_HELP_DBLREM));
    if (!FJit_pHlpDblRem) return false;

    FJit_pHlpRngChkFail = (void (jit_call *) (unsigned tryIndex))
        (jitInfo->getHelperFtn(CORINFO_HELP_RNGCHKFAIL));
    if (!FJit_pHlpRngChkFail) return false;

    FJit_pHlpInternalThrow = (void (jit_call *) (CorInfoException throwEnum))
        (jitInfo->getHelperFtn(CORINFO_HELP_INTERNALTHROW));
    if (!FJit_pHlpInternalThrow) return false;

    FJit_pHlpArrAddr_St = (CORINFO_Object (jit_call *) (CORINFO_Object elem, int index, CORINFO_Object array))
        (jitInfo->getHelperFtn(CORINFO_HELP_ARRADDR_ST));
    if (!FJit_pHlpArrAddr_St) return false;

    FJit_pHlpOverFlow = (void (jit_call *) (unsigned tryIndex))
        (jitInfo->getHelperFtn(CORINFO_HELP_OVERFLOW));
    if (!FJit_pHlpOverFlow) return false;

    FJit_pHlpInitClass = (void (jit_call *) (CORINFO_CLASS_HANDLE cls))
        (jitInfo->getHelperFtn(CORINFO_HELP_INITCLASS));
    if (!FJit_pHlpOverFlow) return false;

    FJit_pHlpNewObj = (CORINFO_Object (jit_call *) (CORINFO_METHOD_HANDLE constructor))
        (jitInfo->getHelperFtn(CORINFO_HELP_NEWOBJ));
    if (!FJit_pHlpNewObj) return false;

    FJit_pHlpThrow = (void (jit_call *) (CORINFO_Object obj))
        (jitInfo->getHelperFtn(CORINFO_HELP_THROW));
    if (!FJit_pHlpThrow) return false;

    FJit_pHlpRethrow = (void (jit_call *) ())
        (jitInfo->getHelperFtn(CORINFO_HELP_RETHROW));
    if (!FJit_pHlpRethrow) return false;

    FJit_pHlpPoll_GC = (void (jit_call *) ())
        (jitInfo->getHelperFtn(CORINFO_HELP_POLL_GC));
    if (!FJit_pHlpPoll_GC) return false;

    FJit_pHlpMonEnter = (void (jit_call *) (CORINFO_Object obj))
        (jitInfo->getHelperFtn(CORINFO_HELP_MON_ENTER));
    if (!FJit_pHlpMonEnter) return false;

    FJit_pHlpMonExit = (void (jit_call *) (CORINFO_Object obj))
        (jitInfo->getHelperFtn(CORINFO_HELP_MON_EXIT));
    if (!FJit_pHlpMonExit) return false;

    FJit_pHlpMonEnterStatic = (void (jit_call *) (CORINFO_METHOD_HANDLE method))
        (jitInfo->getHelperFtn(CORINFO_HELP_MON_ENTER_STATIC));
    if (!FJit_pHlpMonEnterStatic) return false;

    FJit_pHlpMonExitStatic = (void (jit_call *) (CORINFO_METHOD_HANDLE method))
        (jitInfo->getHelperFtn(CORINFO_HELP_MON_EXIT_STATIC));
    if (!FJit_pHlpMonExitStatic) return false;

    FJit_pHlpChkCast = (CORINFO_Object (jit_call *) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls))
        (jitInfo->getHelperFtn(CORINFO_HELP_CHKCAST));
    if (!FJit_pHlpChkCast) return false;

    FJit_pHlpIsInstanceOf = (BOOL (jit_call *) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls))
        (jitInfo->getHelperFtn(CORINFO_HELP_ISINSTANCEOF));
    if (!FJit_pHlpIsInstanceOf) return false;

    FJit_pHlpNewArr_1_Direct = (CORINFO_Object (jit_call *) (CORINFO_CLASS_HANDLE cls, unsigned cElem))
        (jitInfo->getHelperFtn(CORINFO_HELP_NEWARR_1_DIRECT));
    if (!FJit_pHlpNewArr_1_Direct) return false;

    FJit_pHlpBox = (CORINFO_Object (jit_call *) (CORINFO_CLASS_HANDLE cls))
        (jitInfo->getHelperFtn(CORINFO_HELP_BOX));
    if (!FJit_pHlpBox) return false;

    FJit_pHlpUnbox = (void* (jit_call *) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls))
        (jitInfo->getHelperFtn(CORINFO_HELP_UNBOX));
    if (!FJit_pHlpUnbox) return false;

    FJit_pHlpGetField32 = (void* (jit_call *) (CORINFO_Object*, CORINFO_FIELD_HANDLE))
        (jitInfo->getHelperFtn(CORINFO_HELP_GETFIELD32));
    if (!FJit_pHlpGetField32) return false;

    FJit_pHlpGetField64 = (__int64 (jit_call *) (CORINFO_Object*, CORINFO_FIELD_HANDLE))
        (jitInfo->getHelperFtn(CORINFO_HELP_GETFIELD64));
    if (!FJit_pHlpGetField64) return false;

    FJit_pHlpGetField32Obj = (void* (jit_call *) (CORINFO_Object*, CORINFO_FIELD_HANDLE))
        (jitInfo->getHelperFtn(CORINFO_HELP_GETFIELD32OBJ));
    if (!FJit_pHlpGetField32Obj) return false;

    FJit_pHlpSetField32 = (void (jit_call *) (CORINFO_Object*, CORINFO_FIELD_HANDLE,  __int32 ))
        (jitInfo->getHelperFtn(CORINFO_HELP_SETFIELD32));
    if (!FJit_pHlpSetField32) return false;

    FJit_pHlpSetField64 = (void (jit_call *) (CORINFO_Object*, CORINFO_FIELD_HANDLE , __int64 ))
        (jitInfo->getHelperFtn(CORINFO_HELP_SETFIELD64));
    if (!FJit_pHlpSetField64) return false;

    FJit_pHlpSetField32Obj = (void (jit_call *) (CORINFO_Object*, CORINFO_FIELD_HANDLE, LPVOID))
        (jitInfo->getHelperFtn(CORINFO_HELP_SETFIELD32OBJ));
    if (!FJit_pHlpSetField32Obj) return false;

    FJit_pHlpGetFieldAddress = (void* (jit_call *) (CORINFO_Object*, CORINFO_FIELD_HANDLE))
        (jitInfo->getHelperFtn(CORINFO_HELP_GETFIELDADDR));
    if (!FJit_pHlpGetFieldAddress) return false;

    FJit_pHlpGetRefAny = (void (jit_call *) (CORINFO_CLASS_HANDLE cls, void* refany))
        (jitInfo->getHelperFtn(CORINFO_HELP_GETREFANY));
    if (!FJit_pHlpGetRefAny) return false;

    FJit_pHlpEndCatch = (void (jit_call *) ())
        (jitInfo->getHelperFtn(CORINFO_HELP_ENDCATCH));
    if (!FJit_pHlpEndCatch) return false;

    FJit_pHlpPinvokeCalli = (void (jit_call *) ())
        (jitInfo->getHelperFtn(CORINFO_HELP_PINVOKE_CALLI));
    if (!FJit_pHlpPinvokeCalli) return false;

    FJit_pHlpTailCall = (void (jit_call *) ())
        (jitInfo->getHelperFtn(CORINFO_HELP_TAILCALL));
    if (!FJit_pHlpTailCall) return false;

    FJit_pHlpBreak = (void (jit_call *) ())
        (jitInfo->getHelperFtn(CORINFO_HELP_USER_BREAKPOINT));
    if (!FJit_pHlpBreak) return false;

    FJit_pHlpEncResolveVirtual = (CORINFO_MethodPtr* (jit_call *) (CORINFO_Object*, CORINFO_METHOD_HANDLE ))
        (jitInfo->getHelperFtn(CORINFO_HELP_EnC_RESOLVEVIRTUAL));
    if (!FJit_pHlpEncResolveVirtual) return false;

extern CORINFO_Object (jit_call *FJit_pHlpBox) (CORINFO_CLASS_HANDLE cls);

//@TODO: Change when a generic writebarrier helper is added to use it instead
#ifdef _X86_
    FJit_pHlpAssign_Ref_EAX = (void (jit_call *)())
        (jitInfo->getHelperFtn(CORINFO_HELP_CHECKED_ASSIGN_REF_EAX));
    if (!FJit_pHlpAssign_Ref_EAX) return false;
#endif _X86_

    FJit_HelpersInstalled = true;
    return true;
}

// FIX : we should put all the machine dependant stuff in one place


#include "helperFrame.h"

/***************************************************************************/
/* throw an EE exception 'throwEnum' from a fjit C helper.  In order to
   do this, this routine needs 'state', the state of the CPU at the point
   that the helper would return to the FJIT code.  This routine resets
   the CPU to that state (effectively returning from the helper, and then
   sets up the stack as if a call to the EE throw routine was made from that
   point.  It then jumps to the EE throw routine.

   Note that there is a subtlety here in that the IP looks like it just
   executed a call to C helper, but it is really in the throw helper.

   This is only of concern if things like stack depth tracking makes inferences
   based on what the EIP is.  The FJIT does not do this, so we are OK.
*/

#pragma warning (disable : 4731)
void throwFromHelper(CorInfoException throwEnum) {
    LazyMachState state;
    CAPTURE_STATE(state);
    state.getState(2);          // compute the state of caller's caller (the function 
                                // that called throwFromHelper)
#ifdef _X86_
    __asm {
        // restore the state of the machine to what it was if the call returned
    lea EAX, state
    mov ESI, [EAX]MachState._esi
    mov EDI, [EAX]MachState._edi
    mov EBX, [EAX]MachState._ebx
    mov ECX, throwEnum          //load the exception while we can still use esp,ebp
    mov EBP, [EAX]MachState._ebp
    mov ESP, [EAX]MachState._esp

        // set up the state as if we called 'InternalThrow' from the fjit code
    mov EAX, [EAX]MachState._pRetAddr
    mov EAX, [EAX]
    push EAX

    jmp [FJit_pHlpInternalThrow]
    }
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - throwFromHelper (fjit.cpp)");
#endif // _X86_
}
#pragma warning (default : 4731)

//*************************************************************************************
//      FixupTable methods
//*************************************************************************************
FixupTable::FixupTable()
{
    relocations_size = 0;               //let it grow as appropriate
    relocations_len = relocations_size;
    relocations = NULL;
}

FixupTable::~FixupTable()
{
    if (relocations) delete [] relocations;
    relocations = NULL;
}

CorJitResult FixupTable::insert(void** pCodeBuffer)
{
    if (relocations_len >= relocations_size) {
        relocations_size = FJitContext::growBuffer((unsigned char**)&relocations, relocations_len*sizeof(void*), (relocations_len+1)*sizeof(void*));
        relocations_size = relocations_size / sizeof(void*);
    }
    relocations[relocations_len++] = (unsigned) (pCodeBuffer);
    return CORJIT_OK;
}

void  FixupTable::adjustMap(int delta) 
{
    for (unsigned i = 0; i < relocations_len; i++) {
        relocations[i] = (int) relocations[i] + delta;
    }
}

void  FixupTable::resolve(FJit_Encode* mapping, BYTE* startAddress) 
{
    for (unsigned i = 0; i < relocations_len; i++) {
        unsigned* address = (unsigned*) relocations[i];
        unsigned targetILoffset = *address;
        unsigned target;
        if ((unsigned) targetILoffset < 0x80000000)
        {
            target = mapping->pcFromIL(targetILoffset) + (unsigned) startAddress;
        }
        else
        {
            target = targetILoffset - 0x80000000;
        }
        *address = target - ((unsigned) address + sizeof(void*));
    }
}

void  FixupTable::setup() 
{
#ifdef _DEBUG
    memset(relocations, 0xDD, relocations_len*sizeof(void*));
#endif
    relocations_len = 0;
}

//*************************************************************************************


/*  Either an available FJitContext or NULL
    We are assuming that on average we will finish this jit before another starts up.
    If that proves to be untrue, we'll just allocate new FJitContext's as necessary.
    We delete the extra ones in FJitContext::ReleaseContext()
    */
FJitContext* next_FJitContext;

// This is the same as New special cased for FJitContext since the caller 
// has an SEH __try block which is not allowed by the compiler.
void NewFjitContext(FJitContext** pNewContext, ICorJitInfo* comp)
{
    if ((*pNewContext = new FJitContext(comp)) == NULL) 
        RaiseException(SEH_NO_MEMORY,EXCEPTION_NONCONTINUABLE,0,NULL);
    
}
/* get and initialize a compilation context to use for compiling */
FJitContext* FJitContext::GetContext(FJit* jitter, ICorJitInfo* comp, CORINFO_METHOD_INFO* methInfo, DWORD dwFlags) {
    FJitContext* next;

    //@BUG: TODO: replace FastInterlockedExchange with FastInterlockedExchangePointer when available
    next = (FJitContext*)InterlockedExchange((long*) &next_FJitContext,NULL);
    BOOL gotException = TRUE;
    __try 
    {
        /*if the list was empty, make a new one to use */
        if (!next)
        {
            NewFjitContext(&next,comp);
        }
        /* set up this one for use */
        next->jitter = jitter;
        next->jitInfo = comp;
        next->methodInfo = methInfo;
        next->flags = dwFlags;
        next->ensureMapSpace();
        next->setup();
        gotException = FALSE;
    }
    __finally //(EXCEPTION_EXECUTE_HANDLER)
    {
        // cleanup if we get here because of an exception
        if (gotException && (next != NULL))
        {
            next->ReleaseContext();
            next = NULL;
        }
    }

    return next;
}

/* return a compilation context to the free list */
/* xchange with the next_FJitContext and if we get one back, delete the one we get back
   The assumption is that the steady state case is almost no concurrent jits
   */
void FJitContext::ReleaseContext() {
    FJitContext* next;

    /* mark this context as not in use */
    jitInfo = NULL;
    methodInfo = NULL;
    jitter = NULL;
    _ASSERTE(this != next_FJitContext);     // I should not be on the free 'list' 

    //@BUG: TODO: replace FastInterlockedExchange with FastInterlockedExchangePointer when available
    next = (FJitContext*)InterlockedExchange((long*) &next_FJitContext,(long)this);
//  next = (FJitContext*) FastInterlockExchange ((long*) next_FJitContext, (long*) this);

    _ASSERTE(this != next);                 // I was not on the free 'list'
    if (next) delete next;
}

/* make sure list of available compilation contexts is initialized at startup */
BOOL FJitContext::Init() {
    next_FJitContext = NULL;
    return TRUE;
}

void FJitContext::Terminate() {
    //@TODO: for now we are not using a list, so we are not thread safe
    if (next_FJitContext) delete next_FJitContext;
    next_FJitContext = NULL;
    return;
}


FJitContext::FJitContext(ICorJitInfo* comp) {

    // To guard the cast to (bool *) from (BYTE *) in the calls to getClassGClayout
    _ASSERTE(sizeof(BYTE) == sizeof(bool));

    New(mapping,FJit_Encode());
    New(state, FJitState[0]);
    New(localsMap,stackItems[0]);
    New(argsMap,stackItems[0]);
    New(opStack,OpType[0]);
    New(localsGCRef,bool[0]);
    New(interiorGC,bool[0]);
    New(pinnedGC,bool[0]);
    New(pinnedInteriorGC,bool[0]);
    New(gcHdrInfo,unsigned char[0]);

    codeBuffer = (unsigned char*)VirtualAlloc(NULL,
                              MIN_CODE_BUFFER_RESERVED_SIZE,
                              MEM_RESERVE,
                              PAGE_EXECUTE_READWRITE);

    if (codeBuffer) {
        codeBufferReservedSize = MIN_CODE_BUFFER_RESERVED_SIZE;
        codeBufferCommittedSize = 0;
    }
    else
    {
        codeBufferReservedSize = 0;
        codeBufferCommittedSize = 0;
#ifdef _DEBUG
        DWORD errorcode = GetLastError();
        LOGMSG((jitInfo, LL_INFO1000, "Virtual alloc failed. Error code = %#x", errorcode));
#endif
    }

    New(fixupTable,FixupTable());
    gcHdrInfo_len = 0;
    gcHdrInfo_size = 0;
    interiorGC_len = 0;
    localsGCRef_len = 0;
    pinnedGC_len = 0;
    pinnedInteriorGC_len = 0;
    interiorGC_size = 0;
    localsGCRef_size = 0;
    pinnedGC_size = 0;
    pinnedInteriorGC_size = 0;
    EHBuffer_size = 256;    // start with some reasonable size, it is grown more if needed
    New(EHBuffer,unsigned char[EHBuffer_size]);
    opStack_len = 0;
    opStack_size = 0;
    state_size = 0;
    locals_size = 0;
    args_size = 0;

    jitInfo = NULL;
    flags = 0;

    // initialize cached constants
    CORINFO_EE_INFO CORINFO_EE_INFO;
    comp->getEEInfo(&CORINFO_EE_INFO);
    OFFSET_OF_INTERFACE_TABLE = CORINFO_EE_INFO.offsetOfInterfaceTable;


}

FJitContext::~FJitContext() {
    if (mapping) delete mapping;
    mapping = NULL;
    if (state) delete [] state;
    state = NULL;
    if (argsMap) delete [] argsMap;
    argsMap = NULL;
    if (localsMap) delete [] localsMap;
    localsMap = NULL;
    if (opStack) delete [] opStack;
    opStack = NULL;
    if (localsGCRef) delete [] localsGCRef;
    localsGCRef = NULL;
    if (interiorGC) delete [] interiorGC;
    interiorGC = NULL;
    if (pinnedGC) delete [] pinnedGC;
    pinnedGC = NULL;
    if (pinnedInteriorGC) delete [] pinnedInteriorGC;
    pinnedInteriorGC = NULL;
    if (gcHdrInfo) delete [] gcHdrInfo;
    gcHdrInfo = NULL;
    if (EHBuffer) delete [] EHBuffer;
    EHBuffer = NULL;
    _ASSERTE(codeBuffer);
    if (codeBufferCommittedSize>0) {
        VirtualFree(codeBuffer,
                    codeBufferCommittedSize,
                    MEM_DECOMMIT);
    }
    _ASSERTE(codeBufferReservedSize > 0);
    VirtualFree(codeBuffer,0,MEM_RELEASE);
    codeBufferReservedSize = 0;
    if (fixupTable) delete fixupTable;
    fixupTable = NULL;
}

/* Reset state of context to state at the start of jitting. Called when we need to abort and rejit a method */
void FJitContext::resetContextState()
{
    fixupTable->setup();
    mapping->reset();
    resetOpStack(); 
}

/*adjust the internal mem structs as needed for the size of the method being jitted*/
void FJitContext::ensureMapSpace() {
    if (methodInfo->ILCodeSize > state_size) {
        delete [] state;
        state_size = methodInfo->ILCodeSize;
        New(state,FJitState[state_size]);
    }
    memset(state, 0, methodInfo->ILCodeSize * sizeof(FJitState));
    mapping->ensureMapSpace(methodInfo->ILCodeSize);
}

/* initialize the compilation context with the method data */
void FJitContext::setup() {
    unsigned size;
    unsigned char* outPtr;

    methodAttributes = jitInfo->getMethodAttribs(methodInfo->ftn, methodInfo->ftn);

        // @TODO we should always use sig to find out if we have a this pointer
    _ASSERTE(((methodAttributes & CORINFO_FLG_STATIC) == 0) == (methodInfo->args.hasThis()));

    /* set up the labled stacks */
    stacks.reset();
    stacks.jitInfo = jitInfo;

    /* initialize the fixup table */
    fixupTable->setup();

    /* set gcHdrInfo compression buffer empty */
    gcHdrInfo_len = 0;
    if (methodInfo->EHcount) {
        JitGeneratedLocalsSize = (methodInfo->EHcount*2+2)*sizeof(void*);  // two locals for each EHclause,1 for localloc, and one for end marker
    }
    else {
        JitGeneratedLocalsSize = sizeof(void*);  // no eh clause, but there might be a localloc
    }
    /* compute local offsets */
    computeLocalOffsets(); // should be replaced by an exception?
    /* encode the local gc refs and interior refs into the gcHdrInfo */
    //make sure there's room
    //Compression ratio 8:1 (1 bool = 8 bits gets compressed to 1 bit)
    size = ( localsGCRef_len + 7 + 
             interiorGC_len + 7 + 
             pinnedGC_len + 7 + 
             pinnedInteriorGC_len + 7) / 8 
              + 2*4 /* bytes to encode size of each*/;

    if (gcHdrInfo_len+size > gcHdrInfo_size) {
        gcHdrInfo_size = growBuffer(&gcHdrInfo, gcHdrInfo_len, gcHdrInfo_len+size);
    }
    //drop the pieces in
    size = FJit_Encode::compressBooleans(localsGCRef, localsGCRef_len);
    outPtr = &gcHdrInfo[gcHdrInfo_len];
    gcHdrInfo_len += FJit_Encode::encode(size, &outPtr);
    memcpy(outPtr, localsGCRef, size);
    gcHdrInfo_len += size;

    size = FJit_Encode::compressBooleans(interiorGC, interiorGC_len);
    outPtr = &gcHdrInfo[gcHdrInfo_len];
    gcHdrInfo_len += FJit_Encode::encode(size, &outPtr);
    memcpy(outPtr, interiorGC, size);
    gcHdrInfo_len += size;

    size = FJit_Encode::compressBooleans(pinnedGC, pinnedGC_len);
    outPtr = &gcHdrInfo[gcHdrInfo_len];
    gcHdrInfo_len += FJit_Encode::encode(size, &outPtr);
    memcpy(outPtr, pinnedGC, size);
    gcHdrInfo_len += size;

    size = FJit_Encode::compressBooleans(pinnedInteriorGC, pinnedInteriorGC_len);
    outPtr = &gcHdrInfo[gcHdrInfo_len];
    gcHdrInfo_len += FJit_Encode::encode(size, &outPtr);
    memcpy(outPtr, pinnedInteriorGC, size);
    gcHdrInfo_len += size;
    
    _ASSERTE(gcHdrInfo_len <= gcHdrInfo_size);

    /* set up the operand stack */
    size = methodInfo->maxStack+1; //+1 since for a new obj intr, +1 for exceptions
#ifdef _DEBUG
    size++; //to allow writing TOS marker beyond end;
#endif
    if (size > opStack_size) {
        if (opStack) delete [] opStack;
        opStack_size = size+4; //+4 to cut down on reallocations
        New(opStack,OpType[opStack_size]);
    }
    opStack_len = 0;    //stack starts empty

    /* set up the labels table */
    labels.reset();

    /*lets drop the exception handler entry points into our label table.
      but first we have to make a dummy stack with an object on it.
      */
    *opStack = typeRef;
    opStack_len = 1;
    // insert the handler entry points
    if (methodInfo->EHcount) {
        for (unsigned int except = 0; except < methodInfo->EHcount; except++) {
            CORINFO_EH_CLAUSE clause;
            jitInfo->getEHinfo(methodInfo->ftn, except, &clause);
            state[clause.HandlerOffset].isHandler = true;
            if ((clause.Flags & CORINFO_EH_CLAUSE_FINALLY) ||
                (clause.Flags & CORINFO_EH_CLAUSE_FAULT)) {
                labels.add(clause.HandlerOffset, opStack, 0);
            }
            else {
                labels.add(clause.HandlerOffset, opStack, 1);
                state[clause.HandlerOffset].isTOSInReg = true;
            }

            if (clause.Flags & CORINFO_EH_CLAUSE_FILTER) {
                labels.add(clause.FilterOffset, opStack, 1);
                state[clause.FilterOffset].isTOSInReg = true;
                state[clause.FilterOffset].isHandler  = true;
                state[clause.FilterOffset].isFilter   = true;
            }
        }
    }
    // @TODO: Optimization:- instead of EHcount only d= max nesting level slots are needed

    // drop the dummy stack entry
    opStack_len = 0;

    /* compute arg offsets, note offsets <0 imply enregistered args */
    args_len = methodInfo->args.numArgs;
    if (methodInfo->args.hasThis()) args_len++;     //+1 since we treat <this> as arg 0, if <this> is present
    if (args_len > args_size) {
        if (argsMap) delete [] argsMap;
        args_size = args_len+4; //+4 to cut down on reallocating.
        New(argsMap,stackItems[args_size]);
    }

    // Get layout information on the arguments
    _ASSERTE(sizeof(stackItems) == sizeof(argInfo));
    argInfo* argsInfo = (argInfo*) argsMap;
    _ASSERTE(!methodInfo->args.hasTypeArg());

    argsFrameSize = computeArgInfo(&methodInfo->args, argsInfo, jitInfo->getMethodClass(methodInfo->ftn));

        // Convert the sizes to offsets (assumes the stack grows down)
        // Note we are reusing the same memory in place!
    unsigned offset = argsFrameSize + sizeof(prolog_frame);
        // The varargs frame starts just above the first arg.
    if (methodInfo->args.isVarArg())
        offset = 0;
    for (unsigned i =0; i < args_len; i++) {
        if (argsInfo[i].isReg) {
            argsMap[i].offset = offsetOfRegister(argsInfo[i].regNum);
        }
        else {
            offset -= argsInfo[i].size;
            argsMap[i].offset = offset;
        }
        _ASSERTE(argsInfo[i].isReg == argsMap[i].isReg);
        _ASSERTE(argsInfo[i].regNum == argsMap[i].regNum);
    }
    _ASSERTE(offset == sizeof(prolog_frame) || methodInfo->args.isVarArg());

    /* build the method header info for the code manager */
    mapInfo.hasThis = methodInfo->args.hasThis();
    mapInfo.EnCMode = (flags & CORJIT_FLG_DEBUG_EnC) ? true : false;
    mapInfo.methodArgsSize = argsFrameSize;
    mapInfo.methodFrame = (unsigned short)((localsFrameSize + sizeof(prolog_data))/sizeof(void*));
    //mapInfo.hasSecurity = (methodAttributes & CORINFO_FLG_SECURITYCHECK) ? TRUE : FALSE;
    mapInfo.methodJitGeneratedLocalsSize = JitGeneratedLocalsSize;
}

void appendGCArray(unsigned local_word, unsigned* pGCArray_size, unsigned* pGCArray_len,bool** ppGCArray)
{
    if (local_word + 1 > *pGCArray_size) {
        *pGCArray_size = FJitContext::growBooleans(ppGCArray, *pGCArray_len, local_word+1);
    }
    else {
        memset(&((*ppGCArray)[*pGCArray_len]), 0, local_word- *pGCArray_len);
    }
    *pGCArray_len = local_word;
    (*ppGCArray)[(*pGCArray_len)++] = true;

}
/* compute the locals offset map for the method being compiled */
void FJitContext::computeLocalOffsets() {

    /* compute the number of locals and make sure we have the space */
    _ASSERTE(methodInfo->locals.numArgs < 0x10000);
    if (methodInfo->locals.numArgs > locals_size) {
        if (localsMap) delete [] localsMap;
        locals_size = methodInfo->locals.numArgs+16;    // +16 to cut down on reallocation
        New(localsMap,stackItems[locals_size]);
    }

    /* assign the offsets, starting with the ones in defined in the il header */
    interiorGC_len = 0;
    localsGCRef_len = 0;
    pinnedGC_len = 0;
    pinnedInteriorGC_len = 0;
    unsigned local = 0;
    unsigned offset = JitGeneratedLocalsSize;
    unsigned local_word = 0;    //offset in words to a local in the local frame

    /* process the local var sig */
    CORINFO_ARG_LIST_HANDLE sig = methodInfo->locals.args;
    while (local < methodInfo->locals.numArgs) {
		CORINFO_CLASS_HANDLE cls;
        CorInfoTypeWithMod corArgType = jitInfo->getArgType(&methodInfo->locals, sig, &cls);
        CorInfoType argType = strip(corArgType);
        unsigned size = computeArgSize(argType, sig, &methodInfo->locals);
        OpType locType;
        if (argType == CORINFO_TYPE_VALUECLASS) {
            _ASSERTE(cls);  
            locType = OpType(cls);

            unsigned words = size / sizeof(void*);  //#of void* sized words in local
            if (local_word + words > localsGCRef_size)
                localsGCRef_size = growBooleans(&localsGCRef, localsGCRef_len, local_word+words);
            else
                memset(&localsGCRef[localsGCRef_len], 0, local_word-localsGCRef_len);
            localsGCRef_len = local_word;
            jitInfo->getClassGClayout(cls, (BYTE*)&localsGCRef[localsGCRef_len]);
            // the GC layout needs to be reversed since local offsets are negative with respect to EBP
            if (words > 1) {
                for (unsigned index = 0; index < words/2; index++){
                    bool temp = localsGCRef[localsGCRef_len+index];
                    localsGCRef[localsGCRef_len+index] = localsGCRef[localsGCRef_len+words-1-index];
                    localsGCRef[localsGCRef_len+words-1-index] = temp;
                }
            }
            localsGCRef_len = local_word + words;
        }
        else {
            locType = OpType(argType);
            switch (locType.enum_()) {
                default:
                    _ASSERTE(!"Bad Type");

                case typeU1:
                case typeU2:
                case typeI1:
                case typeI2:
                case typeI4:
                case typeI8:
                case typeR4:
                case typeR8:
                    break;
                case typeRef:
                    if (corArgType & CORINFO_TYPE_MOD_PINNED)
                    {
                        appendGCArray(local_word,&pinnedGC_size,&pinnedGC_len,&pinnedGC);
                    }
                    else
                    {
                        appendGCArray(local_word,&localsGCRef_size,&localsGCRef_len,&localsGCRef);
                    }
                    break;

                case typeRefAny:
                    if (local_word + 2 > interiorGC_size) {
                        interiorGC_size = growBooleans(&interiorGC, interiorGC_len, local_word+2);
                    }
                    else {
                        memset(&interiorGC[interiorGC_len], 0, local_word-interiorGC_len);
                    }
                    interiorGC_len = local_word;
                    interiorGC[interiorGC_len++] = true;
                    interiorGC[interiorGC_len++] = false;
                    break;
                case typeByRef:
                    if (corArgType & CORINFO_TYPE_MOD_PINNED)
                    {
                        appendGCArray(local_word,&pinnedInteriorGC_size,&pinnedInteriorGC_len,&pinnedInteriorGC);
                    }
                    else
                    {
                        appendGCArray(local_word,&interiorGC_size,&interiorGC_len,&interiorGC);
                    }
                    break;
            }
        }
        localsMap[local].isReg = false;
        localsMap[local].offset = localOffset(offset, size);
        localsMap[local].type = locType;

        local_word += size/sizeof(void*);
        local++;
        offset += size;
        sig = jitInfo->getArgNext(sig);
    }
    localsFrameSize = offset;
}

/* answer true if this arguement type is enregisterable on a machine chip */
bool FJitContext::enregisteredArg(CorInfoType argType) {
    //@TODO: this should be an array lookup, but wait until the types settle awhile longer
    switch (argType) {
        default:
            _ASSERTE(!"NYI");
            break;
        case CORINFO_TYPE_UNDEF:
        case CORINFO_TYPE_VOID:
            return false;
        case CORINFO_TYPE_BOOL:
        case CORINFO_TYPE_CHAR:
        case CORINFO_TYPE_BYTE:
        case CORINFO_TYPE_UBYTE:
        case CORINFO_TYPE_SHORT:
        case CORINFO_TYPE_USHORT:
        case CORINFO_TYPE_INT:
        case CORINFO_TYPE_UINT:
        case CORINFO_TYPE_STRING:
        case CORINFO_TYPE_PTR:
        case CORINFO_TYPE_BYREF:
        case CORINFO_TYPE_CLASS:
            return true;
        case CORINFO_TYPE_LONG:
        case CORINFO_TYPE_ULONG:
        case CORINFO_TYPE_FLOAT:
        case CORINFO_TYPE_DOUBLE:
        case CORINFO_TYPE_VALUECLASS:
        case CORINFO_TYPE_REFANY:
            return false;
    }
    return false;
}

/* compute the size of an argument based on machine chip */
unsigned int FJitContext::computeArgSize(CorInfoType argType, CORINFO_ARG_LIST_HANDLE argSig, CORINFO_SIG_INFO* sig) {

    //@TODO: this should be an array lookup, but wait until the types settle awhile longer
    switch (argType) {
        case CORINFO_TYPE_UNDEF:
        default:
            _ASSERTE(!"NYI")    ;
            break;
        case CORINFO_TYPE_VOID:
            return 0;
        case CORINFO_TYPE_BOOL:
        case CORINFO_TYPE_CHAR:
        case CORINFO_TYPE_BYTE:
        case CORINFO_TYPE_UBYTE:
        case CORINFO_TYPE_SHORT:
        case CORINFO_TYPE_USHORT:
        case CORINFO_TYPE_INT:
        case CORINFO_TYPE_UINT:
        case CORINFO_TYPE_FLOAT:
        case CORINFO_TYPE_STRING:
        case CORINFO_TYPE_PTR:
        case CORINFO_TYPE_BYREF:
        case CORINFO_TYPE_CLASS:
            return sizeof(void*);
        case CORINFO_TYPE_LONG:
        case CORINFO_TYPE_ULONG:
        case CORINFO_TYPE_DOUBLE:
            return 8;
        case CORINFO_TYPE_REFANY:
            return 2*sizeof(void*);
        case CORINFO_TYPE_VALUECLASS:
            CORINFO_CLASS_HANDLE cls;
            cls = jitInfo->getArgClass(sig, argSig);
            return (cls ?  typeSizeInSlots(jitInfo,cls) *sizeof(void*) : 0);
    }
    return 0;
}

/* compute the argument types and sizes based on the jitSigInfo and place them in 'map'
   return the total stack size of the arguments.  Note that although this function takes into
   calling conventions (varargs), and possible hidden params (returning valueclasses)
   only parameters visible at the IL level (declared + this ptr) are in the map.  
   Note that 'thisCls' can be zero, in which case, we assume the this pointer is a typeRef */

unsigned FJitContext::computeArgInfo(CORINFO_SIG_INFO* jitSigInfo, argInfo* map, CORINFO_CLASS_HANDLE thisCls)
{
    unsigned curReg = 0;
    unsigned totalSize = 0;
    unsigned int arg = 0;

    if (jitSigInfo->hasThis()) {
        map[arg].isReg = true;      //this is always enregistered
        map[arg].regNum = curReg++;
        if (thisCls != 0) {
            unsigned attribs = jitInfo->getClassAttribs(thisCls, methodInfo->ftn);
            if (attribs & CORINFO_FLG_VALUECLASS) {
                if (attribs & CORINFO_FLG_UNMANAGED)
                    map[arg].type = typeI;      // <this> not in the GC heap, just and int
                else 
                    map[arg].type = typeByRef;  // <this> was an unboxed value class, it really is passed byref
            }
            else
            {
                map[arg].type = typeRef;
            }
        }
        arg++;
    }

        // Do we have a hidden return value buff parameter, if so it will use up a reg  
    if (jitSigInfo->hasRetBuffArg()) {
        _ASSERTE(curReg < MAX_ENREGISTERED);
        curReg++;
    }
    
    if (jitSigInfo->isVarArg())     // only 'this' and 'retbuff', are enregistered for varargs
        curReg = MAX_ENREGISTERED;

        // because we don't know the total size, we comute the number
        // that needs to be subtracted from the total size to get the correct arg
    CORINFO_ARG_LIST_HANDLE args = jitSigInfo->args;
    for (unsigned i=0; i < jitSigInfo->numArgs; i++) {
		CORINFO_CLASS_HANDLE cls;
        CorInfoType argType = strip(jitInfo->getArgType(jitSigInfo, args, &cls));
        if(enregisteredArg(argType) && (curReg < MAX_ENREGISTERED)) {
            map[arg].isReg = true;
            map[arg].regNum = curReg++;
        }
        else {
            map[arg].isReg = false;
            map[arg].size = computeArgSize(argType, args, jitSigInfo);
            totalSize += map[arg].size;
        }
        if (argType == CORINFO_TYPE_VALUECLASS)
            map[arg].type = OpType(cls);
        else
        {
            map[arg].type = OpType(argType);
        }
        arg++;
        args = jitInfo->getArgNext(args);
    }

        // Hidden type parameter is passed last
    if (jitSigInfo->hasTypeArg()) {
        if(curReg < MAX_ENREGISTERED) {
            map[arg].isReg = true;
            map[arg].regNum = curReg++;
        }
        else {
            map[arg].isReg = false;
            map[arg].size = sizeof(void*);
            totalSize += map[arg].size;
        }
    }

    return(totalSize);
}

/* compute the offset of the start of the local relative to the frame pointer */
int FJitContext::localOffset(unsigned base, unsigned size) {
#ifdef _X86_  //stack grows down
    /* on x86 we need to bias by the size of the element since he stack grows down */
    return - (int) (base + size) + prolog_bias;
#else   //stack grows up
    _ASSERTE(!"NYI");
    return base + prolog_bias;
#endif
}

/* grow a bool[] array by allocating a new one and copying the old values into it, return the size of the new array */
unsigned FJitContext::growBooleans(bool** bools, unsigned bools_len, unsigned new_bools_size) {
    bool* temp = *bools;
    unsigned allocated_size = new_bools_size+16;    //+16 to cut down on growing
    New(*bools, bool[allocated_size]);
    if (bools_len) memcpy(*bools, temp, bools_len*sizeof(bool));
    if (temp) delete [] temp;
    memset(*bools + bools_len, 0, (allocated_size-bools_len)*sizeof(bool));
    return allocated_size;
}

/* grow an unsigned char[] array by allocating a new one and copying the old values into it, return the size of the new array */
unsigned FJitContext::growBuffer(unsigned char** chars, unsigned chars_len, unsigned new_chars_size) {
    unsigned char* temp = *chars;
    unsigned allocated_size = new_chars_size*3/2 + 16;  //*3/2 +16 to cut down on growing
    New(*chars, unsigned char[allocated_size]);
    if (chars_len) memcpy(*chars, temp, chars_len);
    if (temp) delete [] temp;
#ifdef _DEBUG
    memset(&((*chars)[chars_len]), 0xEE, (allocated_size-chars_len));
#endif
    return allocated_size;
}

#ifdef _DEBUG
void FJitContext::displayGCMapInfo()
{
    char* typeName[] = {
    "typeError",
    "typeByRef",
    "typeRef",
    "typeU1",
    "typeU2",
    "typeI1",
    "typeI2",
    "typeI4",
    "typeI8",
    "typeR4",
    "typeR8"
    "typeRefAny",
    };

    LOGMSG((jitInfo, LL_INFO1000, "********* GC map info *******\n"));
    LOGMSG((jitInfo, LL_INFO1000, "Locals: (Length = %#x, Frame size = %#x)\n",methodInfo->locals.numArgs,localsFrameSize));
    for (unsigned int i=0; i< methodInfo->locals.numArgs; i++) {
        if (!localsMap[i].type.isPrimitive())
            LOGMSG((jitInfo, LL_INFO1000, "    local %d: offset: -%#x type: %#x\n", i, -localsMap[i].offset, localsMap[i].type.cls()));
        else
            LOGMSG((jitInfo, LL_INFO1000, "    local %d: offset: -%#x type: %s\n",i, -localsMap[i].offset, typeName[localsMap[i].type.enum_()]));
    }
    LOGMSG((jitInfo, LL_INFO1000, "Bitvectors printed low bit (low local), first\n"));
    LOGMSG((jitInfo, LL_INFO1000, "LocalsGCRef bit vector len=%d bits: ",localsGCRef_len));
    unsigned numbytes = (localsGCRef_len+7)/8;
    unsigned byteNumber = 1;
    while (true)
    {
        char* buf = (char*) &(localsGCRef[byteNumber-1]);
        unsigned char bits = *buf;
        for (i=1; i <= 8; i++) {
            if ((byteNumber-1)*8+i > localsGCRef_len)
                break;
            LOGMSG((jitInfo, LL_INFO1000, "%1d ", (int) (bits & 1)));
            bits = bits >> 1;
        }
        if ((byteNumber++ * 8) > localsGCRef_len)
            break;

    } // while (true)
    LOGMSG((jitInfo, LL_INFO1000, "\n"));

    LOGMSG((jitInfo, LL_INFO1000, "interiorGC bitvector len=%d bits: ",interiorGC_len));
    numbytes = (interiorGC_len+7)/8;
    byteNumber = 1;
    while (true)
    {
        char* buf = (char*) &(interiorGC[byteNumber-1]);
        unsigned char bits = *buf;
        for (i=1; i <= 8; i++) {
            if ((byteNumber-1)*8+i > interiorGC_len)
                break;
            LOGMSG((jitInfo, LL_INFO1000, "%1d ", (int) (bits & 1)));
            bits = bits >> 1;
        }
        if ((byteNumber++ * 8) > interiorGC_len)
            break;

    } // while (true)
    LOGMSG((jitInfo, LL_INFO1000, "\n"));

    LOGMSG((jitInfo, LL_INFO1000, "Pinned LocalsGCRef bit vector: len=%d bits: ",pinnedGC_len));
    numbytes = (pinnedGC_len+7)/8;
    byteNumber = 1;
    while (true)
    {
        char* buf = (char*) &(pinnedGC[byteNumber-1]);
        unsigned char bits = *buf;
        for (i=1; i <= 8; i++) {
            if ((byteNumber-1)*8+i > pinnedGC_len)
                break;
            LOGMSG((jitInfo, LL_INFO1000, "%1d ", (int) (bits & 1)));
            bits = bits >> 1;
        }
        if ((byteNumber++ * 8) > pinnedGC_len)
            break;

    } // while (true)
    LOGMSG((jitInfo, LL_INFO1000, "\n"));

    LOGMSG((jitInfo, LL_INFO1000, "Pinned interiorGC bit vector len =%d bits: ",pinnedInteriorGC_len));
    numbytes = (pinnedInteriorGC_len+7)/8;
    byteNumber = 1;
    while (true)
    {
        char* buf = (char*) &(pinnedInteriorGC[byteNumber-1]);
        unsigned char bits = *buf;
        for (i=1; i <= 8; i++) {
            if ((byteNumber-1)*8+i > pinnedInteriorGC_len)
                break;
            LOGMSG((jitInfo, LL_INFO1000, "%1d ", (int) (bits & 1)));
            bits = bits >> 1;
        }
        if ((byteNumber++ * 8) > pinnedInteriorGC_len)
            break;

    } // while (true)
    LOGMSG((jitInfo, LL_INFO1000, "\n"));


    LOGMSG((jitInfo, LL_INFO1000, "Args: (Length = %#x, Frame size = %#x)\n",args_len,argsFrameSize));
    for (i=0; i< args_len; i++) 
    {
        if (argsMap[i].type.isPrimitive())
        {
            LOGMSG((jitInfo, LL_INFO1000, "    offset: -%#x type: %s\n",-argsMap[i].offset, typeName[argsMap[i].type.enum_()]));
        }
        else
        {
            LOGMSG((jitInfo, LL_INFO1000, "    offset: -%#x type: valueclass\n",-argsMap[i].offset));
        }
    }

    stacks.PrintStacks(mapping);
}

void StackEncoder::PrintStack(const char* name, unsigned char *& inPtr) {

    int stackLen = FJit_Encode::decode(&inPtr);
    LOGMSG((jitInfo, LL_INFO1000, "        %s len=%d bits:", name, stackLen));
    while(stackLen > 0) {
        --stackLen;
        LOGMSG((jitInfo, LL_INFO1000, "  "));
        unsigned bits = *inPtr++;
        for (unsigned bitPos = 0; bitPos < 8; bitPos++) {
            LOGMSG((jitInfo, LL_INFO1000, "%d ", bits & 1));
            bits >>= 1;

            if (stackLen == 0 && bits == 0)
                break;
        }
        
    }
    LOGMSG((jitInfo, LL_INFO1000, "\n"));
}

void StackEncoder::PrintStacks(FJit_Encode* mapping)
{
    LOGMSG((jitInfo, LL_INFO1000, "Labelled Stacks\n"));
    LOGMSG((jitInfo, LL_INFO1000, "Lowest bit (first thing pushed on opcode stack) printed first\n"));
    for (unsigned i=0; i< labeled_len; i++) {
        unsigned int stackIndex = labeled[i].stackToken;
        unsigned char * inPtr = &(stacks[stackIndex]);
        unsigned ILOffset = mapping->ilFromPC(labeled[i].pcOffset,NULL);
        LOGMSG((jitInfo, LL_INFO1000, "    IL=%#x, Native=%#x\n", ILOffset,labeled[i].pcOffset));

        PrintStack("OBJREF", inPtr);
        PrintStack("BYREF ", inPtr);
    }
}
#endif // _DEBUG

/* compress the gc info into gcHdrInfo and answer the size in bytes */
unsigned int FJitContext::compressGCHdrInfo(){
    stacks.compress(&gcHdrInfo, &gcHdrInfo_len, &gcHdrInfo_size);
    return gcHdrInfo_len;
}

LabelTable::LabelTable() {
    stacks_size = 0;
    stacks = NULL;
    stacks_len = 0;
    labels_size = 0;
    labels = NULL;
    labels_len = 0;
}

LabelTable::~LabelTable() {
    if (stacks) delete [] stacks;
    stacks = NULL;
    stacks_size = 0;
    stacks_len = 0;
    if (labels) delete [] labels;
    labels = NULL;
    labels_size = 0;
    labels_len = 0;
}

void LabelTable::reset() {
    if (stacks_len) {
#ifdef _DEBUG
        memset(stacks, 0xFF, stacks_len);
#endif
        stacks_len = 0;
    }
    if (labels_len) {
#ifdef _DEBUG
        memset(labels, 0xFF, labels_len*sizeof(label_table));
#endif
        labels_len = 0;
    }
    //add a stack of size zero at the beginning, since this is the most common stack at a label
    if (!stacks) {
        New(stacks, unsigned char[1]);
    }
    *stacks = 0;
    stacks_len = 1;
}

/* add a label with a stack signature
   note, the label_table must be kept sorted by ilOffset
   */
void LabelTable::add(unsigned int ilOffset, OpType* op_stack, unsigned int op_stack_len) {

    /* make sure there is room for the label */
    if (labels_len >= labels_size ) {
        growLabels();
    }

    /* get the probable insertion point */
    unsigned int insert = searchFor(ilOffset);

    /* at this point we either are pointing at the insertion point or this label is already here */
    if ((insert < labels_len) && (labels[insert].ilOffset == ilOffset)) {
        // label is here already,
#ifdef _DEBUG
        //lets compare the stacks
        unsigned char* inPtr = &stacks[labels[insert].stackToken];
        unsigned int num = FJit_Encode::decode(&inPtr);
        _ASSERTE(num == op_stack_len);
        OpType type;
        while (num--) {
            type.fromInt(FJit_Encode::decode(&inPtr));
                // FIX this assert may be too strong
            _ASSERTE(*op_stack == type || (type.isPtr() && (*op_stack).isPtr()));
            op_stack++;
        }
#endif
        return;
    }

    /* make the insertion */
    memmove(&labels[insert+1], &labels[insert], (labels_len-insert)*sizeof(label_table));
    labels[insert].ilOffset = ilOffset;
    labels[insert].stackToken = compress(op_stack,op_stack_len);
    labels_len++;

}

/* find a label token from an il offset, returns LABEL_NOT_FOUND if missing */
unsigned int LabelTable::findLabel(unsigned int ilOffset) {
    /* get the probable index by search as if inserting */
    unsigned int result = searchFor(ilOffset);

    /* at this point we either are pointing at the label or we are pointing at the insertion point */
    if ((result >= labels_len) || (labels[result].ilOffset != ilOffset)) {
        return LABEL_NOT_FOUND;
    }

    return result;
}

/* set operand stack from a label token, return the size of the stack, # of operands */
unsigned int LabelTable::setStackFromLabel(unsigned int labelToken, OpType* op_stack, unsigned int op_stack_size) {
    unsigned int result;
    unsigned char* inPtr = &stacks[labels[labelToken].stackToken];  //location of the compressed stack of the label

    /* get the number of operands and make sure there is room */
    unsigned int num = FJit_Encode::decode(&inPtr);
    _ASSERTE(num <= op_stack_size);
    result = num;

    /* expand the stack back out */
    while (num--) {
        op_stack->fromInt(FJit_Encode::decode(&inPtr));
        op_stack++;
    }

    return result;
}

/* write an op stack into the stacks buffer, return the offset into the buffer where written */
unsigned int LabelTable::compress(OpType* op_stack, unsigned int op_stack_len) {

    /* check for empty stack, we have put one at the front of the stacks buffer */
    if (!op_stack_len) return 0;

    /* make sure there is enough room, note this may realloc the stacks buffer
       it is okay to overestimate the space required, but never underestimate */
    unsigned int size = stacks_len + op_stack_len * sizeof(OpType) + 2; //+2 is for op_stack_len
    if (size >= stacks_size) {
        growStacks(size);
    }

    /* we always place the new stack on the end of the buffer*/
    unsigned int result = stacks_len;
    unsigned char* outPtr = (unsigned char* ) &stacks[result];

    /* write the operands */
    FJit_Encode::encode(op_stack_len, &outPtr);
    while (op_stack_len--) {
        FJit_Encode::encode(op_stack->toInt(), &outPtr);
        op_stack++;
    }

    /* compute the new length of the buffer */
    stacks_len = (unsigned)(outPtr - stacks);

    return result;
}

/* find the offset at which the label exists or should be inserted */
unsigned int LabelTable::searchFor(unsigned int ilOffset) {
    //binary search of table
    signed low, mid, high;
    low = 0;
    high = labels_len-1;
    while (low <= high) {
        mid = (low+high)/2;
        if ( labels[mid].ilOffset == ilOffset) {
            return mid;
        }
        if ( labels[mid].ilOffset < ilOffset ) {
            low = mid+1;
        }
        else {
            high = mid-1;
        }
    }
    return low;
}

/* grow the stacks buffer */
void LabelTable::growStacks(unsigned int new_size) {
    unsigned char* temp = stacks;
    unsigned allocated_size = new_size*2;   //*2 to cut down on growing
    New(stacks, unsigned char[allocated_size]);
    if (stacks_len) memcpy(stacks, temp, stacks_len);
    if (temp) delete [] temp;
    stacks_size = allocated_size;
#ifdef _DEBUG
    memset(&stacks[stacks_len], 0xEE, stacks_size-stacks_len);
#endif
}

/* grow the labels array */
void LabelTable::growLabels() {
    label_table* temp = labels;
    unsigned allocated_size = labels_size*2+20; //*2 to cut down on growing
    New(labels, label_table[allocated_size]);

    if (labels_len) memcpy(labels, temp, labels_len*sizeof(label_table));
    if (temp) delete [] temp;
#ifdef _DEBUG
    memset(&labels[labels_len], 0xEE, (labels_size-labels_len)*sizeof(label_table));
#endif
    labels_size = allocated_size;
}


StackEncoder::StackEncoder() {
    last_stack = NULL;
    last_stack_size = 0;
    last_stack_len = 0;
    stacks = NULL;
    stacks_size = 0;
    stacks_len = 0;
    gcRefs = NULL;
    gcRefs_size = 0;
    gcRefs_len = 0;
    interiorRefs = NULL;
    interiorRefs_size = 0;
    interiorRefs_len = 0;
    labeled = NULL;
    labeled_size = 0;
    labeled_len = 0;
}

StackEncoder::~StackEncoder() {
    if (last_stack) delete [] last_stack;
    last_stack = NULL;
    last_stack_size = 0;
    last_stack_len = 0;
    if (stacks) delete [] stacks;
    stacks = NULL;
    stacks_size = 0;
    if (gcRefs) delete [] gcRefs;
    gcRefs = NULL;
    gcRefs_size = 0;
    if (interiorRefs) delete [] interiorRefs;
    interiorRefs = NULL;
    interiorRefs_size = 0;
    if (labeled) delete [] labeled;
    labeled = NULL;
    labeled_size = 0;
}

/* reset so we can be reused */
void StackEncoder::reset() {
    jitInfo = NULL;
#ifdef _DEBUG
    if (last_stack_len) {
        memset(last_stack, 0xFF, last_stack_len*sizeof(OpType));
        last_stack_len = 0;
    }
    if (stacks_len) {
        memset(stacks, 0xFF, stacks_len);
        stacks_len = 0;
    }
    if (gcRefs_len) {
        memset(gcRefs, 0xFF, gcRefs_len);
        gcRefs_len = 0;
    }
    if (interiorRefs_len) {
        memset(interiorRefs, 0xFF, interiorRefs_len);
        interiorRefs_len = 0;
    }
    if (labeled_len) {
        memset(labeled, 0xFF, labeled_len*sizeof(labeled_stacks));
        labeled_len = 0;
    }
#else
    last_stack_len = 0;
    stacks_len = 0;
    gcRefs_len = 0;
    interiorRefs_len = 0;
    labeled_len = 0;
#endif
    //put an empty stack at the front of stacks
    if (stacks_size < 2) {
        if (stacks) delete [] stacks;
        stacks_size = 2;
        New(stacks,unsigned char[stacks_size]);
    }
    stacks[stacks_len++] = 0;
    stacks[stacks_len++] = 0;
    //put an empty labeled stack at pcOffset 0
    if (!labeled_size) {
        labeled_size = 1;
        if ((labeled = (labeled_stacks*) new unsigned char[labeled_size*sizeof(labeled_stacks)]) == NULL)
            RaiseException(SEH_NO_MEMORY,EXCEPTION_NONCONTINUABLE,0,NULL);
    }
    labeled[labeled_len].pcOffset = 0;
    labeled[labeled_len++].stackToken = 0;
}

/* append the stack state at pcOffset to the end */
void StackEncoder::append(unsigned pcOffset, OpType* op_stack, unsigned int op_stack_len) {

    /*check it is the same as the last stack */
    unsigned int num = op_stack_len;
    bool same = (last_stack_len == num);
    while (same && num--)
        same = same && (last_stack[num] == op_stack[num]);
    if (same) return;

    /* @TODO : set last_stack to current stack */
    last_stack_len = op_stack_len;
    if (last_stack_len > last_stack_size) {
        last_stack_size = FJitContext::growBuffer((unsigned char**)&last_stack,0, last_stack_len*sizeof(OpType));
        last_stack_size /= sizeof(OpType);
    }
    for (num = 0; num < op_stack_len; num++)
    {
        last_stack[num] = op_stack[num];
    }

    /* make sure we have space for a new labeled stack */
    if (labeled_len >= labeled_size) {
        labeled_size = FJitContext::growBuffer((unsigned char**)&labeled, labeled_len*sizeof(labeled_stacks), (labeled_len+1)*sizeof(labeled_stacks));
        labeled_size = labeled_size / sizeof(labeled_stacks);
    }

    /* encode the stack and add to labeled stacks */
    unsigned int stackToken = encodeStack(op_stack, op_stack_len);
    labeled[labeled_len].pcOffset = pcOffset;
    labeled[labeled_len++].stackToken = stackToken;
}

/* compress the labeled stacks into the buffer in gcHdrInfo format */
void StackEncoder::compress(unsigned char** buffer, unsigned int* buffer_len, unsigned int* buffer_size) {
    unsigned size;
    unsigned compressed_size;

    /* compress labeled onto itself,
       this words since the compressed form of an entry is smaller than the orig entry
       */
    unsigned char* outPtr = (unsigned char*) labeled;
    labeled_stacks entry;
    for (unsigned i = 0; i < labeled_len; i++) {
        _ASSERTE((unsigned) outPtr <= (unsigned)&labeled[i]);
        entry = labeled[i];
        FJit_Encode::encode(entry.pcOffset, &outPtr);
        FJit_Encode::encode(entry.stackToken, &outPtr);

    }
    compressed_size = ((unsigned)outPtr) - ((unsigned)labeled);
#ifdef _DEBUG
    memset(outPtr, 0xEE, labeled_len*sizeof(labeled_stacks) - compressed_size);
#endif

    /* compute size in bytes of encode form of compressed labeled and make room for it */
    size = compressed_size + FJit_Encode::encodedSize(labeled_len);

    if ((*buffer_len) + size +4 > (*buffer_size)) { // 4 bytes = overestimation of encodedSize(size)
        (*buffer_size) = FJitContext::growBuffer(buffer, *buffer_len, (*buffer_len)+size);
    }
    //move the compressed labeled stacks into buffer
    outPtr = &(*buffer)[*buffer_len];
    (*buffer_len) += FJit_Encode::encode(size, &outPtr);            //#bytes
    (*buffer_len) += FJit_Encode::encode(labeled_len, &outPtr);     //#labeled stacks
    memcpy(outPtr, labeled, compressed_size);                       //compressed labeled bytes
    (*buffer_len) += compressed_size;

    /* compute size needed for the compressed stacks and make room */
    size = stacks_len + FJit_Encode::encodedSize(stacks_len);
    if ((*buffer_len) + size > (*buffer_size)) {
        *buffer_size = FJitContext::growBuffer(buffer, *buffer_len, (*buffer_len)+size);
    }
    outPtr = &(*buffer)[*buffer_len];
    //move the encoded stacks into the buffer
    (*buffer_len) += FJit_Encode::encode(stacks_len, &outPtr);  //#bytes
    memcpy(outPtr, stacks, stacks_len);                         //compressed stacks bytes
    (*buffer_len) += stacks_len;
#ifdef _DEBUG
    outPtr = &(*buffer)[*buffer_len];
#endif
    _ASSERTE((unsigned)outPtr <= (unsigned)&(*buffer)[*buffer_size]);
}

/* encode the stack into the stacks buffer, return the index where it was placed */
unsigned int StackEncoder::encodeStack(OpType* op_stack, unsigned int op_stack_len) {

    if (!op_stack_len) return 0;    //empty stack encodings is at front of stacks

    /* compute the gcRefs and interiorRefs boolean arrays for the stack */
    gcRefs_len = 0;
    interiorRefs_len = 0;
    unsigned int op_word = 0;       //logical operand word we are looking at

    for (unsigned int op = 0; op < op_stack_len; op++) {
        if (!op_stack[op].isPrimitive()) {
            unsigned int words = typeSizeInSlots(jitInfo, op_stack[op].cls());       //#of void* sized words in op
            if (op_word + words > gcRefs_size) {
                gcRefs_size = FJitContext::growBooleans(&gcRefs, gcRefs_len, op_word + words);
            }
            else {
                memset(&gcRefs[gcRefs_len], 0, op_word-gcRefs_len);
            }
            gcRefs_len = op_word;
            jitInfo->getClassGClayout(op_stack[op].cls(), (BYTE*)&gcRefs[gcRefs_len]);
            if (words > 1) {
                for (unsigned index = 0; index < words/2; index++){
                    bool temp = gcRefs[gcRefs_len+index];
                    gcRefs[gcRefs_len+index] = gcRefs[gcRefs_len+words-1-index];
                    gcRefs[gcRefs_len+words-1-index] = temp;
                }
            }
            op_word += words;
            gcRefs_len = op_word;
        }
        else {
            switch (op_stack[op].enum_()) {
                default:
                    _ASSERTE(!"Void or Undef as a operand is not allowed");
                    break;
                case typeI4:
                case typeR4:
                    op_word++;
                    break;
                case typeI8:
                case typeR8:
                    op_word += (8 / sizeof(void*));
                    break;
                case typeRef:
                    op_word;
                    if (op_word+1 > gcRefs_size) {
                        gcRefs_size = FJitContext::growBooleans(&gcRefs, gcRefs_len, op_word+1);
                    }
                    else {
                        memset(&gcRefs[gcRefs_len], 0, op_word-gcRefs_len);
                    }
                    gcRefs_len = op_word;
                    gcRefs[gcRefs_len++] = true;
                    op_word++;
                    break;
                case typeRefAny:
                    if (op_word + 2 > interiorRefs_size) {
                        interiorRefs_size = FJitContext::growBooleans(&interiorRefs, interiorRefs_len, op_word+2);
                    }
                    else {
                        memset(&interiorRefs[interiorRefs_len], 0, op_word-interiorRefs_len);
                    }
                    interiorRefs_len = op_word;
                    interiorRefs[interiorRefs_len++] = true;
                    interiorRefs[interiorRefs_len++] = false;
                    op_word += 2;
                    break;
                case typeByRef:
                    if (op_word + 1 > interiorRefs_size) {
                        interiorRefs_size = FJitContext::growBooleans(&interiorRefs, interiorRefs_len, op_word+1);
                    }
                    else {
                        memset(&interiorRefs[interiorRefs_len], 0, op_word-interiorRefs_len);
                    }
                    interiorRefs_len = op_word;
                    interiorRefs[interiorRefs_len++] = true;
                    op_word++;
                    break;
            }
        }
    }

    /* encode the op stack gc refs and interior refs into the stacks buffer */
    //@TODO: this is not a great compression, it should be improved
    unsigned int result = stacks_len;       //where we are putting it, and what we return
    unsigned char* outPtr;
    //make sure there is space
    unsigned int size = (gcRefs_len + 7 + interiorRefs_len + 7) / 8 + 4;    //overestimate is okay, underestimate is disaster
    if (stacks_len+size > stacks_size) {
        stacks_size = FJitContext::growBuffer(&stacks, stacks_len, stacks_len+size);
    }
    //drop the pieces in
    size = FJit_Encode::compressBooleans(gcRefs, gcRefs_len);
    outPtr = &stacks[stacks_len];
    stacks_len += FJit_Encode::encode(size, &outPtr);
    memcpy(outPtr, gcRefs, size);
    stacks_len += size;
    size = FJit_Encode::compressBooleans(interiorRefs, interiorRefs_len);
    outPtr = &stacks[stacks_len];
    stacks_len += FJit_Encode::encode(size, &outPtr);
    memcpy(outPtr, interiorRefs, size);
    stacks_len += size;
    _ASSERTE(stacks_len <= stacks_size);

    return result;
}


//
// reportDebuggingData is called to pass IL to native mappings and IL
// variable to native variable mappings to the Runtime. This
// information is then passed to the debugger and used to debug the
// jitted code.
//
// NOTE: we currently assume the following:
//
// 1) the FJIT maintains a full mapping of every IL offset to the
// native code associated with each IL instruction. Thus, its not
// necessary to query the Debugger for specific IL offsets to track.
//
// 2) the FJIT keeps all arguments and variables in a single home over
// the life of a method. This means that we don't have to query the
// Debugger for specific variable lifetimes to track.
//
void FJit::reportDebuggingData(FJitContext *fjitData, CORINFO_SIG_INFO* sigInfo)
{
    // Figure out the start and end offsets of the body of the method
    // (exclude prolog and epilog.)
    unsigned int bodyStart = fjitData->mapInfo.prologSize;
    unsigned int bodyEnd = (unsigned int)(fjitData->mapInfo.methodSize -
        fjitData->mapInfo.epilogSize);

    // Report the IL->native offset mapping first.
    fjitData->mapping->reportDebuggingData(fjitData->jitInfo,
                                           fjitData->methodInfo->ftn,
                                           bodyStart,
                                           bodyEnd);


    // Next report any arguments and locals.
    unsigned int varCount = fjitData->args_len +
        fjitData->methodInfo->locals.numArgs;

    if (sigInfo->isVarArg())
        varCount += 2;     // for the vararg cookie and (possibly) this ptr

    unsigned int varIndex = 0;
    unsigned int varNumber = 0;

    if (varCount > 0)
    {
        // Use the allocate method provided by the debugging interface...
        ICorDebugInfo::NativeVarInfo *varMapping =
            (ICorDebugInfo::NativeVarInfo*) fjitData->jitInfo->allocateArray(
                                            varCount * sizeof(varMapping[0]));

#ifdef _X86_
        unsigned int i;
        // Args always come first, slots 0..n
        if (sigInfo->isVarArg())
        {
            unsigned argIndex = 0;
            //  this ptr is first
            if (sigInfo->hasThis()) 
            {
                varMapping[varIndex].loc.vlType = ICorDebugInfo::VLT_STK;
                varMapping[varIndex].loc.vlStk.vlsBaseReg = ICorDebugInfo::REGNUM_EBP;
                varMapping[varIndex].loc.vlStk.vlsOffset = fjitData->argsMap[argIndex].offset;
                varMapping[varIndex].startOffset = bodyStart;
                varMapping[varIndex].endOffset = bodyEnd;
                varMapping[varIndex].varNumber = varNumber;
                varIndex++;
                varNumber++;
                argIndex++;
            }
            // next report varArg cookie
            varMapping[varIndex].loc.vlType = ICorDebugInfo::VLT_STK;
            varMapping[varIndex].loc.vlStk.vlsBaseReg = ICorDebugInfo::REGNUM_EBP;
            varMapping[varIndex].loc.vlStk.vlsOffset = sizeof(prolog_frame);
            varMapping[varIndex].startOffset = bodyStart;
            varMapping[varIndex].endOffset = bodyEnd;
            varMapping[varIndex].varNumber = ICorDebugInfo::VARARGS_HANDLE;
            varIndex++;
            // varNumber NOT incremented

            // next report all fixed varargs with offsets relative to base of fixed args
            for ( ; argIndex < fjitData->args_len ; varIndex++, argIndex++,varNumber++)
            {
                varMapping[varIndex].startOffset = bodyStart;
                varMapping[varIndex].endOffset = bodyEnd;
                varMapping[varIndex].varNumber = varNumber;

                varMapping[varIndex].loc.vlType = ICorDebugInfo::VLT_FIXED_VA;
                varMapping[varIndex].loc.vlFixedVarArg.vlfvOffset = 
                                        - fjitData->argsMap[argIndex].offset;
            }

        }
        else
        {
            for (i = 0; i < fjitData->args_len; i++, varIndex++, varNumber++)
            {
                // We track arguments across the entire method, including
                // the prolog and epilog.
                varMapping[varIndex].startOffset = bodyStart;
                varMapping[varIndex].endOffset = bodyEnd;
                varMapping[varIndex].varNumber = varNumber;

                varMapping[varIndex].loc.vlType = ICorDebugInfo::VLT_STK;
                varMapping[varIndex].loc.vlStk.vlsBaseReg = ICorDebugInfo::REGNUM_EBP;
                varMapping[varIndex].loc.vlStk.vlsOffset = fjitData->argsMap[i].offset;
            }
        }
        // Locals next, slots n+1..m
        for (i = 0; i < fjitData->methodInfo->locals.numArgs; i++, varIndex++, varNumber++)
        {
            // Only track locals over the body of the method (i.e., no
            // prolog or epilog.)
            varMapping[varIndex].startOffset = bodyStart;
            varMapping[varIndex].endOffset = bodyEnd;
            varMapping[varIndex].varNumber = varNumber;

            // Locals are all EBP relative.
            varMapping[varIndex].loc.vlType = ICorDebugInfo::VLT_STK;
            varMapping[varIndex].loc.vlStk.vlsBaseReg = ICorDebugInfo::REGNUM_EBP;
            varMapping[varIndex].loc.vlStk.vlsOffset = fjitData->localsMap[i].offset;
        }
#else
        _ASSERTE(!"Port me!");
#endif // _X86_

        // Pass the array to the debugger...
        fjitData->jitInfo->setVars(fjitData->methodInfo->ftn,
                                   varCount, varMapping);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\fjitencode.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "jitpch.h"
#pragma hdrstop

/*****************************************************************************/

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            FJitEncode.cpp                                   XX
XX                                                                           XX
XX   Encodes and decodes the il to pc map.  In uncompressed form, the map    XX
XX   is a sorted list of il/pc offset pairs where the il and the pc offset   XX
XX   indicate the start of an opcode.  In compressed form, the pairs are     XX
XX   delta encoded from the prior pair                                       XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

//@TODO: for now we are doing no fancy compression of the delta encoding 
//just to keep things simple.  Later this should use a 6bit delta for the pair of the
//form:  3bits of pc delta, 2 bits of il delta, 1 bit more bits follow.

//Note; The compression is done inplace 

#include "FJitEncode.h"
#define SEH_NO_MEMORY		 0xC0000017

#define New(var, exp) \
	if ((var = new exp) == NULL) \
	    RaiseException(SEH_NO_MEMORY,EXCEPTION_NONCONTINUABLE,0,NULL);

FJit_Encode::FJit_Encode() {
	map = NULL;
	map_len = map_capacity = 0;
	compressed = false;
}

FJit_Encode::~FJit_Encode() {
	if (map) delete [] map;
	map = NULL;
	map_capacity = 0;
}

void FJit_Encode::reset() {
	map_len = 0;
    _ASSERTE(!compressed);
}
/*adjust the internal mem structs as needed for the size of the method being jitted*/
void FJit_Encode::ensureMapSpace(unsigned int len) {
	//note, we set the map capcity to be at least one greater #opcodes to allow for an 
	//end of method entry
	unsigned needed;
	needed = len + 1;  //since we are using reference il codes
	if (needed >= map_capacity) {
		if (map) delete [] map;
        New(map,Fjit_il2pcMap[needed]);
		map_capacity = needed;
	}
#ifdef _DEBUG
	memset(map, 0, needed * sizeof(Fjit_il2pcMap));
#endif
	map_len = 0;
	compressed = false;
}

/* add a new pair to the end of the map.  Note pairs must be added in ascending order */
void FJit_Encode::add(unsigned ilOffset, unsigned pcOffset) {
	_ASSERTE(!compressed);
	_ASSERTE(ilOffset < map_capacity);
	for (unsigned i = map_len; i< ilOffset; i++)
        map[i] = map[map_len];
	map[ilOffset] = pcOffset;
	map_len = ilOffset;
}

/* map an il offset to a pc offset, 
   if il offset is in middle of op code, 
   return pc offset of start of op code
*/
unsigned FJit_Encode::pcFromIL(unsigned ilOffset) {
	map_len = decompress();
	//binary search of table, note the table can never be empty
	//and first il offset must be zero

    _ASSERTE(ilOffset <= map_len);
    return map[ilOffset];
}

/*map a pc offset to an il offset and a pc offset within the opcode, 
  returns -1 if il offset does not exist */
signed FJit_Encode::ilFromPC(unsigned pcOffset, unsigned* pcInILOffset) {
	map_len = decompress();
	//binary search of table
	signed low, mid, high;
	low = 0;
	high = map_len-1;
	while (low <= high) {
		mid = (low+high)/2;
		if ( map[mid] == pcOffset) {
            while (mid && map[mid-1] == map[mid]) mid--;
			if (pcInILOffset) *pcInILOffset = 0;
			return mid; 
		}
		if ( map[mid] < pcOffset ) {
			low = mid+1;
		}
		else {
			high = mid-1;
		}
	}
	if (high < 0) {
		//not in table
		if (pcInILOffset) {
			*pcInILOffset = pcOffset;
		}
		return -1;
	}

    while (high && map[high-1] == map[high]) high--;
	if (pcInILOffset) {
		*pcInILOffset = pcOffset - map[high];
	}
	return high; 
}

/* return the size of the compressed stream in bytes. */
unsigned FJit_Encode::compressedSize() {
	unsigned ilOffset = 0;
	unsigned pcDelta;
	unsigned pcOffset = 0;
	unsigned current = 0;
	unsigned char* bytes = (unsigned char*) map;

	if (compressed) {
		return map_len;
	};

	// lift out the first entry so we don't overwrite it with the length
	pcDelta = map[current] - pcOffset;

	if (map_len) {
		encode(map_len, &bytes);
	}

	//since we are compressing in place, we need to be careful to not overwrite ourselves
	while (current < map_len ) {
		current++;
		encode(pcDelta, &bytes);
		_ASSERTE((unsigned) bytes <= (unsigned) &map[current]);
		pcOffset += pcDelta;
		pcDelta = map[current] - pcOffset;
	}
    encode(pcDelta,&bytes);
	_ASSERTE((unsigned) bytes <= (unsigned) &map[current]);
	compressed = true;
	map_len = (unsigned)(bytes - (unsigned char*) map);
	return map_len;
}

/* compress the map into the supplied buffer.  Return true if successful */
bool FJit_Encode::compress(unsigned char* buffer, unsigned buffer_len) {
	if (!compressed) {
		map_len = compressedSize();
	}
	if (map_len > buffer_len) {
		return false;
	}
	memcpy(buffer, map, map_len);
	return true;
}

/* decompress the internals if necessary. Answer the number of entries in the map */
unsigned FJit_Encode::decompress(){
	if (!compressed ) return map_len;

	//since we compressed in place, allocate a new map and then decompress.
	//Note, we are assuming that a map is rarely compressed and then decompressed
	//In fact, there is no known instance of this happening

	Fjit_il2pcMap* temp_map = map;
	unsigned temp_capacity = map_capacity;
	map = NULL;
	map_len = map_capacity = 0;
	decompress((unsigned char*) temp_map);
	if(temp_map) delete [] temp_map;
	return map_len;
}


/* compress the bool* onto itself and answer the number of compressed bytes */
unsigned FJit_Encode::compressBooleans(bool* buffer, unsigned buffer_len) {
	unsigned len = 0;
	unsigned char* compressed = (unsigned char*) buffer;
	unsigned char bits;
	
	/*convert booleans to bits and pack into bytes */
	while (buffer_len >= 8) {
		bits = 0;
		for (unsigned i=0;i<8;i++) {
			bits = (bits>>1) + (*buffer++ ? 128 : 0);
		}
		*compressed++ = bits;
		len++;
		buffer_len -= 8;		
	}
	if (buffer_len) {
		bits = 0;
		unsigned zeroBits = 8;
		while (buffer_len--) {
			bits = (bits>>1) + (*buffer++ ? 128 : 0);
			zeroBits--;
		}
		*compressed++ = (bits >> zeroBits);
		len++;
	}
	return len;
}

/* answer the number of bytes it takes to encode an unsigned val */
unsigned FJit_Encode::encodedSize(unsigned val) {
	unsigned len = 0;
	do {
		len++;
	} while ((val = (val>>7)) > 0);
	return len;
}

/* decompress the bytes. Answer the number of entries in the map */
unsigned FJit_Encode::decompress(unsigned char* bytes) {
	unsigned needed;
	unsigned char* current = bytes;
	unsigned pcOffset = 0;
	needed = decode(&current)+1;
	if (map_capacity < needed) {
		if (map) delete [] map;
        // @TODO: Check for out of memory
		New(map,Fjit_il2pcMap[needed]);
		map_capacity = needed;
        map_len = needed - 1;
	}
	compressed = false;
	for (unsigned i = 0; i <= map_len; i++) {
		map[i] = pcOffset += decode(&current);
	}
	return map_len;
}

/*encode an unsigned, update the buffer ptr and return bytes written*/
unsigned FJit_Encode::encode(unsigned val, unsigned char** buffer) {
	unsigned len = 0;
	unsigned char bits;
	while (val > 0x7f) {
		bits = (val & 0x7f) | 0x80;
		val = val >> 7;
		**buffer = bits;
		(*buffer)++;
		len++;
	}
	**buffer = (unsigned char) val;
	(*buffer)++;
	return len+1;
}	

/*decode an unsigned, buffer ptr is incremented, callable from FJIT_EETwain */
unsigned FJit_Encode::decode_unsigned(unsigned char** buffer) {
	return decode(buffer);
}

/*decode an unsigned, buffer ptr is incremented */
unsigned FJit_Encode::decode(unsigned char** buffer) {
	unsigned val = 0;
	unsigned char bits;
	unsigned i = 0;
	do {
		bits = **buffer; 
		val = ((bits & 0x7f) << (7*i++)) + val;
		(*buffer)++;
	} while ( bits > 0x7f );
	return val;
}

//
// reportDebuggingData is called by FJit::reportDebuggingData to tell
// the encoding to report the IL to native map to the Runtime and
// debugger.
//
void FJit_Encode::reportDebuggingData(ICorJitInfo* jitInfo, CORINFO_METHOD_HANDLE ftn,
                         UINT prologEnd, UINT epilogStart)
{
    // make sure to decompress the map. (shouldn't be compress yet anyway.)
    map_len = decompress();

    // The map should not be empty, and the first offset should be 0.
    _ASSERTE(map_len);
    
    // Create a table to pass the mappings back to the Debugger via
    // the Debugger's allocate method. Note: we're allocating a little
    // too much memory here, but its probably faster than determining
    // the number of valid IL offsets in the map.
    ICorDebugInfo::OffsetMapping *mapping = map_len > 0 ?
        (ICorDebugInfo::OffsetMapping*) jitInfo->allocateArray(
                                                        (map_len+1) *
                                                        sizeof(mapping[0])) : 
        NULL;

    if (mapping != NULL)
    {
        unsigned int lastNativeOffset = 0xFFFFFFFF;
        unsigned int j = 0;
        if (map[0] > 0)
        {
            //Assume that all instructions before the IL are part of the
            //prolog
            mapping[j].ilOffset = ICorDebugInfo::MappingTypes::PROLOG;
            mapping[j].nativeOffset = 0;
            j++;

            _ASSERTE( map[0] == prologEnd );
        }
        
        for (unsigned int i = 0; i < map_len; i++)
        {
            if (map[i] != lastNativeOffset)
            {
                mapping[j].ilOffset = i; //map[i].ilOffset;
                mapping[j].nativeOffset = map[i];
                lastNativeOffset = map[i];
                j++;
            }
        }

        //mark the last block as epilog, since it is.
        if (j > 0)
        {
            j--;
//            mapping[j].nativeOffset++; //FJIT says epilog begins on instruction
            // FOLLOWING nativeOffset, debugger assumes that it starts on
            // instruction AT nativeOffset.
//            _ASSERTE( mapping[j].nativeOffset == epilogStart);
            	
            mapping[j].ilOffset = ICorDebugInfo::MappingTypes::EPILOG;
            j++;
        }
        
        // Pass the offset array to the debugger.
        jitInfo->setBoundaries(ftn, j, mapping);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\fjit.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// -*- C++ -*-
#ifndef _FJIT_H_
#define _FJIT_H_
/*****************************************************************************/

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            FJit.h                                         XX
XX                                                                           XX
XX   The functionality needed for the FJIT DLL.                              XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

//the follwing macros allow the jit helpers to be called from c-code
#define jit_call __fastcall

void logMsg(class ICorJitInfo* info, unsigned logLevel, char* fmt, ...);
#ifdef _DEBUG
#define LOGMSG(x) logMsg x
#else
#define LOGMSG(x)	0
#endif




#include "IFJitCompiler.h"
#include "log.h" 		// for LL_INFO*



#ifdef _WIN64
#define emit_WIN64(x) x
#define emit_WIN32(x)
#else
#define emit_WIN64(x)
#define emit_WIN32(x) x
#endif

#define SEH_ACCESS_VIOLATION 0xC0000005
#define SEH_NO_MEMORY		 0xC0000017
#define SEH_JIT_REFUSED      0xE04a4954  // JIT

extern class FJit* ILJitter;        // The one and only instance of this JITer

/* the jit helpers that we call at runtime */
extern BOOL FJit_HelpersInstalled;
extern unsigned __int64 (__stdcall *FJit_pHlpLMulOvf) (unsigned __int64 val1, unsigned __int64 val2);

//extern float (jit_call *FJit_pHlpFltRem) (float divisor, float dividend);
extern double (jit_call *FJit_pHlpDblRem) (double divisor, double dividend);

extern void (jit_call *FJit_pHlpRngChkFail) (unsigned tryIndex);
extern void (jit_call *FJit_pHlpOverFlow) (unsigned tryIndex);
extern void (jit_call *FJit_pHlpInternalThrow) (CorInfoException throwEnum);
extern CORINFO_Object (jit_call *FJit_pHlpArrAddr_St) (CORINFO_Object elem, int index, CORINFO_Object array);
extern void (jit_call *FJit_pHlpInitClass) (CORINFO_CLASS_HANDLE cls);
//@BUG the following signature does not match the implementation in JitInterface
extern CORINFO_Object (jit_call *FJit_pHlpNewObj) (CORINFO_METHOD_HANDLE constructor);
extern void (jit_call *FJit_pHlpThrow) (CORINFO_Object obj);
extern void (jit_call *FJit_pHlpRethrow) ();
extern void (jit_call *FJit_pHlpPoll_GC) ();
extern void (jit_call *FJit_pHlpMonEnter) (CORINFO_Object obj);
extern void (jit_call *FJit_pHlpMonExit) (CORINFO_Object obj);
extern void (jit_call *FJit_pHlpMonEnterStatic) (CORINFO_METHOD_HANDLE method);
extern void (jit_call *FJit_pHlpMonExitStatic) (CORINFO_METHOD_HANDLE method);
extern CORINFO_Object (jit_call *FJit_pHlpChkCast) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls);
extern CORINFO_Object (jit_call *FJit_pHlpNewArr) (CorInfoType type, unsigned cElem);
extern void (jit_call *FJit_pHlpAssign_Ref_EAX)(); // *EDX = EAX, inform GC
extern BOOL (jit_call *FJit_pHlpIsInstanceOf) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls);
extern CORINFO_Object (jit_call *FJit_pHlpNewArr_1_Direct) (CORINFO_CLASS_HANDLE cls, unsigned cElem);
extern CORINFO_Object (jit_call *FJit_pHlpBox) (CORINFO_CLASS_HANDLE cls);
extern void* (jit_call *FJit_pHlpUnbox) (CORINFO_Object obj, CORINFO_CLASS_HANDLE cls);
extern void* (jit_call *FJit_pHlpGetField32) (CORINFO_Object*, CORINFO_FIELD_HANDLE);
extern __int64 (jit_call *FJit_pHlpGetField64) (CORINFO_Object*, CORINFO_FIELD_HANDLE);
extern void* (jit_call *FJit_pHlpGetField32Obj) (CORINFO_Object*, CORINFO_FIELD_HANDLE);
extern void (jit_call *FJit_pHlpSetField32) (CORINFO_Object*, CORINFO_FIELD_HANDLE , __int32);
extern void (jit_call *FJit_pHlpSetField64) (CORINFO_Object*, CORINFO_FIELD_HANDLE , __int64);
extern void (jit_call *FJit_pHlpSetField32Obj) (CORINFO_Object*, CORINFO_FIELD_HANDLE , LPVOID);
extern void* (jit_call *FJit_pHlpGetFieldAddress) (CORINFO_Object*, CORINFO_FIELD_HANDLE);

extern void (jit_call *FJit_pHlpGetRefAny) (CORINFO_CLASS_HANDLE cls, void* refany);
extern void (jit_call *FJit_pHlpEndCatch) ();
extern void (jit_call *FJit_pHlpPinvokeCalli) ();
extern void (jit_call *FJit_pHlpTailCall) ();
extern void (jit_call *FJit_pHlpWrap) ();
extern void (jit_call *FJit_pHlpUnWrap) ();
extern void (jit_call *FJit_pHlpBreak) ();
extern CORINFO_MethodPtr* (jit_call *FJit_pHlpEncResolveVirtual) (CORINFO_Object*, CORINFO_METHOD_HANDLE);


void throwFromHelper(enum CorInfoException throwEnum);

#define THROW_FROM_HELPER(exceptNum)  {          \
        throwFromHelper(exceptNum); 			\
        return;	}			/* need return so we can decode the epilog */

#define THROW_FROM_HELPER_RET(exceptNum) {       \
        throwFromHelper(exceptNum); 			\
        return 0; }			/* Need return so we can decode the epilog */


    // OpType encodes all we need to know about type on the opcode stack
enum OpTypeEnum {           // colapsing the CorInfoType into the catagories I care about
    typeError  = 0,         // this encoding is reserved for value classes
    typeByRef  = 1,
    typeRef    = 2,
    typeU1     = 3,
    typeU2     = 4,
    typeI1     = 5,
    typeI2     = 6,
    typeI4     = 7,
    typeI8     = 8,
    typeR4     = 9,
    typeR8     = 10,
    typeRefAny = 11,         // isValClass counts on this being last.  
    typeCount  = 12,
#ifdef _WIN64
    typeI      = typeI8,
#else
    typeI      = typeI4,
#endif
    };

#define RefAnyClassHandle ((CORINFO_CLASS_HANDLE) typeRefAny)

struct OpType {
    OpType() {
#ifdef _DEBUG
        u.enum_ = typeError;
#endif
        }
    OpType(OpTypeEnum opEnum) {
        u.enum_ = opEnum;
        _ASSERTE(u.enum_ < typeCount);
        }
    explicit OpType(CORINFO_CLASS_HANDLE valClassHandle) {
        u.cls = valClassHandle;
        _ASSERTE(!isPrimitive());
        }
    explicit OpType(CorInfoType jitType, CORINFO_CLASS_HANDLE valClassHandle) {
        if (jitType != CORINFO_TYPE_VALUECLASS)
            *this = OpType(jitType);
        else
            u.cls = valClassHandle;
        }

    explicit OpType(CorInfoType jitType) {
        _ASSERTE(jitType < CORINFO_TYPE_COUNT);
        static const char toOpStackType[] = {
            typeError,   //CORINFO_TYPE_UNDEF
            typeError,   //CORINFO_TYPE_VOID
            typeI1,      //CORINFO_TYPE_BOOL
            typeU2,      //CORINFO_TYPE_CHAR
            typeI1,      //CORINFO_TYPE_BYTE
            typeU1,      //CORINFO_TYPE_UBYTE
            typeI2,      //CORINFO_TYPE_SHORT
            typeU2,      //CORINFO_TYPE_USHORT
            typeI4,      //CORINFO_TYPE_INT
            typeI4,      //CORINFO_TYPE_UINT
            typeI8,      //CORINFO_TYPE_LONG
            typeI8,      //CORINFO_TYPE_ULONG
            typeR4,      //CORINFO_TYPE_FLOAT
            typeR8,      //CORINFO_TYPE_DOUBLE
            typeRef,     //CORINFO_TYPE_STRING
            typeI,       //CORINFO_TYPE_PTR
            typeByRef,   //CORINFO_TYPE_BYREF
            typeError,   //CORINFO_TYPE_VALUECLASS
            typeRef,     //CORINFO_TYPE_CLASS
            typeRefAny,  //CORINFO_TYPE_REFANY
        };
        _ASSERTE((typeI4 > typeI2) && (typeI1 > typeU1) && (typeU2 > typeU1));
        _ASSERTE(toOpStackType[CORINFO_TYPE_REFANY] == typeRefAny);  //spot check table
        _ASSERTE(toOpStackType[CORINFO_TYPE_BYREF] == typeByRef);    //spot check table
        _ASSERTE(toOpStackType[CORINFO_TYPE_LONG] == typeI8);        //spot check table
        _ASSERTE(sizeof(toOpStackType) == CORINFO_TYPE_COUNT);
        u.enum_ = (OpTypeEnum) toOpStackType[jitType];
		if (u.enum_ == typeError)
			RaiseException(SEH_JIT_REFUSED,EXCEPTION_NONCONTINUABLE,0,NULL); //_ASSERTE(u.enum_ != typeError);
    }
    int operator==(const OpType& opType) { return(u.cls == opType.u.cls); }
    int operator!=(const OpType& opType) { return(u.cls != opType.u.cls); }
	bool isPtr() { return(u.enum_ == typeRef || u.enum_ == typeByRef || u.enum_ == typeI); }
    bool isPrimitive()      { return((unsigned) u.enum_ <= (unsigned) typeRefAny); }    // refany is a primitive
    bool isValClass()       { return((unsigned) u.enum_ >= (unsigned) typeRefAny); }    // refany is a valclass too 
    OpTypeEnum     enum_()  { _ASSERTE(isPrimitive()); return (u.enum_); }
    CORINFO_CLASS_HANDLE    cls()   { _ASSERTE(isValClass()); return(u.cls); }
    unsigned toInt()        { return((unsigned) u.cls); }   // unsafe, please limit use
    void fromInt(unsigned i){ u.cls = (CORINFO_CLASS_HANDLE) i; }   // unsafe, please limit use

    void toNormalizedType() {    
        static OpTypeEnum Normalize[] = {
            typeError , // typeError,   
            typeByRef , // typeByRef,   
            typeRef, // typeRef,
            typeI4, // typeU1,      
            typeI4, // typeU2,      
            typeI4, // typeI1,      
            typeI4, // typeI2,                
        };
    if (u.enum_ < typeI4)
        u.enum_ = Normalize[u.enum_];
    }

    void toFPNormalizedType() {    
        static OpTypeEnum Normalize[] = {
            typeError , // typeError,   
            typeByRef , // typeByRef,   
            typeRef, // typeRef,
            typeI4, // typeU1,      
            typeI4, // typeU2,      
            typeI4, // typeI1,      
            typeI4, // typeI2,                
            typeI4, // typeI4,                
            typeI8, // typeI8,                
            typeR8, // typeR4,                
        };
    if (u.enum_ < typeR8)
        u.enum_ = Normalize[u.enum_];
    }

    union {                 // can make a union because cls is a pointer and ptrs > 4
        OpTypeEnum   enum_;
        CORINFO_CLASS_HANDLE cls;    // cls handle for non-built in classes
       } u;
};
struct stackItems {
    int      offset :24;    // Only used if isReg - false
    unsigned regNum : 7;    // Only need 2 bits, only used if isReg = true
    unsigned isReg  : 1;
    OpType  type;
};

    // Note that we presently rely on the fact that statkItems and
    // argInfo have the same layout
struct argInfo {
    unsigned size   :24;      // Only used if isReg - false, size of this arg in bytes
    unsigned regNum : 7;      // Only need 2 bits, only used if isReg = true
    unsigned isReg  : 1;
    OpType  type;
};




#define LABEL_NOT_FOUND (unsigned int) (0-1)

class LabelTable {
public:

    LabelTable();

    ~LabelTable();

    /* add a label at an il offset with a stack signature */
    void add(unsigned int ilOffset, OpType* op_stack, unsigned int op_stack_len);

    /* find a label token from an il offset */
    unsigned int findLabel(unsigned int ilOffset);

    /* set operand stack from a label token, return the size of the stack */
    unsigned int setStackFromLabel(unsigned int labelToken, OpType* op_stack, unsigned int op_stack_size);

    /* reset table to empty */
    void reset();

private:
    struct label_table {
        unsigned int ilOffset;
        unsigned int stackToken;
    };
    unsigned char*  stacks;         //compressed buffer of stacks laid end to end
    unsigned int    stacks_size;    //allocated size of the compressed buffer
    unsigned int    stacks_len;     //num bytes used in the compressed buffer
    label_table*    labels;         //array of labels, in il offset sorted order
    unsigned int    labels_size;    //allocated size of the label table
    unsigned int    labels_len;     //num of labels in the table

    /* find the offset at which the label exists or should be inserted */
    unsigned int searchFor(unsigned int ilOffset);

    /* write an op stack into the stacks buffer, return the offset into the buffer where written */
    unsigned int compress(OpType* op_stack, unsigned int op_stack_len);

    /* grow the stacks buffer */
    void growStacks(unsigned int new_size);

    /* grow the labels array */
    void growLabels();
};

class StackEncoder {
private:
    struct labeled_stacks {
        unsigned pcOffset;
        unsigned int stackToken;
    };
    OpType*         last_stack;         //last stack encoded
    unsigned int    last_stack_len;     //logical length
    unsigned int    last_stack_size;    //allocated size
    labeled_stacks* labeled;            //array of pc offsets with stack descriptions
    unsigned int    labeled_len;        //logical length
    unsigned int    labeled_size;       //allocated length
    unsigned char*  stacks;             //buffer for holding compressed stacks
    unsigned int    stacks_len;         //logical length
    unsigned int    stacks_size;        //allocated size
    bool*           gcRefs;             //temp buffers used by encodeStack, reused to reduce allocations
    bool*           interiorRefs;       //  ditto
    unsigned int    gcRefs_len;         //
    unsigned int    interiorRefs_len;   //
    unsigned int    gcRefs_size;        //
    unsigned int    interiorRefs_size;  //  ditto

    /* encode the stack into the stacks buffer, return the index where it was placed */
    unsigned int encodeStack(OpType* op_stack, unsigned int op_stack_len);


public:

    ICorJitInfo*       jitInfo;            //see corjit.h

    StackEncoder();

    ~StackEncoder();

    /* reset so we can be reused */
    void reset();

    /* append the stack state at pcOffset to the end */
    void append(unsigned int pcOffset, OpType* op_stack, unsigned int op_stack_len);

    /* compress the labeled stacks in gcHdrInfo format */
    void compress(unsigned char** buffer, unsigned int* buffer_len, unsigned int* buffer_size);
#ifdef _DEBUG
    void StackEncoder::PrintStacks(FJit_Encode* mapping);
	void StackEncoder::PrintStack(const char* name, unsigned char *& inPtr);
#endif
};

//*************************************************************************************************
class FixupTable {
public:
    FixupTable();
    ~FixupTable();
    CorJitResult  insert(void** pCodeBuffer);							    // inserts an entry in fixup table for jump to target at pCodeBuffer
    void  FixupTable::adjustMap(int delta) ;
    void  resolve(FJit_Encode*    mapping, BYTE* startAddress);   // applies fix up to all entries in table
	void  setup();
private:
	unsigned*	relocations;
	unsigned	relocations_len;
	unsigned	relocations_size;
};

#define PAGE_SIZE 0x1000    // should be removed when this constant is defined in corjit.h
#ifdef LOGGING
extern class ConfigMethodSet fJitCodeLog;
#define MIN_CODE_BUFFER_RESERVED_SIZE   (65536*16)
#else
#define MIN_CODE_BUFFER_RESERVED_SIZE   (65536*4)
#endif

	/* this is all the information that the FJIT keeps track of for every IL instruction.
	   Note that this structure takes only 1 byte at present  */
struct FJitState {
	bool isJmpTarget	: 1;		// This is a target of a jump
	bool isTOSInReg		: 1;		// the top of the stack is in a register
	bool isHandler		: 1;		// This is the begining of a handler
	bool isFilter		: 1;		// This is a filter entry point
};


/*  Since there is only a single FJit instance, an instance of this class holds
    all of the compilation specific data
    */

class FJitContext {
public:
    FJit*           jitter;         //the fjit we are being used by
    ICorJitInfo*       jitInfo;        //interface to EE, passed in when compilation starts
    DWORD           flags;          //compilation directives
    CORINFO_METHOD_INFO*methodInfo;     //see corjit.h
    unsigned int    methodAttributes;//see corjit.h
    stackItems*     localsMap;      //local to stack offset map
    unsigned int    localsFrameSize;//total size of locals allocated in frame
    unsigned int    JitGeneratedLocalsSize; // for tracking esp distance on locallocs, and exceptions
    unsigned int    args_len;       //number of args (including this)
    stackItems*     argsMap;        //args to stack offset/reg map, offset <0 means enregisterd
    unsigned int    argsFrameSize;  //total size of args actually pushed on stack
    unsigned int    opStack_len;    //number of operands on the opStack
    OpType*         opStack;        //operand stack
    unsigned        opStack_size;   //allocated length of the opStack array
    FJit_Encode*    mapping;        //il to pc mapping
    FJitState*		state;          //Information I need for every IL instruction
    unsigned char*  gcHdrInfo;      //compressed gcInfo for FJIT_EETwain.cpp
    unsigned int    gcHdrInfo_len;  //num compressed bytes
    Fjit_hdrInfo    mapInfo;        //header info passed to the code manager (FJIT_EETwain) to do stack walk
    LabelTable      labels;         //label table for labels and exception handlers
    StackEncoder    stacks;         //labeled stacks table for call sites (pending args)
    // the following buffer is used by the EJIT at setup  and reused at jit time for
    // certain IL instructions, e.g. CPOBJ
    unsigned        localsGCRef_len;   //num of sizeof(void*) words in gc ref tail sig locals array
    bool*           localsGCRef;       //true iff that word contains a GC ref
    unsigned        localsGCRef_size;  //allocated length of the localsGCRef array
    unsigned char*  codeBuffer;      // buffer in which code in initially compiled
    unsigned        codeBufferReservedSize; // size of Buffer reserved
    unsigned        codeBufferCommittedSize; // size of Buffer committed
    unsigned        EHBuffer_size;      // size of EHBuffer
    unsigned char*  EHBuffer;           
    FixupTable*     fixupTable;

    unsigned        OFFSET_OF_INTERFACE_TABLE;    // this is an EE constant and is being cached for performance

    /* get and initialize a compilation context to use for compiling */
    static FJitContext* GetContext(
        FJit*           jitter,
        ICorJitInfo*       comp,
        CORINFO_METHOD_INFO* methInfo,
        DWORD           dwFlags
        );
    /* return a compilation context to the free list */
    void ReleaseContext();

    /* make sure the list of available compilation contexts is initialized at startup */
    static BOOL Init();

    /* release all of the compilation contexts at shutdown */
    static void Terminate();

    /* compute the size of an argument based on machine chip */
    unsigned int computeArgSize(CorInfoType argType, CORINFO_ARG_LIST_HANDLE argSig, CORINFO_SIG_INFO* sig);

    /* answer true if this arguement is enregistered on a machine chip */
    bool enregisteredArg(CorInfoType argType);

    /* compute the argument offsets based on the machine chip, returns total size of all the arguments */
    unsigned computeArgInfo(CORINFO_SIG_INFO* jitSigIfo, argInfo* argMap, CORINFO_CLASS_HANDLE thisCls=0);

    /* compress the gc info into gcHdrInfo and answer the size in bytes */
    unsigned int compressGCHdrInfo();

    /* grow a bool[] array by allocating a new one and copying the old values into it, return the size of the new array */
    static unsigned growBooleans(bool** bools, unsigned bools_len, unsigned new_bools_size);

    /* grow an unsigned char[] array by allocating a new one and copying the old values into it, return the size of the new array */
    static unsigned growBuffer(unsigned char** chars, unsigned chars_len, unsigned new_chars_size);

    /* manipuate the opcode stack */
    OpType& topOp(unsigned back = 0);
    void popOp(unsigned cnt = 1);
    void pushOp(OpType type);
    bool isOpStackEmpty();
    void resetOpStack();
    FJitContext(ICorJitInfo* comp);

    void resetContextState();       // resets all state info so the method can be rejitted 

    ~FJitContext();
#ifdef _DEBUG
void FJitContext::displayGCMapInfo();
#endif // _DEBUG

private:
    unsigned state_size;            //allocated length of the state array
    unsigned locals_size;           //allocated length of the localsMap array
    unsigned args_size;             //allocated length of the argsMap array
    unsigned interiorGC_len;        //num of sizeof(void*) words in interior ptr tail sig locals array
    bool*    interiorGC;            //true iff that word contains a possibly interior ptr
    unsigned interiorGC_size;       //allocated length of the interiorGC array
    unsigned pinnedGC_len;          //num of sizeof(void*) words in pinnedGC array
    bool*    pinnedGC;              //true iff that word contains a pinned gc ref
    unsigned pinnedGC_size;         //allocated length of the pinnedGC array
    unsigned pinnedInteriorGC_len;  //num of sizeof(void*) words in pinnedInteriorGC array
    bool*    pinnedInteriorGC;      //true iff that word contains a pinned interior ptr
    unsigned pinnedInteriorGC_size; //allocated length of the pinnedInteriorGC array
    unsigned int    gcHdrInfo_size; //size of compression buffer

    /*adjust the internal mem structs as needed for the size of the method being jitted*/
    void ensureMapSpace();

    /* initialize the compilation context with the method data */
    void setup();

    /* compute the locals map for the method being compiled */
    void computeLocalOffsets();

    /* compute the offset of the start of the local */
    int localOffset(unsigned base, unsigned size);

};

class FJit: public IFJitCompiler {
private:
BOOL AtHandlerStart(FJitContext* fjit,unsigned relOffset, CORINFO_EH_CLAUSE* pClause);
unsigned int Compute_EH_NestingLevel(FJitContext* fjit, unsigned ilOffset);

public:


    FJit();
    ~FJit();

    /* the jitting function */
    CorJitResult __stdcall compileMethod (
            ICorJitInfo*               comp,               /* IN */
            CORINFO_METHOD_INFO*		info,               /* IN */
            unsigned                flags,              /* IN */
            BYTE **                 nativeEntry,        /* OUT */
            ULONG  *  				nativeSizeOfCode    /* OUT */
            );

    static BOOL Init(unsigned int cache_len);
    static void Terminate();

    /* TODO: eliminate this method when the FJit_EETwain is moved into the same dll as fjit */
    FJit_Encode* __stdcall getEncoder();

    /* rearrange the stack & regs to match the calling convention for the chip, return the number of parameters, inlcuding <this> */
    enum BuildCallFlags {
        CALL_NONE       = 0,
        CALL_THIS_LAST  = 1,
        CALL_TAIL       = 2,
		CALLI_UNMGD		= 4,
    };

    CorJitResult jitCompile(
                 FJitContext*    fjitData,
                 BYTE **         entryAddress,
                 unsigned *      codeSize               /* IN/OUT */
                 );
private:
    unsigned buildCall(FJitContext* fjitData, CORINFO_SIG_INFO* sigInfo, unsigned char** outPtr, bool* inRegTOS, BuildCallFlags flags);

    /* grab and remember the jitInterface helper addresses that we need at runtime */
    BOOL GetJitHelpers(ICorJitInfo* jitInfo);

		/* emit helpers */
	static unsigned emit_valClassCopy(FJitContext* fjit, CORINFO_CLASS_HANDLE valClass, unsigned char*& outPtr, bool& inRegTOS);
	static void emit_valClassStore(FJitContext* fjit, CORINFO_CLASS_HANDLE valClass, unsigned char*& outPtr, bool& inRegTOS);
	static void emit_valClassLoad(FJitContext* fjit, CORINFO_CLASS_HANDLE valClass, unsigned char*& outPtr, bool& inRegTOS);
	static void emit_copyPtrAroundValClass(FJitContext* fjit, CORINFO_CLASS_HANDLE valClass, unsigned char*& outPtr, bool& inRegTOS);

    /* pass debugging information to the Runtime (eventually gets to the debugger. */
    void reportDebuggingData(FJitContext* fjitData,CORINFO_SIG_INFO* sigInfo);

#if defined(_DEBUG) || defined(LOGGING)
    const char* szDebugClassName;
    const char* szDebugMethodName;
	bool codeLog;
#endif

};


/***********************************************************************************/
inline OpType& FJitContext::topOp(unsigned back) {
    _ASSERTE (opStack_len > back);
    return(opStack[opStack_len-back-1]);
}

inline void FJitContext::popOp(unsigned cnt) {

    _ASSERTE (opStack_len >= cnt);
    opStack_len -= cnt;
#ifdef _DEBUG
    opStack[opStack_len] = typeError;
#endif
}

inline void FJitContext::pushOp(OpType type) {
    _ASSERTE (opStack_len < opStack_size);
    _ASSERTE (type.isValClass() || (type.enum_() >= typeI4 || type.enum_() < typeU1));
    opStack[opStack_len++] = type;
#ifdef _DEBUG
    opStack[opStack_len] = typeError;
#endif
}

inline void FJitContext::resetOpStack() {
    opStack_len = 0;
#ifdef _DEBUG
    opStack[opStack_len] = typeError;
#endif
}

inline bool FJitContext::isOpStackEmpty() {
    return (opStack_len == 0);
}

/* gets the size in void* sized units for the 'valClass'.  Works for RefAny's too. */
inline unsigned typeSizeInBytes(ICorJitInfo* jitInfo, CORINFO_CLASS_HANDLE valClass) {
    if (valClass == RefAnyClassHandle)
        return(2*sizeof(void*));
    return(jitInfo->getClassSize(valClass));

}

inline unsigned typeSizeInSlots(ICorJitInfo* jitInfo, CORINFO_CLASS_HANDLE valClass) {

    unsigned ret = typeSizeInBytes(jitInfo, valClass);
    ret = (ret+sizeof(void*)-1)/sizeof(void *);         // round up to full words 
    return(ret);
}

#endif //_FJIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\fjitcompiler.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            FJitcompiler.h                                 XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

#include "jitpch.h"
#pragma hdrstop

#define FjitCompile _compile
#define DECLARE_HELPERS      // causes the helpers to be declared

//@TODO: clean up all of these includes and get properly set up for WinCE

#include "new.h"                // for placement new

#include <float.h>   // for _isnan
#include <math.h>    // for fmod

#include "openum.h"

#include <stdio.h>

#if defined(_DEBUG) || defined(LOGGING)
void logMsg(ICorJitInfo* info, unsigned logLevel, char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    info->logMsg(logLevel, fmt, args);
}
#endif

#if defined(_DEBUG) || defined(LOGGING)
ICorJitInfo* logCallback = 0;              // where to send the logging mesages
extern char *opname[1];
#endif

#include "cx86def.h"
#include "fjit.h"
#include "fjitdef.h"


#define emit_LDVAR_VC(offset, valClassHnd)              \
    emit_LDVARA(offset);                                \
    emit_valClassLoad(fjit, valClassHnd, outPtr, inRegTOS); 

#define emit_STVAR_VC(offset, valClassHnd)              \
    emit_LDVARA(offset);                                \
    emit_valClassStore(fjit, valClassHnd, outPtr, inRegTOS);    

    // This is needed for varargs support
#define emit_LDIND_VC(dummy, valClassHnd)               \
    emit_valClassLoad(fjit, valClassHnd, outPtr, inRegTOS); 

    // This is needed for varargs support
#define emit_STIND_REV_VC(dummy, valClassHnd)           \
    emit_valClassStore(fjit, valClassHnd, outPtr, inRegTOS);    

#define emit_DUP_VC(dummy, valClassHnd)                     \
    emit_getSP(0);  /* get pointer to current struct */     \
    emit_valClassLoad(fjit, valClassHnd, outPtr, inRegTOS);     

#define emit_POP_VC(dummy, valClassHnd)                 \
    emit_drop(typeSizeInSlots(m_IJitInfo, valClassHnd) * sizeof(void*))     

#define emit_pushresult_VC(dummy, valClassHnd)          {}  /* result already where it belongs */   

#define emit_loadresult_VC(dummy, valClassHnd)           {                                      \
    unsigned retBufReg = fjit->methodInfo->args.hasThis();                                  \
    emit_WIN32(emit_LDVAR_I4(offsetOfRegister(retBufReg))) emit_WIN64(emit_LDVAR_I8(offsetOfRegister(retBufReg))); \
    emit_valClassStore(fjit, valClassHnd, outPtr, inRegTOS);                                \
    }

static unsigned typeSize[] = {  0,   //CORINFO_TYPE_UNDEF
                                0,   //CORINFO_TYPE_VOID
                                4,      //CORINFO_TYPE_BOOL
                                4,      //CORINFO_TYPE_CHAR
                                4,      //CORINFO_TYPE_BYTE
                                4,      //CORINFO_TYPE_UBYTE
                                4,      //CORINFO_TYPE_SHORT
                                4,      //CORINFO_TYPE_USHORT
                                4,      //CORINFO_TYPE_INT
                                4,      //CORINFO_TYPE_UINT
                                8,      //CORINFO_TYPE_LONG
                                8,      //CORINFO_TYPE_ULONG
                                4,      //CORINFO_TYPE_FLOAT
                                8,      //CORINFO_TYPE_DOUBLE
                                sizeof(void*),     //CORINFO_TYPE_STRING
                                sizeof(void*),       //CORINFO_TYPE_PTR
                                sizeof(void*),   //CORINFO_TYPE_BYREF
                                0,   //CORINFO_TYPE_VALUECLASS
                                sizeof(void*),     //CORINFO_TYPE_CLASS
                                2*sizeof(void*)  //CORINFO_TYPE_REFANY
};


/************************************************************************************/
/* emits code that will take a stack (..., dest, src) and copy a value class 
   at src to dest, pops 'src' and 'dest' and set the stack to (...).  returns 
   the number of bytes that 'valClass' takes on the stack */

unsigned  FJit::emit_valClassCopy(FJitContext* fjit, CORINFO_CLASS_HANDLE valClass, unsigned char*& outPtr, bool& inRegTOS) 
{
#ifdef _X86_
    unsigned int numBytes = typeSizeInBytes(fjit->jitInfo, valClass);
    unsigned int numWords = (numBytes + sizeof(void*)-1) / sizeof(void*);

    if (numBytes < sizeof(void*)) {
        switch(numBytes) {
            case 1:
                emit_LDIND_I1();
                emit_STIND_I1();
                return(sizeof(void*));
            case 2:
                emit_LDIND_I2();
                emit_STIND_I2();
                return(sizeof(void*));
            case 3:
                break;
            case 4:
                emit_LDIND_I4();
                emit_STIND_I4();
                return(sizeof(void*));
            default:
                _ASSERTE(!"Invalid numBytes");
        }
    }
    fjit->localsGCRef_len = numWords;
    if (fjit->localsGCRef_size < numWords)
        fjit->localsGCRef_size = FJitContext::growBooleans(&(fjit->localsGCRef), fjit->localsGCRef_len, numWords);
    int compressedSize;
    if (valClass == RefAnyClassHandle) {
        compressedSize = 1;
        *fjit->localsGCRef = 0;     // No write barrier needed (since BYREFS always on stack)
    }
    else {
        fjit->jitInfo->getClassGClayout(valClass, (BYTE *)fjit->localsGCRef);
        compressedSize = FJit_Encode::compressBooleans(fjit->localsGCRef,fjit->localsGCRef_len);
    }

        // @TODO: If no gc refs then do a block move, less than 16 bytes, emit the movs inline.  
    emit_copy_bytes(numBytes,compressedSize,fjit->localsGCRef);


    return(numWords*sizeof(void*));
#else // _X86_
    _ASSERTE(!"@TODO Alpha - emit_valClassCopy (fJitCompiler.cpp)");
    return 0;
#endif // _X86_
}

/************************************************************************************/
/* emits code that given a stack (..., valClassValue, destPtr), copies 'valClassValue' 
   to 'destPtr'.  Leaves the stack (...),  */ 

void FJit::emit_valClassStore(FJitContext* fjit, CORINFO_CLASS_HANDLE valClass, unsigned char*& outPtr, bool& inRegTOS) 
{
#ifdef _X86_
        // TODO: optimize the case for small structs,
    emit_getSP(sizeof(void*));                                                  // push SP+4, which points at valClassValue
    unsigned argBytes = emit_valClassCopy(fjit, valClass, outPtr, inRegTOS);    // copy dest from SP+4;
    // emit_valClassCopy pops off destPtr, now we need to pop the valClass
    emit_drop(argBytes);
#else // _X86_
    _ASSERTE(!"@TODO Alpha - emit_valClassStore (fJitCompiler.cpp)");
#endif // _X86_
}

/************************************************************************************/
/* emits code that takes a stack (... srcPtr) and replaces it with a copy of the
   value class at 'src' (... valClassVal) */

void FJit::emit_valClassLoad(FJitContext* fjit, CORINFO_CLASS_HANDLE valClass, unsigned char*& outPtr, bool& inRegTOS) 
{
#ifdef _X86_
        // TODO: optimize the case for small structs,
    emit_push_words(typeSizeInSlots(fjit->jitInfo, valClass));
#else // _X86_
    _ASSERTE(!"@TODO Alpha - emit_valClassLoad (fJitCompiler.cpp)");
#endif // _X86_
}

/************************************************************************************/
/* emits code that takes a stack (..., ptr, valclass).  and produces (..., ptr, valclass, ptr), */

void FJit::emit_copyPtrAroundValClass(FJitContext* fjit, CORINFO_CLASS_HANDLE valClass, unsigned char*& outPtr, bool& inRegTOS) 
{
#ifdef _X86_
        // TODO this could be optimized to mov EAX [ESP+delta]
    emit_getSP(typeSizeInSlots(fjit->jitInfo, valClass)*sizeof(void*));
    emit_LDIND_PTR();
#else // _X86_
    _ASSERTE(!"@TODO Alpha - emit_copyPtrAroundValClass (fJitCompiler.cpp)");
#endif // _X86_
}

/************************************************************************************/
BOOL FJit::AtHandlerStart(FJitContext* fjit,unsigned relOffset, CORINFO_EH_CLAUSE* pClause)
{
    for (unsigned int except = 0; except < fjit->methodInfo->EHcount; except++) {
        fjit->jitInfo->getEHinfo(fjit->methodInfo->ftn, except, pClause);
        if ( ((pClause->Flags & CORINFO_EH_CLAUSE_FILTER) && (pClause->FilterOffset == relOffset)) ||
            (pClause->HandlerOffset == relOffset) )
        {
            return true;        
        }
    }
    return false;
}
#ifdef _X86_
#define TLS_OFFSET 0x2c
#else
#define TLS_OFFSET 0        // should be defined for each architecture
#endif
/************************************************************************************/

#define CALLEE_SAVED_REGISTER_OFFSET    1                   // offset in DWORDS from EBP/ESP of callee saved registers 
#define EBP_RELATIVE_OFFSET             0x10000000          // bit to indicate that offset is from EBP
#define CALLEE_SAVED_REG_MASK           0x40000000          // EBX:ESI:EDI (3-bit mask) for callee saved registers
#define emit_setup_tailcall(CallerSigInfo,TargetSigInfo) \
{ \
    unsigned tempMapSize; \
    tempMapSize = ((CallerSigInfo.numArgs > TargetSigInfo.numArgs) ? CallerSigInfo.numArgs : \
                          TargetSigInfo.numArgs ) + 1;  /* +1 in case there is a this ptr (since numArgs does not include this)*/ \
    argInfo* tempMap; \
    tempMap = new argInfo[tempMapSize];\
    if (tempMap == NULL) \
       FJIT_FAIL(CORJIT_OUTOFMEM);\
    unsigned int CallerStackArgSize;    \
    CallerStackArgSize = fjit->computeArgInfo(&(CallerSigInfo), tempMap); \
    emit_LDC_I(CallerStackArgSize/sizeof(void*));/* push count of new arguments*/ \
    targetCallStackSize = fjit->computeArgInfo(&(TargetSigInfo), tempMap);        \
    delete tempMap;     \
    emit_LDC_I(targetCallStackSize/sizeof(void*));/* push offset of callee saved regs, EBP/ESP relative bit, and mask*/ \
    emit_LDC_I(EBP_RELATIVE_OFFSET | CALLEE_SAVED_REG_MASK | CALLEE_SAVED_REGISTER_OFFSET ); \
}

/************************************************************************************/
inline void getSequencePoints( ICorJitInfo* jitInfo, 
                               CORINFO_METHOD_HANDLE methodHandle,
                               ULONG32 *cILOffsets, 
                               DWORD **pILOffsets,
                               ICorDebugInfo::BoundaryTypes *implicitBoundaries)
{
    jitInfo->getBoundaries(methodHandle, cILOffsets, pILOffsets, implicitBoundaries);
}

inline void cleanupSequencePoints(ICorJitInfo* jitInfo, DWORD * pILOffsets)
{
    jitInfo->freeArray(pILOffsets);
}

// Determine the EH nesting level at ilOffset. Just walk the EH table 
// and find out how many handlers enclose it. The lowest nesting level = 1.
unsigned int FJit::Compute_EH_NestingLevel(FJitContext* fjit, 
                                           unsigned ilOffset)
{
    DWORD nestingLevel = 1;
    CORINFO_EH_CLAUSE clause;
    unsigned exceptionCount = fjit->methodInfo->EHcount;
    _ASSERTE(exceptionCount > 0);
    if (exceptionCount == 1)
    {
#ifdef _DEBUG
        fjit->jitInfo->getEHinfo(fjit->methodInfo->ftn, 0, &clause);
        _ASSERTE((clause.Flags & CORINFO_EH_CLAUSE_FILTER) ?
                    ilOffset == clause.FilterOffset || ilOffset == clause.HandlerOffset :
                    ilOffset == clause.HandlerOffset);

#endif
        return nestingLevel;
    }
    ICorJitInfo*           jitInfo = fjit->jitInfo;
    CORINFO_METHOD_INFO*    methodInfo = fjit->methodInfo;
    for (unsigned except = 0; except < exceptionCount; except++) 
    {
        jitInfo->getEHinfo(methodInfo->ftn, except, &clause);
        if (ilOffset > clause.HandlerOffset && ilOffset < clause.HandlerOffset+clause.HandlerLength)
            nestingLevel++;
    }

    return nestingLevel;
}
/************************************************************************************/
/* jit the method. if successful, return number of bytes jitted, else return 0 */
//@TODO: eliminate this exta level of call and return real JIT_return codes directly
CorJitResult FJit::jitCompile(
                FJitContext* fjit,
                BYTE **         entryAddress,
                unsigned * codeSize
                )
{
#ifdef _X86_

#define FETCH(ptr, type)        (*((type *&)(ptr)))
#define GET(ptr, type)    (*((type *&)(ptr))++)

#define SET(ptr, val, type)     (*((type *&)(ptr)) = val)
#define PUT(ptr, val, type)    (*((type *&)(ptr))++ = val)

#define LABELSTACK(pcOffset, numOperandsToIgnore)                       \
        _ASSERTE(fjit->opStack_len >= numOperandsToIgnore);             \
        fjit->stacks.append((unsigned)(pcOffset), fjit->opStack, fjit->opStack_len-numOperandsToIgnore)

#define FJIT_FAIL(JitErrorCode)     do { _ASSERTE(!"FJIT_FAIL"); return (JitErrorCode); } while(0)

#define CHECK_STACK(cnt) {if (fjit->opStack_len < cnt) FJIT_FAIL(CORJIT_INTERNALERROR);}
#define CHECK_POP_STACK(cnt) {if (fjit->opStack_len < cnt) FJIT_FAIL(CORJIT_INTERNALERROR); fjit->popOp(cnt);}
#define CEE_OP(ilcode, arg_cnt)                                         \
            case CEE_##ilcode:                                          \
                emit_##ilcode();                                        \
                CHECK_POP_STACK(arg_cnt);                                   \
                break;

#define CEE_OP_LD(ilcode, arg_cnt, ld_type, ld_cls)                     \
            case CEE_##ilcode:                                          \
                emit_##ilcode();                                        \
                CHECK_POP_STACK(arg_cnt);                                   \
                fjit->pushOp(ld_type);                                  \
                break;


#define TYPE_SWITCH_Bcc(CItest,CRtest,BjmpCond,CjmpCond,AllowPtr)                      \
    /* not need to check stack since there is a following pop that checks it */ \
            if (ilrel < 0) {                                            \
                emit_trap_gc();                                         \
                }                                                       \
            switch (fjit->topOp().enum_()) {                                                  \
                emit_WIN32(case typeByRef:)                     \
                emit_WIN32(case typeRef:)                       \
                emit_WIN32(_ASSERTE(AllowPtr || fjit->topOp(1).enum_() == typeI4);) \
                emit_WIN64(_ASSERTE(AllowPtr || fjit->topOp(1).enum_() == typeI8);) \
                case typeI4: \
                    emit_WIN32(_ASSERTE(fjit->topOp(1).enum_() == typeI4 || fjit->topOp(1).enum_() == typeRef|| fjit->topOp(1).enum_() == typeByRef);) \
                    emit_WIN64(_ASSERTE(fjit->topOp(1).enum_() == typeI4);) \
                    emit_BR_I4(CItest##_I4,CjmpCond,BjmpCond,op); \
                    CHECK_POP_STACK(2); \
                    goto DO_JMP; \
                emit_WIN64(case typeByRef:)                     \
                emit_WIN64(case typeRef:)                       \
                emit_WIN64(_ASSERTE(AllowPtr || fjit->topOp(1).enum_() == typeI8);) \
                case typeI8:                                            \
                    emit_WIN32(_ASSERTE(fjit->topOp(1).enum_() == typeI8);) \
                    emit_WIN64(_ASSERTE(fjit->topOp(1).enum_() == typeI8 || fjit->topOp(1).enum_() == typeRef|| fjit->topOp(1).enum_() == typeByRef);) \
                    emit_BR_I8(CItest##_I8,CjmpCond,BjmpCond,op); \
                    CHECK_POP_STACK(2); \
                    goto DO_JMP; \
               case typeR8:                                            \
                    emit_BR_R8(CRtest##_R8,CjmpCond,BjmpCond,op); \
                    CHECK_POP_STACK(2); \
                    goto DO_JMP; \
                default:                                                        \
                    _ASSERTE(!"BadType");                      \
                    FJIT_FAIL(CORJIT_INTERNALERROR);             \
                }

        // operations that can take any type including value classes and small types
#define TYPE_SWITCH_PRECISE(type, emit, args)                            \
            switch (type.toInt()) {                                    \
                case typeU1:                                            \
                    emit##_U1 args;                                 \
                    break; \
                case typeU2:                                            \
                    emit##_U2 args;                                 \
                    break; \
                case typeI1:                                            \
                    emit##_I1 args;                                 \
                    break; \
                case typeI2:                                            \
                    emit##_I2 args;                                 \
                    break; \
                emit_WIN32(case typeByRef:)                     \
                emit_WIN32(case typeRef:)                       \
                case typeI4:                                            \
                    emit##_I4 args;                                 \
                    break;                                                  \
                emit_WIN64(case typeByRef:)                     \
                emit_WIN64(case typeRef:)                       \
                case typeI8:                                            \
                    emit##_I8 args;                                 \
                    break;                                                  \
                case typeR4:                                            \
                    emit##_R4 args;                                 \
                    break;                                                  \
                case typeR8:                                            \
                    emit##_R8 args;                                 \
                    break;                                                 \
                default:                                                     \
                    _ASSERTE(type.isValClass());                    \
                    emit##_VC (args, type.cls())                             \
                }


        // operations that can take any type including value classes
#define TYPE_SWITCH(type, emit, args)                            \
            switch (type.toInt()) {                                    \
                emit_WIN32(case typeByRef:)                     \
                emit_WIN32(case typeRef:)                       \
                case typeI4:                                            \
                    emit##_I4 args;                                 \
                    break;                                                  \
                emit_WIN64(case typeByRef:)                     \
                emit_WIN64(case typeRef:)                       \
                case typeI8:                                            \
                    emit##_I8 args;                                 \
                    break;                                                  \
                case typeR4:                                            \
                    emit##_R4 args;                                 \
                    break;                                                  \
                case typeR8:                                            \
                    emit##_R8 args;                                 \
                    break;                                                 \
                default:                                                     \
                    _ASSERTE(type.isValClass());                    \
                    emit##_VC (args, type.cls())                             \
                }



        // operations that work on pointers and numbers(eg add sub)
#define TYPE_SWITCH_PTR(type, emit, args)                            \
            /* no need to check stack here because the following pop will check it */ \
            switch (type.enum_()) {                                                  \
                emit_WIN32(case typeByRef:)                     \
                emit_WIN32(case typeRef:)                       \
                case typeI4:                                            \
                    emit##_I4 args;                                 \
                    break;                                                  \
                emit_WIN64(case typeByRef:)                     \
                emit_WIN64(case typeRef:)                       \
                case typeI8:                                            \
                    emit##_I8 args;                                 \
                    break;                                                  \
                case typeR8:                                            \
                    emit##_R8 args;                                 \
                    break;                                                  \
                default:                                                        \
                    _ASSERTE(!"BadType");                      \
                    FJIT_FAIL(CORJIT_INTERNALERROR);             \
                }
        // operations that can take number I or R
#define TYPE_SWITCH_ARITH(type, emit, args)                      \
            /* no need to check stack here because the following pop will check it */ \
            switch (type.enum_()) {                                                  \
                case typeI4:                                            \
                        emit##_I4 args;                                 \
                        break;                                                  \
                case typeI8:                                            \
                        emit##_I8 args;                                 \
                        break;                                                  \
                case typeR8:                                            \
                        emit##_R8 args;                                 \
                        break;                                                  \
                case typeRef: \
                case typeByRef: \
                        emit_WIN32(emit##_I4 args;) emit_WIN64(emit##_I8 args;) \
                        break; \
                default:                                                        \
                        _ASSERTE(!"BadType");                   \
                        FJIT_FAIL(CORJIT_INTERNALERROR);    \
                }

#define TYPE_SWITCH_INT(type, emit, args)            \
            /* no need to check stack here because the following pop will check it */ \
            switch (type.enum_()) {                          \
                case typeI4:                        \
                    emit##_I4 args;                 \
                    break;                          \
                case typeI8:                        \
                    emit##_I8 args;                 \
                    break;                          \
                default:                            \
                    _ASSERTE(!"BadType");           \
                    FJIT_FAIL(CORJIT_INTERNALERROR);    \
                }

    // operations that can take just integers I
#define TYPE_SWITCH_LOGIC(type, emit, args)          \
            /* no need to check stack here because the following pop will check it */ \
            switch (type.enum_()) {                          \
                case typeI4:                        \
                    emit##_U4 args;                 \
                    break;                          \
                case typeI8:                        \
                    emit##_U8 args;                 \
                    break;                          \
                default:                            \
                    _ASSERTE(!"BadType");           \
                    FJIT_FAIL(CORJIT_INTERNALERROR);    \
                }
// The following is derived from Table 1: Binary Numeric Operations of the IL Spec
#define COMPUTE_RESULT_TYPE_ADD(type1, type2)          \
            CHECK_STACK(2) \
            switch (type1.enum_()) { \
                case typeByRef:                      \
                    _ASSERTE((type2.enum_() == typeI4) || ((typeI == typeI8) && (type2.enum_() == typeI8))); \
                    CHECK_POP_STACK(2);                   \
                    fjit->pushOp(typeByRef);           \
                    break;                           \
                case typeI4:                          \
                    _ASSERTE((type2.enum_() == typeByRef) ||(type2.enum_() == typeI4));  \
                    if (type2.enum_() == typeByRef) \
                    { \
                        CHECK_POP_STACK(2);  \
                        fjit->pushOp(typeByRef); \
                    } \
                    else \
                    { \
                        CHECK_POP_STACK(2);  \
                        fjit->pushOp(typeI4); \
                    } \
                    break; \
                case typeI8:                          \
                    _ASSERTE((type2.enum_() == typeByRef) ||(type2.enum_() == typeI8));  \
                    if (type2.enum_() == typeByRef) \
                    { \
                        CHECK_POP_STACK(2);  \
                        fjit->pushOp(typeByRef); \
                    } \
                    else \
                    { \
                        CHECK_POP_STACK(2);  \
                        fjit->pushOp(typeI8); \
                    } \
                    break; \
                case typeR8:                                            \
                    _ASSERTE((type2.enum_() == typeR8));  \
                    CHECK_POP_STACK(1);                                 \
                    break;                                                  \
                default:                                                        \
                    _ASSERTE(!"BadType");                      \
                    FJIT_FAIL(CORJIT_INTERNALERROR);             \
            }

#define COMPUTE_RESULT_TYPE_SUB(type1, type2)          \
            CHECK_STACK(2) \
            switch (type1.enum_()) { \
                case typeByRef:                      \
                    if ( (type2.enum_() == typeI4) || ((type2.enum_() == typeI8) && (typeI == typeI8)) ) \
                    {  \
                        CHECK_POP_STACK(2);                   \
                        fjit->pushOp(typeByRef);           \
                    } \
                    else \
                    { \
                        _ASSERTE(type2.enum_() == typeByRef); \
                        CHECK_POP_STACK(2);                   \
                        fjit->pushOp(typeI);  \
                    } \
                    break; \
                case typeI4:                          \
                    _ASSERTE((type2.enum_() == typeByRef) ||(type2.enum_() == typeI4));  \
                    if (type2.enum_() == typeByRef) \
                    { \
                        CHECK_POP_STACK(2);  \
                        fjit->pushOp(typeByRef); \
                    } \
                    else \
                    { \
                        CHECK_POP_STACK(2);  \
                        fjit->pushOp(typeI4); \
                    } \
                    break; \
                case typeI8:                          \
                    _ASSERTE((type2.enum_() == typeByRef) ||(type2.enum_() == typeI8));  \
                    if (type2.enum_() == typeByRef) \
                    { \
                        CHECK_POP_STACK(2);  \
                        fjit->pushOp(typeByRef); \
                    } \
                    else \
                    { \
                        CHECK_POP_STACK(2);  \
                        fjit->pushOp(typeI8); \
                    } \
                    break; \
                case typeR8:                                            \
                    _ASSERTE((type2.enum_() == typeR8));  \
                    CHECK_POP_STACK(1);                                 \
                    break;                                                  \
                default:                                                        \
                    _ASSERTE(!"BadType");                      \
                    FJIT_FAIL(CORJIT_INTERNALERROR);             \
            }

#define LEAVE_CRIT                                                                                  \
            if (methodInfo->args.hasThis()) {                                                    \
                emit_WIN32(emit_LDVAR_I4(prolog_bias + offsetof(prolog_data, enregisteredArg_1)))   \
                emit_WIN64(emit_LDVAR_I8(prolog_bias + offsetof(prolog_data, enregisteredArg_1)));  \
                emit_EXIT_CRIT();                                                                   \
           }                                                                                       \
            else {                                                                                  \
                void* syncHandle;                                                           \
                syncHandle = m_IJitInfo->getMethodSync(methodHandle);                               \
                emit_EXIT_CRIT_STATIC(syncHandle);                                                  \
            }

#define ENTER_CRIT                                                                                  \
            if (methodInfo->args.hasThis()) {                                                    \
                emit_WIN32(emit_LDVAR_I4(prolog_bias + offsetof(prolog_data, enregisteredArg_1)))   \
                emit_WIN64(emit_LDVAR_I8(prolog_bias + offsetof(prolog_data, enregisteredArg_1)));  \
                emit_ENTER_CRIT();                                                                   \
            }                                                                                       \
            else {                                                                                  \
                void* syncHandle;                                                           \
                syncHandle = m_IJitInfo->getMethodSync(methodHandle);                               \
                emit_ENTER_CRIT_STATIC(syncHandle);                                                 \
            }

#define CURRENT_INDEX (inPtr - inBuff)

//#define TOSEnregistered state
    BOOL TailCallForbidden = ((fjit->methodInfo->args.callConv  & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_VARARG);
                              // if set, no tailcalls allowed. Initialized to FALSE. When a security test
                                     // changes it to TRUE, it remains TRUE for the duration of the jit
JitAgain:
    BOOL MadeTailCall = FALSE;       // if a tailcall has been made and subsequently TailCallForbidden is set to TRUE,
                                     // we will rejit the code, disallowing tailcalls.

    unsigned char*  outBuff = fjit->codeBuffer;
    ICorJitInfo*       m_IJitInfo = fjit->jitInfo;
    FJitState*      state = fjit->state;
    CORINFO_METHOD_INFO* methodInfo = fjit->methodInfo;
    CORINFO_METHOD_HANDLE   methodHandle= methodInfo->ftn;
    CORINFO_MODULE_HANDLE    scope = methodInfo->scope;
    unsigned int    len = methodInfo->ILCodeSize;            // IL size
    unsigned char*  inBuff = methodInfo->ILCode;             // IL bytes
    unsigned char*  inPtr = inBuff;                          // current il position
    unsigned char*  inBuffEnd = &inBuff[len];                // end of il
    unsigned char*  outPtr = outBuff;                        // x86 macros write here
    unsigned int    methodAttributes = fjit->methodAttributes;
    unsigned short  offset;
    unsigned        address;
    signed int      i4;
    signed __int64  i8;
    unsigned int    token;
    unsigned int    argBytes;
    unsigned int    SizeOfClass;

    int             op;
    signed          ilrel;

    CORINFO_METHOD_HANDLE   targetMethod;
    CORINFO_CLASS_HANDLE    targetClass;
    CORINFO_FIELD_HANDLE    targetField;
    DWORD           fieldAttributes;
    CorInfoType       jitType;
    bool            fieldIsStatic;
    CORINFO_SIG_INFO    targetSigInfo;
    void*           helper_ftn;

    bool            inRegTOS = false;
    bool            controlContinue = true;              //does control we fall thru to next il instr

    unsigned        maxArgs = fjit->args_len;
    stackItems*     argsMap = fjit->argsMap;
    unsigned int    argsTotalSize = fjit->argsFrameSize;
    unsigned int    maxLocals = methodInfo->locals.numArgs;
    stackItems*     localsMap = fjit->localsMap;
    stackItems*     varInfo;
    OpType          trackedType;

#ifdef _DEBUG
    bool didLocalAlloc = false;
#endif

    _ASSERTE(!(methodAttributes & (CORINFO_FLG_NATIVE)));
    if (methodAttributes & (CORINFO_FLG_NATIVE))
        FJIT_FAIL(CORJIT_INTERNALERROR);


    *entryAddress = outPtr;
 
#if defined(_X86_) && defined(_DEBUG)
    static ConfigMethodSet fJitHalt(L"JitHalt");
    if (fJitHalt.contains(szDebugMethodName, szDebugClassName, PCCOR_SIGNATURE(fjit->methodInfo->args.sig))) {
        cmdByte(expNum(0xCC));      // Drop in an int 3
    }
#endif

    // it may be worth optimizing the following to only initialize locals so as to cover all refs.
    unsigned int localWords = (fjit->localsFrameSize+sizeof(void*)-1)/ sizeof(void*);
    unsigned int zeroWordCnt = localWords;
    emit_prolog(localWords, zeroWordCnt);

    if (fjit->flags & CORJIT_FLG_PROF_ENTERLEAVE)
    {
        BOOL bHookFunction;
        UINT_PTR thisfunc = (UINT_PTR) m_IJitInfo->GetProfilingHandle(methodHandle, &bHookFunction);
        if (bHookFunction)
        {
            _ASSERTE(!inRegTOS);
            emit_LDC_I(thisfunc); 
            ULONG func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_ENTER);
            _ASSERTE(func != NULL);
            emit_callhelper_il(func); 
        }
    }

    if (methodAttributes & CORINFO_FLG_SYNCH) {
        ENTER_CRIT;
    }

#ifdef LOGGING
    if (codeLog) {
        emit_log_entry(szDebugClassName, szDebugMethodName);
    }
#endif

    // Get sequence points
    ULONG32                      cSequencePoints;
    DWORD                   *    sequencePointOffsets;
    unsigned                     nextSequencePoint = 0;
    ICorDebugInfo::BoundaryTypes offsetsImplicit;  // this is ignored by the fjit
    if (fjit->flags & CORJIT_FLG_DEBUG_INFO) {
        getSequencePoints(fjit->jitInfo,methodHandle,&cSequencePoints,&sequencePointOffsets,&offsetsImplicit);
    }
    else {
        cSequencePoints = 0;
        offsetsImplicit = ICorDebugInfo::NO_BOUNDARIES;
    }

    fjit->mapInfo.prologSize = outPtr-outBuff;

    _ASSERTE(!inRegTOS);

    while (inPtr < inBuffEnd)
    {
#ifdef _DEBUG
        argBytes = 0xBADF00D;
#endif
        if (controlContinue) {
            if (state[CURRENT_INDEX].isJmpTarget && inRegTOS != state[CURRENT_INDEX].isTOSInReg) {
                if (inRegTOS) {
                        deregisterTOS;
                }
                else {
                        enregisterTOS;
                }
            }
        }
        else {  // controlContinue == false
            unsigned int label = fjit->labels.findLabel(CURRENT_INDEX);
            if (label == LABEL_NOT_FOUND) {
                CHECK_POP_STACK(fjit->opStack_len);
                inRegTOS = false;
            }
            else { 
                fjit->opStack_len = fjit->labels.setStackFromLabel(label, fjit->opStack, fjit->opStack_size);
                inRegTOS = state[CURRENT_INDEX].isTOSInReg;
            }
            controlContinue = true;
        }

        fjit->mapping->add((inPtr-inBuff),(unsigned) (outPtr - outBuff));
        if (state[CURRENT_INDEX].isHandler) {
            unsigned int nestingLevel = Compute_EH_NestingLevel(fjit,(inPtr-inBuff));
            emit_storeTOS_in_JitGenerated_local(nestingLevel,state[CURRENT_INDEX].isFilter);
        }
        state[CURRENT_INDEX].isTOSInReg = inRegTOS;
        if (cSequencePoints &&   /* will be 0 if no debugger is attached */
            (nextSequencePoint < cSequencePoints) &&
            ((unsigned)(inPtr-inBuff) == sequencePointOffsets[nextSequencePoint]))
        {
            if (fjit->opStack_len == 0)         // only recognize sequence points that are at zero stack
                emit_sequence_point_marker();
            nextSequencePoint++;
        }

#ifdef LOGGING
        ilrel = inPtr - inBuff;
#endif

        OPCODE  opcode = OPCODE(GET(inPtr, unsigned char));
DECODE_OPCODE:

#ifdef LOGGING
    if (codeLog && opcode != CEE_PREFIXREF && (opcode < CEE_PREFIX7 || opcode > CEE_PREFIX1)) {
        bool oldstate = inRegTOS;
        emit_log_opcode(ilrel, opcode, oldstate);
        inRegTOS = oldstate;
    }
#endif

        //      if (opcode != CEE_PREFIXREF)
        //              printf("Stack length = %d, IL: %s \n", fjit->opStack_len,opname[opcode] );


        switch (opcode)
        {

        case CEE_PREFIX1:
            opcode = OPCODE(GET(inPtr, unsigned char) + 256);
            goto DECODE_OPCODE;

        case CEE_LDARG_0:
        case CEE_LDARG_1:
        case CEE_LDARG_2:
        case CEE_LDARG_3:
            offset = (opcode - CEE_LDARG_0);
            _ASSERTE(0 <= offset && offset < 4);
            goto DO_LDARG;

        case CEE_LDARG_S:
            offset = GET(inPtr, unsigned char);
            goto DO_LDARG;

        case CEE_LDARG:
            offset = GET(inPtr, unsigned short);
DO_LDARG:
            _ASSERTE(offset < maxArgs);
            if (offset >= maxArgs)
                FJIT_FAIL(CORJIT_INTERNALERROR);
            varInfo = &argsMap[offset];
            if (methodInfo->args.isVarArg() && !varInfo->isReg) {
                emit_VARARG_LDARGA(offset);
                trackedType = varInfo->type;

DO_LDIND_BYTYPE:
                TYPE_SWITCH_PRECISE(trackedType, emit_LDIND, ());
                trackedType.toFPNormalizedType();
                fjit->pushOp(trackedType);
                break;
            }
            goto DO_LDVAR;
            break;

        case CEE_LDLOC_0:
        case CEE_LDLOC_1:
        case CEE_LDLOC_2:
        case CEE_LDLOC_3:
            offset = (opcode - CEE_LDLOC_0);
            _ASSERTE(0 <= offset && offset < 4);
            goto DO_LDLOC;

        case CEE_LDLOC_S:
            offset = GET(inPtr, unsigned char);
            goto DO_LDLOC;

        case CEE_LDLOC:
            offset = GET(inPtr, unsigned short);
DO_LDLOC:
            _ASSERTE(offset < maxLocals);
            varInfo = &localsMap[offset];
DO_LDVAR:
            TYPE_SWITCH_PRECISE(varInfo->type, emit_LDVAR, (varInfo->offset));
            trackedType = varInfo->type;
            trackedType.toFPNormalizedType();
            fjit->pushOp(trackedType);
            break;

        case CEE_STARG_S:
            offset = GET(inPtr, unsigned char);
            goto DO_STARG;

        case CEE_STARG:
            offset = GET(inPtr, unsigned short);
DO_STARG:
            _ASSERTE(offset < maxArgs);
            if (offset >= maxArgs)
                FJIT_FAIL(CORJIT_INTERNALERROR);
            varInfo = &argsMap[offset];
            trackedType = varInfo->type;
            trackedType.toNormalizedType();
            if (methodInfo->args.isVarArg() && !varInfo->isReg) {
                emit_VARARG_LDARGA(offset);
                TYPE_SWITCH(trackedType, emit_STIND_REV, ());
                CHECK_POP_STACK(1);
                break;
            }
            goto DO_STVAR;

        case CEE_STLOC_0:
        case CEE_STLOC_1:
        case CEE_STLOC_2:
        case CEE_STLOC_3:
            offset = (opcode - CEE_STLOC_0);
            _ASSERTE(0 <= offset && offset < 4);
            goto DO_STLOC;

        case CEE_STLOC_S:
            offset = GET(inPtr, unsigned char);
            goto DO_STLOC;

        case CEE_STLOC:
            offset = GET(inPtr, unsigned short);
DO_STLOC:
            _ASSERTE(offset < maxLocals);
            if (offset >= maxLocals)
                FJIT_FAIL(CORJIT_INTERNALERROR);
            varInfo = &localsMap[offset];
            trackedType = varInfo->type;
            trackedType.toNormalizedType();
DO_STVAR:
            TYPE_SWITCH(trackedType,emit_STVAR, (varInfo->offset));
            CHECK_POP_STACK(1);
            break;

        case CEE_ADD:
            TYPE_SWITCH_PTR(fjit->topOp(), emit_ADD, ());
            COMPUTE_RESULT_TYPE_ADD(fjit->topOp(),fjit->topOp(1));
            break;

        case CEE_ADD_OVF:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_INT(fjit->topOp(), emit_ADD_OVF, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_ADD_OVF_UN:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_LOGIC(fjit->topOp(), emit_ADD_OVF, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_SUB:
            TYPE_SWITCH_PTR(fjit->topOp(), emit_SUB, ());
            COMPUTE_RESULT_TYPE_SUB(fjit->topOp(),fjit->topOp(1));
            break;

        case CEE_SUB_OVF:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_INT(fjit->topOp(), emit_SUB_OVF, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_SUB_OVF_UN:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_LOGIC(fjit->topOp(), emit_SUB_OVF, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_MUL:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_MUL, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_MUL_OVF: {
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            OpType type = fjit->topOp();
            CHECK_POP_STACK(2);             // Note that the pop, push can not be optimized     
                                        // as long as any of the MUL_OVF use ECALL (which
                                        // can cause GC)  When the helpers use FCALL, we
                                        // can optimize this
            TYPE_SWITCH_INT(type, emit_MUL_OVF, ());
            fjit->pushOp(type);
            } break;

        case CEE_MUL_OVF_UN:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_LOGIC(fjit->topOp(), emit_MUL_OVF, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_DIV:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_DIV, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_DIV_UN:
            TYPE_SWITCH_LOGIC(fjit->topOp(), emit_DIV_UN, ());
            CHECK_POP_STACK(1);
            break;


        case CEE_REM:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_REM, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_REM_UN:
            TYPE_SWITCH_LOGIC(fjit->topOp(), emit_REM_UN, ());
            CHECK_POP_STACK(1);
            break;
        case CEE_LOCALLOC:
#ifdef _DEBUG
            didLocalAlloc = true;
#endif
            if (fjit->opStack_len != 1) {
                _ASSERTE(!"LOCALLOC with non-zero stack currently unsupported");
                FJIT_FAIL(CORJIT_INTERNALERROR);
            }
            emit_LOCALLOC(true,fjit->methodInfo->EHcount);
            /* @TODO: The following is an optimization, not sure if needed
            if(fjit->methodInfo->options & CORINFO_OPT_INIT_LOCALS) {
            emit_LOCALLOC(true);
            }
            else {
            emit_LOCALLOC(false);
            }
            */
            break;

        case CEE_NEG:
            CHECK_STACK(1)
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_NEG, ());
            break;

        CEE_OP_LD(LDIND_U1, 1, typeI4, NULL)
        CEE_OP_LD(LDIND_U2, 1, typeI4, NULL)
        CEE_OP_LD(LDIND_I1, 1, typeI4, NULL)
        CEE_OP_LD(LDIND_I2, 1, typeI4, NULL)
        CEE_OP_LD(LDIND_U4, 1, typeI4, NULL)
        CEE_OP_LD(LDIND_I4, 1, typeI4, NULL)
        CEE_OP_LD(LDIND_I8, 1, typeI8, NULL)
        CEE_OP_LD(LDIND_R4, 1, typeR8, NULL)    /* R4 is promoted to R8 on the stack */
        CEE_OP_LD(LDIND_R8, 1, typeR8, NULL)

        case CEE_LDIND_I:
            emit_LDIND_PTR();
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI);
            break;

        case CEE_LDIND_REF:
            emit_LDIND_PTR();
            CHECK_POP_STACK(1);
            fjit->pushOp(typeRef);
            break;

        CEE_OP(STIND_I1, 2)
        CEE_OP(STIND_I2, 2)
        CEE_OP(STIND_I4, 2)
        CEE_OP(STIND_I8, 2)
        DO_STIND_R4:
        CEE_OP(STIND_R4, 2)
        DO_STIND_R8:
        CEE_OP(STIND_R8, 2)
        CEE_OP(STIND_REF, 2)

        case CEE_STIND_I:
            emit_WIN32(emit_STIND_I4()) emit_WIN64(emit_STIND_I8());
            CHECK_POP_STACK(2);
            break;

        case CEE_LDC_I4_M1 :
        case CEE_LDC_I4_0 :
        case CEE_LDC_I4_1 :
        case CEE_LDC_I4_2 :
        case CEE_LDC_I4_3 :
        case CEE_LDC_I4_4 :
        case CEE_LDC_I4_5 :
        case CEE_LDC_I4_6 :
        case CEE_LDC_I4_7 :
        case CEE_LDC_I4_8 :
            i4 = (opcode - CEE_LDC_I4_0);
            _ASSERTE(-1 <= i4 && i4 <= 8);
            goto DO_CEE_LDC_I4;

        case CEE_LDC_I4_S:
            i4 = GET(inPtr, signed char);
            goto DO_CEE_LDC_I4;

        case CEE_LDC_I4:
            i4 = GET(inPtr, signed int);
            goto DO_CEE_LDC_I4;

            i4 = GET(inPtr, signed short);
DO_CEE_LDC_I4:
            emit_LDC_I4(i4);
            fjit->pushOp(typeI4);
            break;
        case CEE_LDC_I8:
            i8 = GET(inPtr, signed __int64);
            emit_LDC_I8(i8);
            fjit->pushOp(typeI8);
            break;

        case CEE_LDC_R4:
            i4 = *(int*)&GET(inPtr, float);
            emit_LDC_R4(i4);    
            fjit->pushOp(typeR8);   // R4 is immediately promoted to R8 on the IL stack
            break;
        case CEE_LDC_R8:
            i8 = *(__int64*)&GET(inPtr, double);
            emit_LDC_R8(i8);
            fjit->pushOp(typeR8);
            break;

        case CEE_LDNULL:
            emit_WIN32(emit_LDC_I4(0)) emit_WIN64(emit_LDC_I8(0));
            fjit->pushOp(typeRef);
            break;

        case CEE_LDLOCA_S:
            offset = GET(inPtr, unsigned char);
            goto DO_LDLOCA;

        case CEE_LDLOCA:
            offset = GET(inPtr, unsigned short);
DO_LDLOCA:
            _ASSERTE(offset < maxLocals);
            if (offset >= maxLocals)
                FJIT_FAIL(CORJIT_INTERNALERROR);

            varInfo = &localsMap[offset];
DO_LDVARA:
            emit_LDVARA(varInfo->offset);
            fjit->pushOp(typeI);
            break;

        case CEE_LDSTR: {
            token = GET(inPtr, unsigned int);
            void* literalHnd = m_IJitInfo->constructStringLiteral(scope,token,0);
            if (literalHnd == 0)
                FJIT_FAIL(CORJIT_INTERNALERROR);
            emit_WIN32(emit_LDC_I4(literalHnd)) emit_WIN64(emit_LDC_I8(literalHnd)) ;
            emit_LDIND_PTR();
            fjit->pushOp(typeRef);
            } break;

        CEE_OP(CPBLK, 3)
        CEE_OP(INITBLK, 3)

        case CEE_INITOBJ:
            token = GET(inPtr, unsigned int);
            if (!(targetClass = m_IJitInfo->findClass(scope,token,methodHandle))) {
                FJIT_FAIL(CORJIT_INTERNALERROR);
            }
            SizeOfClass = typeSizeInBytes(fjit->jitInfo, targetClass);
            emit_init_bytes(SizeOfClass);
            CHECK_POP_STACK(1);
            break;

        case CEE_CPOBJ:
            token = GET(inPtr, unsigned int);
            if (!(targetClass = m_IJitInfo->findClass(scope,token,methodHandle))) {
                FJIT_FAIL(CORJIT_INTERNALERROR);
            }
            emit_valClassCopy(fjit, targetClass, outPtr, inRegTOS);
            CHECK_POP_STACK(2);
            break;

        case CEE_LDOBJ: {
            token = GET(inPtr, unsigned int);
            if (!(targetClass = m_IJitInfo->findClass(scope,token,methodHandle))) {
                FJIT_FAIL(CORJIT_INTERNALERROR);
            }

            CorInfoType eeType = m_IJitInfo->asCorInfoType(targetClass);
			OpType retType(eeType, targetClass);

				// TODO: only bother with this for the small types.  Otherwise 
				// treating as a generic type is OK
			TYPE_SWITCH_PRECISE(retType, emit_LDIND, ());
            CHECK_POP_STACK(1);
			retType.toFPNormalizedType();
            fjit->pushOp(retType);
            }
            break;

        case CEE_STOBJ: {
            token = GET(inPtr, unsigned int);
            if (!(targetClass = m_IJitInfo->findClass(scope,token,methodHandle))) {
                FJIT_FAIL(CORJIT_INTERNALERROR);
            }

                // Since floats are promoted to F, have to treat them specially 
            CorInfoType eeType = m_IJitInfo->asCorInfoType(targetClass);
            if (eeType == CORINFO_TYPE_FLOAT)
                goto DO_STIND_R4;
            else if (eeType == CORINFO_TYPE_DOUBLE)
                goto DO_STIND_R8;
            
            emit_copyPtrAroundValClass(fjit, targetClass, outPtr, inRegTOS);
            emit_valClassStore(fjit, targetClass, outPtr, inRegTOS);
            emit_POP_PTR();     // also pop off original ptr
            CHECK_POP_STACK(2);
            } 
            break;

        case CEE_MKREFANY:
            token = GET(inPtr, unsigned int);
            if (!(targetClass = m_IJitInfo->findClass(scope,token,methodHandle))) {
                FJIT_FAIL(CORJIT_INTERNALERROR);
            }
            emit_MKREFANY(targetClass);
            CHECK_POP_STACK(1);
            fjit->pushOp(typeRefAny);
            break;

        case CEE_SIZEOF:
            token = GET(inPtr, unsigned int);
            if (!(targetClass = m_IJitInfo->findClass(scope,token,methodHandle))) {
                FJIT_FAIL(CORJIT_INTERNALERROR);
            }
            SizeOfClass = m_IJitInfo->getClassSize(targetClass);
            emit_WIN32(emit_LDC_I4(SizeOfClass)) emit_WIN64(emit_LDC_I8(SizeOfClass)) ;
            fjit->pushOp(typeI);
            break;

        case CEE_LEAVE_S:
            ilrel = GET(inPtr, signed char);
            goto DO_LEAVE;

        case CEE_LEAVE:
            ilrel = GET(inPtr, int);
DO_LEAVE: {
              unsigned exceptionCount = methodInfo->EHcount;
              CORINFO_EH_CLAUSE clause;
              unsigned nextIP = inPtr - inBuff;
              unsigned target = nextIP + ilrel;

                    // LEAVE clears the stack
              while (!fjit->isOpStackEmpty()) {
                  TYPE_SWITCH(fjit->topOp(), emit_POP, ());
                  fjit->popOp(1);
              }

              // the following code relies on the ordering of the Exception Info. Table to call the
              // endcatches and finallys in the right order (see Exception Spec. doc.)
              for (unsigned except = 0; except < exceptionCount; except++) 
              {
                  m_IJitInfo->getEHinfo(methodInfo->ftn, except, &clause);
                   
                  if (clause.Flags & CORINFO_EH_CLAUSE_FINALLY)
                  {
#ifdef _DEBUG
                      if (clause.HandlerOffset < nextIP && nextIP <= clause.HandlerOffset+clause.HandlerLength && 
                          !(clause.HandlerOffset <= target && target < clause.HandlerOffset+clause.HandlerLength))
                          _ASSERTE(!"Cannot leave from a finally!");
#endif
                      // we can't leave a finally; check if we are leaving the associated try
                      if (clause.TryOffset < nextIP && nextIP <= clause.TryOffset+clause.TryLength
                          && !(clause.TryOffset <= target && target < clause.TryOffset+clause.TryLength)) 
                      {
                          // call the finally
                          emit_call_opcode();
                          fjit->fixupTable->insert((void**) outPtr);
                          emit_jmp_address(clause.HandlerOffset);
                      }
                      continue;
                  }
                    
                  // if got here, this is neither a filter or a finally, so must be a catch handler
                  // if we are leaving the associated try, there's nothing to do 
                  // but if we are leaving the handler call endcatch
                  if (clause.HandlerOffset < nextIP && nextIP <= clause.HandlerOffset+clause.HandlerLength && 
                      !(clause.HandlerOffset <= target && target < clause.HandlerOffset+clause.HandlerLength))
                  {
                      emit_reset_storedTOS_in_JitGenerated_local();
                      emit_ENDCATCH();
                      controlContinue = false;                    
                  }

              }

          } goto DO_BR;

        case CEE_BR:
            ilrel = GET(inPtr, int);
DO_BR:
            if (ilrel < 0) {
                emit_trap_gc();
            }
            op = CEE_CondAlways;
            goto DO_JMP;
        case CEE_BR_S:
            ilrel = GET(inPtr, signed char);
            if (ilrel < 0) {
                emit_trap_gc();
            }
            op = CEE_CondAlways;
            goto DO_JMP;

DO_JMP:
            //add to label table
            fjit->labels.add(&inPtr[ilrel]-inBuff, fjit->opStack, fjit->opStack_len);
            if ((ilrel == 0) && (op == CEE_CondAlways)) {
                deregisterTOS;
                break;
            }

            if (ilrel < 0 ) {
                _ASSERTE((unsigned) (&inPtr[ilrel]-inBuff) >= 0);
                if (state[&inPtr[ilrel]-inBuff].isTOSInReg) {
                    enregisterTOS;
                }
                else {
                    deregisterTOS;
                }
                emit_jmp_opcode(op);
                address = fjit->mapping->pcFromIL(&inPtr[ilrel]-inBuff)+(unsigned)outBuff-(signed)(outPtr+sizeof(void*));
                emit_jmp_address(address);
            }
            else {
                _ASSERTE(&inPtr[ilrel]<(inBuff+len));
                _ASSERTE((&inPtr[ilrel]-inBuff) >= 0);
                state[&inPtr[ilrel]-inBuff].isJmpTarget = true;     //we mark fwd jmps as true
                deregisterTOS;
                state[&inPtr[ilrel]-inBuff].isTOSInReg = false;     //we always deregister on forward jmps
                emit_jmp_opcode(op);
                //address = fjit->mapping->pcFromIL(&inPtr[ilrel]-inBuff)+(unsigned)outBuff-(signed)(outPtr+sizeof(void*));
                //emit_jmp_address(address);
                fjit->fixupTable->insert((void**) outPtr);
                emit_jmp_address(&inPtr[ilrel]-inBuff);
            }
            if (op == CEE_CondAlways) {
                controlContinue = false;
            }
            break;

        case CEE_BRTRUE:
            ilrel = GET(inPtr, int);
            op = CEE_CondNotEq;
            goto DO_BR_boolean;
        case CEE_BRTRUE_S:
            ilrel = GET(inPtr, signed char);
            op = CEE_CondNotEq;
            goto DO_BR_boolean;
        case CEE_BRFALSE:
            ilrel = GET(inPtr, int);
            op = CEE_CondEq;
            goto DO_BR_boolean;
        case CEE_BRFALSE_S:
            ilrel = GET(inPtr, signed char);
            op = CEE_CondEq;
DO_BR_boolean:
            if (ilrel < 0) {
                emit_trap_gc();
            }
            if (fjit->topOp() == typeI8)
            {
                emit_testTOS_I8();
            }
            else
            {
                emit_testTOS();
            }
            CHECK_POP_STACK(1);
            goto DO_JMP;

        case CEE_CEQ:
            _ASSERTE(fjit->topOp() == fjit->topOp(1) || fjit->topOp().isPtr() == fjit->topOp(1).isPtr());
            TYPE_SWITCH_PTR(fjit->topOp(), emit_CEQ, ());
            CHECK_POP_STACK(2);
            fjit->pushOp(typeI4);
            break;

        case CEE_CGT:
            _ASSERTE(fjit->topOp() == fjit->topOp(1) || fjit->topOp().isPtr() == fjit->topOp(1).isPtr());
            TYPE_SWITCH_PTR(fjit->topOp(), emit_CGT, ());
            CHECK_POP_STACK(2);
            fjit->pushOp(typeI4);
            break;

        case CEE_CGT_UN:
            _ASSERTE(fjit->topOp() == fjit->topOp(1) || fjit->topOp().isPtr() == fjit->topOp(1).isPtr());
            TYPE_SWITCH_PTR(fjit->topOp(), emit_CGT_UN, ());
            CHECK_POP_STACK(2);
            fjit->pushOp(typeI4);
            break;


        case CEE_CLT:
            _ASSERTE(fjit->topOp() == fjit->topOp(1) || fjit->topOp().isPtr() == fjit->topOp(1).isPtr());
            TYPE_SWITCH_PTR(fjit->topOp(), emit_CLT, ());
            CHECK_POP_STACK(2);
            fjit->pushOp(typeI4);
            break;

        case CEE_CLT_UN:
            _ASSERTE(fjit->topOp() == fjit->topOp(1) || fjit->topOp().isPtr() == fjit->topOp(1).isPtr());
            TYPE_SWITCH_PTR(fjit->topOp(), emit_CLT_UN, ());
            CHECK_POP_STACK(2);
            fjit->pushOp(typeI4);
            break;

        case CEE_BEQ_S:
            ilrel = GET(inPtr, char);
            goto DO_CEE_BEQ;

        case CEE_BEQ:
            ilrel = GET(inPtr, int);
DO_CEE_BEQ:
            TYPE_SWITCH_Bcc(emit_CEQ,   // for I
                            emit_CEQ,   // for R
                            CEE_CondEq, // condition used for direct jumps
                            CEE_CondNotEq, // condition used when calling C<cond> helpers
                            true        // allow Ref and ByRef 
                            ); // Does not return

        case CEE_BNE_UN_S:
            ilrel = GET(inPtr, char);
            goto DO_CEE_BNE;

        case CEE_BNE_UN:
            ilrel = GET(inPtr, int);
DO_CEE_BNE:
            TYPE_SWITCH_Bcc(emit_CEQ,   // for I
                            emit_CEQ,   // for R
                            CEE_CondNotEq, // condition used for direct jumps
                            CEE_CondEq, // condition used when calling C<cond> helpers
                            true        // allow Ref and ByRef 
                            ); // Does not return



        case CEE_BGT_S:
            ilrel = GET(inPtr, char);
            goto DO_CEE_BGT;

        case CEE_BGT:
            ilrel = GET(inPtr, int);
DO_CEE_BGT:
            TYPE_SWITCH_Bcc(emit_CGT,   // for I
                            emit_CGT,   // for R
                            CEE_CondGt, // condition used for direct jumps
                            CEE_CondNotEq, // condition used when calling C<cond> helpers
                            false       // do not allow Ref and ByRef 
                            ); // Does not return



        case CEE_BGT_UN_S:
            ilrel = GET(inPtr, char);
            goto DO_CEE_BGT_UN;

        case CEE_BGT_UN:
            ilrel = GET(inPtr, int);
DO_CEE_BGT_UN:
            TYPE_SWITCH_Bcc(emit_CGT_UN,   // for I
                            emit_CGT_UN,   // for R
                            CEE_CondAbove, // condition used for direct jumps
                            CEE_CondNotEq, // condition used when calling C<cond> helpers
                            false       // do not allow Ref and ByRef 
                            ); // Does not return

        case CEE_BGE_S:
            ilrel = GET(inPtr, char);
            goto DO_CEE_BGE;

        case CEE_BGE:
            ilrel = GET(inPtr, int);
DO_CEE_BGE:
            TYPE_SWITCH_Bcc(emit_CLT,   // for I
                            emit_CLT_UN,   // for R
                            CEE_CondGtEq, // condition used for direct jumps
                            CEE_CondEq, // condition used when calling C<cond> helpers
                            false       // do not allow Ref and ByRef 
                            ); // Does not return

        case CEE_BGE_UN_S:
            ilrel = GET(inPtr, char);
            goto DO_CEE_BGE_UN;

        case CEE_BGE_UN:
            ilrel = GET(inPtr, int);
DO_CEE_BGE_UN:
            TYPE_SWITCH_Bcc(emit_CLT_UN,   // for I
                            emit_CLT,   // for R
                            CEE_CondAboveEq, // condition used for direct jumps
                            CEE_CondEq, // condition used when calling C<cond> helpers
                            false       // do not allow Ref and ByRef 
                            ); // Does not return

        case CEE_BLT_S:
            ilrel = GET(inPtr, char);
            goto DO_CEE_BLT;

        case CEE_BLT:
            ilrel = GET(inPtr, int);
DO_CEE_BLT:
            TYPE_SWITCH_Bcc(emit_CLT,   // for I
                            emit_CLT,   // for R
                            CEE_CondLt, // condition used for direct jumps
                            CEE_CondNotEq, // condition used when calling C<cond> helpers
                            false       // do not allow Ref and ByRef 
                            ); // Does not return


        case CEE_BLT_UN_S:
            ilrel = GET(inPtr, char);
            goto DO_CEE_BLT_UN;

        case CEE_BLT_UN:
            ilrel = GET(inPtr, int);
DO_CEE_BLT_UN:
            TYPE_SWITCH_Bcc(emit_CLT_UN,   // for I
                            emit_CLT_UN,   // for R
                            CEE_CondBelow, // condition used for direct jumps
                            CEE_CondNotEq, // condition used when calling C<cond> helpers
                            false       // do not allow Ref and ByRef 
                            ); // Does not return

        case CEE_BLE_S:
            ilrel = GET(inPtr, char);
            goto DO_CEE_BLE;

        case CEE_BLE:
            ilrel = GET(inPtr, int);
DO_CEE_BLE:
            TYPE_SWITCH_Bcc(emit_CGT,   // for I
                            emit_CGT_UN,   // for R
                            CEE_CondLtEq, // condition used for direct jumps
                            CEE_CondEq, // condition used when calling C<cond> helpers
                            false       // do not allow Ref and ByRef 
                            ); // Does not return

        case CEE_BLE_UN_S:
            ilrel = GET(inPtr, char);
            goto DO_CEE_BLE_UN;

        case CEE_BLE_UN:
            ilrel = GET(inPtr, int);
DO_CEE_BLE_UN:
            TYPE_SWITCH_Bcc(emit_CGT_UN,   // for I
                            emit_CGT,   // for R
                            CEE_CondBelowEq, // condition used for direct jumps
                            CEE_CondEq, // condition used when calling C<cond> helpers
                            false       // do not allow Ref and ByRef 
                            ); // Does not return

        case CEE_BREAK:
            emit_break_helper();
            break;

        case CEE_AND:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_LOGIC(fjit->topOp(), emit_AND, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_OR:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_LOGIC(fjit->topOp(), emit_OR, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_XOR:
            _ASSERTE(fjit->topOp() == fjit->topOp(1));
            if (fjit->topOp() != fjit->topOp(1))
                FJIT_FAIL(CORJIT_INTERNALERROR);

            TYPE_SWITCH_LOGIC(fjit->topOp(), emit_XOR, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_NOT:
            CHECK_STACK(1)
            TYPE_SWITCH_LOGIC(fjit->topOp(), emit_NOT, ());
            break;

        case CEE_SHR:
            _ASSERTE(fjit->topOp() == typeI4);
            if (fjit->topOp() != typeI4)
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_LOGIC(fjit->topOp(1), emit_SHR_S, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_SHR_UN:
            _ASSERTE(fjit->topOp() == typeI4);
            if (fjit->topOp() != typeI4)
                FJIT_FAIL(CORJIT_INTERNALERROR);

            TYPE_SWITCH_LOGIC(fjit->topOp(1), emit_SHR, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_SHL:
            _ASSERTE(fjit->topOp() == typeI4);
            if (fjit->topOp() != typeI4)
                FJIT_FAIL(CORJIT_INTERNALERROR);
            TYPE_SWITCH_LOGIC(fjit->topOp(1), emit_SHL, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_DUP:
            CHECK_STACK(1)
            TYPE_SWITCH(fjit->topOp(), emit_DUP, ());
            fjit->pushOp(fjit->topOp());
            break;
        case CEE_POP:
            TYPE_SWITCH(fjit->topOp(), emit_POP, ());
            CHECK_POP_STACK(1);
            break;

        case CEE_NOP:
            emit_il_nop();
            break;

        case CEE_LDARGA_S:
            offset = GET(inPtr, signed char);
            goto DO_LDARGA;

        case CEE_LDARGA:
            offset = GET(inPtr, unsigned short);
DO_LDARGA:
            if (offset >= maxArgs)
                FJIT_FAIL(CORJIT_INTERNALERROR);
            varInfo = &argsMap[offset];
            if (methodInfo->args.isVarArg() && !varInfo->isReg) {
                emit_VARARG_LDARGA(offset);
                fjit->pushOp(typeI);
                break;
            }
            goto DO_LDVARA;

        case CEE_REFANYVAL:
            token = GET(inPtr, unsigned __int32);
            if (!(targetClass = m_IJitInfo->findClass(scope,token,methodHandle))) {
                FJIT_FAIL(CORJIT_INTERNALERROR);
            }
            CHECK_POP_STACK(1);     // pop off the refany
            emit_WIN32(emit_LDC_I4(targetClass)) emit_WIN64(emit_LDC_I8(targetClass)) ;
            emit_REFANYVAL();
            fjit->pushOp(typeByRef);
            break;

        case CEE_REFANYTYPE:
            CHECK_POP_STACK(1);             // Pop off the Refany
            _ASSERTE(offsetof(CORINFO_RefAny, type) == sizeof(void*));      // Type is the second thing
            emit_WIN32(emit_POP_I4()) emit_WIN64(emit_POP_I8());        // Just pop off the data, leaving the type.  
            fjit->pushOp(typeI);
            break;

        case CEE_ARGLIST:
            // The varargs token is always the last item pushed, which is
            // argument 'closest' to the frame pointer
            _ASSERTE(methodInfo->args.isVarArg());
            emit_LDVARA(sizeof(prolog_frame));
            fjit->pushOp(typeI);
            break;

        case CEE_ILLEGAL:
            _ASSERTE(!"Unimplemented");
            break;

        case CEE_CALLI:
            token = GET(inPtr, unsigned int);   // token for sig of function
            m_IJitInfo->findSig(methodInfo->scope, token, &targetSigInfo);
            emit_save_TOS();        // squirel away the target ftn address
            emit_POP_PTR();         // and remove from stack
            CHECK_POP_STACK(1);

            _ASSERTE(!targetSigInfo.hasTypeArg());
            if ((targetSigInfo.callConv & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_STDCALL ||
                (targetSigInfo.callConv & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_C ||
                (targetSigInfo.callConv & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_THISCALL ||
                (targetSigInfo.callConv & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_FASTCALL)
            {
                // for now assume all __stdcall are to unmanaged target
                argBytes = buildCall(fjit, &targetSigInfo, &outPtr, &inRegTOS, CALLI_UNMGD);
                emit_restore_TOS(); //push the saved target ftn address
                inRegTOS = false; // and remove  from the stack
                // The target ftn address is already in SCRATCH_1,
                // and helper calls also use that for RELOCATABLE_CODE
                emit_call_memory_indirect((unsigned int)&FJit_pHlpPinvokeCalli);
            }
            else
            {
                argBytes = buildCall(fjit, &targetSigInfo, &outPtr, &inRegTOS, CALL_NONE);
                emit_restore_TOS(); //push the saved target ftn address
                emit_calli();
            }

            goto DO_PUSH_CALL_RESULT;

        case CEE_CALL: 
            {
            token = GET(inPtr, unsigned int);
            targetMethod = m_IJitInfo->findMethod(scope, token,methodHandle);
            if (!(targetMethod))
                FJIT_FAIL(CORJIT_INTERNALERROR) ; //_ASSERTE(targetMethod);

            DWORD methodAttribs;
            methodAttribs = m_IJitInfo->getMethodAttribs(targetMethod,methodHandle);
            if (methodAttribs & CORINFO_FLG_SECURITYCHECK)
            {
                TailCallForbidden = TRUE;
                if (MadeTailCall)
                { // we have already made a tailcall, so cleanup and jit this method again
                  if(cSequencePoints > 0)
                      cleanupSequencePoints(fjit->jitInfo,sequencePointOffsets);
                  fjit->resetContextState();
                  goto JitAgain;
                }
            }
            if (fjit->flags & CORJIT_FLG_PROF_CALLRET)
            {
                BOOL bHookFunction;
                UINT_PTR from = (UINT_PTR) m_IJitInfo->GetProfilingHandle(methodHandle, &bHookFunction);
                if (bHookFunction)
                {
                    UINT_PTR to = (UINT_PTR) m_IJitInfo->GetProfilingHandle(targetMethod, &bHookFunction);
                    if (bHookFunction) // check that the flag has not been over-ridden
                    {
                        deregisterTOS;
                        emit_LDC_I(to); 
                        emit_LDC_I(from); 
                        ULONG func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_CALL);
                        emit_callhelper_il(func); 
                    }
                }
            }

            m_IJitInfo->getMethodSig(targetMethod, &targetSigInfo);
            if (targetSigInfo.isVarArg())
                m_IJitInfo->findCallSiteSig(scope,token,&targetSigInfo);

            if (targetSigInfo.hasTypeArg())  
            {   
                void* typeParam = m_IJitInfo->getInstantiationParam (scope, token, 0);
                _ASSERTE(typeParam);
                emit_LDC_I(typeParam);                
            }
            argBytes = buildCall(fjit, &targetSigInfo, &outPtr, &inRegTOS, CALL_NONE);
            if (methodAttribs & CORINFO_FLG_DELEGATE_INVOKE)
            {
                CORINFO_EE_INFO info;
                m_IJitInfo->getEEInfo(&info);
                emit_invoke_delegate(info.offsetOfDelegateInstance,
                                     info.offsetOfDelegateFirstTarget);         
            }
            else
            {    
                InfoAccessType accessType = IAT_PVALUE;
                address = (unsigned) m_IJitInfo->getFunctionEntryPoint(targetMethod, &accessType);
                _ASSERTE(accessType == IAT_PVALUE);
                emit_callnonvirt(address);
            }
            }
            goto DO_PUSH_CALL_RESULT;

        case CEE_CALLVIRT:
            token = GET(inPtr, unsigned int);
            targetMethod = m_IJitInfo->findMethod(scope, token,methodHandle);
            if (!(targetMethod))
                FJIT_FAIL(CORJIT_INTERNALERROR) ; //_ASSERTE(targetMethod);
            DWORD methodAttribs;
            methodAttribs = m_IJitInfo->getMethodAttribs(targetMethod,methodHandle);
            if (methodAttribs & CORINFO_FLG_SECURITYCHECK)
            {
                TailCallForbidden = TRUE;
                if (MadeTailCall)
                { // we have already made a tailcall, so cleanup and jit this method again
                  if(cSequencePoints > 0)
                      cleanupSequencePoints(fjit->jitInfo,sequencePointOffsets);
                  fjit->resetContextState();
                  goto JitAgain;
                }
            }

            if (!(targetClass = m_IJitInfo->getMethodClass (targetMethod)))
                FJIT_FAIL(CORJIT_INTERNALERROR);

            if (fjit->flags & CORJIT_FLG_PROF_CALLRET)
            {
                BOOL bHookFunction;
                UINT_PTR from = (UINT_PTR) m_IJitInfo->GetProfilingHandle(methodHandle, &bHookFunction);
                if (bHookFunction)
                {
                    UINT_PTR to = (UINT_PTR) m_IJitInfo->GetProfilingHandle(targetMethod, &bHookFunction);
                    if (bHookFunction) // check that the flag has not been over-ridden
                    {
                        deregisterTOS;
                        emit_LDC_I(from); 
                        emit_LDC_I(to); 
                        ULONG func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_CALL);
                        emit_callhelper_il(func); 
                    }
                }
            }

            m_IJitInfo->getMethodSig(targetMethod, &targetSigInfo);
            if (targetSigInfo.isVarArg())
                m_IJitInfo->findCallSiteSig(scope,token,&targetSigInfo);

            if (targetSigInfo.hasTypeArg())  
            {   
                void* typeParam = m_IJitInfo->getInstantiationParam (scope, token, 0);
                _ASSERTE(typeParam);
                emit_LDC_I(typeParam);                
            }

            argBytes = buildCall(fjit, &targetSigInfo, &outPtr, &inRegTOS, CALL_NONE);

            if (m_IJitInfo->getClassAttribs(targetClass,methodHandle) & CORINFO_FLG_INTERFACE) 
            {
                offset = m_IJitInfo->getMethodVTableOffset(targetMethod);
                //@TODO: Need to support EnC for callvirt to interface methods
                _ASSERTE(!(methodAttribs & CORINFO_FLG_EnC));
                //@BUG: the call interface resolve helper does not protect the args on the stack for the call
                //       so the code here needs to be changed
                unsigned InterfaceTableOffset;
                InterfaceTableOffset = m_IJitInfo->getInterfaceTableOffset(targetClass);
                emit_callinterface_new(fjit->OFFSET_OF_INTERFACE_TABLE,
                                       InterfaceTableOffset*4, 
                                       offset);
            }
            else if (methodAttribs & CORINFO_FLG_EnC) 
            {
                if ((methodAttribs & CORINFO_FLG_FINAL) || !(methodAttribs & CORINFO_FLG_VIRTUAL))
                {
                    emit_checkthis_nullreference();
                }
                emit_call_EncVirtualMethod(targetMethod);
            
            }
            else 
            {
                if ((methodAttribs & CORINFO_FLG_FINAL) || !(methodAttribs & CORINFO_FLG_VIRTUAL)) {
                    emit_checkthis_nullreference();

                    InfoAccessType accessType = IAT_PVALUE;
                    address = (unsigned) m_IJitInfo->getFunctionEntryPoint(targetMethod, &accessType);
                    _ASSERTE(accessType == IAT_PVALUE);
                    if (methodAttribs & CORINFO_FLG_DELEGATE_INVOKE) {
                            // @todo: cache these values?
                            CORINFO_EE_INFO info;
                            m_IJitInfo->getEEInfo(&info);
                            emit_invoke_delegate(info.offsetOfDelegateInstance, 
                                                 info.offsetOfDelegateFirstTarget);
                    }
                    else {
                        emit_callnonvirt(address);
                    }
                }
                else
                {
                    offset = m_IJitInfo->getMethodVTableOffset(targetMethod);
                    _ASSERTE(!(methodAttribs & CORINFO_FLG_DELEGATE_INVOKE));
                    emit_callvirt(offset);
                }
            }
DO_PUSH_CALL_RESULT:
            _ASSERTE(argBytes != 0xBADF00D);    // need to set this before getting here
            if (targetSigInfo.isVarArg())
                emit_drop(argBytes);
            if (targetSigInfo.retType != CORINFO_TYPE_VOID) {
                OpType type(targetSigInfo.retType, targetSigInfo.retTypeClass);
                TYPE_SWITCH_PRECISE(type,emit_pushresult,());
                if (!targetSigInfo.hasRetBuffArg()) // return buff logged in buildCall
                {
                    type.toFPNormalizedType();
                    fjit->pushOp(type);
                }
            }
            
            if (fjit->flags & CORJIT_FLG_PROF_CALLRET)
            {
                BOOL bHookFunction;
                UINT_PTR thisfunc = (UINT_PTR) m_IJitInfo->GetProfilingHandle(methodHandle, &bHookFunction);
                if (bHookFunction) // check that the flag has not been over-ridden
                {
                    deregisterTOS;
                    emit_LDC_I(thisfunc); 
                    ULONG func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_RET);
                    emit_callhelper_il(func);
                }
            }
            break;

        case CEE_CASTCLASS: 
            token = GET(inPtr, unsigned int);
            if (!(targetClass = m_IJitInfo->findClass(scope, token,methodHandle)))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            helper_ftn = m_IJitInfo->getHelperFtn(m_IJitInfo->getChkCastHelper(targetClass));
            _ASSERTE(helper_ftn);
            CHECK_POP_STACK(1);         // Note that this pop /push can not be optimized because there is a 
                                    // call to an EE helper, and the stack tracking has to be accurate
                                    // at that point
            emit_CASTCLASS(targetClass, helper_ftn);
            fjit->pushOp(typeRef);

            break;

        case CEE_CONV_I1:
            _ASSERTE(fjit->topOp() != typeByRef); 
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_TOI1, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        case CEE_CONV_I2:
            _ASSERTE(fjit->topOp() != typeByRef); 
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_TOI2, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

            emit_WIN32(case CEE_CONV_I:)
        case CEE_CONV_I4:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_TOI4, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        case CEE_CONV_U1:
            _ASSERTE(fjit->topOp() != typeByRef); 
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_TOU1, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        case CEE_CONV_U2:
            _ASSERTE(fjit->topOp() != typeByRef); 
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_TOU2, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

            emit_WIN32(case CEE_CONV_U:)
        case CEE_CONV_U4:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_TOU4, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

            emit_WIN64(case CEE_CONV_I:)
        case CEE_CONV_I8:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_TOI8, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI8);
            break;

            emit_WIN64(case CEE_CONV_U:)
        case CEE_CONV_U8:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_TOU8, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI8);
            break;

        case CEE_CONV_R4:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_TOR4, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeR8);   // R4 is immediately promoted to R8
            break;

        case CEE_CONV_R8:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_TOR8, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeR8);
            break;

        case CEE_CONV_R_UN:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_UN_TOR, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeR8);
            break;

        case CEE_CONV_OVF_I1:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_TOI1, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        case CEE_CONV_OVF_U1:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_TOU1, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        case CEE_CONV_OVF_I2:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_TOI2, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        case CEE_CONV_OVF_U2:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_TOU2, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        emit_WIN32(case CEE_CONV_OVF_I:)
        case CEE_CONV_OVF_I4:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_TOI4, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        emit_WIN32(case CEE_CONV_OVF_U:)
        case CEE_CONV_OVF_U4:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_TOU4, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        emit_WIN64(case CEE_CONV_OVF_I:)
        case CEE_CONV_OVF_I8:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_TOI8, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI8);
            break;

        emit_WIN64(case CEE_CONV_OVF_U:)
        case CEE_CONV_OVF_U8:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_TOU8, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI8);
            break;

        case CEE_CONV_OVF_I1_UN:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_UN_TOI1, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        case CEE_CONV_OVF_U1_UN:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_UN_TOU1, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        case CEE_CONV_OVF_I2_UN:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_UN_TOI2, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        case CEE_CONV_OVF_U2_UN:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_UN_TOU2, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        emit_WIN32(case CEE_CONV_OVF_I_UN:)
        case CEE_CONV_OVF_I4_UN:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_UN_TOI4, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        emit_WIN32(case CEE_CONV_OVF_U_UN:)
        case CEE_CONV_OVF_U4_UN:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_UN_TOU4, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI4);
            break;

        emit_WIN64(case CEE_CONV_OVF_I_UN:)
        case CEE_CONV_OVF_I8_UN:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_UN_TOI8, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI8);
            break;

        emit_WIN64(case CEE_CONV_OVF_U_UN:)
        case CEE_CONV_OVF_U8_UN:
            TYPE_SWITCH_ARITH(fjit->topOp(), emit_CONV_OVF_UN_TOU8, ());
            CHECK_POP_STACK(1);
            fjit->pushOp(typeI8);
            break;

        case CEE_LDTOKEN: {
            token = GET(inPtr, unsigned int);   // Get token for class/interface
            CORINFO_GENERIC_HANDLE hnd;
            CORINFO_CLASS_HANDLE tokenType;
            if (!(hnd = m_IJitInfo->findToken(scope, token,methodHandle,tokenType)))
                FJIT_FAIL(CORJIT_INTERNALERROR);

            emit_WIN32(emit_LDC_I4(hnd)) emit_WIN64(emit_LDC_I8(hnd));
            fjit->pushOp(typeI);
            } break;

        case CEE_BOX: {
            token = GET(inPtr, unsigned int);   // Get token for class/interface
            if (!(targetClass = m_IJitInfo->findClass(scope, token,methodHandle)))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            if (!(m_IJitInfo->getClassAttribs(targetClass,methodHandle) & CORINFO_FLG_VALUECLASS)) 
                FJIT_FAIL(CORJIT_INTERNALERROR);

                // Floats were promoted, put them back before continuing. 
            CorInfoType eeType = m_IJitInfo->asCorInfoType(targetClass);
            if (eeType == CORINFO_TYPE_FLOAT) {
                emit_conv_RtoR4();
            } 
            else if (eeType == CORINFO_TYPE_DOUBLE) {
                emit_conv_RtoR8();
            }

            unsigned vcSize = typeSizeInSlots(m_IJitInfo, targetClass) * sizeof(void*);
            emit_BOXVAL(targetClass, vcSize);

            CHECK_POP_STACK(1);
            fjit->pushOp(typeRef);
            } break;

        case CEE_UNBOX:
            token = GET(inPtr, unsigned int);   // Get token for class/interface
            if (!(targetClass = m_IJitInfo->findClass(scope, token,methodHandle)))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            //_ASSERTE(m_IJitInfo->getClassAttribs(targetClass,methodHandle) & CORINFO_FLG_VALUECLASS);
            if (!(m_IJitInfo->getClassAttribs(targetClass,methodHandle) & CORINFO_FLG_VALUECLASS))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            CHECK_POP_STACK(1);
            emit_UNBOX(targetClass);
            fjit->pushOp(typeByRef);
            break;

        case CEE_ISINST:
            token = GET(inPtr, unsigned int);   // Get token for class/interface
            if (!(targetClass = m_IJitInfo->findClass(scope, token,methodHandle)))
                FJIT_FAIL(CORJIT_INTERNALERROR);
            helper_ftn = m_IJitInfo->getHelperFtn(m_IJitInfo->getIsInstanceOfHelper(targetClass));
            _ASSERTE(helper_ftn);
            CHECK_POP_STACK(1);
            emit_ISINST(targetClass, helper_ftn);
            fjit->pushOp(typeRef);
            break;

        case CEE_JMP: {
            token = GET(inPtr, unsigned int);
            targetMethod = m_IJitInfo->findMethod(scope, token,methodHandle);
            if (!(targetMethod))
                FJIT_FAIL(CORJIT_INTERNALERROR) ; //_ASSERTE(targetMethod);

            InfoAccessType accessType = IAT_PVALUE;
            address = (unsigned) m_IJitInfo->getFunctionEntryPoint(targetMethod, &accessType);
            _ASSERTE(accessType == IAT_PVALUE);
            _ASSERTE(fjit->isOpStackEmpty());
            if (!(fjit->isOpStackEmpty()))
                FJIT_FAIL(CORJIT_INTERNALERROR);
#ifdef _DEBUG
            // @TODO: Compare signatures of current method and called method
            //        for now just check count and return type
            //m_IJitInfo->getMethodSig(targetMethod, &targetSigInfo);
            //_ASSERTE(targetSigInfo->numArgs == fjit->methodInfo->args->numArgs);
            //_ASSERTE(targetSigInfo->retType == fjit->methodInfo->args->retType);
#endif

            // Notify the profiler of a tailcall/jmpcall
            if (fjit->flags & CORJIT_FLG_PROF_ENTERLEAVE)
            {
                BOOL bHookFunction;
                UINT_PTR thisfunc = (UINT_PTR) m_IJitInfo->GetProfilingHandle(methodHandle, &bHookFunction);
                if (bHookFunction)
                {
                    _ASSERTE(!inRegTOS);
                    emit_LDC_I(thisfunc); 
                    ULONG func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_TAILCALL);
                    _ASSERTE(func != NULL);
                    emit_callhelper_il(func); 
                }
            }

            emit_prepare_jmp();
            emit_jmp_absolute(* (unsigned *)address);
            } break;

        CEE_OP_LD(LDELEM_U1, 2, typeI4, NULL)
        CEE_OP_LD(LDELEM_U2, 2, typeI4, NULL)
        CEE_OP_LD(LDELEM_I1, 2, typeI4, NULL)
        CEE_OP_LD(LDELEM_I2, 2, typeI4, NULL)
        CEE_OP_LD(LDELEM_I4, 2, typeI4, NULL)
        CEE_OP_LD(LDELEM_U4, 2, typeI4, NULL)
        CEE_OP_LD(LDELEM_I8, 2, typeI8, NULL)
        CEE_OP_LD(LDELEM_R4, 2, typeR8, NULL)   /* R4 is promoted to R8 on the stack */ 
        CEE_OP_LD(LDELEM_R8, 2, typeR8, NULL)
        CEE_OP_LD(LDELEM_REF, 2, typeRef, NULL)


        case CEE_LDELEMA: {
            token = GET(inPtr, unsigned int);   // Get token for class/interface
            if (!(targetClass = m_IJitInfo->findClass(scope, token,methodHandle)))
                FJIT_FAIL(CORJIT_INTERNALERROR);

                // assume it is an array of pointers
            unsigned size = sizeof(void*);
            if (m_IJitInfo->getClassAttribs(targetClass,methodHandle) & CORINFO_FLG_VALUECLASS) {
                size = m_IJitInfo->getClassSize(targetClass);
                targetClass = 0;        // zero means type field before array elements
            }
            emit_LDELEMA(size, targetClass);
            CHECK_POP_STACK(2);
            fjit->pushOp(typeByRef);
            } break;

        case CEE_LDELEM_I:
            emit_WIN32(emit_LDELEM_I4()) emit_WIN64(emit_LDELEM_I8());
            CHECK_POP_STACK(2);
            fjit->pushOp(typeI);
            break;

        case CEE_LDSFLD:
        case CEE_LDFLD: 
            {
            token = GET(inPtr, unsigned int);   // Get MemberRef token for object field
            if(!(targetField = m_IJitInfo->findField (scope, token,methodHandle))) {
                FJIT_FAIL(CORJIT_INTERNALERROR);
            }
            fieldAttributes = m_IJitInfo->getFieldAttribs(targetField,methodHandle);
            BOOL isTLSfield = fieldAttributes & CORINFO_FLG_TLS; 

            CORINFO_CLASS_HANDLE valClass;
            jitType = m_IJitInfo->getFieldType(targetField, &valClass);
            fieldIsStatic =  (fieldAttributes & CORINFO_FLG_STATIC) ? true : false;
            if(!(targetClass = m_IJitInfo->getFieldClass(targetField))) // targetClass is the enclosing class
                FJIT_FAIL(CORJIT_INTERNALERROR);

            if (fieldIsStatic)
            {
                emit_initclass(targetClass);
            }
            
            OpType fieldType(jitType, valClass);
            OpType type;
            if (opcode == CEE_LDFLD) 
            {
                type = fjit->topOp();
                CHECK_POP_STACK(1); 
                if (fieldIsStatic) {
                    // we don't need this pointer 
                    if (type.isValClass()) 
                    {
                        emit_drop(typeSizeInSlots(m_IJitInfo, type.cls()) * sizeof(void*));
                    }
                    else 
                    {
                        emit_POP_PTR();
                    }
                } 
                else
                {
                    if (type.isValClass()) {        // the object itself is a value class
                        fjit->pushOp(type);         // we are going to leave it on the stack
                        emit_getSP(0);              // push pointer to object
                    }
                }
            }
                
            if(fieldAttributes & (CORINFO_FLG_HELPER | CORINFO_FLG_SHARED_HELPER)) 
            {
                _ASSERTE(!isTLSfield);          // cant have both bits set
                LABELSTACK((outPtr-outBuff),0); // Note this can be removed if these become fcalls

                if (fieldIsStatic)                  // static fields go through pointer
                {
                        // Load up the address of the static
                    CorInfoHelpFunc helperNum = m_IJitInfo->getFieldHelper(targetField, CORINFO_ADDRESS);
                    void* helperFunc = m_IJitInfo->getHelperFtn(helperNum,NULL);
                    emit_helperarg_1(targetField); 
                    emit_callhelper(helperFunc,0);
                    emit_pushresult_I4();

                        // do the indirection
                    trackedType = fieldType;
                    goto DO_LDIND_BYTYPE;
                }
                else {
                    // get the helper
                    CorInfoHelpFunc helperNum = m_IJitInfo->getFieldHelper(targetField, CORINFO_GET);
                    void* helperFunc = m_IJitInfo->getHelperFtn(helperNum,NULL);
                    _ASSERTE(helperFunc);

                    switch (jitType) 
                    {
                        case CORINFO_TYPE_BYTE:
                        case CORINFO_TYPE_BOOL:
                        case CORINFO_TYPE_CHAR:
                        case CORINFO_TYPE_SHORT:
                        case CORINFO_TYPE_INT:
                        emit_WIN32(case CORINFO_TYPE_PTR:)
                        case CORINFO_TYPE_UBYTE:
                        case CORINFO_TYPE_USHORT:
                        case CORINFO_TYPE_UINT:
                            emit_LDFLD_helper(helperFunc,targetField);
                            emit_pushresult_I4();
                            break;
                        case CORINFO_TYPE_FLOAT:
                            emit_LDFLD_helper(helperFunc,targetField);
                            emit_pushresult_R4();   
                            break;
                        emit_WIN64(case CORINFO_TYPE_PTR:)
                        case CORINFO_TYPE_LONG:
                        case CORINFO_TYPE_ULONG:
                            emit_LDFLD_helper(helperFunc,targetField);
                            emit_pushresult_I8();
                            break;
                        case CORINFO_TYPE_DOUBLE:
                            emit_LDFLD_helper(helperFunc,targetField);
                            emit_pushresult_R8();
                            emit_conv_R8toR();
                            break;
                        case CORINFO_TYPE_CLASS:
                            emit_LDFLD_helper(helperFunc,targetField);
                            emit_pushresult_I4();
                            break;
                        case CORINFO_TYPE_VALUECLASS: {
                            emit_mov_TOS_arg(1);    // obj => arg reg 2

                                // allocate return buff, zeroing to make valid GC poitners
                            int slots = typeSizeInSlots(m_IJitInfo, valClass);
                            while (slots > 0) {
                                emit_LDC_I4(0);
                                --slots;
                            }
                            fjit->pushOp(fieldType);
                            emit_getSP(0);
                            emit_mov_TOS_arg(0);        // retBuff => arg reg 2
                            emit_LDC_I(targetField);    // fieldDesc on the stack
                            LABELSTACK((outPtr-outBuff),0); // Note this can be removed if these become fcalls
                            emit_callhelper(helperFunc,0);
                            CHECK_POP_STACK(1);             // pop  return value
                            } break;
                        default:
                            FJIT_FAIL(CORJIT_INTERNALERROR);
                            break;
                    }              
                }
            }
            // else no helper for this field
            else {
                bool isEnCField = (fieldAttributes & CORINFO_FLG_EnC) ? true : false;
                if (fieldIsStatic) 
                {
                    if (isTLSfield)
                    {
                        DWORD tlsIndex = (DWORD)m_IJitInfo->getFieldThreadLocalStoreID(targetField,NULL);
                        DWORD fieldOffset = m_IJitInfo->getFieldOffset(targetField);
                        emit_TLSfieldAddress(TLS_OFFSET, tlsIndex, fieldOffset);
                    }
                    else
                    {
                        if (!(address = (unsigned) m_IJitInfo->getFieldAddress(targetField)))
                            FJIT_FAIL(CORJIT_INTERNALERROR);
                        emit_pushconstant_Ptr(address);
                    }
                }
                else // field is not static
                {
                    if (opcode == CEE_LDSFLD)
                        FJIT_FAIL(CORJIT_INTERNALERROR);
                    if (isEnCField)
                    {
                        emit_call_EncLDFLD_GetFieldAddress(targetField);
                    }
                    else
                    {
                        address = m_IJitInfo->getFieldOffset(targetField);
                        emit_pushconstant_Ptr(address);
                    }
                    _ASSERTE(opcode == CEE_LDFLD); //if (opcode == CEE_LDFLD)                   
                }
                
                switch (jitType) {
                case CORINFO_TYPE_BYTE:
                case CORINFO_TYPE_BOOL:
                    emit_LDFLD_I1((fieldIsStatic || isEnCField));
                    break;
                case CORINFO_TYPE_SHORT:
                    emit_LDFLD_I2((fieldIsStatic || isEnCField));
                    break;
                case CORINFO_TYPE_INT:
                    emit_LDFLD_I4((fieldIsStatic || isEnCField));
                    break;
                case CORINFO_TYPE_FLOAT:
                    emit_LDFLD_R4((fieldIsStatic || isEnCField));
                    break;
                case CORINFO_TYPE_UBYTE:
                    emit_LDFLD_U1((fieldIsStatic || isEnCField));
                    break;
                case CORINFO_TYPE_CHAR:
                case CORINFO_TYPE_USHORT:
                    emit_LDFLD_U2((fieldIsStatic || isEnCField));
                    break;
                emit_WIN32(case CORINFO_TYPE_PTR:)
                case CORINFO_TYPE_UINT:
                    emit_LDFLD_U4((fieldIsStatic || isEnCField));
                    break;
                emit_WIN64(case CORINFO_TYPE_PTR:)
                case CORINFO_TYPE_ULONG:
                case CORINFO_TYPE_LONG:
                    emit_LDFLD_I8((fieldIsStatic || isEnCField));
                    break;
                case CORINFO_TYPE_DOUBLE:
                    emit_LDFLD_R8((fieldIsStatic || isEnCField));
                    break;
                case CORINFO_TYPE_CLASS:
                    emit_LDFLD_REF((fieldIsStatic || isEnCField));
                    break;
                case CORINFO_TYPE_VALUECLASS:
                    if (fieldIsStatic)
                    {
                        if ( !(fieldAttributes & CORINFO_FLG_UNMANAGED) && 
                             !(m_IJitInfo->getClassAttribs(targetClass,methodHandle) & CORINFO_FLG_UNMANAGED)) 
                        {
                            // @TODO : This is a hack. Access the boxed object, and then add 4
                            emit_LDFLD_REF(true);
                            emit_LDC_I4(sizeof(void*));
                            emit_WIN32(emit_ADD_I4()) emit_WIN64(emit_ADD_I8());
                        }
                    }
                    else if (!isEnCField) {
                        _ASSERTE(!isTLSfield);
                        emit_WIN32(emit_ADD_I4()) emit_WIN64(emit_ADD_I8(0));
                    }
                    emit_valClassLoad(fjit, valClass, outPtr, inRegTOS);
                    break;
                default:
                    FJIT_FAIL(CORJIT_INTERNALERROR);
                    break;
                }

            }
            if (!fieldIsStatic && type.isValClass()) {
                // at this point things are not quite right, the problem
                // is that we did not pop the original value class.  Thus
                // the stack is (..., obj, field), and we just want (..., field)
                // This code does the fixup. 
                CHECK_POP_STACK(1);   
                unsigned fieldSize;
                if (jitType == CORINFO_TYPE_VALUECLASS) 
                    fieldSize = typeSizeInSlots(m_IJitInfo, valClass) * sizeof(void*);
                else 
                    fieldSize = fjit->computeArgSize(jitType, 0, 0);
                if (jitType == CORINFO_TYPE_FLOAT)
                    fieldSize += sizeof(double) - sizeof(float);    // adjust for the fact that the float is promoted to double on the IL stack
                unsigned objSize = typeSizeInSlots(m_IJitInfo, type.cls())*sizeof(void*);
                
                if (fieldSize <= sizeof(void*) && inRegTOS) {
                    emit_drop(objSize);     // just get rid of the obj
                    _ASSERTE(inRegTOS);     // make certain emit_drop does not deregister
                }
                else {
                    deregisterTOS;
                    emit_mov_arg_stack(objSize, 0, fieldSize);
                    emit_drop(objSize);
                }
            }            
            fieldType.toFPNormalizedType();
            fjit->pushOp(fieldType);
            }
            break;

            case CEE_LDFLDA:
            case CEE_LDSFLDA: {
                token = GET(inPtr, unsigned int);   // Get MemberRef token for object field
                if(!(targetField = m_IJitInfo->findField (scope, token,methodHandle))) {
                    FJIT_FAIL(CORJIT_INTERNALERROR);
                }
                fieldAttributes = m_IJitInfo->getFieldAttribs(targetField,methodHandle);
                if(!(targetClass = m_IJitInfo->getFieldClass(targetField))) {
                    FJIT_FAIL(CORJIT_INTERNALERROR);
                }
                DWORD classAttribs = m_IJitInfo->getClassAttribs(targetClass,methodHandle);
                fieldIsStatic = fieldAttributes & CORINFO_FLG_STATIC ? true : false;

                if (opcode == CEE_LDFLDA) 
                    CHECK_POP_STACK(1);
                if (fieldIsStatic) 
                {
                    if (opcode == CEE_LDFLDA) 
                    {
                        emit_POP_PTR();
                    }
                    emit_initclass(targetClass);

                    BOOL isTLSfield = fieldAttributes & CORINFO_FLG_TLS;
                    if (isTLSfield)
                    {
                        _ASSERTE((fieldAttributes & CORINFO_FLG_HELPER) == 0);  // can't have both bits at the same time
                        _ASSERTE((fieldAttributes & CORINFO_FLG_EnC) == 0);

                        DWORD tlsIndex =(DWORD) m_IJitInfo->getFieldThreadLocalStoreID(targetField,NULL);
                        DWORD fieldOffset = m_IJitInfo->getFieldOffset(targetField);
                        emit_TLSfieldAddress(TLS_OFFSET, tlsIndex, fieldOffset);
                    }
                    else if (fieldAttributes & (CORINFO_FLG_HELPER | CORINFO_FLG_SHARED_HELPER))
                    {
                        _ASSERTE((fieldAttributes & CORINFO_FLG_EnC) == 0);
                        // get the helper
                        CorInfoHelpFunc helperNum = m_IJitInfo->getFieldHelper(targetField,CORINFO_ADDRESS);
                        void* helperFunc = m_IJitInfo->getHelperFtn(helperNum,NULL);
                        _ASSERTE(helperFunc);
                        emit_helperarg_1(targetField);
                        emit_callhelper(helperFunc,0);
                        emit_pushresult_I4();
                    }
                    else
                    {
                        if(!(address = (unsigned) m_IJitInfo->getFieldAddress(targetField)))
                            FJIT_FAIL(CORJIT_INTERNALERROR);
                        emit_pushconstant_Ptr(address);

                        CORINFO_CLASS_HANDLE fieldClass;
                        jitType = m_IJitInfo->getFieldType(targetField, &fieldClass);
                        if (jitType == CORINFO_TYPE_VALUECLASS && !(fieldAttributes & CORINFO_FLG_UNMANAGED) && !(classAttribs & CORINFO_FLG_UNMANAGED)) {
                            // @TODO : This is a hack. Access the boxed object, and then add 4
                            emit_LDFLD_REF(true);
                            emit_LDC_I4(sizeof(void*));
                            emit_WIN32(emit_ADD_I4()) emit_WIN64(emit_ADD_I8());
                        }
                    }
                }
                else 
                {
                    if (opcode == CEE_LDSFLDA) 
                    {
                        FJIT_FAIL(CORJIT_INTERNALERROR);
                    }
                    if (fieldAttributes & CORINFO_FLG_EnC)
                    {
                        _ASSERTE((fieldAttributes & CORINFO_FLG_HELPER) == 0);  // can't have both bits at the same time
                        emit_call_EncLDFLD_GetFieldAddress(targetField);
                    }
                    else if (fieldAttributes & (CORINFO_FLG_HELPER | CORINFO_FLG_SHARED_HELPER))
                    {
                        LABELSTACK((outPtr-outBuff),0);
                        // get the helper
                        CorInfoHelpFunc helperNum = m_IJitInfo->getFieldHelper(targetField,CORINFO_ADDRESS);
                        void* helperFunc = m_IJitInfo->getHelperFtn(helperNum,NULL);
                        _ASSERTE(helperFunc);
                        emit_LDFLD_helper(helperFunc,targetField);
                        emit_pushresult_I4();
                    }
                    else
                    {
                        address = m_IJitInfo->getFieldOffset(targetField);
                        emit_check_TOS_null_reference();
                        emit_pushconstant_Ptr(address);
                        emit_WIN32(emit_ADD_I4()) emit_WIN64(emit_ADD_I8());
                    }
                }
                fjit->pushOp(((classAttribs & CORINFO_FLG_UNMANAGED) || (fieldAttributes & CORINFO_FLG_UNMANAGED)) ? typeI : typeByRef);
                break;
            }

            case CEE_STSFLD:
            case CEE_STFLD: {
                token = GET(inPtr, unsigned int);   // Get MemberRef token for object field
                if (!(targetField = m_IJitInfo->findField (scope, token, methodHandle)))
                    FJIT_FAIL(CORJIT_INTERNALERROR);
                
                fieldAttributes = m_IJitInfo->getFieldAttribs(targetField,methodHandle);
                CORINFO_CLASS_HANDLE valClass;
                jitType = m_IJitInfo->getFieldType(targetField, &valClass);
                fieldIsStatic = fieldAttributes & CORINFO_FLG_STATIC ? true : false;

                if (fieldIsStatic) 
                {
                    if(!(targetClass = m_IJitInfo->getFieldClass(targetField))) 
                    {
                        FJIT_FAIL(CORJIT_INTERNALERROR);
                    }
                    emit_initclass(targetClass);
                }

                if (fieldAttributes & (CORINFO_FLG_HELPER | CORINFO_FLG_SHARED_HELPER))
                {
                    if (fieldIsStatic)                  // static fields go through pointer
                    {
                        CorInfoHelpFunc helperNum = m_IJitInfo->getFieldHelper(targetField, CORINFO_ADDRESS);
                        void* helperFunc = m_IJitInfo->getHelperFtn(helperNum,NULL);
                        emit_helperarg_1(targetField);
                        LABELSTACK((outPtr-outBuff),0);
                        emit_callhelper(helperFunc,0);
                        emit_pushresult_I4();
                        trackedType = OpType(jitType, valClass);
                        trackedType.toNormalizedType();
                        if (trackedType.toInt() == typeRef)
                        {
                            emit_STIND_REV_Ref(opcode == CEE_STSFLD);
                        }
                        else
                        {
                            TYPE_SWITCH(trackedType, emit_STIND_REV, ());
                        }
                        CHECK_POP_STACK(1);             // pop value 
                        if (opcode == CEE_STFLD)
                            CHECK_POP_STACK(1);         // pop object pointer
                    }
                    else 
                    {
                        // get the helper
                        CorInfoHelpFunc helperNum = m_IJitInfo->getFieldHelper(targetField,CORINFO_SET);
                        void* helperFunc = m_IJitInfo->getHelperFtn(helperNum,NULL);
                        _ASSERTE(helperFunc);

                        unsigned fieldSize;
                        switch (jitType)
                        {
                            case CORINFO_TYPE_FLOAT:            // since on the IL stack we always promote floats to doubles
                                emit_conv_RtoR4();
                                // Fall through
                            case CORINFO_TYPE_BYTE:
                            case CORINFO_TYPE_BOOL:
                            case CORINFO_TYPE_CHAR:
                            case CORINFO_TYPE_SHORT:
                            case CORINFO_TYPE_INT:
                            case CORINFO_TYPE_UBYTE:
                            case CORINFO_TYPE_USHORT:
                            case CORINFO_TYPE_UINT:
                            emit_WIN32(case CORINFO_TYPE_PTR:)
                                fieldSize = sizeof(INT32);
                                goto DO_PRIMITIVE_HELPERCALL;
                            case CORINFO_TYPE_DOUBLE:
                            case CORINFO_TYPE_LONG:
                            case CORINFO_TYPE_ULONG:
                            emit_WIN64(case CORINFO_TYPE_PTR:)
                                fieldSize = sizeof(INT64);
                                goto DO_PRIMITIVE_HELPERCALL;
                            case CORINFO_TYPE_CLASS:
                                fieldSize = sizeof(INT32);

                            DO_PRIMITIVE_HELPERCALL:
                                CHECK_POP_STACK(1);             // pop value 
                                if (opcode == CEE_STFLD)
                                    CHECK_POP_STACK(1);         // pop object pointer

                                LABELSTACK((outPtr-outBuff),0); 
                                if (opcode == CEE_STFLD)
                                {
                                    emit_STFLD_NonStatic_field_helper(targetField,fieldSize,helperFunc);
                                }
                                else
                                {
                                    emit_STFLD_Static_field_helper(targetField,fieldSize,helperFunc);
                                }
                                break;
                            case CORINFO_TYPE_VALUECLASS: {
                                emit_copyPtrAroundValClass(fjit, valClass, outPtr, inRegTOS);
                                emit_mov_TOS_arg(0);            // obj => arg reg 1

                                emit_helperarg_2(targetField);  // fieldDesc => arg reg 2

                                emit_getSP(0);                  // arg 3 == pointer to value class
                                LABELSTACK((outPtr-outBuff),0); 
                                emit_callhelper(helperFunc,0);

                                    // Pop off the value class and the object pointer
                                int slots = typeSizeInSlots(m_IJitInfo, valClass);
                                emit_drop((slots + 1) * sizeof(void*)); // value class and pointer

                                CHECK_POP_STACK(1);             // pop value class
                                if (opcode == CEE_STFLD)
                                    CHECK_POP_STACK(1);         // pop object pointer
                                } break;
                            default:
                                FJIT_FAIL(CORJIT_INTERNALERROR);
                                break;
                        }
                    }
                }
                else /* not a special field */
                {
                    DWORD isTLSfield = fieldAttributes & CORINFO_FLG_TLS;
                    bool isEnCField = (fieldAttributes & CORINFO_FLG_EnC) ? true : false;
                    if (fieldIsStatic)
                    {
                        if (!isTLSfield)
                        {
                            if (!(address = (unsigned) m_IJitInfo->getFieldAddress(targetField))) {
                                FJIT_FAIL(CORJIT_INTERNALERROR);
                            }
                        }
                    }
                    else {
                        if (opcode == CEE_STSFLD) {
                            FJIT_FAIL(CORJIT_INTERNALERROR);
                        }
                        address = m_IJitInfo->getFieldOffset(targetField);
                    }
                    

                    CORINFO_CLASS_HANDLE fieldClass;
                    CorInfoType fieldType = m_IJitInfo->getFieldType(targetField, &fieldClass);
                    // This needs to be done before the address computation for TLS fields
                    if (fieldType == CORINFO_TYPE_FLOAT)
                    {
                        emit_conv_RtoR4();      
                    }
                    else 
                    {
                        if (fieldType == CORINFO_TYPE_DOUBLE)
                            emit_conv_RtoR8();
                    }
                    if (isTLSfield)
                    {
                        DWORD tlsIndex = (DWORD)m_IJitInfo->getFieldThreadLocalStoreID(targetField,NULL);
                        DWORD fieldOffset = m_IJitInfo->getFieldOffset(targetField);
                        emit_TLSfieldAddress(TLS_OFFSET, tlsIndex, fieldOffset);
                    }
                    else
                    {
                        if (isEnCField && !fieldIsStatic)
                        {
                            unsigned fieldSize;
                            fieldSize = fieldType == CORINFO_TYPE_VALUECLASS ? 
                                           typeSizeInBytes(m_IJitInfo,valClass) :
                                           typeSize[fieldType];
                            emit_call_EncSTFLD_GetFieldAddress(targetField,fieldSize);
                        }
                        else
                        {
                            emit_pushconstant_Ptr(address);
                        }
                    }
                    CHECK_POP_STACK(1);             // pop value 
                    if (opcode == CEE_STFLD)
                        CHECK_POP_STACK(1);         // pop object pointer
                    
                    switch (fieldType) {
                    case CORINFO_TYPE_UBYTE:
                    case CORINFO_TYPE_BYTE:
                    case CORINFO_TYPE_BOOL:
                        emit_STFLD_I1((fieldIsStatic || isEnCField));
                        break;
                    case CORINFO_TYPE_SHORT:
                    case CORINFO_TYPE_USHORT:
                    case CORINFO_TYPE_CHAR:
                        emit_STFLD_I2((fieldIsStatic || isEnCField));
                        break;

                    emit_WIN32(case CORINFO_TYPE_PTR:)
                    case CORINFO_TYPE_UINT:
                    case CORINFO_TYPE_INT:
                        emit_STFLD_I4((fieldIsStatic || isEnCField));
                        break;
                    case CORINFO_TYPE_FLOAT:
                        emit_STFLD_R4((fieldIsStatic || isEnCField));
                        break;
                    emit_WIN64(case CORINFO_TYPE_PTR:)
                    case CORINFO_TYPE_ULONG:
                    case CORINFO_TYPE_LONG:
                        emit_STFLD_I8((fieldIsStatic || isEnCField));
                        break;
                    case CORINFO_TYPE_DOUBLE:
                        emit_STFLD_R8((fieldIsStatic || isEnCField));
                        break;
                    case CORINFO_TYPE_CLASS:
                        emit_STFLD_REF((fieldIsStatic || isEnCField));
                        break;
                    case CORINFO_TYPE_VALUECLASS:
                        if (fieldIsStatic)
                        {
                            if ( !(fieldAttributes & CORINFO_FLG_UNMANAGED) && 
                                 !(m_IJitInfo->getClassAttribs(targetClass,methodHandle) & CORINFO_FLG_UNMANAGED)) 
                            {
                                // @TODO : This is a hack. Access the boxed object, and then add 4
                                emit_LDFLD_REF(true);
                                emit_LDC_I4(sizeof(void*));
                                emit_WIN32(emit_ADD_I4()) emit_WIN64(emit_ADD_I8());
                            }
                            emit_valClassStore(fjit, valClass, outPtr, inRegTOS);
                        }
                        else if (!isEnCField)
                        {
                            _ASSERTE(inRegTOS); // we need to undo the pushConstant_ptr since it needs to be after the emit_copyPtrAroundValClass 
                            inRegTOS = false;
                            emit_copyPtrAroundValClass(fjit, valClass, outPtr, inRegTOS);
                            emit_pushconstant_Ptr(address);
                            emit_WIN32(emit_ADD_I4()) emit_WIN64(emit_ADD_I8());
                            emit_valClassStore(fjit, valClass, outPtr, inRegTOS);
                            emit_POP_PTR();         // also pop off original ptr
                        }
                        else // non-static EnC field
                        {
                            _ASSERTE(inRegTOS); // address of valclass field
                            emit_valClassStore(fjit,valClass,outPtr,inRegTOS);
                        }
                        break;
                    default:
                        FJIT_FAIL(CORJIT_INTERNALERROR);
                        break;
                    }

                    if (isEnCField && !fieldIsStatic)   {               // also for EnC fields, we use a helper to get the address, so the THIS pointer is unused
                        emit_POP_PTR();
                    }
                }   /* else, not a special field */

                if (opcode == CEE_STFLD && fieldIsStatic) {     // using STFLD on a static, we have a unused THIS pointer
                    emit_POP_PTR();
                }
                } break;

            case CEE_LDFTN: {
                token = GET(inPtr, unsigned int);   // token for function
                targetMethod = m_IJitInfo->findMethod(scope, token, methodHandle);
                if (!(targetMethod))
                    FJIT_FAIL(CORJIT_INTERNALERROR) ; //_ASSERTE(targetMethod);
            DO_LDFTN:
                InfoAccessType accessType = IAT_VALUE;
                address = (unsigned) m_IJitInfo->getFunctionFixedEntryPoint(targetMethod, &accessType);
                if (accessType != IAT_VALUE || address == 0)
                    FJIT_FAIL(CORJIT_INTERNALERROR);
                _ASSERTE((m_IJitInfo->getMethodSig(targetMethod, &targetSigInfo), !targetSigInfo.hasTypeArg()));
                emit_WIN32(emit_LDC_I4(address)) emit_WIN64(emit_LDC_I8(address));
                fjit->pushOp(typeI);
                } break;

            CEE_OP_LD(LDLEN, 1, typeI4, NULL);

            case CEE_LDVIRTFTN:
                token = GET(inPtr, unsigned int);   // token for function
                if (!(targetMethod = m_IJitInfo->findMethod(scope, token, methodHandle)))
                    FJIT_FAIL(CORJIT_INTERNALERROR);
                if (!(targetClass = m_IJitInfo->getMethodClass (targetMethod)))
                    FJIT_FAIL(CORJIT_INTERNALERROR);
                _ASSERTE((m_IJitInfo->getMethodSig(targetMethod, &targetSigInfo), !targetSigInfo.hasTypeArg()));
                methodAttribs = m_IJitInfo->getMethodAttribs(targetMethod,methodHandle);
                DWORD classAttribs;
                classAttribs = m_IJitInfo->getClassAttribs(targetClass,methodHandle);

                if ((methodAttribs & CORINFO_FLG_FINAL) || !(methodAttribs & CORINFO_FLG_VIRTUAL)) 
                {
                    emit_POP_I4();      // Don't need this pointer
                    CHECK_POP_STACK(1);
                    goto DO_LDFTN;
                }

                if (methodAttribs & CORINFO_FLG_EnC && !(classAttribs & CORINFO_FLG_INTERFACE))
                {
                    _ASSERTE(!"LDVIRTFTN for EnC NYI");
                }
                else
                {
                    offset = m_IJitInfo->getMethodVTableOffset(targetMethod);
                    if (classAttribs & CORINFO_FLG_INTERFACE) {
                        unsigned InterfaceTableOffset;
                        InterfaceTableOffset = m_IJitInfo->getInterfaceTableOffset(targetClass);
                        emit_ldvtable_address_new(fjit->OFFSET_OF_INTERFACE_TABLE,
                                                  InterfaceTableOffset*4, 
                                                  offset);

                    }
                    else {
                        emit_ldvirtftn(offset);
                    }
                }
                CHECK_POP_STACK(1);
                fjit->pushOp(typeI);
                break;

            case CEE_NEWARR:
                token = GET(inPtr, unsigned int);   // token for element type
                if (!(targetClass = m_IJitInfo->findClass(scope, token, methodHandle)))
                    FJIT_FAIL(CORJIT_INTERNALERROR);
                    // convert to the array class for this element type
                targetClass = m_IJitInfo->getSDArrayForClass(targetClass);
                _ASSERTE(targetClass);
                CHECK_POP_STACK(1);
                emit_NEWOARR(targetClass);
                fjit->pushOp(typeRef);
                break;

             case CEE_NEWOBJ:
                unsigned int targetMethodAttributes;
                unsigned int targetClassAttributes;

                unsigned int targetCallStackSize;
                token = GET(inPtr, unsigned int);       // MemberRef token for constructor
                targetMethod = m_IJitInfo->findMethod(scope, token, methodHandle);
                if (!(targetMethod))
                    FJIT_FAIL(CORJIT_INTERNALERROR) ;      //_ASSERTE(targetMethod);
                if(!(targetClass = m_IJitInfo->getMethodClass (targetMethod))) {
                    FJIT_FAIL(CORJIT_INTERNALERROR);
                }
                targetClassAttributes = m_IJitInfo->getClassAttribs(targetClass,methodHandle);

                m_IJitInfo->getMethodSig(targetMethod, &targetSigInfo);
                _ASSERTE(!targetSigInfo.hasTypeArg());
                targetMethodAttributes = m_IJitInfo->getMethodAttribs(targetMethod,methodHandle);
                if (targetClassAttributes & CORINFO_FLG_ARRAY) {

                    //_ASSERTE(targetClassAttributes & CORINFO_FLG_VAROBJSIZE);
                    if (!(targetClassAttributes & CORINFO_FLG_VAROBJSIZE))
                        FJIT_FAIL(CORJIT_INTERNALERROR);
                    // allocate md array
                    //@TODO: this needs to change when the JIT helpers are fixed
                    targetSigInfo.callConv = CORINFO_CALLCONV_VARARG;
                    //@TODO: alloate stackItems on the stack;
                    argInfo* tempMap = new argInfo[targetSigInfo.numArgs];
                    if(tempMap == NULL)
                        FJIT_FAIL(CORJIT_OUTOFMEM);
                    targetCallStackSize = fjit->computeArgInfo(&targetSigInfo, tempMap, 0);
                    delete tempMap;
                    CHECK_POP_STACK(targetSigInfo.numArgs);
                    emit_NEWOBJ_array(scope, token, targetCallStackSize);
                    fjit->pushOp(typeRef);

                }
                else if (targetClassAttributes & CORINFO_FLG_VAROBJSIZE) {
                    // variable size objects that are not arrays, e.g. string
                    // call the constructor with a null `this' pointer
                    emit_WIN32(emit_LDC_I4(0)) emit_WIN64(emit_LDC_I8(0));
                    fjit->pushOp(typeI4);
                    InfoAccessType accessType = IAT_PVALUE;
                    address = (unsigned) m_IJitInfo->getFunctionEntryPoint(targetMethod, &accessType);
                    _ASSERTE(accessType == IAT_PVALUE);
                    m_IJitInfo->getMethodSig(targetMethod, &targetSigInfo);
                    targetSigInfo.retType = CORINFO_TYPE_CLASS;
                    //targetSigInfo.retTypeClass = targetClass;
                    argBytes = buildCall(fjit, &targetSigInfo, &outPtr, &inRegTOS, CALL_THIS_LAST);
                    emit_callnonvirt(address);
                    goto DO_PUSH_CALL_RESULT;
                }
                else if (targetClassAttributes & CORINFO_FLG_VALUECLASS) {
                        // This acts just like a static method that returns a value class
                    targetSigInfo.retTypeClass = targetClass;
                    targetSigInfo.retType = CORINFO_TYPE_VALUECLASS;
                    targetSigInfo.callConv = CorInfoCallConv(targetSigInfo.callConv & ~CORINFO_CALLCONV_HASTHIS);

                    argBytes = buildCall(fjit, &targetSigInfo, &outPtr, &inRegTOS, CALL_NONE);

                    InfoAccessType accessType = IAT_PVALUE;
                    address = (unsigned) m_IJitInfo->getFunctionEntryPoint(targetMethod, &accessType);
                    _ASSERTE(accessType == IAT_PVALUE);
                    emit_callnonvirt(address);
                }
                else {
                    //allocate normal object
                    helper_ftn = m_IJitInfo->getHelperFtn(m_IJitInfo->getNewHelper(targetClass, methodInfo->ftn));
                    _ASSERTE(helper_ftn);
                    //fjit->pushOp(typeRef); we don't do this and compensate for it in the popOp down below
                    emit_NEWOBJ(targetClass, helper_ftn);
                    fjit->pushOp(typeRef);

                    emit_save_TOS();        //squirrel the newly created object away; will be reported in FJit_EETwain
                    //note: the newobj is still on TOS
                    argBytes = buildCall(fjit, &targetSigInfo, &outPtr, &inRegTOS, CALL_THIS_LAST);
                    InfoAccessType accessType = IAT_PVALUE;
                    address = (unsigned) m_IJitInfo->getFunctionEntryPoint(targetMethod, &accessType);
                    _ASSERTE(accessType == IAT_PVALUE);
                    emit_callnonvirt(address);
                    if (targetSigInfo.isVarArg())
                        emit_drop(argBytes);
                    emit_restore_TOS(); //push the new obj back on TOS
                    fjit->pushOp(typeRef);
                }
                break;


            case CEE_ENDFILTER:
                emit_loadresult_I4();   // put top of stack in the return register

                // Fall through
            case CEE_ENDFINALLY:
                controlContinue = false;
                emit_reset_storedTOS_in_JitGenerated_local();
                emit_ret(0);
                break;

            case CEE_RET:
#if 0       // IF we disallow rets inside trys turn this on

                {       // make certain we are not in a try block
                CORINFO_EH_CLAUSE clause;
                unsigned nextIP = inPtr - inBuff;
              
                for (unsigned except = 0; except < methodInfo->EHcount; except++) {
                    m_IJitInfo->getEHinfo(methodInfo->ftn, except, &clause);
                    if (clause.StartOffset < nextIP && nextIP <= clause.EndOffset) {
                        _ASSERTE(!"Return inside of a try block");
                        FJIT_FAIL(CORJIT_INTERNALERROR);
                    }
                       
                }
                }
#endif 
                // TODO put this code in the epilog
#ifdef LOGGING
                if (codeLog) {
                    emit_log_exit(szDebugClassName, szDebugMethodName);
                }
#endif
                if (methodAttributes & CORINFO_FLG_SYNCH) {
                    LEAVE_CRIT;
                }

#ifdef _DEBUG
                if (!didLocalAlloc) {
                    unsigned retSlots;
                    if (methodInfo->args.retType == CORINFO_TYPE_VALUECLASS) 
                        retSlots = typeSizeInSlots(fjit->jitInfo, methodInfo->args.retTypeClass);
                    else 
                    {
                        retSlots = fjit->computeArgSize(methodInfo->args.retType, 0, 0) / sizeof(void*);
                        if (methodInfo->args.retType == CORINFO_TYPE_FLOAT)
                            retSlots += (sizeof(double) - sizeof(float))/sizeof(void*); // adjust for the fact that the float is promoted to double on the IL stack
                    }
                    emit_stack_check(localWords + retSlots);
                }
#endif // _DEBUG
                
                if (methodInfo->args.retType != CORINFO_TYPE_VOID) {
                    OpType type(methodInfo->args.retType, methodInfo->args.retTypeClass);
                    TYPE_SWITCH_PRECISE(type, emit_loadresult, ());
                    CHECK_POP_STACK(1);
                }
                /*At this point, the result, if any must have been loaded via a
                emit_loadresult_()<type>. In this case we violate the restriction that forward
                jumps must have deregistered the TOS.  We just don't care, as long as the result
                is in the right place. */
                if (inPtr != &inBuff[len]) {
                    //we have more il to do, so branch to epilog
                    emit_jmp_opcode(CEE_CondAlways);
                    fjit->fixupTable->insert((void**) outPtr);
                    emit_jmp_address(len);
                    controlContinue = false;
                }
                break;

            CEE_OP(STELEM_I1, 3)
            CEE_OP(STELEM_I2, 3)
            CEE_OP(STELEM_I4, 3)
            CEE_OP(STELEM_I8, 3)
            CEE_OP(STELEM_R4, 3)
            CEE_OP(STELEM_R8, 3)
            CEE_OP(STELEM_REF, 3)
            

            case CEE_STELEM_I:
                emit_WIN64(emit_STELEM_I8()) emit_WIN32(emit_STELEM_I4());
                CHECK_POP_STACK(3);
                break;


            case CEE_CKFINITE:
                _ASSERTE(fjit->topOp().enum_() == typeR8);
                emit_CKFINITE_R8();
                break;

                case CEE_SWITCH:
                    unsigned int limit;
                    unsigned int ilTableOffset;
                    unsigned int ilNext;
                    unsigned char* saveInPtr;
                    saveInPtr = inPtr;
                    limit = GET(inPtr, unsigned int);

                    // insert a GC check if there is a backward branch
                    while (limit-- > 0)
                    {
                        ilrel = GET(inPtr, signed int);
                        if (ilrel < 0)
                        {
                            emit_trap_gc();
                            break;
                        }
                    }
                    inPtr = saveInPtr;

                    limit = GET(inPtr, unsigned int);
                    ilTableOffset = inPtr - inBuff;
                    ilNext = ilTableOffset + limit*4;
                    _ASSERTE(ilNext < len);             // len = IL size
                    emit_pushconstant_4(limit);         
                    emit_SWITCH(limit);
                    CHECK_POP_STACK(1);

                    //mark the start of the il branch table
                    fjit->mapping->add(ilTableOffset, (unsigned) (outPtr - outBuff));
                    //add switch index out of bounds target to label table
                    fjit->labels.add(ilNext, fjit->opStack, fjit->opStack_len);


                    while (limit-- > 0) {
                        ilrel = GET(inPtr, signed int);

                        //add each switch table target to label table
                        fjit->labels.add(ilNext+ilrel, fjit->opStack, fjit->opStack_len);

                        
                        if (ilrel < 0                           // backward jump
                            && state[ilNext+ilrel].isTOSInReg)  // the dest has enregistered TOS
                        {
                            FJIT_FAIL(CORJIT_INTERNALERROR);
                        }
                        emit_jmp_opcode(CEE_CondAlways);
                        fjit->fixupTable->insert((void**) outPtr);
                        emit_jmp_address(ilNext+ilrel);
                    }
                    emit_jmp_opcode(CEE_CondAlways);
                    fjit->fixupTable->insert((void**) outPtr);
                    emit_jmp_address(ilNext);
                    controlContinue = false;
                    _ASSERTE(inPtr == ilNext+inBuff);
                    break;


                case CEE_THROW:
                    emit_THROW();
                    controlContinue = false;
                    break;

                case CEE_RETHROW:
                    emit_RETHROW();
                    controlContinue = false;
                    break;

                case CEE_TAILCALL:
                    if (TailCallForbidden)
                        break;  // just ignore the prefix
                    unsigned char* savedInPtr;
                    savedInPtr = inPtr;
                    opcode = OPCODE(GET(inPtr, unsigned char));
#ifdef LOGGING
                    if (codeLog && opcode != CEE_PREFIXREF && (opcode > CEE_PREFIX1 || opcode < CEE_PREFIX7)) {
                        bool oldstate = inRegTOS;
                        emit_log_opcode(ilrel, opcode, oldstate);
                        inRegTOS = oldstate;
                    }
#endif
                    // Determine if tailcall is allowed
                    bool thisTailCallAllowed; // 
                    if (opcode == CEE_CALL)
                    {
                        token = GET(inPtr, unsigned int);
                        targetMethod = m_IJitInfo->findMethod(scope, token, methodHandle);
                        if (!(targetMethod))
                            FJIT_FAIL(CORJIT_INTERNALERROR) ; //_ASSERTE(targetMethod);
                        thisTailCallAllowed = m_IJitInfo->canTailCall(methodHandle,targetMethod);
                    }
                    else 
                        thisTailCallAllowed = m_IJitInfo->canTailCall(methodHandle,NULL);
                    if (!thisTailCallAllowed)
                    {
                        // we don't have to rejit, but we need to ignore the tailcall prefix for this call
                        inPtr = savedInPtr; 
                        break;
                    }
                    
                    switch (opcode)
                    {
                    case CEE_CALLI:
                        token = GET(inPtr, unsigned int);   // token for sig of function
                        m_IJitInfo->findSig(methodInfo->scope, token, &targetSigInfo);
                        // we don't support tailcall on vararg in v1
                        if ((targetSigInfo.callConv  & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_VARARG)
                        {
                            inPtr = savedInPtr;
                            goto IGNORE_TAILCALL;
                        }
                        MadeTailCall = TRUE;
                        emit_save_TOS();        //squirel away the target ftn address
                        emit_POP_PTR();     //  and remove from stack
                        _ASSERTE(!targetSigInfo.hasTypeArg());
                        argBytes = buildCall(fjit, &targetSigInfo, &outPtr, &inRegTOS, CALL_NONE);
                        emit_setup_tailcall(methodInfo->args,targetSigInfo);
                        emit_restore_TOS(); //push the saved target ftn address
                        emit_callhelper_il(FJit_pHlpTailCall);         

                        break;
                    case CEE_CALL:
                        m_IJitInfo->getMethodSig(targetMethod, &targetSigInfo);
                        // we don't support tailcall on vararg in v1
                        if ((targetSigInfo.callConv  & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_VARARG)
                        {
                            inPtr = savedInPtr;
                            goto IGNORE_TAILCALL;
                        }
                        MadeTailCall = TRUE;
                        if (fjit->flags & CORJIT_FLG_PROF_CALLRET)
                        {
                            BOOL bHookFunction;
                            UINT_PTR from = (UINT_PTR) m_IJitInfo->GetProfilingHandle(methodHandle, &bHookFunction);
                            if (bHookFunction)
                            {
                                UINT_PTR to = (UINT_PTR) m_IJitInfo->GetProfilingHandle(targetMethod, &bHookFunction);
                                if (bHookFunction) // check that the flag has not been over-ridden
                                {
                                    deregisterTOS;
                                    emit_LDC_I(from);
                                    ULONG func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_CALL);
                                    emit_callhelper_il(func); 
                                    emit_LDC_I(from); 
                                    emit_LDC_I(to); 
                                    func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_RET);
                                    emit_callhelper_il(func); 
                                } 
                            }
                        }

                        // Need to notify profiler of Tailcall so that it can maintain accurate shadow stack
                        if (fjit->flags & CORJIT_FLG_PROF_ENTERLEAVE)
                        {
                            BOOL bHookFunction;
                            UINT_PTR from = (UINT_PTR) m_IJitInfo->GetProfilingHandle(methodHandle, &bHookFunction);
                            if (bHookFunction)
                            {
                                deregisterTOS;
                                _ASSERTE(!inRegTOS);
                                emit_LDC_I(from);
                                ULONG func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_TAILCALL);
                                emit_callhelper_il(func); 
                            }
                        }

                        if (targetSigInfo.hasTypeArg())  
                        {   
                            // FIX NOW: this is the wrong class handle 
                            if (!(targetClass = m_IJitInfo->getMethodClass (targetMethod)))
                                FJIT_FAIL(CORJIT_INTERNALERROR);
                            emit_LDC_I(targetClass);                
                        }
                        argBytes = buildCall(fjit, &targetSigInfo, &outPtr, &inRegTOS, CALL_NONE);// push count of old arguments
                        emit_setup_tailcall(methodInfo->args,targetSigInfo);
                        DWORD methodAttribs;
                        methodAttribs = m_IJitInfo->getMethodAttribs(targetMethod,methodHandle);
                        if (methodAttribs & CORINFO_FLG_DELEGATE_INVOKE)
                        {
                            CORINFO_EE_INFO info;
                            m_IJitInfo->getEEInfo(&info);
                            emit_compute_invoke_delegate(info.offsetOfDelegateInstance, 
                                                         info.offsetOfDelegateFirstTarget);
                        }
                        else
                        {
                            InfoAccessType accessType = IAT_PVALUE;
                            address = (unsigned) m_IJitInfo->getFunctionEntryPoint(targetMethod, &accessType);
                            _ASSERTE(accessType == IAT_PVALUE);
                            emit_LDC_I(*(unsigned*)address);
                        }
                        emit_callhelper_il(FJit_pHlpTailCall);
                        break;
                    case CEE_CALLVIRT:
                        token = GET(inPtr, unsigned int);
                        targetMethod = m_IJitInfo->findMethod(scope, token, methodHandle);
                        if (!(targetMethod))
                            FJIT_FAIL(CORJIT_INTERNALERROR) ; //_ASSERTE(targetMethod);
                        if (!(targetClass = m_IJitInfo->getMethodClass (targetMethod)))
                            FJIT_FAIL(CORJIT_INTERNALERROR);

                        m_IJitInfo->getMethodSig(targetMethod, &targetSigInfo);
                        // we don't support tailcall on vararg in v1
                        if ((targetSigInfo.callConv  & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_VARARG)
                        {
                            inPtr = savedInPtr;
                            goto IGNORE_TAILCALL;
                        }
                        MadeTailCall = TRUE;
                        if (fjit->flags & CORJIT_FLG_PROF_CALLRET)
                        {
                            BOOL bHookFunction;
                            UINT_PTR from = (UINT_PTR) m_IJitInfo->GetProfilingHandle(methodHandle, &bHookFunction);
                            if (bHookFunction)
                            {
                                UINT_PTR to = (UINT_PTR) m_IJitInfo->GetProfilingHandle(targetMethod, &bHookFunction);
                                if (bHookFunction) // check that the flag has not been over-ridden
                                {
                                    deregisterTOS;
                                    emit_LDC_I(from);
                                    ULONG func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_CALL);
                                    emit_callhelper_il(func);
                                    emit_LDC_I(from); 
                                    emit_LDC_I(to); 
                                    func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_RET);
                                    emit_callhelper_il(func); 
                                } 
                            }
                        }

                        // Need to notify profiler of Tailcall so that it can maintain accurate shadow stack
                        if (fjit->flags & CORJIT_FLG_PROF_ENTERLEAVE)
                        {
                            BOOL bHookFunction;
                            UINT_PTR from = (UINT_PTR) m_IJitInfo->GetProfilingHandle(methodHandle, &bHookFunction);
                            if (bHookFunction)
                            {
                                deregisterTOS;
                                _ASSERTE(!inRegTOS);
                                emit_LDC_I(from);
                                ULONG func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_TAILCALL);
                                emit_callhelper_il(func); 
                            }
                        }

                        if (targetSigInfo.hasTypeArg())  
                        {   
                            // FIX NOW: this is the wrong class handle 
                            if (!(targetClass = m_IJitInfo->getMethodClass (targetMethod)))
                                FJIT_FAIL(CORJIT_INTERNALERROR);
                            emit_LDC_I(targetClass);                
                        }
                        argBytes = buildCall(fjit, &targetSigInfo, &outPtr, &inRegTOS, CALL_NONE);

                        if (m_IJitInfo->getClassAttribs(targetClass,methodHandle) & CORINFO_FLG_INTERFACE) {
                            offset = m_IJitInfo->getMethodVTableOffset(targetMethod);
                            emit_setup_tailcall(methodInfo->args,targetSigInfo);
                            unsigned InterfaceTableOffset;
                            InterfaceTableOffset = m_IJitInfo->getInterfaceTableOffset(targetClass);
                            emit_compute_interface_new(fjit->OFFSET_OF_INTERFACE_TABLE,
                                                   InterfaceTableOffset*4, 
                                                   offset);
                            emit_callhelper_il(FJit_pHlpTailCall);
                            
                        }
                        else {
                            DWORD methodAttribs;
                            methodAttribs = m_IJitInfo->getMethodAttribs(targetMethod,methodHandle);
                            if ((methodAttribs & CORINFO_FLG_FINAL) || !(methodAttribs & CORINFO_FLG_VIRTUAL)) {
                                emit_checkthis_nullreference();
                                emit_setup_tailcall(methodInfo->args,targetSigInfo);
                                if (methodAttribs & CORINFO_FLG_DELEGATE_INVOKE) {
                                    // @todo: cache these values?
                                    CORINFO_EE_INFO info;
                                    m_IJitInfo->getEEInfo(&info);
                                    emit_compute_invoke_delegate(info.offsetOfDelegateInstance, 
                                                             info.offsetOfDelegateFirstTarget);
                                }
                                else {
                                    InfoAccessType accessType = IAT_PVALUE;
                                    address = (unsigned) m_IJitInfo->getFunctionEntryPoint(targetMethod, &accessType);
                                    _ASSERTE(accessType == IAT_PVALUE);
                                    emit_LDC_I(*(unsigned*)address);
                               }
                                emit_callhelper_il(FJit_pHlpTailCall);
                            }
                            else
                            {
                                offset = m_IJitInfo->getMethodVTableOffset(targetMethod);
                                _ASSERTE(!(methodAttribs & CORINFO_FLG_DELEGATE_INVOKE));
                                emit_setup_tailcall(methodInfo->args,targetSigInfo);
                                emit_compute_virtaddress(offset);
                                emit_callhelper_il(FJit_pHlpTailCall);
                            }
                        }
                        break;
                    default:
                        FJIT_FAIL(CORJIT_INTERNALERROR);       // should be a different error message
                        break;
                    } // switch (opcode) for tailcall
                    goto DO_PUSH_CALL_RESULT;
IGNORE_TAILCALL:
                    break;
                  
                    case CEE_UNALIGNED:
                        // ignore the alignment
                        GET(inPtr, unsigned __int8);
                        break;

                    case CEE_VOLATILE:
                        break;      // since we neither cache reads or suppress writes this is a nop

                    default:
#ifdef _DEBUG
                        printf("\nUnimplemented OPCODE = %d", opcode);
                        _ASSERTE(!"Unimplemented Opcode");
#endif
                        FJIT_FAIL(CORJIT_INTERNALERROR);

        }
    }


    /*Note: from here to the end, we must not do anything that effects what may have been
    loaded via an emit_loadresult_()<type> previously.  We are just going to emit the epilog. */


    fjit->mapping->add(len, (outPtr-outBuff));

    
    /* the single epilog that all returns jump to */

    /* callee pops args for varargs */
    if (methodInfo->args.isVarArg())
        argsTotalSize = 0;

    if (fjit->flags & CORJIT_FLG_PROF_ENTERLEAVE)
    {
        BOOL bHookFunction;
        UINT_PTR thisfunc = (UINT_PTR) m_IJitInfo->GetProfilingHandle(methodHandle, &bHookFunction);

        if (bHookFunction)
        {
            inRegTOS = true;        // lie so that eax is always saved
            emit_save_TOS();        // squirel away the return value, this is safe since GC cannot happen 
                                    // until we finish the epilog
            emit_POP_PTR();         // and remove from stack
            emit_LDC_I(thisfunc); 
            ULONG func = (ULONG) m_IJitInfo->getHelperFtn(CORINFO_HELP_PROF_FCN_LEAVE);
            _ASSERTE(func != NULL);
            emit_callhelper_il(func); 
            emit_restore_TOS();
        }
    }

    emit_return(argsTotalSize);

    fjit->mapInfo.methodSize = outPtr-outBuff;
    fjit->mapInfo.epilogSize = (outPtr - outBuff) - fjit->mapping->pcFromIL(len);

    //_ASSERTE(((unsigned)(outPtr - outBuff)) < (*codeSize));
    *codeSize = outPtr - outBuff;
    if(cSequencePoints > 0)
        cleanupSequencePoints(fjit->jitInfo,sequencePointOffsets);
    return  CORJIT_OK; //(outPtr - outBuff);
#else // _X86_
    _ASSERTE(!"@TODO Alpha - jitCompile (fJitCompiler.cpp)");
    return CORJIT_INTERNALERROR;
#endif // _X86_
}

#include "fjitpass.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\gms.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************/
/*                       helperFrame.cpp                      */
/**************************************************************/
#include "jitpch.h"
#pragma hdrstop
#include "corjit.h" 


#include "helperFrame.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\fjitdef.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/*                                 fjitdef.h                              */
/***************************************************************************/

/* Defines the code generators and helpers for the fast jit in a platform
   and chip neutral way. It is also 32 and 64 bit neutral. */

/* This file implements all of the opcodes via helper calls with the exception'
   of the call/return/jmps and direct stack manipulations */

/* a chip specific file can redefine any macros directly.  For an example of
   this see the file x86fit.h */

/* The top of stack may or may not be enregistered.  The macros
   enregisterTOS and deregisterTOS dynamically move and track the
   TOS. */

/* AUTHOR: George Bosworth
   DATE:   6/15/98       */
/***************************************************************************/

#include "helperFrame.h"

/***************************************************************************
  The following macros must be defined for each chip.
  These consist of call/return and direct stack manipulations
***************************************************************************/

//#define NON_RELOCATABLE_CODE  // uncomment to generate relocatable code

/* macros used to implement helper calls */
//#define USE_CDECL_HELPERS

#ifndef USE_CDECL_HELPERS
#define HELPER_CALL __stdcall
#else
#define HELPER_CALL __cdecl
#endif // USE_CDECL_HELPERS

#ifdef _X86_

#define emit_pushresult_R4() x86_pushresult_R4
#define emit_pushresult_R8() x86_pushresult_R8
#define emit_pushresult_U4() emit_pushresult_I4()
#define emit_pushresult_U8() emit_pushresult_I8()

/* call/return */


#define emit_ret(argsSize) ret(argsSize)
#define emit_loadresult_R4() x86_emit_loadresult_R4()
#define emit_loadresult_R8() x86_emit_loadresult_R8()
#define emit_loadresult_U4() emit_loadresult_I4()
#define emit_loadresult_U8() emit_loadresult_I8()
#define emit_call_opcode() call_opcode()
/* stack operations */
#define emit_POP_R4() emit_POP_I4()
#define emit_POP_R8() emit_POP_I8()
    //note: emit_drop(n) cannot alter the result registers
#define emit_DUP_R4() emit_DUP_I8()	// since R4 is always promoted to R8 on the stack
#define emit_DUP_R8() emit_DUP_I8()


/* relative jumps and misc*/
#define emit_jmp_opcode(op) x86_jmp_cond_large(op,0)
#define emit_jmp_address(pcrel) cmdDWord(pcrel)

/* condition codes for braching and comparing
//@TODO: the commented out condition codes are probably not ever needed.
//       so delete them (when we are sure) */
//#define CEE_CondOver  x86CondOver
//#define CEE_CondNotOver x86CondNotOver
#define CEE_CondBelow   x86CondBelow
#define CEE_CondAboveEq x86CondAboveEq        
#define CEE_CondEq      x86CondEq
#define CEE_CondNotEq   x86CondNotEq
#define CEE_CondBelowEq x86CondBelowEq        
#define CEE_CondAbove   x86CondAbove      
//#define x86CondSign           8
//#define x86CondNotSign        9
//#define x86CondParityEven 10
//#define x86CondParityOdd  11
#define CEE_CondLt x86CondLt
#define CEE_CondGtEq x86CondGtEq
#define CEE_CondLtEq x86CondLtEq
#define CEE_CondGt x86CondGt
#define CEE_CondAlways x86CondAlways

/**************************************************************************
   define any additional macros as necessary for a given chip
**************************************************************************/



#define SP             X86_ESP
#define FP             X86_EBP
#define ARG_1          X86_ECX
#define ARG_2          X86_EDX
#define CALLEE_SAVED_1 X86_ESI
#define CALLEE_SAVED_2 X86_EDI
#define SCRATCH_1      X86_EAX
#define RESULT_1       X86_EAX  // this should be the same as SCRATCH_1
#define RESULT_2       X86_EDX  // this cannot be the same as ARG_1
#define CondNonZero    x86CondNotEq
#define CondZero	   x86CondEq

#define push_register(r)                 x86_push(r)
#define mov_register(r1,r2)              x86_mov_reg(x86DirTo,x86Big,x86_mod_reg(r1,r2))
#define mov_register_indirect_to(r1,r2)  x86_mov_reg(x86DirTo,x86Big,x86_mod_ind(r1,r2))
#define mov_register_indirect_from(r1,r2)x86_mov_reg(x86DirFrom,x86Big,x86_mod_ind(r1,r2))
#define mov_constant(r,c)                x86_mov_reg_imm(x86Big,r,(unsigned int)c)
#define load_indirect_byte_signextend(r1,r2)  x86_movsx(x86Byte,x86_mod_ind(r1,r2))
#define load_indirect_byte_zeroextend(r1,r2)  x86_movzx(x86Byte,x86_mod_ind(r1,r2))
#define load_indirect_word_signextend(r1,r2)  x86_movsx(x86Big,x86_mod_ind(r1,r2))
#define load_indirect_word_zeroextend(r1,r2)  x86_movzx(x86Big,x86_mod_ind(r1,r2))
#define load_indirect_dword_signextend(r1,r2)  mov_register_indirect_to(r1,r2)
#define load_indirect_dword_zeroextend(r1,r2)  mov_register_indirect_to(r1,r2)
#define store_indirect_byte(r1,r2)       x86_mov_reg(x86DirFrom,x86Byte,x86_mod_ind(r1,r2))
#define store_indirect_word(r1,r2)       x86_16bit(x86_mov_reg(x86DirFrom,x86Big,x86_mod_ind(r1,r2)))
#define store_indirect_dword(r1,r2)      mov_register_indirect_from(r1,r2)
#define pop(r)                           x86_pop(r)
#define add_constant(r,c)                if (c < 128) {x86_barith_imm(x86OpAdd,x86Big,x86Extend,r,c); } \
                                         else {x86_barith_imm(x86OpAdd,x86Big,x86NoExtend,r,c); }  
#define and_constant(r,c)                if (c < 128) {x86_barith_imm(x86OpAnd,x86Big,x86Extend,r,c); } \
                                         else {x86_barith_imm(x86OpAnd,x86Big,x86NoExtend,r,c); }  
#define sub_constant(r,c)                if (c < 128) {x86_barith_imm(x86OpSub,x86Big,x86Extend,r,c); } \
                                         else {x86_barith_imm(x86OpSub,x86Big,x86NoExtend,r,c); }  
#define sub_register(r1,r2)              x86_barith(x86OpSub, x86Big, x86_mod_reg(r1,r2))
#define ret(x)                           x86_ret(x)
#define jmp_register(r)                  x86_jmp_reg(r)
#define call_register(r)                 x86_call_reg(r)
#define jmp_condition(cond,offset)       x86_jmp_cond_small(cond);cmdByte(offset-1) 
#define call_opcode()                    x86_call_opcode()
#define jmp_opcode()                     x86_jmp_opcode()
#define and_register(r1,r2)              x86_test(x86Big, x86_mod_reg(r1, r2))
#define emit_shift_left(r,c)             x86_shift_imm(x86ShiftLeft,r,c)
#define emit_shift_right(r,c)            x86_shift_imm(x86ShiftRight,r,c)
#define emit_break()                     x86_break()
#define emit_il_nop()                    x86_cld()          // we use cld for a nop since the native nop is used for sequence points
#define emit_SWITCH(limit)               x86_SWITCH(limit)
#define compare_register(r1,r2)          x86_barith(x86OpCmp,x86Big,x86_mod_reg(r1,r2))
#define emit_call_memory_indirect(c)     x86_call_memory_indirect(c)
#define emit_TLSfieldAddress(tlsOffset, tlsIndex, fieldOffset) x86_TlsFieldAddress(tlsOffset, tlsIndex, fieldOffset)
#define emit_conv_R4toR8 x86_emit_conv_R4toR8
#define emit_conv_R8toR4 x86_emit_conv_R8toR4
#define emit_narrow_R8toR4 x86_narrow_R8toR4

#define x86_load_indirect_qword() \
    enregisterTOS; \
    x86_push_general(x86_mod_ind_disp8(6,X86_EAX,sizeof(void*))); \
    mov_register_indirect_to(SCRATCH_1,SCRATCH_1);

#include "x86fjit.h"

#endif // _X86_ 

#ifndef SCHAR_MAX

#define SCHAR_MAX 127.0     // Maximum signed char value
#define SCHAR_MIN -128.0    // Minimum signed char value
#define UCHAR_MAX 255.0     //Maximum unsigned char value
#define USHRT_MAX 65535.0   //Maximum unsigned short value
#define SHRT_MAX 32767.0    //Maximum (signed) short value
#define SHRT_MIN -32768     //Minimum (signed) short value
#define UINT_MAX 4294967295.0 //Maximum unsigned int value
#define INT_MAX 2147483647.0  // Maximum (signed) int value
#define INT_MIN -2147483648.0 // Minimum (unsigned) int value

#endif

         // 0x7FFFFFFF * 0x100000000 + (0x1000000000 - 1024) (1024 because of the loss of bits at double precision)
#define INT64_MAX  (2147483647.0 * 4294967296.0 + 4294966272.0)
         // -(0x7FFFFFFF * 0x100000000 + 0x100000000) - 1024 
#define INT64_MIN  (-(2147483647.0 * 4294967296.0 + 4294968320.0))
         // 0xFFFFFFFF * 0x100000000 + (0x1000000000 - 1024) (1024 because of the loss of bits at double precision)
#define UINT64_MAX  (4294967295.0 * 4294967296.0 + 4294966272.0)

/*******************************************************************************/
#ifndef emit_conv_R4toR
#define emit_conv_R4toR() { emit_conv_R4toR8() } 
#endif
#ifndef emit_conv_R8toR
#define emit_conv_R8toR() { } /* nop */
#endif
#ifndef emit_conv_RtoR4
#define emit_conv_RtoR4() { emit_conv_R8toR4() } 
#endif
#ifndef emit_conv_RtoR8
#define emit_conv_RtoR8() { } /* nop */
#endif
/*******************************************************************************/

#ifndef  deregisterTOS
#define deregisterTOS \
   if (inRegTOS) \
      push_register(SCRATCH_1); \
   inRegTOS = false; 
#endif // deregisterTOS

#ifndef  enregisterTOS
#define enregisterTOS \
   if (!inRegTOS) \
      pop(SCRATCH_1); \
   inRegTOS = true; 
#endif // enregisterTOS


/*************************************************************************************
        call/return macros
*************************************************************************************/


#ifndef grow
#define grow(n,zeroInitialized) \
{\
    if (zeroInitialized)\
    {\
        mov_constant(ARG_1,n);\
        deregisterTOS;\
        mov_constant(SCRATCH_1,0);\
        unsigned char* label = outPtr;\
        push_register(SCRATCH_1);\
        sub_constant(ARG_1,1);\
        jmp_condition(CondNonZero,label-outPtr);\
    }\
    else\
    {\
        _ASSERTE(n<=PAGE_SIZE);\
        sub_constant(SP,n);\
    }\
}
#endif // !grow

#ifndef emit_grow
#define emit_grow(n) grow(n,false)
#endif // !emit_grow

#ifndef emit_drop
#define emit_drop(n)\
{ \
   add_constant(SP,n); \
}
#endif // !emit_drop

#ifndef emit_prolog
#define emit_prolog(locals,zeroCnt) \
{\
   push_register(FP);\
   mov_register(FP,SP);\
   push_register(CALLEE_SAVED_1);\
   mov_constant(CALLEE_SAVED_1,0);\
   push_register(CALLEE_SAVED_1);\
   push_register(ARG_1);\
   push_register(ARG_2);\
   _ASSERTE(locals == zeroCnt);\
   if (locals) \
      grow(locals,true); /* zero initialized */ \
}
#endif // !emit_prolog

	// check to see that the stack is not corrupted only in debug code
#ifdef _DEBUG
#define emit_stack_check(localWords)								\
	deregisterTOS;													\
    push_register(SP);												\
	push_register(FP);												\
    emit_LDC_I4(sizeof(prolog_data) + (localWords)*sizeof(void*));	\
    emit_callhelper_I4I4I4(check_stack); 		

#ifdef DECLARE_HELPERS
void HELPER_CALL check_stack(int frameSize, BYTE* fp, BYTE* sp) {
	if (sp + frameSize != fp)
		_ASSERTE(!"ESP not correct on method exit.  Did you forget a leave?");
}
#endif // DECLARE_HELPERS
#else  // !_DEBUG
#define emit_stack_check(zeroCnt) 
#endif // _DEBUG

#ifndef emit_return
#define emit_return(argsSize)\
{\
   mov_register(ARG_1,FP); \
   add_constant(ARG_1,- (int)sizeof(void*)); \
   mov_register_indirect_to(CALLEE_SAVED_1,ARG_1); \
   mov_register(SP,FP); \
   pop(FP); \
   ret(argsSize); \
}
#endif // !emit_return

#ifndef emit_prepare_jmp
#define emit_prepare_jmp() \
{ \
   mov_register(ARG_2,FP); \
   add_constant(ARG_2,0- (int) sizeof(void*)); \
   mov_register_indirect_to(CALLEE_SAVED_1,ARG_2); \
   add_constant(ARG_2,-2 * (int)sizeof(void*)); \
   mov_register_indirect_to(ARG_1,ARG_2); \
   add_constant(ARG_2,0 - (int) sizeof(void*)); \
   mov_register_indirect_to(ARG_2,ARG_2); \
   mov_register(SP,FP); \
   pop(FP); \
}
#endif // !emit_prepare_jmp

#ifndef emit_jmp_absolute
#define emit_jmp_absolute(address)\
{ \
   mov_constant(SCRATCH_1,address); \
   jmp_register(SCRATCH_1); \
}
#endif // !emit_jmp_absolute

#ifndef emit_remove_frame
#define emit_remove_frame() \
{ \
   mov_register(CALLEE_SAVED_1,FP); \
   add_constant(CALLEE_SAVED_1,0- (int) sizeof(void*)); \
   mov_register_indirect_to(CALLEE_SAVED_1,CALLEE_SAVED_1); \
   mov_register(SP,FP); \
   pop(FP); \
}
#endif // !emit_remove_frame

#ifndef emit_mov_TOS_arg
#define emit_mov_TOS_arg(reg)\
{ \
   _ASSERTE(reg+1 == ARG_1 || reg+1 == ARG_2); \
   if (inRegTOS) { \
      mov_register(reg+1,SCRATCH_1); \
      inRegTOS = false; \
   }\
   else { \
      pop(reg+1); \
  }\
}
#endif // !emit_mov_TOS_arg

#ifndef emit_mov_arg_reg
#define emit_mov_arg_reg(offset, reg)\
{ \
   _ASSERTE(reg+1 == ARG_1 || reg+1 == ARG_2); \
   _ASSERTE(!inRegTOS); \
   mov_register(reg+1,SP); \
   add_constant(reg+1,offset); \
   mov_register_indirect_to(reg+1,reg+1); \
}
#endif // !emit_mov_arg_reg


#ifndef emit_mov_arg_stack
#define emit_mov_arg_stack(dest,src, size)\
{ \
   _ASSERTE(!inRegTOS); \
   _ASSERTE(size >= 4 );\
   if (dest > src) \
   { \
       push_register(CALLEE_SAVED_1); \
       int emitter_scratch_i4 = size; \
       mov_register(CALLEE_SAVED_1,SP); \
       push_register(CALLEE_SAVED_2); \
       mov_register(CALLEE_SAVED_2,CALLEE_SAVED_1); \
       add_constant(CALLEE_SAVED_1,src+emitter_scratch_i4); \
       add_constant(CALLEE_SAVED_2,dest+emitter_scratch_i4); \
       _ASSERTE(emitter_scratch_i4 > 0); \
       while (true) \
       { \
          mov_register_indirect_to(SCRATCH_1,CALLEE_SAVED_1); \
          mov_register_indirect_from(SCRATCH_1,CALLEE_SAVED_2); \
          if (emitter_scratch_i4 == sizeof(void*)) \
            break;\
          add_constant(CALLEE_SAVED_1,-(int) sizeof(void*)); \
          add_constant(CALLEE_SAVED_2,-(int) sizeof(void*)); \
          emitter_scratch_i4 -= sizeof(void*); \
       }\
       pop(CALLEE_SAVED_2); \
       pop(CALLEE_SAVED_1); \
   } \
   else \
   { \
       /*_ASSERTE(!""); */\
       push_register(CALLEE_SAVED_1); \
       unsigned int emitter_scratch_i4 = sizeof(void*); \
       mov_register(CALLEE_SAVED_1,SP); \
       push_register(CALLEE_SAVED_2); \
       mov_register(CALLEE_SAVED_2,CALLEE_SAVED_1); \
       add_constant(CALLEE_SAVED_1,src+emitter_scratch_i4); \
       add_constant(CALLEE_SAVED_2,dest+emitter_scratch_i4); \
       _ASSERTE(emitter_scratch_i4 <= size); \
       while (true) \
       { \
          mov_register_indirect_to(SCRATCH_1,CALLEE_SAVED_1); \
          mov_register_indirect_from(SCRATCH_1,CALLEE_SAVED_2); \
          if (emitter_scratch_i4 == size) \
            break;\
          add_constant(CALLEE_SAVED_1,(int) sizeof(void*)); \
          add_constant(CALLEE_SAVED_2,(int) sizeof(void*)); \
          emitter_scratch_i4 += sizeof(void*); \
       }\
       pop(CALLEE_SAVED_2); \
       pop(CALLEE_SAVED_1); \
   } \
}
#endif // !emit_mov_arg_stack
#ifndef emit_replace_args_with_operands
#define emit_replace_args_with_operands(dest, src, size)\
{ \
   emit_mov_arg_stack(dest,src,size); \
}
#endif // !emit_replace_args_with_operands

#ifndef emit_loadresult_U1
#define emit_loadresult_U1() \
{ \
  emit_callhelper_I4_I4(load_result_U1_helper); \
  emit_pushresult_I4(); \
}
unsigned int HELPER_CALL load_result_U1_helper(int x) {return (unsigned int) ((unsigned char) x);}
#endif // !emit_loadresult_U1

#ifndef emit_loadresult_I1
#define emit_loadresult_I1() \
{ \
  emit_callhelper_I4_I4(load_result_I1_helper); \
  emit_pushresult_I4(); \
}
int HELPER_CALL load_result_I1_helper(int x) {return (int) ((signed char) x);}
#endif // !emit_loadresult_I1

#ifndef emit_loadresult_U2
#define emit_loadresult_U2() \
{ \
  emit_callhelper_I4_I4(load_result_U2_helper); \
  emit_pushresult_I4(); \
}
unsigned int HELPER_CALL load_result_U2_helper(int x) {return (unsigned int) ((unsigned short) x);}
#endif // !emit_loadresult_U2

#ifndef emit_loadresult_I2
#define emit_loadresult_I2() \
{ \
  emit_callhelper_I4_I4(load_result_I2_helper); \
  emit_pushresult_I4(); \
}
int HELPER_CALL load_result_I2_helper(int x) {return (int) ((short) x);}
#endif  // !emit_loadresult_I2
 
#ifndef emit_loadresult_I4
#define emit_loadresult_I4() \
{ \
   enregisterTOS ; \
   inRegTOS = false; \
}
#endif // !emit_loadresult_I4

#ifndef emit_loadresult_I8
#define emit_loadresult_I8() \
{ \
   enregisterTOS; \
   pop(RESULT_2); \
   inRegTOS = false; \
}
#endif // !emit_loadresult_I8

#ifndef emit_compute_virtaddress
#define emit_compute_virtaddress(vt_offset) \
{  deregisterTOS; \
   mov_register_indirect_to(SCRATCH_1,ARG_1); \
   add_constant(SCRATCH_1,vt_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   push_register(SCRATCH_1); \
   _ASSERTE(inRegTOS == false); \
}
#endif // !emit_compute_virtaddress

#ifndef emit_callvirt
#define emit_callvirt(vt_offset)\
{ \
   mov_register_indirect_to(SCRATCH_1,ARG_1); \
   add_constant(SCRATCH_1,vt_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   call_register(SCRATCH_1); \
}
#endif // !emit_callvirt

#ifndef emit_jmpvirt
#define emit_jmpvirt(vt_offset)\
{ \
   mov_register_indirect_to(SCRATCH_1,ARG_1); \
   add_constant(SCRATCH_1,vt_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   jmp_register(SCRATCH_1); \
}
#endif // !emit_jmpvirt

#ifndef emit_check_TOS_null_reference
#define emit_check_TOS_null_reference() \
{ \
   enregisterTOS; \
   mov_register_indirect_to(ARG_1,SCRATCH_1); \
}
#endif // !emit_check_this_null_reference

#ifndef emit_calli
#define emit_calli() \
{ \
   enregisterTOS; \
   call_register(SCRATCH_1); \
   inRegTOS = false; \
}
#endif // !emit_calli

#ifndef emit_ldvtable_address
#define emit_ldvtable_address(hint, offset)\
{ \
   _ASSERTE(inRegTOS); \
   mov_register(ARG_1,SCRATCH_1); \
   mov_constant(SCRATCH_1,hint); \
   push_register(SCRATCH_1); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   call_register(SCRATCH_1); \
   add_constant(RESULT_1,offset); \
   mov_register_indirect_to(SCRATCH_1,RESULT_1); \
   inRegTOS = true; \
}
#endif // !emit_ldvtable_address

#ifndef emit_ldvtable_address_new
#define emit_ldvtable_address_new(ifctable_offset,interface_offset, vt_offset) \
{ \
   _ASSERTE(inRegTOS); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(SCRATCH_1,ifctable_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(SCRATCH_1,interface_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(SCRATCH_1,vt_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
} 
#endif // !emit_ldvtable_address_new

#ifndef emit_callinterface
#define emit_callinterface(vt_offset,hint)\
{ \
   mov_constant(SCRATCH_1,hint); \
   push_register(SCRATCH_1); \
   inRegTOS = false; \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   call_register(SCRATCH_1); \
   add_constant(RESULT_1,vt_offset); \
   mov_register_indirect_to(SCRATCH_1,RESULT_1); \
   call_register(SCRATCH_1); \
}
#endif // !emit_callinterface

#ifndef emit_compute_interface_new
#define emit_compute_interface_new(ifctable_offset,interface_offset, vt_offset) \
{ \
   mov_register_indirect_to(SCRATCH_1,ARG_1); \
   add_constant(SCRATCH_1,ifctable_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(SCRATCH_1,interface_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(SCRATCH_1,vt_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   push_register(SCRATCH_1); \
} 
#endif // !emit_compute_interface_new

#ifndef emit_callinterface_new
#define emit_callinterface_new(ifctable_offset,interface_offset, vt_offset) \
{ \
   mov_register_indirect_to(SCRATCH_1,ARG_1); \
   add_constant(SCRATCH_1,ifctable_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(SCRATCH_1,interface_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(SCRATCH_1,vt_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   call_register(SCRATCH_1); \
} 
#endif // !emit_callinterface_new

#ifndef emit_jmpinterface_new
#define emit_jmpinterface_new(ifctable_offset,interface_offset, vt_offset) \
{ \
   mov_register_indirect_to(SCRATCH_1,ARG_1); \
   add_constant(SCRATCH_1,ifctable_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(SCRATCH_1,interface_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(SCRATCH_1,vt_offset); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   jmp_register(SCRATCH_1); \
} 
#endif // !emit_jmpinterface_new

#ifndef emit_jmpinterface
#define emit_jmpinterface(vt_offset, hint)\
{ \
   mov_constant(CALLEE_SAVED_1,hint); \
   push_register(CALLEE_SAVED_1); \
   mov_constant(CALLEE_SAVED_1,0); \
   push_register(SCRATCH_1); \
   inRegTOS = false; \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   call_register(SCRATCH_1); \
   add_constant(RESULT_1,vt_offset); \
   mov_register_indirect_to(SCRATCH_1,RESULT_1); \
   jmp_register(SCRATCH_1); \
}
#endif // !emit_jmpinterface

#ifndef  emit_callnonvirt
#define emit_callnonvirt(ftnptr)\
{ \
   mov_constant(SCRATCH_1,ftnptr); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   call_register(SCRATCH_1); \
}
#endif // !emit_callnonvirt

#ifndef  emit_compute_invoke_delegate
#define emit_compute_invoke_delegate(obj,ftnptr)\
{ \
   mov_register(SCRATCH_1,ARG_1); \
   add_constant(SCRATCH_1,ftnptr); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(ARG_1,obj); \
   mov_register_indirect_to(ARG_1,ARG_1); \
   push_register(SCRATCH_1); \
}

#endif // !emit_compute_invoke_delegate

#ifndef  emit_invoke_delegate
#define emit_invoke_delegate(obj,ftnptr)\
{ \
   mov_register(SCRATCH_1,ARG_1); \
   add_constant(SCRATCH_1,ftnptr); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(ARG_1,obj); \
   mov_register_indirect_to(ARG_1,ARG_1); \
   call_register(SCRATCH_1); \
}
#endif // !emit_invoke_delegate

#ifndef  emit_jmp_invoke_delegate
#define emit_jmp_invoke_delegate(obj,ftnptr)\
{ \
   mov_register(SCRATCH_1,ARG_1); \
   add_constant(SCRATCH_1,ftnptr); \
   mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
   add_constant(ARG_1,obj); \
   mov_register_indirect_to(ARG_1,ARG_1); \
   jmp_register(SCRATCH_1); \
}

#endif // !emit_jmp_invoke_delegate


#ifndef emit_POP_I4
#define emit_POP_I4() \
{ \
   enregisterTOS; \
   inRegTOS = false; \
}
#endif // !emit_POP_I4

#ifndef emit_POP_I8
#define emit_POP_I8() \
{ \
   emit_POP_I4(); \
   emit_POP_I4(); \
}
#endif // !emit_POP_I8

#ifndef emit_set_zero
#define emit_set_zero(offset) \
    _ASSERTE(!inRegTOS); /* I trash EAX */ \
    mov_constant(SCRATCH_1,0); \
    push_register(ARG_1); /* since this is going to be trashed*/ \
    mov_register(ARG_1,SP); \
    add_constant(ARG_1,offset+sizeof(void*)); \
    mov_register_indirect_from(SCRATCH_1,ARG_1); \
    pop(ARG_1); /* restore */  
#endif // !emit_set_zero

#ifndef emit_getSP
#define emit_getSP(n)\
{ \
   deregisterTOS; \
   mov_register(SCRATCH_1,SP); \
   add_constant(SCRATCH_1,n); \
   inRegTOS = true; \
}
#endif // !emit_getSP

#ifndef emit_DUP_I4
#define emit_DUP_I4() \
{ \
   enregisterTOS; \
   push_register(SCRATCH_1); \
}
#endif // !emit_DUP_I4

#ifndef emit_DUP_I8
#define emit_DUP_I8() \
{ \
   emit_DUP_I4() ; \
   mov_register(RESULT_2,SP); \
   add_constant(RESULT_2,4); \
   mov_register_indirect_to(RESULT_2,RESULT_2); \
   push_register(RESULT_2); \
}

#endif // !emit_DUP_I8

#ifndef emit_pushconstant_4
#define emit_pushconstant_4(val) \
{ \
   deregisterTOS; \
   mov_constant(SCRATCH_1,val); \
   inRegTOS = true; \
}
#endif // !emit_pushconstant_4

#ifndef emit_pushconstant_8
#define emit_pushconstant_8(val)\
{ \
   deregisterTOS; \
   int x = (int) ((val >> 32) & 0xffffffff); \
   emit_pushconstant_4(x); \
   deregisterTOS; \
   x = (int) (val & 0xffffffff); \
   emit_pushconstant_4(x); \
   inRegTOS = true; \
}
#endif // !emit_pushconstant_8

#ifndef emit_pushconstant_Ptr
#define emit_pushconstant_Ptr(val)\
{ \
   deregisterTOS; \
   mov_constant(SCRATCH_1,val); \
   inRegTOS = true; \
} 
#endif // !emit_pushconstant_Ptr

#ifndef emit_LDVARA
#define emit_LDVARA(offset) \
{ \
   deregisterTOS; \
   mov_register(SCRATCH_1,FP); \
   if (offset > 0) { add_constant(SCRATCH_1,offset);} \
   else {sub_constant(SCRATCH_1,-(int)offset);} \
   inRegTOS = true; \
} 
#endif // !emit_LDVARA

#ifndef emit_helperarg_1
#define emit_helperarg_1(val) \
    mov_constant(ARG_1,val); 
#endif // !emit_helperarg_1

#ifndef emit_helperarg_2
#define emit_helperarg_2(val) \
    mov_constant(ARG_2,val); 
#endif // !emit_helperarg_2
/*********************************************************/
#ifdef NON_RELOCATABLE_CODE
//**************
#define emit_callhelper_il(helper) \
    deregisterTOS; \
    call_opcode() ; \
    fjit->fixupTable->insert((void**) outPtr); \
	emit_jmp_address((unsigned)helper+0x80000000);

#ifndef USE_CDECL_HELPERS
#define emit_callhelper(helper,argsize) \
    deregisterTOS; \
    call_opcode(); \
    fjit->fixupTable->insert((void**) outPtr); \
	emit_jmp_address((unsigned)helper+0x80000000);
#else // USE_CDECL_HELPERS
#define emit_callhelper(helper,argsize) \
    deregisterTOS; \
    call_opcode() ; \
    fjit->fixupTable->insert((void**) outPtr); \
	emit_jmp_address((unsigned)helper+0x80000000); \
    if (argsize) \
       add_constant(SP,(argsize));
#endif // USE_CDECL_HELPERS

#define emit_callimmediate(address) call_opcode() ; \
    fjit->fixupTable->insert((void**) outPtr); \
	emit_jmp_address((unsigned)address+0x80000000); \

//**************
#else // NON_RELOCATABLE_CODE
//**************
#define emit_callhelper_il(helper) \
    deregisterTOS; \
    mov_constant(SCRATCH_1,helper); \
    call_register(SCRATCH_1);

#ifndef USE_CDECL_HELPERS

#define emit_callhelper(helper,argsize) \
    deregisterTOS; \
    mov_constant(SCRATCH_1,helper); \
    call_register(SCRATCH_1); 

#else // USE_CDECL_HELPERS

#define emit_callhelper(helper,argsize) \
    deregisterTOS; \
    mov_constant(SCRATCH_1,helper); \
    call_register(SCRATCH_1); \
    if (argsize) \
        add_constant(SP,(argsize));

#endif // !USE_CDECL_HELPERS

#ifndef emit_callimmediate
// call immediate without using a register
//@TODO fix this when ejt doesn't bother about non-relocatable code
#define emit_callimmediate(address) \
		mov_constant(CALLEE_SAVED_1,address); \
		call_register(CALLEE_SAVED_1);
#endif // !emit_callimmediate
//**************

#endif  // NON_RELOCATABLE_CODE

/************************************************************************/
// Define helpers that operate on abstract types D (dword) and Q (qword) 
// in terms of the above helpers

#ifndef _WIN64

#define emit_callhelper_Q(helper) emit_callhelper(helper,2*sizeof(void*))
#define emit_callhelper_DQ(helper) emit_callhelper(helper,3*sizeof(void*))
#define emit_callhelper_QD(helper) emit_callhelper(helper,3*sizeof(void*))
#define emit_callhelper_D_Q(helper) emit_callhelper(helper,sizeof(void*))
#define emit_callhelper_Q_D(helper) emit_callhelper(helper,2*sizeof(void*))
#define emit_callhelper_Q_Q(helper) emit_callhelper(helper,2*sizeof(void*))
#define emit_callhelper_DD_Q(helper) emit_callhelper(helper,2*sizeof(void*))
#define emit_callhelper_DQ_Q(helper) emit_callhelper(helper,3*sizeof(void*))
#define emit_callhelper_QQ_D(helper) emit_callhelper(helper,4*sizeof(void*))
#define emit_callhelper_QQ_Q(helper) emit_callhelper(helper,4*sizeof(void*))
#define emit_callhelper_DQD(helper) emit_callhelper(helper,4*sizeof(void*))
#define emit_callhelper_QDD(helper) emit_callhelper(helper,4*sizeof(void*))

#else // WIN64

#define emit_callhelper_Q(helper) emit_callhelper(helper,sizeof(void*))
#define emit_callhelper_DQ(helper) emit_callhelper(helper,2*sizeof(void*))
#define emit_callhelper_QD(helper) emit_callhelper(helper,2*sizeof(void*))
#define emit_callhelper_Q_D(helper) emit_callhelper(helper,sizeof(void*))
#define emit_callhelper_Q_Q(helper) emit_callhelper(helper,sizeof(void*))
#define emit_callhelper_DD_Q(helper) emit_callhelper(helper,sizeof(void*))
#define emit_callhelper_DQ_Q(helper) emit_callhelper(helper,2*sizeof(void*))
#define emit_callhelper_QQ_D(helper) emit_callhelper(helper,4*sizeof(void*))
#define emit_callhelper_QQ_Q(helper) emit_callhelper(helper,2*sizeof(void*))
#define emit_callhelper_DQD(helper) emit_callhelper(helper,3*sizeof(void*))
#define emit_callhelper_QDD(helper) emit_callhelper(helper,3*sizeof(void*))

#endif // _WIN64

// Define helpers that are the same in Win32 and Win64
#define emit_callhelper_(helper) emit_callhelper(helper,0)
#define emit_callhelper_D(helper) emit_callhelper(helper,sizeof(void*))
#define emit_callhelper_DD(helper) emit_callhelper(helper,2*sizeof(void*))
#define emit_callhelper_DDD(helper) emit_callhelper(helper,3*sizeof(void*))
#define emit_callhelper_DDDD(helper) emit_callhelper(helper,4*sizeof(void*))
#define emit_callhelper_DDDDD(helper) emit_callhelper(helper,5*sizeof(void*))

#define emit_callhelper_D_D(helper) emit_callhelper(helper,sizeof(void*))
#define emit_callhelper_DD_D(helper) emit_callhelper(helper,2*sizeof(void*))
#define emit_callhelper_DDD_D(helper) emit_callhelper(helper,3*sizeof(void*))

/************************************************************************/
// Define type specific helpers in terms of D (dword) and Q (qword)
#define emit_callhelper_I4 emit_callhelper_D
#define emit_callhelper_I8 emit_callhelper_Q
#define emit_callhelper_R4 emit_callhelper_D
#define emit_callhelper_R8 emit_callhelper_Q
#define emit_callhelper_I4I4 emit_callhelper_DD
#define emit_callhelper_I4I8 emit_callhelper_DQ
#define emit_callhelper_I4R4 emit_callhelper_DD
#define emit_callhelper_I4R8 emit_callhelper_DQ
#define emit_callhelper_I8I4 emit_callhelper_QD
#define emit_callhelper_R4I4 emit_callhelper_DD
#define emit_callhelper_R8I4 emit_callhelper_QD
#define emit_callhelper_I4I4I4 emit_callhelper_DDD
#define emit_callhelper_I4I8I4 emit_callhelper_DQD
#define emit_callhelper_I4R4I4 emit_callhelper_DDD
#define emit_callhelper_I4R8I4 emit_callhelper_DDD
#define emit_callhelper_I8I4I4 emit_callhelper_QDD
#define emit_callhelper_R4I4I4 emit_callhelper_DDD
#define emit_callhelper_R8I4I4 emit_callhelper_QDD
#define emit_callhelper_I4I4I4I4 emit_callhelper_DDDD
#define emit_callhelper_I4I4I4I4I4 emit_callhelper_DDDDD


#define emit_callhelper_I4_I4 emit_callhelper_D_D
#define emit_callhelper_I4_I8 emit_callhelper_D_Q
#define emit_callhelper_I8_I4 emit_callhelper_Q_D
#define emit_callhelper_I8_I8 emit_callhelper_Q_Q
#define emit_callhelper_R4_I4 emit_callhelper_D_D
#define emit_callhelper_R8_I4 emit_callhelper_Q_D
#define emit_callhelper_R4_I8 emit_callhelper_D_Q
#define emit_callhelper_R8_I8 emit_callhelper_Q_Q
#define emit_callhelper_I4I4_I4 emit_callhelper_DD_D
#define emit_callhelper_I4I4_I8 emit_callhelper_DD_Q
#define emit_callhelper_I4I8_I8 emit_callhelper_DQ_Q
#define emit_callhelper_I8I8_I4 emit_callhelper_QQ_D
#define emit_callhelper_I8I8_I8 emit_callhelper_QQ_Q
#define emit_callhelper_R4R4_I4 emit_callhelper_DD_D
#define emit_callhelper_R8I8_I8 emit_callhelper_QQ_Q
#define emit_callhelper_R8R8_I4 emit_callhelper_QQ_D
#define emit_callhelper_R8R8_I8 emit_callhelper_QQ_Q
#define emit_callhelper_R8R8_R8 emit_callhelper_QQ_Q
#define emit_callhelper_I4I4I4_I4 emit_callhelper_DDD_D
/*********************************************************/


#define emit_pushresult_U1() \
	and_constant(RESULT_1,0xff); \
	inRegTOS = true;

#define emit_pushresult_U2() \
	and_constant(RESULT_1,0xffff); \
	inRegTOS = true;

#ifndef emit_pushresult_I1
#define emit_pushresult_I1() \
	inRegTOS = true; \
    emit_callhelper_I4_I4(CONV_TOI4_I1_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI4_I1_helper(__int8 val) {
    return (__int32) val;
}
#endif
#endif

#ifndef emit_pushresult_I2
#define emit_pushresult_I2() \
	inRegTOS = true; \
    emit_callhelper_I4_I4(CONV_TOI4_I2_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI4_I2_helper(__int16 val) {
    return (__int32) val;
}
#endif
#endif


#define emit_pushresult_I4() \
    inRegTOS = true

#ifndef emit_pushresult_I8
#define emit_pushresult_I8() \
    push_register(RESULT_2); \
    inRegTOS = true;
#endif // !emit_pushresult_I8

#ifndef emit_invoke_delegate
#define emit_invoke_delegate(obj, ftnptr) \
    mov_register(SCRATCH_1,ARG_1); \
    add_constant(ARG_1,ftnptr); \
    mov_register_indirect_to(SCRATCH_1,SCRATCH_1);
    add_constant(ARG_1,obj); \
    mov_register_indirect_to(ARG_1,ARG_1); \
    call_register(SCRATCH_1);
#endif // !emit_invoke_delegate

#ifndef emit_jmp_invoke_delegate
#define emit_jmp_invoke_delegate(obj, ftnptr) \
    mov_register(SCRATCH_1,ARG_1); \
    add_constant(ARG_1,ftnptr); \
    mov_register_indirect_to(SCRATCH_1,SCRATCH_1);
    add_constant(ARG_1,obj); \
    mov_register_indirect_to(ARG_1,ARG_1); \
    jmp_register(SCRATCH_1);
#endif // !emit_jmp_invoke_delegate

#ifndef emit_testTOS
#define emit_testTOS() \
    enregisterTOS;      \
    inRegTOS = false;   \
    and_register(SCRATCH_1,SCRATCH_1);
#endif // !emit_testTOS

#ifndef emit_testTOS_I8
#define emit_testTOS_I8() \
    deregisterTOS;      \
    emit_callhelper_I8_I4(BoolI8ToI4_helper) \
	and_register(RESULT_1,RESULT_1);

#ifdef DECLARE_HELPERS
int HELPER_CALL BoolI8ToI4_helper(__int64 val) {
	return (val ? 1 : 0);
}
#endif
#endif // !emit_testTOS
    
#ifndef _WIN64
#define emit_BR_I4(Ctest,Cjmp,Bjmp,JmpOp) \
    enregisterTOS; \
    pop(ARG_1); \
    compare_register(ARG_1,SCRATCH_1); \
    inRegTOS = false; \
    JmpOp = Bjmp;
#endif // !_WIN64

// The following four macros are all the same, they have been
// separated out, so we can overwrite some of them with more 
// efficient, less portable ones.
#ifndef emit_BR_Common
#define emit_BR_Common(Ctest,Cjmp,Bjmp,JmpOp) \
    Ctest(); \
    emit_testTOS(); \
    JmpOp = Cjmp;
#endif // !emit_BR_Common

#ifndef emit_BR_I4
#define emit_BR_I4(Ctest,Cjmp,Bjmp,JmpOp) \
    emit_BR_Common(Ctest,Cjmp,Bjmp,JmpOp)
#endif // !emit_BR_I4

#ifndef emit_BR_I8
#define emit_BR_I8(Ctest,Cjmp,Bjmp,JmpOp) \
    emit_BR_Common(Ctest,Cjmp,Bjmp,JmpOp)
#endif // !emit_BR_I8

#ifndef emit_BR_R4
#define emit_BR_R4(Ctest,Cjmp,Bjmp,JmpOp) \
    emit_BR_Common(Ctest,Cjmp,Bjmp,JmpOp)
#endif // !emit_BR_R4

#ifndef emit_BR_R8
#define emit_BR_R8(Ctest,Cjmp,Bjmp,JmpOp) \
    emit_BR_Common(Ctest,Cjmp,Bjmp,JmpOp)
#endif // !emit_BR_R8

#ifndef emit_init_bytes
#define emit_init_bytes(num_of_bytes) \
{ \
    emit_LDC_I4(num_of_bytes);                  \
    deregisterTOS;                              \
    emit_callhelper_I4I4(InitBytes_helper); \
}

#ifdef DECLARE_HELPERS
void HELPER_CALL InitBytes_helper(const unsigned __int32 size, __int8 * dest)
{
    if(dest == NULL) {      
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    memset(dest,0,size);
}
#endif // DECLARE_HELPERS
#endif // !emit_init_bytes

#ifndef emit_copy_bytes
#define emit_copy_bytes(num_of_bytes,gcLayoutSize,gcLayout) \
{ \
    emit_LDC_I4(num_of_bytes);                  \
    deregisterTOS;                              \
    call_opcode();                              \
    cmdDWord(gcLayoutSize);              \
    for(int i=0; i < gcLayoutSize; i++) {       \
        cmdByte(gcLayout[i]);                   \
    }                                           \
    emit_callhelper_I4I4I4I4(CopyBytes_helper);           \
}
#endif // !emit_copy_bytes

#ifdef DECLARE_HELPERS
void HELPER_CALL CopyBytes_helper(const unsigned char* gcLayout, unsigned __int32 size, __int32 * src, __int32 * dest)
{
#ifdef _X86_
    char mask = 1;
    if((unsigned) dest <= sizeof(void*)) {      
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    for (unsigned i = 0; i < size/sizeof(void*); i++) {
        if (gcLayout[i/8] & mask) {
            __int32 val = *src++;
            __asm {
                mov eax, val
                mov edx, dest
            }
            FJit_pHlpAssign_Ref_EAX();
            dest++;
        }
        else {
            *dest++ = *src++;
        }
        if (mask == 0x80)
            mask = 1;
        else
            mask <<= 1;
    }
        // all of the bits left in the byte should be zero (this insures we aren't pointing at trash).  
    _ASSERTE(mask == 1 || ((-mask) & gcLayout[i/8]) == 0);

	// now copy any leftover bytes
	{ 
		unsigned char* _dest = (unsigned char*)dest;
		unsigned char* _src = (unsigned char*)src;
		unsigned int numBytes = size & 3;
		for (i=0; i<numBytes;i++)
			*_dest++ = *_src++;
	}
#else //!_X86_
    _ASSERTE(!"@TODO Alpha - CopyBytes_helper (fJitDef.h)");
#endif // _X86_
}
#endif // DECLARE_HELPERS

#ifndef emit_push_words
#define emit_push_words(size)  \
   if (inRegTOS) { \
        mov_register(CALLEE_SAVED_1,SCRATCH_1); \
		inRegTOS = false;											\
    } \
    else { pop(CALLEE_SAVED_1); } \
    mov_constant(ARG_1,size);                       \
    add_constant(CALLEE_SAVED_1,(size-1)*sizeof(void*)); \
    unsigned char* label = outPtr; \
    mov_register_indirect_to(SCRATCH_1,CALLEE_SAVED_1);    \
    push_register(SCRATCH_1);    \
    add_constant(CALLEE_SAVED_1,-(int)sizeof(void*)); \
    add_constant(ARG_1,-1); \
    jmp_condition(CondNonZero,label-outPtr); \
    mov_constant(CALLEE_SAVED_1,0);    
#endif // !emit_push_words

#ifndef emit_jmp_result
#define emit_jmp_result() jmp_register(RESULT_1)
#endif // !emit_jmp_result

#ifndef emit_checkthis_nullreference
#define emit_checkthis_nullreference() mov_register_indirect_to(SCRATCH_1,ARG_1)
#endif // !emit_checkthis_nullreference

/* support for new obj, since constructors don't return the constructed object.
   support for calli since the target address needs to come off the stack while
   building the call frame
   NOTE: save_TOS copies the TOS to a save area in the frame or register but leaves
         the current value on the TOS.
         restore_TOS pushes the saved value onto the TOS.
         It is required that the code not be interruptable between the save and the restore */

#define emit_save_TOS()                                                \
    (inRegTOS ?                                                     \
        mov_register(CALLEE_SAVED_1,SCRATCH_1) \
    :                                                               \
        pop(CALLEE_SAVED_1))

#define emit_restore_TOS()                                             \
    deregisterTOS; \
    mov_register(SCRATCH_1,CALLEE_SAVED_1); \
    inRegTOS = true;                                                \
    mov_constant(CALLEE_SAVED_1,0);

/**************************************************************************
   debugging and logging macros
**************************************************************************/
#ifdef LOGGING

extern ICorJitInfo* logCallback;		// where to send the logging mesages

#define emit_log_opcode(il, opcode, TOSstate)   \
    deregisterTOS;                              \
    push_register(SP);                          \
    push_register(FP);                          \
    emit_pushconstant_4(il);                    \
    emit_pushconstant_4(opcode);                \
    emit_pushconstant_4(TOSstate);              \
    emit_callhelper_I4I4I4I4I4(log_opcode_helper);         \
    if (TOSstate) {                             \
        enregisterTOS;                          \
    }
#ifdef DECLARE_HELPERS
void HELPER_CALL log_opcode_helper(bool TOSstate, unsigned short opcode, unsigned short il, unsigned framePtr, unsigned* stackPtr) {
    logMsg(logCallback, LL_INFO100000, "ESP:%1s%8x[%8x:%8x:%8x] EBP:%8x IL:%4x %s \n",
        (TOSstate? "+" :""),
        (unsigned) stackPtr,
        stackPtr[0], stackPtr[1], stackPtr[2],
        framePtr, il, opname[opcode]
        );
}
#endif // DECLARE_HELPERS

#define emit_log_entry(szDebugClassName, szDebugMethodName)     \
    emit_pushconstant_4(szDebugClassName);                      \
    emit_pushconstant_4(szDebugMethodName);                     \
    emit_callhelper_I4I4(log_entry_helper);                          \
    inRegTOS = false
#ifdef DECLARE_HELPERS
void HELPER_CALL log_entry_helper(const char * szDebugMethodName, const char * szDebugClassName) {
    logMsg(logCallback, LL_INFO10000, "{ entering %s::%s\n", szDebugClassName, szDebugMethodName);
}
#endif // DECLARE_HELPERS

#define emit_log_exit(szDebugClassName, szDebugMethodName)     \
    emit_pushconstant_4(szDebugClassName);                      \
    emit_pushconstant_4(szDebugMethodName);                     \
    emit_callhelper_I4I4(log_exit_helper);                          \
    inRegTOS = false
#ifdef DECLARE_HELPERS
void HELPER_CALL log_exit_helper(const char * szDebugMethodName, const char * szDebugClassName) {
    logMsg(logCallback, LL_INFO10000, "} leaving %s::%s \n", szDebugClassName, szDebugMethodName);
}
#endif // DECLARE_HELPERS

#endif // LOGGING
/**************************************************************************
   useful macros
**************************************************************************/

#define emit_pushresult_Ptr()           \
    emit_WIN32(emit_pushresult_U4())    \
    emit_WIN64(emit_pushresult_U8())

#define emit_loadresult_Ptr()           \
    emit_WIN32(emit_loadresult_U4())    \
    emit_WIN64(emit_loadresult_U8())

#define emit_POP_PTR()      \
    emit_WIN32(emit_POP_I4())   \
    emit_WIN64(emit_POP_I8())

#define emit_LDIND_PTR()         \
    emit_WIN32(emit_LDIND_I4())   \
    emit_WIN64(emit_LDIND_I8())

/**************************************************************************
    shared helper routines for code generation
**************************************************************************/

#ifdef DECLARE_HELPERS



void HELPER_CALL StoreIndirect_REF_helper(unsigned* pObj, unsigned val) 
{
#ifdef _X86_
    __asm{
        mov edx,pObj
        mov eax,val
        }
    FJit_pHlpAssign_Ref_EAX();
#else // !_X86_
    _ASSERTE(!"NYI");
#endif // _X86_
}

CORINFO_Object* HELPER_CALL CheckNull_helper(CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return or;
}

#endif //DECLARE_HELPERS

/**************************************************************************
    chip independent code generation macros, using helper calls
**************************************************************************/

// Note: the STIND op codes do not use the shared helpers since the
//       args on the stack are reversed
#ifndef emit_VARARG_LDARGA
#define emit_VARARG_LDARGA(offset) {                                                \
    emit_LDVARA(sizeof(prolog_frame));   /* get the vararg handle */                \
    emit_LDC_I4(varInfo->offset);                                                   \
    emit_callhelper_I4I4(VARARG_LDARGA_helper);                                          \
    emit_WIN32(emit_pushresult_I4())                                                \
    emit_WIN64(emit_pushresult_I8());                                               \
    }

#ifdef DECLARE_HELPERS
void* HELPER_CALL VARARG_LDARGA_helper(int argOffset, CORINFO_VarArgInfo** varArgHandle) {

    CORINFO_VarArgInfo* argInfo = *varArgHandle;
    char* argPtr = (char*) varArgHandle;

    argPtr += argInfo->argBytes+argOffset;
    return(argPtr);
}

#endif // DECLARE_HELPERS
#endif // !emit_VARARG_LDARGA

#ifndef emit_LDVAR_U1
#define emit_LDVAR_U1(offset)     \
    emit_LDVARA(offset);    \
    load_indirect_byte_zeroextend(SCRATCH_1,SCRATCH_1); \
    _ASSERTE(inRegTOS); 
#endif // !emit_LDVAR_U1

#ifndef emit_LDVAR_U2
#define emit_LDVAR_U2(offset)     \
    emit_LDVARA(offset);    \
    load_indirect_word_zeroextend(SCRATCH_1,SCRATCH_1); \
    _ASSERTE(inRegTOS); 
#endif // !emit_LDVAR_U2
#ifndef emit_LDVAR_I1
#define emit_LDVAR_I1(offset)     \
    emit_LDVARA(offset);    \
    load_indirect_byte_signextend(SCRATCH_1,SCRATCH_1); \
    _ASSERTE(inRegTOS); 
#endif // !emit_LDVAR_I1

#ifndef emit_LDVAR_I2
#define emit_LDVAR_I2(offset)     \
    emit_LDVARA(offset);    \
    load_indirect_word_signextend(SCRATCH_1,SCRATCH_1); \
    _ASSERTE(inRegTOS); 
#endif // !emit_LDVAR_I2

#ifndef emit_LDVAR_I4
#define emit_LDVAR_I4(offset)     \
    emit_LDVARA(offset);    \
    mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
    emit_pushresult_I4()
#endif // !emit_LDVAR_I4

#ifndef emit_LDVAR_I8
#define emit_LDVAR_I8(offset)     \
    emit_LDVARA(offset);    \
    emit_LDIND_I8();
#endif // !emit_LDVAR_I8

#ifndef emit_LDVAR_R4
#define emit_LDVAR_R4(offset)     \
    emit_LDVARA(offset);    \
    emit_LDIND_R4();  
#endif // !emit_LDVAR_R4

#ifndef emit_LDVAR_R8
#define emit_LDVAR_R8(offset)     \
    emit_LDVARA(offset);    \
    emit_LDIND_R8();
#endif // !emit_LDVAR_R8

#ifndef emit_STVAR_I4
#define emit_STVAR_I4(offset)     \
    emit_LDVARA(offset);    \
    enregisterTOS; \
    pop(ARG_1); \
    mov_register_indirect_from(ARG_1,SCRATCH_1); \
    inRegTOS = false
#endif // !emit_STVAR_I4

#ifndef emit_STVAR_I8
#define emit_STVAR_I8(offset)     \
    emit_LDVARA(offset);    \
    emit_STIND_REV_I8();
#endif // !emit_STVAR_I8

#ifndef emit_STVAR_R4
#define emit_STVAR_R4(offset)     \
    emit_LDVARA(offset);    \
    emit_STIND_REV_R4()
#endif // !emit_STVAR_R4

#ifndef emit_STVAR_R8
#define emit_STVAR_R8(offset)     \
    emit_LDVARA(offset);    \
    emit_STIND_REV_R8()
#endif // !emit_STVAR_R8

#ifndef emit_LDIND_U1
#define emit_LDIND_U1()     \
    enregisterTOS; \
    load_indirect_byte_zeroextend(SCRATCH_1,SCRATCH_1)
#endif // !emit_LDIND_U1

#ifndef emit_LDIND_U2
#define emit_LDIND_U2()     \
    enregisterTOS; \
    load_indirect_word_zeroextend(SCRATCH_1,SCRATCH_1)
#endif // !emit_LDIND_U2

#ifndef emit_LDIND_I1
#define emit_LDIND_I1()     \
    enregisterTOS; \
    load_indirect_byte_signextend(SCRATCH_1,SCRATCH_1)
#endif // !emit_LDIND_I1

#ifndef emit_LDIND_I2
#define emit_LDIND_I2()     \
    enregisterTOS; \
    load_indirect_word_signextend(SCRATCH_1,SCRATCH_1)
#endif // !emit_LDIND_I2

#ifndef emit_LDIND_I4
#define emit_LDIND_I4()     \
    enregisterTOS; \
    load_indirect_dword_signextend(SCRATCH_1,SCRATCH_1)
#endif // !emit_LDIND_I4

#ifndef emit_LDIND_I8
#define emit_LDIND_I8()                  x86_load_indirect_qword()
#endif

#ifndef emit_LDIND_U4
#define emit_LDIND_U4()     \
    enregisterTOS; \
    load_indirect_dword_zeroextend(SCRATCH_1,SCRATCH_1)
#endif // !emit_LDIND_U4

/*#ifndef emit_LDIND_I8
#define emit_LDIND_I8()     \
    emit_callhelper_I4_I8(LoadIndirect_I8_helper);        \
    emit_pushresult_I8()
#endif // !emit_LDIND_I8
*/

#ifndef emit_LDIND_R4 
#define emit_LDIND_R4() { \
   emit_LDIND_I4();   \
   emit_conv_R4toR(); \
   }
#endif // !emit_LDIND_R4

#ifndef emit_LDIND_R8
#define emit_LDIND_R8 emit_LDIND_I8   /* this should really load a 80bit float*/
#endif // !emit_LDIND_R8

// Note: the STIND op codes do not use the shared helpers since the
//       args on the stack are reversed
#ifndef emit_STIND_I1
#define emit_STIND_I1()     \
    enregisterTOS; \
    pop(ARG_1); \
    inRegTOS = false; \
    store_indirect_byte(SCRATCH_1,ARG_1); 
#endif

#ifndef emit_STIND_I2
#define emit_STIND_I2()     \
    enregisterTOS; \
    pop(ARG_1); \
    inRegTOS = false; \
    store_indirect_word(SCRATCH_1,ARG_1); 
#endif // !emit_STIND_I2


#ifndef emit_STIND_I4
#define emit_STIND_I4()     \
    enregisterTOS; \
    pop(ARG_1); \
    inRegTOS = false; \
    store_indirect_dword(SCRATCH_1,ARG_1); 
#endif // !emit_STIND_I4

#ifndef emit_STIND_I8
#define emit_STIND_I8()     \
    enregisterTOS; /*val lo*/\
    pop(ARG_1);  /* val hi*/ \
    pop(ARG_2); /*adr*/ \
    store_indirect_dword(SCRATCH_1,ARG_2); \
    add_constant(ARG_2,sizeof(void*)); \
    store_indirect_dword(ARG_1,ARG_2); \
    inRegTOS = false; 
#endif

#ifndef emit_STIND_REV_I8
#define emit_STIND_REV_I8() \
    enregisterTOS; /* adr */  \
    pop(ARG_1);  /* val lo */ \
    pop(ARG_2); /* vali hi */ \
    store_indirect_dword(ARG_1,SCRATCH_1); \
    add_constant(SCRATCH_1,sizeof(void*)); \
    store_indirect_dword(ARG_2,SCRATCH_1); \
    inRegTOS = false; 
#endif

#ifndef emit_STIND_REV_I1
#define emit_STIND_REV_I1()     \
    enregisterTOS; \
    pop(ARG_1); \
    inRegTOS = false; \
    store_indirect_byte(ARG_1,SCRATCH_1); 
#endif

#ifndef emit_STIND_REV_I2
#define emit_STIND_REV_I2()     \
    enregisterTOS; \
    pop(ARG_1); \
    inRegTOS = false; \
    store_indirect_word(ARG_1,SCRATCH_1); 
#endif // !emit_STIND_REV_I2


#ifndef emit_STIND_REV_I4
#define emit_STIND_REV_I4()     \
    enregisterTOS; \
    pop(ARG_1); \
    inRegTOS = false; \
    store_indirect_dword(ARG_1,SCRATCH_1); 
#endif // !emit_STIND_REV_I4

#ifndef emit_STIND_REV_Ref
#define emit_STIND_REV_Ref(IsSTSFLD)     \
	if (IsSTSFLD) {\
	  LABELSTACK((outPtr-outBuff), 1);				\
	} \
    else { \
	  LABELSTACK((outPtr-outBuff), 2);				\
	} \
    emit_callhelper_I4I4(STIND_REV_REF_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL STIND_REV_REF_helper(CORINFO_Object** ptr_, CORINFO_Object* val) {
#ifdef _X86_
    __asm{
        mov edx,ptr_
        mov eax,val
        }
    FJit_pHlpAssign_Ref_EAX();
#else
    _ASSERTE(!"@TODO Alpha - STIND_REV_REF helper (fjitdef.h)");
#endif  // _X86_
}
#endif
#endif // !emit_STIND_REV_REF


#ifndef emit_STIND_R4
#define emit_STIND_R4() { \
	emit_conv_R8toR4();\
    emit_STIND_I4();\
	}
#endif 

#ifndef emit_STIND_R8
#define emit_STIND_R8 emit_STIND_I8
#endif 


#ifndef emit_STIND_REF
#define emit_STIND_REF()                                \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4(STIND_REF_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL STIND_REF_helper(CORINFO_Object* val, CORINFO_Object** ptr_) {
#ifdef _X86_
    __asm{
        mov edx,ptr_
        mov eax,val
        }
    FJit_pHlpAssign_Ref_EAX();
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - STIND_R8_helper (fjitdef.h)");
#endif  // _X86_
}
#endif  // DECLARE_HELPERS
#endif  // emit_STIND_REF


#ifndef emit_STIND_REV_I4
#define emit_STIND_REV_I4()     \
    enregisterTOS; \
    pop(ARG_1); \
    inRegTOS = false; \
    store_indirect_dword(ARG_1,SCRATCH_1); 
#endif


#ifndef emit_STIND_REV_R4
#define emit_STIND_REV_R4() { \
    enregisterTOS; \
    inRegTOS = false; \
	emit_conv_RtoR4() \
    pop(ARG_1); \
    store_indirect_dword(ARG_1,SCRATCH_1); \
}
#endif

#ifndef emit_STIND_REV_R8
#define emit_STIND_REV_R8 emit_STIND_REV_I8
#endif


#define emit_LDC_I(val) emit_WIN32(emit_LDC_I4(val)) ;\
                        emit_WIN64(emit_LDC_I8(val))

#ifndef emit_LDC_I4
#define emit_LDC_I4(val)    \
    emit_pushconstant_4(val)
#endif

#ifndef emit_LDC_I8
#define emit_LDC_I8(val)    \
    emit_pushconstant_8(val)
#endif

#ifndef emit_LDC_R4
#define emit_LDC_R4(val)  {          \
    emit_pushconstant_4(val); \
	emit_conv_R4toR();        \
}
#endif

#ifndef emit_LDC_R8
#define emit_LDC_R8(val)            \
    emit_pushconstant_8(val)
#endif

#ifndef emit_CPBLK
#define emit_CPBLK()                    \
    emit_callhelper_I4I4I4(CPBLK_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL CPBLK_helper(int size, char* pSrc, char* pDst) {
    memcpy(pDst, pSrc, size);
}
#endif
#endif

#ifndef emit_INITBLK
#define emit_INITBLK()                  \
    emit_callhelper_I4I4I4(INITBLK_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL INITBLK_helper(int size, char val, char* pDst) {
    memset(pDst, val, size);
}
#endif
#endif


#ifndef emit_INITBLKV
#define emit_INITBLKV(val)                  \
    emit_LDC_I4(val);                       \
    emit_callhelper_I4I4I4(INITBLKV_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL INITBLKV_helper(char val, int size, char* pDst) {
    memset(pDst, val, size);
}
#endif
#endif

#ifndef emit_ADD_I4
#define emit_ADD_I4()               \
    emit_callhelper_I4I4_I4(ADD_I4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL ADD_I4_helper(int i, int j) {
    return j + i;
}
#endif
#endif


#ifndef emit_ADD_I8
#define emit_ADD_I8()   \
    emit_callhelper_I8I8_I8(ADD_I8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL ADD_I8_helper(__int64 i, __int64 j) {
    return j + i;
}
#endif
#endif


#ifndef emit_ADD_R4
#define emit_ADD_R4()   \
    emit_callhelper_R4R4_I4(ADD_R4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL ADD_R4_helper(float i, float j) {
    float result = j+i;
    return *(unsigned int*)&result;
}
#endif
#endif


#ifndef emit_ADD_R8
#define emit_ADD_R8()   \
    emit_callhelper_R8R8_I8(ADD_R8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL ADD_R8_helper(double i, double j) {
    double result = j + i;
    return *(unsigned __int64*)&result;
}
#endif
#endif


#ifndef emit_SUB_I4
#define emit_SUB_I4()   \
    emit_callhelper_I4I4_I4(SUB_I4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL SUB_I4_helper(int i, int j) {
    return j - i;
}
#endif
#endif


#ifndef emit_SUB_I8
#define emit_SUB_I8()   \
    emit_callhelper_I8I8_I8(SUB_I8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL SUB_I8_helper(__int64 i, __int64 j) {
    return j - i;
}
#endif
#endif


#ifndef emit_SUB_R4
#define emit_SUB_R4()   \
    emit_callhelper_R4R4_I4(SUB_R4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL SUB_R4_helper(float i, float j) {
    float result = j - i;
    return *(unsigned int*)&result;
}
#endif
#endif


#ifndef emit_SUB_R8
#define emit_SUB_R8()   \
    emit_callhelper_I8I8_I8(SUB_R8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL SUB_R8_helper(double i, double j) {
    double result = j - i;
    return *(unsigned __int64*)&result;
}
#endif
#endif


#ifndef emit_MUL_I4
#define emit_MUL_I4()   \
    emit_callhelper_I4I4_I4(MUL_I4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL MUL_I4_helper(int i, int j) {
    return j * i;
}
#endif
#endif


#ifndef emit_MUL_I8
#define emit_MUL_I8()   \
    emit_callhelper_I8I8_I8(MUL_I8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL MUL_I8_helper(__int64 i, __int64 j) {
    return j * i;
}
#endif
#endif


#ifndef emit_MUL_R4
#define emit_MUL_R4()   \
    emit_callhelper_R4R4_I4(MUL_R4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL MUL_R4_helper(float i, float j) {
    float result = j * i;
    return *(unsigned int*)&result;
}
#endif
#endif


#ifndef emit_MUL_R8
#define emit_MUL_R8()   \
    emit_callhelper_R8R8_R8(MUL_R8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL MUL_R8_helper(double i, double j) {
    double result = j * i;
    return *(unsigned __int64*)&result;
}
#endif
#endif


#ifndef emit_DIV_I4
#define emit_DIV_I4()                           \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(DIV_I4_helper);         \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL DIV_I4_helper(int i, int j) {

    // check for divisor == 0 and divisor == -1 cases at the same time
    if (((unsigned int) -i) <= 1) {
        if(i == 0) {
            THROW_FROM_HELPER_RET(CORINFO_DivideByZeroException);
        }
        else if (j == 0x80000000 ) {
            //divisor == -1, dividend == MIN_INT
            THROW_FROM_HELPER_RET(CORINFO_OverflowException);
        }
    }
    return j / i;
}
#endif
#endif


#ifndef emit_DIV_I8
#define emit_DIV_I8()                           \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I8I8_I8(DIV_I8_helper);         \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL DIV_I8_helper(__int64 i, __int64 j) {
    // check for divisor == 0 and divisor == -1 cases at the same time
    if (((unsigned __int64) -i) <= 1) {
        if(i == 0) {
            THROW_FROM_HELPER_RET(CORINFO_DivideByZeroException);
        }
        else if (j == 0x8000000000000000L ) {
            //divisor == -1, dividend == MIN_INT
            THROW_FROM_HELPER_RET(CORINFO_OverflowException);
        }
    }
    return j / i;
}
#endif
#endif

#ifndef emit_DIV_UN_U4
#define emit_DIV_UN_U4()                           \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(DIV_UN_U4_helper);         \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL DIV_UN_U4_helper(unsigned int i, unsigned int j) {
    if (i == 0) {
        THROW_FROM_HELPER_RET(CORINFO_DivideByZeroException);
    }
    return j / i;
}
#endif
#endif

#ifndef emit_DIV_UN_U8
#define emit_DIV_UN_U8()                           \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I8I8_I8(DIV_UN_U8_helper);         \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL DIV_UN_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    if(i == 0) {
        THROW_FROM_HELPER_RET(CORINFO_DivideByZeroException);
    }
    return j / i;
}
#endif
#endif

#ifndef emit_DIV_R4
#define emit_DIV_R4()                           \
    emit_callhelper_R4R4_I4(DIV_R4_helper);         \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL DIV_R4_helper(float i, float j) {
    float result = j / i;
    return *(unsigned int*)&result;
}
#endif
#endif

#ifndef emit_DIV_R8
#define emit_DIV_R8()                           \
    emit_callhelper_R8R8_I8(DIV_R8_helper);         \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL DIV_R8_helper(double i, double j) {
    double result = j / i;
    return *(unsigned __int64*)&result;
}
#endif
#endif

#ifndef emit_REM_I4
#define emit_REM_I4()                           \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(REM_I4_helper);         \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL REM_I4_helper(int i, int j) {
    // check for divisor == 0 and divisor == -1 cases at the same time
    if (((unsigned int) -i) <= 1) {
        if(i == 0) {
            THROW_FROM_HELPER_RET(CORINFO_DivideByZeroException);
        }
        else if (j == 0x80000000 ) {
            //divisor == -1, dividend == MIN_INT
            THROW_FROM_HELPER_RET(CORINFO_OverflowException);
        }
    }
    return j % i;
}
#endif
#endif

#ifndef emit_REM_I8
#define emit_REM_I8()                           \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I8I8_I8(REM_I8_helper);         \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL REM_I8_helper(__int64 i, __int64 j) {
    // check for divisor == 0 and divisor == -1 cases at the same time
    if (((unsigned __int64) -i) <= 1) {
        if(i == 0) {
            THROW_FROM_HELPER_RET(CORINFO_DivideByZeroException);
        }
        else if (j == 0x8000000000000000L ) {
            //divisor == -1, dividend == MIN_INT
            THROW_FROM_HELPER_RET(CORINFO_OverflowException);
        }
    }
    return j % i;
}
#endif
#endif


#ifndef emit_REM_R8
#define emit_REM_R8()                           \
    emit_callhelper_R8R8_I8(REM_R8_helper);         \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL REM_R8_helper(double i, double j) {
    double result = FJit_pHlpDblRem(i,j);
    return *(unsigned __int64*)&result;
}
#endif
#endif

#ifndef emit_REM_UN_U4
#define emit_REM_UN_U4()                           \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(REM_UN_U4_helper);         \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL REM_UN_U4_helper(unsigned int i, unsigned int j) {
    if (i == 0) {
        THROW_FROM_HELPER_RET(CORINFO_DivideByZeroException);
    }
    return j % i;
}
#endif
#endif

#ifndef emit_REM_UN_U8
#define emit_REM_UN_U8()                           \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I8I8_I8(REM_UN_U8_helper);         \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL REM_UN_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    if(i == 0) {
        THROW_FROM_HELPER_RET(CORINFO_DivideByZeroException);
    }
    return j % i;
}
#endif
#endif

#ifndef emit_MUL_OVF_I1
#define emit_MUL_OVF_I1()                           \
  	LABELSTACK((outPtr-outBuff),0);				\
    emit_callhelper_I4I4_I4(MUL_OVF_I1_helper);         \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL MUL_OVF_I1_helper(int i, int j) {
    int i4 = j * i;
    if((int)(signed char) i4 != i4) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return i4;
}
#endif
#endif

#ifndef emit_MUL_OVF_I2
#define emit_MUL_OVF_I2()                           \
  	LABELSTACK((outPtr-outBuff),0);				\
    emit_callhelper_I4I4_I4(MUL_OVF_I2_helper);         \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL MUL_OVF_I2_helper(int i, int j) {
    int i4 = j * i;
    if((int)(signed short) i4 != i4) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return i4;
}
#endif
#endif

#ifndef emit_MUL_OVF_I4
#define emit_MUL_OVF_I4()                           \
  	LABELSTACK((outPtr-outBuff),0);				\
    emit_callhelper_I4I4_I4(MUL_OVF_I4_helper);         \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL MUL_OVF_I4_helper(int i, int j) {
    __int64 i8 = (__int64) j * (__int64) i;
    if((__int64)(int) i8 != i8) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (int) i8;
}
#endif
#endif

#ifndef emit_MUL_OVF_I8
#define emit_MUL_OVF_I8()                           \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_I8I8_I8(FJit_pHlpLMulOvf);          \
    emit_pushresult_I8()
#endif

#ifndef emit_MUL_OVF_U1
#define emit_MUL_OVF_U1()                           \
  	LABELSTACK((outPtr-outBuff),0);				\
    emit_callhelper_I4I4_I4(MUL_OVF_U1_helper);         \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL MUL_OVF_U1_helper(unsigned int i, unsigned int j) {
    unsigned int u4 = j * i;
    if(u4 > 0xff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return u4;
}
#endif
#endif

#ifndef emit_MUL_OVF_U2
#define emit_MUL_OVF_U2()                           \
  	LABELSTACK((outPtr-outBuff),0);				\
    emit_callhelper_I4I4_I4(MUL_OVF_U2_helper);         \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL MUL_OVF_U2_helper(unsigned int i, unsigned int j) {
    unsigned int u4 = j * i;
    if(u4 > 0xffff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return u4;
}
#endif
#endif

#ifndef emit_MUL_OVF_U4
#define emit_MUL_OVF_U4()                           \
  	LABELSTACK((outPtr-outBuff),0);				\
    emit_callhelper_I4I4_I4(MUL_OVF_U4_helper);         \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL MUL_OVF_U4_helper(unsigned int i, unsigned int j) {
    unsigned __int64 u8 = (unsigned __int64) j * (unsigned __int64) i;
    if(u8 > 0xffffffff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (unsigned int) u8;
}
#endif
#endif

#ifndef emit_MUL_OVF_U8
#define emit_MUL_OVF_U8()                           \
  	LABELSTACK((outPtr-outBuff),0);				\
    emit_callhelper_I8I8_I8(MUL_OVF_U8_helper);         \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL MUL_OVF_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    unsigned __int64 u8 = 0;
    while (i > 0) {
        if (i & 1) {
            if (u8 + j < u8) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
            }
            u8 += j;
        }
        i >>= 1;
        if (i > 0 && (j & 0x8000000000000000L)) 
        {
            THROW_FROM_HELPER_RET(CORINFO_OverflowException);
        }
        j <<= 1;
    }
    return u8;
}
#endif
#endif


#ifndef emit_CEQ_I4
#define emit_CEQ_I4()    \
    emit_callhelper_I4I4_I4(CEQ_I4_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CEQ_I4_helper(int i, int j) {
    return (j == i);
}
#endif
#endif


#ifndef emit_CEQ_I8
#define emit_CEQ_I8()    \
    emit_callhelper_I8I8_I4(CEQ_I8_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CEQ_I8_helper(__int64 i, __int64 j) {
    return (j == i);
}
#endif
#endif

#ifndef emit_CEQ_R4
#define emit_CEQ_R4()    \
    emit_callhelper_R4R4_I4(CEQ_R4_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CEQ_R4_helper(float i, float j) {
    if (_isnan(i) || _isnan(j))
    {
        return FALSE;
    }
    return (j == i);
}
#endif
#endif

#ifndef emit_CEQ_R8
#define emit_CEQ_R8()    \
    emit_callhelper_R8R8_I4(CEQ_R8_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CEQ_R8_helper(double i, double j) {
    if (_isnan(j) || _isnan(i))
    {
        return FALSE;
    }
    return (j == i);
}
#endif
#endif


#ifndef emit_CGT_I4
#define emit_CGT_I4()    \
    emit_callhelper_I4I4_I4(CGT_I4_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CGT_I4_helper(int i, int j) {
    return (j > i);
}
#endif
#endif

#ifndef emit_CGT_UN_I4
#define emit_CGT_UN_I4()    \
    emit_callhelper_I4I4_I4(CGT_U4_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CGT_U4_helper(unsigned int i, unsigned int j) {
    return (j > i);
}
#endif
#endif

#ifndef emit_CGE_U4
#define emit_CGE_U4()    \
    emit_callhelper_I4I4_I4(CGE_U4_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CGE_U4_helper(unsigned int i, unsigned int j) {
    return (j >= i);
}
#endif
#endif
#ifndef emit_CGT_I8
#define emit_CGT_I8()    \
    emit_callhelper_I8I8_I4(CGT_I8_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CGT_I8_helper(__int64 i, __int64 j) {
    return (j > i);
}
#endif
#endif


#ifndef emit_CGT_UN_I8
#define emit_CGT_UN_I8()    \
    emit_callhelper_I8I8_I4(CGT_U8_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CGT_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    return (j > i);
}
#endif
#endif

#ifndef emit_CGE_U8
#define emit_CGE_U8()    \
    emit_callhelper_I8I8_I4(CGE_U8_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CGE_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    return (j >= i);
}
#endif
#endif

#ifndef emit_CLT_I4
#define emit_CLT_I4()    \
    emit_callhelper_I4I4_I4(CLT_I4_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CLT_I4_helper(int i, int j) {
    return (j < i);
}
#endif
#endif

#ifndef emit_CLT_UN_I4
#define emit_CLT_UN_I4()    \
    emit_callhelper_I4I4_I4(CLT_U4_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CLT_U4_helper(unsigned int i, unsigned int j) {
    return (j < i);
}
#endif
#endif

#ifndef emit_CLE_U4
#define emit_CLE_U4()    \
    emit_callhelper_I4I4_I4(CLE_U4_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CLE_U4_helper(unsigned int i, unsigned int j) {
    return (j <= i);
}
#endif
#endif

#ifndef emit_CLT_I8
#define emit_CLT_I8()    \
    emit_callhelper_I8I8_I4(CLT_I8_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CLT_I8_helper(__int64 i, __int64 j) {
    return (j < i);
}
#endif
#endif

#ifndef emit_CLT_UN_I8
#define emit_CLT_UN_I8()    \
    emit_callhelper_I8I8_I4(CLT_U8_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CLT_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    return (j < i);
}
#endif
#endif
#ifndef emit_CLE_U8
#define emit_CLE_U8()    \
    emit_callhelper_I8I8_I4(CLE_U8_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CLE_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    return (j <= i);
}
#endif
#endif
#ifndef emit_CLT_R4
#define emit_CLT_R4()    \
    emit_callhelper_R4R4_I4(CLT_R4_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CLT_R4_helper(float i, float j) {
    // if either number is NaN return FALSE
    if (_isnan(j) || _isnan(i))
    {
        return FALSE;
    }
    return j < i;
}
#endif
#endif

#ifndef emit_CLT_R8
#define emit_CLT_R8()    \
    emit_callhelper_R8R8_I4(CLT_R8_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CLT_R8_helper(double i, double j) {
    // if either number is NaN return FALSE
    if (_isnan(j) || _isnan(i))
    {
        return FALSE;
    }
    return j < i;
}
#endif
#endif

#ifndef emit_CLT_UN_R4
#define emit_CLT_UN_R4()    \
    emit_callhelper_R4R4_I4(CLT_UN_R4_helper);      \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CLT_UN_R4_helper(float i, float j) {
    // if either number is NaN return TRUE
    if (_isnan(j) || _isnan(i))
    {
        return TRUE;
    }
    return j < i;
}
#endif
#endif

#ifndef emit_CLT_UN_R8
#define emit_CLT_UN_R8()    \
    emit_callhelper_R8R8_I4(CLT_UN_R8_helper);      \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CLT_UN_R8_helper(double i, double j) {
    // if either number is NaN return TRUE
    if (_isnan(j) || _isnan(i))
    {
        return TRUE;
    }
    return j < i;
}
#endif
#endif



#ifndef emit_CGT_R4
#define emit_CGT_R4()    \
    emit_callhelper_R4R4_I4(CGT_R4_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CGT_R4_helper(float i, float j) {
    // if either number is NaN return FALSE
    if (_isnan(j) || _isnan(i))
    {
        return FALSE;
    }
    return j > i;
}
#endif
#endif

#ifndef emit_CGT_R8
#define emit_CGT_R8()    \
    emit_callhelper_R8R8_I4(CGT_R8_helper);     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CGT_R8_helper(double i, double j) {
    // if either number is NaN return FALSE
    if (_isnan(j) || _isnan(i))
    {
        return FALSE;
    }
    return j > i;
}
#endif
#endif

#ifndef emit_CGT_UN_R4
#define emit_CGT_UN_R4()    \
    emit_callhelper_R4R4_I4(CGT_UN_R4_helper);      \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CGT_UN_R4_helper(float i, float j) {
    // if either number is NaN return TRUE
    if (_isnan(j) || _isnan(i))
    {
        return TRUE;
    }
    return j > i;
}
#endif
#endif

#ifndef emit_CGT_UN_R8
#define emit_CGT_UN_R8()    \
    emit_callhelper_R8R8_I4(CGT_UN_R8_helper);      \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CGT_UN_R8_helper(double i, double j) {
    // if either number is NaN return TRUE
    if (_isnan(j) || _isnan(i))
    {
        return TRUE;
    }
    return j > i;
}
#endif
#endif

#ifndef emit_compareTOS_I4
#define emit_compareTOS_I4()        \
    emit_callhelper_I4I4_I4(CompareTOS_I4_helper);      \
    emit_pushresult_I4();       \
    emit_testTOS()
#ifdef DECLARE_HELPERS
int HELPER_CALL CompareTOS_I4_helper(int i, int j) {
    return (j - i);
}
#endif
#endif

#ifndef emit_compareTOS_I8
#define emit_compareTOS_I8()            \
    emit_callhelper_I8I8_I4(CompareTOS_I8_helper);      \
    emit_pushresult_I4();       \
    emit_testTOS()
#ifdef DECLARE_HELPERS
int HELPER_CALL CompareTOS_I8_helper(__int64 i, __int64 j) {
    return (j < i)? -1: (j == i)? 0 : 1;
}
#endif
#endif

#ifndef emit_compareTOS_UN_I4
#define emit_compareTOS_UN_I4()        \
    emit_callhelper_I4I4_I4(CompareTOS_U4_helper);      \
    emit_pushresult_I4();       \
    emit_testTOS()
#ifdef DECLARE_HELPERS
int HELPER_CALL CompareTOS_U4_helper(unsigned int i, unsigned int j) {
    return (j < i)? -1: (j == i)? 0 : 1;
}
#endif
#endif

#ifndef emit_compareTOS_UN_I8
#define emit_compareTOS_UN_I8()            \
    emit_callhelper_I8I8_I4(CompareTOS_U8_helper);      \
    emit_pushresult_I4();       \
    emit_testTOS()
#ifdef DECLARE_HELPERS
int HELPER_CALL CompareTOS_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    return (j < i)? -1: (j == i)? 0 : 1;
}
#endif
#endif

#ifndef emit_compareTOS_Ptr
#define emit_compareTOS_Ptr()           \
    emit_WIN32(emit_compareTOS_UN_I4();)                   \
    emit_WIN64(emit_compareTOS_UN_I8();)
#endif

/******************************************************************/
/* signed convert overlow */

#ifndef emit_CONV_OVF_TOI1_I4
#define emit_CONV_OVF_TOI1_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I4_I4(CONV_OVF_TOI1_I4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI1_I4_helper(int val) {
    char i1 = val ;
    if (val != (int) i1) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (int) i1;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOI1_I8
#define emit_CONV_OVF_TOI1_I8()                 \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_TOI1_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI1_I8_helper(__int64 val) {
    __int8 x = (__int8) val;
    if ( (__int64) x != val) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (int) x;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOI1_R4
#define emit_CONV_OVF_TOI1_R4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R4_I4(CONV_OVF_TOI1_R4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI1_R4_helper(float val) {
    if ( _isnan(val) || val >= SCHAR_MAX + 1.0 || val <= SCHAR_MIN - 1.0)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int8) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOI1_R8
#define emit_CONV_OVF_TOI1_R8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R8_I4(CONV_OVF_TOI1_R8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI1_R8_helper(double val) {
    if ( _isnan(val) || val >= SCHAR_MAX + 1.0 || val <= SCHAR_MIN - 1.0)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int8) val;
}
#endif
#endif

/****************************************************************
// Support for Precise R
*****************************************************************/
#ifndef emit_CONV_OVF_TOI1_R
#define emit_CONV_OVF_TOI1_R()         \
    emit_conv_RtoR4(); \
    emit_CONV_OVF_TOI1_R4();
#endif

#ifndef emit_CONV_OVF_TOI2_R
#define emit_CONV_OVF_TOI2_R()         \
    emit_conv_RtoR4(); \
    emit_CONV_OVF_TOI2_R4();
#endif

#ifndef emit_CONV_OVF_TOI4_R
#define emit_CONV_OVF_TOI4_R()         \
    emit_conv_RtoR4(); \
    emit_CONV_OVF_TOI4_R4();
#endif

#ifndef emit_CONV_OVF_TOI8_R
#define emit_CONV_OVF_TOI8_R()         \
    emit_conv_RtoR8(); \
    emit_CONV_OVF_TOI8_R8();
#endif

#ifndef emit_CONV_OVF_TOU1_R
#define emit_CONV_OVF_TOU1_R()         \
    emit_conv_RtoR4(); \
    emit_CONV_OVF_TOU1_R4();
#endif

#ifndef emit_CONV_OVF_TOU2_R
#define emit_CONV_OVF_TOU2_R()         \
    emit_conv_RtoR4(); \
    emit_CONV_OVF_TOU2_R4();
#endif

#ifndef emit_CONV_OVF_TOU4_R
#define emit_CONV_OVF_TOU4_R()         \
    emit_conv_RtoR4(); \
    emit_CONV_OVF_TOU4_R4();
#endif

#ifndef emit_CONV_OVF_TOU8_R
#define emit_CONV_OVF_TOU8_R()         \
    emit_conv_RtoR8(); \
    emit_CONV_OVF_TOU8_R8();
#endif

#ifndef emit_CONV_TOI1_R
#define emit_CONV_TOI1_R()                 \
    emit_conv_RtoR8(); \
    emit_callhelper_R8_I4(CONV_TOI1_R8_helper);  \
    emit_pushresult_I4()
#endif

#ifndef emit_CONV_TOI2_R
#define emit_CONV_TOI2_R()                 \
    emit_conv_RtoR8(); \
    emit_callhelper_R8_I4(CONV_TOI2_R8_helper);  \
    emit_pushresult_I4()
#endif

#ifndef emit_CONV_TOI4_R
#define emit_CONV_TOI4_R()                 \
    emit_conv_RtoR8() ; \
    emit_callhelper_R8_I4(CONV_TOI4_R8_helper);  \
    emit_pushresult_I4()
#endif

#ifndef emit_CONV_TOI8_R
#define emit_CONV_TOI8_R()                 \
    emit_conv_RtoR8(); \
    emit_callhelper_R8_I8(CONV_TOI8_R8_helper);  \
    emit_pushresult_I8()
#endif


#ifndef emit_CONV_TOU1_R
#define emit_CONV_TOU1_R()                 \
    emit_conv_RtoR8(); \
    emit_callhelper_R8_I4(CONV_TOU1_R8_helper);  \
    emit_pushresult_I4()
#endif

#ifndef emit_CONV_TOU2_R
#define emit_CONV_TOU2_R()                 \
    emit_conv_RtoR8(); \
    emit_callhelper_R8_I4(CONV_TOU2_R8_helper);  \
    emit_pushresult_I4()
#endif

/****************************************************************/

#ifndef emit_CONV_OVF_TOI2_I4
#define emit_CONV_OVF_TOI2_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I4_I4(CONV_OVF_TOI2_I4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI2_I4_helper(int val) {
    signed short i2 = val;
    if (val != (int) i2) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return i2;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOI2_I8
#define emit_CONV_OVF_TOI2_I8()                 \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_TOI2_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI2_I8_helper(__int64 val) {
    __int16 x = (__int16) val;
    if (((__int64) x ) != val) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (int) x;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOI2_R4
#define emit_CONV_OVF_TOI2_R4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R4_I4(CONV_OVF_TOI2_R4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI2_R4_helper(float val) {
    if ( _isnan(val) || val >= SHRT_MAX + 1.0 || val <= SHRT_MIN - 1.0)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int16) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOI2_R8
#define emit_CONV_OVF_TOI2_R8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R8_I4(CONV_OVF_TOI2_R8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI2_R8_helper(double val) {
    if ( _isnan(val) || val >= SHRT_MAX + 1.0 || val <= SHRT_MIN - 1.0)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int16) val;
}
#endif
#endif

#define emit_CONV_OVF_TOI4_I4() /* do nothing */

#ifndef emit_CONV_OVF_TOI4_I8
#define emit_CONV_OVF_TOI4_I8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_TOI4_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI4_I8_helper(signed __int64 val) {
    int i4 = (int) val;
    if (val != (signed __int64) i4) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return i4;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOI4_R4
#define emit_CONV_OVF_TOI4_R4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R4_I4(CONV_OVF_TOI4_R4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI4_R4_helper(float val) {
    if ( _isnan(val) || val >= INT_MAX + 1.0 || val <= INT_MIN - 1.0)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int32) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOI4_R8
#define emit_CONV_OVF_TOI4_R8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R8_I4(CONV_OVF_TOI4_R8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOI4_R8_helper(double val) {
    if ( _isnan(val) || val >= INT_MAX + 1.0 || val <= INT_MIN - 1.0)
	{
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int32) val;
}
#endif
#endif

#define emit_CONV_OVF_TOI8_I4() emit_CONV_TOI8_I4()

#define emit_CONV_OVF_TOI8_I8() /* do nothing */

#ifndef emit_CONV_OVF_TOI8_R4
#define emit_CONV_OVF_TOI8_R4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R4_I8(CONV_OVF_TOI8_R4_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_OVF_TOI8_R4_helper(float val) {
    if ( _isnan(val) || val > INT64_MAX || val < INT64_MIN)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int64) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOI8_R8
#define emit_CONV_OVF_TOI8_R8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R8_I8(CONV_OVF_TOI8_R8_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_OVF_TOI8_R8_helper(double val) {
    if ( _isnan(val) || val > INT64_MAX || val < INT64_MIN)
	{
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int64) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU1_I4
#define emit_CONV_OVF_TOU1_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I4_I4(CONV_OVF_TOU1_U4_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_TOU1_U4_helper(unsigned int val) {
    if (val > 0xff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU1_I8
#define emit_CONV_OVF_TOU1_I8()                 \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_TOU1_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOU1_I8_helper(__int64 val) {
    unsigned __int8 x = (unsigned __int8) val;
    if ((__int64) x != val) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (int) x;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU1_R4
#define emit_CONV_OVF_TOU1_R4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R4_I4(CONV_OVF_TOU1_R4_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_TOU1_R4_helper(float val) {
    if ( _isnan(val) || val <= -1.0 || val >= UCHAR_MAX + 1.0)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int8) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU1_R8
#define emit_CONV_OVF_TOU1_R8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R8_I4(CONV_OVF_TOU1_R8_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_TOU1_R8_helper(double val) {
    if ( _isnan(val) || val <= -1.0 || val >= UCHAR_MAX + 1.0 )
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int8) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU2_I4
#define emit_CONV_OVF_TOU2_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I4_I4(CONV_OVF_TOU2_U4_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_TOU2_U4_helper(unsigned int val) {
    if (val > 0xffff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU2_I8
#define emit_CONV_OVF_TOU2_I8()                 \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_TOU2_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_TOU2_I8_helper(__int64 val) {
    unsigned __int16 x = (unsigned __int16) val;
    if ((__int64) x != val) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (int) x;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU2_R4
#define emit_CONV_OVF_TOU2_R4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R4_I4(CONV_OVF_TOU2_R4_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_TOU2_R4_helper(float val) {
    if ( _isnan(val) || val <= -1.0 || val >= USHRT_MAX + 1.0)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int16) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU2_R8
#define emit_CONV_OVF_TOU2_R8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R8_I4(CONV_OVF_TOU2_R8_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_TOU2_R8_helper(double val) {
    if ( _isnan(val) || val <= -1.0 || val >= USHRT_MAX + 1.0 )
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int16) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU4_I4
#define emit_CONV_OVF_TOU4_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I4_I4(CONV_OVF_TOU4_I4_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_TOU4_I4_helper(int val) {
    if (val < 0) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU4_I8
#define emit_CONV_OVF_TOU4_I8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_TOU4_U8_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_TOU4_U8_helper(unsigned __int64 val) {
    if (val > 0xffffffff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (unsigned __int32) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU4_R4
#define emit_CONV_OVF_TOU4_R4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R4_I4(CONV_OVF_TOU4_R4_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_TOU4_R4_helper(float val) {
    if ( _isnan(val) || val <= -1.0 || val >= UINT_MAX + 1.0)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
	__int64 valI8 = (__int64) val;
    return (unsigned __int32) valI8;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU4_R8
#define emit_CONV_OVF_TOU4_R8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R8_I4(CONV_OVF_TOU4_R8_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_TOU4_R8_helper(double val) {
    if ( _isnan(val) || val <= -1.0 || val >= UINT_MAX + 1.0)
	{
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
	__int64 valI8 = (__int64) val;
    return (unsigned __int32) valI8;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU8_I4
#define emit_CONV_OVF_TOU8_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_TOU8_I4_helper);  \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL CONV_OVF_TOU8_I4_helper(signed __int32 val) {
    if (val < 0) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU8_I8
#define emit_CONV_OVF_TOU8_I8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I8(CONV_OVF_TOU8_I8_helper);  \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL CONV_OVF_TOU8_I8_helper(signed __int64 val) {
    if (val < 0) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return val;
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU8_R4
#define emit_CONV_OVF_TOU8_R4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R4_I8(CONV_OVF_TOU8_R4_helper);  \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL CONV_OVF_TOU8_R4_helper(float val) {
    if ( _isnan(val) || val <= -1.0 || val > UINT64_MAX)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    if (val <= INT64_MAX) 
		return (unsigned __int64) val;

		// subtract 0x8000000000000000, do the convert then add it back again
    val = (val - (float) (2147483648.0 * 4294967296.0));
	return(((unsigned __int64) val) + 0x8000000000000000L);
}
#endif
#endif

#ifndef emit_CONV_OVF_TOU8_R8
#define emit_CONV_OVF_TOU8_R8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_R8_I8(CONV_OVF_TOU8_R8_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL CONV_OVF_TOU8_R8_helper(double val) {
    if ( _isnan(val) || val <= -1.0 || val > UINT64_MAX)
    {   // have we overflowed
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }

    if (val <= INT64_MAX) 
		return (unsigned __int64) val;

		// subtract 0x8000000000000000, do the convert then add it back again
    val = (val - (2147483648.0 * 4294967296.0));
	return(((unsigned __int64) val) + 0x8000000000000000L);
}
#endif
#endif

/******************************************************************/
/* unsigned convert overlow */

#ifndef emit_CONV_OVF_UN_TOI1_I4
#define emit_CONV_OVF_UN_TOI1_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I4_I4(CONV_OVF_UN_TOI1_I4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_UN_TOI1_I4_helper(unsigned int val) {
    if (val > 0x7F) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int8) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_UN_TOI1_I8
#define emit_CONV_OVF_UN_TOI1_I8()                 \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_UN_TOI1_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_UN_TOI1_I8_helper(unsigned __int64 val) {
    if (val > 0x7F) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int8) val;
}
#endif
#endif

#define emit_CONV_OVF_UN_TOI1_R4() emit_CONV_OVF_TOI1_R4() 

#define emit_CONV_OVF_UN_TOI1_R8() emit_CONV_OVF_TOI1_R8() 

#define emit_CONV_OVF_UN_TOI1_R() emit_CONV_OVF_TOI1_R() 

#ifndef emit_CONV_OVF_UN_TOI2_I4
#define emit_CONV_OVF_UN_TOI2_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I4_I4(CONV_OVF_UN_TOI2_I4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_UN_TOI2_I4_helper(unsigned int val) {
    if (val > 0x7FFF) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int16) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_UN_TOI2_I8
#define emit_CONV_OVF_UN_TOI2_I8()                 \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_UN_TOI2_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_UN_TOI2_I8_helper(unsigned __int64 val) {
    if (val > 0x7FFF) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int16) val;
}
#endif
#endif

#define emit_CONV_OVF_UN_TOI2_R4() emit_CONV_OVF_TOI2_R4() 

#define emit_CONV_OVF_UN_TOI2_R8() emit_CONV_OVF_TOI2_R8() 

#define emit_CONV_OVF_UN_TOI2_R()  emit_CONV_OVF_TOI2_R() 

#ifndef emit_CONV_OVF_UN_TOI4_I4
#define emit_CONV_OVF_UN_TOI4_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I4_I4(CONV_OVF_UN_TOI4_I4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_UN_TOI4_I4_helper(unsigned int val) {	
    if (val > 0x7FFFFFFF) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int32) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_UN_TOI4_I8
#define emit_CONV_OVF_UN_TOI4_I8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_UN_TOI4_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_OVF_UN_TOI4_I8_helper(unsigned __int64 val) {
    if (val > 0x7FFFFFFF) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (__int32) val;
}
#endif
#endif

#define emit_CONV_OVF_UN_TOI4_R4() emit_CONV_OVF_TOI4_R4() 

#define emit_CONV_OVF_UN_TOI4_R8() emit_CONV_OVF_TOI4_R8() 
#define emit_CONV_OVF_UN_TOI4_R() emit_CONV_OVF_TOI4_R() 

#define emit_CONV_OVF_UN_TOI8_I4() emit_CONV_TOU8_I4() 

#ifndef emit_CONV_OVF_UN_TOI8_I8
#define emit_CONV_OVF_UN_TOI8_I8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I8(CONV_OVF_UN_TOI8_I8_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_OVF_UN_TOI8_I8_helper(signed __int64 val) {	 /* note SIGNED value */
    if (val < 0) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return val;
}
#endif
#endif

#define emit_CONV_OVF_UN_TOI8_R4() emit_CONV_OVF_TOI8_R4() 

#define emit_CONV_OVF_UN_TOI8_R8() emit_CONV_OVF_TOI8_R8() 
#define emit_CONV_OVF_UN_TOI8_R() emit_CONV_OVF_TOI8_R() 

#ifndef emit_CONV_OVF_UN_TOU1_I4
#define emit_CONV_OVF_UN_TOU1_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I4_I4(CONV_OVF_UN_TOU1_U4_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_UN_TOU1_U4_helper(unsigned int val) {
    if (val > 0xff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (unsigned __int8) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_UN_TOU1_I8
#define emit_CONV_OVF_UN_TOU1_I8()                 \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_UN_TOU1_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_UN_TOU1_I8_helper(unsigned __int64 val) {
    if (val > 0xff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (unsigned __int8) val;
}
#endif
#endif

#define emit_CONV_OVF_UN_TOU1_R4() emit_CONV_OVF_TOU1_R4() 

#define emit_CONV_OVF_UN_TOU1_R8() emit_CONV_OVF_TOU1_R8() 
#define emit_CONV_OVF_UN_TOU1_R() emit_CONV_OVF_TOU1_R() 

#ifndef emit_CONV_OVF_UN_TOU2_I4
#define emit_CONV_OVF_UN_TOU2_I4()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I4_I4(CONV_OVF_UN_TOU2_I4_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_UN_TOU2_I4_helper(unsigned int val) {
    if (val > 0xffff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (unsigned __int16) val;
}
#endif
#endif

#ifndef emit_CONV_OVF_UN_TOU2_I8
#define emit_CONV_OVF_UN_TOU2_I8()                 \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_UN_TOU2_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_UN_TOU2_I8_helper(unsigned __int64 val) {
    if (val > 0xffff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (unsigned __int16) val;
}
#endif
#endif

#define emit_CONV_OVF_UN_TOU2_R4() emit_CONV_OVF_TOU2_R4() 

#define emit_CONV_OVF_UN_TOU2_R8() emit_CONV_OVF_TOU2_R8() 
#define emit_CONV_OVF_UN_TOU2_R() emit_CONV_OVF_TOU2_R() 

#define emit_CONV_OVF_UN_TOU4_I4() /* do nothing */

#ifndef emit_CONV_OVF_UN_TOU4_I8
#define emit_CONV_OVF_UN_TOU4_I8()         \
	LABELSTACK((outPtr-outBuff), 1);	\
    emit_callhelper_I8_I4(CONV_OVF_UN_TOU4_U8_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_OVF_UN_TOU4_U8_helper(unsigned __int64 val) {
    if (val > 0xffffffff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (unsigned __int32) val;
}
#endif
#endif

#define emit_CONV_OVF_UN_TOU4_R4() emit_CONV_OVF_TOU4_R4() 

#define emit_CONV_OVF_UN_TOU4_R8() emit_CONV_OVF_TOU4_R8() 
#define emit_CONV_OVF_UN_TOU4_R() emit_CONV_OVF_TOU4_R() 

#define emit_CONV_OVF_UN_TOU8_I4() emit_CONV_TOU8_I4() 

#define emit_CONV_OVF_UN_TOU8_I8()	/* do nothing */

#define emit_CONV_OVF_UN_TOU8_R4() emit_CONV_OVF_TOU8_R4() 

#define emit_CONV_OVF_UN_TOU8_R8() emit_CONV_OVF_TOU8_R8() 

#define emit_CONV_OVF_UN_TOU8_R() emit_CONV_OVF_TOU8_R() 

/******************************************************************/
/* convert (no overflow) */

#ifndef emit_CONV_TOI1_I4
#define emit_CONV_TOI1_I4()                 \
    emit_callhelper_I4_I4(CONV_TOI1_I4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI1_I4_helper(int val) {
    return (int) ((char) val);
}
#endif
#endif

#ifndef emit_CONV_TOI1_I8
#define emit_CONV_TOI1_I8()                 \
    emit_callhelper_I8_I4(CONV_TOI1_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI1_I8_helper(__int64 val) {
    return (int) ((char) val);
}
#endif
#endif

#ifndef emit_CONV_TOI1_R4
#define emit_CONV_TOI1_R4()                 \
    emit_callhelper_R4_I4(CONV_TOI1_R4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI1_R4_helper(float val) {
    int x = (int) val;
    return (int) ((char) x);
}
#endif
#endif

#ifndef emit_CONV_TOI1_R8
#define emit_CONV_TOI1_R8()                 \
    emit_callhelper_R8_I4(CONV_TOI1_R8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI1_R8_helper(double val) {
    int x = (int) val;
    return (int) ((char) x);
}
#endif
#endif

#ifndef emit_CONV_TOI2_I4
#define emit_CONV_TOI2_I4()                 \
    emit_callhelper_I4_I4(CONV_TOI2_I4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI2_I4_helper(int val) {
    return (int) ((short) val);
}
#endif
#endif

#ifndef emit_CONV_TOI2_I8
#define emit_CONV_TOI2_I8()                 \
    emit_callhelper_I8_I4(CONV_TOI2_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI2_I8_helper(__int64 val) {
    return (int) ((short) val);
}
#endif
#endif

#ifndef emit_CONV_TOI2_R4
#define emit_CONV_TOI2_R4()                 \
    emit_callhelper_R4_I4(CONV_TOI2_R4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI2_R4_helper(float val) {
    int x = (int) val;
    return (int) ((short) x);
}
#endif
#endif

#ifndef emit_CONV_TOI2_R8
#define emit_CONV_TOI2_R8()                 \
    emit_callhelper_R8_I4(CONV_TOI2_R8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI2_R8_helper(double val) {
    int x = (int) val;
    return (int) ((short) x);
}
#endif
#endif


#define emit_CONV_TOI4_I4()     /* do nothing */

#ifndef emit_CONV_TOI4_I8
#define emit_CONV_TOI4_I8()                 \
    emit_callhelper_I8_I4(CONV_TOI4_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI4_I8_helper(__int64 val) {
    return (__int32) val;
}
#endif
#endif

#ifndef emit_CONV_TOI4_R4
#define emit_CONV_TOI4_R4()                 \
    emit_callhelper_R4_I4(CONV_TOI4_R4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI4_R4_helper(float val) {
    return (__int32) val;
}
#endif
#endif

#ifndef emit_CONV_TOI4_R8
#define emit_CONV_TOI4_R8()                 \
    emit_callhelper_R8_I4(CONV_TOI4_R8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL CONV_TOI4_R8_helper(double val) {
    return (__int32) val;
}
#endif
#endif

#ifndef emit_CONV_TOI8_I4
#define emit_CONV_TOI8_I4()                 \
    emit_callhelper_I4_I8(CONV_TOI8_I4_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_TOI8_I4_helper(int val) {
    return val;
}
#endif
#endif

#define emit_CONV_TOI8_I8()     /* do nothing */

#ifndef emit_CONV_TOI8_R4
#define emit_CONV_TOI8_R4()                 \
    emit_callhelper_R4_I8(CONV_TOI8_R4_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_TOI8_R4_helper(float val) {
    return (__int64) val;
}
#endif
#endif

#ifndef emit_CONV_TOI8_R8
#define emit_CONV_TOI8_R8()                 \
    emit_callhelper_R8_I8(CONV_TOI8_R8_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_TOI8_R8_helper(double val) {
    return (__int64) val;
}
#endif
#endif

/* this routine insures that a float is truncated to float
   precision.  We do this by forcing the memory spill  */ 
float truncateToFloat(float f);

#ifndef emit_CONV_TOR4_I4
#define emit_CONV_TOR4_I4()                 \
    emit_callhelper_I4_I4(CONV_TOR4_I4_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_TOR4_I4_helper(int val) {
    double result = (double) truncateToFloat((float) val);
    return *(__int64*)&result;
}
#endif
#endif

#ifndef emit_CONV_TOR4_I8
#define emit_CONV_TOR4_I8()                 \
    emit_callhelper_I8_I4(CONV_TOR4_I8_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_TOR4_I8_helper(__int64 val) {
    double result = (double) truncateToFloat((float) val);
    return *(__int64*)&result;
}
#endif
#endif

//#define emit_CONV_TOR4_R4()     /* do nothing */

#define emit_CONV_TOR4_R8() {\
	emit_conv_R8toR4(); \
	emit_conv_R4toR8(); \
}


#ifndef emit_CONV_TOR4_R8
#define emit_CONV_TOR4_R8()                 \
    emit_callhelper_R8_I4(CONV_TOR4_R8_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_TOR4_R8_helper(double val) {
    double result = (double) truncateToFloat((float) val);
    return *(__int64*)&result;
}
#endif
#endif


#ifndef emit_CONV_TOR8_I4
#define emit_CONV_TOR8_I4()                 \
    emit_callhelper_I4_I8(CONV_TOR8_I4_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_TOR8_I4_helper(int val) {
    double result = (double) val;
    return *(__int64*)&result;
}
#endif
#endif

#ifndef emit_CONV_TOR8_I8
#define emit_CONV_TOR8_I8()                 \
    emit_callhelper_I8_I8(CONV_TOR8_I8_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_TOR8_I8_helper(__int64 val) {
    double result = (double) val;
    return *(__int64*)&result;
}
#endif
#endif

#ifndef emit_CONV_TOR8_R4
#define emit_CONV_TOR8_R4()                 \
    emit_callhelper_R4_I8(CONV_TOR8_R4_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_TOR8_R4_helper(float val) {
    double result = val;
    return *(__int64*)&result;
}
#endif
#endif

#define emit_CONV_TOR8_R8()     /* do nothing */

#ifndef emit_CONV_UN_TOR_I4
#define emit_CONV_UN_TOR_I4()                 \
    emit_callhelper_I4_I8(CONV_UN_TOR_I4_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_UN_TOR_I4_helper(unsigned int val) {
    double result = (double) val;
    return *(__int64*)&result;
}
#endif
#endif

#ifndef emit_CONV_UN_TOR_I8
#define emit_CONV_UN_TOR_I8()                 \
    emit_callhelper_I8_I8(CONV_UN_TOR_I8_helper);  \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL CONV_UN_TOR_I8_helper(unsigned __int64 val) {
    double result = (double) ((__int64) val);
	if (result < 0)
		result += (4294967296.0 * 4294967296.0);	// add 2^64
	_ASSERTE(result >= 0);
    return *(__int64*)&result;
}
#endif
#endif


#define emit_CONV_UN_TOR_R4()     /* do nothing */
#define emit_CONV_UN_TOR_R8()     /* do nothing */


#ifndef emit_CONV_TOU1_I4
#define emit_CONV_TOU1_I4()                 \
    emit_callhelper_I4_I4(CONV_TOU1_I4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_TOU1_I4_helper(int val) {
    return (int) (val & 0xff);
}
#endif
#endif

#ifndef emit_CONV_TOU1_I8
#define emit_CONV_TOU1_I8()                 \
    emit_callhelper_I8_I4(CONV_TOU1_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned  HELPER_CALL CONV_TOU1_I8_helper(__int64 val) {
    return (unsigned) (val & 0xff);
}
#endif
#endif

#ifndef emit_CONV_TOU1_R4
#define emit_CONV_TOU1_R4()                 \
    emit_callhelper_R4_I4(CONV_TOU1_R4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_TOU1_R4_helper(float val) {
    return (unsigned int) ((unsigned char) val);
}
#endif
#endif

#ifndef emit_CONV_TOU1_R8
#define emit_CONV_TOU1_R8()                 \
    emit_callhelper_R8_I4(CONV_TOU1_R8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_TOU1_R8_helper(double val) {
    return (unsigned int) ((unsigned char) val);
}
#endif
#endif


#ifndef emit_CONV_TOU2_I4
#define emit_CONV_TOU2_I4()                 \
    emit_callhelper_I4_I4(CONV_TOU2_I4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_TOU2_I4_helper(int val) {
    return (unsigned int) (val & 0xffff);
}
#endif
#endif

#ifndef emit_CONV_TOU2_I8
#define emit_CONV_TOU2_I8()                 \
    emit_callhelper_I8_I4(CONV_TOU2_I8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_TOU2_I8_helper(__int64 val) {
    return (unsigned int) (val & 0xffff);
}
#endif
#endif

#ifndef emit_CONV_TOU2_R4
#define emit_CONV_TOU2_R4()                 \
    emit_callhelper_R4_I4(CONV_TOU2_R4_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_TOU2_R4_helper(float val) {
    return (unsigned int) ((unsigned short) val);
}
#endif
#endif

#ifndef emit_CONV_TOU2_R8
#define emit_CONV_TOU2_R8()                 \
    emit_callhelper_R8_I4(CONV_TOU2_R8_helper);  \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL CONV_TOU2_R8_helper(double val) {
    return (unsigned int) (unsigned short) val;
}
#endif
#endif

#define emit_CONV_TOU4_I4()     /* do nothing */

#define emit_CONV_TOU4_I8()     emit_CONV_TOI4_I8()

#define emit_CONV_TOU4_R4()     emit_CONV_TOI4_R4()

#define emit_CONV_TOU4_R8()     emit_CONV_TOI4_R8()
#define emit_CONV_TOU4_R()     emit_CONV_TOI4_R()

#ifndef emit_CONV_TOU8_I4
#define emit_CONV_TOU8_I4()                 \
    emit_callhelper_I4_I8(CONV_TOU8_U4_helper);  \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL CONV_TOU8_U4_helper(unsigned int val) {
    return val;
}
#endif
#endif

#define emit_CONV_TOU8_I8()     /* do nothing */

#define emit_CONV_TOU8_R4()     emit_CONV_TOI8_R4()

#define emit_CONV_TOU8_R8()     emit_CONV_TOI8_R8()
#define emit_CONV_TOU8_R()     emit_CONV_TOI8_R()

#ifndef emit_OR_U4
#define emit_OR_U4()                        \
    emit_callhelper_I4I4_I4(OR_U4_helper);  \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL OR_U4_helper(unsigned int i, unsigned int j) {
    return j | i;
}
#endif
#endif

#ifndef emit_OR_U8
#define emit_OR_U8()                        \
    emit_callhelper_I8I8_I8(OR_U8_helper);  \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL OR_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    return j | i;
}
#endif
#endif

#ifndef emit_AND_U4
#define emit_AND_U4()                       \
    emit_callhelper_I4I4_I4(AND_U4_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL AND_U4_helper(unsigned int i, unsigned int j) {
    return j & i;
}
#endif
#endif

#ifndef emit_AND_U8
#define emit_AND_U8()                       \
    emit_callhelper_I8I8_I8(AND_U8_helper); \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL AND_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    return j & i;
}
#endif
#endif

#ifndef emit_XOR_U4
#define emit_XOR_U4()                       \
    emit_callhelper_I4I4_I4(XOR_U4_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL XOR_U4_helper(unsigned int i, unsigned int j) {
    return j ^ i;
}
#endif
#endif

#ifndef emit_XOR_U8
#define emit_XOR_U8()                       \
    emit_callhelper_I8I8_I8(XOR_U8_helper); \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL XOR_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    return j ^ i;
}
#endif
#endif

#ifndef emit_NOT_U4
#define emit_NOT_U4()                       \
    emit_callhelper_I4_I4(NOT_U4_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
int HELPER_CALL NOT_U4_helper(int val) {
    return ~val;
}
#endif
#endif

#ifndef emit_NOT_U8
#define emit_NOT_U8()                       \
    emit_callhelper_I8_I8(NOT_U8_helper); \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL NOT_U8_helper(__int64 val) {
    return ~val;
}
#endif
#endif

#ifndef emit_NEG_I4
#define emit_NEG_I4()                       \
    emit_callhelper_I4_I4(Neg_I4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL Neg_I4_helper(int val) {
    return -val;
}
#endif
#endif

#ifndef emit_NEG_I8
#define emit_NEG_I8()                       \
    emit_callhelper_I8_I8(Neg_I8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL Neg_I8_helper(__int64 val) {
    return -val;
}
#endif
#endif

#ifndef emit_NEG_R4
#define emit_NEG_R4()                       \
    emit_callhelper_R4_I4(Neg_R4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL Neg_R4_helper(float val) {
    float result = -val;
    return *(int*)&result;
}
#endif
#endif

#ifndef emit_NEG_R8
#define emit_NEG_R8()                       \
    emit_callhelper_R8_I8(Neg_R8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL Neg_R8_helper(double val) {
    double result = -val;
    return *(__int64*)&result;
}
#endif
#endif

#ifndef emit_SHR_S_U4
#define emit_SHR_S_U4()                       \
    emit_callhelper_I4I4_I4(SHR_I4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL SHR_I4_helper(unsigned int cnt, int val) {
    return val>>cnt;
}
#endif
#endif

#ifndef emit_SHR_U4
#define emit_SHR_U4()                       \
    emit_callhelper_I4I4_I4(SHR_U4_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL SHR_U4_helper(unsigned int cnt, unsigned int val) {
    return val>>cnt;
}
#endif
#endif

#ifndef emit_SHL_U4
#define emit_SHL_U4()                       \
    emit_callhelper_I4I4_I4(SHL_U4_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL SHL_U4_helper(unsigned int cnt, unsigned int val) {
    return val<<cnt;
}
#endif
#endif

#ifndef emit_SHR_S_U8
#define emit_SHR_S_U8()                       \
    emit_callhelper_I4I8_I8(SHR_I8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL SHR_I8_helper(unsigned int cnt, __int64 val) {
    return val>>cnt;
}
#endif
#endif

#ifndef emit_SHR_U8
#define emit_SHR_U8()                       \
    emit_callhelper_I4I8_I8(SHR_U8_helper); \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL SHR_U8_helper(unsigned int cnt, unsigned __int64 val) {
    return val>>cnt;
}
#endif
#endif

#ifndef emit_SHL_U8
#define emit_SHL_U8()                       \
    emit_callhelper_I4I8_I8(SHL_U8_helper); \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL SHL_U8_helper(unsigned int cnt, unsigned __int64 val) {
    return val<<cnt;
}
#endif
#endif

#ifndef emit_SHR_I4_IMM1
#define emit_SHR_I4_IMM1(cnt)           \
    emit_pushconstant_4(cnt);           \
    emit_callhelper_I4I4_I4(SHR_I4_IMM1_helper);    \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL SHR_I4_IMM1_helper(unsigned int cnt, int val) {
    return val>>cnt;
}
#endif
#endif

#ifndef emit_SHR_U4_IMM1
#define emit_SHR_U4_IMM1(cnt)           \
    emit_pushconstant_4(cnt);           \
    emit_callhelper_I4I4_I4(SHR_U4_IMM1_helper);    \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL SHR_U4_IMM1_helper(unsigned int cnt, unsigned int val) {
    return val>>cnt;
}
#endif
#endif

#ifndef emit_SHL_U4_IMM1
#define emit_SHL_U4_IMM1(cnt)           \
    emit_pushconstant_4(cnt);           \
    emit_callhelper_I4I4_I4(SHL_U4_IMM1_helper);    \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL SHL_U4_IMM1_helper(unsigned int cnt, unsigned int val) {
    return val<<cnt;
}
#endif
#endif

#ifndef emit_ADD_OVF_I1
#define emit_ADD_OVF_I1()                   \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(ADD_OVF_I1_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL ADD_OVF_I1_helper(int i, int j) {
    int i4 = j + i;
    if ((int)((signed char) i4) != i4) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return i4;
}
#endif
#endif

#ifndef emit_ADD_OVF_I2
#define emit_ADD_OVF_I2()                   \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(ADD_OVF_I2_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL ADD_OVF_I2_helper(int i, int j) {
    int i4 = j + i;
    if ((int)((signed short) i4) != i4) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return i4;
}
#endif
#endif

#ifndef emit_ADD_OVF_I4
#define emit_ADD_OVF_I4()                   \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(ADD_OVF_I4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL ADD_OVF_I4_helper(int i, int j) {
    int i4 = j + i;
    // if the signs of i and j are different, then we can never overflow
    // if the signs of i and j are the same, then the result must have the same sign
    if ((j ^ i) >= 0) {
        // i and j have the same sign (the sign bit of j^i is not set)
        // ensure that the result has the same sign
        if ((i4 ^ j) < 0) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
        }
    }
    return i4;
}
#endif
#endif

#ifndef emit_ADD_OVF_I8
#define emit_ADD_OVF_I8()                   \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_R8I8_I8(ADD_OVF_I8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL ADD_OVF_I8_helper(__int64 i, __int64 j) {
    __int64 i8 = j + i;
    // if the signs of i and j are different, then we can never overflow
    // if the signs of i and j are the same, then the result must have the same sign
    if ((j>=0) == (i>=0)) {
        // ensure that the result has the same sign
        if ((i8>=0) != (j>=0)) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
        }
    }
    return i8;
}
#endif
#endif

#ifndef emit_ADD_OVF_U1
#define emit_ADD_OVF_U1()                   \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(ADD_OVF_U1_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL ADD_OVF_U1_helper(unsigned int i, unsigned int j) {
    unsigned int u4 = j + i;
    if (u4 > 0xff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return u4;
}
#endif
#endif

#ifndef emit_ADD_OVF_U2
#define emit_ADD_OVF_U2()                   \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(ADD_OVF_U2_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL ADD_OVF_U2_helper(unsigned int i, unsigned int j) {
    unsigned int u4 = j + i;
    if (u4 > 0xffff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return u4;
}
#endif
#endif

#ifndef emit_ADD_OVF_U4
#define emit_ADD_OVF_U4()                   \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(ADD_OVF_U4_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL ADD_OVF_U4_helper(unsigned int i, unsigned int j) {
    unsigned int u4 = j + i;
    if (u4 < j) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return u4;
}
#endif
#endif

#ifndef emit_ADD_OVF_U8
#define emit_ADD_OVF_U8()                   \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I8I8_I8(ADD_OVF_U8_helper); \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL ADD_OVF_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    unsigned __int64 u8 = j + i;
    if (u8 < j) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return u8;
}
#endif
#endif

#ifndef emit_LDELEMA
#define emit_LDELEMA(elemSize, clshnd)              \
    deregisterTOS;                          \
    emit_pushconstant_4(elemSize);          \
    emit_pushconstant_4(clshnd);          \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4I4_I4(LDELEMA_helper);        \
    emit_pushresult_Ptr()
#ifdef DECLARE_HELPERS
void* HELPER_CALL LDELEMA_helper(void* clshnd, unsigned int elemSize, unsigned int index, CORINFO_Array* or) {
    void* ptr;
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
	if (clshnd != 0) {
		CORINFO_CLASS_HANDLE elemType = *((CORINFO_CLASS_HANDLE*) &or->i1Elems);	
		if (elemType != clshnd)
			THROW_FROM_HELPER_RET(CORINFO_ArrayTypeMismatchException);
		ptr = &or->i1Elems[index*elemSize + sizeof(CORINFO_CLASS_HANDLE)];
	}
	else 
		ptr = &or->i1Elems[index*elemSize];
    return ptr;
}
#endif
#endif

#ifndef emit_LDELEM_I1
#define emit_LDELEM_I1()                        \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(LDELEM_I1_helper);      \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL LDELEM_I1_helper(unsigned int index, CORINFO_Array* or) {
    int i4;
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
    i4 = or->i1Elems[index];
    return i4;
}
#endif
#endif

#ifndef emit_LDELEM_I2
#define emit_LDELEM_I2()                        \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(LDELEM_I2_helper);      \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL LDELEM_I2_helper(unsigned int index, CORINFO_Array* or) {
    int i4;
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
    i4 = or->i2Elems[index];
    return i4;
}
#endif
#endif

#ifndef emit_LDELEM_I4
#define emit_LDELEM_I4()                        \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(LDELEM_I4_helper);      \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL LDELEM_I4_helper(unsigned int index, CORINFO_Array* or) {
    int i4;
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
    i4 = or->i4Elems[index];
    return i4;
}
#endif
#endif

#ifndef emit_LDELEM_U4
#define emit_LDELEM_U4()                        \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(LDELEM_U4_helper);      \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned HELPER_CALL LDELEM_U4_helper(unsigned int index, CORINFO_Array* or) {
    int u4;
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
    u4 = or->u4Elems[index];
    return u4;
}
#endif
#endif

#ifndef emit_LDELEM_I8
#define emit_LDELEM_I8()                        \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I8(LDELEM_I8_helper);      \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
signed __int64 HELPER_CALL LDELEM_I8_helper(unsigned int index, CORINFO_Array* or) {
    signed __int64 i8;
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
    i8 = or->i8Elems[index];
    return i8;
}
#endif
#endif

#ifndef emit_LDELEM_U1
#define emit_LDELEM_U1()                        \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(LDELEM_U1_helper);      \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL LDELEM_U1_helper(unsigned int index, CORINFO_Array* or) {
    unsigned int u4;
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
    u4 = or->u1Elems[index];
    return u4;
}
#endif
#endif

#ifndef emit_LDELEM_U2
#define emit_LDELEM_U2()                        \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(LDELEM_U2_helper);      \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL LDELEM_U2_helper(unsigned int index, CORINFO_Array* or) {
    unsigned int u4;
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
    u4 = or->u2Elems[index];
    return u4;
}
#endif
#endif


#ifndef emit_LDELEM_R4
#define emit_LDELEM_R4()                        \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(LDELEM_R4_helper);      \
    emit_pushresult_I8(); 
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL LDELEM_R4_helper(unsigned int index, CORINFO_Array* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
    double r8;
    r8 = (double) or->r4Elems[index];
    return *(__int64*)&r8;
}
#endif
#endif

#ifndef emit_LDELEM_R8
#define emit_LDELEM_R8()                        \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I8(LDELEM_R8_helper);      \
    emit_pushresult_I8(); \
    emit_conv_R8toR()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL LDELEM_R8_helper(unsigned int index, CORINFO_Array* or) {
    double r8;
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
    r8 = or->r8Elems[index];
    return *(__int64*)&r8;
}
#endif
#endif

#ifndef emit_LDELEM_REF
#define emit_LDELEM_REF()                       \
  	LABELSTACK((outPtr-outBuff),2);				\
    emit_callhelper_I4I4_I4(LDELEM_REF_helper);     \
    emit_pushresult_Ptr()
#ifdef DECLARE_HELPERS
unsigned HELPER_CALL LDELEM_REF_helper(unsigned int index, CORINFO_RefArray* or) {
    CORINFO_Object* result;
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER_RET(CORINFO_IndexOutOfRangeException);
    }
    result = or->refElems[index];
    return (unsigned) result;
}
#endif
#endif

#ifndef emit_LDFLD_I1
#define emit_LDFLD_I1(isStatic)                 \
    if (!isStatic) { \
       LABELSTACK((outPtr-outBuff),0); \
	   emit_callhelper_I4I4_I4(LDFLD_I1_helper);\
	}  \
    else {load_indirect_byte_signextend(SCRATCH_1,SCRATCH_1); }     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL LDFLD_I1_helper(unsigned int offset, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return *((signed char*) ((char*)(or)+offset));
}
#endif
#endif

#ifndef emit_LDFLD_I2
#define emit_LDFLD_I2(isStatic)             \
    if (!isStatic) { \
       LABELSTACK((outPtr-outBuff),0); \
	   emit_callhelper_I4I4_I4(LDFLD_I2_helper);\
	}  \
    else {load_indirect_word_signextend(SCRATCH_1,SCRATCH_1);}     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL LDFLD_I2_helper(unsigned int offset, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return *((signed short*) ((char*)(or)+offset));
}
#endif
#endif

#ifndef emit_LDFLD_I4
#define emit_LDFLD_I4(isStatic)             \
    if (!isStatic) { \
       LABELSTACK((outPtr-outBuff),0); \
	   emit_callhelper_I4I4_I4(LDFLD_I4_helper);\
	}  \
    else {mov_register_indirect_to(SCRATCH_1,SCRATCH_1);}     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL LDFLD_I4_helper(unsigned int offset, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return *((int*) ((char*)(or)+offset));
}
#endif
#endif

#ifndef emit_LDFLD_R4
#define emit_LDFLD_R4(isStatic)             \
    if (!isStatic) { \
       LABELSTACK((outPtr-outBuff),0); \
	   emit_callhelper_I4I4_I4(LDFLD_R4_helper);\
	   emit_pushresult_I8();\
	}  \
    else {emit_LDIND_R4();}     
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL LDFLD_R4_helper(unsigned int offset, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
	double f = (double) (*((float*) ((char*)(or)+offset))); 
    return *(__int64*) (&f);
}
#endif
#endif

#ifndef emit_LDFLD_U1
#define emit_LDFLD_U1(isStatic)             \
    if (!isStatic) { \
       LABELSTACK((outPtr-outBuff),0); \
	   emit_callhelper_I4I4_I4(LDFLD_U1_helper); \
	   emit_pushresult_I4();\
	}  \
    else {load_indirect_byte_zeroextend(SCRATCH_1,SCRATCH_1);} 
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL LDFLD_U1_helper(unsigned int offset, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return *((unsigned char*) ((char*)(or)+offset));
}
#endif
#endif

#ifndef emit_LDFLD_U2
#define emit_LDFLD_U2(isStatic)             \
    if (!isStatic) { \
       LABELSTACK((outPtr-outBuff),0); \
	   emit_callhelper_I4I4_I4(LDFLD_U2_helper);\
	}  \
    else {load_indirect_word_zeroextend(SCRATCH_1,SCRATCH_1);}     \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL LDFLD_U2_helper(unsigned int offset, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return *((unsigned short*) ((char*)(or)+offset));
}
#endif
#endif
#ifndef emit_LDFLD_U4
#define emit_LDFLD_U4(isStatic)             \
    if (!isStatic) { \
       LABELSTACK((outPtr-outBuff),0); \
	   emit_callhelper_I4I4_I4(LDFLD_U4_helper);\
	}  \
    else {mov_register_indirect_to(SCRATCH_1,SCRATCH_1);}     \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
int HELPER_CALL LDFLD_U4_helper(unsigned int offset, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return *((int*) ((char*)(or)+offset));
}
#endif
#endif


#ifndef emit_LDFLD_I8
#define emit_LDFLD_I8(isStatic)             \
    if (!isStatic) { \
       LABELSTACK((outPtr-outBuff),0); \
	   emit_callhelper_I4I4_I8(LDFLD_I8_helper);\
	   emit_pushresult_I8();\
	}  \
    else {emit_LDIND_I8();}     \
    
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL LDFLD_I8_helper(unsigned int offset, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return *((__int64*) ((char*)(or)+offset));
}
#endif
#endif

#ifndef emit_LDFLD_R8
#define emit_LDFLD_R8(isStatic)             \
    if (!isStatic) { \
       LABELSTACK((outPtr-outBuff),0); \
	   emit_callhelper_I4I4_I8(LDFLD_R8_helper);\
	   emit_pushresult_I8() ;}  \
    else {emit_LDIND_R8();}     \
    emit_conv_R8toR();

#ifdef DECLARE_HELPERS
__int64 HELPER_CALL LDFLD_R8_helper(unsigned int offset, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return *((__int64*) ((char*)(or)+offset));
}
#endif
#endif

#ifndef emit_LDFLD_REF
#define emit_LDFLD_REF(isStatic)                \
    if (!isStatic) { \
       LABELSTACK((outPtr-outBuff),0); \
	   emit_callhelper_I4I4_I4(LDFLD_REF_helper);} \
    else {mov_register_indirect_to(SCRATCH_1,SCRATCH_1);}        \
    emit_pushresult_Ptr()
#ifdef DECLARE_HELPERS
unsigned HELPER_CALL LDFLD_REF_helper(unsigned int offset, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return *((unsigned*) ((char*)(or)+offset));
}
#endif
#endif

#ifndef emit_LDFLD_helper
#define emit_LDFLD_helper(helper,fieldDesc) \
	if (inRegTOS) {\
	   mov_register(ARG_1, SCRATCH_1); \
	   inRegTOS = false;}\
	else {\
	   pop(ARG_1); }\
	emit_helperarg_2(fieldDesc); \
    mov_constant(SCRATCH_1,helper); \
	call_register(SCRATCH_1);
#endif

#ifndef emit_STFLD_NonStatic_field_helper
#define emit_STFLD_NonStatic_field_helper(fieldDesc,sizeInBytes,helper) \
	emit_getSP(sizeInBytes);                 \
    emit_LDIND_PTR();                        \
    emit_mov_TOS_arg(0);		    	     \
	emit_helperarg_2(fieldDesc)			  	 \
    mov_constant(SCRATCH_1,helper);          \
	call_register(SCRATCH_1);                \
    emit_POP_PTR(); 
#endif

#ifndef emit_STFLD_Static_field_helper
#define emit_STFLD_Static_field_helper(fieldDesc,sizeInBytes,helper) \
	emit_helperarg_1(fieldDesc);      \
    if (sizeInBytes == sizeof(void*)) \
    {                                \
		if (inRegTOS) {\
		   mov_register(ARG_2, SCRATCH_1); \
		   inRegTOS = false;}\
		else {\
		   pop(ARG_2); }\
    } \
	else /*cannot enregister args*/ \
    { \
        _ASSERTE(inRegTOS == FALSE); \
    }\
    mov_constant(SCRATCH_1,helper);          \
	call_register(SCRATCH_1);                
#endif

/*       
#ifndef emit_STFLD_Special32
#define emit_STFLD_Special32(fieldDesc)      \
    emit_getSP(sizeof(void*));               \
    emit_LDIND_PTR();                        \
    emit_mov_TOS_arg(0);		    	     \
	emit_helperarg_2(fieldDesc)			  	 \
    emit_callhelper_il(FJit_pHlpSetField32);    \
    emit_POP_PTR();
#endif

#ifndef emit_STFLD_Special64
#define emit_STFLD_Special64(fieldDesc)      \
    emit_getSP(8);                           \
    emit_LDIND_PTR();                        \
    emit_mov_TOS_arg(0);		    	     \
	emit_helperarg_2(fieldDesc)			  	 \
    emit_callhelper_il(FJit_pHlpSetField64);    \
    emit_POP_PTR();
#endif

#ifndef emit_STFLD_Special32Obj
#define emit_STFLD_Special32Obj(fieldDesc)      \
    emit_getSP(sizeof(void*));               \
    emit_LDIND_PTR();                        \
    emit_mov_TOS_arg(0);		    	     \
	emit_helperarg_2(fieldDesc);		  	 \
    emit_callhelper_il(FJit_pHlpSetField32Obj);    \
    emit_POP_PTR();
#endif
*/
#ifndef emit_STELEM_I1
#define emit_STELEM_I1()                        \
	LABELSTACK((outPtr-outBuff),3); \
    emit_callhelper_I4I4I4(STELEM_I1_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL STELEM_I1_helper(signed char i1, unsigned int index, CORINFO_Array* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER(CORINFO_IndexOutOfRangeException);
    }
    or->i1Elems[index] = i1;
}
#endif
#endif

#ifndef emit_STELEM_I2
#define emit_STELEM_I2()                        \
	LABELSTACK((outPtr-outBuff),3); \
    emit_callhelper_I4I4I4(STELEM_I2_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL STELEM_I2_helper(signed short i2, unsigned int index, CORINFO_Array* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER(CORINFO_IndexOutOfRangeException);
    }
    or->i2Elems[index] = i2;
}
#endif
#endif

#ifndef emit_STELEM_I4
#define emit_STELEM_I4()                        \
	LABELSTACK((outPtr-outBuff),3); \
    emit_callhelper_I4I4I4(STELEM_I4_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL STELEM_I4_helper(signed int i4, unsigned int index, CORINFO_Array* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER(CORINFO_IndexOutOfRangeException);
    }
    or->i4Elems[index] = i4;
}
#endif
#endif

#ifndef emit_STELEM_I8
#define emit_STELEM_I8()                        \
	LABELSTACK((outPtr-outBuff),3); \
    emit_callhelper_I8I4I4(STELEM_I8_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL STELEM_I8_helper(signed __int64 i8, unsigned int index, CORINFO_Array* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER(CORINFO_IndexOutOfRangeException);
    }
    or->i8Elems[index] = i8;
}
#endif
#endif

#ifndef emit_STELEM_U1
#define emit_STELEM_U1()                        \
	LABELSTACK((outPtr-outBuff),3); \
    emit_callhelper_I4I4I4(STELEM_U1_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL STELEM_U1_helper(unsigned char u1, unsigned int index, CORINFO_Array* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER(CORINFO_IndexOutOfRangeException);
    }
    or->u1Elems[index] = u1;
}
#endif
#endif

#ifndef emit_STELEM_U2
#define emit_STELEM_U2()                        \
	LABELSTACK((outPtr-outBuff),3); \
    emit_callhelper_I4I4I4(STELEM_U2_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL STELEM_U2_helper(unsigned short u2, unsigned int index, CORINFO_Array* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER(CORINFO_IndexOutOfRangeException);
    }
    or->u2Elems[index] = u2;
}
#endif
#endif

#ifndef emit_STELEM_REF
#define emit_STELEM_REF()                   \
    enregisterTOS;  /* array */     \
    pop(ARG_2);   /* index */     \
    pop(ARG_1);   /* ref   */     \
    deregisterTOS;                  \
	LABELSTACK((outPtr-outBuff), 3);   \
    emit_callhelper_il(FJit_pHlpArrAddr_St)

#endif

#ifndef emit_STELEM_R4
#define emit_STELEM_R4()                        \
    emit_conv_RtoR4(); \
	LABELSTACK((outPtr-outBuff),3); \
    emit_callhelper_R4I4I4(STELEM_R4_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL STELEM_R4_helper(float r4, unsigned int index, CORINFO_Array* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER(CORINFO_IndexOutOfRangeException);
    }
    or->r4Elems[index] = r4;
}
#endif
#endif

#ifndef emit_STELEM_R8
#define emit_STELEM_R8()                        \
	LABELSTACK((outPtr-outBuff),3); \
    emit_conv_RtoR8(); \
    emit_callhelper_R8I4I4(STELEM_R8_helper)
#ifdef DECLARE_HELPERS
void HELPER_CALL STELEM_R8_helper(double r8, unsigned int index, CORINFO_Array* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    if (index >= or->length) {
        THROW_FROM_HELPER(CORINFO_IndexOutOfRangeException);
    }
    or->r8Elems[index] = r8;
}
#endif
#endif

#ifndef emit_STFLD_I1
#define emit_STFLD_I1(isStatic)             \
    if (!isStatic) {\
		LABELSTACK((outPtr-outBuff),0); \
		emit_callhelper_I4I4I4(STFLD_I1_helper);}  \
    else {emit_STIND_REV_I1();}
#ifdef DECLARE_HELPERS
void HELPER_CALL STFLD_I1_helper(unsigned int offset, signed char val, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    *((signed char*) ((char*)(or)+offset)) = val;
}
#endif
#endif

#ifndef emit_STFLD_I2
#define emit_STFLD_I2(isStatic)             \
    if (!isStatic) {\
		LABELSTACK((outPtr-outBuff),0); \
		emit_callhelper_I4I4I4(STFLD_I2_helper);}  \
    else {emit_STIND_REV_I2();}
#ifdef DECLARE_HELPERS
void HELPER_CALL STFLD_I2_helper(unsigned int offset, signed short val, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    *((signed short*) ((char*)(or)+offset)) = val;
}
#endif
#endif

#ifndef emit_STFLD_I4
#define emit_STFLD_I4(isStatic)             \
    if (!isStatic) {\
		LABELSTACK((outPtr-outBuff),0); \
		emit_callhelper_I4I4I4(STFLD_I4_helper);}  \
    else {enregisterTOS; \
          pop(ARG_1); \
          mov_register_indirect_from(ARG_1,SCRATCH_1); \
	      inRegTOS = false;}
#ifdef DECLARE_HELPERS
void HELPER_CALL STFLD_I4_helper(unsigned int offset, int val, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    *((int*) ((char*)(or)+offset)) = val;
}
#endif
#endif

#ifndef emit_STFLD_R4
#define emit_STFLD_R4(isStatic)             \
    /*emit_conv_RtoR4(); - hoisted out because of tls support  */                           \
    if (!isStatic) {\
		LABELSTACK((outPtr-outBuff),0); \
		emit_callhelper_I4R4I4(STFLD_R4_helper);}  \
    else {emit_STIND_REV_I4(); /* since we have already converted the R to R4 */}
#ifdef DECLARE_HELPERS
void HELPER_CALL STFLD_R4_helper(unsigned int offset, float val, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    *((float*) ((char*)(or)+offset)) = (float) val;
}
#endif
#endif

#ifndef emit_STFLD_I8
#define emit_STFLD_I8(isStatic)             \
    if (!isStatic) {\
		LABELSTACK((outPtr-outBuff),0); \
		emit_callhelper_I4I8I4(STFLD_I8_helper);}  \
    else {emit_STIND_REV_I8();}
#ifdef DECLARE_HELPERS
void HELPER_CALL STFLD_I8_helper(unsigned int offset, __int64 val, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    *((__int64*) ((char*)(or)+offset)) = val;
}
#endif
#endif

#define emit_STIND_REV_R8 emit_STIND_REV_I8

#ifndef emit_STFLD_R8
#define emit_STFLD_R8(isStatic)             \
    /*emit_conv_RtoR8(); - hoisted out because of tls support */ \
    if (!isStatic) {\
		LABELSTACK((outPtr-outBuff),0); \
		emit_callhelper_I4R8I4(STFLD_R8_helper);}  \
    else {emit_STIND_REV_R8();}
#ifdef DECLARE_HELPERS
void HELPER_CALL STFLD_R8_helper(unsigned int offset, double val, CORINFO_Object* or) {
    if (or == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    *((double*) ((char*)(or)+offset)) = val;
}
#endif
#endif

#ifndef emit_STFLD_REF
#define emit_STFLD_REF(isStatic)                \
    if (!isStatic) {\
		LABELSTACK((outPtr-outBuff),0); \
		emit_callhelper_I4I4I4(STFLD_REF_helper);} \
    else {emit_callhelper_I4I4I4(StoreIndirect_REF_helper);}
#ifdef DECLARE_HELPERS
void HELPER_CALL STFLD_REF_helper(unsigned int offset, unsigned val, CORINFO_Object* obj) {
    if(obj == NULL) {
        THROW_FROM_HELPER(CORINFO_NullReferenceException);
    }
    //@TODO: should call a generic jit helper w/GC write barrier support,
    //       but it does not exist yet, so here is an i86 specufic sequence
    obj = (CORINFO_Object*) ( (unsigned int) obj + offset);
#ifdef _X86_
    __asm{
        mov edx,obj
        mov eax,val
        }
    FJit_pHlpAssign_Ref_EAX();
#else
    _ASSERTE(!"@TODO Alpha - STDFLD_REF_helper (fjitdef.h)");
#endif  // _X86_
}
#endif  // DECLARE_HELPERS
#endif  // emit_STFLD_REF


#ifndef emit_break_helper
#define emit_break_helper() { \
    LABELSTACK((outPtr-outBuff), 0);   \
    emit_callhelper_il(FJit_pHlpBreak);  \
}
#endif

#ifndef emit_SUB_OVF_I1
#define emit_SUB_OVF_I1()                   \
    LABELSTACK((outPtr-outBuff), 2);   \
    emit_callhelper_I4I4_I4(SUB_OVF_I1_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL SUB_OVF_I1_helper(int i, int j) {
    int i4 = j - i;
    if ((int)((signed char) i4) != i4) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return i4;
}
#endif
#endif


#ifndef emit_SUB_OVF_I2
#define emit_SUB_OVF_I2()                   \
    LABELSTACK((outPtr-outBuff), 2);   \
    emit_callhelper_I4I4_I4(SUB_OVF_I2_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL SUB_OVF_I2_helper(int i, int j) {
    int i4 = j - i;
    if ((int)((signed short) i4) != i4) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return i4;
}
#endif
#endif

#ifndef emit_SUB_OVF_I4
#define emit_SUB_OVF_I4()                   \
    LABELSTACK((outPtr-outBuff), 2);   \
    emit_callhelper_I4I4_I4(SUB_OVF_I4_helper); \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
int HELPER_CALL SUB_OVF_I4_helper(int i, int j) {
    int i4 = j - i;
    // if the signs of i and j are the same, then we can never overflow
    // if the signs of i and j are different, then the result must have the same sign as j
    if ((j ^ i) < 0) {
        // i and j have different sign (the sign bit of j^i is set)
        // ensure that the result has the same sign as j
        if ((i4 ^ j) < 0) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
        }
    }
    return i4;
}
#endif
#endif

#ifndef emit_SUB_OVF_I8
#define emit_SUB_OVF_I8()                   \
    LABELSTACK((outPtr-outBuff), 2);   \
    emit_callhelper_I8I8_I8(SUB_OVF_I8_helper); \
    emit_pushresult_I8()
#ifdef DECLARE_HELPERS
__int64 HELPER_CALL SUB_OVF_I8_helper(__int64 i, __int64 j) {
    __int64 i8 = j - i;
    // if the signs of i and j are the same, then we can never overflow
    // if the signs of i and j are different, then the result must have the same sign as j
    if ((j>=0) != (i>=0)) {
        // ensure that the result has the same sign as j
        if ((i8>=0) != (j>=0)) {
            THROW_FROM_HELPER_RET(CORINFO_OverflowException);
        }
    }
    return i8;
}
#endif
#endif

#ifndef emit_SUB_OVF_U1
#define emit_SUB_OVF_U1()                   \
    LABELSTACK((outPtr-outBuff), 2);   \
    emit_callhelper_I4I4_I4(SUB_OVF_U1_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL SUB_OVF_U1_helper(unsigned int i, unsigned int j) {
    unsigned int u4 = j - i;
    if (u4 > 0xff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return u4;
}
#endif
#endif

#ifndef emit_SUB_OVF_U2
#define emit_SUB_OVF_U2()                   \
    LABELSTACK((outPtr-outBuff), 2);   \
    emit_callhelper_I4I4_I4(SUB_OVF_U2_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL SUB_OVF_U2_helper(unsigned int i, unsigned int j) {
    unsigned int u4 = j - i;
    if (u4 > 0xffff) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return u4;
}
#endif
#endif

#ifndef emit_SUB_OVF_U4
#define emit_SUB_OVF_U4()                   \
    LABELSTACK((outPtr-outBuff), 2);   \
    emit_callhelper_I4I4_I4(SUB_OVF_U4_helper); \
    emit_pushresult_U4()
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL SUB_OVF_U4_helper(unsigned int i, unsigned int j) {
    unsigned int u4 = j - i;
    if (u4 > j) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return u4;
}
#endif
#endif

#ifndef emit_SUB_OVF_U8
#define emit_SUB_OVF_U8()                   \
    LABELSTACK((outPtr-outBuff), 2);   \
    emit_callhelper_I8I8_I8(SUB_OVF_U8_helper); \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL SUB_OVF_U8_helper(unsigned __int64 i, unsigned __int64 j) {
    unsigned __int64 u8 = j - i;
    if (u8 > j) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return u8;
}
#endif
#endif

#ifndef emit_CKFINITE_R4
#define emit_CKFINITE_R4()  \
    emit_conv_RtoR4(); \
    LABELSTACK((outPtr-outBuff), 1);   \
    emit_callhelper_R4_I4(CKFINITE_R4_helper);    \
    emit_pushresult_I4()
#ifdef DECLARE_HELPERS
unsigned HELPER_CALL CKFINITE_R4_helper(float i) {
    if (!_finite(i)) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (*(int*)&i);
}
#endif
#endif

#ifndef emit_CKFINITE_R8
#define emit_CKFINITE_R8()              \
    emit_conv_RtoR8();                              \
    LABELSTACK((outPtr-outBuff), 1);   \
    emit_callhelper_R8_I8(CKFINITE_R8_helper);    \
    emit_pushresult_U8()
#ifdef DECLARE_HELPERS
unsigned __int64 HELPER_CALL CKFINITE_R8_helper(double i) {
    if (!_finite(i)) {
        THROW_FROM_HELPER_RET(CORINFO_OverflowException);
    }
    return (*(unsigned __int64 *) &i);
}
#endif
#endif


#ifndef emit_LDLEN
#define emit_LDLEN()                                            \
    LABELSTACK((outPtr-outBuff), 1);   \
    emit_callhelper_I4_I4(LDLEN_helper);                              \
    emit_pushresult_U4();
#ifdef DECLARE_HELPERS
unsigned int HELPER_CALL LDLEN_helper(CORINFO_Array* or) {
    if (or == NULL) {
        THROW_FROM_HELPER_RET(CORINFO_NullReferenceException);
    }
    return or->length;
}
#endif
#endif

/*********************************************************************************************
    opcodes implemented by inline calls to the standard JIT helpers

    Note: An extra call layer is defined here in the cases the JIT helper calling convention
          differs from the FJIT helper calling convention on a particular chip.
          If they are the same, then these could be redefined in the chip specific macro file
          to remove the extra call layer, if desired.

**********************************************************************************************/
//@TODO: there are more opcodes that should use the standard JIT helpers, but the current
//         helpers are x86 specific and/or do not throw exceptions at the right time

#ifndef emit_initclass
#define emit_initclass(cls)             \
    LABELSTACK((outPtr-outBuff), 0);              \
    deregisterTOS;                      \
    emit_helperarg_1((unsigned int) cls);\
    emit_callhelper_il(FJit_pHlpInitClass)
#endif

#ifndef emit_trap_gc
#define emit_trap_gc()              \
    LABELSTACK((outPtr-outBuff), 0);                  \
    emit_callhelper_il(FJit_pHlpPoll_GC)
#endif

#ifndef emit_NEWOARR
#define emit_NEWOARR(comType)                   \
    emit_helperarg_1(comType);                  \
    if (MAX_ENREGISTERED) {                     \
        emit_mov_TOS_arg(1);					\
    }                                           \
	LABELSTACK((outPtr-outBuff),0);				\
    emit_callhelper_il(FJit_pHlpNewArr_1_Direct);  \
    emit_pushresult_Ptr()
#endif

#ifndef emit_NEWOBJ
#define emit_NEWOBJ(targetClass,jit_helper) \
    emit_helperarg_1(targetClass);          \
	LABELSTACK((outPtr-outBuff),0);			\
    emit_callhelper_il(jit_helper);            \
    emit_pushresult_Ptr()
#endif

#ifndef emit_NEWOBJ_array
#define emit_NEWOBJ_array(scope, token, constructorArgBytes)    \
    emit_LDC_I4(token);                                         \
    emit_LDC_I4(scope);                                             \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_il(FJit_pHlpNewObj);                           \
    emit_drop(constructorArgBytes+8);   \
    emit_pushresult_Ptr()
#endif

#ifndef emit_MKREFANY
#define emit_MKREFANY(token)            \
    emit_save_TOS();                        \
    inRegTOS = false;                       \
    emit_pushconstant_4(token);         \
    emit_restore_TOS();
#endif

#ifndef emit_REFANYVAL
#define emit_REFANYVAL()					\
	if (MAX_ENREGISTERED) {					\
        emit_mov_TOS_arg(0);				\
    }                                       \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_il(FJit_pHlpGetRefAny);	\
    emit_pushresult_Ptr();
#endif

#ifndef emit_THROW
#define emit_THROW()                            \
    if (MAX_ENREGISTERED) {                 \
        emit_mov_TOS_arg(0);\
    }                                       \
    emit_callhelper_il(FJit_pHlpThrow)
#endif


#ifndef emit_RETHROW
#define emit_RETHROW()                            \
    emit_callhelper_il(FJit_pHlpRethrow)
#endif

#ifndef emit_ENDCATCH
#define emit_ENDCATCH() \
    emit_callhelper_il(FJit_pHlpEndCatch)
#endif

#ifndef emit_ENTER_CRIT
//monitor object is <this>, i.e. arg #0
#define emit_ENTER_CRIT()                   \
    if (MAX_ENREGISTERED) {                 \
        emit_mov_TOS_arg(0);\
    }                                       \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_il(FJit_pHlpMonEnter)
#endif

#ifndef emit_EXIT_CRIT
//monitor object is <this>, i.e. arg #0
#define emit_EXIT_CRIT()                        \
    if (MAX_ENREGISTERED) {                 \
        emit_mov_TOS_arg(0);\
    }                                       \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_il(FJit_pHlpMonExit)
#endif

#ifndef emit_ENTER_CRIT_STATIC
#define emit_ENTER_CRIT_STATIC(methodHandle)    \
    emit_helperarg_1(methodHandle);             \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_il(FJit_pHlpMonEnterStatic)
#endif

#ifndef emit_EXIT_CRIT_STATIC
#define emit_EXIT_CRIT_STATIC(methodHandle) \
    emit_helperarg_1(methodHandle);         \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_il(FJit_pHlpMonExitStatic)
#endif

#ifndef emit_CASTCLASS
#define emit_CASTCLASS(targetClass, jit_helper) \
    emit_helperarg_1(targetClass);              \
    if (MAX_ENREGISTERED > 1) {                 \
        emit_mov_TOS_arg(1);    \
    }                                           \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_il(jit_helper);                \
    emit_pushresult_Ptr()
#endif

#ifndef emit_ISINST
#define emit_ISINST(targetClass, jit_helper)\
    emit_helperarg_1(targetClass);          \
    if (MAX_ENREGISTERED) {                 \
        emit_mov_TOS_arg(1);\
    }                                       \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_il(jit_helper);            \
    emit_pushresult_I4()
#endif

#ifndef emit_BOX
#define emit_BOX(cls)                       \
    emit_helperarg_1(cls);                  \
    if (MAX_ENREGISTERED) {                 \
        emit_mov_TOS_arg(1);\
    }                                       \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_il(FJit_pHlpBox);          \
    emit_pushresult_Ptr()
#endif

#ifndef emit_BOXVAL
#define emit_BOXVAL(cls, clsSize)           \
   deregisterTOS; 							\
   emit_helperarg_1(cls);                   \
   mov_register(ARG_2,SP); 					\
   LABELSTACK((outPtr-outBuff),0);			\
   emit_callhelper_il(FJit_pHlpBox);        \
   emit_drop(clsSize);						\
   emit_pushresult_Ptr();					
#endif

#ifndef emit_UNBOX
#define emit_UNBOX(cls)                     \
    emit_helperarg_1(cls);                  \
    if (MAX_ENREGISTERED) {                 \
        emit_mov_TOS_arg(1);\
    }                                       \
	LABELSTACK((outPtr-outBuff),0);	/* Note this can be removed if this becomes an fcalls */ \
    emit_callhelper_il(FJit_pHlpUnbox);        \
    emit_pushresult_Ptr()
#endif

#ifndef emit_ldvirtftn
#define emit_ldvirtftn(offset)  \
    emit_LDC_I4(offset); \
    emit_callhelper_I4I4_I4(ldvirtftn_helper);      \
    emit_WIN32(emit_pushresult_I4());        \
    emit_WIN64(emit_pushresult_I8());
#ifdef DECLARE_HELPERS
void* HELPER_CALL ldvirtftn_helper(unsigned offset,unsigned* obj) {
    return ((void*) (* (unsigned*) (*obj + offset)));
}
#endif
#endif

#ifndef emit_storeTOS_in_JitGenerated_local
#define emit_storeTOS_in_JitGenerated_local(nestingLevel,isFilter) \
    mov_register(ARG_1,FP); \
    add_constant(ARG_1,(prolog_bias-2*sizeof(void*))) ; \
    mov_constant(ARG_2, nestingLevel); \
	mov_register_indirect_from(ARG_2,ARG_1); \
    emit_WIN32(emit_shift_left(ARG_2,3)); \
    emit_WIN64(emit_shift_left(ARG_2,4)); \
    sub_register(ARG_1,ARG_2);   \
    if (isFilter) { \
        mov_register(ARG_2,SP); \
		add_constant(ARG_2,1) ;  \
		add_constant(ARG_1,4) ;   \
		mov_register_indirect_from(ARG_2,ARG_1);\
    } \
    else { \
	    add_constant(ARG_1,4) ;\
	    mov_register_indirect_from(SP,ARG_1);\
    }
#endif

#ifndef emit_reset_storedTOS_in_JitGenerated_local
#define emit_reset_storedTOS_in_JitGenerated_local() \
    mov_register(ARG_1,FP); \
    add_constant(ARG_1,(prolog_bias-2*sizeof(void*))) ; \
    mov_register_indirect_to(ARG_2,ARG_1); \
    add_constant(ARG_2,-1); \
    mov_register_indirect_from(ARG_2,ARG_1); \
    emit_WIN32(emit_shift_left(ARG_2,3)); \
    emit_WIN64(emit_shift_left(ARG_2,4)); \
    sub_register(ARG_1,ARG_2);  \
    mov_constant(ARG_2,0) ;  \
    add_constant(ARG_1,-(int)sizeof(void*)); \
    mov_register_indirect_from(ARG_2,ARG_1); \
    add_constant(ARG_1,-(int)sizeof(void*)); \
    mov_register_indirect_from(ARG_2,ARG_1); 
#endif

#ifndef emit_LOCALLOC
#define emit_LOCALLOC(initialized,EHcount)  \
    enregisterTOS;      \
    and_register(SCRATCH_1,SCRATCH_1); \
	jmp_condition(CondZero,0); \
    { \
		BYTE* scratch_1; scratch_1 = outPtr; \
		emit_WIN32(add_constant(SCRATCH_1,3)); \
		emit_WIN64(add_constant(SCRATCH_1,7)); \
		mov_register(ARG_1,SCRATCH_1);   \
		emit_WIN32(emit_shift_right(ARG_1, 2)) ; \
		emit_WIN64(emit_shift_right(ARG_1, 3)) ; \
		int emitter_scratch_i4; emitter_scratch_i4 = (unsigned int) outPtr;                \
		{ \
		   mov_constant(SCRATCH_1,0); \
		   unsigned char* label; label = outPtr;\
		   push_register(SCRATCH_1);\
		   add_constant(ARG_1,-1); \
		   jmp_condition(CondNonZero,label-outPtr);\
		} \
	*(scratch_1-1) = (BYTE) (outPtr-scratch_1); \
    } \
    /* also store the esp in the appropriate JitGenerated local slot, to support GC reporting */ \
if (EHcount) { \
        mov_register(SCRATCH_1,FP); \
        add_constant(SCRATCH_1,(prolog_bias-2*sizeof(void*))) ; \
        mov_register_indirect_to(SCRATCH_1,SCRATCH_1); \
		emit_WIN32(emit_shift_left(SCRATCH_1,3)); \
        emit_WIN64(emit_shift_left(SCRATCH_1,4)); \
		mov_register(ARG_1,FP); \
        add_constant(ARG_1,(prolog_bias-2*sizeof(void*))) ; \
        sub_register(ARG_1,SCRATCH_1); \
		add_constant(ARG_1,sizeof(void*)); \
		mov_register_indirect_from(SP,ARG_1);  \
} \
    else { \
	    mov_register(SCRATCH_1,FP); \
        add_constant(SCRATCH_1,(prolog_bias-sizeof(void*))) ; \
		mov_register_indirect_from(SP,SCRATCH_1); \
}\
    mov_register(RESULT_1,SP) ;
#endif

#ifndef emit_call_EncVirtualMethod
#define emit_call_EncVirtualMethod(targetMethod) { \
	push_register(ARG_2); \
	push_register(ARG_1); \
    mov_constant(ARG_2, targetMethod); \
	emit_callhelper_il(FJit_pHlpEncResolveVirtual); \
	pop(ARG_1); \
	pop(ARG_2); \
    call_register(RESULT_1); \
}
#endif    

#ifndef emit_call_EncLDFLD_GetFieldAddress
#define emit_call_EncLDFLD_GetFieldAddress(fieldHandle) { \
	_ASSERTE(inRegTOS); \
	mov_register(ARG_1,SCRATCH_1); \
	inRegTOS = false; /* we no longer need the object, since we will compute the address of the field*/\
	mov_constant(ARG_2,fieldHandle); \
	LABELSTACK((outPtr-outBuff),0); \
	emit_callhelper_il(FJit_pHlpGetFieldAddress); \
	inRegTOS = true; /* address of field */ \
}
#endif

#ifndef emit_call_EncSTFLD_GetFieldAddress
#define emit_call_EncSTFLD_GetFieldAddress(fieldHandle,fieldSize) { \
	deregisterTOS; \
	mov_register(SCRATCH_1,SP); \
	add_constant(SCRATCH_1,fieldSize); /* get the object*/ \
	mov_register_indirect_to(ARG_1,SCRATCH_1); \
	mov_constant(ARG_2,fieldHandle); \
	LABELSTACK((outPtr-outBuff),0); \
	emit_callhelper_il(FJit_pHlpGetFieldAddress); \
	inRegTOS = true; /* address of field */ \
	}
#endif


#ifndef emit_sequence_point_marker
#define emit_sequence_point_marker() x86_nop()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\fjitpass.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            FJitpass.h                                     XX
XX                                                                           XX
XX   Routines that are specialized for each pass of the jit                  XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


/* rearrange the stack & regs to match the calling convention for the chip,
   return the amount of stack space that the NATIVE call takes up.   (That is 
   the amount the ESP needs to be moved after the call is made.  For the default
   convention this number is not needed as it is the callee's responciblity to
   make this adjustment, but for varargs, the caller needs to do it).  */

unsigned  FJit::buildCall(FJitContext* fjit, CORINFO_SIG_INFO* sigInfo, unsigned char** pOutPtr, bool* pInRegTOS, BuildCallFlags flags) {
#ifdef _X86_
    unsigned char* outPtr = *pOutPtr;
    bool inRegTOS = *pInRegTOS;

    _ASSERTE((sigInfo->callConv & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_DEFAULT ||
             (sigInfo->callConv & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_STDCALL ||
             (sigInfo->callConv & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_C ||
             (sigInfo->callConv & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_THISCALL ||
             (sigInfo->callConv & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_FASTCALL ||
             (sigInfo->callConv & CORINFO_CALLCONV_MASK) == CORINFO_CALLCONV_VARARG);

    unsigned int argCount = sigInfo->numArgs;
    if (sigInfo->hasThis()) argCount++;
    if (sigInfo->hasTypeArg()) argCount++;

		// we may need space for the return value buffer
	unsigned retValBuffWords = 0;
	if (sigInfo->hasRetBuffArg())
		retValBuffWords = typeSizeInSlots(fjit->jitInfo, sigInfo->retTypeClass);
	unsigned nativeStackSize = 0;

		// Pop off the arguments
	fjit->popOp(sigInfo->totalILArgs());

    /*  we now have the correct number of arguments
        Note:when we finish, we must have forced TOS out of the inRegTOS register, i.e.
        we either moved it to an arg reg or we did a deregisterTOS
        */
    if (argCount != 0 || retValBuffWords != 0) {
		argInfo* argsInfo = (argInfo*) _alloca(sizeof(argInfo) * (argCount+1)); // +1 for possible thisLast swap
		nativeStackSize = fjit->computeArgInfo(sigInfo, argsInfo);

		if (flags & CALL_THIS_LAST) {
			_ASSERTE(argCount > 0 && sigInfo->hasThis());
			//this has been push last, rather than first as the argMap assumed,
			//So, lets fix up argMap to match the actual call site
			//This only works because <this> is always enregistered so the stack offsets in argMap are unaffected
			argsInfo[argCount] = argsInfo[0];
			argsInfo++;
		}

		/*
		  We are going to assume that for any chip, the space taken by an enregistered arg
		  is sizeof(void*).
		  Note:
			nativeStackSize describes the size of the eventual call stack.
			The order of the args in argsInfo (note <this> is now treated like any other arg
				arg 0
				arg 1
				...
				arg n
			the order on the stack is:
				tos: arg n
					 arg n-1
					 ...
					 arg 0
		*/

		//see if we can just pop some stuff off TOS quickly
		//See if stuff at TOS is going to regs.
		// This also insure that the 'thisLast' argument is gone for the loop below
		while (argCount > 0 && argsInfo[argCount-1].isReg) {
			--argCount;
			emit_mov_TOS_arg(argsInfo[argCount].regNum);
		}

			// If there are more args than would go in regsister or we have a return 
			// buff, we need to rearrange the stack
		if (argCount != 0 || retValBuffWords != 0) {
			deregisterTOS;
			   // Compute the size of the arguments on the IL stack
			unsigned ilStackSize = nativeStackSize;
			for (unsigned i=0; i < argCount; i++) {
				if ((argsInfo[i].isReg) ||					// add in all the enregistered args.
					(argsInfo[i].type.isPrimitive() && argsInfo[i].type.enum_() == typeR4))	// since R4's are stored as R8's on the stack
					ilStackSize += sizeof(void*);       
			}

				   // if we have a hidden return buff param, allocate space and load the reg
				   // in this case the stack is growing, so we have to perform the argument
				   // shuffle in the opposite order 
			if (retValBuffWords > 0)
			{
				// From a stack tracking perspective, this return value buffer comes
				// into existance before the call is made, we do that tracking here.  
				fjit->pushOp(OpType(sigInfo->retTypeClass));
				nativeStackSize += retValBuffWords*sizeof(void*);   // allocate the return buffer
			}

			if (nativeStackSize >= ilStackSize)
			{
				if (nativeStackSize - ilStackSize)
					emit_grow(nativeStackSize-ilStackSize);     // get the extra space
				 
				// figure out the offsets from the moved stack pointer.  
				unsigned ilOffset = nativeStackSize-ilStackSize;     // start at the last IL arg
				unsigned nativeOffset = 0;                           // put it here
				
				i = argCount; 
				while(i > 0) {
					--i; 
					if (argsInfo[i].isReg) {
						emit_mov_arg_reg(ilOffset, argsInfo[i].regNum);
						ilOffset += sizeof(void*);
					}
					else {
						_ASSERTE(nativeOffset <= ilOffset); 
						if (!(argsInfo[i].type.isPrimitive() && argsInfo[i].type.enum_() == typeR4))
						{
							if (ilOffset != nativeOffset) 
							{
								emit_mov_arg_stack(nativeOffset, ilOffset, argsInfo[i].size);
							}
							ilOffset += argsInfo[i].size;
						}
						else // convert from R8 to R4
						{
							emit_narrow_R8toR4(nativeOffset, ilOffset);
							ilOffset += sizeof(double);
						}
						nativeOffset += argsInfo[i].size;
					}
				}
				_ASSERTE(nativeOffset == nativeStackSize - retValBuffWords*sizeof(void*));
				_ASSERTE(ilOffset == nativeStackSize);

			}
			else {
				// This is the normal case, the stack will shink because the register
				// arguments don't take up space 
				unsigned ilOffset = ilStackSize;                 // This points just above the first arg.  
				unsigned  nativeOffset = ilStackSize - retValBuffWords*sizeof(void*);            // we want the native args to overwrite the il args
				
				for (i=0; i < argCount; i++) {
					if (argsInfo[i].isReg) {
						ilOffset -= sizeof(void*);
						emit_mov_arg_reg(ilOffset, argsInfo[i].regNum);
					}
					else {
						if (!(argsInfo[i].type.isPrimitive() && argsInfo[i].type.enum_() == typeR4))
						{
							ilOffset -= argsInfo[i].size;
							nativeOffset -= argsInfo[i].size;
							//_ASSERTE(nativeOffset >= ilOffset); // il args always take up more space
							if (ilOffset != nativeOffset) 
							{
								emit_mov_arg_stack(nativeOffset, ilOffset, argsInfo[i].size);
							}
						}
						else // convert from R8 to R4
						{
							ilOffset -= sizeof(double);
							nativeOffset -= sizeof(float);
							//_ASSERTE(nativeOffset >= ilOffset); // il args always take up more space
							emit_narrow_R8toR4(nativeOffset,ilOffset);
						}

					}
				}
				_ASSERTE(ilOffset == 0);
				emit_drop(nativeOffset);    // Pop off the unused part of the stack
			}
			
			if (retValBuffWords > 0)
			{
					// Get the GC info for return buffer, an zero out any GC pointers
				bool* gcInfo;
				if (sigInfo->retType == CORINFO_TYPE_REFANY) {
					_ASSERTE(retValBuffWords == 2);
					static bool refAnyGCInfo[] = { true, false };
					gcInfo = refAnyGCInfo;
				}
				else {
					gcInfo = (bool*) _alloca(retValBuffWords*sizeof(bool));
					fjit->jitInfo->getClassGClayout(sigInfo->retTypeClass, (BYTE*)gcInfo);
				}
				unsigned retValBase = nativeStackSize-retValBuffWords*sizeof(void*);
				for (unsigned i=0; i < retValBuffWords; i++) {
					if (gcInfo[i])
						emit_set_zero(retValBase + i*sizeof(void*));
				}

					// set the return value buffer argument to the allocate buffer
				unsigned retBufReg = sigInfo->hasThis();    // return buff param is either the first or second reg param
				emit_getSP(retValBase);                     // get pointer to reutrn buffer
				emit_mov_TOS_arg(retBufReg);   
			}

		}
	}
	else {
		deregisterTOS;
    }

        // If this is a varargs function, push the hidden signature variable
		// or if it is calli to an unmanaged target push the sig
    if (sigInfo->isVarArg() || (flags & CALLI_UNMGD)) {
            // push token
        CORINFO_VARARGS_HANDLE vasig = fjit->jitInfo->getVarArgsHandle(sigInfo);
        emit_WIN32(emit_LDC_I4(vasig)) emit_WIN64(emit_LDC_I8(vasig));
        deregisterTOS;
        nativeStackSize += sizeof(void*);
    }

		// If anything is left on the stack, we need to log it for GC tracking puposes.  
	LABELSTACK(outPtr-fjit->codeBuffer, 0); 

    *pOutPtr = outPtr;
    *pInRegTOS = inRegTOS;
    return(nativeStackSize - retValBuffWords*sizeof(void*));
#else // _X86_
    _ASSERTE(!"@TODO Alpha - buildCall (fJitPass.h)");
    return 0;
#endif // _X86_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\fjitencode.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// -*- C++ -*-
#ifndef _FJIT_ENCODE_H_
#define _FJIT_ENCODE_H_
/*****************************************************************************/

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            FJitEncode.h                                   XX
XX                                                                           XX
XX   Encodes and decodes the il to pc map.  In uncompressed form, the map    XX
XX   is a sorted list of il/pc offset pairs where the il and the pc offset   XX
XX   indicate the start of an opcode.  In compressed form, the pairs are     XX
XX   delta encoded from the prior pair                                       XX
XX                                                                           XX
XX   Also has generic boolean array to bit string compress and decompress    XX
XX                                                                           XX
XX                                                                           XX
XX                                                                           XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/

//@TODO: for now we are doing a simple compression of the delta encoding 
//just to keep things simple.  Later this should use a 6bit delta pair of the
//form:  3bits of pc delta, 2 bits of il delta, 1 bit more bits follow.


class FJit_Encode {

private:

	/*struct Fjit_il2pcMap
	{
		unsigned ilOffset;    
		unsigned pcOffset;	 
	};*/
    typedef unsigned Fjit_il2pcMap;

	Fjit_il2pcMap*	map;
	unsigned		map_len;
	unsigned		map_capacity;
	bool			compressed;

	/* decompress the internals if necessary. Answer the number of entries in the map */
	unsigned decompress();

public:
	

	FJit_Encode();
	virtual ~FJit_Encode();

    // resets the map to empty
    void reset();

	/*adjust the internal mem structs as needed for the size of the method being jitted*/
	void ensureMapSpace(unsigned int len);

	/* decompress the bytes. Answer the number of entries in the map */
	virtual unsigned decompress(unsigned char* bytes);

	/* add a new pair to the end of the map.  Note pairs must be added in ascending order */
	void add(unsigned ilOffset, unsigned pcOffset);

	/* map an il offset to a pc offset, returns zero if the il offset does not exist */
	unsigned pcFromIL(unsigned ilOffset);

	/*map a pc offset to an il offset and optionally a pc offset within the opcode, 
	  returns -1 if il offset does not exist */
	virtual signed ilFromPC(unsigned pcOffset, unsigned* pcInILOffset);

	/* return the size of the compressed stream in bytes. */
	unsigned compressedSize();

	/* compress the map into the supplied buffer.  Return true if successful */
	bool compress(unsigned char* buffer, unsigned buffer_len);

	/* compress the bool* onto itself and answer the number of compressed bytes */
	static unsigned compressBooleans(bool* buffer, unsigned buffer_len);

	/* answer the number of bytes it takes to encode an unsigned val */
	static unsigned encodedSize(unsigned val);

	/*encode an unsigned, buffer ptr is incremented */
	static unsigned encode(unsigned val, unsigned char** buffer);

	/*decode an unsigned, buffer ptr is incremented, called from FJIT_EETwain.cpp */
	virtual unsigned decode_unsigned(unsigned char** buffer);

	/*decode an unsigned, buffer ptr is incremented, called from FJIT_EETwain.cpp */
	static unsigned decode(unsigned char** buffer);

    void reportDebuggingData(ICorJitInfo* jitInfo, CORINFO_METHOD_HANDLE ftn,
                             UINT prologEnd, UINT epilogStart);

};
#endif //_FJIT_ENCODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\helperframe.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************/
/*                       helperFrame.cpp                      */
/**************************************************************/
#include "helperFrame.h"

/***************************************************************/
/* setMachState figures out what the state of the CPU will be
   when the function that calls 'setMachState' returns.  It stores
   this information in 'frame'

   setMachState works by simulating the execution of the
   instructions starting at the instruction following the
   call to 'setMachState' and continuing until a return instruction
   is simulated.  To avoid having to process arbitrary code, the
   call to 'setMachState' should be called as follows

      if (machState.setMachState != 0) return;

   setMachState is guarnenteed to return 0 (so the return
   statement will never be executed), but the expression above
   insures insures that there is a 'quick' path to epilog
   of the function.  This insures that setMachState will only
   have to parse a limited number of X86 instructions.   */


/***************************************************************/
#ifndef POISONC
#define POISONC ((sizeof(int *) == 4)?0xCCCCCCCC:0xCCCCCCCCCCCCCCCC)
#endif

MachState::MachState(void** aPEdi, void** aPEsi, void** aPEbx, void** aPEbp, void* aEsp, void** aPRetAddr) {

#ifdef _DEBUG
        _edi = (void*)POISONC;
        _esi = (void*)POISONC;
        _ebx = (void*)POISONC;
        _ebp = (void*)POISONC;
#endif
        _esp = aEsp;
        _pRetAddr = aPRetAddr;
        _pEdi = aPEdi;
        _pEsi = aPEsi;
        _pEbx = aPEbx;
        _pEbp = aPEbp;
}

/***************************************************************/
#ifdef _X86_
__declspec(naked)
#endif // !_X86_
int LazyMachState::captureState() {
#ifdef _X86_
    __asm{
                mov     [ECX]MachState._pRetAddr, 0             ;; marks that this is not yet valid
                mov     [ECX]MachState._edi, EDI                ;; remember register values
                mov     [ECX]MachState._esi, ESI
                mov     [ECX]MachState._ebx, EBX

                mov     [ECX]LazyMachState.captureEbp, EBP
                mov     [ECX]LazyMachState.captureEsp, ESP
                mov     EAX, [ESP]                                                      ;; catpure return address
                mov     [ECX]LazyMachState.captureEip,EAX

                xor     EAX, EAX
                ret
                }
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - getMachState (HelperFrame.cpp)");
    return 0;
#endif // _X86_
}

/***************************************************************/
void LazyMachState::getState(int funCallDepth, TestFtn testFtn) {
#ifdef _X86_

    if (isValid())          // already in valid state, can return
            return;

    // currently we only do this for depth 1 through 3
    _ASSERTE(1 <= funCallDepth && funCallDepth <= 3);

            // Work with a copy so that we only write the values once.
            // this avoids race conditions.
    MachState copy;
    copy._edi = _edi;
    copy._esi = _esi;
    copy._ebx = _ebx;
    copy._ebp = captureEbp;
    copy._pEdi = &_edi;
    copy._pEsi = &_esi;
    copy._pEbx = &_ebx;
    copy._pEbp = &_ebp;

        // We have caputred the state of the registers as they exist in 'captureState'
        // we need to simulate execution from the return address caputred in 'captureState
        // until we return from the caller of caputureState.

    unsigned __int8* ip = captureEip;
    void** ESP = captureEsp;
    ESP++;                                                                          // pop caputureState's return address


        // VC now has small helper calls that it uses in epilogs.  We need to walk into these
        // helpers if we are to decode the stack properly.  After we walk the helper we need
        // to return and continue walking the epiliog.  This varaible remembers were to return to
    unsigned __int8* epilogCallRet = 0;
    BOOL bFirstCondJmp = TRUE;

#ifdef _DEBUG
    int count = 0;
#endif
    bool bset16bit=false;
    bool b16bit=false;
    for(;;)
    {
        _ASSERTE(count++ < 1000);       // we should never walk more than 1000 instructions!
        b16bit=bset16bit;
        bset16bit=false;
        switch(*ip)
        {
            case 0x90:              // nop 
            case 0x64:              // FS: prefix
            incIp1:
                bset16bit=b16bit;
                ip++;
                break;
            case 0x66:              //operand size prefix
                ip++;
                bset16bit=true;
                break;

            case 0x5B:              // pop EBX
                copy._pEbx = ESP;
                copy._ebx  = *ESP++;
                goto incIp1;
            case 0x5D:              // pop EBP
                copy._pEbp = ESP;
                copy._ebp  = *ESP++;
                goto incIp1;
            case 0x5E:              // pop ESI
                copy._pEsi = ESP;
                copy._esi = *ESP++;
                goto incIp1;
            case 0x5F:              // pop EDI
                copy._pEdi = ESP;
                copy._edi = *ESP++;
                goto incIp1;

            case 0x58:              // pop EAX
            case 0x59:              // pop ECX
            case 0x5A:              // pop EDX
                ESP++;
                goto incIp1;

            case 0xEB:              // jmp <disp8>
                ip += (signed __int8) ip[1] + 2;
                break;

            case 0xE8:              // call <disp32>
                ip += 5;
                    // Normally we simply skip calls since we should only run into descructor calls, and they leave 
                    // the stack unchanged.  VC emits special epilog helpers which we do need to walk into
                    // we determine that they are one of these because they are followed by a 'ret' (this is
                    // just a heuristic, but it works for now)

    
                if (epilogCallRet == 0 && (*ip == 0xC2 || *ip == 0xC3)) {   // is next instr a ret or retn?
                        // Yes.  we found a call we need to walk into.
                    epilogCallRet = ip;             // remember our return address
                    --ESP;                          // simulate pushing the return address
                    ip += *((__int32*) &ip[-4]);        // goto the call
                }
                break;

            case 0xE9:              // jmp <disp32>
                ip += *((__int32*) &ip[1]) + 5;
                break;

            case 0x0f:   // follow non-zero jumps:
                if (ip[1] == 0x85)  // jne <disp32>
                    ip += *((__int32*) &ip[2]) + 6;
                else
                if (ip[1] == 0x84)  // je <disp32>
                    ip += 6;
                else
                    goto badOpcode;
                break;

                // This is here because VC seems no not always optimize
                // away a test for a literal constant
            case 0x6A:              // push 0xXX
                ip += 2;
                --ESP;
                break;

            // Added to handle VC7 generated code
            case 0x50:              // push EAX
            case 0x51:              // push ECX
            case 0x52:              // push EDX
            case 0x53:              // push EBX
            case 0x55:              // push EBP
            case 0x56:              // push ESI
            case 0x57:              // push EDI
                --ESP;
            case 0x40:              // inc EAX
                goto incIp1;

            case 0x68:              // push 0xXXXXXXXX
                if ((ip[5] == 0xFF) && (ip[6] == 0x15)) {
                    ip += 11; // This is a hack for BBT.
                              // BBT inserts a push, call indirect pair,
                              // we assume that the call pops the const and
                              // so we skip push const, call indirect pair and assume
                              // that the stack didn't change.
                }
                else
                    ip += 5;
                break;

            case 0x75:              // jnz <target>
                // Except the first jump, we always follow forward jump to avoid possible looping.
                // If you make any change in this function, please talk to VanceM.
                if (bFirstCondJmp) {
                    bFirstCondJmp = FALSE;
                    ip += (signed __int8) ip[1] + 2;   // follow the non-zero path
                }
                else {
                    unsigned __int8* tmpIp = ip + (signed __int8) ip[1] + 2;
                    if (tmpIp > ip) {
                        ip = tmpIp;
                    }
                    else {
                        ip += 2;
                    }
                }
                break;

            case 0x74:              // jz <target>
                if (bFirstCondJmp) {
                    bFirstCondJmp = FALSE;
                    ip += 2;            // follow the non-zero path
                }
                else {
                    unsigned __int8* tmpIp = ip + (signed __int8) ip[1] + 2;
                    if (tmpIp > ip) {
                        ip = tmpIp;
                    }
                    else {
                        ip += 2;
                    }
                }
                break;

            case 0x85:
                if ((ip[1] & 0xC0) != 0xC0)  // TEST reg1, reg2
                    goto badOpcode;
                ip += 2;
                break;

            case 0x31:
            case 0x32:
            case 0x33:
                if ((ip[1] & 0xC0) == 0xC0) // mod bits are 11
                {
                    // XOR reg1, reg2

                // VC generates a silly sequence in some code
                // xor reg, reg
                // test reg reg (might be not present)
                // je   <target>
                // This is just an unconditional branch, so to it
                if ((ip[1] & 7) == ((ip[1] >> 3) & 7)) {
                    if (ip[2] == 0x85 && ip[3] == ip[1]) {      // TEST reg, reg
                        if (ip[4] == 0x74) {
                            ip += (signed __int8) ip[5] + 6;   // follow the non-zero path
                            break;
                        }
                        _ASSERTE(ip[4] != 0x0f || ((ip[5] & 0xF0)!=0x80));              // If this goes off, we need the big jumps
                    }
                    else
                    {
                        if(ip[2]==0x74)
                        {
                            ip += (signed __int8) ip[3] + 4;
                            break;
                        }
                        _ASSERTE(ip[2] != 0x0f || ((ip[3] & 0xF0)!=0x80));              // If this goes off, we need the big jumps
                    }
                }
                    ip += 2;
                }
                else if ((ip[1] & 0xC0) == 0x40) // mod bits are 01
                {
                    // XOR reg1, [reg+offs8]
                    // Used by the /GS flag for call to __security_check_cookie()
                    // Should only be XOR ECX,[EBP+4]
                    _ASSERTE((((ip[1] >> 3) & 0x7) == 0x1) && ((ip[1] & 0x7) == 0x5) && (ip[2] == 4));
                    ip += 3;
                }
                else if ((ip[1] & 0xC0) == 0x80) // mod bits are 10
                {
                    // XOR reg1, [reg+offs32]
                    // Should not happen but may occur with __security_check_cookie()
                    _ASSERTE(!"Unexpected XOR reg1, [reg+offs32]");
                    ip += 6;
                }
                else
                {
                    goto badOpcode;
                }
                break;

            case 0x3B:
                if ((ip[1] & 0xC0) != 0xC0)  // CMP reg1, reg2
                    goto badOpcode;
                ip += 2;
                break;
            
    

            case 0x89:                         // MOV
                if ((ip[1] & 0xC7) == 0x5) {   // MOV [mem], REG
                    ip += 6;
                    break;
                }
                if ((ip[1] & 0xC7) == 0x45) {   // MOV [EBP+XX], REG
                    ip += 3;
                    break;
                }

                if (ip[1] == 0xEC)   // MOV ESP, EBP
                    goto mov_esp_ebp;

#ifdef _DEBUG
                if ((ip[1] & 0xC7) == 0x85) {   // MOV [EBP+XXXX], REG
                    ip += 6;
                    break;
                }

                if ((ip[1] & 0xC0) == 0xC0) {    // MOV EAX, REG
                    ip += 2;
                    break;
                }
#endif
                goto badOpcode;

            case 0x81:                              // ADD ESP, <imm32>
                if(b16bit)
                    goto badOpcode;
                if (ip[1] == 0xC4) {
                    ESP = (void**) ((__int8*) ESP + *((__int32*) &ip[2]));
                    ip += 6;
                    break;
                }
                else if (ip[1] == 0xC1) {
                    ip += 6;
                    break;
                }
                goto badOpcode;

            case 0x83:
                if (ip[1] == 0xC4)  {            // ADD ESP, <imm8>
                    ESP = (void**) ((__int8*) ESP + (signed __int8) ip[2]);
                    ip += 3;
                    break;
                }
                if (ip[1] == 0xc5) {            // ADD EBP, <imm8>
                    copy._ebp  = (void*)((size_t)copy._ebp + (signed __int8) ip[2]);
                    ip += 3;
                    break;
                }
                if ((ip[1] &0xC0) == 0xC0) {            // OP [REG] XX
                    ip += 3;
                    break;
                }
                if ((ip[1] & 7) != 4) {                 // No SIB byte
                    if ((ip[1] & 0xC0) == 0x80)         // OP [REG+XXXX] XXXX
                        ip += 7;
                    else if ((ip[1] & 0xC0) == 0x40)    // OP [REG+XXXX] XX
                        ip += 4;
                    else
                        goto badOpcode;
                    break;
                }
                else {                                  // SIB byte
                    if ((ip[1] & 0xC0) == 0x80)         // OP [REG+XXXX] XXXX
                        ip += 8;
                    else if ((ip[1] & 0xC0) == 0x40)    // OP [REG+XXXX] XX
                        ip += 5;
                    else
                        goto badOpcode;
                    break;
                }
                break;

            case 0x8B:                                                  // MOV
                if (ip[1] == 0xE5) {                    // MOV ESP, EBP
                mov_esp_ebp:
                    ESP = (void**) copy._ebp;
                    ip += 2;
                    break;
                }
                //intentionally not breaking the case clause because 0x8B has the same instruction size
            case 0x8A:                                                  // MOV 

                if ((ip[1] & 0xE7) == 0x45) {   // MOV E*X, [EBP+XX]
                    ip += 3;
                    break;
                }

                if ((ip[1] & 0xE4) == 0) {              // MOV E*X, [E*X]
                    ip += 2;
                    break;
                                }
                if ((ip[1] & 0xC7) == 0x44 && ip[2] == 0x24) // MOV reg, [ESP+disp8]
                {
                    ip += 4;
                    break;
                }

                if ((ip[1] & 0xC7) == 0x84 && ip[2] == 0x24) // MOV reg, [ESP+disp32]
                {
                    ip += 7;
                    break;
                }
                if ((ip[1] & 0xE7) == 0x85) {   // MOV E*X, [EBP+XXXX]
                    ip += 6;
                    break;
                }

                if ((ip[1] & 0xC0) == 0xC0) {    // MOV REG, REG
                    ip += 2;
                    break;
                }
                goto badOpcode;

            case 0x8D:                          // LEA
                if ((ip[1] & 0x38) == 0x20) {                       // Don't allow ESP to be updated
                    if (ip[1] == 0xA5)          // LEA ESP, [EBP+XXXX]
                        ESP = (void**) ((__int8*) copy._ebp + *((signed __int32*) &ip[2])); 
                    else if (ip[1] == 0x65)     // LEA ESP, [EBP+XX]
                        ESP = (void**) ((__int8*) copy._ebp + (signed __int8) ip[2]); 
                    else
                        goto badOpcode;
                }

                if ((ip[1] & 0xC7) == 0x45)                       // LEA reg, [EBP+disp8]
                    ip += 3;
                else if ((ip[1] & 0x47) == 0x05)                  // LEA reg, [reg+disp32]
                    ip += 6;
                else if ((ip[1] & 0xC7) == 0x44 && ip[2] == 0x24) // LEA reg, [ESP+disp8]
                    ip += 4;
                else if ((ip[1] & 0xC7) == 0x84 && ip[2] == 0x24) // LEA reg, [ESP+disp32]
                    ip += 7;
                else
                    goto badOpcode;
                break;

            case 0xB8:  // MOV EAX, imm32
            case 0xB9:  // MOV ECX, imm32
            case 0xBA:  // MOV EDX, imm32
            case 0xBB:  // MOV EBX, imm32
            case 0xBE:  // MOV ESI, imm32
            case 0xBF:  // MOV EDI, imm32
                if(b16bit)
                    ip += 3;
                else
                    ip += 5;
                break;

            case 0xC2:                  // ret N
                {
                unsigned __int16 disp = *((unsigned __int16*) &ip[1]);
                                ip = (unsigned __int8*) (*ESP);
                copy._pRetAddr = ESP++;
                _ASSERTE(disp < 64);    // sanity check (although strictly speaking not impossible)
                ESP = (void**)((size_t) ESP + disp);           // pop args
                goto ret;
                }
            case 0xC3:                  // ret
                ip = (unsigned __int8*) (*ESP);
                copy._pRetAddr = ESP++;

                if (epilogCallRet != 0) {       // we are returning from a special epilog helper
                    ip = epilogCallRet;
                    epilogCallRet = 0;
                    break;                      // this does not count toward funcCallDepth
                }
            ret:
                --funCallDepth;
                if (funCallDepth <= 0 || (testFtn != 0 && (*testFtn)(*copy.pRetAddr())))
                    goto done;
                bFirstCondJmp = TRUE;
                break;

            case 0xC6:
                if (ip[1] == 0x05)      // MOV disp32, imm8
                    ip += 7;
                else if (ip[1] == 0x45) // MOV disp8[EBP], imm8
                    ip += 4;
                else if (ip[1] == 0x85) // MOV disp32[EBP], imm8
                    ip += 7;
                else
                    goto badOpcode;
                break;

            case 0xC7:

                if (ip[1] == 0x85)      // MOV [EBP+disp32], imm32
                    ip += b16bit?8:10;
                else if (ip[1] == 0x45) // MOV [EBP+disp8], imm32
                    ip += b16bit?5:7;
                else if (ip[1] == 0x44 && ip[2] == 0x24) // MOV [ESP+disp8], imm32
                    ip += b16bit?6:8;
                else if (ip[1] == 0x84 && ip[2] == 0x24) // MOV [ESP+disp32], imm32
                    ip += b16bit?9:11;
                else
                    goto badOpcode;

                break;

            case 0xC9:                  // leave
                ESP = (void**) (copy._ebp);
                copy._pEbp = ESP;
                copy._ebp = *ESP++;
                ip++;
                                break;

            case 0xCC:
                *((int*) 0) = 1;        // If you get at this error, it is because yout
                                                                                // set a breakpoint in a helpermethod frame epilog
                                                                                // you can't do that unfortunately.  Just move it
                                                                                // into the interior of the method to fix it

                goto done;

            case 0xD9:  // single prefix
                if (0xEE == ip[1])
                {
                    ip += 2;            // FLDZ
                    break;
                }
                //
                // INTENTIONAL FALL THRU
                //
            case 0xDD:  // double prefix
                switch (ip[1])
                {
                case 0x5D:  ip += 3; break; // FSTP {d|q}word ptr [EBP+disp8]
                case 0x45:  ip += 3; break; // FLD  {d|q}word ptr [EBP+disp8]
                case 0x85:  ip += 6; break; // FLD  {d|q}word ptr [EBP+disp32]
                case 0x05:  ip += 6; break; // FLD  {d|q}word ptr [XXXXXXXX]
                default:    goto badOpcode; 
                }
                break;
            
            // opcode generated by Vulcan/BBT instrumentation
            case 0xFF:
            // search for push dword ptr[esp]; push imm32; call disp32 and if found ignore it
                if ((ip[1] == 0x34) && (ip[2] == 0x24) && // push dword ptr[esp]  (length 3 bytes)
                    (ip[3] == 0x68) &&                    // push imm32           (length 5 bytes)
                    (ip[8] == 0xe8))                      // call disp32          (length 5 bytes)
                {
                    // found the magic seq emitted by Vulcan instrumentation
                    ip += 13;  // (3+5+5)
                    break;
                }
                else 
                    goto badOpcode;

            default:
            badOpcode:
                _ASSERTE(!"Bad opcode");
                // FIX what to do here?
                *((unsigned __int8**) 0) = ip;  // cause an access violation (Free Build assert)
                goto done;
        }
    }
    done:
        _ASSERTE(epilogCallRet == 0);

    // At this point the fields in 'frame' coorespond exactly to the register
    // state when the the helper returns to its caller.
        copy._esp = ESP;


        // _pRetAddr has to be the last thing updated when we make the copy (because its
        // is the the _pRetAddr becoming non-zero that flips this from invalid to valid.
        // we assert that it is the last field in the struct.

#ifdef _DEBUG
                        // Make certain _pRetAddr is last and struct copy happens lowest to highest
        static int once = 0;
        if (!once) {
                _ASSERTE(offsetof(MachState, _pRetAddr) == sizeof(MachState) - sizeof(void*));
                void* buff[sizeof(MachState) + sizeof(void*)];
                MachState* from = (MachState*) &buff[0];        // Set up overlapping buffers
                MachState* to = (MachState*) &buff[1];
                memset(to, 0xCC, sizeof(MachState));
                from->_pEdi = 0;
                *to = *from;                                                            // If lowest to highest, 0 gets propageted everywhere
                _ASSERTE(to->_pRetAddr == 0);
                once = 1;
        }
#endif

        *((MachState *) this) = copy;

#else // !_X86_
    _ASSERTE(!"@TODO Alpha - getMachStateEx (HelperFrame.cpp)");
#endif // _X86_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\helperframe.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**************************************************************/
/*                       helperFrame.h                        */
/**************************************************************/
/* HelperFrame is defines 'GET_STATE(machState)' macro, which 
   figures out what the state of the machine will be when the 
   current method returns.  It then stores the state in the
   JIT_machState structure.  */

/**************************************************************/

#ifndef _HELPERFRAME_H_

#define _HELPERFRAME_H_

	// A MachState indicates the register state of the processor at some point in time (usually
	// just before or after a call is made).  It can be made one of two ways.  Either explicitly
	// (when you for some reason know the values of all the registers), or implicitly using the
	// GET_STATE macros.  

struct MachState {
		// Create a machine state explicitly
	MachState(void** aPEdi, void** aPEsi, void** aPEbx, void** aPEbp, void* aEsp, void** aPRetAddr);

	MachState() { 
#ifdef _DEBUG
		memset(this, 0xCC, sizeof(MachState)); 
#endif
		}

    typedef void* (*TestFtn)(void*);
	void getState(int funCallDepth=1, TestFtn testFtn=0);									

	bool  isValid()		{ _ASSERTE(_pRetAddr != (void**)(size_t)0xCCCCCCCC); return(_pRetAddr != 0); }
	void** pEdi() 		{ _ASSERTE(_pEdi != (void**)(size_t)0xCCCCCCCC); return(_pEdi); }
	void** pEsi() 		{ _ASSERTE(_pEsi != (void**)(size_t)0xCCCCCCCC); return(_pEsi); }
	void** pEbx() 		{ _ASSERTE(_pEbx != (void**)(size_t)0xCCCCCCCC); return(_pEbx); }
	void** pEbp() 		{ _ASSERTE(_pEbp != (void**)(size_t)0xCCCCCCCC); return(_pEbp); }
	void*  esp() 		{ _ASSERTE(isValid()); return(_esp); }
	void**&  pRetAddr()	{ _ASSERTE(isValid()); return(_pRetAddr); }

	friend void throwFromHelper(enum CorInfoException throwEnum, struct MachState* state);
	friend class HelperMethodFrame;
	friend struct LazyMachState;

protected:
		// Note the fields are layed out to make generating a
		// MachState structure from assembly code very easy

		// The state of all the callee saved registers.
		// If the register has been spill to the stack p<REG>
		// points at this location, otherwise it points
		// at the field <REG> field itself 
	void** _pEdi; 
    void* 	_edi;
    void** _pEsi;
    void* 	_esi;
    void** _pEbx;
    void* 	_ebx;
    void** _pEbp;
    void* 	_ebp;

    void* _esp;          // stack pointer after the function returns
    void** _pRetAddr;   // The address of the stored IP address (points to the stack)
};

/********************************************************************/
/* This allows you to defer the computation of the Machine state 
   until later.  Note that we don't reuse slots, because we want
   this to be threadsafe without locks */

struct LazyMachState : public MachState {
		// Do the initial capture of the machine state.  This is meant to be 
		// as light weight as possible, as we may never need the state that 
		// we capture.  Thus to complete the process you need to call 
		// 'getMachState()', which finishes the process
	int captureState();		
		// compute the machine state of the processor as it will exist just 
		// after the return after at most'funCallDepth' number of functions.
        // if 'testFtn' is non-NULL, the return address is tested at each
        // return instruction encountered.  If this test returns non-NULL,
        // then stack walking stops (thus you can walk up to the point that the
        // return address matches some criteria

        // Normally this is called with funCallDepth=1 and testFtn = 0 so that 
        // it returns the state of the processor after the function that called 'captureState()'
	void getState(int funCallDepth=1, TestFtn testFtn=0);									

	friend void throwFromHelper(enum CorInfoException throwEnum, struct MachState* state);
	friend class HelperMethodFrame;
private:
	void*			 captureEbp;		// Ebp at the time of caputre
	void** 			 captureEsp;		// Esp at the time of capture
	unsigned __int8* captureEip;		// Eip at the time of capture
};

inline void MachState::getState(int funCallDepth, TestFtn testFtn) {
	((LazyMachState*) this)->getState(funCallDepth, testFtn);
}

// CAPUTURE_STATE captures just enough register state so that the state of the
// processor can be deterined just after the the routine that has CAPUTURE_STATE in
// it returns.  CAPUTURE_STATE comes in two flavors, depending of whether the
// routine it is in returns a value or not.  

    // This macro is for use in methods that have no return value
    // Note that the return is never taken, is is there for epilog walking
#define CAPTURE_STATE(machState)                            \
      if (machState.captureState()) return        

    // This macro is for use in methods that return a value
    // Note that the return is never taken, is is there for epilog walking
#define CAPTURE_STATE_RET(machState)                        \
      if (machState.captureState()) return(0)        

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\ifjitcompiler.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// -*- C++ -*-
#ifndef _IFJITCOMPILER_H_
#define _IFJITCOMPILER_H_
#include "FjitEncode.h"
/*****************************************************************************/

/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XX                                                                           XX
XX                            FJit.h                                         XX
XX                                                                           XX
XX   The functionality needed for the FJIT DLL.                              XX
XX                                                                           XX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
*/


class IFJitCompiler: public ICorJitCompiler {
public:
    virtual FJit_Encode* __stdcall getEncoder () = 0;
};

//@TODO: for now, are just passing this struct with a memcpy
//A compressed format needs to be defined and a compressor and a decompressor built.
struct Fjit_hdrInfo
{
    size_t              methodSize;
    unsigned short      methodFrame;      /* includes all save regs and security obj, units are sizeof(void*) */
    unsigned short      methodArgsSize;   /* amount to pop off in epilog */
    unsigned short      methodJitGeneratedLocalsSize; /* number of jit generated locals in method */
    unsigned char       prologSize;
    unsigned char       epilogSize;
    bool                hasThis;
	bool				EnCMode;		   /* has been compiled in EnC mode */
};

#define JIT_GENERATED_LOCAL_LOCALLOC_OFFSET 0
#define JIT_GENERATED_LOCAL_NESTING_COUNTER -1
#define JIT_GENERATED_LOCAL_FIRST_ESP       -2  // this - 2*[nestingcounter-1] = top of esp stack

//@TODO: move this define to a better place
#ifdef _X86_
#define MAX_ENREGISTERED 2
#endif

#ifdef _X86_
//describes the layout of the prolog frame in ascending address order
struct prolog_frame {
    unsigned nextFrame;
    unsigned returnAddress;
};

//describes the layout of the saved data in the prolog in ascending address order
struct prolog_data {
    unsigned enregisteredArg_2;     //EDX  
    unsigned enregisteredArg_1;     //ECX
    unsigned security_obj;
    unsigned callee_saved_esi;
};

#define prolog_bias 0-sizeof(prolog_data)

    /* tell where a register argument lives in the stack frame */
inline unsigned offsetOfRegister(unsigned regNum) {
    return(prolog_bias + offsetof(prolog_data, enregisteredArg_1) - regNum*sizeof(void*));
}

#endif //_X86_



//@TODO: properly define this for ia64
#ifdef _IA64_
#define MAX_ENREGISTERED 2
//describes the layout of the prolog frame in ascending address order
struct prolog_frame {
    unsigned nextFrame;
    unsigned returnAddress;
};

//describes the layout of the saved data in the prolog in ascending address order
struct prolog_data {
    unsigned enregisteredArg_2;     //EDX  
    unsigned enregisteredArg_1;     //ECX
    unsigned security_obj;
    unsigned callee_saved_esi;
};

#define prolog_bias 0-sizeof(prolog_data)

    /* tell where a register argument lives in the stack frame */
inline unsigned offsetOfRegister(unsigned regNum) {
    return(prolog_bias + offsetof(prolog_data, enregisteredArg_1) - regNum*sizeof(void*));
}

#endif //_IA64_



//@TODO: move this define to a better place
#ifdef _ALPHA_
#define MAX_ENREGISTERED 2
#endif

#ifdef _ALPHA_
//describes the layout of the prolog frame in ascending address order
struct prolog_frame {
    unsigned nextFrame;
    unsigned returnAddress;
};

//describes the layout of the saved data in the prolog in ascending address order
struct prolog_data {
    unsigned enregisteredArg_2;     //EDX  
    unsigned enregisteredArg_1;     //ECX
    unsigned security_obj;
    unsigned callee_saved_esi;
};

#define prolog_bias 0-sizeof(prolog_data)

    /* tell where a register argument lives in the stack frame */
inline unsigned offsetOfRegister(unsigned regNum) {
    _ASSERTE(!"@TODO Alpha - offsetOfRegister (IFjitCompiler.h)");
    return(prolog_bias + offsetof(prolog_data, enregisteredArg_1) - regNum*sizeof(void*));
}

#endif //_ALPHA_



#endif //_IFJITCOMPILER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS           VS_FF_DEBUG
#else
#define VER_FILEFLAGS           VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "MSCOREJT.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft COM Runtime Code Expander\0"
#define VER_ORIGFILENAME_STR    "mscorejt.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\x86fjit.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/*                                 x86fjit.h                              */
/***************************************************************************/

/* Defines the code generators and helpers for the fast jit for the x86 in
   32 bit mode. */

/* This file implements all of the macros needed for helper calls and
   the call/return/jmps and direct stack manipulations opcodes*/

/* Most of the I4 and U4 opcodes are redefined to generate direct code
   instead of helper calls. */

/* Locals are assigned 64 bits whether they need them or not to keep things
   simple. */

/* Values pushed on the stack take an integral number of 32 bit words (1 or 2)
   */

/* The top of stack may or may not be enregistered (EAX).  The boolean variable
   inRegTOS indicates whether the top 32 bits of the stack are in EAX.
   The macros enregisterTOS and deregisterTOS dynamically move and track the TOS.
   If the TOS is a 64 bit entitiy, and it is enregisterd, only the low order
   32 bits are in EAX, the rest is still on the machine stack.*/

/* AUTHOR: George Bosworth
   DATE:   6/15/98       */
/***************************************************************************/

/***************************************************************************
  The following macros are redefinitions for performance
***************************************************************************/
//#define SUPPORT_PRECISE_R
#ifndef _FJIT_PORT_BLD 
#define emit_mov_arg_stack(dest, src, size) x86_mov_arg_stack(dest, src, size)
#define emit_push_words(size) x86_push_words(size)

/* call/return */
#define emit_prolog(maxlocals, zeroCnt) x86_emit_prolog(maxlocals, zeroCnt)
#define emit_prepare_jmp() x86_emit_prepare_jmp()
#define emit_remove_frame() x86_emit_remove_frame()
#define emit_mov_TOS_arg(targetReg) x86_mov_TOS_arg(targetReg)
#define emit_mov_arg_reg(offset, reg) x86_mov_arg_reg(offset, reg)
#define emit_replace_args_with_operands(dest, src, size) x86_replace_args_with_operands(dest, src, size)
#define emit_return(argsSize) x86_emit_return(argsSize)
#define emit_loadresult_I4() x86_emit_loadresult_I4()
#define emit_loadresult_I8() x86_emit_loadresult_I8()
#define emit_callvirt(vt_offset) x86_callvirt(vt_offset)
#define emit_jmpvirt(vt_offset) x86_jmpvirt(vt_offset)
#define emit_callinterface(vt_offset, hint) x86_callinterface(vt_offset, hint)
#define emit_callinterface_new(ifctable_offset,interface_offset, vt_offset) x86_callinterface_new(ifctable_offset,interface_offset, vt_offset)
#define emit_calli() x86_calli
#define emit_jmpinterface(vt_offset, hint) x86_jmpinterface(vt_offset, hint)
#define emit_compute_interface_new(ifctable_offset,interface_offset, vt_offset) x86_compute_interface_new(ifctable_offset,interface_offset, vt_offset)
#define emit_jmpinterface_new(ifctable_offset,interface_offset, vt_offset) x86_jmpinterface_new(ifctable_offset,interface_offset, vt_offset)
#define emit_callnonvirt(ftnptr) x86_callnonvirt(ftnptr)
#define emit_ldvtable_address(hint,offset) x86_emit_ldvtable_address(hint,offset)
#define emit_ldvtable_address_new(ifctable_offset,interface_offset, vt_offset) x86_emit_ldvtable_address_new(ifctable_offset,interface_offset, vt_offset)

/* stack operations */
#define emit_testTOS() x86_testTOS

/* moves between memory */

/* relative jumps and misc*/
#define emit_jmp_absolute(address) x86_jmp_absolute(address)
#define emit_checkthis_nullreference() x86_checkthis_nullreference()  // this can be deleted

/* stack operations */
#define deregisterTOS x86_deregisterTOS
#define enregisterTOS x86_enregisterTOS
#define emit_POP_I4() x86_POP4
#define emit_POP_I8() x86_POP8
#define emit_drop(n) x86_drop(n)
#define emit_grow(n) x86_grow(n)
#define emit_getSP(offset) x86_getSP(offset)
#define emit_DUP_I4() x86_DUP4
#define emit_DUP_I8() x86_DUP8
#define emit_pushconstant_4(val) x86_pushconstant_4(val)
#define emit_pushconstant_8(val) x86_pushconstant_8(val)
#define emit_pushconstant_Ptr(val) x86_pushconstant_Ptr(val)


// Floating point instructions
#ifdef SUPPORT_PRECISE_R

#define emit_ADD_R4() x86_emit_ADD_R()
#define emit_ADD_R8() x86_emit_ADD_R()
#define emit_SUB_R4() x86_emit_SUB_R()
#define emit_SUB_R8() x86_emit_SUB_R()
#define emit_MUL_R4() x86_emit_MUL_R()
#define emit_MUL_R8() x86_emit_MUL_R()
#define emit_DIV_R4() x86_emit_DIV_R()
#define emit_DIV_R8() x86_emit_DIV_R()
//#define emit_REM_R4 x86_emit_REM_R()
//#define emit_REM_R8 x86_emit_REM_R()*/

#define emit_CEQ_R4() x86_emit_CEQ_R()
#define emit_CLT_R4() x86_emit_CLT_R()
#define emit_CLT_UN_R4() x86_emit_CLT_UN_R()
#define emit_CGT_R4() x86_emit_CGT_R()
#define emit_CGT_UN_R4() x86_emit_CGT_UN_R()
#define emit_CEQ_R8() x86_emit_CEQ_R()
#define emit_CLT_R8() x86_emit_CLT_R()
#define emit_CLT_UN_R8() x86_emit_CLT_UN_R()
#define emit_CGT_R8() x86_emit_CGT_R()
#define emit_CGT_UN_R8() x86_emit_CGT_UN_R()

#define emit_conv_R4toR emit_conv_R4toR8
#define emit_conv_R8toR x86_emit_conv_R8toR
#define emit_conv_RtoR4 emit_conv_R8toR4
#define emit_conv_RtoR8 x86_emit_conv_RtoR8
#endif

/* macros used to implement helper calls */
#define emit_LDVARA(offset) x86_LDVARA(offset)
#define emit_helperarg_1(val) x86_helperarg_1(val)
#define emit_helperarg_2(val) x86_helperarg_2(val)
//#define emit_callhelper(helper) x86_callhelper(helper)
#define emit_pushresult_I8() x86_pushresult_I8
#define emit_compute_invoke_delegate(obj, ftnptr) x86_compute_invoke_delegate(obj,ftnptr)
#define emit_invoke_delegate(obj, ftnptr) x86_invoke_delegate(obj,ftnptr)
#define emit_jmp_invoke_delegate(obj, ftnptr) x86_jmp_invoke_delegate(obj,ftnptr)
#define emit_set_zero(offset) x86_set_zero(offset)	    // mov [ESP+offset], 0
#define emit_LOCALLOC(initialized,EHcount) x86_LOCALLOC(initialized,EHcount)


/**************************************************************************
   call/return
**************************************************************************/

/* NOTE: any changes made in this macro need to be reflected in FJit_EETWain.cpp
         and in IFJitCompile.h */
#define x86_emit_prolog(locals, zeroCnt)                                        \
    x86_push(X86_EBP);                                              \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_EBP, X86_ESP));   \
    x86_push(X86_ESI);  /* callee saved, used by newobj and calli*/ \
    x86_barith(x86OpXor, x86Big, x86_mod_reg(X86_ESI, X86_ESI));    \
    x86_push(X86_ESI);  /* security obj == NULL */                  \
    x86_push(X86_ECX);  /* 1st enregistered arg */                  \
    x86_push(X86_EDX);  /* 2nd enregistered arg */                  \
    _ASSERTE(locals == zeroCnt);                      				\
    if (locals) {                                                   \
         x86_mov_reg_imm(x86Big, X86_ECX, locals);                 \
         int emitter_scratch_i4 = (unsigned int) outPtr;                \
         x86_push_imm(0);                                           \
         x86_loop();                                                \
         cmdByte(emitter_scratch_i4-((unsigned int) outPtr)-1);     \
    }

/* NOTE: any changes made in this macro need to be reflected in FJit_EETwain.cpp */
#define x86_emit_return(argsSize)                               \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_ESI, X86_EBP, 0-sizeof(void*))); \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_ESP,X86_EBP));\
    x86_pop(X86_EBP);                                           \
    x86_ret(argsSize)


/* NOTE: any changes made in this macro need to be reflected in FJit_EETwain.cpp */
#define x86_emit_prepare_jmp() \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_EDX, X86_EBP, 0-4*sizeof(void*))); \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_ECX, X86_EBP, 0-3*sizeof(void*)));  \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_ESI, X86_EBP, 0-sizeof(void*)));     \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_ESP,X86_EBP));\
    x86_pop(X86_EBP); 

#define x86_jmp_absolute(address) \
    x86_mov_reg_imm(x86Big, X86_EAX, address); \
    x86_jmp_reg(X86_EAX);

/* NOTE: any changes made in this macro need to be reflected in FJit_EETwain.cpp */
#define x86_emit_remove_frame() \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_ESI, X86_EBP, 0-sizeof(void*)));     \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_ESP,X86_EBP));\
    x86_pop(X86_EBP);


#define x86_mov_TOS_arg(reg)                \
    _ASSERTE(X86_ECX == reg+1 || X86_EDX == reg+1);\
    if (inRegTOS) {                         \
        x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(reg+1, X86_EAX));\
        inRegTOS = false;                   \
    }                                       \
    else {                                  \
        x86_pop(reg+1);                     \
    }

#define x86_mov_arg_reg(offset, reg)                \
    _ASSERTE(X86_ECX == reg+1 || X86_EDX == reg+1); \
    _ASSERTE(!inRegTOS);                             \
    x86_mov_reg(x86DirTo, x86Big,                   \
        x86_mod_base_scale_disp(reg+1, X86_ESP, X86_NO_IDX_REG, offset, 0))

#define x86_mov_arg_stack(dest, src, size)  {                                                           \
        _ASSERTE(!inRegTOS);                                                                             \
        _ASSERTE(size >= 4 );                                                                             \
        if (dest > src) \
        {               \
            int emitter_scratch_i4 = size-4;                                                       \
            while (emitter_scratch_i4 >=0) {                                                                \
                x86_mov_reg(x86DirTo, x86Big,                                                               \
                    x86_mod_base_scale_disp(X86_EAX, X86_ESP, X86_NO_IDX_REG, src+emitter_scratch_i4, 0));  \
                x86_mov_reg(x86DirFrom, x86Big,                                                             \
                    x86_mod_base_scale_disp(X86_EAX, X86_ESP, X86_NO_IDX_REG, dest+emitter_scratch_i4, 0)); \
                emitter_scratch_i4 -= 4;                                                                    \
            }                                                                                               \
        }               \
        else            \
        {               \
            unsigned int emitter_scratch_i4 = 0;                                                               \
            while (emitter_scratch_i4 <= (size-4)) {                                                           \
                x86_mov_reg(x86DirTo, x86Big,                                                               \
                    x86_mod_base_scale_disp(X86_EAX, X86_ESP, X86_NO_IDX_REG, src+emitter_scratch_i4, 0));  \
                x86_mov_reg(x86DirFrom, x86Big,                                                             \
                    x86_mod_base_scale_disp(X86_EAX, X86_ESP, X86_NO_IDX_REG, dest+emitter_scratch_i4, 0)); \
                emitter_scratch_i4 += 4;                                                                    \
            }                                                                                               \
        }                                                                                               \
    }

#define x86_replace_args_with_operands(dest, src, size) {                                               \
        _ASSERTE(!inRegTOS);                                                                             \
        int emitter_scratch_i4 = size-4;                                                                \
        while (emitter_scratch_i4 >=0) {                                                                \
            x86_mov_reg(x86DirTo, x86Big,                                                               \
                x86_mod_base_scale_disp(X86_EAX, X86_ESP, X86_NO_IDX_REG, src+emitter_scratch_i4, 0));  \
            x86_mov_reg(x86DirFrom, x86Big,                                                             \
                x86_mod_base_scale_disp(X86_EAX, X86_EBP, X86_NO_IDX_REG, dest+emitter_scratch_i4, 0)); \
            emitter_scratch_i4 -= 4;                                                                    \
        }                                                                                               \
    }

#define x86_emit_loadresult_I4()    \
    x86_enregisterTOS;          \
    inRegTOS = false

#define x86_emit_loadresult_I8()    \
    x86_enregisterTOS;          \
    x86_pop(X86_EDX);           \
    inRegTOS = false

#endif // _FJIT_PORT_BLD

#ifndef SUPPORT_PRECISE_R

#define x86_emit_loadresult_R4()    \
    x86_deregisterTOS;                \
    x86_FLT64(x86_mod_base_scale(x86_FPLoad64, X86_ESP, X86_NO_IDX_REG, 0)); \
    x86_barith_imm(x86OpAdd, x86Big, x86Extend, X86_ESP, 4 /*SIZE_PRECISE_R-SIZE_R4*/); \
	x86_FLT32(x86_mod_base_scale(x86_FPStoreP32, X86_ESP, X86_NO_IDX_REG, 0)); \
	x86_FLT32(x86_mod_base_scale(x86_FPLoad32, X86_ESP, X86_NO_IDX_REG, 0));

#define x86_emit_loadresult_R8()    \
    x86_deregisterTOS;                \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_EAX,X86_ESP)); \
    x86_FLD64(x86_mod_ind(X86_EAX,0) )

#define SIZE_R8 8
#define SIZE_R4 4

#define x86_emit_conv_R4toR8() \
    deregisterTOS; \
    x86_FLT32(x86_mod_base_scale(x86_FPLoad32, X86_ESP, X86_NO_IDX_REG, 0)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, 4 /*SIZE_R8-SIZE_R4*/); \
    x86_FLT64(x86_mod_base_scale(x86_FPStoreP64, X86_ESP, X86_NO_IDX_REG, 0));

#define x86_emit_conv_R8toR4() \
    deregisterTOS; \
    x86_FLT64(x86_mod_base_scale(x86_FPLoad64, X86_ESP, X86_NO_IDX_REG, 0)); \
    x86_barith_imm(x86OpAdd, x86Big, x86Extend, X86_ESP, 4 /*SIZE_PRECISE_R-SIZE_R4*/); \
    x86_FLT32(x86_mod_base_scale(x86_FPStoreP32, X86_ESP, X86_NO_IDX_REG, 0));

#define x86_narrow_R8toR4(stack_offset_dest, stack_offset_src) \
    x86_FLT64(x86_mod_base_scale_disp(x86_FPLoad64, X86_ESP, X86_NO_IDX_REG, stack_offset_src,0)); \
    x86_FLT32(x86_mod_base_scale_disp(x86_FPStoreP32, X86_ESP, X86_NO_IDX_REG, stack_offset_dest,0));


#define emit_LDIND_R4() \
	_ASSERTE(inRegTOS); /* address */\
    x86_FLT32(x86_mod_ind(x86_FPLoad32,X86_EAX)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_R8); \
    x86_FLT64(x86_mod_base_scale(x86_FPStoreP64, X86_ESP, X86_NO_IDX_REG, 0)); \
	inRegTOS = false;
#endif 

#ifndef _FJIT_PORT_BLD
#define x86_callvirt(vt_offset)                     \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind(X86_EAX, X86_ECX));   \
    x86_call_ind(X86_EAX, vt_offset)

#define x86_jmpvirt(vt_offset)                      \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind(X86_EAX, X86_ECX));   \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,vt_offset));    \
    x86_jmp_reg(X86_EAX)

#define x86_checkthis_nullreference() \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind(X86_EAX, X86_ECX));


#define x86_calli                       \
    enregisterTOS;                      \
    x86_call_reg(X86_EAX); \
    inRegTOS = false; 

#define x86_emit_ldvtable_address(hint,offset) \
    _ASSERTE(inRegTOS); \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_ECX, X86_EAX)); \
    x86_mov_reg_imm(x86Big, X86_EAX,hint);                      \
    x86_push(X86_EAX);                              \
    x86_call_ind(X86_EAX, 0);                       \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,offset)); \
    inRegTOS = true;

#define x86_emit_ldvtable_address_new(ifctable_offset,interface_offset, vt_offset) \
    _ASSERTE(inRegTOS); \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind(X86_EAX, X86_EAX));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,ifctable_offset));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,interface_offset));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,vt_offset)); 

#define x86_callinterface(vt_offset, hint)          \
    x86_pushconstant_4(hint);                       \
    x86_push(X86_EAX);                              \
    inRegTOS = false;                               \
    x86_call_ind(X86_EAX, 0);                       \
    x86_call_ind(X86_EAX, vt_offset)

#define x86_callinterface_new(ifctable_offset,interface_offset, vt_offset)          \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind(X86_EAX, X86_ECX));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,ifctable_offset));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,interface_offset));                       \
    x86_call_ind(X86_EAX, vt_offset)

#define x86_compute_interface_new(ifctable_offset,interface_offset, vt_offset)           \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind(X86_EAX, X86_ECX));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,ifctable_offset));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,interface_offset));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,vt_offset)); \
    x86_push(X86_EAX)

#define x86_jmpinterface(vt_offset, hint)           \
    x86_pushconstant_4(hint);                       \
    x86_push(X86_EAX);                              \
    inRegTOS = false;                               \
    x86_call_ind(X86_EAX, 0);                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,vt_offset)); \
    x86_jmp_reg(X86_EAX)

#define x86_jmpinterface_new(ifctable_offset,interface_offset, vt_offset)           \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind(X86_EAX, X86_ECX));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,ifctable_offset));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,interface_offset));                       \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,vt_offset)); \
    x86_jmp_reg(X86_EAX)

#define x86_callnonvirt(ftnptr)                 \
    x86_mov_reg_imm(x86Big, X86_EAX, ftnptr);   \
    x86_call_ind(X86_EAX, 0)

#define x86_compute_invoke_delegate(obj,ftnptr)                 \
    x86_mov_reg(x86DirTo,x86Big,x86_mod_ind_disp(X86_EAX, X86_ECX, ftnptr));    \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_ECX, X86_ECX,obj));   \
    x86_push(X86_EAX)

#define x86_invoke_delegate(obj,ftnptr)                 \
    x86_lea(x86_mod_ind_disp(X86_EAX, X86_ECX, ftnptr));    \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_ECX, X86_ECX,obj));   \
    x86_call_ind(X86_EAX, 0)

#define x86_jmp_invoke_delegate(obj,ftnptr)                 \
    x86_mov_reg(x86DirTo,x86Big,x86_mod_ind_disp(X86_EAX, X86_ECX, ftnptr));    \
    x86_mov_reg(x86DirTo,x86Big, x86_mod_ind_disp(X86_ECX, X86_ECX,obj));   \
    x86_jmp_reg(X86_EAX)

/****************************************************************************
   stack operations
****************************************************************************/
#endif //_FJIT_PORT_BLD

#define x86_deregisterTOS   \
    if (inRegTOS){          \
        x86_push(X86_EAX);  \
    }                       \
    inRegTOS = false

#define x86_enregisterTOS   \
    if (!inRegTOS) {        \
        x86_pop(X86_EAX);   \
    }     \
    inRegTOS = true

#ifndef _FJIT_PORT_BLD
#define x86_POP4        \
    enregisterTOS;      \
    inRegTOS = false

#define x86_POP8            \
    x86_POP4;               \
    x86_POP4

// drop(n) drops n bytes from the stack w/o losing any prior result not yet pushed onto the stack
#define x86_drop(n)                                                     \
    if (n) {                                                            \
        if (n < 128) {                                                  \
            x86_barith_imm(x86OpAdd, x86Big, x86Extend, X86_ESP, n);    \
        }                                                               \
        else {                                                          \
            x86_barith_imm(x86OpAdd, x86Big, x86NoExtend, X86_ESP, n);  \
        }                                                               \
    }


// adds n bytes to the stack (inverse of drop(n))
#define x86_grow(n)                                                     \
    if (n) {                                                            \
        if (n < 128) {                                                  \
            x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, n);    \
        }                                                               \
        else {                                                          \
           int i = n;                                                  \
            while (i > PAGE_SIZE)  {                                    \
                x86_barith_imm(x86OpSub, x86Big, x86NoExtend, X86_ESP, PAGE_SIZE);  \
                x86_mov_reg(x86DirTo, x86Big,x86_mod_base_scale(X86_EDI, X86_ESP,X86_NO_IDX_REG,0)); \
                i -= PAGE_SIZE;                                         \
            }                                                           \
            if (i)                                                      \
                x86_barith_imm(x86OpSub, x86Big, x86NoExtend, X86_ESP,i); \
        }                                                               \
    }

// push a pointer pointing 'n' bytes back in the stack
#define x86_getSP(n)												    \
	deregisterTOS;														\
	if (n == 0)															\
	    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_EAX, X86_ESP));	\
	else																\
		x86_lea(x86_mod_base_scale_disp(X86_EAX, X86_ESP, X86_NO_IDX_REG, n, 0));   \
    inRegTOS = true; 


#define x86_DUP4                    \
    enregisterTOS;                  \
    x86_push(X86_EAX)

#define x86_DUP8                    \
    x86_DUP4;                       \
    x86_mov_reg(x86DirTo, x86Big,                                           \
        x86_mod_base_scale_disp(X86_EDX, X86_ESP, X86_NO_IDX_REG, 4, 0));   \
    x86_push(X86_EDX)

#define x86_pushconstant_4(val)                                     \
    deregisterTOS;                                                  \
    if ((unsigned int) val) {                                       \
        x86_mov_reg_imm(x86Big, X86_EAX,(unsigned int) val);        \
    }                                                               \
    else {                                                          \
        x86_barith(x86OpXor, x86Big, x86_mod_reg(X86_EAX, X86_EAX));\
    }                                                               \
    inRegTOS = true

#define x86_pushconstant_8(val) {                               \
    deregisterTOS;                                              \
    int emitter_scratch_i4 = (int) ((val >> 32) & 0xffffffff);  \
    x86_pushconstant_4(emitter_scratch_i4);                     \
    deregisterTOS;                                              \
    emitter_scratch_i4 = (int) (val & 0xffffffff);              \
    x86_pushconstant_4(emitter_scratch_i4);                     \
    inRegTOS = true;                                            \
    }

#define x86_pushconstant_Ptr(val)       \
    emit_WIN32(x86_pushconstant_4(val)) \
    emit_WIN64(x86_pushconstant_8(val))

#define x86_testTOS     \
    enregisterTOS;      \
    inRegTOS = false;   \
    x86_test(x86Big, x86_mod_reg(X86_EAX, X86_EAX))


#define x86_LOCALLOC(initialized,EHcount)  \
    enregisterTOS;      \
    x86_test(x86Big, x86_mod_reg(X86_EAX, X86_EAX)); \
	x86_jmp_cond_small(x86CondEq); \
	{ \
		BYTE* emitter_scratch_1; emitter_scratch_1 = outPtr; \
		outPtr++; \
		emit_WIN32(x86_barith_imm(x86OpAdd, x86Big, x86Extend, X86_EAX, 3)); \
		emit_WIN64(x86_barith_imm(x86OpAdd, x86Big, x86Extend, X86_EAX, 7)); \
		if (initialized) { \
			x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_ECX, X86_EAX));   \
			emit_WIN32(x86_shift_imm(x86ShiftArithRight, X86_ECX, 2)) ; \
			emit_WIN64(x86_shift_imm(x86ShiftArithRight, X86_ECX, 3)) ; \
			int emitter_scratch_i4 = (unsigned int) outPtr;                \
			x86_push_imm(0);                                           \
			x86_loop();                                                \
			cmdByte(emitter_scratch_i4-((unsigned int) outPtr)-1);     \
		} \
		else { /*not initialized, so stack must be grown a page at a time*/  \
			_ASSERTE(!"NYI");                                          \
		} \
		*emitter_scratch_1 = (BYTE) (outPtr - emitter_scratch_1 -1); \
	}\
    /* also store the esp in the appropriate JitGenerated local slot, to support GC reporting */ \
if (EHcount) { \
        x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_EAX, X86_EBP, (prolog_bias-2*sizeof(void*)))) ; \
	    emit_WIN32(x86_shift_imm(x86ShiftLeft,X86_EAX,3)); \
	    emit_WIN64(x86_shift_imm(x86ShiftLeft,X86_EAX,4)); \
		x86_lea(x86_mod_ind_disp(X86_ECX, X86_EBP, (prolog_bias-2*sizeof(void*))));		\
		x86_barith(x86OpSub,  x86Big, x86_mod_reg(X86_ECX, X86_EAX));  \
		x86_mov_reg(x86DirFrom, x86Big, x86_mod_ind_disp(X86_ESP, X86_ECX,sizeof(void*))) ; \
} \
    else { \
        x86_mov_reg(x86DirFrom, x86Big, x86_mod_ind_disp(X86_ESP, X86_EBP,(prolog_bias-sizeof(void*)))) ; \
}\
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_EAX, X86_ESP)) ;


/************************************************************************
    Support for handling gc support in methods with localloc and EH
*************************************************************************/
// JitGenerated locals start at ebp+prolog_bias
// the layout is the following
// typedef struct {
//      locallocSize (in machine words)
//      [esp at start of outermost handler/finally/filter
//       locallocSize for the handler/finally/filter]*
//      ...
//      marker = 0  / indicates end of JitGenerated local region

#define emit_storeTOS_in_JitGenerated_local(nestingLevel,isFilter) \
    x86_mov_reg_imm(x86Big, X86_EDX, nestingLevel); \
	x86_mov_reg(x86DirFrom, x86Big, x86_mod_ind_disp(X86_EDX, X86_EBP, (prolog_bias-2*sizeof(void*)))) ; \
    if (isFilter) { \
        x86_lea(x86_mod_base_scale_disp8(X86_EDX, X86_ESP,X86_NO_IDX_REG, 1, 1));       \
        x86_mov_reg(x86DirFrom, x86Big, x86_mod_ind_disp(X86_EDX, X86_EBP,(prolog_bias-2*(1+nestingLevel)*sizeof(void*)+sizeof(void*)))) ;  \
    } \
    else { \
       x86_mov_reg(x86DirFrom, x86Big, x86_mod_ind_disp(X86_ESP, X86_EBP,(prolog_bias-2*(1+nestingLevel)*sizeof(void*)+sizeof(void*))));  \
    }

#define emit_reset_storedTOS_in_JitGenerated_local() \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_EDX, X86_EBP, (prolog_bias-2*sizeof(void*)))) ; \
    x86_inc_dec(1,X86_EDX); \
    x86_mov_reg(x86DirFrom, x86Big, x86_mod_ind_disp(X86_EDX, X86_EBP, (prolog_bias-2*sizeof(void*)))) ; \
    x86_lea(x86_mod_ind_disp(X86_ECX, X86_EBP, (prolog_bias-2*sizeof(void*))));     \
    emit_WIN32(x86_shift_imm(x86ShiftLeft,X86_EDX,3)); \
    emit_WIN64(x86_shift_imm(x86ShiftLeft,X86_EDX,4)); \
    x86_barith(x86OpSub,  x86Big, x86_mod_reg(X86_ECX, X86_EDX));  \
    x86_barith(x86OpXor,  x86Big, x86_mod_reg(X86_EDX, X86_EDX));  \
    x86_mov_reg(x86DirFrom, x86Big, x86_mod_ind_disp(X86_EDX, X86_ECX, (0-  sizeof(void*)))) ;   \
    x86_mov_reg(x86DirFrom, x86Big, x86_mod_ind_disp(X86_EDX, X86_ECX, (0-2*sizeof(void*)))) ;


/***************************************************************************
   relative jumps
****************************************************************************/
#define x86_jmp_address(pcrel)  \
    cmdDWord(pcrel)

#define x86_load_opcode     \
    cmdByte(expOr2(expNum(0xB0 | (x86Big << 3)), X86_EAX))

#endif // _FJIT_PORT_BLD
#define x86_jmp_result      \
    x86_jmp_reg(X86_EAX)

#ifndef _FJIT_PORT_BLD
/************************************************************************************
  x86 specific helper call emitters
************************************************************************************/

#define x86_LDVARA(offset)   \
    deregisterTOS;                                                  \
    x86_lea(x86_mod_ind_disp(X86_EAX, X86_EBP, offset));        \
    inRegTOS = true

/* load the constant val as the first helper arg (ecx) */
#define x86_helperarg_1(val)            \
    if (val) {                                                      \
        x86_mov_reg_imm(x86Big, X86_ECX,(unsigned int) val);        \
    }                                                               \
    else {                                                          \
        x86_barith(x86OpXor, x86Big, x86_mod_reg(X86_ECX, X86_ECX));\
    }

/* load the constant val as the second helper arg (edx) */
#define x86_helperarg_2(val)            \
    if (val) {                                                      \
        x86_mov_reg_imm(x86Big, X86_EDX,(unsigned int) val);        \
    }                                                               \
    else {                                                          \
        x86_barith(x86OpXor, x86Big, x86_mod_reg(X86_EDX, X86_EDX));\
    }

#define x86_callhelper(helper)  \
    deregisterTOS;                  \
    x86_call((unsigned int) helper)

#define x86_callhelper_using_register(helper,REG)  \
    deregisterTOS;                  \
    x86_mov_reg_imm(x86Big, REG,(unsigned int) helper); \
    x86_call_reg(REG)

#define x86_pushresult_I8   \
    x86_push(X86_EDX);      \
    inRegTOS = true

#endif //_FJIT_PORT_BLD

#ifndef SUPPORT_PRECISE_R
#define x86_pushresult_R4   \
	x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, 8); \
    x86_FLT64(x86_mod_base_scale(x86_FPStoreP64, X86_ESP, X86_NO_IDX_REG, 0));

#define x86_pushresult_R8   \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, 8); \
    x86_FLT64(x86_mod_base_scale(x86_FPStoreP64, X86_ESP, X86_NO_IDX_REG, 0));
#endif

#define x86_SWITCH(limit) \
    emit_callhelper_(SWITCH_helper); \
    x86_jmp_result; 
#ifdef DECLARE_HELPERS
__declspec (naked) void SWITCH_helper()
{
    
    __asm {
        pop   eax       // return address
        pop   ecx       // limit
        pop   edx       // index
        push  eax
        cmp   edx, ecx  
        jbe   L1
        mov   edx, ecx
L1:     lea   edx, [edx*4+edx+2]        // +2 is the size of the "jmp eax" instruction just before the switch table
                                        // this is being done only for the convenience of the debugger, which 
                                        // currently cannot handle functions that do a jmp out.
        add   eax, edx  // since eax+edx*5 is not allowed
        ret
    }
}
#endif
/************************************************************************************
  Miscellaneous
************************************************************************************/
#define x86_TlsFieldAddress(tlsOffset, tlsIndex, fieldOffset) \
    x86_deregisterTOS; \
    x86_mov_segment_reg(x86DirFrom, x86Big, X86_FS_Prefix,tlsOffset); \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_EAX, X86_EAX,sizeof(void*)*tlsIndex)); \
    if (fieldOffset) \
    { \
        if (fieldOffset < 128) \
        { \
            x86_barith_imm(x86OpAdd, x86Big, x86Extend, X86_EAX, fieldOffset); \
        } \
        else \
        { \
            x86_barith_imm(x86OpAdd,  x86Big, x86NoExtend, X86_EAX, fieldOffset); \
        } \
    } \
    inRegTOS = true;

#define x86_break() \
    emit_callhelper_(BREAK_helper); 
#ifdef DECLARE_HELPERS
void HELPER_CALL BREAK_helper()
{
    __asm int 3
}
#endif
/************************************************************************************
 support for new obj adn calli, since TOS needs to be saved while building a call
************************************************************************************/
#ifndef _FJIT_PORT_BLD
#define x86_save_TOS                                                \
    (inRegTOS ?                                                     \
        x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_ESI, X86_EAX))\
    :                                                               \
        x86_pop(X86_ESI))

#define x86_restore_TOS                                             \
    deregisterTOS; \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_EAX, X86_ESI));   \
    inRegTOS = true;                                                \
    x86_barith(x86OpXor, x86Big, x86_mod_reg(X86_ESI, X86_ESI))

/************************************************************************************
  x86 specific IL emitters for I4 and U4 (optional)
  The following macros are redefinitions done for performance
************************************************************************************/


#undef  emit_LDIND_I4
#define emit_LDIND_I4()								 						    \
    enregisterTOS;														        \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind(X86_EAX, X86_EAX));				

#undef  emit_LDVAR_I4
#define emit_LDVAR_I4(offset)                   \
    deregisterTOS;                              \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_ind_disp(X86_EAX, X86_EBP, offset)); \
    inRegTOS = true

#undef  emit_STVAR_I4
#define emit_STVAR_I4(offset)                   \
    enregisterTOS;                              \
    x86_mov_reg(x86DirFrom, x86Big, x86_mod_ind_disp(X86_EAX, X86_EBP, offset));  \
    inRegTOS = false

#undef  emit_ADD_I4
#define emit_ADD_I4()       \
    enregisterTOS;      \
    x86_pop(X86_ECX);       \
    x86_barith(x86OpAdd, x86Big, x86_mod_reg(X86_EAX, X86_ECX));    \
    inRegTOS = true

#undef  emit_SUB_I4
#define emit_SUB_I4()       \
    enregisterTOS;      \
    x86_pop(X86_ECX);       \
    x86_barith(x86OpSub, x86Big, x86_mod_reg(X86_ECX, X86_EAX));    \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_EAX, X86_ECX));  \
    inRegTOS = true

#undef  emit_MUL_I4
#define emit_MUL_I4()       \
    enregisterTOS;      \
    x86_pop(X86_ECX);       \
    x86_uarith(x86OpIMul, x86Big, X86_ECX); \
    inRegTOS = true


#undef emit_DIV_I4
#define emit_DIV_I4()                                                   \
    enregisterTOS;  /* divisor */                                   \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_ECX, X86_EAX));   \
    x86_pop(X86_EAX); /*dividend */                                 \
    x86_mov_reg(x86DirTo, x86Big, x86_mod_reg(X86_EDX, X86_EAX));   \
    x86_shift_imm(x86ShiftArithRight, X86_EDX, 31);                 \
    x86_uarith(x86OpIDiv, x86Big, X86_ECX);                         \
    inRegTOS = true;


#undef  emit_OR_U4
#define emit_OR_U4()        \
    enregisterTOS;      \
    x86_pop(X86_ECX);       \
    x86_barith(x86OpOr, x86Big, x86_mod_reg(X86_EAX, X86_ECX)); \
    inRegTOS = true

#undef  emit_AND_U4
#define emit_AND_U4()       \
    enregisterTOS;      \
    x86_pop(X86_ECX);       \
    x86_barith(x86OpAnd, x86Big, x86_mod_reg(X86_EAX, X86_ECX));    \
    inRegTOS = true

#undef  emit_XOR_U4
#define emit_XOR_U4()       \
    enregisterTOS;      \
    x86_pop(X86_ECX);       \
    x86_barith(x86OpXor, x86Big, x86_mod_reg(X86_EAX, X86_ECX));    \
    inRegTOS = true

#undef  emit_NOT_U4
#define emit_NOT_U4()                           \
    enregisterTOS;                          \
    x86_uarith(x86OpNot, x86Big, X86_EAX);  \
    inRegTOS = true

#undef  emit_NEG_I4
#define emit_NEG_I4()                           \
    enregisterTOS;                          \
    x86_uarith(x86OpNeg, x86Big, X86_EAX);  \
    inRegTOS = true

#undef  emit_compareTOS_I4
#define emit_compareTOS_I4()        \
    enregisterTOS;      \
    x86_pop(X86_ECX);       \
    x86_barith(x86OpCmp, x86Big, x86_mod_reg(X86_ECX, X86_EAX));  \
    inRegTOS = false

#undef  emit_CONV_TOU8_I4
#define emit_CONV_TOU8_I4()                                         \
    enregisterTOS;                                                  \
    x86_barith(x86OpXor, x86Big, x86_mod_reg(X86_EDX, X86_EDX));    \
    x86_push(X86_EDX);                                              \
    inRegTOS = true

#undef  emit_CEQ_I4
#define emit_CEQ_I4() \
    enregisterTOS; \
    x86_pop(X86_ECX);  \
    x86_barith(x86OpCmp,x86Big, x86_mod_reg(X86_EAX, X86_ECX)); \
    x86_set_cond(X86_EAX, x86CondEq); \
    x86_movzx(x86Byte,x86_mod_reg(X86_EAX,X86_EAX))

/************************************************************************************
  x86 specific IL emitters for REF (optional)
  The following macros are redefinitions done for performance
************************************************************************************/
#undef  emit_STELEM_REF
#define emit_STELEM_REF()                   \
    x86_enregisterTOS;  /* array */     \
    x86_pop(X86_EDX);   /* index */     \
    x86_pop(X86_ECX);   /* ref   */     \
    x86_deregisterTOS;                  \
	LABELSTACK((outPtr-outBuff), 3);   \
    emit_callhelper_il(FJit_pHlpArrAddr_St)

#undef emit_STFLD_REF
#define emit_STFLD_REF(isStatic)                    \
    if (!isStatic) {x86_STFLD_REF();}                 \
    else {x86_STSFLD_REF();}

#ifdef NON_RELOCATABLE_CODE
#define HELPER_CALL_JMP_OFFSET_1 0x05
#else
#define HELPER_CALL_JMP_OFFSET_1 0x07
#endif

//@TODO: should use a generic helper call that does the check for NULL and the assign, but it doesn't exist yet
#define x86_STFLD_REF()   {                           \
        _ASSERTE(inRegTOS); \
        x86_mov_reg(x86DirTo,x86Big,x86_mod_reg(X86_EDX,X86_EAX)); /*offset*/\
        inRegTOS = false; \
		LABELSTACK((outPtr-outBuff),0); \
        x86_pop(X86_EAX); /*value*/                                       \
        x86_pop(X86_ECX); /*obj*/                                      \
        x86_test(x86Big, x86_mod_reg(X86_ECX, X86_ECX));        \
        x86_jmp_cond_small(x86CondNotEq);                       \
        cmdByte(HELPER_CALL_JMP_OFFSET_1); /* jmp around the helper call */         \
        int emitter_scratch_i4 = (unsigned int) outPtr;         \
        _ASSERTE(CORINFO_NullReferenceException == 0);              \
        /* ecx=0, we can skip next */                           \
        /* x86_helperarg_1(0);  */                              \
        emit_callhelper_il(FJit_pHlpInternalThrow);                 \
        _ASSERTE((unsigned int) outPtr - emitter_scratch_i4 == HELPER_CALL_JMP_OFFSET_1);\
        x86_barith(x86OpAdd,x86Big, x86_mod_reg(X86_EDX, X86_ECX));  /* EDX = obj + offset */  \
        x86_callhelper_using_register(FJit_pHlpAssign_Ref_EAX,X86_ECX);                \
    }


#define x86_STSFLD_REF()         \
    _ASSERTE(inRegTOS); \
    x86_mov_reg(x86DirTo,x86Big,x86_mod_reg(X86_EDX,X86_EAX)); \
    x86_pop(X86_EAX);                              \
    inRegTOS = false;                           \
    x86_callhelper_using_register(FJit_pHlpAssign_Ref_EAX,X86_ECX) //x86_mov_reg(x86DirFrom, x86Big, x86_mod_ind(X86_EAX, X86_EDX))


/********************************************************************/




#define x86_push_words(size)  \
    if (inRegTOS) { \
        x86_mov_reg(x86DirTo,x86Big,x86_mod_reg(X86_ESI,X86_EAX)); \
		inRegTOS = false;											\
    } \
    else { x86_pop(X86_ESI); } \
    x86_mov_reg_imm(x86Big,X86_ECX,size);                       \
    x86_grow(size*4);                                            \
    x86_mov_reg(x86DirTo,x86Big,x86_mod_reg(X86_EDX,X86_EDI));    \
    x86_mov_reg(x86DirTo,x86Big,x86_mod_reg(X86_EDI,X86_ESP));    \
    cmdByte(0xF3);                                                 \
    cmdByte(0xA5);                                                  \
    x86_mov_reg(x86DirTo,x86Big,x86_mod_reg(X86_EDI,X86_EDX));    \
    x86_barith(x86OpXor, x86Big, x86_mod_reg(X86_ESI, X86_ESI));


    // Set the void* pointer at 'offset' from SP to zero,
    // TODO, I can do this in one instruction on the X86.  
#define x86_set_zero(offset)  {                                                \
    _ASSERTE(!inRegTOS); /* I trash EAX */                                     \
    x86_barith(x86OpXor, x86Big, x86_mod_reg(X86_EAX, X86_EAX));               \
    x86_mov_reg(x86DirFrom, x86Big,                                            \
        x86_mod_base_scale_disp(X86_EAX, X86_ESP, X86_NO_IDX_REG, (offset), 0)); \
    }



/********************************************************************/
#ifdef SUPPORT_PRECISE_R

#define SIZE_PRECISE_R 0xc

// conversions between R4/R8 and R
#define x86_emit_conv_R4toR() \
    deregisterTOS; \
    x86_FLT32(x86_mod_base_scale(x86_FPLoad32, X86_ESP, X86_NO_IDX_REG, 0)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, (SIZE_PRECISE_R-SIZE_R4)); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));

#define x86_emit_conv_R8toR() \
    deregisterTOS; \
    x86_FLT64(x86_mod_base_scale(x86_FPLoad64, X86_ESP, X86_NO_IDX_REG, 0)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, (SIZE_PRECISE_R-SIZE_R8)); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));

#define x86_emit_conv_RtoR4() \
    deregisterTOS; \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG, 0)); \
    x86_barith_imm(x86OpAdd, x86Big, x86Extend, X86_ESP, (SIZE_PRECISE_R-SIZE_R4)); \
    x86_FLT32(x86_mod_base_scale(x86_FPStoreP32, X86_ESP, X86_NO_IDX_REG, 0));
#define x86_emit_conv_RtoR8() \
    deregisterTOS; \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG, 0)); \
    x86_barith_imm(x86OpAdd, x86Big, x86Extend, X86_ESP, (SIZE_PRECISE_R-SIZE_R8)); \
    x86_FLT64(x86_mod_base_scale(x86_FPStoreP64, X86_ESP, X86_NO_IDX_REG, 0));

#define emit_LDC_R8(val)            \
    emit_pushconstant_8(val);\
    x86_emit_conv_R8toR();
 
//load/store locals and args
#define emit_LDVAR_R4(offset) \
    deregisterTOS; \
    x86_FLT32(x86_mod_ind_disp(x86_FPLoad32,X86_EBP,offset)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));

#define emit_LDVAR_R8(offset) \
    deregisterTOS; \
    x86_FLT64(x86_mod_ind_disp(x86_FPLoad64,X86_EBP,offset)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));

#define emit_STVAR_R4(offset) \
    deregisterTOS; \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG, 0));\
    x86_FST32(x86_mod_ind_disp(x86_FPStoreP32,X86_EBP,offset)); \
    x86_barith_imm(x86OpAdd,x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R); 

#define emit_STVAR_R8(offset) \
    deregisterTOS; \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG, 0));\
    x86_FST64(x86_mod_ind_disp(x86_FPStoreP64,X86_EBP,offset)); \
    x86_barith_imm(x86OpAdd,x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R); 


// load/store indirect
#define emit_LDIND_R4() \
    x86_FLT32(x86_mod_ind(x86_FPLoad32,X86_EAX)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R-sizeof(void*)); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));

#define emit_LDIND_R8() \
    x86_FLT64(x86_mod_ind(x86_FPLoad64,X86_EAX)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R-sizeof(void*)); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));


#define emit_STIND_R4()     \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG ,0)); \
    x86_mov_reg(x86DirTo, x86Big, \
            x86_mod_base_scale_disp8(X86_EAX, X86_ESP, X86_NO_IDX_REG,SIZE_R4,0)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R+sizeof(void*)); \
    x86_FLT32(x86_mod_ind(x86_FPStoreP32, X86_EAX)); 

#define emit_STIND_R8()     \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG ,0)); \
    x86_mov_reg(x86DirTo, x86Big, \
            x86_mod_base_scale_disp8(X86_EAX, X86_ESP, X86_NO_IDX_REG,SIZE_R8,0)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R+sizeof(void*)); \
    x86_FLT64(x86_mod_ind(x86_FPStoreP64, X86_EAX)); 


#define emit_STIND_REV_R4()     \
    x86_FLT80(x86_mod_base_scale_disp8(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG,SIZE_R4 ,0)); \
    x86_mov_reg(x86DirTo, x86Big, \
            x86_mod_base_scale(X86_EAX, X86_ESP, X86_NO_IDX_REG,0)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R+sizeof(void*)); \
    x86_FLT32(x86_mod_ind(x86_FPStoreP32, X86_EAX)); 

#define emit_STIND_REV_R8()     \
    x86_FLT80(x86_mod_base_scale_disp8(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG,SIZE_R8 ,0)); \
    x86_mov_reg(x86DirTo, x86Big, \
            x86_mod_base_scale(X86_EAX, X86_ESP, X86_NO_IDX_REG,0)); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R+sizeof(void*)); \
    x86_FLT64(x86_mod_ind(x86_FPStoreP64, X86_EAX)); 

    
// returning floats from a method

#define x86_emit_loadresult_R4()    \
    x86_deregisterTOS;                \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG, 0));\
    x86_barith_imm(x86OpAdd,x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R-SIZE_R4); \
    x86_FLT32(x86_mod_base_scale(x86_FPStore32,X86_ESP, X86_NO_IDX_REG, 0)); 

#define x86_emit_loadresult_R8()    \
    x86_deregisterTOS;                \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG, 0));\
    x86_barith_imm(x86OpAdd,x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R-SIZE_R8); \
    x86_FLT64(x86_mod_base_scale(x86_FPStore64,X86_ESP, X86_NO_IDX_REG, 0)); 

// loading results from jit helpers 
#define x86_pushresult_R   \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R); \
    x86_barith_imm(x86OpSub, x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80,X86_ESP, X86_NO_IDX_REG, 0)); 

#define x86_pushresult_R8  x86_pushresult_R
#define x86_pushresult_R4  x86_pushresult_R

// Arithmetic operations (add, sub, mul, div, rem)
#define x86_emit_FltBinOp_Common() \
    deregisterTOS;    \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG, 0));\
    x86_barith_imm(x86OpAdd,x86Big, x86Extend, X86_ESP, SIZE_PRECISE_R); \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG, 0));  

#define x86_emit_ADD_R() \
    x86_emit_FltBinOp_Common(); \
    x86_FltAddP(); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));

#define x86_emit_SUB_R() \
    x86_emit_FltBinOp_Common(); \
    x86_FltSubP(); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));

#define x86_emit_MUL_R() \
    x86_emit_FltBinOp_Common(); \
    x86_FltMulP(); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));

#define x86_emit_DIV_R() \
    x86_emit_FltBinOp_Common(); \
    x86_FltDivP(); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));

// @TODO: FltRem

#define x86_emit_NEG_R() \
    deregisterTOS;    \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG, 0));\
    x86_FltToggleSign(); \
    x86_FLT80(x86_mod_base_scale(x86_FPStoreP80, X86_ESP, X86_NO_IDX_REG, 0));

// Comparison operations (ceq, cne, clt, cgt, etc.)
#define x86_emit_Compare_R_Common() \
    deregisterTOS;    \
    /*x86_barith(x86OpXor, x86Big, x86_mod_reg(X86_EAX, X86_EAX)); */   \
    x86_FLT80(x86_mod_base_scale(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG, 0));\
    x86_FLT80(x86_mod_base_scale_disp8(x86_FPLoad80, X86_ESP, X86_NO_IDX_REG,SIZE_PRECISE_R ,0));\
    x86_barith_imm(x86OpAdd,x86Big, x86Extend, X86_ESP, (2*SIZE_PRECISE_R)); \
    x86_FltComPP()\
    x86_FltStoreStatusWord(); \
    x86_SAHF();

typedef struct {
    BYTE   x[12];
    } PRECISE_REAL;


#define PUSH_ENCODING_LENGTH 2
#define JCC_SMALL_ENCODING_LENGTH 2

#define JMP_OFFSET_2 PUSH_ENCODING_LENGTH
#define JMP_OFFSET_1 JCC_SMALL_ENCODING_LENGTH + JMP_OFFSET_2

#define x86_emit_CEQ_R() \
    x86_emit_Compare_R_Common() \
    x86_jmp_cond_small(x86CondNotEq); /* if ZF=0, fail*/ \
    cmdByte(JMP_OFFSET_FAIL2); \
    /* else, ZF=1, but check either PF or CF also */ \
    x86_jmp_cond_small(x86CondParityEven); /* if PF = 1, fail*/\
    cmdByte(JMP_OFFSET_FAIL1); \
    x86_push_imm(1);    \
    x86_jmp_small(); \
    cmdByte(JMP_OFFSET_2); \
    x86_push_imm(0); 

#define x86_emit_CLT_UN_R() \
    x86_emit_Compare_R_Common() \
    x86_jmp_cond_small(x86CondBelow); \
    cmdByte(JMP_OFFSET_1); \
    x86_push_imm(0);    \
    x86_jmp_small(); \
    cmdByte(JMP_OFFSET_2); \
    x86_push_imm(1); 

#define JMP_OFFSET_FAIL1 JMP_OFFSET_1
#define JMP_OFFSET_FAIL2 JMP_OFFSET_FAIL1+JCC_SMALL_ENCODING_LENGTH
#define x86_emit_CLT_R() \
    x86_emit_Compare_R_Common() \
    x86_jmp_cond_small(x86CondAboveEq); /*if CF=0, fail*/\
    cmdByte(JMP_OFFSET_FAIL2); \
    x86_jmp_cond_small(x86CondEq); /* if ZF = 1, fail*/\
    cmdByte(JMP_OFFSET_FAIL1); \
    x86_push_imm(1);    \
    x86_jmp_small(); \
    cmdByte(JMP_OFFSET_2); \
    x86_push_imm(0); 

#define x86_emit_CGT_R() \
    x86_emit_Compare_R_Common() \
    x86_jmp_cond_small(x86CondAbove);  /*if CF=0 and ZF=0,... success*/\
    cmdByte(JMP_OFFSET_1); \
    x86_push_imm(0);    \
    x86_jmp_small(); \
    cmdByte(JMP_OFFSET_2); \
    x86_push_imm(1); 

#define JMP_OFFSET_SUCCESS2 JMP_OFFSET_1
#define JMP_OFFSET_SUCCESS1 JMP_OFFSET_SUCCESS2+JCC_SMALL_ENCODING_LENGTH
#define x86_emit_CGT_UN_R() \
    x86_emit_Compare_R_Common() \
    x86_jmp_cond_small(x86CondAbove); /*if CF=0 and ZF=0,... success*/\
    cmdByte(JMP_OFFSET_SUCCESS1); \
    /* else, CF=1 and/or ZF=1 */ \
    x86_jmp_cond_small(x86CondParityEven); /* if PF = 1, success*/\
    cmdByte(JMP_OFFSET_SUCCESS2); \
    x86_push_imm(0);    \
    x86_jmp_small(); \
    cmdByte(JMP_OFFSET_2); \
    x86_push_imm(1); 


// Conversions

#endif // SUPPORT_PRECISE_R

#endif //_FJIT_PORT_BLD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\jitpch.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


#include <windows.h>

#define INJITDLL            // used in corjit.h

#include "corjit.h"
#include "malloc.h"         // for _alloca

extern ICorJitInfo* logCallback;

#ifdef _DEBUG
#ifdef _X86_
#define DbgBreak() 	__asm { int 3 }		// This is nicer as it breaks at the assert code
#else
#define DbgBreak() 	DebugBreak();
#endif

#define _ASSERTE(expr) 		\
        do { if (!(expr) && logCallback->doAssert(__FILE__, __LINE__, #expr)) \
			 DbgBreak(); } while (0)
#else
#define _ASSERTE(expr)  0
#endif

#ifdef _DEBUG
#include "Utilcode.h"		// for Config* classes
#define LOGGING
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\commonlib\commonlib.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ==========================================================================
// commonlib.h
//
// Purpose:
//  Contains headers for library common to the wrappers and custom actions.
// ==========================================================================                                                                                 
#ifndef COMMONLIB_H
#define COMMONLIB_H

int VersionCompare( LPCTSTR lpVersion1, LPCTSTR lpVersion2 );

#endif // COMMONLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\commonlib\commonlib.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ==========================================================================
// commonlib.cpp
//
// Purpose:
//  Contains library common to the wrappers and custom actions.
// ==========================================================================
#include <tchar.h>
#include <windows.h>
#include <stdlib.h>
#include "commonlib.h"

typedef struct TAG_FILE_VERSION
    {
        int   FileVersionMS_High;
        int   FileVersionMS_Low;
        int   FileVersionLS_High;
        int   FileVersionLS_Low;
    }
    FILE_VERSION, *PFILE_VERSION;

// ==========================================================================
//  Name: ConvertVersionToINT()
//
//  Purpose:
//  Converts a string version into 4 parts of integers
//  Inputs:
//    lpVersionString - A input version string
//  Outputs:
//  pFileVersion - A structure that stores the version in to 4 integers
//  Returns
//    true  - if success
//    false - if failed                     
// ==========================================================================
bool ConvertVersionToINT( LPCTSTR lpVersionString, PFILE_VERSION pFileVersion )
{
    LPTSTR lpToken  = NULL;
    TCHAR tszVersionString[50] = {_T('\0')};
    bool bRet = true;

    _tcscpy(tszVersionString, lpVersionString);

    lpToken = _tcstok(tszVersionString, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionMS_High = atoi(lpToken);
    }

    lpToken = _tcstok(NULL, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionMS_Low = atoi(lpToken);
    }

    lpToken = _tcstok(NULL, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionLS_High = atoi(lpToken);
    }

    lpToken = _tcstok(NULL, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionLS_Low = atoi(lpToken);
    }

    return bRet;
}

// ==========================================================================
//  Name: VersionCompare()
//
//  Purpose:
//  Compare two version string.
//  Inputs:
//    lpVersion1 - String of first version to compare
//    lpVersion2 - String of second version to compare
//  Outputs:
//  Returns
//    -1 if lpVersion1 < lpVersion2
//     0 if lpVersion1 = lpVersion2
//     1 if lpVersion1 > lpVersion2
//   -99 if ERROR occurred                         
// ==========================================================================
int VersionCompare( LPCTSTR lpVersion1, LPCTSTR lpVersion2 )
{
    FILE_VERSION Version1;
    FILE_VERSION Version2;
    int          iRet = 0;

    if ( !ConvertVersionToINT(lpVersion1, &Version1) )
    {
        return -99;
    }

    if ( !ConvertVersionToINT(lpVersion2, &Version2) )
    {
        return -99; 
    }

    if ( Version1.FileVersionMS_High > Version2.FileVersionMS_High )
    {
        iRet = 1;
    }
    else if ( Version1.FileVersionMS_High < Version2.FileVersionMS_High )
    {
        iRet = -1;
    }

    if ( 0 == iRet )
    {
        if ( Version1.FileVersionMS_Low > Version2.FileVersionMS_Low )
        {
            iRet = 1;
        }
        else if ( Version1.FileVersionMS_Low < Version2.FileVersionMS_Low )
        {
            iRet = -1;
        }
    }

    if ( 0 == iRet )
    {
        if ( Version1.FileVersionLS_High > Version2.FileVersionLS_High )
        {
            iRet = 1;
        }
        else if ( Version1.FileVersionLS_High < Version2.FileVersionLS_High )
        {
            iRet = -1;
        }
    }

    if ( 0 == iRet )
    {
        if ( Version1.FileVersionLS_Low > Version2.FileVersionLS_Low )
        {
            iRet = 1;
        }
        else if ( Version1.FileVersionLS_Low < Version2.FileVersionLS_Low )
        {
            iRet = -1;
        }
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fjit\x86def.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/*                                 x86def.h                              */
/***************************************************************************/

/* Defines the layout of the x86 machine instructions using Cmd structures.
   Note that the code here ONLY deals with x86 specific information, no
   other instruction set (like OMNI) is involved at this point */

/* If you are not already familiar with the x86 instruction set please 
   get an archetecture manual first, This file can be thought of as a
   distilation of the code layout part */

/* Note that we assume that the x86 CPU is in 32bit mode */

/* FIX: worry about the non-orthoginalities of the x86 addressing modes */

/* AUTHOR: Vance Morrison
   DATE:  1/17/97		*/
/* MODIFIED: George Bosworth
   DATE:  6/15/98       */
/***************************************************************************/


#ifndef x86def_h
#define x86def_h 1

/***************************************************************************/
/* The register numbering */

#define X86_EAX 0
#define X86_EBX 3
#define X86_ECX 1
#define X86_EDX 2
#define X86_ESP 4
#define X86_EBP 5
#define X86_ESI 6
#define X86_EDI 7

#define X86_NO_IDX_REG 4

/* segment register override Prefix*/
#define X86_FS_Prefix 0x64 /* FS segment override prefix */
/***************************************************************************/
/* Define the 'mod' and 'sib' byte that are used in other instructions */
#define x86_sib(scale, scaleReg, baseReg) 					\
    cmdByte(expOr3(expBits(scale,2,6), expBits(baseReg,3,0), expBits(scaleReg,3,3)))


#define x86_mod(mod, reg, r_m) 							\
    (/*_ASSERTE(mod < 4),*/								\
    (mod == 0) ?								\
	cmdByte(expOr2(expBits(r_m, 3, 0), expBits(reg, 3, 3)))			\
    :										\
	cmdByte(expOr3(expNum(mod << 6), expBits(r_m, 3, 0), expBits(reg, 3, 3)))) 


/* also define the 16 bit override prefix */
#define x86_16bit(cmd) 								\
    cmdBlock2(cmdByte(expNum(0x66)), cmd)


/*****************************************************************************/
/* These are the addressing modes for the x86 CPU */

#define x86_mod_disp32(reg, disp32) 						\
    cmdBlock2(									\
	x86_mod(0, reg, expNum(5)), 						\
	cmdDWord(disp32))	


#define x86_mod_ind(reg, ptr) 							\
    x86_mod(0, reg, ptr) 	/* FIX reg can't be BP! */


#define x86_mod_ind_disp8(reg, ptr, disp8) 					\
    cmdBlock2(									\
	x86_mod(1, reg, ptr), 							\
	cmdByte(disp8))			


#define x86_mod_ind_disp32(reg, ptr, disp32) 					\
    cmdBlock2(									\
	x86_mod(2, reg, ptr), 							\
	cmdDWord(disp32))		

#define x86_mod_ind_disp(reg, ptr, disp) 	\
	((((signed) disp < 128) && ((signed) disp >= -128)) ?	\
		x86_mod_ind_disp8(reg, ptr, disp)	\
		:									\
		x86_mod_ind_disp32(reg, ptr, disp))

#define x86_mod_reg(dstReg, srcReg) 						\
    x86_mod(3, dstReg, srcReg)


#define x86_mod_base_scale(reg, baseReg, scaleReg, scale) 			\
    cmdBlock2(									\
	x86_mod(0, reg, expNum(4)), 						\
	x86_sib(scale, scaleReg, baseReg))		


#define x86_mod_base_scale_disp8(reg, baseReg, scaleReg, disp8, scale)		\
    cmdBlock3(									\
	x86_mod(1, reg, expNum(4)), 						\
	x86_sib(scale, scaleReg, baseReg),					\
	cmdByte(disp8))


#define x86_mod_base_scale_disp32(reg, baseReg, scaleReg, disp32, scale) 	\
    cmdBlock3(									\
	x86_mod(2, reg, expNum(4)), 						\
	x86_sib(scale, scaleReg, baseReg),					\
	cmdDWord(disp32))

#define x86_mod_base_scale_disp(reg, baseReg, scaleReg, disp, scale) 	\
	((((signed)disp < 128) && ((signed) disp >= -128)) ?							\
		x86_mod_base_scale_disp8(reg, baseReg, scaleReg, disp, scale)	\
		:																\
		x86_mod_base_scale_disp32(reg, baseReg, scaleReg, disp, scale))

#define x86_mod_scale_disp32(reg, scaleReg, disp32, scale) 			\
    cmdBlock3(									\
	x86_mod(0, reg, expNum(4)), 						\
	x86_sib(scale, scaleReg, expNum(5)),					\
	cmdDWord(disp32))


/*****************************************************************************/
/* full x86 instructions, not we only defined the ones needed for omni conversion */

#define x86Byte 	0 		/* possible sizes */
#define x86Big		1

#define x86NoExtend	0 		/* possible 'ext' values */
#define x86Extend 	1  

/********************** MOV instructions ***************************/

#define x86DirFrom	0 		/* possible 'dir' values */
#define x86DirTo 	2  

#define x86_mov_reg(dir, size, addMode) 				\
    (/*_ASSERTE(size == x86Byte | size == x86Big),*/	\
     cmdBlock2(											\
	cmdByte(expNum(0x88 | dir | size)), 				\
	addMode))


#define x86_mov_reg_imm(size, reg, imm) 				\
    (/*_ASSERTE(size == x86Byte | size == x86Big),	*/	\
     cmdBlock2(											\
	cmdByte(expOr2(expNum(0xB0 | (size << 3)), reg)),	\
	size?cmdDWord(imm):cmdByte(imm)))

/* In using this instruction The destination register for addMode should be 0 */
#define x86_mov_mem_imm(size, addMode, imm) 				\
	(_ASSERTE(size == x86Byte | size == x86Big),	\
	 cmdBlock3(							\
	    cmdByte(expNum(0xC6 | size)),				\
	    addMode,							\
	    size?cmdDWord(imm):cmdByte(imm)))
	

#define x86_movsx(size, addMode) 					\
    (/*_ASSERTE(size == x86Byte | size == x86Big),*/				\
     cmdBlock3(								\
	cmdByte(expNum(0x0F)),						\
	cmdByte(expNum(0xBE | size)),					\
	addMode))			


#define x86_movzx(size, addMode) 					\
    (/*_ASSERTE(size == x86Byte | size == x86Big),*/				\
     cmdBlock3(								\
	cmdByte(expNum(0x0F)),						\
	cmdByte(expNum(0xB6 | size)),					\
	addMode))


#define x86_lea(addMode) 						\
    cmdBlock2(								\
	cmdByte(expNum(0x8D)),						\
	addMode)

#define x86_mov_segment_reg(dir, size, segmentRegPrefix,offset)  \
    cmdBlock3( \
      cmdByte(segmentRegPrefix), \
      cmdByte(expNum(0xA0 | size | dir)), \
      cmdDWord(offset))
/******************** Binary Arithmetic instructions **********************/

		// FIX what are 0 and 1?
#define x86OpNot	2  		/* values for unary op */
#define x86OpNeg	3  
#define x86OpMul	4  
#define x86OpIMul	5  
#define x86OpDiv	6  
#define x86OpIDiv	7

	// we only do register ops for now
#define x86_uarith(op, size, reg) 					\
    (/*_ASSERTE(size == x86Byte | size == x86Big),	*/			\
     cmdBlock2(								\
	cmdByte(expNum(0xF6 | size)),					\
	cmdByte(expOr2(expNum(0xC0 | (op << 3)), reg))))


#define x86_inc_dec(neg, reg) 						\
    cmdByte(expOr2(expNum(0x40 | (neg << 3)), reg))


/******************** Binary Arithmetic instructions **********************/

#define x86OpAdd	0		/* possible values for binary op */
#define x86OpOr		1
#define x86OpAdc	2
#define x86OpSbb	3
#define x86OpAnd	4
#define x86OpSub	5
#define x86OpXor	6
#define x86OpCmp	7

#define x86_barith(op, size, addMode) 					\
    (/*_ASSERTE(size == x86Byte | size == x86Big),	*/			\
     cmdBlock2(								\
	cmdByte(expNum(0x02 | (op << 3) | size)),			\
	addMode))


#define x86_barith_imm(op, size, ext, reg, imm) 			\
    (/*_ASSERTE(!(ext == x86Extend && size == x86Byte)),*/			\
     /*_ASSERTE(size == x86Byte | size == x86Big),*/				\
     cmdBlock3(								\
	cmdByte(expNum(0x80 | size | (ext << 1))),			\
	cmdByte(expOr2(expNum(0xC0 | (op << 3)), reg)),			\
	(ext == x86NoExtend && size == x86Big)?cmdDWord(imm):cmdByte(imm)))


/********************* Shift instructions ************************/

#define x86ShiftLeft		4 
#define x86ShiftRight		5
#define x86ShiftArithRight	7 

#define x86_shift_imm(dir, reg, imm)				 	\
    cmdBlock3(								\
	cmdByte(expNum(0xC1)),						\
	cmdByte(expOr2(expNum(0xC0 | (dir << 3)), reg)),		\
	cmdByte(imm))


#define x86_shift_cl(dir, reg)					 	\
    cmdBlock2(								\
	cmdByte(expNum(0xD3)),						\
	cmdByte(expOr2(expNum(0xC0 | (dir << 3)), reg)))	


/********************* Stack instructions ************************/

#define x86_push(reg) 							\
    cmdByte(expOr2(expNum(0x50), reg))

#define x86_push_imm(val)						\
	(((unsigned) val < 256) ?					\
		cmdBlock2(								\
		cmdByte(0x6A),							\
		cmdByte(val))							\
	:											\
		cmdBlock2(								\
		cmdByte(0x68),							\
		cmdDWord(val)))

#define x86_push_general(addMode) \
    cmdBlock2( \
        cmdByte(expNum(0xFF)), \
        addMode)

#define x86_pop(reg)					 		\
    cmdByte(expOr2(expNum(0x58), reg))

#define x86_push_immediate() \
    cmdByte(0x68)

/********************* Control  instructions ************************/

#define x86_jmp_large()					 		\
    cmdByte(expNum(0xE9))


#define x86_jmp_small()					 		\
    cmdByte(expNum(0xEB))


#define x86_jmp_reg(reg)					 	\
    cmdBlock2(								\
	cmdByte(expNum(0xFF)),						\
	cmdByte(expOr2(expNum(0xE0), reg)))


#define x86CondOver			0 
#define x86CondNotOver		1 
#define x86CondBelow		2 
#define x86CondAboveEq		3 
#define x86CondEq			4 
#define x86CondNotEq		5 
#define x86CondBelowEq		6 
#define x86CondAbove		7 
#define x86CondSign			8 
#define x86CondNotSign		9 
#define x86CondParityEven	10
#define x86CondParityOdd	11
#define x86CondLt			12
#define x86CondGtEq			13
#define x86CondLtEq			14
#define x86CondGt			15
#define x86CondAlways		-1

#define x86Neg(cond) (cond ^ 1)

#define x86_jmp_cond_small(cond) 					\
	(cond == x86CondAlways)? x86_jmp_small() : cmdByte(expNum(0x70 | cond))


#define x86_jmp_cond_large(cond, neg) 					\
	(cond == x86CondAlways)?		\
	x86_jmp_large()  \
	:				\
    cmdBlock2(								\
	cmdByte(expNum(0x0F)),						\
	cmdByte(expNum(0x80 | cond)))		

#define x86_set_cond(reg,cond) \
    cmdBlock3(								\
	cmdByte(expNum(0x0F)),						\
	cmdByte(expNum(0x90 | cond)), \
    cmdByte(expNum(0xC0 | reg)))

#define x86_loop() cmdByte(expNum(0xe2))

#define x86_loope() cmdByte(expNum(0xe1))

#define x86_loopne() cmdByte(expNum(0xe0))

#define x86_call_opcode() 	\
    cmdByte(expNum(0xE8))

/*#define x86_call(address) 	\
	cmdBlock2(				\
	cmdByte(expNum(0xE8)),	\
	cmdDWord(address-((signed) outPtr)-sizeof(void*)))
*/
#define x86_call_reg(reg) 					\
    cmdBlock2(								\
	cmdByte(expNum(0xFF)),					\
	cmdByte(expOr2(expNum(0xD0), reg)))

#define x86_call_ind(reg, disp) 			\
	cmdBlock2(								\
	cmdByte(expNum(0xFF)),					\
	((disp == 0) ?							\
		x86_mod_ind(2, reg)					\
	:										\
	((((signed)disp < 128) && ((signed) disp >= -128)) ?	\
		x86_mod_ind_disp8(2, reg, disp)		\
		:									\
		x86_mod_ind_disp32(2, reg, disp))))

#define x86_call_memory_indirect(adr) 			\
    cmdBlock3( \
      cmdByte(expNum(0xFF)), \
      cmdByte(expNum(0x15)), \
      cmdDWord(adr))

#define x86_ret(bytes)						\
	bytes ?									\
	cmdBlock2(								\
	cmdByte(expNum(0xC2)),					\
	cmdWord(expNum(bytes)))					\
	:										\
	cmdByte(expNum(0xC3))  

/********************* FP  instructions ************************/
#define x86_FPLoad32    0
#define x86_FPLoad64    0
#define x86_FPLoad80    5
#define x86_FPStore32   2
#define x86_FPStore64   2
#define x86_FPStoreP32  3
#define x86_FPStoreP64  3
#define x86_FPStoreP80  7


#define x86_FLT32(addMode) \
    cmdBlock2(cmdByte(0xD9),addMode)

#define x86_FLT64(addMode) \
    cmdBlock2(cmdByte(0xDD),addMode)

#define x86_FLT80(addMode) \
    cmdBlock2(cmdByte(0xDB),addMode)

#define x86_FLD32(addMode) x86_FLT32(addMode)
#define x86_FLD64(addMode) x86_FLT64(addMode)
#define x86_FST32(addMode) x86_FLT32(addMode)
#define x86_FST64(addMode) x86_FLT64(addMode)

#define x86_FltAddP()  \
    cmdBlock2(cmdByte(expNum(0xde)), \
              cmdByte(expNum(0xc1)));

#define x86_FltSubP()  \
    cmdBlock2(cmdByte(expNum(0xde)), \
              cmdByte(expNum(0xe9)));

#define x86_FltMulP()  \
    cmdBlock2(cmdByte(expNum(0xde)), \
              cmdByte(expNum(0xc9)));

#define x86_FltDivP()  \
    cmdBlock2(cmdByte(expNum(0xde)), \
              cmdByte(expNum(0xf9)));

#define x86_FltComPP()  \
    cmdBlock2(cmdByte(expNum(0xde)), \
              cmdByte(expNum(0xd9)));

#define x86_FltUComPP()  \
    cmdBlock2(cmdByte(expNum(0xda)), \
              cmdByte(expNum(0xe9)));

#define x86_FltToggleSign()  \
    cmdBlock2(cmdByte(expNum(0xd9)), \
              cmdByte(expNum(0xe0)));

#define x86_FltStoreStatusWord() \
    cmdBlock2(cmdByte(expNum(0xdf)), \
              cmdByte(expNum(0xe0)));

#define x86_SAHF() cmdByte(expNum(0x9e))

/********************* Misc  instructions ************************/
#define X86_CARRY_FLAG  0x0001
#define X86_ZERO_FLAG   0x0040
#define X86 SIGN_FLAG   0x0080

#define x86_int(intNum) 						\
    cmdBlock2(								\
	cmdByte(expNum(0xCD)),						\
	cmdByte(expNum(intNum)))

#endif

#define x86_test(size, addMode) 					\
    (/*_ASSERTE(size == x86Byte | size == x86Big),	*/	\
     cmdBlock2(								\
	cmdByte(expNum(0x84 | size)),			\
	addMode))

#define x86_test_EAX(size, val) 					\
    (_ASSERTE(size == x86Byte | size == x86Big);	\
     cmdBlock2(								\
	cmdByte(expNum(0xa8 | size)),			\
	cmdByte(expNum(val)))

#define x86_std() cmdByte(expNum(0xFD))

#define x86_cld()	cmdByte(expNum(0xFC))

#define x86_nop() cmdByte(expNum(0x90))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\checkservice\checkservice.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CheckService.cpp : Custom Action type 1
// It inserts temporary rows into ServiceControl table so that we can start 
// iisadmin-dependent services that were running before install or uninstall.
// 
// Jungwook Bae

#include <windows.h>
#include "..\..\inc\msiquery.h"

int AddToStartList(MSIHANDLE hInstance, char* pszSvc);
BOOL IsServiceDisabled(SC_HANDLE hscManager, char* ServiceName);

extern "C" __declspec(dllexport) UINT __stdcall CheckService(MSIHANDLE hInstall)
{
    SC_HANDLE hsc  = NULL;
    SC_HANDLE hsvc = NULL;
    SERVICE_STATUS status;
    DWORD cbBytesNeeded = 0;
    DWORD dwServicesReturned = 0;
    LPENUM_SERVICE_STATUS lpServices = NULL; 

    hsc = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if (hsc == NULL) goto cleanup;
    
    hsvc = OpenService(hsc, "iisadmin", SERVICE_ALL_ACCESS);
    if (hsvc == NULL) goto cleanup;

    if (!ControlService(hsvc, SERVICE_CONTROL_INTERROGATE, &status)) goto cleanup;
    if(IsServiceDisabled(hsc, "iisadmin"))
    {        
        goto cleanup;
    }
    
    if (status.dwCurrentState != SERVICE_STOPPED) {
        AddToStartList(hInstall, "iisadmin");
        EnumDependentServices(hsvc, SERVICE_ACTIVE,  NULL, 0, &cbBytesNeeded, &dwServicesReturned);
        if (cbBytesNeeded <= 0) goto cleanup;

        lpServices = (LPENUM_SERVICE_STATUS)new char[cbBytesNeeded];
//      if (!lpServices) goto cleanup;

        if (!EnumDependentServices(hsvc, SERVICE_ACTIVE,  lpServices, cbBytesNeeded, &cbBytesNeeded, &dwServicesReturned))
            goto cleanup;

        for (DWORD dw = 0; dw < dwServicesReturned; dw++) 
        {
            if(!IsServiceDisabled(hsc,lpServices[dw].lpServiceName))
            {
                AddToStartList(hInstall, lpServices[dw].lpServiceName);
            }
        }
    };

cleanup:
    if (lpServices) delete[] (char*)lpServices;
    if (hsvc != NULL) CloseServiceHandle(hsvc);
    if (hsc  != NULL) CloseServiceHandle(hsc);

    return ERROR_SUCCESS;
}

BOOL IsServiceDisabled(SC_HANDLE hscManager, char* ServiceName)
{
    SC_HANDLE hsvc = NULL;
    QUERY_SERVICE_CONFIG qsConfig;
    DWORD cbBytesNeeded = 0;
    DWORD dBytesNeeded = 0;
    LPQUERY_SERVICE_CONFIG lpqsConfig = &qsConfig;

    hsvc = OpenService(hscManager, ServiceName, SERVICE_ALL_ACCESS);
    if (hsvc == NULL) 
    {
        return TRUE;
    }
    QueryServiceConfig(hsvc, &qsConfig, 0, &cbBytesNeeded); //Query with size 0 to get buffer size;
    lpqsConfig = (LPQUERY_SERVICE_CONFIG) new BYTE[cbBytesNeeded];    
    if (!QueryServiceConfig(hsvc, lpqsConfig, cbBytesNeeded, &dBytesNeeded))
    {                            
        delete[] lpqsConfig;
        CloseServiceHandle(hsvc);
        return TRUE;
    }
   
    if ( lpqsConfig->dwStartType == SERVICE_DISABLED) 
    {
        delete[] lpqsConfig;
        CloseServiceHandle(hsvc);
        return TRUE;
    }
            
    delete[] lpqsConfig;
    CloseServiceHandle(hsvc);
    return FALSE;


}


int AddToStartList(MSIHANDLE hInstance, char* pszSvc)
{
    char szQry[1024] = "Insert into ServiceControl(ServiceControl,Name,Event,Wait,Component_) values('";
    MSIHANDLE hMsi;
    MSIHANDLE hView;
    UINT uRet;

    hMsi = MsiGetActiveDatabase(hInstance);
    if (hMsi == 0) return 1;

    strcat(szQry, pszSvc);
    strcat(szQry, "','");
    strcat(szQry, pszSvc);
    strcat(szQry, "',17,0,'ASPNET_ISAPI_DLL_____X86.3643236F_FC70_11D3_A536_0090278A1BB8') TEMPORARY");

#ifdef _DEBUG
    MessageBox(NULL, szQry, "AddToStartList", MB_OK);
#endif
    uRet = MsiDatabaseOpenView(hMsi, szQry, &hView);
    if (uRet != ERROR_SUCCESS) return 2;

    uRet = MsiViewExecute(hView, 0);
    if (uRet != ERROR_SUCCESS) {
        MsiViewClose(hView);
        return 3;
    }

    uRet = MsiDatabaseCommit(hMsi);
    if (uRet != ERROR_SUCCESS) {
        MsiViewClose(hView);
        return 4;
    }

    MsiViewClose(hView);
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\deletetree\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "DeleteTree.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Custom Action\0"
#define VER_ORIGFILENAME_STR    "DeleteTree.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\checkservice\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "CheckService.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Custom Action\0"
#define VER_ORIGFILENAME_STR    "CheckService.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\detectbeta\detectbeta.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ==========================================================================
// DetectBeta.cpp
//
// Purpose:
//  Detects NDP beta component (mscoree.dll) and block installation. Displays
//  a messagebox with products that installed beta NDP components.
// ==========================================================================
#include "SetupCALib.h"
#include "DetectBeta.h"
#include "commonlib.h"
#include <msiquery.h>
#include <crtdbg.h>
#include <string>

#define EMPTY_BUFFER { _T('\0') }

// This is type 19 custom action in MSI that displays error message.
const TCHAR BLOCKBETA_CA_SZ[]  = _T("CA_BlockBeta.3643236F_FC70_11D3_A536_0090278A1BB8");
const TCHAR BETAPROD_PROP_SZ[] = _T("BetaProd.3643236F_FC70_11D3_A536_0090278A1BB8");

MSIHANDLE g_hInstall = NULL;

CDetectBeta::CDetectBeta( PFNLOG pfnLog )
: m_pfnLog( pfnLog ), m_nCount( 0 ), m_strProducts(_T("\0"))
{}

// ==========================================================================
// CDetectBeta::FindProducts()
//
// Purpose:
//  Enumerate all products that installed beta and older NDP components.
//  It checks version of mscoree.dll. PDC is a special case since it had
//  version of 2000.14.X.X
// Inputs: none
// Outputs:
//  Returns LPCTSTR pszProducts that contains all products seperated by newline.
// Dependencies:
//  Requires Windows Installer
// Notes:
// ==========================================================================
LPCTSTR CDetectBeta::FindProducts()
{
    LPCTSTR pszProducts                 = NULL;
    DWORD   dwSize                      = 0;
    LPTSTR  lpCAData                    = NULL;
    BOOL    fContinue                   = TRUE;
    LPTSTR  lpToken                     = NULL;
    TCHAR   tszLog[_MAX_PATH+1]         = {_T('\0')};
    TCHAR   szProductName[_MAX_PATH+1]  = {_T('\0')};
    DWORD   dwLen                       = 0;

    //
    // Get the BetaBlockID property for all the products needs to be blocked
    //

    // Set the size for the Property
    MsiGetProperty(g_hInstall, _T("BetaBlockID"), _T(""), &dwSize);
    
    // Create buffer for the property
    lpCAData = new TCHAR[++dwSize];

    if (NULL == lpCAData)
    {
        FWriteToLog (g_hInstall, _T("\tERROR: Failed to allocate memory for BetaBlockID"));
        return pszProducts;
    }
    
    if ( ERROR_SUCCESS != MsiGetProperty( g_hInstall,
                                          _T("BetaBlockID"),
                                          lpCAData,
                                          &dwSize ) )
    {
        FWriteToLog (g_hInstall, _T("\tERROR: Failed to get MsiGetProperty for BetaBlockID"));
        delete [] lpCAData;
        lpCAData = NULL;
        return pszProducts;
    }
    else
    {
        lpToken = _tcstok(lpCAData, _T(";"));
        if (NULL == lpToken)
        {
            fContinue = FALSE;
        }

        while (fContinue)
        {
            FWriteToLog1( g_hInstall, _T("\tSTATUS: Check Beta ProductID : %s"), lpToken );
            
            dwLen = LENGTH(szProductName) - 1; // make sure we have space for terminating NULL
            if ( ERROR_SUCCESS == MsiGetProductInfo( lpToken,
                                                     INSTALLPROPERTY_INSTALLEDPRODUCTNAME,
                                                     szProductName,
                                                     &dwLen ) )
            {
                FWriteToLog1 ( g_hInstall, _T("\tSTATUS: Beta Product Detected : %s"), szProductName );
                m_strProducts += _T("\n");
                m_strProducts += szProductName;
            }

            lpToken = _tcstok(NULL, _T(";"));
            if (NULL == lpToken)
            {
                fContinue = FALSE;
            }

        } // end of while (fContinue) loop
    } // end of else

    delete [] lpCAData;
    lpCAData = NULL;

    if ( !m_strProducts.empty() )
    {
        pszProducts = m_strProducts.c_str();
    }
    return pszProducts;
}

void LogIt( LPCTSTR pszFmt, LPCTSTR pszArg )
{
    FWriteToLog1( g_hInstall, pszFmt, pszArg );
}

// ==========================================================================
// DetectBeta()
//
// Purpose:
//  This exported function is called by darwin when the CA runs. It finds products
//  that installed beta NDP components using CDetectBeta and displays error.
//  Then it terminates install.
//
// Inputs:
//  hInstall            Windows Install Handle to current installation session
// Dependencies:
//  Requires Windows Installer & that an install be running.
//  custom action type 19 BLOCKBETA_CA_SZ should exist.
// Notes:
// ==========================================================================
extern "C" UINT __stdcall DetectBeta( MSIHANDLE hInstall )
{
    UINT  uRetCode = ERROR_FUNCTION_NOT_CALLED;
    unsigned int nCnt = 0;

    FWriteToLog( hInstall, _T("\tSTATUS: DetectBeta started") );

    _ASSERTE( hInstall );
    g_hInstall = hInstall;

    LPCTSTR pszProducts = NULL;
    CDetectBeta db( LogIt );

    pszProducts = db.FindProducts();
    if ( pszProducts )
    {
        MsiSetProperty( hInstall, BETAPROD_PROP_SZ, pszProducts );
        return MsiDoAction( hInstall, BLOCKBETA_CA_SZ );
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\detectbeta\detectbeta.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ==========================================================================
// DetectBeta.h
//
// Purpose:
//  This contains constants needed for class CDetectBeta.
// ==========================================================================                                                                                 
#ifndef DETECTBETALIB_H
#define DETECTBETALIB_H

#include <windows.h>
#include <TCHAR.H>

#define LENGTH(A) (sizeof(A)/sizeof(A[0]))

using namespace std;

typedef basic_string<TCHAR> tstring;

const LPCTSTR MSCOREE_COMPID_SZ         = _T("{173A6EB3-6403-11D4-A53F-0090278A1BB8}"); // CompID of mscoree.dll in beta1, beta2
const LPCTSTR MSCOREE_PDC_COMPID_SZ     = _T("{A1B926EF-7FD9-11D2-A429-00A0C9E80AFB}"); // CompID of mscoree.dll in pdc build
const LPCTSTR NGWSSDK_PDC_PRODID_SZ     = _T("{4498E2C0-8F1F-41D0-ADB3-C00B2E43FF59}"); // ProductCode of ngws SDK

const LPCTSTR MSCOREE_BETA_VERSION_SZ   = _T("1.0.3329.0"); // let's use 3329.0 since loc builds have higher revision than 3215.11
// PDC shipped mscoree.dll 2000.14.1812.10
const LPCTSTR MSCOREE_PDC_VERSION_SZ   = _T("2000.14.1812.10");

typedef void (__stdcall *PFNLOG)( LPCTSTR pszFmt, LPCTSTR pszArg );

class CDetectBeta
{
public:
    LPCTSTR FindProducts();
    CDetectBeta( PFNLOG pfnLog );
    unsigned int m_nCount;

private:
    tstring m_strProducts;
    PFNLOG m_pfnLog;
};

#endif // DETECTBETALIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\detectbeta\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "DetectBeta.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Custom Action\0"
#define VER_ORIGFILENAME_STR    "DetectBeta.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\createenvbat\createenvbat.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include "\\jbae1\c$\MsiIntel.SDK\Include\msiquery.h"
#include <stdio.h>
#include <malloc.h>

#define MAXCMD  10240

extern "C" __declspec(dllexport) UINT __stdcall CreateEnvBat(MSIHANDLE hInstall)
{
    PMSIHANDLE hRec = MsiCreateRecord(2);
    UINT  uRetCode     = ERROR_SUCCESS;
	char szCAData[MAXCMD], *pszEnv = NULL, *pCh = NULL, *pCh2 = NULL;
    int i = 0, j = 0;
    FILE* pFile;

	// Get the command line
	DWORD dwLen = sizeof(szCAData);
	uRetCode = MsiGetProperty(hInstall, "CustomActionData", szCAData, &dwLen);
	if (uRetCode != ERROR_SUCCESS || strlen(szCAData) == 0) goto cleanup;
	
#ifdef _DEBUG
	MessageBox(NULL, szCAData, "CustomActionData", MB_OK);
#endif

	pCh = strstr(szCAData, ";");
	if (pCh == NULL) goto cleanup;
	*pCh = '\0';

	MsiRecordSetString(hRec,1,szCAData);
	MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);

    pszEnv = (char*)_alloca(dwLen+1);
    pCh++; i = 0;
    pCh2 = NULL;
	while(*pCh)
	{
        switch(*pCh)
        {
        case '|':
            pszEnv[i] = '\n';
            pCh++;
            i++;
            break;
        case '<': // this mark starts long pathname to be converted to short pathname
            pCh++;
            pCh2 = pCh;
            break;
        case '>': // this ends long pathname
            *pCh = '\0'; // terminate string
            j = GetShortPathName(pCh2, pszEnv+i, dwLen-i);
            pCh++;
            i = i + j;
            pCh2 = NULL;
            break;
        default:
            if ( NULL == pCh2 )
            {
                pszEnv[i] = *pCh;
                i++;
            }
            pCh++;
        }
    }
    pszEnv[i] = '\0'; // terminate string

	MsiRecordSetString(hRec,1,pszEnv);
	MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);

	pFile = fopen(szCAData, "w");
	if (pFile == NULL) return ERROR_FUNCTION_NOT_CALLED;

	fputs(pszEnv, pFile);	
	fclose(pFile);

cleanup:
    if (uRetCode == ERROR_SUCCESS)
		MsiRecordSetString(hRec,1,"Success");
	else
		MsiRecordSetString(hRec,1,"Failed");

    MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);
   	return uRetCode;
}

extern "C" __declspec(dllexport) UINT __stdcall RemoveEnvBat(MSIHANDLE hInstall)
{
    UINT  uRetCode     = ERROR_SUCCESS;
	char szCAData[MAXCMD];

	// Get the command line
	DWORD dwLen = sizeof(szCAData);
	uRetCode = MsiGetProperty(hInstall, "CustomActionData", szCAData, &dwLen);
	if (uRetCode != ERROR_SUCCESS || strlen(szCAData) == 0) 
		uRetCode = ERROR_FUNCTION_NOT_CALLED;

	if (_unlink(szCAData) != 0)
		uRetCode = ERROR_FUNCTION_NOT_CALLED;

	return uRetCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\deletetree\deletetree.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <tchar.h>
#include <windows.h>
#include "msiquery.h"
#include "SetupCALib.h"

const TCHAR DELETETREE_DIR_PROP[] = _T("DELETETREE_DIR.3643236F_FC70_11D3_A536_0090278A1BB8");
const TCHAR DELETETREE_COMP_PROP[] = _T("DELETETREE_COMP.3643236F_FC70_11D3_A536_0090278A1BB8");
// ==========================================================================
// DeleteTree()
//
// Purpose:
//  Entry point for DeleteTree custom action. Need two properties to be set
//  before calling this function.
//
//    DELETETREE_DIR:   directory to delete
//    DELETETREE_COMP:  component to associate
//
//  It calls DeleteTreeByDarwin() to remove the directory tree.
// Inputs:
//  hInstall            Windows Install Handle to current installation session
// Dependencies:
//  Requires Windows Installer & that an install be running.
// Notes:
// ==========================================================================
extern "C" UINT __stdcall DeleteTree( MSIHANDLE hInstall )
{
    UINT  uRetCode = ERROR_FUNCTION_NOT_CALLED;
    TCHAR szDir[MAX_PATH+1] = { _T('\0') };     // directory to remove (property DELETETREE_DIR)
    TCHAR szComp[72+1] = { _T('\0') };          // component to associate (property DELETETREE_COMP)
    DWORD dwLen = 0;

    FWriteToLog( hInstall, _T("\tDeleteTree started") );
try
{
    if ( NULL == hInstall )
    {
        throw( _T("\t\tError: MSIHANDLE hInstall cannot be NULL") );
    }
        
    // Get properties DELETETREE_DIR and DELETETREE_COMP
    dwLen = sizeof(szDir)/sizeof(szDir[0]) - 1;
    uRetCode = MsiGetProperty( hInstall, DELETETREE_DIR_PROP, szDir, &dwLen );
    if ( ERROR_MORE_DATA == uRetCode )
    {
        throw( _T("\t\tError: strlen(DELETETREE_DIR) cannot be more than MAX_PATH") );
    }
    else if ( ERROR_SUCCESS != uRetCode || 0 == _tcslen(szDir) ) 
    {
        throw( _T("\t\tError: Cannot get property DELETETREE_DIR.3643236F_FC70_11D3_A536_0090278A1BB8") );
    }
    FWriteToLog1( hInstall, _T("\t\tDELETETREE_DIR: %s"), szDir );

    dwLen = sizeof(szComp)/sizeof(szComp[0]) - 1;
    uRetCode = MsiGetProperty( hInstall, DELETETREE_COMP_PROP, szComp, &dwLen );
    if ( ERROR_MORE_DATA == uRetCode )
    {
        throw( _T("\t\tError: strlen(DELETETREE_COMP) cannot be more than 72") );
    }
    else if ( ERROR_SUCCESS != uRetCode || 0 == _tcslen(szComp) ) 
    {
        throw( _T("\t\tError: Cannot get property DELETETREE_COMP.3643236F_FC70_11D3_A536_0090278A1BB8") );
    }
    FWriteToLog1( hInstall, _T("\t\tDELETETREE_COMP: %s"), szComp );

    TCHAR *pLast = _tcschr( szDir, _T('\0') );
    pLast = _tcsdec( szDir, pLast );
    if ( _T('\\') == *pLast )
    {
        *pLast = _T('\0'); // remove the last backslash
    }

    DeleteTreeByDarwin( hInstall, szDir, szComp );

    uRetCode = ERROR_SUCCESS;
    FWriteToLog( hInstall, _T("\tDeleteTree ended successfully") );
}
catch( TCHAR *pszMsg )
{
    uRetCode = ERROR_FUNCTION_NOT_CALLED; // return failure to darwin
    FWriteToLog( hInstall, pszMsg );
    FWriteToLog( hInstall, _T("\tError: DeleteTree failed") );
}
    // If we call this during uninstall, we might want to ignore the return code and continue (+64).
    return uRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\execnoconsole\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "Execnoconsole.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Custom Action\0"
#define VER_ORIGFILENAME_STR    "Execnoconsole.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\loadcorperf\loadcorperf.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// loadCORPerf.cpp
// Custom Action for lodctr CORPerfMonSymbols.ini and unlodctr COMPlus
// Jungwook Bae

#define MAXPATH 1024
#include <stdio.h>
#include <windows.h>
#include "..\..\inc\msiquery.h"
#include <loadperf.h>

extern "C" __declspec(dllexport) UINT __stdcall loadCORPerf(MSIHANDLE hInstall)
{
    typedef LONG (__stdcall*lpFnLoadPerf)(LPSTR, BOOL);
    HINSTANCE  hLibrary = NULL;
	LONG lRet = ERROR_FUNCTION_NOT_CALLED;
	lpFnLoadPerf pFnLoad = NULL;
	char szPath1[MAXPATH], szPath[MAXPATH+2];
	DWORD dwLen = sizeof(szPath1);
	UINT err;

    PMSIHANDLE hRec = MsiCreateRecord(2);
    MsiRecordSetString(hRec,1,"COMPlus");
    MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);

	hLibrary = ::LoadLibrary("loadperf.dll");
	if (!hLibrary) goto cleanup;

	pFnLoad = (lpFnLoadPerf)::GetProcAddress(hLibrary, "LoadPerfCounterTextStringsA");
	if (!pFnLoad) goto cleanup;

	// Get the path to CorPerfMonSymbols.ini
	err = MsiGetProperty(hInstall, "CustomActionData", szPath1, &dwLen);
	if (err != ERROR_SUCCESS || strlen(szPath1) == 0) goto cleanup;

	strcpy(szPath, "x "); // KB ID:Q188769 
	strcat(szPath, szPath1);
	lRet = (*pFnLoad)(szPath, FALSE);

cleanup:
	if (hLibrary)
		::FreeLibrary(hLibrary) ;

	if (MsiGetMode(hInstall,MSIRUNMODE_SCHEDULED))
	{
		if (lRet == ERROR_SUCCESS) {
			return ERROR_SUCCESS;
		}
		else {
//		    PMSIHANDLE hRec2 = MsiCreateRecord(2);
//		    MsiRecordSetInteger(hRec2,1,25000);
//		    MsiRecordSetString(hRec2,2,"COMPlus");
//			MsiProcessMessage(hInstall, INSTALLMESSAGE_USER, hRec2);
			return ERROR_FUNCTION_NOT_CALLED;
		}
	}

	return ERROR_SUCCESS;
}

extern "C" __declspec(dllexport) UINT __stdcall unloadCORPerf(MSIHANDLE hInstall)
{
    typedef LONG (__stdcall*lpFnUnloadPerf)(LPSTR, BOOL);
    HINSTANCE  hLibrary = NULL;
	lpFnUnloadPerf pFnUnload = NULL;   

    PMSIHANDLE hRec = MsiCreateRecord(2);
    MsiRecordSetString(hRec,1,"COMPlus");
    MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);

	hLibrary = ::LoadLibrary("loadperf.dll");
	if (!hLibrary) goto cleanup;

	pFnUnload = (lpFnUnloadPerf)::GetProcAddress(hLibrary, "UnloadPerfCounterTextStringsA");
	if (!pFnUnload) goto cleanup;

	// Try to unlodctr COMPlus and ignore any error.
	(*pFnUnload)("x COMPlus", FALSE); // KB ID:Q188769

cleanup:
	if (hLibrary)
		::FreeLibrary(hLibrary) ;

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\locatewww\locatewww.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include "..\..\inc\msiquery.h"

extern "C" __declspec(dllexport) UINT __stdcall locateWWW(MSIHANDLE hInstall)
{
    HKEY hKey;
	char szBuf[1024], *pCh;
	DWORD dwLen = sizeof(szBuf);
	UINT uRetCode;

try
{
    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            TEXT("SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots"),
            0,
            KEY_QUERY_VALUE,
            &hKey) != ERROR_SUCCESS )
		throw("cannot open Reg Key");
		
    if( RegQueryValueEx(hKey,
            TEXT("/"),
            NULL,
            NULL,
            (LPBYTE)szBuf,
            &dwLen
            ) != ERROR_SUCCESS )
	{
		    RegCloseKey(hKey);
			throw("cannot read Reg Key");
	}

    RegCloseKey(hKey);

	// Try to find ',' and put \ and '\0'.
	pCh = szBuf;
	while(*pCh != '\0' && *pCh != ',') pCh++;
	if (*pCh == '\0') 
	{
		// there's no comma. must be bad format
		throw("bad format");
	}

	*pCh = '\\';
	*(pCh+1) = '\0';

}
catch(char *)
{
	dwLen = sizeof(szBuf);
	MsiGetProperty(hInstall, "WindowsVolume", szBuf, &dwLen);
	strcat(szBuf, "Inetpub\\wwwroot\\");
}

    // hard-corded WWWROOT for Beta 1
	uRetCode = MsiSetTargetPath(hInstall, "wwwroot.3643236F_FC70_11D3_A536_0090278A1BB8", szBuf);
	if (uRetCode != ERROR_SUCCESS) 
	{
        PMSIHANDLE hRec = MsiCreateRecord(2);

        MsiRecordSetInteger( hRec, 1, 25000 );
        MsiRecordSetString( hRec, 2, szBuf );
        MsiProcessMessage( hInstall, INSTALLMESSAGE_ERROR, hRec );
        
        return ERROR_INSTALL_FAILURE;
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\removezap\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "RemoveZAP.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Custom Action\0"
#define VER_ORIGFILENAME_STR    "RemoveZAP.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\removezap\removezap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ==========================================================================
// RemoveZAP.cpp
//
// Purpose:
//  Adds Zap Cache directory tree into RemoveFile table so that they can be 
//  removed. Gets version from "URTVersion" property. After loading fusion.dll
//  of the correct version, it calls GetCachePath() to find Zap Cache directory.
// ==========================================================================
#include <tchar.h>
#include <windows.h>
#include <msiquery.h>
#include "SetupCALib.h"
#include <fusion.h>
#include <mscoree.h>
#include <crtdbg.h>
#include <string>

#ifndef NumItems
#define NumItems(s) (sizeof(s) / sizeof(s[0]))
#endif

const LPCTSTR FUSION_CACHE_DIR_ZAP_SZ   = _T("assembly\\NativeImages1_");
const LPCTSTR FRAMEWORK_DIR_SZ          = _T("Microsoft.NET\\Framework\\");
const LPCTSTR FUSION_COMP               = _T("FUSION_DLL_____X86.3643236F_FC70_11D3_A536_0090278A1BB8");
const LPCTSTR URTVERSION_PROP           = _T("URTVersion");

// prototype of fusion GetCachePath() in fusion.dll
typedef HRESULT (__stdcall *PFNGETCACHEPATH)( ASM_CACHE_FLAGS dwCacheFlags, LPWSTR pwzCachePath, PDWORD pcchPath );
typedef HRESULT (__stdcall *CORBINDTORUNTIMEEX)(LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor, DWORD flags, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
typedef std::basic_string<TCHAR> tstring;

// ==========================================================================
// FindZAPDir()
//
// Purpose:
//  It tries to find ZAP directory by calling GetCachePath() in fusion.dll. If
//  that fails, it uses the default path: <WindowsFolder>assembly\NativeImages1_<version>.
//
// Inputs:
//  hInstall            Windows Install Handle to current installation session
//
// Outputs:
//  szZapCacheDir       Zap Cache directory to return
// Dependencies:
//  Requires Windows Installer & that an install be running.
//  URTVersion property should exist
// Notes:
// ==========================================================================
void FindZAPDir( MSIHANDLE hInstall, LPTSTR szZapCacheDir )
{
    UINT  uRetCode = ERROR_FUNCTION_NOT_CALLED;
    TCHAR szWindowsFolder[MAX_PATH+1] = { _T('\0') };
    TCHAR szSystemFolder[MAX_PATH+1] = { _T('\0') };
    TCHAR szVersion[MAX_PATH+1] = { _T('\0') };
    WCHAR wzVersion[MAX_PATH+1] = { L'\0' };
    WCHAR wzZapCacheDir[MAX_PATH+1] = { L'\0' };
    DWORD dwLen = 0;
    HINSTANCE hFusionDll = NULL;
    HINSTANCE hMscoreeDll = NULL;

    _ASSERTE( hInstall );
    _ASSERTE( szZapCacheDir );

    // First, get URTVersion property
    dwLen = sizeof( szVersion )/sizeof( szVersion[0] ) - 1;
    uRetCode = MsiGetProperty( hInstall, URTVERSION_PROP, szVersion, &dwLen );
    if ( ERROR_MORE_DATA == uRetCode )
    {
        throw( _T("\t\tError: strlen(URTVersion) cannot be more than MAX_PATH") );
    }
    else if ( ERROR_SUCCESS != uRetCode || 0 == _tcslen(szVersion) ) 
    {
        throw( _T("\t\tError: Cannot get property URTVersion") );
    }

    FWriteToLog1( hInstall, _T("\tURTVersion: %s"), szVersion );

    // Get WindowsFolder
    dwLen = sizeof( szWindowsFolder )/sizeof( szWindowsFolder[0] ) - 1;
    uRetCode = MsiGetProperty(hInstall, _T("WindowsFolder"), szWindowsFolder, &dwLen);
    if ( ERROR_MORE_DATA == uRetCode )
    {
        throw( _T("\tError: strlen(WindowsFolder) cannot be more than MAX_PATH") );
    }
    else if ( ERROR_SUCCESS != uRetCode || 0 == _tcslen(szWindowsFolder) ) 
    {
        throw( _T("\tError: Cannot get property WindowsFolder") );
    }

try
{
    // We need to bind to specific runtime version (szVersion) by calling CorBindToRuntimeEx() in mscoree.dll
    // before calling GetCachePath() in fusion.dll.
    // Also we should not unload mscoree.dll until we call GetCachePath().
    UINT nChars = GetSystemDirectory( szSystemFolder, NumItems(szSystemFolder) );
    if ( nChars == 0 || nChars > NumItems(szSystemFolder))
    {
        throw( _T("\tError: Cannot get System directory") );
    }

    tstring strMscoreeDll( szSystemFolder );
    strMscoreeDll += _T("\\mscoree.dll");

    hMscoreeDll = ::LoadLibrary( strMscoreeDll.c_str() );
    if ( hMscoreeDll )
    {
        CORBINDTORUNTIMEEX pfnCorBindToRuntimeEx = NULL;
        FWriteToLog1( hInstall, _T("\t%s loaded"), strMscoreeDll.c_str() );
        pfnCorBindToRuntimeEx = (CORBINDTORUNTIMEEX)GetProcAddress( hMscoreeDll, _T("CorBindToRuntimeEx") );
        if ( !pfnCorBindToRuntimeEx ) 
        {
            throw( _T("\tError: Getting GetProcAddress of CorBindToRuntimeEx() failed") );
        }

        if (!MultiByteToWideChar( CP_ACP, 0, szVersion, -1, wzVersion, MAX_PATH ))
        {
            throw( _T("\tError: MultiByteToWideChar() failed") );
        }
        
        if ( SUCCEEDED(pfnCorBindToRuntimeEx( wzVersion,NULL,STARTUP_LOADER_SETPREFERENCE|STARTUP_LOADER_SAFEMODE,IID_NULL,IID_NULL,NULL ) ) )
        {
            FWriteToLog1( hInstall, _T("\tbound to runtime version %s"), szVersion );
        }
        else
        {
            throw( _T("\tError: CorBindToRuntimeEx() failed") );
        }
    }
    else
    {
        throw( _T("\tError: mscoree.dll load failed") );
    }

    // Load the version of Fusion from the versioned directory
    // I am trying avoid using LoadLibraryShim() since loading mscoree.dll may cause problems
    // and it may not exist.
    tstring strFusionDll( szWindowsFolder );
    strFusionDll += FRAMEWORK_DIR_SZ;
    strFusionDll += szVersion;
    strFusionDll += _T("\\fusion.dll");

    LPCTSTR pszFusionDll = strFusionDll.c_str();
    FWriteToLog1( hInstall, _T("\tLoading fusion: %s"), pszFusionDll );

    // we have to use LOAD_WITH_ALTERED_SEARCH_PATH because of fusion.dll's dependency
    // on msvcr70.dll
    hFusionDll = ::LoadLibraryEx( pszFusionDll, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
    if ( hFusionDll )
    {
        PFNGETCACHEPATH pfnGetCachePath = NULL;
        FWriteToLog( hInstall, _T("\tfusion loaded") );
        pfnGetCachePath = (PFNGETCACHEPATH)GetProcAddress( hFusionDll, _T("GetCachePath") );
        if ( !pfnGetCachePath ) 
        {
            throw( _T("\tError: Getting GetProcAddress of GetCachePath() failed") );
        }

        dwLen = sizeof(wzZapCacheDir);
        if ( SUCCEEDED( pfnGetCachePath( ASM_CACHE_ZAP, wzZapCacheDir, &dwLen ) ) )
        {
            if (!WideCharToMultiByte( CP_ACP, 0, wzZapCacheDir, -1, szZapCacheDir, MAX_PATH, NULL, NULL ))
            {
                throw( _T("\tError: WideCharToMultiByte() failed") );
            }
        }
        else
        {
            throw( _T("\tError: GetCachePath() failed") );
        }
    }
    else
    {
        LPVOID lpMsgBuf;
        FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            GetLastError(),
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL 
        );
        FWriteToLog1( hInstall, _T("\tLast Error: %s"), (LPCTSTR)lpMsgBuf );
        LocalFree( lpMsgBuf );

        throw( _T("\tError: fusion load failed") );
    }
}
catch( TCHAR *pszMsg )
{
    FWriteToLog( hInstall, pszMsg );
    FWriteToLog( hInstall, _T("\tCannot get ZapCache. Let's use default") );

    if ( MAX_PATH <= _tcslen( szWindowsFolder ) + _tcslen( FUSION_CACHE_DIR_ZAP_SZ ) + _tcslen( szVersion ) )
    {
        if ( hMscoreeDll )
        {
            ::FreeLibrary( hMscoreeDll );
        }
        if ( hFusionDll )
        {
            ::FreeLibrary( hFusionDll );
        }
        throw( _T("\tError: ZapCache too long") );
    }

    _tcscpy( szZapCacheDir, szWindowsFolder );
    _tcscat( szZapCacheDir, FUSION_CACHE_DIR_ZAP_SZ );
    _tcscat( szZapCacheDir, szVersion );
}
    if ( hMscoreeDll )
    {
        ::FreeLibrary( hMscoreeDll );
    }
    if ( hFusionDll )
    {
        ::FreeLibrary( hFusionDll );
    }

    return;
}

// ==========================================================================
// RemoveZAP()
//
// Purpose:
//  This exported function is called by darwin when the CA runs. It tries to find
//  ZAP directory through fusion.dll and add the directory tree into RemoveFile table
//  to be removed by darwin later.
//
// Inputs:
//  hInstall            Windows Install Handle to current installation session
// Dependencies:
//  Requires Windows Installer & that an install be running.
// Notes:
// ==========================================================================
extern "C" UINT __stdcall RemoveZAP( MSIHANDLE hInstall )
{
    UINT  uRetCode = ERROR_FUNCTION_NOT_CALLED;
    TCHAR szZapCacheDir[MAX_PATH+1] = { _T('\0') };
    DWORD dwLen = 0;
    FWriteToLog( hInstall, _T("\tRemoveZAP started") );

try
{
    if ( !hInstall )
    {
        throw( _T("\tError: MSIHANDLE hInstall is NULL") );
    }

    FindZAPDir( hInstall, szZapCacheDir );

    FWriteToLog1( hInstall, _T("\tZapCache: %s"), szZapCacheDir );

    DeleteTreeByDarwin( hInstall, szZapCacheDir, FUSION_COMP );

    uRetCode = ERROR_SUCCESS;
    FWriteToLog( hInstall, _T("\tRemoveZAP ended successfully") );
}
catch( TCHAR *pszMsg )
{
    uRetCode = ERROR_FUNCTION_NOT_CALLED; // return failure to darwin
    FWriteToLog( hInstall, pszMsg );
    FWriteToLog( hInstall, _T("\tRemoveZAP failed") );
}
    // If we call this during uninstall, we might want to ignore the return code and continue (+64).
    return uRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\execnoconsole\execnoconsole.cpp ===
/******************************************************************************
FILE:    ExecNoConsole.cpp
PROJECT: NDP Custom Action Project
DESC:    Creates the DLL containing the call "QuietExec" ... will quietly
         execute a given application
OWNER:   JoeA/JBae

Copyright (C) Microsoft Corp 2001.  All Rights Reserved.
******************************************************************************/

#include <windows.h>
#include <msiquery.h>
#include <stdio.h>
#include <assert.h>

//defines
//
const int  MAXCMD        = 1024;
const char g_chEndOfLine = '\0';

//forwards
//
void ReportActionError(MSIHANDLE hInstall, char* pszErrorMsg, char* pszCmd);
BOOL CreateCPParams( char* szInString, char*& pszExecutable, char*& pszCommandLine );
BOOL IsExeExtention( const char* pszString, char* pBlank );
BOOL GetApplicationNameFromNonQuotedString( const char* pszString, char* pszApplicationName, char* pszCommandLine );
BOOL GetApplicationNameFromQuotedString( const char* pszString, char* pszApplicationName, char* pszCommandLine );



//////////////////////////////////////////////////////////////////////////////
// Receives: MSIHANDLE  - handle to MSI 
// Returns : UINT       - Win32 error code
// Purpose : Custom action to be called as a DLL; will extract custom action
//           data from the MSI and quietly execute that application and 
//           return the call from that app
//
extern "C" __declspec(dllexport) UINT __stdcall QuietExec(MSIHANDLE hInstall)

{
    BOOL  bReturnVal   = false ;
    UINT  uRetCode     = ERROR_FUNCTION_NOT_CALLED ;
    char szCmd[MAXCMD];
    DWORD dwLen = sizeof(szCmd);
    PMSIHANDLE hRec = MsiCreateRecord(2);
    char *pRec = NULL, *pPath = NULL;
    STARTUPINFO  si ;
    ZeroMemory(&si, sizeof(si)) ;
    si.cb = sizeof(si) ;

    // Get the command line
    uRetCode = MsiGetProperty(hInstall, "CustomActionData", szCmd, &dwLen);
    
    if ((uRetCode != ERROR_SUCCESS) || (0 == strlen(szCmd)))
    {
        ReportActionError(hInstall, "Failed in call to MsiGetProperty(hInstall, 'CustomActionData', szCmd, &dwLen) - could not get the custom action data (or an empty string was returned)!", szCmd);
        uRetCode = ERROR_INSTALL_FAILURE;
    }

    // continue only if we were successful in getting the property    
    if (uRetCode == ERROR_SUCCESS)
    {           

        pRec = strstr(szCmd, ";");
        if (pRec != NULL) {
            *pRec = '\0';
            pRec++;
            pPath = strstr(pRec, ";");
            if (pPath != NULL) {
                *pPath = '\0';
                pPath++;
                SetEnvironmentVariable("PATH", pPath);
            }

            MsiRecordSetString(hRec,1,szCmd);
            MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);
        }

        //create strings to hand CreateProcess with
        // space for quotes, if needed, and null
        //
        size_t cLen = ::strlen( szCmd );
        char* pszExeName = new char[cLen+3];
        char* pszCmdLine = new char[cLen+3];

        pszExeName[0] = '\0';
        pszCmdLine[0] = '\0';

        //CreateProcess requires the first parameter to be the exe name
        // and the second to be the exe (again) and cmdline
        //
        CreateCPParams( szCmd, pszExeName, pszCmdLine );
        assert( NULL != pszExeName );
        assert( NULL != pszCmdLine );

        PROCESS_INFORMATION process_info ;
        DWORD  dwExitCode ;
        bReturnVal = CreateProcess(
                        pszExeName,          // name of executable module
                        pszCmdLine,          // command line string
                        NULL,                // Security
                        NULL,                // Security
                        FALSE,               // handle inheritance option
                        DETACHED_PROCESS,    // creation flags
                        NULL,                // new environment block
                        NULL,                // current directory name
                        &si,                 // startup information
                        &process_info );     // process information

        if(bReturnVal)
        {
            CloseHandle( process_info.hThread ) ;
            WaitForSingleObject( process_info.hProcess, INFINITE ) ;
            GetExitCodeProcess( process_info.hProcess, &dwExitCode ) ;
            CloseHandle( process_info.hProcess ) ;
            if (dwExitCode == 0)
            {
                // Process returned 0 (success)
                uRetCode = ERROR_SUCCESS;
            }
            else
            {

                // Process returned something other than zero
                ReportActionError(hInstall, "Process returned non-0 value!", szCmd);
                uRetCode = ERROR_INSTALL_FAILURE;
            }
        }
        else
        {
            // Failed in call to CreateProcess
            ReportActionError(hInstall, "Failed in call to CreateProcess", szCmd);
            uRetCode = ERROR_INSTALL_FAILURE;
        }

        if( pszExeName )
        {
            delete[] pszExeName;
        }

        if( pszCmdLine )
        {
            delete[] pszCmdLine;
        }
    }   


    if (uRetCode == ERROR_SUCCESS)
        MsiRecordSetString(hRec,1,"Success");
    else
        MsiRecordSetString(hRec,1,"Failed");

    MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);
    return uRetCode;
}


//////////////////////////////////////////////////////////////////////////////
// Receives: MSIHANDLE - MSI installation
//           char*     - informational message
//           char*     - line that was errored on
// Returns : void
// Purpose : used to pass custom action errors back to the MSI installation
//
void ReportActionError(MSIHANDLE hInstall, char* pszErrorMsg, char* pszCmd)
{
    if (!pszErrorMsg || !pszCmd || (0 == hInstall))
    {
        // Nothing we can do...
        return;
    }

    char szFormat[] = "ERROR: %s CMDLINE: %s";
    unsigned int iBuffSize = strlen(pszCmd) + strlen(pszErrorMsg) + strlen(szFormat) + 1;

    char* pszMsg = new char[iBuffSize];
    sprintf(pszMsg, szFormat, pszErrorMsg, pszCmd);

    PMSIHANDLE hRec = MsiCreateRecord(2);
    MsiRecordSetString(hRec, 1, pszMsg);
    MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);

    delete []pszMsg;
}


//////////////////////////////////////////////////////////////////////////////
// Receives: char*  - [IN]  data from the MSI custom action
//           char*& - [OUT] exe name
//           char*& - [OUT] exe and cmd line
// Returns : BOOL
// Purpose : 
// breaks pszString to applicationName (exe-file) and command-line (exefile
// and arguments) encloses exe-name in quotes (for commandLine only), if it 
// is not quoted already removes quotes from applicationName if exe-name was 
// quoted returns false if pszString is in wrong format (contains one quote 
// only, has no exe-name, etc)
// Parameters:
//          [in] pszString - string containing exe-name and arguments
//                           "my.exe" arg1, arg2
//                            
//          [out] pszApplicationName - will contain exe-name
//          [out] pszCommandLine - same as pszString with exe-name quoted

// for example if pszString = "my.exe" arg1 arg2 (OR pszString = my.exe arg1 arg2)
// then 
//       pszApplicationName = my.exe 
//       pszCommandLine     = "my.exe" arg1 arg2
//
BOOL CreateCPParams( char* pszString, 
                     char*& pszApplicationName, 
                     char*& pszCommandLine )
{
    BOOL bRes = FALSE;

    if ( pszString == NULL )
    {
        assert( !L"GetApplicationName Error! pszString is null." );
        return bRes;
    }

    if ( pszString && pszString[0] == L'\"' )
    {
        bRes  = GetApplicationNameFromQuotedString( pszString, 
                                                    pszApplicationName, 
                                                    pszCommandLine );
    }
    else
    {
        bRes  = GetApplicationNameFromNonQuotedString( pszString, 
                                                       pszApplicationName, 
                                                       pszCommandLine );
    }
    
    return bRes;
}



//////////////////////////////////////////////////////////////////////////////
// Receives: char*  - [IN]  data from the MSI custom action
//           char*& - [OUT] exe name
//           char*& - [OUT] exe and cmd line
// Returns : BOOL
// Purpose : breaks command-line to applicationName and arguments 
//           for path begins with quote (pszString = "my.exe" arg1 arg2)
//
BOOL GetApplicationNameFromQuotedString( const char* pszString, 
                                         char* pszApplicationName, 
                                         char* pszCommandLine )
{
    assert( NULL != pszString );
    assert( NULL != pszApplicationName );
    assert( NULL != pszCommandLine );

    // command line begins with quote:
    // make commandLine to be equal to pszString,
    // applName should contain exe-name without quotes
    ::strcpy( pszCommandLine, pszString );
    
    // copy beginning with next symbol after quote
    ::strcpy( pszApplicationName, &pszString[1] );
    
    // search for the second quote, assign to applName
    char* pQuotes = ::strchr( pszApplicationName, '\"' );

    if( pQuotes != NULL )
    {
        *pQuotes = g_chEndOfLine;
        return TRUE;
    }

    return FALSE;
}



//////////////////////////////////////////////////////////////////////////////
// Receives: char*  - [IN]  data from the MSI custom action
//           char*& - [OUT] exe name
//           char*& - [OUT] exe and cmd line
// Returns : BOOL
// Purpose : breaks command-line to applicationName and arguments for path 
//           that does NOT begin with quote (pszString = my.exe arg1 arg2)
//
BOOL GetApplicationNameFromNonQuotedString( const char* pszString, 
                                            char* pszApplicationName, 
                                            char* pszCommandLine )
{
    assert( NULL != pszString );
    assert( NULL != pszApplicationName );
    assert( NULL != pszCommandLine );

    // find the blankspace, such that the 4 chars before it are ".exe"
    char* pBlank = NULL;
    pBlank = ::strchr( pszString, ' ' ); 
    if ( pBlank == NULL )
    {
        // whole string is exe, no quotes are necessary: 
        ::strcpy( pszApplicationName, pszString );
        ::strcpy( pszCommandLine, pszString );

        return TRUE;
    }
    
    // pBlank point to the first blank space
    BOOL bExenameFound = FALSE;
    pBlank = ::CharPrev( pszString, pBlank );

    do
    {
        if( IsExeExtention( pszString, pBlank ) )
        {
            bExenameFound = TRUE;
            break;
        }

        //walk back to blank and then to next char
        //
        pBlank = ::CharNext( pBlank );
        assert( ' ' == *pBlank );

        pBlank = ::CharNext( pBlank );
        pBlank = ::strchr( pBlank, ' ' );
        
    } while( pBlank != NULL );
    
    if( NULL == pBlank &&
        FALSE == bExenameFound )
    {
        //hit the end of line ... must be no cmdline args, test for exe
        //
        char* pEOL = const_cast<char*>( pszString ); //casting away constness
                                                      //...won't modify

        //find the last character
        //
        while( '\0' != *pEOL )
        {
            pBlank = pEOL;
            pEOL = ::CharNext( pEOL );
        }

        if( IsExeExtention( pszString, pBlank ) )
        {
            bExenameFound = TRUE;
        }
    }
    
    if( bExenameFound == TRUE )
    {
        pBlank = ::CharNext( pBlank );
        
        size_t exeNameLen = pBlank - pszString;
        ::strncpy( pszApplicationName, pszString, exeNameLen );
        pszApplicationName[exeNameLen] = g_chEndOfLine;
        
        // commandline should contain quoted exe-name and args
        ::strcpy( pszCommandLine, "\"" );
        ::strcat( pszCommandLine, pszApplicationName );
        ::strcat( pszCommandLine, "\"" );
        ::strcat( pszCommandLine, pBlank );
        
        return TRUE;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
// Receives: char* - pointer to string
//           char* - pointer to the character before the space between two 
//                   words ... looking for space between .exe and args
// Returns : BOOL
// Purpose : return TRUE if last 4 characters before pBlank are ".exe"
//           return FALSE otherwise
//
BOOL IsExeExtention( const char* pszString, char* pLastChar )
{
    assert( NULL != pszString );
    assert( NULL != pLastChar );

    char chCheckChars[] = {'e', 'x', 'e', '.', g_chEndOfLine };

    char *pExtChar = pLastChar;
    char *pCheckChar = chCheckChars;

    //walk backwards from pBlank and compare with the chCheckChars
    //
    while( *pCheckChar != g_chEndOfLine && 
           ( *pExtChar == *pCheckChar   || 
             *pExtChar == ::toupper( *pCheckChar ) ) )
    {
        ++pCheckChar;
        pExtChar = ::CharPrev( pszString, pExtChar );
    }
    
    return ( *pCheckChar == g_chEndOfLine ) ? TRUE : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\setnt4acl\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


#include <windows.h>
#include <aclapi.h>
#include <accctrl.h>

const WCHAR frameworkSubPath[] = L"Microsoft.Net\\Framework";
const WCHAR mscoreeSubPath[] = L"System32\\mscoree.dll";
const HKEY frameworkRootKey = HKEY_LOCAL_MACHINE;
WCHAR frameworkSubKey[] = L"Software\\Microsoft\\.NETFramework";


struct PartialAcl
{
    DWORD grfAccessPermissions;
    LPWSTR trusteeName;
};

// These values were found by examining an NT4
// machine right after setup.

const PartialAcl DefaultFileAcls[] =
{
    { 2032127, L"Everyone" },
    { 2032127, L"Everyone" },
};


const PartialAcl DefaultRegistryAcls[] =
{
    { 196639, L"Everyone" },
    { 196639, L"Everyone" },
    { 983103, L"BUILTIN\\Administrators" },
    { 983103, L"BUILTIN\\Administrators" },
    { 983103, L"NT AUTHORITY\\SYSTEM" },
    { 983103, L"NT AUTHORITY\\SYSTEM" },
    { 983103, L"CREATOR OWNER" },
};

const WCHAR* SafeFilePrefixes[] =
{
    L"security.config.cch.",
    L"enterprisesec.config.cch.",
};


static BOOL SetFileAccessWorker( const LPCWSTR wszFileName )
{
    DWORD dwRes;
    PSID pAdminSID = NULL;
    PSID pUsersSID = NULL;
    PSID pPowerUsersSID = NULL;
    PSID pSystemSID = NULL;
    PSID pCreatorSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    EXPLICIT_ACCESS_W ea[5];
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthCreator = SECURITY_CREATOR_SID_AUTHORITY;
    BOOL bReturn = FALSE;

/*
    // Detect the default acls and take no action if they are found.

    DWORD requiredSize;
    if (!GetFileSecurityW( wszFileName, DACL_SECURITY_INFORMATION, NULL, 0, &requiredSize ))
    {
        pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                                 requiredSize); 
        if (pSD == NULL)
        { 
            goto Cleanup; 
        } 

        if (!GetFileSecurityW( wszFileName, DACL_SECURITY_INFORMATION, pSD, requiredSize, &requiredSize ))
        {
            goto Cleanup;
        }

        BOOL bDaclPresent, bDaclDefaulted;
        PACL pDacl;

        if (!GetSecurityDescriptorDacl( pSD, &bDaclPresent, &pDacl, &bDaclDefaulted ))
        {
            goto Cleanup;
        }

        if (bDaclPresent)
        {
            ULONG numEntries;
            EXPLICIT_ACCESS_W* explicitEntries;

            if (GetExplicitEntriesFromAclW( pDacl, &numEntries, &explicitEntries ) != ERROR_SUCCESS)
            {
                goto Cleanup;
            }

            if (numEntries > sizeof( DefaultFileAcls ) / sizeof( PartialAcl ))
            {
                goto Cleanup;
            }

            ULONG i;

			for (i = 0; i < numEntries; ++i)
			{
                if (explicitEntries[i].grfAccessPermissions != DefaultFileAcls[i].grfAccessPermissions ||
                    explicitEntries[i].Trustee.TrusteeForm != TRUSTEE_IS_NAME ||
                    wcscmp( explicitEntries[i].Trustee.ptstrName, DefaultFileAcls[i].trusteeName ) != 0)
                {
                    goto Cleanup;
                }
			}
        }

        LocalFree(pSD);
    }
*/

    ZeroMemory(&ea, sizeof( ea ));

    // Create a well-known SID for the everyone group.

    if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
                     SECURITY_WORLD_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pUsersSID) )
    {
        goto Cleanup;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    ea[0].grfAccessPermissions = GENERIC_READ | GENERIC_EXECUTE;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[0].Trustee.ptstrName  = (LPWSTR) pUsersSID;

    // Create a SID for the BUILTIN\Administrators group.

    if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0, 0, 0, 0, 0, 0,
                     &pAdminSID) )
    {
        goto Cleanup; 
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the Administrators group full access to the key.

    ea[1].grfAccessPermissions = GENERIC_ALL | READ_CONTROL | DELETE | WRITE_DAC | WRITE_OWNER | SYNCHRONIZE;
    ea[1].grfAccessMode = SET_ACCESS;
    ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[1].Trustee.ptstrName  = (LPWSTR) pAdminSID;


    // Create a SID for the BUILTIN\Power Users group.

    if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_POWER_USERS,
                     0, 0, 0, 0, 0, 0,
                     &pPowerUsersSID) )
    {
        goto Cleanup; 
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the power users group access to read, write, and execute.

    ea[2].grfAccessPermissions = GENERIC_ALL;
    ea[2].grfAccessMode = SET_ACCESS;
    ea[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[2].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[2].Trustee.ptstrName  = (LPWSTR) pPowerUsersSID;

    // Create a SID for the NT AUTHORITY\SYSTEM

    if(! AllocateAndInitializeSid( &SIDAuthNT, 1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pSystemSID) )
    {
        goto Cleanup; 
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the system account full generic access to the key.

    ea[3].grfAccessPermissions = GENERIC_ALL;
    ea[3].grfAccessMode = SET_ACCESS;
    ea[3].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[3].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[3].Trustee.ptstrName  = (LPWSTR) pSystemSID;

    // Create a SID for the creator owner

    if(! AllocateAndInitializeSid( &SIDAuthCreator, 1,
                     SECURITY_CREATOR_OWNER_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pCreatorSID) )
    {
        goto Cleanup; 
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the creator owner full generic access to the key.

    ea[4].grfAccessPermissions = GENERIC_ALL;
    ea[4].grfAccessMode = SET_ACCESS;
    ea[4].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[4].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[4].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[4].Trustee.ptstrName  = (LPWSTR) pCreatorSID;

    // Create a new ACL that contains the new ACEs.

    dwRes = SetEntriesInAclW(sizeof( ea ) / sizeof( EXPLICIT_ACCESS_W ), ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes)
    {
        goto Cleanup;
    }

    // Initialize a security descriptor.  
     
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                             SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSD == NULL)
    { 
        goto Cleanup; 
    } 
     
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
    {  
        goto Cleanup; 
    }

    // Add the ACL to the security descriptor. 
     
    if (!SetSecurityDescriptorDacl(pSD, 
            TRUE,     // fDaclPresent flag   
            pACL, 
            FALSE))   // not a default DACL 
    {  
        goto Cleanup; 
    }
    
    if (!SetFileSecurityW( wszFileName, DACL_SECURITY_INFORMATION, pSD ))
    {
        goto Cleanup;
    }
        
    bReturn = TRUE;

Cleanup:
    if (pUsersSID)
        FreeSid(pUsersSID);
    if (pAdminSID) 
        FreeSid(pAdminSID);
    if (pPowerUsersSID) 
        FreeSid(pPowerUsersSID);
    if (pSystemSID)
        FreeSid(pSystemSID);
    if (pCreatorSID)
        FreeSid(pCreatorSID);
    if (pACL) 
        LocalFree(pACL);
    if (pSD)
        LocalFree(pSD);
    return bReturn;
}


static BOOL SetFileAccess( const LPCWSTR wszFileName )
{
    if (!SetFileAccessWorker( wszFileName ))
        return FALSE;

        
    struct _WIN32_FIND_DATAW findData;
    WCHAR findPath[MAX_PATH];

    wcscpy( findPath, wszFileName );
    wcscat( findPath, L"\\*" );

    HANDLE searchHandle = FindFirstFileW( findPath, &findData );

    if (searchHandle == INVALID_HANDLE_VALUE)
    {
        return TRUE;
    }

    do
    {
        WCHAR newPath[MAX_PATH];

        wcscpy( newPath, wszFileName );
        wcscat( newPath, L"\\" );
        wcscat( newPath, findData.cFileName );

        if ((findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
        {
            if (wcscmp( findData.cFileName, L"." ) != 0 &&
                wcscmp( findData.cFileName, L".." ) != 0 &&
                !SetFileAccess( newPath ))
            {
                return FALSE;
            }
        }
        else
        {
            if (!SetFileAccessWorker( newPath ))
            {
                BOOL isSafe = FALSE;

                for (size_t i = 0; i < sizeof( SafeFilePrefixes ) / sizeof( WCHAR* ); ++i)
                {
                    if (wcsstr( newPath, SafeFilePrefixes[i] ) != NULL)
                    {
                        isSafe = TRUE;
                        break;
                    }
                }

                if (!isSafe)
                    return FALSE;
            }

        }
    }
    while (FindNextFileW( searchHandle, &findData ));

    return TRUE;
}




static BOOL SetRegistryAccessWorker( HKEY regKey )
{
    DWORD dwRes;
    PSID pAdminSID = NULL;
    PSID pUsersSID = NULL;
    PSID pSystemSID = NULL;
    PSID pCreatorSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    EXPLICIT_ACCESS_W ea[4];
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SIDAuthCreator = SECURITY_CREATOR_SID_AUTHORITY;
    BOOL bReturn = FALSE;

    // Detect the default acls and take no action if they are found.

    DWORD requiredSize = 0;

/*
    if (RegGetKeySecurity( regKey, DACL_SECURITY_INFORMATION, NULL, &requiredSize ) != ERROR_SUCCESS)
    {
        pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, requiredSize); 
        if (pSD == NULL)
        { 
            goto Cleanup; 
        } 

        if (RegGetKeySecurity( regKey, DACL_SECURITY_INFORMATION, pSD, &requiredSize ) != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        BOOL bDaclPresent, bDaclDefaulted;
        PACL pDacl;

        if (!GetSecurityDescriptorDacl( pSD, &bDaclPresent, &pDacl, &bDaclDefaulted ))
        {
            goto Cleanup;
        }

        if (bDaclPresent)
        {
            ULONG numEntries;
            EXPLICIT_ACCESS_W* explicitEntries;

            if (GetExplicitEntriesFromAclW( pDacl, &numEntries, &explicitEntries ) != ERROR_SUCCESS)
            {
                goto Cleanup;
            }

            ULONG i;

            if (numEntries > sizeof( DefaultRegistryAcls ) / sizeof( PartialAcl ))
            {
                goto Cleanup;
            }

			for (i = 0; i < numEntries; ++i)
			{
                if (explicitEntries[i].grfAccessPermissions != DefaultRegistryAcls[i].grfAccessPermissions ||
                    explicitEntries[i].Trustee.TrusteeForm != TRUSTEE_IS_NAME ||
                    wcscmp( explicitEntries[i].Trustee.ptstrName, DefaultRegistryAcls[i].trusteeName ) != 0)
                {
                    goto Cleanup;
                }
			}

        }

        LocalFree(pSD);
    }
*/

    ZeroMemory(&ea, sizeof( ea ));
    
    // Create a well-known SID for the everyone group.

    if(! AllocateAndInitializeSid( &SIDAuthWorld, 1,
                     SECURITY_WORLD_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pUsersSID) )
    {
        goto Cleanup;
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    ea[0].grfAccessPermissions = GENERIC_READ;
    ea[0].grfAccessMode = SET_ACCESS;
    ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea[0].Trustee.ptstrName  = (LPWSTR) pUsersSID;

    // Create a SID for the BUILTIN\Administrators group.

    if(! AllocateAndInitializeSid( &SIDAuthNT, 2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0, 0, 0, 0, 0, 0,
                     &pAdminSID) )
    {
        goto Cleanup; 
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the Administrators group full access to the key.

    ea[1].grfAccessPermissions = GENERIC_ALL | READ_CONTROL | DELETE | WRITE_DAC | WRITE_OWNER | SYNCHRONIZE;
    ea[1].grfAccessMode = SET_ACCESS;
    ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[1].Trustee.ptstrName  = (LPWSTR) pAdminSID;

    // Create a SID for the NT AUTHORITY\SYSTEM

    if(! AllocateAndInitializeSid( &SIDAuthNT, 1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pSystemSID) )
    {
        goto Cleanup; 
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the system account full generic access to the key.

    ea[2].grfAccessPermissions = GENERIC_ALL;
    ea[2].grfAccessMode = SET_ACCESS;
    ea[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[2].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[2].Trustee.ptstrName  = (LPWSTR) pSystemSID;

    // Create a SID for the NT AUTHORITY\SYSTEM

    if(! AllocateAndInitializeSid( &SIDAuthCreator, 1,
                     SECURITY_CREATOR_OWNER_RID,
                     0, 0, 0, 0, 0, 0, 0,
                     &pCreatorSID) )
    {
        goto Cleanup; 
    }

    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow the system account full generic access to the key.

    ea[3].grfAccessPermissions = GENERIC_ALL;
    ea[3].grfAccessMode = SET_ACCESS;
    ea[3].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ea[3].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
    ea[3].Trustee.ptstrName  = (LPWSTR) pCreatorSID;

    
    // Create a new ACL that contains the new ACEs.

    dwRes = SetEntriesInAclW(sizeof( ea ) / sizeof( EXPLICIT_ACCESS_W ), ea, NULL, &pACL);
    if (ERROR_SUCCESS != dwRes)
    {
        goto Cleanup;
    }

    // Initialize a security descriptor.  
     
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                             SECURITY_DESCRIPTOR_MIN_LENGTH); 
    if (pSD == NULL)
    { 
        goto Cleanup; 
    } 
     
    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
    {  
        goto Cleanup; 
    }

    // Add the ACL to the security descriptor. 
     
    if (!SetSecurityDescriptorDacl(pSD, 
            TRUE,     // fDaclPresent flag   
            pACL, 
            FALSE))   // not a default DACL 
    {  
        goto Cleanup; 
    }
    
    if (RegSetKeySecurity( regKey, DACL_SECURITY_INFORMATION, pSD ) != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
        
    bReturn = TRUE;

Cleanup:
    if (pUsersSID)
        FreeSid(pUsersSID);
    if (pAdminSID) 
        FreeSid(pAdminSID);
    if (pSystemSID)
        FreeSid(pSystemSID);
    if (pCreatorSID)
        FreeSid(pCreatorSID);
    if (pACL) 
        LocalFree(pACL);
    if (pSD)
        LocalFree(pSD);
    return bReturn;
}




static BOOL SetRegistryAccess( HKEY rootKey, const LPWSTR subKey )
{
    HKEY regKey = NULL;
    BOOL retval = FALSE;
    BOOL keyLoopDone = FALSE;
    DWORD index = 0;

    if (RegOpenKeyW( rootKey, subKey, &regKey ) != ERROR_SUCCESS)
        goto CLEANUP;

    if (!SetRegistryAccessWorker( regKey ))
        goto CLEANUP;

    WCHAR findSubKey[1024];
    WCHAR newSubKey[4096];

    do
    {
        LONG retval = RegEnumKeyW( regKey, index++, findSubKey, 1024 );

        switch (retval)
        {
        case ERROR_SUCCESS:
            wcscpy( newSubKey, subKey );
            wcscat( newSubKey, L"\\" );
            wcscat( newSubKey, findSubKey );

            if (!SetRegistryAccess( rootKey, newSubKey ))
                goto CLEANUP;

            break;

        case ERROR_NO_MORE_ITEMS:
            keyLoopDone = TRUE;
            break;

        default:
            goto CLEANUP;
            break;
        };
    }
    while (!keyLoopDone);

    retval = TRUE;

CLEANUP:
    if (regKey != NULL)
        RegCloseKey( regKey );

    return retval;
}



static BOOL IsNT4( void )
{
    DWORD dwVersion = GetVersion();

    if (dwVersion >= 0x80000000)
        return FALSE;

    if (LOWORD(dwVersion) != 4)
        return FALSE;

    return TRUE;
}

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    // This is only intended to run on NT4.

    if (!IsNT4())
        return 0;
  
    WCHAR windowsDirectory[MAX_PATH];
    WCHAR frameworkDirectory[MAX_PATH];
    WCHAR mscoreePath[MAX_PATH];

    // Grab the name of the windows directory

    UINT windowsDirectoryLength = GetWindowsDirectoryW( windowsDirectory, MAX_PATH );

    if (windowsDirectoryLength == 0 ||
        windowsDirectoryLength > MAX_PATH)
        return -1;

    if (windowsDirectory[windowsDirectoryLength-1] != L'\\')
    {
        wcscat( windowsDirectory, L"\\" );
    }

    // Build of the paths to the framework install directory
    // and the mscoree directory.

    wcscpy( frameworkDirectory, windowsDirectory );
    wcscat( frameworkDirectory, frameworkSubPath );

    wcscpy( mscoreePath, windowsDirectory );
    wcscat( mscoreePath, mscoreeSubPath );

    if (!SetFileAccess( frameworkDirectory ))
        return -1;

    if (!SetFileAccess( mscoreePath ))
        return -1;

    WCHAR* frameworkSubKeyLocal = frameworkSubKey;

    if (!SetRegistryAccess( frameworkRootKey, frameworkSubKeyLocal ))
        return -1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\setnt4acl\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_APP
#define VER_INTERNALNAME_STR    "clrnt4su.exe"
#define VER_FILEDESCRIPTION_STR "NT4 NDP Security Provider\0"
#define VER_ORIGFILENAME_STR    "clrnt4su.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\setupcalib\setupcalib.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <tchar.h>
#include <windows.h>
#include "msiquery.h"
#include <iostream>

using namespace std;

bool FWriteToLog( MSIHANDLE hSession, LPCTSTR ctszMessage );
bool FWriteToLog1( MSIHANDLE hSession, LPCTSTR ctszFormat, LPCTSTR ctszArg );
void DeleteTreeByDarwin( MSIHANDLE hInstall, LPCTSTR pszDir, LPCTSTR pszComp );

typedef basic_string<TCHAR> tstring;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\setregkeyvalue\setregkeyvalue.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <windows.h>
#include <tchar.h>
#include <msiquery.h>
#include <stdio.h>
#include "..\setupcalib\setupcalib.h"

const DWORD MAX_VALUE_LENGTH = 1024;

extern "C" __declspec(dllexport) UINT __stdcall SetRegKeyValue(MSIHANDLE hInstall)

{
    UINT  uRetCode = ERROR_FUNCTION_NOT_CALLED ;
    HKEY hKey;
    DWORD dwRegValue = 0;
    TCHAR* pszStubPath = NULL;

    FWriteToLog(hInstall, _T("STATUS: Starting SetRegKeyValue CA."));

    TCHAR szKey[] = _T("SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\{89B4C1CD-B018-4511-B0A1-5476DBF70820}");
    TCHAR szIsInstalledValue[] = _T("IsInstalled");
    TCHAR szStubPathValue[] = _T("StubPath");

    if (ERROR_SUCCESS != (uRetCode = RegOpenKey(HKEY_LOCAL_MACHINE, szKey, &hKey)))
    {
        FWriteToLog(hInstall, _T("ERROR: Could not open the target reg key for modification!"));
        FWriteToLog(hInstall, _T("ERROR: CA Failed!"));
        return ERROR_INSTALL_FAILURE;
    }

    // IsInstalled DWORD change
    // ------------------------
    dwRegValue = 0x00000000;
    if (ERROR_SUCCESS != (uRetCode = RegSetValueEx(hKey, szIsInstalledValue, NULL, REG_DWORD, (BYTE *)&dwRegValue, sizeof(DWORD))))
    {
        FWriteToLog(hInstall, _T("ERROR: Could not set the value of the target reg key(IsInstalled value change)!"));
        FWriteToLog(hInstall, _T("ERROR: CA Failed!"));
        RegCloseKey(hKey);
        return ERROR_INSTALL_FAILURE;
    }

    // StubPath Uninstall changes
    // --------------------------
    DWORD dwBuffSize = MAX_VALUE_LENGTH;  // Initial value
    DWORD dwType = REG_SZ;
    DWORD dwSize = 0;

    pszStubPath = new TCHAR[dwBuffSize + 2];
    memset(pszStubPath, 0, (dwBuffSize + 2)* sizeof(TCHAR));
    dwSize = dwBuffSize * sizeof(TCHAR);
    uRetCode = RegQueryValueEx(hKey, szStubPathValue, NULL, &dwType, (LPBYTE)pszStubPath, &dwSize);
    if (uRetCode == ERROR_MORE_DATA)
    {
        delete []pszStubPath;
        dwBuffSize = dwSize;
        pszStubPath = new TCHAR[ dwBuffSize + 2 ];
        memset(pszStubPath, 0, (dwBuffSize + 2)* sizeof(TCHAR));
        uRetCode = RegQueryValueEx(hKey, szStubPathValue, NULL, &dwType, (LPBYTE)pszStubPath, &dwSize);
    }

    if (ERROR_SUCCESS != uRetCode)
    {
        FWriteToLog(hInstall, _T("ERROR: Could not query the value of the target reg key(Stub Path Configuration)!"));
        FWriteToLog(hInstall, _T("ERROR: CA Failed!"));
        RegCloseKey(hKey);
        return ERROR_INSTALL_FAILURE;
    }
    DWORD dwDestLen = _tcslen(pszStubPath) + 2;

    TCHAR * pszDest = new TCHAR[dwDestLen + 2];
    memset(pszDest, 0, (dwDestLen + 2) * sizeof(TCHAR));

    TCHAR * pTmp = _tcsstr(pszStubPath, _T(","));
    if (pTmp == NULL)
    {
        FWriteToLog(hInstall, _T("ERROR: Malformed value in key(Stub Path Configuration)!"));
        FWriteToLog(hInstall, _T("ERROR: CA Failed!"));
        RegCloseKey(hKey);
        return ERROR_INSTALL_FAILURE;
    }

    *pTmp = _T('\0'); // Terminate it
    _tcsncpy(pszDest, pszStubPath, dwDestLen * sizeof(TCHAR));
    _tcsncat(pszDest, _T(",Uninstall"), (dwDestLen - _tcslen(pszDest)) * sizeof(TCHAR));

    if (ERROR_SUCCESS != (uRetCode = RegSetValueEx(hKey, szStubPathValue, NULL, REG_SZ, (LPBYTE)pszDest, sizeof(TCHAR) * _tcslen(pszDest))))
    {
        FWriteToLog(hInstall, _T("ERROR: Could not write the value of the target reg key(Stub Path Configuration)!"));
        FWriteToLog(hInstall, _T("ERROR: CA Failed!"));
        RegCloseKey(hKey);
        return ERROR_INSTALL_FAILURE;
    }

    RegCloseKey(hKey);
    FWriteToLog(hInstall, _T("STATUS: Custom Action succeeded."));
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempdef\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by URTTempDef.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\setregkeyvalue\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "SetRegKeyValue.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Custom Action\0"
#define VER_ORIGFILENAME_STR    "SetRegKeyValue.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\setpropforadv\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "SetPropForAdv.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Custom Action\0"
#define VER_ORIGFILENAME_STR    "SetPropForAdv.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\setpropforadv\setpropforadv.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ==========================================================================
// DetectBeta.cpp
//
// Purpose:
//  Detects NDP beta component (mscoree.dll) and block installation. Displays
//  a messagebox with products that installed beta NDP components.
// ==========================================================================
#include "SetupCALib.h"
#include <msiquery.h>
#include <crtdbg.h>
#include <string>

#ifndef NumItems
#define NumItems(s) (sizeof(s) / sizeof(s[0]))
#endif

#define EMPTY_BUFFER { _T('\0') }
#define LENGTH(A) (sizeof(A)/sizeof(A[0]))

typedef struct TAG_FILE_VERSION
    {
        int   FileVersionMS_High;
        int   FileVersionMS_Low;
        int   FileVersionLS_High;
        int   FileVersionLS_Low;
    }
    FILE_VERSION, *PFILE_VERSION;

// This is the property we need to set
LPCTSTR szProperties[] = 
{
    _T("MOFCOMP_EXE.3643236F_FC70_11D3_A536_0090278A1BB8"),
    _T("MMCFOUND.3643236F_FC70_11D3_A536_0090278A1BB8")
};
LPCTSTR szFileNames[] = 
{
    _T("mofcomp.exe"),
    _T("mmc.exe")
};
LPCTSTR szFileSubfolders[] = 
{
    _T("\\wbem\\"), // file is located under [SystemDir]\wbeb
    _T("\\")        // file is located under [SystemDir]
};
LPCTSTR szVersions[] = 
{
    _T("1.50.1085.0"),
    _T("5.00.2153.1")
};

// ==========================================================================
//  Name: ConvertVersionToINT()
//
//  Purpose:
//  Converts a string version into 4 parts of integers
//  Inputs:
//    lpVersionString - A input version string
//  Outputs:
//  pFileVersion - A structure that stores the version in to 4 integers
//  Returns
//    true  - if success
//    false - if failed                     
// ==========================================================================
bool ConvertVersionToINT( LPCTSTR lpVersionString, PFILE_VERSION pFileVersion )
{
    LPTSTR lpToken  = NULL;
    TCHAR tszVersionString[50] = {_T('\0')};
    bool bRet = true;

    _tcscpy(tszVersionString, lpVersionString);

    lpToken = _tcstok(tszVersionString, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionMS_High = atoi(lpToken);
    }

    lpToken = _tcstok(NULL, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionMS_Low = atoi(lpToken);
    }

    lpToken = _tcstok(NULL, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionLS_High = atoi(lpToken);
    }

    lpToken = _tcstok(NULL, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionLS_Low = atoi(lpToken);
    }

    return bRet;
}

// ==========================================================================
//  Name: VersionCompare()
//
//  Purpose:
//  Compare two version string.
//  Inputs:
//    lpVersion1 - String of first version to compare
//    lpVersion2 - String of second version to compare
//  Outputs:
//  Returns
//    -1 if lpVersion1 < lpVersion2
//     0 if lpVersion1 = lpVersion2
//     1 if lpVersion1 > lpVersion2
//   -99 if ERROR occurred                         
// ==========================================================================
int VersionCompare( LPCTSTR lpVersion1, LPCTSTR lpVersion2 )
{
    FILE_VERSION Version1;
    FILE_VERSION Version2;
    int          iRet = 0;

    if ( !ConvertVersionToINT(lpVersion1, &Version1) )
    {
        return -99;
    }

    if ( !ConvertVersionToINT(lpVersion2, &Version2) )
    {
        return -99; 
    }

    if ( Version1.FileVersionMS_High > Version2.FileVersionMS_High )
    {
        iRet = 1;
    }
    else if ( Version1.FileVersionMS_High < Version2.FileVersionMS_High )
    {
        iRet = -1;
    }

    if ( 0 == iRet )
    {
        if ( Version1.FileVersionMS_Low > Version2.FileVersionMS_Low )
        {
            iRet = 1;
        }
        else if ( Version1.FileVersionMS_Low < Version2.FileVersionMS_Low )
        {
            iRet = -1;
        }
    }

    if ( 0 == iRet )
    {
        if ( Version1.FileVersionLS_High > Version2.FileVersionLS_High )
        {
            iRet = 1;
        }
        else if ( Version1.FileVersionLS_High < Version2.FileVersionLS_High )
        {
            iRet = -1;
        }
    }

    if ( 0 == iRet )
    {
        if ( Version1.FileVersionLS_Low > Version2.FileVersionLS_Low )
        {
            iRet = 1;
        }
        else if ( Version1.FileVersionLS_Low < Version2.FileVersionLS_Low )
        {
            iRet = -1;
        }
    }

    return iRet;
}

// ==========================================================================
// LoadOleacc()
//
// Purpose:
//  calls LoadLibrary( "oleacc.dll" ) and frees it for W2K
// Inputs:
//  MSIHANDLE hInstall: darwin handle used for logging
// Outputs:
//  none
// ==========================================================================
void LoadOleacc( MSIHANDLE hInstall )
{
    OSVERSIONINFO osvi ;

    osvi.dwOSVersionInfoSize = sizeof(osvi) ;
    GetVersionEx(&osvi) ;

    // If the system is running Win2K,
    if ( (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osvi.dwMajorVersion == 5) && (osvi.dwMinorVersion == 0) )
    {
        // Do a Load Library on oleacc.dll so that we can register it. URT Bug 32050
        HINSTANCE hOleacc ;
        
        FWriteToLog( hInstall, _T("\tSTATUS: Trying to load oleacc.dll") );
        hOleacc = ::LoadLibrary( "oleacc.dll" ) ;

        if( hOleacc )
        {
            // Success.  Close handle and proceed to install.
            FWriteToLog( hInstall, _T("\tSTATUS: Successfully loaded oleacc.dll") );
            ::FreeLibrary( hOleacc ) ;
        }
        else 
        {
            // Load Library Failed.
            throw( _T("\tERROR: Cannot load oleacc.dll") );
        }
    }
}

// ==========================================================================
// SetPropForAdv()
//
// Purpose:
//  This exported function is called by darwin when the CA runs. It does the job
//  of AppSearch to set property MOFCOMP_EXE.3643236F_FC70_11D3_A536_0090278A1BB8.
//  We do this to support Advertised installation since AppSearch runs only once
//  on client side and those custom properties are not passed to server side.
// Inputs:
//  hInstall            Windows Install Handle to current installation session
// Dependencies:
//  Requires Windows Installer & that an install be running.
// Notes:
// ==========================================================================
extern "C" UINT __stdcall SetPropForAdv( MSIHANDLE hInstall )
{
    TCHAR szSystemFolder[MAX_PATH+1] = EMPTY_BUFFER;
    DWORD dwLen = 0;
    DWORD dwLenV = 0;
    TCHAR szVersion[24] = EMPTY_BUFFER;
    TCHAR szLang[_MAX_PATH+1] = EMPTY_BUFFER;
    UINT  uRetCode = ERROR_INSTALL_FAILURE;
    UINT nRet = E_FAIL;

    TCHAR szFullPath[_MAX_PATH+1] = EMPTY_BUFFER;
    

    FWriteToLog( hInstall, _T("\tSTATUS: SetPropForAdv started") );
    _ASSERTE( hInstall );

try
{
    UINT nNumChars = GetSystemDirectory( szSystemFolder, NumItems(szSystemFolder));
    if (nNumChars == 0 || nNumChars > NumItems(szSystemFolder) )
    {
        throw( _T("\tERROR: Cannot get System directory") );
    }

    for (int i = 0; i < sizeof(szProperties) / sizeof(szProperties[0]); i++)
    {
        ::_tcscpy(szFullPath, szSystemFolder);
        ::_tcsncat(szFullPath, szFileSubfolders[i], ((_MAX_PATH+1) - ::_tcslen(szFileSubfolders[i])));
        ::_tcsncat(szFullPath, szFileNames[i], ((_MAX_PATH+1) - ::_tcslen(szFileNames[i])));
               
        FWriteToLog1( hInstall, _T("\tSTATUS: Checking Version of %s"), szFullPath );
        FWriteToLog1( hInstall, _T("\tSTATUS: Comparing the version of the file with %s"), szVersions[i] );

        dwLenV = LENGTH( szVersion );
        dwLen = LENGTH( szLang );
        nRet = MsiGetFileVersion( szFullPath, szVersion, &dwLenV, szLang, &dwLen );

        if ( ERROR_SUCCESS != nRet )
        {
            FWriteToLog1( hInstall, _T("\tSTATUS: Cannot get version of %s. Probably it does not exist."), szFileNames[i] );
        }
        else
        {
            FWriteToLog1( hInstall, _T("\tSTATUS: Version: %s"), szVersion );
            FWriteToLog1( hInstall, _T("\tSTATUS: Language: %s"), szLang );

            int nRetVersion = VersionCompare( szVersion, szVersions[i] );
            
            if ( -99 == nRetVersion )
            {
                throw( _T("\tERROR: Version comparison failed") );
            }
            else if ( -1 == nRetVersion )
            {
                FWriteToLog1( hInstall, _T("\tSTATUS: Version of the file is older than %s"), szVersions[i] );
            }
            else
            {   // set Property since version is ok
                FWriteToLog1( hInstall, _T("\tSTATUS: Version of the file is equal or newer than %s"), szVersions[i]);
                FWriteToLog1( hInstall, _T("\tSTATUS: Setting Property %s"), szProperties[i]  );
            
                if ( ERROR_SUCCESS != MsiSetProperty( hInstall, szProperties[i], szFullPath ) )
                {
                    throw( _T("\tERROR: Cannot Set %s property"), szProperties[i] );
                }
            }
        }
    }

    LoadOleacc( hInstall ); // see URT bug 32050

    uRetCode = ERROR_SUCCESS;
    FWriteToLog( hInstall, _T("\tSTATUS: SetPropForAdv ended successfully") );
}
catch( TCHAR *pszMsg )
{
    uRetCode = ERROR_INSTALL_FAILURE; // return failure to darwin
    FWriteToLog( hInstall, pszMsg );
    FWriteToLog( hInstall, _T("\tERROR: SetPropForAdv failed") );
}
    return uRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\setupcalib\setupcalib.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ==========================================================================
// SetupCALib.cpp
//
// Purpose:
//  This contains library functions used by custom action DLLs
// ==========================================================================
#pragma warning (disable:4786) // for string more than 512 warnings

#include <queue>
#include <tchar.h>
#include "SetupCALib.h"

#include <windows.h>
#include "msiquery.h"
#include <crtdbg.h>

using namespace std;

const TCHAR QRY[]            = _T("Insert into RemoveFile(FileKey,Component_,FileName,DirProperty,InstallMode) values(?,?,?,?,?) TEMPORARY");
const TCHAR FILEKEY[]        = _T("FileKey.%s.%X");
const TCHAR DIRPROPERTY[]    = _T("DirProp.%s.%X");

LPCTSTR g_pszComp = NULL;

#define LENGTH(x) sizeof(x)/sizeof(x[0])
#define EMPTY_BUFFER { _T('\0') }


// ==========================================================================
// FWriteToLog()
//
// Purpose:
//  Write given string to the Windows Installer log file for the given install
//  installation session
// Inputs:
//  hSession            Windows Install Handle to current installation session
//  tszMessage          Const pointer to a string.
// Outputs:
//  Returns true for success, and false if it fails.
//  If successful, then the string (tszMessage) is written to the log file.
// Dependencies:
//  Requires Windows Installer & that an install be running.
// Notes:
// ==========================================================================
bool FWriteToLog( MSIHANDLE hSession, LPCTSTR pszMessage )
{
    _ASSERTE( NULL != hSession );
    _ASSERTE( NULL != pszMessage );

    PMSIHANDLE hMsgRec = ::MsiCreateRecord( 1 );
    bool bRet = false;

    if( ERROR_SUCCESS == ::MsiRecordSetString( hMsgRec, 0, pszMessage ) )
    {
       if( IDOK == ::MsiProcessMessage( hSession, INSTALLMESSAGE_INFO, hMsgRec ) )
       {
            bRet = true;
       }
    }

    _RPTF1(_CRT_WARN, "%s\n", pszMessage );
    return bRet;
}

// ==========================================================================
// FWriteToLog() with string argument
//
// Purpose:
//  Write given string to the Windows Installer log file for the given install
//  installation session
// Inputs:
//  hSession            Windows Install Handle to current installation session
//  tszMessage          Const pointer to a format string.
//  ctszArg             Argument to be replaced
// Outputs:
//  Returns true for success, and false if it fails.
//  If successful, then the string (tszMessage) is written to the log file.
// Dependencies:
//  Requires Windows Installer & that an install be running.
// Notes:
// ==========================================================================
bool FWriteToLog1( MSIHANDLE hSession, LPCTSTR pszFormat, LPCTSTR pszArg )
{
    bool bRet = false;

    _ASSERTE( NULL != hSession );
    _ASSERTE( NULL != pszFormat );
    _ASSERTE( NULL != pszArg );

    LPTSTR pszMsg = new TCHAR[ _tcslen( pszFormat ) + _tcslen( pszArg ) + 1 ];
    if ( pszMsg )
    {
        PMSIHANDLE hMsgRec = MsiCreateRecord( 1 );

        _stprintf( pszMsg, pszFormat, pszArg );
        if( ERROR_SUCCESS == ::MsiRecordSetString( hMsgRec, 0, pszMsg ) )
        {
           if( IDOK == ::MsiProcessMessage( hSession, INSTALLMESSAGE_INFO, hMsgRec ) )
           {
                bRet = true;
           }
        }

        _RPTF1( _CRT_WARN, "%s\n", pszMsg );
        delete [] pszMsg;
    }

    return bRet;
}

// ==========================================================================
// AddToRemoveFile()
//
// Purpose:
//  Add the passed Directory into RemoveFile table in msi so that this directory
//  can be removed.
//
// Inputs:
//  hInstance           Windows Install Handle to current installation session
//  ctszDir             Directory to remove
// Dependencies:
//  Requires Windows Installer & that an install be running.
// Notes:
// ==========================================================================
void AddToRemoveFile( MSIHANDLE hInstance, LPCTSTR pszDir, LPCTSTR pszComp )
{
    PMSIHANDLE hMsi(0);
	PMSIHANDLE hView(0);
    PMSIHANDLE hRec(0);
    UINT uRet = ERROR_SUCCESS;
    static unsigned long nFileKeyID = 0; // This should be enough numbers
    static unsigned long nDirPropID = 0;
    TCHAR szFileKey[73] = { _T('\0') };
    TCHAR szDirProperty[73] = { _T('\0') };

try
{
    _ASSERTE( NULL != hInstance );
    _ASSERTE( NULL != pszDir );
    _ASSERTE( _T('\0') != *pszDir );
    _ASSERTE( NULL != pszComp );
    _ASSERTE( _T('\0') != *pszComp );

    FWriteToLog( hInstance,pszDir );

    hMsi = MsiGetActiveDatabase( hInstance );
	if ( 0 == hMsi )
    {
        throw( _T("\tError: MsiGetActiveDatabase failed") ); 
    }

    uRet = MsiDatabaseOpenView(hMsi, QRY, &hView);
	if ( ERROR_SUCCESS != uRet )
    {
        throw( _T("\tError: MsiDatabaseOpenView failed") ); 
    }

    hRec = MsiCreateRecord( 5 );
    if ( NULL == hRec )
    {
        throw( _T("\tError: MsiCreateRecord failed") ); 
    }

    ++nDirPropID;
    ++nFileKeyID;

    _stprintf( szFileKey, FILEKEY, g_pszComp, nFileKeyID );
    _stprintf( szDirProperty, DIRPROPERTY, g_pszComp, nDirPropID );

    if ( ERROR_SUCCESS != MsiSetProperty( hInstance, szDirProperty, pszDir ) )
    {
        throw( _T("\tError: MsiSetProperty failed") ); 
    }

    if ( (ERROR_SUCCESS != MsiRecordSetString( hRec, 1, szFileKey ) ) ||
         (ERROR_SUCCESS != MsiRecordSetString( hRec, 2, pszComp ) ) ||
         (ERROR_SUCCESS != MsiRecordSetString( hRec, 3, _T("*") ) ) ||
         (ERROR_SUCCESS != MsiRecordSetString( hRec, 4, szDirProperty ) ) ||
         (ERROR_SUCCESS != MsiRecordSetInteger( hRec, 5, 3 ) ) )
    {
        throw( _T("\tError: MsiRecordSetString failed") ); 
    }

    uRet = MsiViewExecute( hView, hRec );
	if (uRet != ERROR_SUCCESS) 
    {
        throw( _T("\tError: MsiViewExecute failed") ); 
	}

    ++nFileKeyID;
    _stprintf( szFileKey, FILEKEY, g_pszComp, nFileKeyID );

    if ( (ERROR_SUCCESS != MsiRecordSetString( hRec, 1, szFileKey ) ) ||
         (ERROR_SUCCESS != MsiRecordSetString( hRec, 3, _T("") ) ) )
    {
        throw( _T("\tError: MsiRecordSetString failed") ); 
    }

    uRet = MsiViewExecute( hView, hRec );
	if (uRet != ERROR_SUCCESS)
    {
        throw( _T("\tError: MsiViewExecute failed") ); 
	}

	uRet = MsiDatabaseCommit(hMsi);
	if (uRet != ERROR_SUCCESS) 
    {
        throw( _T("\tError: MsiDatabaseCommit failed") ); 
	}
}
catch( LPTSTR pszMsg )
{
    FWriteToLog( hInstance, pszMsg );
    FWriteToLog( hInstance, _T("\tError: AddToRemoveFile failed") );
}

    if ( hView )
    {
		MsiViewClose(hView);
    }
	return;
}

// ==========================================================================
// DeleteTreeByDarwin()
//
// Purpose:
//  Walk down a given directory to find all sub-directories and call AddToRemoveFile()
//  This is non-recursive version. Use STL queue.
//
// Inputs:
//  hInstance           Windows Install Handle to current installation session
//  pszDir              Directory to remove
//  pszComp             Component to reference
// Dependencies:
//  Requires Windows Installer & that an install be running.
// Notes:
// ==========================================================================
void DeleteTreeByDarwin( MSIHANDLE hInstall, LPCTSTR pszDir, LPCTSTR pszComp )
{
    _ASSERTE( NULL != hInstall );
    _ASSERTE( NULL != pszDir );
    _ASSERTE( NULL != pszComp );
    _ASSERTE( _T('\0') != *pszDir );
    _ASSERTE( _T('\0') != *pszComp );

    g_pszComp = pszComp; // save Component key to generate unique FileKey and DirProp

    queue<tstring> queDir;
	WIN32_FIND_DATA fd;
	BOOL fOk = FALSE;
    tstring strDir, strSubDir;
	HANDLE hFind = NULL;

    strDir = pszDir;
    queDir.push( strDir );
    while( !queDir.empty() )
    {        
        strDir = queDir.front();
        queDir.pop();

        AddToRemoveFile( hInstall, (LPCTSTR)strDir.c_str(), pszComp );

        strSubDir = strDir;
        strSubDir += _T("\\*");
	    hFind = FindFirstFile( (LPCTSTR)strSubDir.c_str(), &fd );
	    fOk = ( INVALID_HANDLE_VALUE != hFind );
	    while( fOk )
	    {
		    if ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            {
		        if ( 0 != _tcscmp( fd.cFileName, _T(".") ) &&
			         0 != _tcscmp( fd.cFileName, _T("..") ) )
		        {
                    strSubDir = strDir;
                    strSubDir += _T("\\");
                    strSubDir += fd.cFileName;

                    queDir.push( strSubDir ); // add sub-directories into queue
		        }
            }
	        fOk = FindNextFile( hFind, &fd );
	    }
	    FindClose( hFind );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempdef\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdafx.cpp : source file that includes just the standard includes
//	setupbld.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempdef\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9A1ADB9F_BFB7_11D2_9301_00E02914334C__INCLUDED_)
#define AFX_STDAFX_H__9A1ADB9F_BFB7_11D2_9301_00E02914334C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include "msi.h"
#include "MsiDefs.h"
#include "msiquery.h"
#include  <io.h>
#include  <stdlib.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9A1ADB9F_BFB7_11D2_9301_00E02914334C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempdef\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "URTTempDef.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Custom Action\0"
#define VER_ORIGFILENAME_STR    "URTTempDef.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempdef\urttempdef.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#if !defined(URTTempDef_H)
#define URTTempDef_H

#ifndef NumItems
#define NumItems(s) (sizeof(s) / sizeof(s[0]))
#endif

//
// constant declarations
//
#define MSINULL 0L

BOOL CleanUp(LPTSTR lpCAData);
bool DeleteURTTempFile( MSIHANDLE hInstall, LPTSTR lpTempPath, LPTSTR lpCabPath, LPTSTR lpExtractPath );
bool FWriteToLog( MSIHANDLE hSession, LPCTSTR ctszMessage );
bool SmartDelete(MSIHANDLE hInstall,LPCTSTR lpFullFileName, LPCTSTR lpFilePath);
bool osVersionNT(MSIHANDLE hInstall);
bool VerifyHash( MSIHANDLE hInstall, LPTSTR lpFile, LPTSTR lpFileHash );

#endif // defined URTTempProc_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempdef\vscrypt.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ==========================================================================
// Name:     VsCrypt.h
// Owner:    JeremyRo
// Purpose:  Classes/functions for creating cryptographic hashes.
//
// History:
//  02/19/2002, JeremyRo:  Created
//  02/20/2002, JeremyRo:  Added 'VsCryptHashValue::CopyHashValueToString()' 
//                         member function.
//
// ==========================================================================

#include "stdafx.h"

#if !defined(__DDRT_VsCrypt_H)
#define __DDRT_VsCrypt_H


//
// Make sure that CryptAPI is actually included in 
// headers.  Its possible that previous inclusion
// could have defined constants that will exclude
// Crypto, so detect that & undefine them.
//
#if defined(__WINCRYPT_H__) && !defined(PROV_RSA_FULL)

#undef __WINCRYPT_H__
#if (_WIN32_WINNT < 0x0400)
#undef _WIN32_WINNT
#endif // (_WIN32_WINNT < 0x0400)

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif  // !defined(_WIN32_WINNT)

#endif  // defined(__WINCRYPT_H__) && !defined(PROV_RSA_FULL)

#include <wincrypt.h>
#include <crtdbg.h>
#include <tchar.h>


// Classes

// ==========================================================================
// class VsCryptProvider
//
// Purpose:
//  Wrap CryptAPI Provider functionality to create/release the base
//  cryptographic provider.  (We use the v1.0 provder for compatibility on 
//  Win9x systems).
//
// Dependencies:
//  CryptAPI (crypt32.lib)
// Notes:
// ==========================================================================
class VsCryptProvider
{
    public:
        VsCryptProvider();
        virtual ~VsCryptProvider();
        bool Init( void );
        operator HCRYPTPROV() const;

    protected:
        HCRYPTPROV m_hProvider;
};


// ==========================================================================
// class VsCryptHash
//
// Purpose:
//  Wrap CryptAPI Hash functionality to create/destroy, and calculate SHA
//  hash for arbitrary data.
//
// Dependencies:
//  CryptAPI (crypt32.lib)
// Notes:
// ==========================================================================
class VsCryptHash
{
    public:
        VsCryptHash( HCRYPTPROV hProv );
        virtual ~VsCryptHash();

        bool HashData( BYTE* pbData, DWORD dwDataLen );
        operator HCRYPTHASH() const;

    protected:
        HCRYPTHASH m_hHash;

    private:
        VsCryptHash() : m_hHash( NULL ){}
};




// ==========================================================================
// class VsCryptHashValue
//
// Purpose:
//  Represents an arbitrary hash value of a Crypto- HCRYPTHASH/VsCryptHash
//  instance.  This class stores the value/size (in bytes) of the hash.
//
// Dependencies:
//  CryptAPI (crypt32.lib)
// Notes:
// ==========================================================================
class VsCryptHashValue
{
    public:
        VsCryptHashValue() 
            : m_nHashDataSize( 0 )
            , m_pbHashData( NULL )
        {}

        inline VsCryptHashValue( HCRYPTHASH hHash )
        {
            *this = hHash;
        }

        virtual ~VsCryptHashValue();
        VsCryptHashValue& operator=( HCRYPTHASH hHash );

        inline const BYTE * GetHashValue(void) const
        { 
            return const_cast<const BYTE*>(m_pbHashData); 
        }
        inline size_t GetHashValueSize(void) const
        { 
            return m_nHashDataSize; 
        }

        bool CopyHashValueToString( LPTSTR * ptszNewString );

    protected:
        BYTE*   m_pbHashData;
        size_t  m_nHashDataSize;
};


// Prototypes
bool CalcHashForFileSpec( LPCTSTR ctszPath, VsCryptHashValue* phvHashVal );
bool CalcHashForFileHandle( HANDLE hFile, VsCryptHashValue* phvHashVal );


// If we aren't using VSLAB.LIB, then define our own funcitons.
#if !defined(VsLabLib)

// Macros
#if !defined( ASSERT )
#define ASSERT(x)   _MYASSERT((x))
#endif

#if defined(DEBUG) || defined(_DEBUG)
#define _MYASSERT(expr) \
        for(;;) { DWORD dwErr = GetLastError(); \
                if ((0 == expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr))) \
                _CrtDbgBreak(); \
                SetLastError(dwErr); break;}
#else
#define _MYASSERT(expr)
#endif

// Inline functions

// ==========================================================================
// IsEmptyTsz()
//
// Purpose:
//  Deteremine if string (pointer) is null, or points to empty string.
//
// Inputs:
//  [in]  ctsz          Pointer to string (TCHAR).
// Outputs:
//  Return true if pointer is null, or points to null character.
// Dependencies:
//  one
// Notes:
// ==========================================================================
inline bool IsEmptyTsz( LPCTSTR ctsz )
{
    return( (NULL == ctsz) || (_T('\0') == *ctsz) );
}

// Prototypes
bool _DoesFileExist( LPCTSTR szPath );

#endif // !defined(VsLabLib)




#endif // !defined(__DDRT_VsCrypt_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempproc\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by URTTempProc.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempdef\urttempdef.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/******************************************************************************
 * URTTempDef.cpp
 *
 *
 *****************************************************************************/

#include "stdafx.h"
#include "VsCrypt.h"
#include "URTTempDef.h"

#ifndef NumItems
#define NumItems(s) (sizeof(s) / sizeof(s[0]))
#endif

///////////////////////////////////////////////////////////////////////////////
/*

  Name: ExtractSystemTemp()

  This Copies cab from the user temp location to the system temp location and 
  explode the CAB.

*/
///////////////////////////////////////////////////////////////////////////////

extern "C"
UINT __stdcall ExtractSystemTemp(MSIHANDLE hInstall)
{

    // Grab the CustomActionData property
	LPTSTR lpCAData = NULL;
    LPTSTR lpToken  = NULL;

    TCHAR  tszUserTmp[_MAX_PATH+1]             = {_T('\0')};
    TCHAR  tszSystemTmp[_MAX_PATH+1]           = {_T('\0')};
    TCHAR  tszCabName[_MAX_PATH+1]             = {_T('\0')};
    TCHAR  tszExtractTool[_MAX_PATH+1]         = {_T('\0')};
    TCHAR  tszSystemPath[_MAX_PATH+1]          = {_T('\0')};
    TCHAR  tszFullSystemTmp[_MAX_PATH+1]       = {_T('\0')};
    TCHAR  tszFullCabSytemTmp[_MAX_PATH+1]     = {_T('\0')};
    TCHAR  tszFullCabUserTmp[_MAX_PATH+1]      = {_T('\0')};
    TCHAR  tszFullExtractSytemTmp[_MAX_PATH+1] = {_T('\0')};
    TCHAR  tszFullExtractUserTmp[_MAX_PATH+1]  = {_T('\0')};
    TCHAR  szCommand[3 * _MAX_PATH]            = {_T('\0')};
    TCHAR  tszSetProperty[50]                  = {_T('\0')};
    TCHAR  tszLog[_MAX_PATH+1]                 = {_T('\0')};
    TCHAR  tszCabHash[_MAX_PATH+1]             = {_T('\0')};
    TCHAR  tszExtractHash[_MAX_PATH+1]         = {_T('\0')};


    DWORD  dwSize    = 0;
    DWORD  dwWait    = 0;
    UINT   uiError   = ERROR_SUCCESS;
    bool   bContinue = true;

    STARTUPINFO           si;
    PROCESS_INFORMATION   pi;

    // Set the size for the Property
    MsiGetProperty(hInstall, _T("CustomActionData"), _T(""), &dwSize);
	
    // Create buffer for the property
    lpCAData = new TCHAR[++dwSize];

    if (NULL == lpCAData)
    {
		return ERROR_INSTALL_FAILURE;
    }
	
    // 1) Get property using the new buffer
    if ( ERROR_SUCCESS != MsiGetProperty( hInstall,
                                          _T("CustomActionData"),
                                          lpCAData,
                                          &dwSize ) )
	{
		uiError = ERROR_INSTALL_FAILURE;
	}
    else
    {
        // Get user temp location
        lpToken = _tcstok(lpCAData, _T(";"));

        if (NULL == lpToken)
        {
            uiError = ERROR_INSTALL_FAILURE;
        }
        else
        {
            _tcscpy(tszUserTmp, lpToken);
        }

        // Get system temp location
        lpToken = _tcstok(NULL, _T(";"));

        if (NULL == lpToken)
        {
            uiError = ERROR_INSTALL_FAILURE;
        }
        else
        {
            _tcscpy(tszSystemTmp, lpToken);
        }

        // Get CAB Name
        lpToken = _tcstok(NULL, _T(";"));

        if (NULL == lpToken)
        {
            uiError = ERROR_INSTALL_FAILURE;
        }
        else
        {
            _tcscpy(tszCabName, lpToken);
        }

        // Get extract tool name
        lpToken = _tcstok(NULL, _T(";"));

        if (NULL == lpToken)
        {
            uiError = ERROR_INSTALL_FAILURE;
        }
        else
        {
            _tcscpy(tszExtractTool, lpToken);
        }

        // Get Darwin Property that was set
        lpToken = _tcstok(NULL, _T(";"));

        if (NULL == lpToken)
        {
            uiError = ERROR_INSTALL_FAILURE;
        }
        else
        {
            _tcscpy(tszSetProperty, lpToken);
            _stprintf( tszLog, _T("\tSTATUS: property CARRYINGNDP : %s"), tszSetProperty);
            FWriteToLog (hInstall, tszLog);
        }

        // Get Hash for the CAB
        lpToken = _tcstok(NULL, _T(";"));

        if (NULL == lpToken)
        {
            uiError = ERROR_INSTALL_FAILURE;
        }
        else
        {
            _tcscpy(tszCabHash, lpToken);
        }

        // Get Hash for the Extract Tool
        lpToken = _tcstok(NULL, _T(";"));

        if (NULL == lpToken)
        {
            uiError = ERROR_INSTALL_FAILURE;
        }
        else
        {
            _tcscpy(tszExtractHash, lpToken);
        }

    }

    // 2) Generate Filename and Path in SystemTmp
    if (ERROR_SUCCESS == uiError)
    {
        // Find the <SYSTEM> path
        UINT nNumChars = GetSystemDirectory(tszSystemPath, NumItems(tszSystemPath));

        if (nNumChars == 0 || nNumChars > NumItems(tszSystemPath))
            uiError = ERROR_INSTALL_FAILURE;
        else
        {
            tszFullSystemTmp[NumItems(tszFullSystemTmp)-1] = 0;
            // Create the system temp
            _tcsncpy(tszFullSystemTmp, tszSystemPath, NumItems(tszFullSystemTmp)-1);
            int nLen = _tcslen(tszFullSystemTmp);

            _tcsncat(tszFullSystemTmp, _T("\\"), NumItems(tszFullSystemTmp)-nLen-1);
            nLen = _tcslen(tszFullSystemTmp);

            _tcsncat(tszFullSystemTmp, tszSystemTmp, NumItems(tszFullSystemTmp)-nLen-1);

            // Full path to the CAB in system's temp
            tszFullCabSytemTmp[NumItems(tszFullCabSytemTmp)-1] = 0;

            _tcsncpy(tszFullCabSytemTmp, tszFullSystemTmp, NumItems(tszFullCabSytemTmp)-1);
            nLen = _tcslen(tszFullCabSytemTmp);

            _tcsncat(tszFullCabSytemTmp, _T("\\"), NumItems(tszFullCabSytemTmp) - nLen - 1);
            nLen = _tcslen(tszFullCabSytemTmp);

            _tcsncat(tszFullCabSytemTmp, tszCabName, NumItems(tszFullCabSytemTmp) - nLen - 1);
            
            // Full path to the extract tool in system's temp
            tszFullExtractSytemTmp[NumItems(tszFullExtractSytemTmp)-1] = 0;

            _tcsncpy(tszFullExtractSytemTmp, tszFullSystemTmp, NumItems(tszFullExtractSytemTmp)-1);
            nLen = _tcslen(tszFullExtractSytemTmp);

            _tcsncat(tszFullExtractSytemTmp, _T("\\"), NumItems(tszFullExtractSytemTmp) - nLen - 1);
            nLen = _tcslen(tszFullExtractSytemTmp);

            _tcsncat(tszFullExtractSytemTmp, tszExtractTool, NumItems(tszFullExtractSytemTmp) - nLen - 1);
        }
     }

    // 3) Delete files in the URTTemp location
    // MSI Version is newer or equal to the version in <SYSTEM>
    if (ERROR_SUCCESS == uiError)
    {
        FWriteToLog (hInstall, _T("\tSTATUS: Attempt to delete files in URTTemp"));

        if ( !DeleteURTTempFile(hInstall, tszFullSystemTmp, tszFullCabSytemTmp, tszFullExtractSytemTmp) )
        {
            if ( 0 == _stricmp( tszSetProperty, _T("URTREINSTALL") ) )
            {
                // Continue setup but don't extract CAB
                FWriteToLog (hInstall, _T("\tWARNING: Failed to delete files in URTTemp folder"));
                FWriteToLog (hInstall, _T("\tWARNING: URTREINSTALL property set, continue setup without failure"));
                bContinue = false;
            }
            else
            {
                // TODO : need to something to rename?  Probably make DeleteURTTempFile more robust.
                FWriteToLog (hInstall, _T("\tERROR: Failed to delete files in URTTemp folder : Reboot Required"));
                uiError = ERROR_INSTALL_FAILURE;
            }
        }
    }


    // 4) Copy file from User temp to system temp
    if ( (ERROR_SUCCESS == uiError) && bContinue )
    {
        FWriteToLog (hInstall, _T("\tSTATUS: Copying from <USER> temp to <SYSTEM> temp"));

        if ( !CreateDirectory(tszFullSystemTmp, NULL) )
        {
            if ( ERROR_ALREADY_EXISTS != GetLastError () )
            {
                uiError = ERROR_INSTALL_FAILURE;
                FWriteToLog (hInstall, _T("\tERROR: Failed to create URTTemp directory"));
            }
        }
    
        // Full path to the cab in the user's temp
        _tcscpy(tszFullCabUserTmp, tszUserTmp);
        _tcscat(tszFullCabUserTmp, tszCabName);

        // Full path to the extract tool in the user's temp
        _tcscpy(tszFullExtractUserTmp, tszUserTmp);
        _tcscat(tszFullExtractUserTmp, tszExtractTool);
    
        // copy the CAB from user's temp to system's temp
        if ( !CopyFile(tszFullCabUserTmp, tszFullCabSytemTmp, FALSE) )
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed to copy URTCore.cab into URTTemp"));
            uiError = ERROR_INSTALL_FAILURE;
        }

        // copy the extract tool from user's temp to system's temp
        if ( !CopyFile(tszFullExtractUserTmp, tszFullExtractSytemTmp, FALSE) )
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed to copy extraction tool into URTTemp"));
            uiError = ERROR_INSTALL_FAILURE;
        }
    }

	delete [] lpCAData;
    lpCAData = NULL;

    // 4.5) Verify Hash for both CAB and Extract tool.
    if ( (ERROR_SUCCESS == uiError) && bContinue )
    {

        FWriteToLog (hInstall, _T("\tSTATUS: Verifying URTCoreCab Hash"));

        if ( !VerifyHash(hInstall, tszFullCabSytemTmp, tszCabHash) )
        {
            uiError = ERROR_INSTALL_FAILURE;
        }

        FWriteToLog (hInstall, _T("\tSTATUS: Verifying Extract Tool Hash"));

        if ( !VerifyHash(hInstall, tszFullExtractSytemTmp, tszExtractHash) )
        {
            uiError = ERROR_INSTALL_FAILURE;
        }
    }


    // 5) Extract the CAB in system temp
    if ( (ERROR_SUCCESS == uiError) && bContinue )
    {
        FWriteToLog (hInstall, _T("\tSTATUS: Extracting URTCore.cab in <SYSTEM> temp"));

        memset( &si, 0, sizeof(si) );
        si.cb = sizeof(si);

        // Create required commandline options to extract
        _stprintf( szCommand,
                   _T("%s %s -T %s"),
                   tszFullExtractSytemTmp,
                   tszFullCabSytemTmp,
                   tszFullSystemTmp );

        // Launch of the extraction
        //
        if ( CreateProcess(
                        tszFullExtractSytemTmp,      // name of executable module
                        szCommand,                   // command line string
                        NULL,                        // Security
                        NULL,                        // Security
                        FALSE,                       // handle inheritance option
                        DETACHED_PROCESS,            // creation flags
                        NULL,                        // new environment block
                        NULL,                        // current directory name
                        &si,                         // startup information
                        &pi ) )                      // process information
        {
            dwWait = WaitForSingleObject(pi.hProcess, 300000);

            switch (dwWait)
            {
                case WAIT_FAILED:
                {
                    uiError = ERROR_INSTALL_FAILURE;
                    FWriteToLog (hInstall, _T("\tERROR: dwWait Failed in extraction of CAB"));
                    break;
                }
                case WAIT_ABANDONED:
                {
                    uiError = ERROR_INSTALL_FAILURE;
                    FWriteToLog (hInstall, _T("\tERROR: dwWait Abandoned in extraction of CAB"));
                    break;
                }
                case WAIT_TIMEOUT:
                {
                    uiError = ERROR_INSTALL_FAILURE;
                    FWriteToLog (hInstall, _T("\tERROR: dwWait Timeout in extraction of CAB"));
                    break;
                }

            } // End Switch (dwWait)

        } // End If (CreateProcess)
        else
        {
            // CreateProcess Failed.
            uiError = ERROR_INSTALL_FAILURE;
            FWriteToLog (hInstall, _T("\tERROR: CreateProcess Failed in extraction of CAB"));
        } // End else - If (CreateProcess)

    } // End if (ERROR_SUCCESS == uiError)


 //Creating   mscoree.dll.local for bug # 284771
    TCHAR  tszMscoreeLocalPath[_MAX_PATH];
    _tcscpy(tszMscoreeLocalPath, tszFullSystemTmp);
    _tcscat(tszMscoreeLocalPath, _T("\\mscoree.dll.local"));
    

    if( (_taccess(tszMscoreeLocalPath, 0 )) == -1 )
    {
        
        FWriteToLog (hInstall, _T("\tSTATUS:mscoree.dll.local  Does not exist Creating ..."));
     
        HANDLE hFile = INVALID_HANDLE_VALUE;
        hFile = CreateFile(tszMscoreeLocalPath,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL );

        if(INVALID_HANDLE_VALUE == hFile)
        {
            FWriteToLog (hInstall, _T("\tERROR: Unable to Create file mscoree.dll.local"));
            uiError = ERROR_INSTALL_FAILURE;
        }
        else
        {
            FWriteToLog (hInstall, _T("\tSTATUS: Created the  file mscoree.dll.local"));        
        }
    }

    return uiError;
}


///////////////////////////////////////////////////////////////////////////////
/*

  Name: URTCoreCleanUp()
  
  calls the clean function if setup failed.  This is used for both Rollback
  and Commit actions.
                            
*/
///////////////////////////////////////////////////////////////////////////////

extern "C"
UINT __stdcall URTCoreCleanUp(MSIHANDLE hInstall)
{
    UINT uiError = ERROR_SUCCESS;
	LPTSTR lpCAData = NULL;
	DWORD  dwSize  = 0;
    BOOL   bRollback;
    BOOL   bCommit;

	// determine mode in which we are called
	bRollback = MsiGetMode(hInstall, MSIRUNMODE_ROLLBACK); // true for rollback

	// determine mode in which we are called
	bCommit = MsiGetMode(hInstall, MSIRUNMODE_COMMIT); // true for Commit

    if (FALSE == bCommit && FALSE == bRollback)
    {
    	return uiError;
    }

    // Set the size for the Property
    MsiGetProperty(hInstall, _T("CustomActionData"), _T(""), &dwSize);
	
    // Create buffer for the property
    lpCAData = new TCHAR[++dwSize];

    if (NULL == lpCAData)
    {
		return ERROR_INSTALL_FAILURE;
    }
	
    // Get property using the new buffer
    if ( ERROR_SUCCESS != MsiGetProperty( hInstall, 
                                          _T("CustomActionData"),
                                          lpCAData,
                                          &dwSize ) )
	{
        FWriteToLog (hInstall, _T("\tERROR: Failed to get Property for clean up"));
		uiError = ERROR_INSTALL_FAILURE;
	}
    else
    {
        // Don't want to fail if clean up doesn't work
        CleanUp(lpCAData);
    }

	delete [] lpCAData;
    lpCAData = NULL;

    return uiError;
}



///////////////////////////////////////////////////////////////////////////////
/*

  Name: CleanUp()

  This function will delete all files we dump into both the User's temp location
  and the sytem's temp location.
                            
*/
///////////////////////////////////////////////////////////////////////////////

BOOL CleanUp(LPTSTR lpCAData)
{
    TCHAR  tszUserTmp[_MAX_PATH]             = {_T('\0')};
    TCHAR  tszSystemTmp[_MAX_PATH]           = {_T('\0')};
    TCHAR  tszCabName[_MAX_PATH]             = {_T('\0')};
    TCHAR  tszExtractTool[_MAX_PATH]         = {_T('\0')};
    TCHAR  tszSystemPath[_MAX_PATH]          = {_T('\0')};
    TCHAR  tszFullSystemTmp[_MAX_PATH]       = {_T('\0')};
    TCHAR  tszDeletePath[_MAX_PATH]          = {_T('\0')};
    TCHAR  tszSetProperty[50]                = {_T('\0')};
    LPTSTR lpToken  = NULL;
    BOOL   bRet = TRUE;
    
    // Get user temp location
    lpToken = _tcstok(lpCAData, _T(";"));

    if (NULL == lpToken)
    {
        bRet = FALSE;
    }
    else
    {
        _tcscpy(tszUserTmp, lpToken);
    }

    // Get system temp location
    lpToken = _tcstok(NULL, _T(";"));

    if (NULL == lpToken)
    {
        bRet = FALSE;
    }
    else
    {
        _tcscpy(tszSystemTmp, lpToken);
    }

    // Get CAB Name
    lpToken = _tcstok(NULL, _T(";"));

    if (NULL == lpToken)
    {
        bRet = FALSE;
    }
    else
    {
        _tcscpy(tszCabName, lpToken);
    }

    // Get extract tool name
    lpToken = _tcstok(NULL, _T(";"));

    if (NULL == lpToken)
    {
        bRet = FALSE;
    }
    else
    {
        _tcscpy(tszExtractTool, lpToken);
    }

    // Get Darwin Property that was set
    lpToken = _tcstok(NULL, _T(";"));

    if (NULL == lpToken)
    {
        bRet = FALSE;
    }
    else
    {
        _tcscpy(tszSetProperty, lpToken);
    }

    // Delete CAB and Extraction tool
    if (TRUE == bRet)
    {
        GetSystemDirectory(tszSystemPath, _MAX_PATH);

        // Create the system temp
        _tcscpy(tszFullSystemTmp, tszSystemPath);
        _tcscat(tszFullSystemTmp, _T("\\"));
        _tcscat(tszFullSystemTmp, tszSystemTmp);


        // Delete Cab in user temp
        _tcscpy(tszDeletePath, tszUserTmp);
        _tcscat(tszDeletePath, tszCabName);
        if( !DeleteFile(tszDeletePath) )
        {

        }

        // Delete extract tool in user temp
        _tcscpy(tszDeletePath, tszUserTmp);
        _tcscat(tszDeletePath, tszExtractTool);
        if( !DeleteFile(tszDeletePath) )
        {

        }

        // Delete CAB in system's temp
        _tcscpy(tszDeletePath, tszFullSystemTmp);
        _tcscat(tszDeletePath, _T("\\"));
        _tcscat(tszDeletePath, tszCabName);
        if( !DeleteFile(tszDeletePath) )
        {

        }

        // Delete extract tool in system's temp
        _tcscpy(tszDeletePath, tszFullSystemTmp);
        _tcscat(tszDeletePath, _T("\\"));
        _tcscat(tszDeletePath, tszExtractTool);
        if( !DeleteFile(tszDeletePath) )
        {

        }
    }

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
/*

  Name: DeleteURTTempFile()

  Delete files in the URTTemp directory

  INPUT :
    hInstall   - Handle to the install session
    lpTempPath - Path to the URTTemp folder

  OUTPUT :
    N/A

  RETURN :
    true  - if success
    false - if failed
                      
*/
///////////////////////////////////////////////////////////////////////////////

bool DeleteURTTempFile( MSIHANDLE hInstall, LPTSTR lpTempPath, LPTSTR lpCabPath, LPTSTR lpExtractPath )
{
    bool bRet = true;
    TCHAR tszDeletePath[_MAX_PATH] = {_T('\0')};


    // Delete mscoree.dll in system's temp
    // If failed to delete MSCOREE.DLL. Fail the install and don't continue delete.
    _tcscpy(tszDeletePath, lpTempPath);
    _tcscat(tszDeletePath, _T("\\mscoree.dll"));
    if ( -1 != _taccess( tszDeletePath, 0 ) )
    {
        if( !SmartDelete(hInstall,tszDeletePath,lpTempPath) )
        {
            FWriteToLog (hInstall, _T("\tWARNING: Failed to delete mscoree.dll"));
            bRet = false;
            return bRet;
        }
    }

    // Delete fusion.dll in system's temp
    _tcscpy(tszDeletePath, lpTempPath);
    _tcscat(tszDeletePath, _T("\\fusion.dll"));
    if ( -1 != _taccess( tszDeletePath, 0 ) )
    {
        if( !SmartDelete(hInstall,tszDeletePath,lpTempPath) )
        {
            FWriteToLog (hInstall, _T("\tWARNING: Failed to delete fusion.dll"));
            bRet = false;
        }
    }

    // Delete mscorsn.dll in system's temp
    _tcscpy(tszDeletePath, lpTempPath);
    _tcscat(tszDeletePath, _T("\\mscorsn.dll"));
    if ( -1 != _taccess( tszDeletePath, 0 ) )
    {
        if( !SmartDelete(hInstall,tszDeletePath,lpTempPath) )
        {
            FWriteToLog (hInstall, _T("\tWARNING: Failed to delete mscorsn.dll"));
            bRet = false;
        }
    }

    // Delete mscorwks.dll in system's temp
    _tcscpy(tszDeletePath, lpTempPath);
    _tcscat(tszDeletePath, _T("\\mscorwks.dll"));
    if ( -1 != _taccess( tszDeletePath, 0 ) )
    {
        if( !SmartDelete(hInstall,tszDeletePath,lpTempPath) )
        {
            FWriteToLog (hInstall, _T("\tWARNING: Failed to delete mscorwks.dll"));
            bRet = false;
        }
    }

    // Delete msvcr70.dll in system's temp
    _tcscpy(tszDeletePath, lpTempPath);
    _tcscat(tszDeletePath, _T("\\msvcr70.dll"));
    if ( -1 != _taccess( tszDeletePath, 0 ) )
    {
        if( !SmartDelete(hInstall,tszDeletePath,lpTempPath))
        {
            FWriteToLog (hInstall, _T("\tWARNING: Failed to delete msvcr70.dll"));
            bRet = false;
        }
    }

    // Delete CAB in system's temp
    _tcscpy(tszDeletePath, lpCabPath);
    if ( -1 != _taccess( tszDeletePath, 0 ) )
    {
        if( !SmartDelete(hInstall,tszDeletePath,lpTempPath))
        {
            FWriteToLog (hInstall, _T("\tWARNING: Failed to delete URTCore.cab"));
            bRet = false;
        }
    }

    // Delete extract tool in system's temp
    _tcscpy(tszDeletePath, lpExtractPath);
    if ( -1 != _taccess( tszDeletePath, 0 ) )
    {
        if( !SmartDelete(hInstall,tszDeletePath,lpTempPath))
        {
            FWriteToLog (hInstall, _T("\tWARNING: Failed to delete exploder.exe"));
            bRet = false;
        }
    }

    return bRet;
}


// ==========================================================================
// FWriteToLog()
//
// Purpose:
//  Write given string to the Windows Installer log file for the given install
//  installation session
//  Copied from the HTML Project, should someday use one logging function.
//
// Inputs:
//  hSession            Windows Install Handle to current installation session
//  tszMessage          Const pointer to a string.
// Outputs:
//  Returns true for success, and false if it fails.
//  If successful, then the string (tszMessage) is written to the log file.
// Dependencies:
//  Requires Windows Installer & that an install be running.
// Notes:
// ==========================================================================

bool FWriteToLog( MSIHANDLE hSession, LPCTSTR ctszMessage )
{
    PMSIHANDLE hMsgRec = MsiCreateRecord( 1 );
    bool bRet = false;

    if( ERROR_SUCCESS == ::MsiRecordSetString( hMsgRec, 0, ctszMessage ) )
    {
       if( IDOK == ::MsiProcessMessage( hSession, INSTALLMESSAGE_INFO, hMsgRec ) )
       {
            bRet = true;
       }
    }

    return bRet;
}



// ==========================================================================
// SmartDelete()
//
// Purpose:
//  Tries to delete given file first. If its unable to then it would 
//  check if it is WIN NT platform, if it is then it would move the file
// given into a temp file and would delete the file so that it would get removed after 
// a reboot.
//
// Inputs:
//  lpFullFileName      The full path name of the file to be deleted
//  lpFilePath          The path to the file
// Outputs:
//  Returns true if file is deleted false otherwise
//   Dependencies:
//  none
// Notes:
// ==========================================================================
bool SmartDelete(MSIHANDLE hInstall, LPCTSTR lpFullFileName, LPCTSTR lpFilePath)

{
    
    TCHAR   tszFileName[10]             = _T("temp");
    TCHAR   tszTempFileName[_MAX_PATH]  = _T("");
    TCHAR   tszErrorMessage[2*_MAX_PATH]        = _T("");

    _stprintf(tszErrorMessage,_T("\tSTATUS: Deleting file %s"), lpFullFileName);
    FWriteToLog (hInstall,tszErrorMessage );

    if(!DeleteFile(lpFullFileName))
    {
        if(osVersionNT(hInstall))
        {
            
            FWriteToLog (hInstall, _T("\tSTATUS: Getting the temp file name"));

            if(!GetTempFileName(lpFilePath, tszFileName, 0, tszTempFileName ) )
            {
                FWriteToLog (hInstall, _T("\tERROR: Failed to get temp file name"));
                return false;
            }

            _stprintf(tszErrorMessage,_T("\tSTATUS: moving the dll to the temp file %s"),tszTempFileName);
            FWriteToLog (hInstall,tszErrorMessage );

            if(!MoveFileEx(lpFullFileName, tszTempFileName, MOVEFILE_REPLACE_EXISTING))
            {
                _stprintf(tszErrorMessage,_T("\tERROR: Failed to move  dll to temp file %s"), tszTempFileName);
                FWriteToLog (hInstall,tszErrorMessage );
                return false;
            }
            
            _stprintf(tszErrorMessage, _T("\tSTATUS: Putting the  temp file %s to delete on reboot"), tszTempFileName);
            FWriteToLog (hInstall,tszErrorMessage );

            if(!MoveFileEx(tszTempFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT) )
            {
                _stprintf(tszErrorMessage, _T("\tSTATUS: Cound not put the  temp file %s for delete on reboot"), tszTempFileName);
                FWriteToLog (hInstall,tszErrorMessage );
            }

        }
        else
        {
            FWriteToLog (hInstall, _T("\tSTATUS: Unable to delete file on Win9X platform"));
            return false;
        }
    }
    return true;
}
    




// ==========================================================================
// osVersionNT()
//
// Purpose:
//  Checks if the platform is WIN NT type or not
//
// Inputs: hInstall:    Record for logging
// Outputs:
//  Returns true if platform in winNT type false otherwise
//   Dependencies:
//  none
// Notes:
// ==========================================================================

bool osVersionNT(MSIHANDLE hInstall)
{
    OSVERSIONINFOEX     VersionInfo;
    bool                fGotVersionInfo = true;
    bool                fRetVal = false;
    
    
   // Try calling GetVersionEx using the OSVERSIONINFOEX structure,
   // which is supported on Windows 2000.
   //
   // If that fails, try using the OSVERSIONINFO structure.

    
    ZeroMemory(&VersionInfo, sizeof(OSVERSIONINFOEX));
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if( !GetVersionEx ((OSVERSIONINFO *) &VersionInfo) )
    {
       
        // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO

        VersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (! GetVersionEx ( (OSVERSIONINFO *) &VersionInfo) ) 
        {
            fGotVersionInfo = false;
            FWriteToLog (hInstall, _T("\tERROR: Failed to get OS Version information"));
        }
    }

    if (fGotVersionInfo)
    {
	    if (VER_PLATFORM_WIN32_NT==VersionInfo.dwPlatformId)
        {
            FWriteToLog (hInstall, _T("\tSTATUS: OS Version is WIN NT"));
		    fRetVal =  true;
        }

        else if (VER_PLATFORM_WIN32_WINDOWS==VersionInfo.dwPlatformId)
        {
            FWriteToLog (hInstall, _T("\tSTATUS: OS Version is WIN 9X"));
	    }
        else if (VER_PLATFORM_WIN32s==VersionInfo.dwPlatformId)
        {
            FWriteToLog (hInstall, _T("\tSTATUS: OS Version is WIN 32s"));
        }
        else 
        {
            FWriteToLog (hInstall, _T("\tSTATUS: Unknown OS Version type"));
        }

    }
    return fRetVal;
 
}

// ==========================================================================
// VerifyHash()
//
// Purpose:
//  To verify the Hash for file lpFile against the Hash from lpFileHash
//
// Inputs:
//  hInstall          Handle to the MSI
//  lpFile            File to be verified
//  lpFileHash        The Hash the file has to match up.
// Outputs:
//  Returns true  - If file hash matches
//          false - If file hash doesn't match
//
// Notes:
// ==========================================================================

bool VerifyHash( MSIHANDLE hInstall, LPTSTR lpFile, LPTSTR lpFileHash )
{
    bool bRet = false;
    VsCryptHashValue chvFile;
    LPTSTR lpHashString = NULL;


    if( CalcHashForFileSpec( lpFile, &chvFile ) )
    {
        if( chvFile.CopyHashValueToString( &lpHashString ) )
        {
            if ( 0 == _tcsicmp(lpFileHash, lpHashString) )
            {
                bRet = true;
            }
            else
            {
                FWriteToLog (hInstall, _T("\tERROR: File Hash mismatch"));
            }
            
            delete [] lpHashString;
        }
        else
        {
            FWriteToLog (hInstall, _T("\tERROR: CopyHashValueToString Failed"));
        }
    }
    else
    {
        FWriteToLog (hInstall, _T("\tERROR: CalcHashForFileSpec Failed"));
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempdef\vscrypt.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ==========================================================================
// Name:     VsCrypt.cpp
// Owner:    JeremyRo
// Purpose:  Classes/functions for creating cryptographic hashes.
//
// History:
//  02/19/2002, JeremyRo:  Created
//  02/20/2002, JeremyRo:  Added 'VsCryptHashValue::CopyHashValueToString()' 
//                         member function.
//
// ==========================================================================

#include "stdafx.h"
#include "VsCrypt.h"




// ==========================================================================
// class VsCryptProvider
//
// Purpose:
//  Wraps the CryptoAPI HCYRPTPROV object... creation/destruction.
//  This implementation specifically use the base provider:
//      "Microsoft Base Cryptographic Provider v1.0"
//  for compatibility with Win9x (Win98 Gold/Win 95 OSR2).
//

VsCryptProvider::VsCryptProvider() 
    : m_hProvider( NULL )
{
}


VsCryptProvider::~VsCryptProvider()
{
    if( m_hProvider )
    {
       CryptReleaseContext( m_hProvider,0 );
       m_hProvider = NULL;
    }
}

// Method:
//  Init()
//
// Purpose:
//  Acquires the Cryptographic Service Provider.
// Inputs:
//  None.
// Outputs:
//  Returns true if success, false otherwise.
// Dependencies:
//  CryptoAPI (crypt32.lib).
// Notes:
bool VsCryptProvider::Init( void )
{
    if( NULL == m_hProvider )
    {
        DWORD dwError = 0;
        if( !CryptAcquireContext( &m_hProvider, NULL, 
                                  MS_DEF_PROV , 
                                  PROV_RSA_FULL, 
                                  CRYPT_VERIFYCONTEXT ) ) 
        {
            dwError = GetLastError();
            m_hProvider = NULL;
        }
    }
    
    return( NULL != m_hProvider );
}


VsCryptProvider::operator HCRYPTPROV() const
{
    return m_hProvider;
}

//
// ==========================================================================



// ==========================================================================
// class VsCryptHash
//
// Purpose:
//  Wraps the CryptoAPI HCRYPTHASH object... creation/destruction/hashing of
//  data.  This implementation specifically targets the "SHA-1" algorithim 
//  for hash generation.
//

VsCryptHash::VsCryptHash( HCRYPTPROV hProv )
{
    DWORD dwErr = 0;
    if( NULL != hProv )
    {
        if (! CryptCreateHash( hProv, CALG_SHA1, 0, 0, &m_hHash ) )
        {
            dwErr = GetLastError();
            m_hHash = NULL;
        }
    }

}

VsCryptHash::~VsCryptHash()
{
    DWORD dwError = 0;
    if( NULL != m_hHash )
    {
        if( !CryptDestroyHash( m_hHash ) )
        {
            dwError = GetLastError();
        }
        else
        {
            m_hHash = NULL;
        }
    }
}


// Method:
//  HashData()
//
// Purpose:
//  Adds data to the current instance.  Can be called multiple times
//  for long/discontinuous data strams.
// Inputs:
//  pbData      Pointer to BYTE.  Additional data to hash.
//  dwDataLen   DWORD.  Number of BYTE's of data to hash.
// Outputs:
//  Returns true if success, false otherwise.
// Dependencies:
//  CryptoAPI (crypt32.lib).
// Notes:
bool VsCryptHash::HashData( BYTE* pbData, DWORD dwDataLen )
{
    ASSERT( NULL != pbData );
    bool  bRet = false;
    DWORD dwErr = 0;

    if( NULL != pbData )
    {
        if( !CryptHashData( m_hHash, pbData, dwDataLen, 0 ) )
        {
            dwErr = GetLastError();
        }
        else
        {
            bRet = true;
        }
    }

    return bRet;
}


VsCryptHash::operator HCRYPTHASH() const
{
    return m_hHash;
}

//
// ==========================================================================



// ==========================================================================
// class VsCryptHashValue
//
// Purpose:
//  Represents an arbitrary hash value of a Crypto- HCRYPTHASH/VsCryptHash
//  instance.  This class stores the value/size (in bytes) of the hash.
//

// Method:
//  destructor
//
// Purpose:
//  Cleanup resources
// Inputs:
//  None.
// Outputs:
//  None.
// Dependencies:
//  CryptoAPI (crypt32.lib).
// Notes:
VsCryptHashValue::~VsCryptHashValue()
{
    if( m_pbHashData )
    {
        ZeroMemory( m_pbHashData, m_nHashDataSize );
    }
    delete [] m_pbHashData;
    m_pbHashData = NULL;
}

// Method:
//  operator= (assignment operator)
//
// Purpose:
//  Assigns a new value using the specified HCRYPTHASH handle.
//
// Inputs:
//  [in]    hHash       CryptoAPI Hash handle to a hash object.
// Outputs:
//  returns reference to current instance.
// Dependencies:
//  CryptoAPI (crypt32.lib).
// Notes:
VsCryptHashValue& VsCryptHashValue::operator=( HCRYPTHASH hHash )
{
    DWORD dwNumBytes = 0;
    DWORD dwSize = sizeof(dwNumBytes);
    DWORD dwError = 0;
    PBYTE pbData = NULL;
    bool bSuccess = false;
    
    if( NULL != hHash )
    {
        if( CryptGetHashParam( hHash, HP_HASHSIZE, 
                              (BYTE*)(&dwNumBytes), &dwSize, 0 ) ) 
        {
            pbData = new BYTE[ dwNumBytes ];
            if( (NULL != pbData)
                && CryptGetHashParam( hHash, HP_HASHVAL, pbData, &dwNumBytes, 0 ) )
            {
                bSuccess = true;
            }
            else
            {
                dwError = GetLastError();
            }
        }
        else
        {
            dwError = GetLastError();
        }
    }

    delete [] m_pbHashData;
    if( !bSuccess )
    {
        dwNumBytes = 0;
        delete [] pbData;
        pbData = NULL;
    }

    m_nHashDataSize = dwNumBytes;
    m_pbHashData = pbData;

    return *this;
}



// Method:
//  CopyHashValueToString
//
// Purpose:
//  Given a pointer to a string (TCHAR**, or LPTSTR*), this function will 
//  return a new buffer that contatins the string representation of the
//  the hash value.
//
// Inputs:
//  [out]   hFile       Pointer to string for the returned buffer.  This 
//                      must be non null, but it should point to a NULL
//                      string.
//                      (e.g.   LPTSTR tszString = NULL;
//                              pHashVal->CopyHashValueToString( &tszString ) )
// Outputs:
//  returns 'true' if success, 'false' otherwise.
// Dependencies:
//  CryptoAPI (crypt32.lib).
// Notes:
//  Caller must use 'delete []' to free the buffer.
bool VsCryptHashValue::CopyHashValueToString( LPTSTR * ptszNewString )
{
    ASSERT( NULL != ptszNewString );
    ASSERT( NULL == *ptszNewString );

    bool bRet = false;

    if( (NULL != m_pbHashData) && (0 < m_nHashDataSize) )
    {
        const UINT cnStringSize = 2*m_nHashDataSize + 1;
        
        LPTSTR tszTemp = new TCHAR[ cnStringSize ];
        if( (NULL != ptszNewString) && (NULL != tszTemp) )
        {
            int nWritten = 0;
            DWORD dwErr = 0L;

            memset( tszTemp, 0, cnStringSize * sizeof(TCHAR) );
            for( UINT uiCur = 0; uiCur < m_nHashDataSize; uiCur++ )
            {
                nWritten = wsprintf( (tszTemp + (2*uiCur)), _T("%2.2x"), m_pbHashData[uiCur] );
                if( nWritten < 2 )
                {
                    dwErr = GetLastError();
                    break;
                }
            }

            ASSERT( 2 == nWritten );
            ASSERT( 0 == dwErr );
            ASSERT( uiCur == m_nHashDataSize );

            if( (uiCur != m_nHashDataSize) || (2 != nWritten) )
            {
                // failed... cleanup
                delete [] tszTemp;
                tszTemp = NULL;

            }
            else
            {
                ASSERT( _T('\0') == tszTemp[cnStringSize - 1] );
                bRet = true;
            }

            *ptszNewString = tszTemp;
        }
    }

    return bRet;
}

//
// ==========================================================================


// ==========================================================================
// CalcHashForFileHandle()
//
// Purpose:
//  Given open handle to a file, calculate the SHA (160 bit) hash for that
//  file, and return the hash value.
//
// Inputs:
//  [in]  hFile         Handle to file, opened with (at least) read access.
//  [out] phvHashVal    Pointer to VsCryptHashValue instance.  Instance must
//                      exist, but existing data (if any) will be 
//                      overwritten.
// Outputs:
//  Returns true if success, false otherwise.
// Dependencies:
//  CryptoAPI (crypt32.lib).
// Notes:
// ==========================================================================
bool CalcHashForFileHandle( HANDLE hFile, VsCryptHashValue* phvHashVal )
{
    bool bRet = false;

    // create/initialze Cryptographic provider
    VsCryptProvider vscCryptProv;
    vscCryptProv.Init();

    // create hash
    VsCryptHash vscHash( vscCryptProv );

    const DWORD cnBlockSize = 4096;
    BYTE * pbData = new BYTE[ cnBlockSize ];
    if( NULL == pbData )
    {
        ASSERT(!"Error: unable to allocate memory.\n");
    }
    else
    {
        // read file, and add data to hash calculation
        DWORD  dwRead = 0L;
        BOOL bReadSuccess = false;
        BOOL bHashSuccess = false;
        DWORD dwError = 0;
        do
        {
            if( TRUE == (bReadSuccess = ReadFile( hFile, pbData, 
                                                  cnBlockSize , 
                                                  &dwRead, NULL )) )
            {
                // add data to hash calc
                bHashSuccess = vscHash.HashData( pbData, dwRead );
            }
            else
            {
                dwError = GetLastError();
            }

        } while( bReadSuccess && bHashSuccess && (dwRead > 0) );

        if( !bReadSuccess )
        {
            ASSERT(!"Error: read operation from file failed.\n");
        }
        else if( !bHashSuccess )
        {
            ASSERT(!"Error: hash operation for file data failed.\n");
        }
        else
        {
            // get hash value & return it...
            *phvHashVal = vscHash;
            bRet = true;
        }

    }

    delete [] pbData;
    return bRet;
}


// ==========================================================================
// CalcHashForFileSpec()
//
// Purpose:
//  Given the full path to a file, calculate the SHA (160 bit) hash for that
//  file, and return it.
//
// Inputs:
//  [in]  ctszPath      File specification.  
//  [out] phvHashVal    Pointer to VsCryptHashValue instance.  Instance must
//                      exist, but existing data (if any) will be 
//                      overwritten.
// Outputs:
//  Returns true if success, false otherwise.
// Dependencies:
//  CryptoAPI (crypt32.lib).
// Notes:
// ==========================================================================
bool CalcHashForFileSpec( LPCTSTR ctszPath, VsCryptHashValue* phvHashVal )
{
    bool bRet = false;

    ASSERT(!IsEmptyTsz( ctszPath ) );
    ASSERT( NULL != phvHashVal );

    if( !IsEmptyTsz(ctszPath) 
        && (NULL != phvHashVal) 
        && _DoesFileExist( ctszPath ) )
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;
        __try
        {
            hFile = CreateFile( ctszPath, GENERIC_READ, 
                                FILE_SHARE_READ, NULL, 
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL 
                                | FILE_FLAG_SEQUENTIAL_SCAN, NULL );

            if( INVALID_HANDLE_VALUE == hFile )
            {
                ASSERT(!"Error: unable to open specified file\n");
            }
            else
            {
                bRet = CalcHashForFileHandle( hFile, phvHashVal );
            }
        }
        __finally
        {
            if( INVALID_HANDLE_VALUE != hFile )
            {
                CloseHandle( hFile );
            }
        }
    }
   
    return bRet;
}




#if !defined(VsLabLib)

// ==========================================================================
// _DoesFileExist()
//
// Purpose:
//  Determine if a file exists
// Inputs:
//  szFileSpec          File specification
// Outputs:
//  Returns true if the file exists, else false
// Dependencies:
//  None
// Notes:
// ==========================================================================
bool _DoesFileExist( LPCTSTR szPath )
{
    ASSERT( NULL != szPath );

    bool bRet = false;
    WIN32_FIND_DATA wfData;
    HANDLE hFind = INVALID_HANDLE_VALUE;

    ZeroMemory( &wfData, sizeof( wfData ) );

    hFind = FindFirstFile( szPath, &wfData );
    if( INVALID_HANDLE_VALUE != hFind )
    {
        FindClose( hFind );
        bRet = true;
    }

    return bRet;
}


#endif // !defined(VsLabLib)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempproc\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "URTTempProc.dll"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Custom Action\0"
#define VER_ORIGFILENAME_STR    "URTTempProc.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempproc\urttempproc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#if !defined(URTTempProc_H)
#define URTTempProc_H



//
// constant declarations
//
#define MSINULL 0L

typedef struct TAG_FILE_VERSION
    {
        int   FileVersionMS_High;
        int   FileVersionMS_Low;
        int   FileVersionLS_High;
        int   FileVersionLS_Low;
    }
    FILE_VERSION, *PFILE_VERSION;


UINT WriteStreamToFile(MSIHANDLE hMsi, LPTSTR lpStreamName, LPTSTR lpFileName);
bool GetMSIMSCOREEVersion(MSIHANDLE hMsi, LPTSTR lpVersionString);
int VersionCompare(LPTSTR lpVersion1, LPTSTR lpVersion2);
bool ConvertVersionToINT(LPTSTR lpStreamName, PFILE_VERSION pFileVersion);
bool FWriteToLog( MSIHANDLE hSession, LPCTSTR ctszMessage );


#endif // defined URTTempProc_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\adminprivs.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
FILE:    AdminPrivs.h
PROJECT: UTILS.LIB
DESC:    Declaration of AdminPrivs functions
OWNER:   JoeA

****************************************************************************/

#ifndef _ADMINPRIVS_H
#define _ADMINPRIVS_H

#include <windows.h>

//callers should use
// TRUE means user has administrator privs
// FALSE means user does not have admin privs
BOOL UserHasPrivileges();


//internal functions
BOOL IsAdmin( void );


#endif  //_ADMINPRIVS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\fxsetuplib.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     fxsetuplib.cpp
// Owner:    jbae
// Purpose:  Implements common library functions for .NET Framework (SDK) setup wrapper
//
// History:
//  long ago, anantag:  Created
//  01/10/01, jbae: Many changes to support ref-counting of Framework
//  03/09/01, jbae: re-factoring to share code in SDK and Redist setup
//  07/18/01, joea: adding logging functionality
//  07/20/01, jbae: adding a prettier message for Win95 block.

#include "SetupError.h"
#include "fxsetuplib.h"
#include "osver.h"
#include "MsiWrapper.h"
#include <time.h>         //for LogThis() function
#include "DetectBeta.h"
#include "commonlib.h"

//defines
//
#define EMPTY_BUFFER { _T('\0') }
#define END_OF_STRING  _T( '\0' )

// Somehow including windows.h or winuser.h didn't find this constant
// I found that CLR files hard-code them as below so I am following it.
#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION 0x1000
#endif

extern HINSTANCE g_AppInst ;
extern const TCHAR *g_szLogName;

// ==========================================================================
// ConfigCheck()
//
// Purpose:
//  Check to ensure the system meets the minimum configuration requirements
// Inputs: none
// Outputs: none (throws exception if minimum system configuration is not met)
// Dependencies:
//  None
// Notes:
// ==========================================================================
UINT ConfigCheck()
{
    TCHAR szOS[BUF_4_BIT+1]  = EMPTY_BUFFER;
    TCHAR szVer[BUF_4_BIT+1] = EMPTY_BUFFER;
    TCHAR szSP[BUF_4_BIT+1]  = EMPTY_BUFFER;
    BOOL  fServer = FALSE;
    
    OS_Required os = GetOSInfo( szOS, szVer, szSP, fServer );

    TCHAR szLog[_MAX_PATH+1] = EMPTY_BUFFER;
    ::_stprintf( szLog, _T( "OS: %s" ), szOS );
    LogThis( szLog, ::_tcslen( szLog ) );
    ::_stprintf( szLog, _T( "Ver: %s" ), szVer );
    LogThis( szLog, ::_tcslen( szLog ) );
    ::_stprintf( szLog, _T( "SP: %s" ), szSP );
    LogThis( szLog, ::_tcslen( szLog ) );

    switch( os )
    {
    case OSR_9XOLD: // We block Win95. We will not try to detect platform older than Win95 such as Win3.1.
        if ( REDIST == g_sm )
        {
            CSetupError se( IDS_UNSUPPORTED_PLATFORM_REDIST, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
            throw( se );
        }
        else if ( SDK == g_sm )
        {
            CSetupError se( IDS_UNSUPPORTED_PLATFORM_SDK, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
            throw( se );
        }

        break;

    case OSR_98GOLD:
    case OSR_98SE:
    case OSR_ME:
    case OSR_FU9X:
        if ( SDK == g_sm )
        {
            CSetupError se( IDS_UNSUPPORTED_PLATFORM_SDK, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
            throw( se );
        }
        break;

    case OSR_NT2K: //win 2k                                        
        break;

    case OSR_NT4: //win nt4
        if ( SDK == g_sm )
        {
            CSetupError se( IDS_UNSUPPORTED_PLATFORM_SDK, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
            throw( se );
        }

        if(IsTerminalServicesEnabled())
        {
            CSetupError se( IDS_NT4_TERMINAL_SERVICE, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
            throw( se );
            break;
        }
       
        LPTSTR pszVersion;
        pszVersion = _tcsrchr( szSP, _T(' ') );
        if ( NULL != pszVersion )
        {
            pszVersion = _tcsinc( pszVersion );
            double dVersion = atof( pszVersion ) ;
            if ( dVersion > 6 )
            {
                break;
            }
            else if ( dVersion < 6 ) 
            {
                CSetupError se( IDS_NT4_PRE_SP6A, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
                throw( se );
            }
            else 
            {
                HKEY hKey = NULL;
                LONG lRet = -1;
                DWORD dwRet =sizeof(DWORD); 
                DWORD dwKeyVal=0;
                lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, NTSP6A_REGKEY,0, KEY_READ, &hKey );
                if ( ERROR_SUCCESS == lRet )
                {                   
                    _ASSERTE( NULL != hKey );
                    lRet = RegQueryValueEx( hKey, NTSP6A_REGNAME,NULL, NULL,(LPBYTE)&dwKeyVal, &dwRet ); //If The value of installed is 1 then we have SP6A installed
                    RegCloseKey( hKey );
                    if ( ERROR_SUCCESS != lRet )
                    {
                        CSetupError se( IDS_NT4_PRE_SP6A, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
                        throw( se );
                    }
                    if ( NTSP6A_REGVALUE != dwKeyVal )
                    {
                        CSetupError se( IDS_NT4_PRE_SP6A, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
                        throw( se );
                    } 
                    
                }
                else
                {
                    CSetupError se( IDS_NT4_PRE_SP6A, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
                    throw( se );                    
                }
                                                          
            }
        }
        else
        {
            CSetupError se( IDS_NT4_PRE_SP6A, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
            throw( se );
        }

        break;

    case OSR_WHISTLER: // Whistler
    case OSR_FUNT: //future NT
        // Whistler or later
        break;

    default:
        CSetupError se( IDS_UNSUPPORTED_PLATFORM, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
        throw( se );
        break;
    }

    // Passed the OS test.  Now, the IE test
    TCHAR szRegValue[LONG_BUF] = EMPTY_BUFFER;          // Registry values and general str storage

    TCHAR szMsg[] = _T( "Checking Internet Explorer Version" );
    LogThis( szMsg, sizeof( szMsg ) );

    LogThis1( _T("Looking for %s"), IE_VERSION );
    HKEY hKey = NULL;
    DWORD dwRet = sizeof(szRegValue); 
    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            IE_REGKEY,
            0,
            KEY_QUERY_VALUE,
            &hKey) != ERROR_SUCCESS )
    {
        CSetupError se( IDS_PRE_IE_501, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
        throw( se );
    }

    if( RegQueryValueEx(hKey,
            IE_REGNAME,
            NULL,
            NULL,
            (LPBYTE)szRegValue,
            &dwRet
            ) != ERROR_SUCCESS )
    {
        RegCloseKey(hKey);
        CSetupError se( IDS_PRE_IE_501, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
        throw( se );
    }

    RegCloseKey(hKey);

    ::_stprintf( szLog, _T( "Found Internet Explorer Version: %s" ), szRegValue );
    LogThis( szLog, ::_tcslen( szLog ) );

    if ( 0 > VersionCompare( szRegValue, IE_VERSION ) )
    { // (szRegValue < IE_VERSION) or error
        LogThis1( _T("Internet Explorer Version is less"), _T("") );
        CSetupError se( IDS_PRE_IE_501, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
        throw( se );        
    }

    TCHAR szMsgOk[] = _T( "Internet Explorer Version is OK..." );
    LogThis( szMsgOk, sizeof( szMsgOk ) );

    return 0;
}  // End of ConfigCheck

// ==========================================================================
// CheckDarwin()
//
// Purpose:
//  Check the version of darwin
// Inputs: none
// Outputs: returns one of three
//      ERROR_SUCCESS       -- version equal or higher
//      DARWIN_VERSION_OLD  -- version old
//      DARWIN_VERSION_NONE -- no darwin
// Dependencies:
//  None
// Notes:
// ==========================================================================
UINT CheckDarwin()
{
    TCHAR szOS[BUF_4_BIT+1]  = EMPTY_BUFFER;
    TCHAR szVer[BUF_4_BIT+1] = EMPTY_BUFFER;
    TCHAR szSP[BUF_4_BIT+1]  = EMPTY_BUFFER;
    BOOL  fServer = FALSE;
    HINSTANCE hinstDll;
    UINT uRetCode = DARWIN_VERSION_NONE;
    
    TCHAR szWinVer[] = _T( "Checking Windows Installer version..." );
    LogThis( szWinVer, sizeof( szWinVer ) );

    OS_Required os = GetOSInfo( szOS, szVer, szSP, fServer );
    if ( (OSR_WHISTLER != os) && (OSR_FUNT != os) ) // only for lower OS than Whistler
    {
        hinstDll = LoadDarwinLibrary();
        if( hinstDll )
        {
            TCHAR szMsiOk[] = _T( "msi.dll loaded ok" );
            LogThis( szMsiOk, sizeof( szMsiOk ) );

            // Darwin is installed
            DLLGETVERSIONPROC pProc = (DLLGETVERSIONPROC)::GetProcAddress( hinstDll, TEXT("DllGetVersion") ) ;
            if( pProc )
            {
                DLLVERSIONINFO verMsi ;
                HRESULT        hr ;

                ZeroMemory( &verMsi, sizeof(verMsi) ) ;
                verMsi.cbSize = sizeof(verMsi) ;
                hr = (*pProc)(&verMsi) ;

                TCHAR szLog[_MAX_PATH+1] = EMPTY_BUFFER;
                ::_stprintf( szLog, _T( "Looking for: %d.%d.%d" ), DARWIN_MAJOR, DARWIN_MINOR, DARWIN_BUILD );
                LogThis( szLog, ::_tcslen( szLog ) );

                ::_stprintf( szLog, _T( "Found: %d.%d.%d" ), verMsi.dwMajorVersion, verMsi.dwMinorVersion, verMsi.dwBuildNumber );
                LogThis( szLog, ::_tcslen( szLog ) );

                bool bMajor = ( verMsi.dwMajorVersion < DARWIN_MAJOR ) ;
                bool bMinor = ( verMsi.dwMajorVersion == DARWIN_MAJOR && verMsi.dwMinorVersion < DARWIN_MINOR ) ;
                bool bBuild = ( verMsi.dwMajorVersion == DARWIN_MAJOR && verMsi.dwMinorVersion == DARWIN_MINOR && verMsi.dwBuildNumber < DARWIN_BUILD ) ;

                if( bMajor || bMinor || bBuild )
                {
                    // if installed Darwin is older than ours ...
                    TCHAR szDarwin[] = _T( "Detected old Windows Installer" );
                    LogThis( szDarwin, sizeof( szDarwin ) );

                    uRetCode = DARWIN_VERSION_OLD ;
                }
                else
                {
                    TCHAR szDarwinOk[] = _T( "Windows Installer version ok" );
                    LogThis( szDarwinOk, sizeof( szDarwinOk ) );

                    uRetCode = ERROR_SUCCESS ;
                }
            }
            else
            {
                // Can't find DllGetVersion for msi.dll, something is wrong
                uRetCode = DARWIN_VERSION_NONE;
            }

            ::FreeLibrary(hinstDll) ;
        }
        else
        {
            // msi.dll not found
            TCHAR szDarwinInstall[] = _T( "Cannot find Windows Installer." );
            LogThis( szDarwinInstall, sizeof( szDarwinInstall ) );

            uRetCode = DARWIN_VERSION_NONE;
        }
    }
    else // whistler
    {
        uRetCode = ERROR_SUCCESS ;
    }

    TCHAR szDarwinDone[] = _T( "Finished Checking Windows Installer version." );
    LogThis( szDarwinDone, sizeof( szDarwinDone ) );

    return uRetCode ;
}  // End of CheckDarwin

/********************************************************************************************
 *                                                                                          *
 *  Function:   VerifyDarwin()                                                              *
 *  Purpose:    Checks the system for the latest ver of Darwin, and updates as necessary.   *
 *  Creator:    Ananta Gudipaty                                                             *
 *                                                                                          *
 ********************************************************************************************/
UINT VerifyDarwin( bool bIsQuietMode )
{
    TCHAR szOS[BUF_4_BIT+1]  = EMPTY_BUFFER;
    TCHAR szVer[BUF_4_BIT+1] = EMPTY_BUFFER;
    TCHAR szSP[BUF_4_BIT+1]  = EMPTY_BUFFER;
    BOOL  fServer = FALSE;
    HINSTANCE hinstDll;
    UINT      uRetCode   = ERROR_SUCCESS;
    
    TCHAR szWinVer[] = _T( "Checking Windows Installer version..." );
    LogThis( szWinVer, sizeof( szWinVer ) );

    OS_Required os = GetOSInfo( szOS, szVer, szSP, fServer );
    if ( (OSR_WHISTLER != os) && (OSR_FUNT != os) ) // only for lower OS than Whistler
    {
        hinstDll = LoadDarwinLibrary();
        if( hinstDll )
        {
            TCHAR szMsiOk[] = _T( "msi.dll loaded ok" );
            LogThis( szMsiOk, sizeof( szMsiOk ) );

            // Darwin is installed
            DLLGETVERSIONPROC pProc = (DLLGETVERSIONPROC)::GetProcAddress( hinstDll, TEXT("DllGetVersion") ) ;
            if( pProc )
            {
                DLLVERSIONINFO verMsi ;
                HRESULT        hr ;

                ZeroMemory( &verMsi, sizeof(verMsi) ) ;
                verMsi.cbSize = sizeof(verMsi) ;
                hr = (*pProc)(&verMsi) ;

                TCHAR szLog[_MAX_PATH+1] = EMPTY_BUFFER;
                ::_stprintf( szLog, _T( "Looking for: %d.%d.%d" ), DARWIN_MAJOR, DARWIN_MINOR, DARWIN_BUILD );
                LogThis( szLog, ::_tcslen( szLog ) );

                ::_stprintf( szLog, _T( "Found: %d.%d.%d" ), verMsi.dwMajorVersion, verMsi.dwMinorVersion, verMsi.dwBuildNumber );
                LogThis( szLog, ::_tcslen( szLog ) );

                bool bMajor = ( verMsi.dwMajorVersion < DARWIN_MAJOR ) ;
                bool bMinor = ( verMsi.dwMajorVersion == DARWIN_MAJOR && verMsi.dwMinorVersion < DARWIN_MINOR ) ;
                bool bBuild = ( verMsi.dwMajorVersion == DARWIN_MAJOR && verMsi.dwMinorVersion == DARWIN_MINOR && verMsi.dwBuildNumber < DARWIN_BUILD ) ;

                if( bMajor || bMinor || bBuild )
                {
                    // if installed Darwin is older than ours ...
                    TCHAR szDarwin[] = _T( "Let's upgrade Windows Installer" );
                    LogThis( szDarwin, sizeof( szDarwin ) );

                    uRetCode = InstallDarwin( bIsQuietMode ) ;
                }
                else
                {
                    TCHAR szDarwinOk[] = _T( "Windows Installer version ok" );
                    LogThis( szDarwinOk, sizeof( szDarwinOk ) );

                    uRetCode = ERROR_SUCCESS ;
                }
            }
            else
            {
                // Can't find DllGetVersion for msi.dll, something is wrong
                CSetupError se( IDS_SETUP_FAILURE, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_NOT_INSTALLED );
                throw( se );
            }

            ::FreeLibrary(hinstDll) ;
        }
        else
        {
            // msi.dll not found, install Darwin
            TCHAR szDarwinInstall[] = _T( "Cannot find Windows Installer. Let's install it" );
            LogThis( szDarwinInstall, sizeof( szDarwinInstall ) );

            uRetCode = InstallDarwin( bIsQuietMode ) ;
        }
    }

    TCHAR szDarwinDone[] = _T( "Finished Checking Windows Installer version." );
    LogThis( szDarwinDone, sizeof( szDarwinDone ) );

    return uRetCode ;
}  // End of VerifyDarwin



/********************************************************************************************
 *                                                                                          *
 *  Function:   InstallDarwin()                                                             *
 *  Purpose:    Determines the OS (NT or 9X), and calls the appropriate version of InstMsi. *
 *  Creator:    Ananta Gudipaty                                                             *
 *                                                                                          *
 ********************************************************************************************/
UINT InstallDarwin( bool bIsQuietMode )
{
    BOOL  bReturnVal   = false ;
    UINT  uIconType    = MB_ICONEXCLAMATION ;

    int   iResponse ;
    DWORD  dwExitCode ;


    // Unless we are in quiet mode, give the user the option to install Darwin.
    if( !bIsQuietMode )
    {
        LPVOID pArgs[] = { (LPVOID)CSetupError::GetProductName() };
        CSetupError se;
        se.SetError2( IDS_MSI_UPDATE, MB_YESNO|MB_DEFBUTTON1|MB_ICONEXCLAMATION, ERROR_SUCCESS, (va_list *)pArgs );
        iResponse = se.ShowError2();
    }
    else
    {
        // If we are in quiet mode, assume the answer is "Yes."
        iResponse = IDYES ;
    }

    if( iResponse != IDYES )
    {
        CSetupError se( IDS_SETUP_CANCELLED, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, ERROR_INSTALL_USEREXIT );
        throw( se );
    }

    OSVERSIONINFO       osvi ;
    osvi.dwOSVersionInfoSize = sizeof(osvi) ;

    bReturnVal = GetVersionEx(&osvi) ;

    LogThis1( _T("Installing Windows Installer"), _T("") );
    // There is a Unicode and ANSI version of Darwin, we will install the appropriate version.
    if( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
    {
        LogThis1( _T("Running %s"), DARWIN_SETUP_CMD_W );
        dwExitCode = QuietExec( DARWIN_SETUP_CMD_W );
    }
    else
    {
        LogThis1( _T("Running %s"), DARWIN_SETUP_CMD_A );
        dwExitCode = QuietExec( DARWIN_SETUP_CMD_A );
    }
    LogThisDWORD( _T("Windows Installer Installation returned %d"), dwExitCode );
    LogThisDWORD( _T("\r\n[InstMsi.exe]\r\nReturnCode=%d"), dwExitCode );
    
    return dwExitCode;
}  // End of InstallDarwin

// ==========================================================================
// InstallProduct()
//
// Purpose:
//  Installs given MSI package on a machine that should now be Darwin
//  enabled.  
// Inputs:
//  CReadFlags *rf: commandline switches
//  LPTSTR psaPackageName: path to MSI
//  LPTSTR pszCmdLine: commandline to MsiInstallProduct()
// Outputs:
//  CSetupCode *sc: will contain returncode, message and icon to display.
//                  Also used to raise exception
// Dependencies:
//  None
// Notes:
// ==========================================================================
UINT InstallProduct( const CReadFlags *rf, LPCTSTR pszPackageName, LPCTSTR pszCmdLine, CSetupCode *sc )
{
    _ASSERTE( NULL != rf );
    _ASSERTE( NULL != pszPackageName );
    _ASSERTE( NULL != sc );

    UINT uDarCode = ERROR_SUCCESS;
    LPTSTR pszDarwinCmdLine = NULL;
    CMsiWrapper msi;
    TCHAR       tszOSName[OS_MAX_STR+1]      = EMPTY_BUFFER;
    TCHAR       tszVersion[OS_MAX_STR+1]     = EMPTY_BUFFER;
    TCHAR       tszServicePack[OS_MAX_STR+1] = EMPTY_BUFFER;
    BOOL        fIsServer;
    OS_Required osr;
    
    pszDarwinCmdLine = new TCHAR[_tcslen(pszCmdLine) + _tcslen(IIS_NOT_PRESENT_PROP) + _tcslen(MDAC_NOT_PRESENT_PROP) + 3];
    _tcscpy( pszDarwinCmdLine, pszCmdLine );

    osr = GetOSInfo(tszOSName, tszVersion, tszServicePack, fIsServer);     
    
    //Check only on Win2K systems and above
    //
    if (osr == OSR_NT2K || osr == OSR_WHISTLER || osr == OSR_FUNT)
    {
        if ( !IsIISInstalled() )
        {
            TCHAR szNoIis[] = _T( "IIS not found" );
            LogThis( szNoIis, sizeof( szNoIis ) );
            _tcscat( pszDarwinCmdLine, _T(" ") );
            _tcscat( pszDarwinCmdLine, IIS_NOT_PRESENT_PROP );
        }

        if ( !IsMDACInstalled() )
        {
            _tcscat( pszDarwinCmdLine, _T(" ") );
            _tcscat( pszDarwinCmdLine, MDAC_NOT_PRESENT_PROP );
        }
    }

    // Shutdown Darwin Service
    StopDarwinService();
        

    msi.LoadMsi();

    // turn on logging if logfile is given
    // it flushes every 20 lines
    if ( NULL != rf->GetLogFileName() )
    {
        LogThis1( _T("Darwin log: %s"), rf->GetLogFileName() );
        (*(PFNMSIENABLELOG)msi.GetFn(_T("MsiEnableLogA")))( DARWIN_LOG_FLAG, rf->GetLogFileName(), INSTALLLOGATTRIBUTES_APPEND );
    }

    // Tell Darwin to use the appropriate UI Level
    // If we're in a quiet install, don't use a UI.
    if ( rf->IsProgressOnly() )
    {
        LogThis1( _T("Basic+ProgressOnly UI"), _T("") );
        (*(PFNMSISETINTERNALUI)msi.GetFn(_T("MsiSetInternalUI")))(INSTALLUILEVEL_BASIC|INSTALLUILEVEL_PROGRESSONLY,NULL) ;
    }
    else if( rf->IsQuietMode() )
    {
        LogThis1( _T("No UI"), _T("") );
        (*(PFNMSISETINTERNALUI)msi.GetFn(_T("MsiSetInternalUI")))(INSTALLUILEVEL_NONE,NULL) ;
    }
    else
    {
        if ( rf->IsInstalling() )
        {
            LogThis1( _T("Full UI"), _T("") );
            (*(PFNMSISETINTERNALUI)msi.GetFn(_T("MsiSetInternalUI")))(INSTALLUILEVEL_FULL,NULL) ;
        }
        else
        {
            LogThis1( _T("Basic UI"), _T("") );
            (*(PFNMSISETINTERNALUI)msi.GetFn(_T("MsiSetInternalUI")))(INSTALLUILEVEL_BASIC,NULL) ;
        }
    }

    LogThis1( _T("Calling MsiInstallProduct() with commandline: %s"), pszDarwinCmdLine );
    // Tell Darwin to actually install the product
    uDarCode = (*(PFNMSIINSTALLPRODUCT)msi.GetFn(_T("MsiInstallProductA")))( pszPackageName, pszDarwinCmdLine ) ;
    delete [] pszDarwinCmdLine;

    LogThisDWORD( _T("MsiInstallProduct() returned %d"), uDarCode );
    LogThisDWORD( _T("\r\n[MsiInstallProduct]\r\nReturnCode=%d"), uDarCode );

    switch ( uDarCode )
    {
        case ERROR_SUCCESS :
             sc->SetReturnCode( IDS_SETUP_COMPLETE, IDS_DIALOG_CAPTION, MB_ICONINFORMATION, ERROR_SUCCESS );
             if ( rf->IsInstalling() )
                sc->m_bQuietMode = true;
             break ;
        case ERROR_SUCCESS_REBOOT_REQUIRED :
             sc->SetReturnCode( IDS_SETUP_COMPLETE, IDS_DIALOG_CAPTION, MB_ICONINFORMATION, ERROR_SUCCESS_REBOOT_REQUIRED );
             sc->m_bQuietMode = true;
             break ;
        case ERROR_INSTALL_USEREXIT :
             sc->SetError( IDS_SETUP_CANCELLED, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, ERROR_INSTALL_USEREXIT );
             if ( rf->IsInstalling() )
                sc->m_bQuietMode = true;
             throw (*sc);
             break ;
        case ERROR_FILE_NOT_FOUND :
        case ERROR_INSTALL_PACKAGE_OPEN_FAILED:
             sc->SetError( IDS_CANNOT_OPEN_MSI, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, uDarCode );
             throw (*sc);
             break ;
        case ERROR_INSTALL_LANGUAGE_UNSUPPORTED:
             sc->SetError( IDS_INSTALL_LANGUAGE_UNSUPPORTED, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, uDarCode );
             throw (*sc);
             break ;
        case ERROR_UNKNOWN_PRODUCT :
             sc->SetError( IDS_FRAMEWORK_NOT_EXIST, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, ERROR_UNKNOWN_PRODUCT );
             throw (*sc);
             break ;
        case ERROR_INSTALL_PLATFORM_UNSUPPORTED :
             sc->SetError( IDS_UNSUPPORTED_PLATFORM, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
             throw (*sc);
             break ;
        case ERROR_PRODUCT_VERSION :
             sc->SetError( IDS_ERROR_PRODUCT_VERSION, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_PRODUCT_VERSION );
             throw (*sc);
             break ;
        default :
             sc->SetError( IDS_SETUP_FAILURE, IDS_DIALOG_CAPTION, MB_ICONERROR, uDarCode );
             throw (*sc);
             break ;
    }

    // Shutdown Darwin Service
    StopDarwinService();
    
    return ERROR_SUCCESS;
}  // End of InstallProduct

// ==========================================================================
// QuietExec()
//
// Purpose:
//  Runs command
// Inputs:
//  LPCTSTR pszCmd: command to run
// Outputs:
//  DWORD dwExitCode: exit code from the command
// Notes:
// ==========================================================================
DWORD QuietExec( LPCTSTR pszCmd )
{
    BOOL  bReturnVal   = false ;
    STARTUPINFO  si ;
    DWORD  dwExitCode ;
    SECURITY_ATTRIBUTES saProcess, saThread ;
    PROCESS_INFORMATION process_info ;

    ZeroMemory(&si, sizeof(si)) ;
    si.cb = sizeof(si) ;

    saProcess.nLength = sizeof(saProcess) ;
    saProcess.lpSecurityDescriptor = NULL ;
    saProcess.bInheritHandle = TRUE ;

    saThread.nLength = sizeof(saThread) ;
    saThread.lpSecurityDescriptor = NULL ;
    saThread.bInheritHandle = FALSE ;

    bReturnVal = CreateProcess(NULL, (LPSTR)pszCmd, &saProcess, &saThread, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &process_info) ;

    if(bReturnVal)
    {
        CloseHandle( process_info.hThread ) ;
        WaitForSingleObject( process_info.hProcess, INFINITE ) ;
        GetExitCodeProcess( process_info.hProcess, &dwExitCode ) ;
        CloseHandle( process_info.hProcess ) ;
    }
    else
    {
        CSetupError se( IDS_SETUP_FAILURE, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_EXIT_FAILURE );
        throw( se );
    }

    return dwExitCode;
}

// ==========================================================================
// LoadDarwinLibrary()
//
// Purpose:
//  loads msi.dll after getting location from registry
// Inputs:
//  none
// Outputs:
//  none
// Returns:
//  HMODULE hMsi: handle to msi.dll
// Notes:
// ==========================================================================
HMODULE LoadDarwinLibrary()
{
    HKEY hKey = NULL;
    LONG lRet = -1;
    TCHAR szMsiPath[MAX_PATH] = EMPTY_BUFFER;
    DWORD dwRet = sizeof(szMsiPath); 
    HMODULE hMsi = NULL;
    
    TCHAR szLoadMsi[] = _T( "Trying to load msi.dll" );
    LogThis( szLoadMsi, sizeof( szLoadMsi ) );

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, DARWIN_REGKEY, 0, KEY_READ, &hKey );
    if ( ERROR_SUCCESS == lRet )
    {                   
        _ASSERTE( NULL != hKey );
        lRet = RegQueryValueEx( hKey, DARWIN_REGNAME, NULL, NULL, (LPBYTE)szMsiPath, &dwRet );
        RegCloseKey( hKey );
        if ( ERROR_SUCCESS == lRet )
        {
            _tcscat( szMsiPath, _T("\\msi.dll") );
        }
        else
        {
            _tcscpy( szMsiPath, _T("msi.dll") );
        }
    }
    else
    {
        _tcscpy( szMsiPath, _T("msi.dll") );
    }

    LogThis1( _T( "Loading: %s" ), szMsiPath );

    hMsi = ::LoadLibrary( szMsiPath ) ;

    return hMsi;
}

// ==========================================================================
// MyNewHandler()
//
// Purpose:
//  this is handler for new()
//  It throws exception with error ERROR_NOT_ENOUGH_MEMORY
// Inputs:
//  none
// Outputs:
//  none
// ==========================================================================
int MyNewHandler( size_t size )
{
    CSetupError se( IDS_NOT_ENOUGH_MEMORY, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_NOT_ENOUGH_MEMORY, (LPTSTR)CSetupError::GetProductName() );
    throw( se );
    return 0;
}

BOOL IsIISInstalled()
{
    BOOL retVal = TRUE;
    
    TCHAR szCheckIis[] = _T( "Checking IIS..." );
    LogThis( szCheckIis, sizeof( szCheckIis ) );
    
    // open the service control manager     
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);   

    if (hSCM == NULL)
    {
        TCHAR szNoScm[] = _T( "Could not open the Service Control Manager" );
        LogThis( szNoScm, sizeof( szNoScm ) );

        return FALSE;
    }

    // check if the IIS service exist     
    SC_HANDLE hIIS = OpenService(hSCM, _T("w3svc"), SERVICE_QUERY_STATUS);

    if (hIIS == NULL)
    {
        retVal = FALSE;
    }
    else
    {
        CloseServiceHandle(hIIS);
    }
    
    // clean up
    CloseServiceHandle(hSCM);

    return retVal;
}

bool IsMDACInstalled()
{
    TCHAR szVersion[_MAX_PATH] = EMPTY_BUFFER;
    bool bRet = false;
    HKEY hKey = NULL;
    LONG lRet = -1;
    DWORD dwRet =sizeof(szVersion);

    TCHAR szMdac[] = _T( "Checking MDAC Version" );
    LogThis( szMdac, sizeof( szMdac ) );

    LogThis1( _T("Looking for %s"), MDAC_VERSION );
    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, MDAC_REGKEY,0, KEY_QUERY_VALUE, &hKey );
    if ( ERROR_SUCCESS == lRet )
    {                   
        _ASSERTE( NULL != hKey );
        lRet = RegQueryValueEx( hKey, MDAC_REGNAME ,NULL, NULL,(LPBYTE)szVersion, &dwRet );
        RegCloseKey( hKey );
        if ( ERROR_SUCCESS == lRet )
        {
            TCHAR szLog[_MAX_PATH+1] = EMPTY_BUFFER;
            ::_stprintf( szLog, _T( "Found MDAC Version: %s" ), szVersion );
            LogThis( szLog, ::_tcslen( szLog ) );
            
            if ( 0 <= VersionCompare( szVersion, MDAC_VERSION ) )
            { // szVersion >= MDAC_VERSION
                bRet = true;
            }
        }   
    }
    if ( bRet )
        LogThis1( _T("MDAC Version OK"), _T("") );
    else
        LogThis1( _T("MDAC Version is less or MDAC not installed"), _T("") );

    return bRet;
}

// ==========================================================================
// LogThis1()
//
// Purpose:
//  Adds a string to a log file. It calls LogThis()
// Inputs:
//  LPCTSTR pszFormat: format string with %s
//  LPCTSTR pszArg: argument to format
// Outputs:
//  void
// ==========================================================================
void LogThis1( LPCTSTR pszFormat, LPCTSTR pszArg )
{
    _ASSERTE( pszFormat );
    _ASSERTE( pszArg );

    LPTSTR pszData = new TCHAR[ _tcslen(pszFormat) + _tcslen(pszArg) + 1];
    _stprintf( pszData, pszFormat, pszArg );
    LogThis( pszData, _tcslen(pszData) );
    delete [] pszData;
}

// ==========================================================================
// LogThisDWORD()
//
// Purpose:
//  Adds a string to a log file. It calls LogThis()
// Inputs:
//  LPCTSTR pszFormat: format string with %s
//  LPCTSTR pszArg: argument to format
// Outputs:
//  void
// ==========================================================================
void LogThisDWORD( LPCTSTR pszFormat, DWORD dwNum )
{
    _ASSERTE( pszFormat );

    LPTSTR pszData = new TCHAR[ _tcslen(pszFormat) + 20 ]; // 20 should cover enough digits for DWORD
    _stprintf( pszData, pszFormat, dwNum );
    LogThis( pszData, _tcslen(pszData) );
    delete [] pszData;
}

// LogThis()
//
// Purpose:
//  Adds a string to a log file. It calls LogThis()
// Inputs:
//  LPCTSTR pszMessage: string to log
// Outputs:
//  void
// ==========================================================================
void LogThis( LPCTSTR pszMessage )
{
    _ASSERTE( pszMessage );
    LogThis( pszMessage, _tcslen(pszMessage) );
}


// ==========================================================================
// LogThis()
//
// Purpose:
//  Adds a string to a log file.
//  Log file will have a static name, always be created in the %temp% dir,
//  and will be over-written each install. 
// Inputs:
//  LPCTSTR szData:  null terminated string to log
//  size_t  nLength: number of bytes in szData
// Outputs:
//  void
// ==========================================================================
//defines
void LogThis( LPCTSTR szData, size_t nLength )
{
    _ASSERTE( FALSE == IsBadReadPtr( szData, nLength ) );

    //determines if we should create or nulify existing content
    // versus appending ... the first time this is called in any
    // session, we will create, otherwise we append
    //
    static bool fFirstPass = true;
    static CTempLogPath templog( g_szLogName );

    FILE* fp = ::_tfopen( 
        (LPCTSTR)templog, 
        fFirstPass ? _T( "w" ) : _T( "a" ) );

    if( fp )
    {
        //date and time stamps are added to all entries
        //
        TCHAR dbuffer[10] = EMPTY_BUFFER;
        TCHAR tbuffer[10] = EMPTY_BUFFER;
        
        ::_tstrdate( dbuffer );
        ::_tstrtime( tbuffer );
        
        ::_ftprintf( 
            fp, 
            _T( "[%s,%s] %s\n" ), 
            dbuffer, 
            tbuffer, 
            szData );
        
        ::fclose( fp );
        fp = NULL;
    }
    else
    {
        CSetupError se( IDS_CANNOT_WRITE_LOG, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_CANNOT_WRITE_LOG, false );
        throw se;
    }

    if( fFirstPass )
    {
        fFirstPass = false;
    }
}

CDetectBeta::CDetectBeta( PFNLOG pfnLog )
: m_pfnLog( pfnLog ), m_nCount( 0 )
{}

// ==========================================================================
// CDetectBeta::FindProducts()
//
// Purpose:
//  Enumerate all products that installed beta and older NDP components.
//  It checks version of mscoree.dll. PDC is a special case since it had
//  version of 2000.14.X.X
// Inputs: none
// Outputs:
//  Returns LPCTSTR pszProducts that contains all products seperated by newline.
// Dependencies:
//  Requires Windows Installer
// Notes:
// ==========================================================================
LPCTSTR CDetectBeta::FindProducts()
{
    DWORD dwInx = 0;
    DWORD dwLen = 0;
    DWORD dwLenV = 0;
    TCHAR szClientId[39] = EMPTY_BUFFER;
    TCHAR szProductName[_MAX_PATH+1] = EMPTY_BUFFER;
    TCHAR szVersion[24] = EMPTY_BUFFER;
    TCHAR szLang[_MAX_PATH+1] = EMPTY_BUFFER;
    TCHAR szMscoreePath[_MAX_PATH+1] = EMPTY_BUFFER;
    INSTALLSTATE is = INSTALLSTATE_UNKNOWN;
    UINT nRet = E_FAIL;
    UINT cchProdBuf = 0;
    LPCTSTR pszProducts = NULL;
    CMsiWrapper msi;

    msi.LoadMsi();

    m_pfnLog( _T("Looking for mscoree.dll from PDC"), _T("") );
    dwLen = LENGTH( szMscoreePath );
    is = (*(PFNMSILOCATECOMPONENT)msi.GetFn(_T("MsiLocateComponentA")))( MSCOREE_PDC_COMPID_SZ, szMscoreePath, &dwLen );
    if ( INSTALLSTATE_LOCAL == is )
    {
        m_pfnLog( _T("%s is installed local"), szMscoreePath );
        if ( ERROR_SUCCESS == (*(PFNMSIENUMCLIENTS)msi.GetFn(_T("MsiEnumClientsA")))( MSCOREE_PDC_COMPID_SZ, 0, szClientId ) )
        {
            dwLen = LENGTH(szProductName);
            m_pfnLog( _T("ProductCode: %s"), szClientId ); // comredist.msi. Need to find comsdk.msi which installed comredist.msi
            if ( ERROR_SUCCESS == (*(PFNMSIGETPRODUCTINFO)msi.GetFn(_T("MsiGetProductInfoA")))( NGWSSDK_PDC_PRODID_SZ, INSTALLPROPERTY_INSTALLEDPRODUCTNAME, szProductName, &dwLen ) )
            {
                m_pfnLog( _T("ProductName: %s"), szProductName );
                m_strProducts += szProductName;
                m_strProducts += _T("\n");
                ++m_nCount;
            }
        }
    }
    else
    {
        m_pfnLog( _T("mscoree.dll from PDC is not installed local"), _T("") );
    }

    m_pfnLog( _T("Looking for mscoree.dll from Beta"), _T("") );
    dwLen = LENGTH( szMscoreePath );
    is = (*(PFNMSILOCATECOMPONENT)msi.GetFn(_T("MsiLocateComponentA")))( MSCOREE_COMPID_SZ, szMscoreePath, &dwLen );
    if ( INSTALLSTATE_LOCAL == is )
    {
        m_pfnLog( _T("%s is installed local"), szMscoreePath );
        dwLenV = LENGTH( szVersion );
        dwLen = LENGTH( szLang );
        nRet = (*(PFNMSIGETFILEVERSION)msi.GetFn(_T("MsiGetFileVersionA")))( szMscoreePath, szVersion, &dwLenV, szLang, &dwLen );
        if ( ERROR_SUCCESS == nRet )
        {
            m_pfnLog( _T("Version: %s"), szVersion );
            m_pfnLog( _T("Language: %s"), szLang );
            if ( (0 == VersionCompare( MSCOREE_PDC_VERSION_SZ, szVersion )) || // probably redist is installed on top of PDC ngws SDK
                 (0 < VersionCompare( MSCOREE_BETA_VERSION_SZ, szVersion )) )  // szVersion < MSCOREE_BETA_VERSION_SZ
            {
                m_pfnLog( _T("mscoree.dll is older than %s"), MSCOREE_BETA_VERSION_SZ );
                dwInx = 0;
                while( ERROR_SUCCESS == (*(PFNMSIENUMCLIENTS)msi.GetFn(_T("MsiEnumClientsA")))( MSCOREE_COMPID_SZ, dwInx, szClientId ) )
                {
                    dwLen = LENGTH(szProductName);
                    m_pfnLog( _T("ProductCode: %s"), szClientId );
                    if ( ERROR_SUCCESS == (*(PFNMSIGETPRODUCTINFO)msi.GetFn(_T("MsiGetProductInfoA")))( szClientId, INSTALLPROPERTY_INSTALLEDPRODUCTNAME, szProductName, &dwLen ) )
                    {
                        m_pfnLog( _T("ProductName: %s"), szProductName );
                        m_strProducts += szProductName;
                    }
                    else // if we cannot get ProductName, use ProductCode instead
                    {
                        m_strProducts += _T("ProductCode: ");
                        m_strProducts += szClientId;
                    }
                    m_strProducts += _T("\n");
                    ++dwInx;
                    ++m_nCount;
                }
            }
            else
            {
                m_pfnLog( _T("mscoree.dll is newer than %s"), MSCOREE_BETA_VERSION_SZ );
            }
        }
        else
        {
            m_pfnLog( _T("Cannot get version of mscoree.dll"), _T("") );
        }
    }
    else
    {
        m_pfnLog( _T("mscoree.dll is not installed local"), _T("") );
    }

    if ( !m_strProducts.empty() )
    {
        pszProducts = m_strProducts.c_str();
    }

    return pszProducts;
}

void StopDarwinService()
{
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    TCHAR       tszOSName[OS_MAX_STR+1]      = EMPTY_BUFFER;
    TCHAR       tszVersion[OS_MAX_STR+1]     = EMPTY_BUFFER;
    TCHAR       tszServicePack[OS_MAX_STR+1] = EMPTY_BUFFER;
    BOOL        fIsServer;
    OS_Required osr;

    try
    {
        osr = GetOSInfo(tszOSName, tszVersion, tszServicePack, fIsServer);     
        
        // Check that this is NT3.1 or higher
        // ----------------------------------
        if (osr == OSR_OTHER || osr == OSR_9XOLD || osr == OSR_98SE || osr == OSR_98GOLD || osr == OSR_ME)
        {
            // We won't do this operation on Win9X
            LogThis(_T("StopDarwinService() - Note: Win9x/Win31 machine, not necessary to stop the darwin service.  Continuing with setup..."));
            return;
        }


        // Try to open the SC Manager
        // --------------------------
        hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        if (NULL == hSCM)
        {
            DWORD res = GetLastError();

            LogThis(_T("StopDarwinService() - ERROR: Unable to open the SC Manager!"));
            LogThisDWORD( _T("   GetLastError() returned: <%i>"), res);
            
            CSetupCode sc;
            sc.SetError( IDS_DARWIN_SERVICE_INTERNAL_ERROR, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_SERVICE_INTERNAL_ERROR );
            throw (sc);
        }


        // Try to open the msiserver service
        // ---------------------------------
        hService = OpenService(hSCM, "msiserver", SERVICE_STOP | SERVICE_QUERY_STATUS);
        if (NULL == hService)
        {
            DWORD res = GetLastError();

            LogThis( _T("StopDarwinService() - ERROR: Unable to open the 'msiserver' service!"));
            LogThisDWORD( _T("   GetLastError() returned: <%i>"), res);
            
            CSetupCode sc;
            sc.SetError( IDS_DARWIN_SERVICE_INTERNAL_ERROR, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_SERVICE_INTERNAL_ERROR );
            throw (sc);
        }

        
        SERVICE_STATUS ss;
        
        // Chec the status of the service
        BOOL bSuccess = FALSE;
        bSuccess = QueryServiceStatus(hService, &ss);
        if (FALSE == bSuccess)
        {
            DWORD res = GetLastError();

            LogThis( _T("StopDarwinService() - ERROR: Unable to query the state of the service"));
            LogThisDWORD( _T("   GetLastError() returned: <%i>"), res);
            
            CSetupCode sc;
            sc.SetError( IDS_DARWIN_SERVICE_INTERNAL_ERROR, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_SERVICE_INTERNAL_ERROR );
            throw (sc);
        }

        if (ss.dwCurrentState != SERVICE_STOPPED)
        {
            // We must shut it down since it is not stopped already
            
            SERVICE_STATUS ss;
            BOOL bRes = ControlService(hService, SERVICE_CONTROL_STOP, &ss);
            if (FALSE == bRes)
            {
                LogThis( _T("StopDarwinService() - Call to ControlService() failed!"));
                
                DWORD res = GetLastError();
                LogThisDWORD( _T("  GetLastError() returned: <%i>"), res);
                
                CSetupCode sc;
                sc.SetError( IDS_DARWIN_SERVICE_INTERNAL_ERROR, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_SERVICE_INTERNAL_ERROR );
                throw (sc);
            }
            else
            {
                if (!WaitForServiceState(hService, SERVICE_STOPPED, &ss, 15000))
                {
                    LogThis(_T("StopDarwinService(): Call to WaitForServiceState() failed [Darwin service requires reboot]"));
                    
                    CSetupCode sc;
                    sc.SetError( IDS_DARWIN_SERVICE_REQ_REBOOT, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_SERVICE_REQ_REBOOT  );
                    throw (sc);
                }
                else
                {
                    LogThis(_T("StopDarwinService(): Darwin service successfully stopped"));
                }
            }
        }
        else
        {
            // Service was already stopped
            LogThis(_T("StopDarwinService(): Darwin Service was already stopped"));
        }
        
        if (hService != NULL)
            CloseServiceHandle(hService);
        if (hSCM != NULL)
            CloseServiceHandle(hSCM);
    }
    catch (CSetupCode cs)
    {
        if (hService != NULL)
            CloseServiceHandle(hService);
        if (hSCM != NULL)
            CloseServiceHandle(hSCM);

        throw(cs);
    }
}

BOOL WaitForServiceState(SC_HANDLE hService, DWORD dwDesiredState, SERVICE_STATUS* pss, DWORD dwMilliseconds)
{
    BOOL fServiceOK = TRUE;
    BOOL fFirstTime = TRUE;

    DWORD dwLastState = 0, dwLastCheckPoint = 0;
    DWORD dwTimeout = GetTickCount() + dwMilliseconds;

    for (;;)
    {
        fServiceOK = ::QueryServiceStatus(hService, pss);

        if (!fServiceOK) break;                                           // error occured
        if (pss->dwCurrentState == dwDesiredState) break;                 // desired state
        if ((dwMilliseconds != INFINITE) && (dwTimeout < GetTickCount())) // Timeout
        {
            fServiceOK = FALSE;
            SetLastError(ERROR_TIMEOUT);
            break;
        }


        if (fFirstTime)
        {
            dwLastState = pss->dwCurrentState;
            dwLastCheckPoint = pss->dwCheckPoint;
            fFirstTime = FALSE;
        }
        else
        {
            if (dwLastState != pss->dwCurrentState)
            {
                dwLastState = pss->dwCurrentState;
                dwLastCheckPoint = pss->dwCheckPoint;
            }
            else
            {
                if (pss->dwCheckPoint >= dwLastCheckPoint)
                {
                    // Good check point
                    dwLastCheckPoint = pss->dwCheckPoint;
                }
                else
                {
                    // Bad check point
                    fServiceOK = FALSE;
                    break;
                }
            }
        }

        // Wait the specified period of time
        DWORD dwWaitHint = pss->dwWaitHint / 10;
        if (dwWaitHint < 1000) dwWaitHint = 1000;
        if (dwWaitHint > 10000) dwWaitHint = 10000;
        Sleep(dwWaitHint);
    }

    return (fServiceOK);
}

//Detecting If Terminal Services is Installed
// code is taken directly from  http://msdndevstg/library/psdk/termserv/termserv_7mp0.htm


/* -------------------------------------------------------------
   Note that the ValidateProductSuite and IsTerminalServices
   functions use ANSI versions of Win32 functions to maintain
   compatibility with Windows 95/98.
   ------------------------------------------------------------- */

BOOL ValidateProductSuite (LPSTR lpszSuiteToValidate);

BOOL IsTerminalServicesEnabled() 
{
  BOOL    bResult = FALSE;
  DWORD   dwVersion;
  OSVERSIONINFOEXA osVersion;
  DWORDLONG dwlCondition = 0;
  HMODULE hmodK32 = NULL;
  HMODULE hmodNtDll = NULL;
  typedef ULONGLONG (WINAPI *PFnVerSetCondition) (ULONGLONG, ULONG, UCHAR);
  typedef BOOL (WINAPI *PFnVerifyVersionA) (POSVERSIONINFOEXA, DWORD, DWORDLONG);
  PFnVerSetCondition pfnVerSetCondition;
  PFnVerifyVersionA pfnVerifyVersionA;

  dwVersion = GetVersion();

  // Are we running Windows NT?

  if (!(dwVersion & 0x80000000)) 
  {
    // Is it Windows 2000 or greater?
    
    if (LOBYTE(LOWORD(dwVersion)) > 4) 
    {
      // In Windows 2000, use the VerifyVersionInfo and 
      // VerSetConditionMask functions. Don't static link because 
      // it won't load on earlier systems.

      hmodNtDll = GetModuleHandleA( "ntdll.dll" );
      if (hmodNtDll) 
      {
        pfnVerSetCondition = (PFnVerSetCondition) GetProcAddress( 
            hmodNtDll, "VerSetConditionMask");
        if (pfnVerSetCondition != NULL) 
        {
          dwlCondition = (*pfnVerSetCondition) (dwlCondition, 
              VER_SUITENAME, VER_AND);

          // Get a VerifyVersionInfo pointer.

          hmodK32 = GetModuleHandleA( "KERNEL32.DLL" );
          if (hmodK32 != NULL) 
          {
            pfnVerifyVersionA = (PFnVerifyVersionA) GetProcAddress(
               hmodK32, "VerifyVersionInfoA") ;
            if (pfnVerifyVersionA != NULL) 
            {
              ZeroMemory(&osVersion, sizeof(osVersion));
              osVersion.dwOSVersionInfoSize = sizeof(osVersion);
              osVersion.wSuiteMask = VER_SUITE_TERMINAL;
              bResult = (*pfnVerifyVersionA) (&osVersion,
                  VER_SUITENAME, dwlCondition);
            }
          }
        }
      }
    }
    else  // This is Windows NT 4.0 or earlier.

      bResult = ValidateProductSuite( "Terminal Server" );
  }

  return bResult;
}

////////////////////////////////////////////////////////////
// ValidateProductSuite function
//
// Terminal Services detection code for systems running
// Windows NT 4.0 and earlier.
//
////////////////////////////////////////////////////////////

BOOL ValidateProductSuite (LPSTR lpszSuiteToValidate) 
{
  BOOL fValidated = FALSE;
  LONG lResult;
  HKEY hKey = NULL;
  DWORD dwType = 0;
  DWORD dwSize = 0;
  LPSTR lpszProductSuites = NULL;
  LPSTR lpszSuite;

  // Open the ProductOptions key.

  lResult = RegOpenKeyA(
      HKEY_LOCAL_MACHINE,
      "System\\CurrentControlSet\\Control\\ProductOptions",
      &hKey
  );
  if (lResult != ERROR_SUCCESS)
      goto exit;

  // Determine required size of ProductSuite buffer.

  lResult = RegQueryValueExA( hKey, "ProductSuite", NULL, &dwType, 
      NULL, &dwSize );
  if (lResult != ERROR_SUCCESS || !dwSize)
      goto exit;

  // Allocate buffer.

  lpszProductSuites = (LPSTR) LocalAlloc( LPTR, dwSize );
  if (!lpszProductSuites)
      goto exit;

  // Retrieve array of product suite strings.

  lResult = RegQueryValueExA( hKey, "ProductSuite", NULL, &dwType,
      (LPBYTE) lpszProductSuites, &dwSize );
  if (lResult != ERROR_SUCCESS || dwType != REG_MULTI_SZ)
      goto exit;

  // Search for suite name in array of strings.

  lpszSuite = lpszProductSuites;
  while (*lpszSuite) 
  {
      if (lstrcmpA( lpszSuite, lpszSuiteToValidate ) == 0) 
      {
          fValidated = TRUE;
          break;
      }
      lpszSuite += (lstrlenA( lpszSuite ) + 1);
  }

exit:
  if (lpszProductSuites)
      LocalFree( lpszProductSuites );

  if (hKey)
      RegCloseKey( hKey );

  return fValidated;
}
////////////////////////////////////////////////////
// SetTSInInstallMode
// checks if Terminal Services is enabled and if so 
// switches machine in INSTALL mode
///////////////////////////////////////////////////
void SetTSInInstallMode()
{
    if (IsTerminalServicesEnabled())
    {

        TCHAR szAppPath[_MAX_PATH+2] = {_T('\0')};
        UINT uRes = GetSystemDirectory(szAppPath, _MAX_PATH);
        if ( (uRes != 0) && (uRes <=_MAX_PATH))
        {
            // check if the last char is '\' if not add it
            int len = _tcslen(szAppPath);
            if (_tcsrchr(szAppPath, _T('\\')) != szAppPath+len-1)
            {
                _tcsncat(szAppPath, _T("\\"), _MAX_PATH - _tcslen(szAppPath));
            }
            
            _tcsncat(szAppPath, TS_CHANGE_USER_INSTALL, _MAX_PATH - _tcslen(szAppPath));

            QuietExec(szAppPath);
        }
        else
        {
            // Couldn't get the system directory... just try and launch it straight
            QuietExec(TS_CHANGE_USER_INSTALL);
        }
        
    }
}

// ==========================================================================
// CTempLogPath::CTempLogPath()
//
// Purpose:
//  Constructor for CTempLogPath. It finds %TEMP% dir and appends pszLogName.
//  If the path is too long or anything fails, it raises exception.
// Inputs: 
//  pszLogName: name of the log file
// Outputs: none
// ==========================================================================
CTempLogPath::
CTempLogPath( LPCTSTR pszLogName ) : m_pszLogPath(NULL) 
{
    DWORD dwBufSize = 0;
    DWORD dwBufSize2 = 0;

    // see how much space we need to store %TEMP% path
    dwBufSize = GetTempPath( 0, m_pszLogPath );
    // raise exception if GetTempPath fails
    if ( 0 == dwBufSize ) 
    {
        CSetupError se( IDS_CANNOT_GET_TEMP_DIR, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_CANNOT_GET_TEMP_DIR, false );
        throw se;
    }

    dwBufSize++;
    dwBufSize*=2;


    dwBufSize += _tcslen(pszLogName);
    if ( _MAX_PATH < dwBufSize )
    {
        CSetupError se( IDS_TEMP_DIR_TOO_LONG, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_TEMP_DIR_TOO_LONG, false );
        throw se;
    }

    m_pszLogPath = new TCHAR[ dwBufSize +1];
    // initialize the buffer with zeros 
    memset( m_pszLogPath, 0, dwBufSize );
    dwBufSize2 = GetTempPath( dwBufSize, m_pszLogPath );
    if ( 0 == dwBufSize || dwBufSize2 + _tcslen(pszLogName)>= dwBufSize  ) 
    {
        CSetupError se( IDS_CANNOT_GET_TEMP_DIR, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_CANNOT_GET_TEMP_DIR, false );
        throw se;
    }

    // if we're not in a TS session, return
    if( !GetSystemMetrics(SM_REMOTESESSION) )
    {
        _tcscat( m_pszLogPath, pszLogName );
        return;
    }

    // we're in a TS session -- check for the 2 possible ways to turn off per-session temp dirs
    BOOL bOff1 = FALSE;
    BOOL bOff2 = FALSE;
    HKEY h;
    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\Terminal Server"), NULL, KEY_READ, &h) == ERROR_SUCCESS )
    {
        DWORD dwData = 0;
        DWORD dwSize = sizeof( dwData );
        if( RegQueryValueEx(h, _T("PerSessionTempDir"), NULL, NULL, (BYTE*)&dwData, &dwSize) == ERROR_SUCCESS )
        {
            bOff1 = !dwData;
        }
        RegCloseKey( h );
    }

    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\Terminal Server"), NULL, KEY_READ, &h) == ERROR_SUCCESS )
    {
        TCHAR szData[1024];
        DWORD dwSize = 1024;
        if( RegQueryValueEx(h, _T("FlatTempDir"), NULL, NULL, (BYTE*)szData, &dwSize) == ERROR_SUCCESS )
        {
            bOff2 = _ttoi( szData );
        }
        RegCloseKey( h );
    }

    // if either are set to TRUE, return
    if( bOff1 || bOff2 )
    {
        _tcscat( m_pszLogPath, pszLogName );
        return;
    }

    // per-session is on, so take the reutrn from GetTempPath, remove the last '\', and return that
    //  NOTE: since GTP() returns w/a '\' on the end, remove it first
    TCHAR* pszLast = &m_pszLogPath[_tcslen(m_pszLogPath) - 1];
    *pszLast = END_OF_STRING;
    
    // find the last \ + 1 and return (still need to return w/a trailing '\'
    pszLast = _tcsrchr( m_pszLogPath, _T('\\') ) + 1;
    if( pszLast )
    {
        *pszLast = END_OF_STRING;
    }
    _tcscat( m_pszLogPath, pszLogName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\customaction\urttempproc\urttempproc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/******************************************************************************
 * URTTempProc.cpp
 *
 * The CA will Copy URTCore.cab into the user temp location and schedule 
 * deferred CA to copy it into the System32 TEMP location.  Also schedule
 * Cleanup and Rollback actions.
 *
 *****************************************************************************/

#include <stdio.h>
#include <windows.h>
#include <tchar.h>
#include "msi.h"
#include "MsiDefs.h"
#include "msiquery.h"
#include "URTTempProc.h"
#include  <io.h>
#include  <stdlib.h>

extern "C"
UINT __stdcall ExtractUserTemp(MSIHANDLE hInstall)
{
    TCHAR tszTempPath[_MAX_PATH]    = {_T('\0')};
    TCHAR tszSystemTemp[_MAX_PATH]  = {_T('\0')};
    TCHAR tszCabName[]              = _T("URTCore.cab");
    TCHAR tszExtract[]              = _T("exploder.exe");
    TCHAR tszFullCabName[_MAX_PATH] = {_T('\0')};
    TCHAR tszFullExtract[_MAX_PATH] = {_T('\0')};
    TCHAR tszData[4 * _MAX_PATH]    = {_T('\0')};
    TCHAR tszSystemPath[_MAX_PATH]  = {_T('\0')};
    TCHAR tszMSCOREEPath[_MAX_PATH] = {_T('\0')};
    TCHAR tszSystemMSCOREEVer[50]   = {_T('\0')};
    DWORD dwVersionSize             = 50;
    UINT  uRetCode                  = ERROR_SUCCESS;
    TCHAR tszMSIMSCOREEVer[50]      = {_T('\0')};
    TCHAR tszURTTempPath[_MAX_PATH] = {_T('\0')};
    bool bContinueWithBootstrap     = false;
    TCHAR tszMSILog[_MAX_PATH]      = {_T('\0')};
    TCHAR tszSetProperty[50]        = _T("NOT_SET");
    DWORD dwTempPathLength = 0;

    DWORD  dwSize    = 0;
    LPTSTR lpCAData  = NULL;


    PMSIHANDLE hMsi = MSINULL;



// We are registering the keys only if SkipStrongNameVerification is defined.
// We can turn this property off in RTM skus.

    char szProperty[_MAX_PATH] = "";
    DWORD dwLen = sizeof(szProperty);
    uRetCode = MsiGetProperty(hInstall, "SkipStrongNameVerification", szProperty, &dwLen);
    
    if ((uRetCode != ERROR_SUCCESS) || (0 == strlen(szProperty)))
    {
        FWriteToLog (hInstall, _T("\tSTATUS: SkipStrongNameVerification property not defined"));
    }

    else
    {
        
        HKEY hk = 0;
        LONG lResult;
        
        FWriteToLog (hInstall, _T("\tSTATUS: SkipStrongNameVerification property is defined"));
        lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE,                                                           // handle to open key
                                  _T("SOFTWARE\\Microsoft\\StrongName\\Verification\\*,03689116d3a4ae33"),      // subkey name
                                  0,                                                                            // reserved
                                  NULL,                                                                         // class string
                                  REG_OPTION_NON_VOLATILE,                                                      // special options
                                  KEY_WRITE,                                                                    // desired security access
                                  NULL,                                                                         // inheritance
                                  &hk,                                                                          // key handle 
                                  NULL                                                                          // disposition value buffer
                                );

        if (ERROR_SUCCESS == lResult)
        {
            RegCloseKey( hk );
        }
        else
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed in Create regkey *,03689116d3a4ae33"));
        }

    //
        lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE,                                                           // handle to open key
                                  _T("SOFTWARE\\Microsoft\\StrongName\\Verification\\*,33aea4d316916803"),      // subkey name
                                  0,                                                                            // reserved
                                  NULL,                                                                         // class string
                                  REG_OPTION_NON_VOLATILE,                                                      // special options
                                  KEY_WRITE,                                                                    // desired security access
                                  NULL,                                                                         // inheritance
                                  &hk,                                                                          // key handle 
                                  NULL                                                                          // disposition value buffer
                                );

        if (ERROR_SUCCESS == lResult)
        {
            FWriteToLog (hInstall, _T("\tSTATUS: Created regkey *,33aea4d316916803"));
            RegCloseKey( hk );
        }
        else
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed in Create regkey *,33aea4d316916803"));
        }

    //
        lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE,                                                           // handle to open key
                                  _T("SOFTWARE\\Microsoft\\StrongName\\Verification\\*,b03f5f7f11d50a3a"),      // subkey name
                                  0,                                                                            // reserved
                                  NULL,                                                                         // class string
                                  REG_OPTION_NON_VOLATILE,                                                      // special options
                                  KEY_WRITE,                                                                    // desired security access
                                  NULL,                                                                         // inheritance
                                  &hk,                                                                          // key handle 
                                  NULL                                                                          // disposition value buffer
                                );

        if (ERROR_SUCCESS == lResult)
        {
            FWriteToLog (hInstall, _T("\tSTATUS: Created regkey *,b03f5f7f11d50a3a"));
            RegCloseKey( hk );
        }
        else
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed in Create regkey *,b03f5f7f11d50a3a"));
        }

    //
        lResult = RegCreateKeyEx( HKEY_LOCAL_MACHINE,                                                           // handle to open key
                                  _T("SOFTWARE\\Microsoft\\StrongName\\Verification\\*,b77a5c561934e089"),      // subkey name
                                  0,                                                                            // reserved
                                  NULL,                                                                         // class string
                                  REG_OPTION_NON_VOLATILE,                                                      // special options
                                  KEY_WRITE,                                                                    // desired security access
                                  NULL,                                                                         // inheritance
                                  &hk,                                                                          // key handle 
                                  NULL                                                                          // disposition value buffer
                                );

        if (ERROR_SUCCESS == lResult)
        {
            FWriteToLog (hInstall, _T("\tSTATUS: Created regkey *,b77a5c561934e089"));
            RegCloseKey( hk );
        }
        else
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed in Create regkey *,b77a5c561934e089"));
        }
    } //end else


    // This provides a fix for Bug No. 281997 regarding GetTempPath problems.
    // Get the user temp path
    dwTempPathLength = GetTempPath(_MAX_PATH, tszTempPath);

    // Check the actual length of the Temp Path
    // If temp path is longer then _MAX_PATH - max(length(tszExtract), length(tszCabName)), then we have to fail
    if(dwTempPathLength > (_MAX_PATH - ((_tcslen(tszCabName) > _tcslen(tszExtract)) ? _tcslen(tszCabName): _tcslen(tszExtract))))
    {     
        FWriteToLog (hInstall, _T("\tERROR: Temp Path too long"));
        return ERROR_INSTALL_FAILURE;
    }

    // Darwin expect the final directory in the <SYSTEM>\URTTemp location.
    _tcscpy(tszSystemTemp, _T("URTTemp"));
    
    // Generate the Full CAB Name
    _tcscpy(tszFullCabName, tszTempPath);
    _tcscat(tszFullCabName, tszCabName);

    // Generate the Full Extract tool name
    _tcscpy(tszFullExtract, tszTempPath);
    _tcscat(tszFullExtract, tszExtract);

    hMsi = MsiGetActiveDatabase(hInstall);

    if (MSINULL == hMsi)
    {
        FWriteToLog (hInstall, _T("\tERROR: Failed in MsiGetActiveDatabase"));
        return ERROR_INSTALL_FAILURE;
    }

    // Get location of System Dir
    GetSystemDirectory(tszSystemPath, _MAX_PATH);

    _tcscpy(tszURTTempPath, tszSystemPath);
    _tcscat(tszURTTempPath, _T("\\"));
    _tcscat(tszURTTempPath, tszSystemTemp);

    // MSCOREE.DLL should exists on the User's system if URT is previously installed
    _tcscpy(tszMSCOREEPath, tszSystemPath);
    _tcscat(tszMSCOREEPath, _T("\\mscoree.dll"));

    // Detect if MSCOREE is in the user's system
    if ( -1 == _taccess( tszMSCOREEPath, 0 ) )
    {
        // if MSCOREE is not in the system, continue with bootstrap
        FWriteToLog (hInstall, _T("\tSTATUS: MSCOREE.DLL not in <SYSTEM>"));

        // Setting property : CARRYINGNDP will tell Darwin to use the Bootstrapped version of URT.
        FWriteToLog (hInstall, _T("\tSTATUS: Set property : CARRYINGNDP : URTUPGRADE"));
        MsiSetProperty( hInstall, _T("CARRYINGNDP"), _T("URTUPGRADE") );
        _tcscpy(tszSetProperty, _T("URTUPGRADE"));

        bContinueWithBootstrap = true;
    }
    else
    {
        // If the file exist in the user's system

        // Get MSCOREE version from System
        if ( ERROR_SUCCESS != MsiGetFileVersion( tszMSCOREEPath,
                                                 tszSystemMSCOREEVer,
                                                 &dwVersionSize,
                                                 0,
                                                 0 ) )
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed to obtain MSCOREE.DLL version in <SYSTEM>"));
        }
        else
        {
            _stprintf( tszMSILog,
                       _T("\tSTATUS: MSCOREE.DLL version in <SYSTEM> : %s"),
                       tszSystemMSCOREEVer );

            FWriteToLog (hInstall, tszMSILog);
        }

        // Get MSCOREE version from MSI
        if ( !GetMSIMSCOREEVersion(hMsi, tszMSIMSCOREEVer) )
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed to obtain MSCOREE.DLL version in MSI"));
        }
        else
        {
            _stprintf( tszMSILog,
                       _T("\tSTATUS: MSCOREE.DLL version in MSI : %s"),
                       tszMSIMSCOREEVer );

            FWriteToLog (hInstall, tszMSILog);
        }

        // Compare Version
        // if the version in the MSI is greater, then use the URTTEMP MSCOREE
        // else use the version in SYSTEM.  This is done by setting property CARRYINGNDP

        if ( -99 == VersionCompare(tszMSIMSCOREEVer, tszSystemMSCOREEVer) )
        {
            // Compare version failed, use <SYSTEM> copy of URT, this shouldn't happen.
            // Hopefully setup will work with the URT that's already installed.
            // If not, the log will show this ERROR.
            FWriteToLog (hInstall, _T("\tERROR: Failed to Compare Version, don't bootstrap."));
        }
        else if ( 1 == VersionCompare(tszMSIMSCOREEVer, tszSystemMSCOREEVer ) )
        {
            // MSI Version is newer than the version exisits in System
            FWriteToLog (hInstall, _T("\tSTATUS: MSCOREE.DLL in <SYSTEM> is older, need to bootstrap."));

            // Setting property : CARRYINGNDP will tell Darwin to use the Bootstrapped version of URT.
            FWriteToLog (hInstall, _T("\tSTATUS: Set property : CARRYINGNDP : URTUPGRADE"));
            MsiSetProperty( hInstall, _T("CARRYINGNDP"), _T("URTUPGRADE") );
            _tcscpy(tszSetProperty, _T("URTUPGRADE"));

            bContinueWithBootstrap = true;
        }
        else if ( 0 == VersionCompare(tszMSIMSCOREEVer, tszSystemMSCOREEVer ) )
        {
            // MSI Version is the same as the version exisits in <SYSTEM>
            FWriteToLog (hInstall, _T("\tSTATUS: MSCOREE.DLL in <SYSTEM> is same, need to bootstrap."));

            // Setting property : CARRYINGNDP will tell Darwin to use the Bootstrapped version of URT.
            // URTREINSTALL will tell Darwin to use the bootstrapped version if possible.  Else use <SYSTEM> version.
            FWriteToLog (hInstall, _T("\tSTATUS: Set property : CARRYINGNDP : URTREINSTALL"));
            MsiSetProperty( hInstall, _T("CARRYINGNDP"), _T("URTREINSTALL") );
            _tcscpy(tszSetProperty, _T("URTREINSTALL"));

            bContinueWithBootstrap = true;
        }
        else
        {
            // MSI Version is the same or older than the version in System : No action needed.
            FWriteToLog (hInstall, _T("\tSTATUS: MSCOREE.DLL in <SYSTEM> is equal or greater, don't need to bootstrap."));
        }
    }

    // Don't need bootstrapping (Default bContinueWithBootstrap = false)
    if ( !bContinueWithBootstrap )
    {
        // UNSET property : if CARRYINGNDP property is not set.  The SYSTEM 32 version will be used.
        FWriteToLog (hInstall, _T("\tSTATUS: Unset property : CARRYINGNDP"));
        MsiSetProperty( hInstall, _T("CARRYINGNDP"), NULL );
        return uRetCode;
    }


    //
    // We now started the bootstrapping extraction code.
    //

    if ( ERROR_SUCCESS != WriteStreamToFile(hMsi, _T("Binary.BINExtract"), tszFullExtract) )
    {
        FWriteToLog (hInstall, _T("\tERROR: Failed to extract extration tool"));
        uRetCode = ERROR_INSTALL_FAILURE;
    }

    if ( ERROR_SUCCESS != WriteStreamToFile(hMsi, _T("Binary.URTCoreCab"), tszFullCabName) )
    {
        FWriteToLog (hInstall, _T("\tERROR: Failed to extract URTCoreCab"));
        uRetCode = ERROR_INSTALL_FAILURE;
    }

    //
    // Get the Hash for BINExtract and URTCoreCab From MSI property
    //

    // Set the size for the Property
    MsiGetProperty(hInstall, _T("UrtCabHash"), _T(""), &dwSize);
    
    // Create buffer for the property
    lpCAData = new TCHAR[++dwSize];

    if (NULL == lpCAData)
    {
        FWriteToLog (hInstall, _T("\tERROR: Failed to allocate memory for UrtCabHash"));
        return ERROR_INSTALL_FAILURE;
    }
    
    if ( ERROR_SUCCESS != MsiGetProperty( hInstall,
                                          _T("UrtCabHash"),
                                          lpCAData,
                                          &dwSize ) )
    {
        FWriteToLog (hInstall, _T("\tERROR: Failed to MsiGetProperty for UrtCabHash"));
        delete [] lpCAData;
        lpCAData = NULL;
        return ERROR_INSTALL_FAILURE;
    }


    // Constructing the data for use in the deferred CA
    _tcscpy(tszData, tszTempPath);
    _tcscat(tszData, _T(";"));
    _tcscat(tszData, tszSystemTemp);
    _tcscat(tszData, _T(";"));
    _tcscat(tszData, tszCabName);
    _tcscat(tszData, _T(";"));
    _tcscat(tszData, tszExtract);
    _tcscat(tszData, _T(";"));
    _tcscat(tszData, tszSetProperty);
    _tcscat(tszData, _T(";"));
    _tcscat(tszData, lpCAData);

    delete [] lpCAData;
    lpCAData = NULL;

    // Create a deferred custom action
    // Deferred custom actions can't read tables, so we have to set a property
    if ( ERROR_SUCCESS  != MsiSetProperty( hInstall,
                                           _T("CA_BootstrapURT_Rollback.3643236F_FC70_11D3_A536_0090278A1BB8"),
                                           tszData) )
    {
        FWriteToLog (hInstall, _T("\tERROR: Failed to Set data for Rollback CA : CA_BootstrapURT_Rollback"));
        uRetCode = ERROR_INSTALL_FAILURE;
    }
    else
    {
        if ( ERROR_SUCCESS != MsiDoAction(hInstall, _T("CA_BootstrapURT_Rollback.3643236F_FC70_11D3_A536_0090278A1BB8")) )
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed Schedule Rollback CA : CA_BootstrapURT_Rollback"));
            uRetCode = ERROR_INSTALL_FAILURE;
        }
    }

    // Create a deferred custom action
    // Deferred custom actions can't read tables, so we have to set a property
    if ( ERROR_SUCCESS  != MsiSetProperty( hInstall,
                                           _T("CA_BootstrapURT_Def.3643236F_FC70_11D3_A536_0090278A1BB8"),
                                           tszData) )
    {
        FWriteToLog (hInstall, _T("\tERROR: Failed to Set data for Deferred CA : CA_BootstrapURT_Def"));
        uRetCode = ERROR_INSTALL_FAILURE;
    }
    else
    {
        if ( ERROR_SUCCESS != MsiDoAction(hInstall, _T("CA_BootstrapURT_Def.3643236F_FC70_11D3_A536_0090278A1BB8")) )
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed Schedule for Deferred CA : CA_BootstrapURT_Def"));
            uRetCode = ERROR_INSTALL_FAILURE;
        }
    }

    // Create a deferred custom action
    // Deferred custom actions can't read tables, so we have to set a property
    if ( ERROR_SUCCESS  != MsiSetProperty( hInstall,
                                           _T("CA_BootstrapURT_Commit.3643236F_FC70_11D3_A536_0090278A1BB8"),
                                           tszData) )
    {
        FWriteToLog (hInstall, _T("\tERROR: Failed to Set data for Commit CA : CA_BootstrapURT_Commit"));
        uRetCode = ERROR_INSTALL_FAILURE;
    }
    else
    {
        if ( ERROR_SUCCESS != MsiDoAction(hInstall, _T("CA_BootstrapURT_Commit.3643236F_FC70_11D3_A536_0090278A1BB8")) )
        {
            FWriteToLog (hInstall, _T("\tERROR: Failed Schedule for Commit CA : CA_BootstrapURT_Commit"));
            uRetCode = ERROR_INSTALL_FAILURE;
        }
    }

    return uRetCode;
}


///////////////////////////////////////////////////////////////////////////////
/*

  Name: WriteStreamToFile()

  This function will write the file lpFileName by extracting the lpStreamName
  from the Binary table
                            
*/
///////////////////////////////////////////////////////////////////////////////


UINT WriteStreamToFile(MSIHANDLE hMsi, LPTSTR lpStreamName, LPTSTR lpFileName)
{
    PMSIHANDLE hView        = MSINULL;
    PMSIHANDLE hRec         = MSINULL;
    PBYTE      lpbCabBuffer = NULL;
    DWORD      dwBufSize    = 0;
    DWORD      dwActBytes   = 0;
    UINT       uiStat       = ERROR_SUCCESS;
    UINT       uRetCode     = ERROR_SUCCESS;

    TCHAR      tszQuery[_MAX_PATH];

    _stprintf( tszQuery,
               _T("SELECT `Data` FROM `_Streams` WHERE `Name` = '%s'"),
               lpStreamName );

    uiStat = MsiDatabaseOpenView(hMsi, tszQuery, &hView);
    if (ERROR_SUCCESS == uiStat)
    { 
        // Execute MSI Query
        uiStat = MsiViewExecute(hView, (MSIHANDLE)0);
        if (ERROR_SUCCESS != uiStat)
        {
            return ERROR_INSTALL_FAILURE;
        }
    }
    else
    {
        return ERROR_INSTALL_FAILURE;
    }

    uiStat = MsiViewFetch(hView,&hRec);
    if ( ERROR_SUCCESS == uiStat )
    {
        //this returns the number of bytes to allocate
        uiStat = MsiRecordReadStream(hRec, 1, 0, &dwBufSize);
        if (ERROR_SUCCESS == uiStat )
        {
            //allocating the required memory to the buffer
            if(NULL == (lpbCabBuffer = new BYTE[dwBufSize]))
            {
                return ERROR_INSTALL_FAILURE;
            }
       
            //this is actual call which fills the buffer with data
            if(ERROR_SUCCESS == MsiRecordReadStream(hRec,
                                                    1,
                                                    (char *)lpbCabBuffer,
                                                    &dwBufSize))
            {
                HANDLE hFile = 0;

                //creates the temporary File and opens 
                hFile = CreateFile(lpFileName,              // file name
                                   GENERIC_WRITE,           // write access mode
                                   0,                       // security attributes
                                   NULL,                    // share mode
                                   CREATE_ALWAYS,           // always creates a new one
                                   FILE_ATTRIBUTE_NORMAL,   // file attributes
                                   NULL);                   // template file

                if ( INVALID_HANDLE_VALUE != hFile )
                {
                    WriteFile(hFile, lpbCabBuffer, dwBufSize, &dwActBytes, NULL);
                    CloseHandle(hFile);
                }
                else
                {
                    uRetCode = ERROR_INSTALL_FAILURE;
                }

            } // END if (ERROR_SUCCESS == MsiRecordReadStream)

            else
            {
                uRetCode = ERROR_INSTALL_FAILURE;
            }

            //deleting the memory allocated for streaming to buffer
            delete [] lpbCabBuffer;
            lpbCabBuffer = NULL;

        } // END if (ERROR_SUCCESS == MsiRecordReadStream)
        else
        {
            uRetCode = ERROR_INSTALL_FAILURE;
        }

    }   // END if (ERROR_SUCCESS == MsiViewFetch())
    else
    {
        uRetCode = ERROR_INSTALL_FAILURE;

    }   // END else if (ERROR_SUCCESS == MsiViewFetch())
   
    return uRetCode;
}


///////////////////////////////////////////////////////////////////////////////
/*

  Name: GetMSIMSCOREEVersion()

  Get the version of MSCOREE from the MSI

  INPUT :
    hMsi - Handle to a MSI

  OUTPUT :
    lpVersionString - The Version of MSCOREE

  RETURN :
    true  - if success
    false - if failed

*/
///////////////////////////////////////////////////////////////////////////////

bool GetMSIMSCOREEVersion(MSIHANDLE hMsi, LPTSTR lpVersionString)
{

    TCHAR tszQuery[]   = _T("SELECT File.Version FROM File WHERE File.File = 'FL_mscoree_dll_____X86.3643236F_FC70_11D3_A536_0090278A1BB8'");
    TCHAR tszTemp[50]  = {_T('\0')};
    PMSIHANDLE hView   = NULL;
    PMSIHANDLE hRec    = NULL;
    DWORD dwSize       = 50;
    bool  bRet         = false;

    if ( ERROR_SUCCESS == MsiDatabaseOpenView(hMsi,(LPCTSTR)tszQuery, &hView) )
    { 
        if (ERROR_SUCCESS == MsiViewExecute(hView, (MSIHANDLE)0) ) 
        {
            if (ERROR_SUCCESS == MsiViewFetch(hView, &hRec) ) 
            {
                if ( ERROR_SUCCESS == MsiRecordGetString( hRec, 
                                                          1, 
                                                          tszTemp,
                                                          &dwSize ))
                {
                    _tcscpy(lpVersionString, tszTemp);
                    bRet = true;
                }
            }
        }
    }

    return bRet;
}


///////////////////////////////////////////////////////////////////////////////
/*

  Name: VersionCompare()

  Compare two version string.

  INPUT :
    lpVersion1 - String of first version to compare
    lpVersion2 - String of second version to compare

  OUTPUT :
    N/A

  RETURN :
    -1 if lpVersion1 < lpVersion2
     0 if lpVersion1 = lpVersion2
     1 if lpVersion1 > lpVersion2
   -99 if ERROR occurred

                            
*/
///////////////////////////////////////////////////////////////////////////////

int VersionCompare(LPTSTR lpVersion1, LPTSTR lpVersion2)
{
    FILE_VERSION Version1;
    FILE_VERSION Version2;
    int          iRet = 0;

    if ( !ConvertVersionToINT(lpVersion1, &Version1) )
    {
        return -99;
    }

    if ( !ConvertVersionToINT(lpVersion2, &Version2) )
    {
        return -99;
    }

    if ( Version1.FileVersionMS_High > Version2.FileVersionMS_High )
    {
        iRet = 1;
    }
    else if ( Version1.FileVersionMS_High < Version2.FileVersionMS_High )
    {
        iRet = -1;
    }

    if ( 0 == iRet )
    {
        if ( Version1.FileVersionMS_Low > Version2.FileVersionMS_Low )
        {
            iRet = 1;
        }
        else if ( Version1.FileVersionMS_Low < Version2.FileVersionMS_Low )
        {
            iRet = -1;
        }
    }

    if ( 0 == iRet )
    {
        if ( Version1.FileVersionLS_High > Version2.FileVersionLS_High )
        {
            iRet = 1;
        }
        else if ( Version1.FileVersionLS_High < Version2.FileVersionLS_High )
        {
            iRet = -1;
        }
    }

    if ( 0 == iRet )
    {
        if ( Version1.FileVersionLS_Low > Version2.FileVersionLS_Low )
        {
            iRet = 1;
        }
        else if ( Version1.FileVersionLS_Low < Version2.FileVersionLS_Low )
        {
            iRet = -1;
        }
    }

    return iRet;
}


///////////////////////////////////////////////////////////////////////////////
/*

  Name: ConvertVersionToINT()

  Converts a string version into 4 parts of integers

  INPUT :
    lpVersionString - A input version string

  OUTPUT :
    pFileVersion - A structure that stores the version in to 4 integers

  RETURN :
    true  - if success
    false - if failed
                       
*/
///////////////////////////////////////////////////////////////////////////////

bool ConvertVersionToINT(LPTSTR lpVersionString, PFILE_VERSION pFileVersion)
{
    LPTSTR lpToken  = NULL;
    TCHAR tszVersionString[50] = {_T('\0')};
    bool bRet = true;

    _tcscpy(tszVersionString, lpVersionString);

    lpToken = _tcstok(tszVersionString, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionMS_High = atoi(lpToken);
    }

    lpToken = _tcstok(NULL, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionMS_Low = atoi(lpToken);
    }

    lpToken = _tcstok(NULL, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionLS_High = atoi(lpToken);
    }

    lpToken = _tcstok(NULL, _T("."));

    if (NULL == lpToken)
    {
        bRet = false;
    }
    else
    {
        pFileVersion->FileVersionLS_Low = atoi(lpToken);
    }

    return bRet;
}


// ==========================================================================
// FWriteToLog()
//
// Purpose:
//  Write given string to the Windows Installer log file for the given install
//  installation session
//  Copied from the HTML Project, should someday use one logging function.
//
// Inputs:
//  hSession            Windows Install Handle to current installation session
//  tszMessage          Const pointer to a string.
// Outputs:
//  Returns true for success, and false if it fails.
//  If successful, then the string (tszMessage) is written to the log file.
// Dependencies:
//  Requires Windows Installer & that an install be running.
// Notes:
// ==========================================================================

bool FWriteToLog( MSIHANDLE hSession, LPCTSTR ctszMessage )
{
    PMSIHANDLE hMsgRec = MsiCreateRecord( 1 );
    bool bRet = false;

    if( ERROR_SUCCESS == ::MsiRecordSetString( hMsgRec, 0, ctszMessage ) )
    {
       if( IDOK == ::MsiProcessMessage( hSession, INSTALLMESSAGE_INFO, hMsgRec ) )
       {
            bRet = true;
       }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\makefile.inc ===
# additional dependencies

ndp_fxsetuplib:
       @if not exist .\$(_TGTCPU)                     mkdir .\$(_TGTCPU)
       @if not exist .\$(_TGTCPU)\$(DDKBUILDENV)      mkdir .\$(_TGTCPU)\$(DDKBUILDENV)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\adminprivs.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
FILE:    AdminPrivs.cpp
PROJECT: UTILS.LIB
DESC:    Implementation of AdminPrivs functions
OWNER:   JoeA

****************************************************************************/


//#include "stdafx.h"
#include "AdminPrivs.h"
#include <osver.h>

// 
// Make up some private access rights.
// 
const int ACCESS_READ  = 1;
const int ACCESS_WRITE = 2;

const int iBuffSize = 128;

/******************************************************************************
Function Name:  CheckUserPrivileges
Description:  Checks to see if the current user has local Admin privileges
Inputs: None 
Results:  Returns TRUE if the user has local admin rights or we are
          running on Win9x, FALSE otherwise.
Written By: aaronste
******************************************************************************/
BOOL UserHasPrivileges()
{
    BOOL bReturnValue = FALSE;

    //get os information
    TCHAR pszOS[iBuffSize+1]  = { _T( '\0' ) };
    TCHAR pszVer[iBuffSize+1] = { _T( '\0' ) };
    TCHAR pszSP[iBuffSize+1]  = { _T( '\0' ) };
    BOOL  fServer = FALSE;

    OS_Required os = GetOSInfo( pszOS, pszVer, pszSP, fServer );

    // If this in Win9x, we don't need to check because there is no
    // concept of an Administrator account
    if ( ( os == OSR_9XOLD )  || 
         ( os == OSR_98GOLD ) || 
         ( os == OSR_98SE )   || 
         ( os == OSR_ME )     || 
         ( os == OSR_FU9X ) )
    {
        bReturnValue = TRUE;
    }
    else
        bReturnValue = IsAdmin();

    return bReturnValue;
}


/******************************************************************************
Function Name:  IsAdmin
Description:    Checks the token of the calling thread to see if
                the caller belongs to the Administrators group
Inputs:         None 
Results:        TRUE if the caller is an administrator on the local
                machine.  Otherwise, FALSE.
Written By:     http://support.microsoft.com/support/kb/articles/Q118/6/26.ASP
******************************************************************************/
BOOL IsAdmin( void )
{
   HANDLE hToken;
   DWORD  dwStatus;
   DWORD  dwAccessMask;
   DWORD  dwAccessDesired;
   DWORD  dwACLSize;
   DWORD  dwStructureSize = sizeof(PRIVILEGE_SET);
   PACL   pACL            = NULL;
   PSID   psidAdmin       = NULL;
   BOOL   bReturn         = FALSE;

   PRIVILEGE_SET   ps;
   GENERIC_MAPPING GenericMapping;

   PSECURITY_DESCRIPTOR     psdAdmin           = NULL;
   SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
   
   __try
   {

      // AccessCheck() requires an impersonation token.
      ImpersonateSelf( SecurityImpersonation );

      if( !OpenThreadToken( GetCurrentThread(), 
          TOKEN_QUERY, 
          FALSE, 
          &hToken ) )
      {

         if( GetLastError() != ERROR_NO_TOKEN )
            __leave;

         // If the thread does not have an access token, we'll 
         // examine the access token associated with the process.
         if( !OpenProcessToken( GetCurrentProcess(), 
                TOKEN_QUERY, 
                &hToken ) )
            __leave;
      }

      if( !AllocateAndInitializeSid( &SystemSidAuthority, 
            2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 
            0, 
            0, 
            0, 
            0, 
            0, 
            &psidAdmin ) )
         __leave;

      psdAdmin = LocalAlloc( LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH );
      if( psdAdmin == NULL )
         __leave;

      if( !InitializeSecurityDescriptor( psdAdmin,
            SECURITY_DESCRIPTOR_REVISION ) )
         __leave;
  
      // Compute size needed for the ACL.
      dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
            GetLengthSid(psidAdmin) - sizeof(DWORD);

      // Allocate memory for ACL.
      pACL = (PACL)LocalAlloc(LPTR, dwACLSize);
      if( pACL == NULL )
         __leave;

      // Initialize the new ACL.
      if( !InitializeAcl( pACL, dwACLSize, ACL_REVISION2 ) )
         __leave;

      dwAccessMask = ACCESS_READ | ACCESS_WRITE;
      
      // Add the access-allowed ACE to the DACL.
      if( !AddAccessAllowedAce( pACL, 
            ACL_REVISION2,
            dwAccessMask, 
            psidAdmin ) )
         __leave;

      // Set our DACL to the SD.
      if( !SetSecurityDescriptorDacl( psdAdmin, TRUE, pACL, FALSE ) )
         __leave;

      // AccessCheck is sensitive about what is in the SD; set
      // the group and owner.
      SetSecurityDescriptorGroup( psdAdmin, psidAdmin, FALSE );
      SetSecurityDescriptorOwner( psdAdmin, psidAdmin, FALSE );

      if( !IsValidSecurityDescriptor( psdAdmin ) )
         __leave;

      dwAccessDesired = ACCESS_READ;

      // 
      // Initialize GenericMapping structure even though we
      // won't be using generic rights.
      // 
      GenericMapping.GenericRead    = ACCESS_READ;
      GenericMapping.GenericWrite   = ACCESS_WRITE;
      GenericMapping.GenericExecute = 0;
      GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;

      if( !AccessCheck( psdAdmin, 
            hToken, 
            dwAccessDesired, 
            &GenericMapping, 
            &ps, 
            &dwStructureSize, 
            &dwStatus, 
            &bReturn ) )
         __leave;

      RevertToSelf();
   
   } 
   __finally
   {
      // Cleanup 
      if( pACL ) 
          LocalFree( pACL );
      if( psdAdmin ) 
          LocalFree( psdAdmin );  
      if( psidAdmin ) 
          FreeSid( psidAdmin );
   }

   return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\msiwrapper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     MsiWrapper.cpp
// Owner:    jbae
// Purpose:  This class wraps function calls to msi.dll. To support delayed reboot,
//           we need to load msi.dll from the location specified in registry.
//                              
// History:
//  03/06/01, jbae: created

#include "MsiWrapper.h"
#include "SetupError.h"
#include "fxsetuplib.h"

// Constructors
//
// ==========================================================================
// CMsiWrapper::CMsiWrapper()
//
// Inputs: none
// Purpose:
//  Initialize m_hMsi and m_pFn to NULL
// ==========================================================================
CMsiWrapper::
CMsiWrapper()
: m_hMsi(NULL), m_pFn(NULL)
{
}

// ==========================================================================
// CMsiWrapper::~CMsiWrapper()
//
// Inputs: none
// Purpose:
//  frees m_hMsi
// ==========================================================================
CMsiWrapper::
~CMsiWrapper()
{
    ::FreeLibrary( m_hMsi );
}

// Implementations
//
// ==========================================================================
// CMsiReader::LoadMsi()
//
// Purpose:
//  Loads msi.dll by calling LoadDarwinLibrary().
// Inputs:
//  none
// Outputs:
//  sets m_hMsi
// ==========================================================================
void CMsiWrapper::
LoadMsi()
{
    m_hMsi = LoadDarwinLibrary();
    if ( NULL == m_hMsi )
    {
        CSetupError se( IDS_DARWIN_NOT_INSTALLED, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_NOT_INSTALLED );
        throw( se );
    }
}

// ==========================================================================
// CMsiReader::GetFn()
//
// Purpose:
//  Returns pointer to the function name passed in
// Inputs:
//  LPTSTR pszFnName: name of the function to call
// Outputs:
//  sets m_pFn
// Returns:
//  pointer to a function
// ==========================================================================
void *CMsiWrapper::
GetFn( LPTSTR pszFnName )
{
    _ASSERTE( NULL != m_hMsi );
    m_pFn = ::GetProcAddress( m_hMsi, pszFnName );
    if ( NULL == m_pFn )
    {
        // TODO: need proper message
        CSetupError se( IDS_DARWIN_NOT_INSTALLED, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_NOT_INSTALLED );
        throw( se );
    }

    return m_pFn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\fxsetuplib.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/************************************************************************************************
 *																								*
 *	File: fxsetuplib.h                                                                               *
 *	Purpose: The all inclusive include file (aside from the resources.h) for Setup.             *
 *                                                                                              *
 ************************************************************************************************/

#ifndef FXSETUPLIB_H
#define FXSETUPLIB_H

// standard include files
#include <stdlib.h>
#include <stdio.h>          // for fprintf()
#include <io.h>             // for _taccess()
#include "windows.h"
#include "winbase.h"
#include "winreg.h"
#include "winsvc.h"
#include <new.h>

// additional include files
//#include "__product__.ver"  // build version information
#include "msi.h"
#include "msiquery.h"
#include "resource.h"
#include "setupapi.h"
#include "SetupCodes.h"
#include "SHLWAPI.H"
#include <TCHAR.H>
#include <crtdbg.h>
#include "SetupError.h"
#include "ReadFlags.h"
#include <iostream>

#define LENGTH(A) (sizeof(A)/sizeof(A[0]))

using namespace std;

typedef basic_string<TCHAR> tstring;

// constants
const DWORD   DARWIN_MAJOR    = 2 ;             // Darwin version information
const DWORD   DARWIN_MINOR    = 0 ;
const DWORD   DARWIN_BUILD    = 2600 ;

const DWORD   BUF_8_BIT       = 255 ;           // General Constants
const UINT    BUF_4_BIT       = 127 ;
const UINT    LONG_BUF        = 1024 ;

const UINT    DARWIN_VERSION_OLD    = 1;
const UINT    DARWIN_VERSION_NONE   = 2;

// NT4 SP6A registry key
const TCHAR   NTSP6A_REGKEY[]       = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix\\Q246009");
const TCHAR   NTSP6A_REGNAME[]      = _T("Installed");
const DWORD   NTSP6A_REGVALUE       = 1;

// IE 5.01 registry key
const TCHAR   IE_REGKEY[]           = _T("SOFTWARE\\Microsoft\\Internet Explorer");
const TCHAR   IE_REGNAME[]          = _T("Version");
const TCHAR   IE_VERSION[]          = _T("5.0.2919.6307");

// MDAC 2.7 registry key
const TCHAR   MDAC_REGKEY[]         = _T("SOFTWARE\\Microsoft\\DataAccess");
const TCHAR   MDAC_REGNAME[]        = _T("FullInstallVer");
const TCHAR   MDAC_VERSION[]        = _T("2.70.7713.0");

// darwin install command
const TCHAR   DARWIN_REGKEY[]      = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer");
const TCHAR   DARWIN_REGNAME[]     = _T("InstallerLocation");
const TCHAR   INST_CERT_CMD[]      = _T("Insttrc.exe");
const TCHAR   DARWIN_SETUP_CMD_A[] = _T("InstMsi.exe /c:\"msiinst /delayrebootq\"");
const TCHAR   DARWIN_SETUP_CMD_W[] = _T("InstMsiW.exe /c:\"msiinst /delayrebootq\"");
const TCHAR   TS_CHANGE_USER_INSTALL[] = _T("change user /INSTALL");

// darwin properties for install/uninstall
const TCHAR   ADDLOCAL_PROP[]      = _T("ADDLOCAL=All");
const TCHAR   REBOOT_PROP[]        = _T("REBOOT=ReallySuppress");
const TCHAR   NOARP_PROP[]         = _T("ARPSYSTEMCOMPONENT=1 ARPNOREMOVE=1");
const TCHAR IIS_NOT_PRESENT_PROP[] = _T("IIS_NOT_PRESENT=1");
const TCHAR MDAC_NOT_PRESENT_PROP[] = _T("MDAC_NOT_PRESENT=1");
const DWORD DARWIN_LOG_FLAG         = INSTALLLOGMODE_FATALEXIT |
                                      INSTALLLOGMODE_ERROR |
                                      INSTALLLOGMODE_WARNING |
                                      INSTALLLOGMODE_USER |
                                      INSTALLLOGMODE_INFO |
                                      INSTALLLOGMODE_RESOLVESOURCE |
                                      INSTALLLOGMODE_OUTOFDISKSPACE |
                                      INSTALLLOGMODE_ACTIONSTART |
                                      INSTALLLOGMODE_ACTIONDATA |
                                      INSTALLLOGMODE_COMMONDATA |
                                      INSTALLLOGMODE_PROPERTYDUMP |
                                      INSTALLLOGMODE_VERBOSE;

// function prototypes
typedef UINT (CALLBACK* PFNMSIINSTALLPRODUCT)( LPCTSTR,LPCTSTR ); // MsiInstallProduct()
typedef UINT (CALLBACK* PFNMSIENABLELOG)( DWORD, LPCTSTR, DWORD );// MsiEnableLog()
typedef DWORD (CALLBACK* PFNMSISETINTERNALUI)( DWORD, HWND* );    // MsiSetInternalUI()
typedef INSTALLSTATE (CALLBACK* PFNMSILOCATECOMPONENT)( LPCTSTR, LPCTSTR, DWORD* ); // MsiLocateComponent()
typedef UINT (CALLBACK* PFNMSIENUMCLIENTS)( LPCTSTR, DWORD, LPTSTR ); // MsiEnumClients()
typedef UINT (CALLBACK* PFNMSIGETPRODUCTINFO)( LPCTSTR, LPCTSTR, LPTSTR, DWORD* ); // MsiGetProductInfo()
typedef UINT (CALLBACK* PFNMSIGETFILEVERSION)( LPCTSTR, LPCTSTR, DWORD*, LPCTSTR, DWORD* ); // MsiGetFileVersion()


HMODULE LoadDarwinLibrary();                             // Load msi.dll
LPTSTR GetDarwinLocation( LPTSTR pszDir, DWORD dwSize ); // Get location of Windows Installer
UINT  ConfigCheck() ;                                    // Check to ensure the system meets min config.
UINT  CheckDarwin();                                     // Check version of Windows Installer
UINT  InstallDarwin( bool bIsQuietMode ) ;	             // Installs or upgrades Darwin
UINT  VerifyDarwin( bool bIsQuietMode ) ;	             // Checks for Darwin on system
DWORD QuietExec( LPCTSTR pszCmd );                       // Runs EXE silently
void LoadOleacc();
int MyNewHandler( size_t size );                         // new() handler
BOOL IsIISInstalled();                                   // Check if IIS is installed
bool IsMDACInstalled();
void LogThis( LPCTSTR pszMessage );                      // simple LogThis() with one parameter
void LogThis( LPCTSTR szData, size_t nLength );          // Enters text into wrapper logfile
void LogThis1( LPCTSTR pszFormat, LPCTSTR pszArg );      // log using format and arg
void LogThisDWORD( LPCTSTR pszFormat, DWORD dwNum );     // log with a DWORD argument
UINT  InstallProduct( const CReadFlags *, LPCTSTR, LPCTSTR, CSetupCode * ) ; // Installs package
void StopDarwinService();                                // Stop the Darwin Service
BOOL WaitForServiceState(SC_HANDLE hService, DWORD dwDesiredState, SERVICE_STATUS* pss, DWORD dwMilliseconds); // Waits for a Service State to reach the desired State
BOOL IsTerminalServicesEnabled();
void SetTSInInstallMode();
// ==========================================================================
// CSingleInstance
//
// Purpose:
//  creates an objec that will either detect or create a single instance
//  mutex. Mutex is freed when class goes out of scope. You are unable to 
//  create a default object.
// ==========================================================================
class CSingleInstance
{
public:
    CSingleInstance( TCHAR* szMutexName ) : 
      m_hMutex( NULL ), 
      m_fFirstInstance( TRUE )
    {
        if( NULL == szMutexName )
        {
            _ASSERTE( !_T( "Error CSingleInstance ctor! NULL string passed to destructor." ) );
        }
        else
        {
            m_hMutex = CreateMutex( NULL, NULL, szMutexName );

            //check that the handle didn't already exist
            //
            if( ERROR_ALREADY_EXISTS == ::GetLastError() )
            {
                ::CloseHandle( m_hMutex );
                m_hMutex = NULL;

                m_fFirstInstance = FALSE;
            }
        }
    }
    ~CSingleInstance()
    {
        if( NULL != m_hMutex )
        {
            ::CloseHandle( m_hMutex );
            m_hMutex = NULL;
        }
    }

    //used to determine if there was already an instance
    // of this mutex in use
    //
    inline BOOL IsUnique( void ) { return m_fFirstInstance; }
    
    //used to determine if the CreateMutex call succeeded
    //
    inline BOOL IsHandleOK( void ) { return m_hMutex ? TRUE : FALSE; }

private:
    CSingleInstance( void )
    {
        //this is not used
    }
    HANDLE m_hMutex;
    BOOL   m_fFirstInstance;
};

class CTempLogPath
{
    LPTSTR m_pszLogPath;
 public:
    CTempLogPath( LPCTSTR pszLogName );
    ~CTempLogPath(){if (m_pszLogPath) delete [] m_pszLogPath;}
    operator LPCTSTR() {return (LPCTSTR)m_pszLogPath;}
};








#endif // FXSETUPLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\osver.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
FILE:    OSVer.h
PROJECT: UTILS.LIB
DESC:    Declaration of OSVERSION structures
OWNER:   JoeA

****************************************************************************/

#ifndef __OSVER_H_
#define __OSVER_H_


#include <windows.h>
#include <tchar.h>

typedef enum tag_OSREQUIRED
{
    OSR_9XOLD = 0,             //versions of windows older than 98             
    OSR_NTOLD,                 //versions of nt older than 4                   
    OSR_98GOLD,                //win98 gold                                    
    OSR_98SE,                  //win98 service edition                         
    OSR_NT4,                   //win nt4                                       
    OSR_NT2K,                  //win 2k                                        
    OSR_ME,                    //millenium                                     
    OSR_FU9X,                  //future 9x                                     
    OSR_FUNT,                  //future NT                                     
    OSR_WHISTLER,              //whistler
    OSR_OTHER,                 //unknown platform
    OSR_ERROR_GETTINGINFO      //error!
}OS_Required;

#define OS_MAX_STR 256

extern const TCHAR g_szWin95[];
extern const TCHAR g_szWin98[];
extern const TCHAR g_szWinNT[];
extern const TCHAR g_szWin2k[];
extern const TCHAR g_szWin31[];
extern const TCHAR g_szWinME[];



OS_Required GetOSInfo(LPTSTR pstrOSName, LPTSTR pstrVersion, LPTSTR pstrServicePack, BOOL& bIsServerb);



#endif  //__OSVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\msiwrapper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     MsiWrapper.h
// Owner:    jbae
// Purpose:  definition of CMsiWrapper
//                              
// History:
//  03/06/01, jbae: created

#ifndef MSIWRAPPER_H
#define MSIWRAPPER_H

#include <windows.h>
#include <tchar.h>

// ==========================================================================
// class CMsiWrapper
//
// Purpose:
//  this class loads msi.dll and returns pointer to functions in msi.dll
// ==========================================================================
class CMsiWrapper
{
public:
    // Constructor
    //
    CMsiWrapper();

    // Destructor
    //
    ~CMsiWrapper();

    // Operations
    //
    void LoadMsi();
    void *GetFn( LPTSTR pszFnName );

protected:
    // Attributes
    //
    HMODULE m_hMsi; // handle to msi.dll
    void *m_pFn;    // pointer to a function
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\readflags.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     ReadFlags.h
// Owner:    jbae
// Purpose:  definition of CReadFlags
//                              
// History:
//  01/02/01, jbae: created

#ifndef READFLAGS_H
#define READFLAGS_H

#include <windows.h>
#include <tchar.h>

const int MAX_SOURCEDIR       = 247; // max size of source dir

typedef enum _SETUPMODE
{
    REDIST = 0,
    SDK,
} SETUPMODE;

extern SETUPMODE g_sm;

// ==========================================================================
// class CReadFlags
//
// Purpose:
//  this class parses commandline and stores them into member variables
// ==========================================================================
class CReadFlags
{
public:
    // Constructor and destructor
    //
    CReadFlags( LPTSTR szCommandLine, LPCTSTR pszMsiName );
    ~CReadFlags();

    // Operations
    //
    void Parse();
    bool IsQuietMode() const { return m_bQuietMode; }
    bool IsProgressOnly() const { return m_bProgressOnly; }
    bool IsInstalling() const { return m_bInstalling; }
    bool IsNoARP() const { return m_bNoARP; }
    bool IsNoASPUpgrade() const { return m_bNoASPUpgrade; }
    LPCTSTR GetLogFileName() const;
    LPCTSTR GetSourceDir() const { return const_cast<LPCTSTR>( m_szSourceDir ); } 
    LPCTSTR GetSDKDir() const;
    void ThrowUsageException();

protected:
    // Attributes
    //
    LPTSTR m_pszCommandLine;
    LPCTSTR m_pszMsiName;
    bool m_bQuietMode;
    bool m_bProgressOnly;
    bool m_bInstalling;
    LPTSTR m_pszLogFileName;
    TCHAR m_szSourceDir[_MAX_PATH];
    bool m_bNoARP;
    bool m_bNoASPUpgrade;

    // For SDK setup only
    LPTSTR m_pszSDKDir;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\readflags.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     ReadFlags.cpp
// Owner:    jbae
// Purpose:  reads commandline switches and stores those information
//                              
// History:
//  01/02/01, jbae: created
//  07/18/01, joea: adding logging functionality

#include "fxsetuplib.h"
#include "ReadFlags.h"
#include "SetupError.h"

SETUPMODE g_sm;

//defines
//
#define EMPTY_BUFFER { _T( '\0' ) }
#define END_OF_STRING  _T( '\0' )

// Constructor
//
// ==========================================================================
// CReadFlags::CReadFlags()
//
// Inputs:
//  LPTSTR pszCommandLine: commandline passed in by system. It must inclue path to
//  the wrapper (Install.exe).
//
// Purpose:
//  initializes member varialbes.
// ==========================================================================
CReadFlags::
CReadFlags( LPTSTR pszCommandLine, LPCTSTR pszMsiName )
: m_pszCommandLine(pszCommandLine), m_pszMsiName(pszMsiName), m_bQuietMode(false), m_bInstalling(true),
  m_pszLogFileName(NULL), m_pszSDKDir(NULL), m_bProgressOnly(false), m_bNoARP(false), m_bNoASPUpgrade(false)
{
    // Initialize member variables
    _ASSERTE( NULL != pszCommandLine );
    _ASSERTE( REDIST == g_sm || SDK == g_sm );

    *m_szSourceDir   = END_OF_STRING;
}

CReadFlags::
~CReadFlags()
{
    if ( m_pszLogFileName )
        delete [] m_pszLogFileName;
    if ( m_pszSDKDir )
        delete [] m_pszSDKDir;
}

// Operations
//
// ==========================================================================
// CReadFlags::Parse()
//
// Purpose:
//  parses commandline switches and stores them into member variables.
// ==========================================================================
void CReadFlags::
Parse()
{
    TCHAR *pszBuf = NULL;
    TCHAR *pszTmp = NULL;
    TCHAR *pszTmp2 = NULL;
    TCHAR szSwitch[] = _T("/-");

    // First, we need to get the directory Install.exe lies
    if ( _T('"') == *m_pszCommandLine )
    {
        // if started with double-quote, we need to find the matching one.
        m_pszCommandLine = _tcsinc( m_pszCommandLine );
        pszTmp = _tcschr( m_pszCommandLine, _T('"') );
        if ( NULL == pszTmp )
        {
            ThrowUsageException();
        }
        else
        {
            *pszTmp = END_OF_STRING;
            pszTmp = _tcsinc( pszTmp );    
        }
    }
    else
    {
        pszTmp = _tcschr( m_pszCommandLine, _T(' ') );
        if ( NULL == pszTmp )
        {
            pszTmp = _tcschr( m_pszCommandLine, END_OF_STRING );
        }
        else
        {
            *pszTmp = END_OF_STRING;
            pszTmp = _tcsinc( pszTmp );    
        }
    }

    // If there's \ before Install.exe, we have SourceDir
    // otherwise, SourceDir is empty
    pszTmp2 = _tcsrchr( m_pszCommandLine, _T('\\') );
    if ( NULL == pszTmp2 )
    {
        _tcscpy( m_szSourceDir, _T("") );
    }
    else
    {
        pszTmp2 = _tcsinc( pszTmp2 ); // leave trailing backslash
        *pszTmp2 = END_OF_STRING;
        _tcscpy( m_szSourceDir, m_pszCommandLine );
    }
    LogThis1( _T( "SourceDir: %s" ), m_szSourceDir );
    if ( MAX_SOURCEDIR < _tcslen(m_szSourceDir) )
    {
        CSetupError se( IDS_SOURCE_DIR_TOO_LONG, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_SOURCE_DIR_TOO_LONG );
        throw se;
    }

    // Now pszTmp points to switches only
    // remove white spaces before switches
    while( iswspace( *pszTmp ) )
    {
        pszTmp = _tcsinc( pszTmp );
    }
    pszTmp = _tcstok( pszTmp, szSwitch );
    while ( NULL != pszTmp )
    {
        switch ( *pszTmp )
        {
        case _T('q'):
        case _T('Q'):
            pszBuf = _tcsinc( pszTmp );
            if ( _T('b') == *pszBuf || _T('B') == *pszBuf )
            {
                // Basic and progress bar only
                // INSTALLUILEVEL_BASIC | INSTALLUILEVEL_PROGRESSONLY
                m_bProgressOnly = true;
                pszBuf = _tcsinc( pszBuf );
            }

            while( iswspace( *pszBuf ) )
                pszBuf = _tcsinc( pszBuf );
            if ( END_OF_STRING == *pszBuf )
                m_bQuietMode = true;
            else
                ThrowUsageException();
            break;
        case _T('u'):
        case _T('U'):
    		m_bInstalling = false;
            break;
        case _T('l'):
        case _T('L'): // Hidden switch for darwin logging
            pszBuf = _tcsinc( pszTmp );
            while( iswspace( *pszBuf ) )
            {
                pszBuf = _tcsinc( pszBuf );
            }
            if ( END_OF_STRING != *pszBuf )
            { // we have some non-white characters
                pszTmp2 = _tcschr( pszBuf, END_OF_STRING );
                pszTmp2 = _tcsdec( pszBuf, pszTmp2 );
                while( iswspace( *pszTmp2 ) )
                {
                    pszTmp2 = _tcsdec( pszBuf, pszTmp2 );
                }
                pszTmp2 = _tcsinc( pszTmp2 );
                *pszTmp2 = END_OF_STRING;
                // now white spaces are gone
                m_pszLogFileName = new TCHAR[ _tcslen(pszBuf) + 1 ];
                if ( _T('"') == *pszBuf )
                {
                    pszBuf = _tcsinc( pszBuf );
                    pszTmp2 = _tcschr( pszBuf, END_OF_STRING );
                    pszTmp2 = _tcsdec( pszBuf, pszTmp2 );
                    if ( _T('"') == *pszTmp2 )
                    {
                        *pszTmp2 = END_OF_STRING;
                        _tcscpy( m_pszLogFileName, pszBuf );
                    }
                }
                else
                {
                    _tcscpy( m_pszLogFileName, pszBuf );
                }
            }
            else
            {   // /l switch given but no <logfile> given
                // Use default logfile: %TEMP%\<MsiName>.log
                LPTSTR pszLogFile = new TCHAR[ _tcslen(m_pszMsiName) + 1 ];
                LPTSTR pChar = NULL;

                _tcscpy( pszLogFile, m_pszMsiName );
                pChar = _tcsrchr( pszLogFile, _T('.') );
                if ( pChar )
                {
                    *pChar = END_OF_STRING;
                }
                _tcscat( pszLogFile, _T(".log") );

                CTempLogPath templog( pszLogFile );
                m_pszLogFileName = new TCHAR[ _tcslen((LPCTSTR)templog) + 1 ];
                _tcscpy( m_pszLogFileName, (LPCTSTR)templog );
                delete [] pszLogFile;
            }
            break;
        case _T('n'):
        case _T('N'):
            // Remove trailing whitespace
            pszTmp2 = _tcschr( pszTmp, END_OF_STRING );
            pszTmp2 = _tcsdec( pszTmp, pszTmp2 );
            while( iswspace( *pszTmp2 ) )
            {
                pszTmp2 = _tcsdec( pszTmp, pszTmp2 );
            }
            pszTmp2 = _tcsinc( pszTmp2 );
            *pszTmp2 = END_OF_STRING;

            if ( 0 == _tcsicmp( _T("noarp"), pszTmp ) )
            {
                LogThis( _T( "Will not add to ARP" ) );
                m_bNoARP = true;
                break;
            }

            if ( 0 == _tcsicmp( _T("noaspupgrade"), pszTmp ) )
            {
                if ( REDIST != g_sm )
                {
                    ThrowUsageException();
                }
                LogThis( _T( "NOASPUPGRADE" ) );
                m_bNoASPUpgrade = true;
                break;
            }

            ThrowUsageException();
            break;

        case _T('s'):
        case _T('S'):
            // Only for SDK
            if ( REDIST == g_sm )
            {
                ThrowUsageException();
            }
            else if ( SDK == g_sm && 0 != _tcsnicmp( _T("sdkdir"), pszTmp, 6 ) )
            {
                ThrowUsageException();
            }
           	// SDK Dir
            pszBuf = _tcsninc( pszTmp, 6 ); // skip "sdkdir"
            while( iswspace( *pszBuf ) )
            {
                pszBuf = _tcsinc( pszBuf );
            }
            if ( END_OF_STRING != *pszBuf )
            { // we have some non-white characters
                pszTmp2 = _tcschr( pszBuf, END_OF_STRING );
                pszTmp2 = _tcsdec( pszBuf, pszTmp2 );
                while( iswspace( *pszTmp2 ) )
                {
                    pszTmp2 = _tcsdec( pszBuf, pszTmp2 );
                }
                pszTmp2 = _tcsinc( pszTmp2 );
                *pszTmp2 = END_OF_STRING;
                // now white spaces are gone
                m_pszSDKDir = new TCHAR[ _tcslen(pszBuf) + 1 ];
                if ( _T('"') == *pszBuf )
                {
                    pszBuf = _tcsinc( pszBuf );
                    pszTmp2 = _tcschr( pszBuf, END_OF_STRING );
                    pszTmp2 = _tcsdec( pszBuf, pszTmp2 );
                    if ( _T('"') == *pszTmp2 )
                    {
                        *pszTmp2 = END_OF_STRING;
                        _tcscpy( m_pszSDKDir, pszBuf );
                    }
                }
                else
                {
                    _tcscpy( m_pszSDKDir, pszBuf );
                }
            }
            LogThis1( _T( "SDKDir: %s" ), m_pszSDKDir );

            break;

        case _T('?'):
        case _T('h'):
        case _T('H'):
        default:
            ThrowUsageException();
        }
        
        pszTmp = _tcstok( NULL, szSwitch );
    }
}

// ==========================================================================
// CReadFlags::GetLogFileName()
//
// Inputs: none
// Returns: 
//  LPTSTR: returns NULL if logfile is not given otherwise
//          returns the name of the logfile.
// Purpose:
//  returns logfile name.
// ==========================================================================
LPCTSTR CReadFlags::
GetLogFileName() const
{
    return const_cast<LPCTSTR>( m_pszLogFileName );
}

// ==========================================================================
// CReadFlags::GetSDKDir()
//
// Inputs: none
// Returns: 
//  LPTSTR: returns NULL if logfile is not given otherwise
//          returns the name of the logfile.
// Purpose:
//  returns logfile name.
// ==========================================================================
LPCTSTR CReadFlags::
GetSDKDir() const
{
    return const_cast<LPCTSTR>( m_pszSDKDir );
}

void CReadFlags::
ThrowUsageException()
{
    CSetupError se;

    switch( g_sm )
    {
    case REDIST:
        se.SetError( IDS_USAGE_TEXT_REDIST, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, COR_USAGE_ERROR );
        throw se;
        break;
    case SDK:
        se.SetError( IDS_USAGE_TEXT_SDK, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, COR_USAGE_ERROR );
        throw se;
        break;
    default:
        se.SetError( IDS_USAGE_TEXT_REDIST, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, COR_USAGE_ERROR );
        throw se;
        break;                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by fxsetuplib.rc
//
#define IDS_PRODUCT_REDIST              1
#define IDS_PRODUCT_SDK                 2
#define IDS_INSTALL_LANGUAGE_UNSUPPORTED 3
#define IDS_NT4_TERMINAL_SERVICE        4
#define IDS_SETUP_FAILURE               6
#define IDS_MSI_UPDATE                  7
#define IDS_UNSUPPORTED_PLATFORM        8
#define IDS_DIALOG_CAPTION              10
#define IDS_USAGE_TEXT_REDIST           11
#define IDS_SETUP_COMPLETE              13
#define IDS_SETUP_CANCELLED             14
#define IDS_PRE_IE_501                  19
#define IDS_NT4_PRE_SP6A                20
#define IDS_OCM_FOUND                   21
#define IDS_CANNOT_OPEN_MSI             22
#define IDS_INSUFFICIENT_PRIVILEGES     27
#define IDS_FRAMEWORK_NOT_EXIST         29
#define IDS_DARWIN_INSTALL_FAILURE      31
#define IDS_DARWIN_NOT_INSTALLED        32
#define IDS_USAGE_TEXT_SDK              36
#define IDS_ERROR_PRODUCT_VERSION       37
#define IDS_NOT_ENOUGH_MEMORY           40
#define IDS_CANNOT_GET_TEMP_DIR         41
#define IDS_UNSUPPORTED_PLATFORM_REDIST 43
#define IDS_UNSUPPORTED_PLATFORM_SDK    44
#define IDS_OLD_FRAMEWORK_EXIST         46
#define IDS_TEMP_DIR_TOO_LONG           47
#define IDS_SOURCE_DIR_TOO_LONG         48
#define IDS_CANNOT_WRITE_LOG            50
#define IDS_CANNOT_READ_MSI             51
#define IDS_NOT_SINGLE_INSTANCE         100
#define IDS_SINGLE_INSTANCE_FAIL        101
#define IDS_DARWIN_SERVICE_REQ_REBOOT   102
#define IDS_DARWIN_SERVICE_INTERNAL_ERROR 103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\setuperror.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     SetupError.cpp
// Owner:    jbae
// Purpose:  handles displaying of messagebox and stores return-code from WinMain()
//                              
// History:
//  01/10/01, jbae: created
//  03/09/01, jbae: changes to support darwin 1.5 delayed reboot and
//              sharing of .rc file
//  07/18/01, joea: adding logging functionality

#include "SetupError.h"
#include "fxsetuplib.h"

//defines
//
#define EMPTY_BUFFER { _T( '\0' ) }
#define END_OF_STRING  _T( '\0' )

// Constructors
//
// ==========================================================================
// CSetupError::CSetupError()
//
// Purpose:
//  constructs CSetupError object with no parameter. Sets QuietMode to false by default
// ==========================================================================
CSetupError::
CSetupError()
: m_nRetCode(ERROR_SUCCESS), m_bQuietMode(false), m_pszArg1(NULL), m_bLogError(true)
{
    _ASSERTE( REDIST == g_sm || SDK == g_sm );
}

// ==========================================================================
// CSetupError::CSetupError()
//
// Inputs:
//  UINT nMsg: resourceId for the message to display
//  UINT nCap: resourceId for the caption to display
//  UINT nIcon: icon to use
//  int nRetCode: return code to be returned to the caller of the wrapper
// Purpose:
//  constructs CSetupError object with initial values
// ==========================================================================
CSetupError::
CSetupError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode )
: m_nMessage(nMsg), m_nCaption(nCap), m_nIconType(nIcon), m_bQuietMode(false), m_pszArg1(NULL),
  m_nRetCode((ERROR_SUCCESS_REBOOT_REQUIRED == nRetCode) ? COR_REBOOT_REQUIRED : nRetCode), m_bLogError(true)
{
    _ASSERTE( REDIST == g_sm || SDK == g_sm );
}

// ==========================================================================
// CSetupError::CSetupError()
//
// Inputs:
//  UINT nMsg: resourceId for the message to display
//  UINT nCap: resourceId for the caption to display
//  UINT nIcon: icon to use
//  int nRetCode: return code to be returned to the caller of the wrapper
//  bool bLogIt: determines whether to log it or not
// Purpose:
//  constructs CSetupError object with initial values
// ==========================================================================
CSetupError::
CSetupError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode, bool bLogIt )
: m_nMessage(nMsg), m_nCaption(nCap), m_nIconType(nIcon), m_bQuietMode(false), m_pszArg1(NULL),
  m_nRetCode((ERROR_SUCCESS_REBOOT_REQUIRED == nRetCode) ? COR_REBOOT_REQUIRED : nRetCode), m_bLogError(bLogIt)
{
    _ASSERTE( REDIST == g_sm || SDK == g_sm );
}

// ==========================================================================
// CSetupError::CSetupError()
//
// Inputs:
//  UINT nMsg: resourceId for the message to display
//  UINT nCap: resourceId for the caption to display
//  UINT nIcon: icon to use
//  int nRetCode: return code to be returned to the caller of the wrapper
//  LPTSTR pszArg1: argument string that is inserted to the resource string
// Purpose:
//  constructs CSetupError object with initial values
// ==========================================================================
CSetupError::
CSetupError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode, LPTSTR pszArg1 )
: m_nMessage(nMsg), m_nCaption(nCap), m_nIconType(nIcon), m_bQuietMode(false), m_pszArg1(pszArg1),
  m_nRetCode((ERROR_SUCCESS_REBOOT_REQUIRED == nRetCode) ? COR_REBOOT_REQUIRED : nRetCode), m_bLogError(true)
{
    _ASSERTE( REDIST == g_sm || SDK == g_sm );
}

// ==========================================================================
// CSetupError::SetError()
//
// Inputs:
//  UINT nMsg: resourceId for the message to display
//  UINT nCap: resourceId for the caption to display
//  UINT nIcon: icon to use
//  int nRetCode: return code to be returned to the caller of the wrapper
// Purpose:
//  initializes attributes
// ==========================================================================
void CSetupError::
SetError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode )
{
    m_nMessage = nMsg;
    m_nCaption = nCap;
    m_nIconType = nIcon;
    if ( ERROR_SUCCESS_REBOOT_REQUIRED == nRetCode )
    {
        m_nRetCode |= COR_REBOOT_REQUIRED;
    }
    else
    {
        m_nRetCode |= nRetCode;
    }
}

// ==========================================================================
// CSetupError::SetError2()
//
// Inputs:
//  UINT nMsg: resourceId for the message to display
//  UINT nIcon: icon to use
//  int nRetCode: return code to be returned to the caller of the wrapper
//  va_list *pArgs: arguments to be inserted
// Purpose:
//  initializes attributes
// ==========================================================================
void CSetupError::
SetError2( UINT nMsg, UINT nIcon, int nRetCode, va_list *pArgs )
{
    m_nMessage = nMsg;
    m_nIconType = nIcon;
    if ( ERROR_SUCCESS_REBOOT_REQUIRED == nRetCode )
    {
        m_nRetCode |= COR_REBOOT_REQUIRED;
    }
    else
    {
        m_nRetCode |= nRetCode;
    }
    m_pArgs = pArgs;
}

// Operations
// ==========================================================================
// CSetupError::ShowError()
//
// Inputs: none
// Purpose:
//  displays messagebox with message loaded from resource if non-quiet mode
// ==========================================================================
int CSetupError
::ShowError()
{
    TCHAR szCapFmt[MAX_PATH]  = EMPTY_BUFFER;
    TCHAR szMsgFmt[MAX_MSG]   = EMPTY_BUFFER;
    TCHAR szCaption[MAX_PATH] = EMPTY_BUFFER;
    TCHAR szMessage[MAX_MSG]  = EMPTY_BUFFER;

    ::LoadString( hAppInst, m_nCaption, szCapFmt, LENGTH(szCapFmt) );
    ::LoadString( hAppInst, m_nMessage, szMsgFmt, LENGTH(szMsgFmt) ) ;
    _stprintf( szCaption, szCapFmt, CSetupError::GetProductName() );
    if ( NULL != m_pszArg1 )
    {
        _stprintf( szMessage, szMsgFmt, m_pszArg1 );
    }
    else
    {
        _stprintf( szMessage, szMsgFmt, CSetupError::GetProductName() );
    }

#ifdef _DEBUG
    TCHAR szTmp[10];
    _stprintf( szTmp, ": %d", m_nRetCode );
    _tcscat( szCaption, szTmp );
#endif

    if ( m_bLogError )
    {
        TCHAR szMsg[] = _T( "Preparing Dialog" );
        LogThis( szMsg, sizeof( szMsg ) );

        LogThis1( _T( "Message: %s" ), szMessage );
    }

    if ( !m_bQuietMode )
	{
		// Show usage and exit

		return ::MessageBox( NULL, szMessage, szCaption, MB_OK | m_nIconType ) ;
	}

	// else print message to stderr
	else
	{
		_ftprintf ( stderr, szMessage ) ;
        return 0;
	}
}

// Operations
// ==========================================================================
// CSetupError::ShowError2()
//
// Inputs: none
// Purpose:
//  displays messagebox with message loaded from resource if non-quiet mode
// ==========================================================================
int CSetupError
::ShowError2()
{
    int nResponse = IDNO;
    TCHAR szCapFmt[MAX_PATH]  = EMPTY_BUFFER;
    TCHAR szMsgFmt[MAX_MSG]   = EMPTY_BUFFER;
    TCHAR szCaption[MAX_PATH] = EMPTY_BUFFER;
  
    ::LoadString( hAppInst, IDS_DIALOG_CAPTION, szCapFmt, LENGTH(szCapFmt) );
#ifdef _DEBUG
    TCHAR szTmp[10];
    _stprintf( szTmp, ": %d", m_nRetCode );
    _tcscat( szCapFmt, szTmp );
#endif
    ::LoadString( hAppInst, m_nMessage, szMsgFmt, LENGTH(szMsgFmt) ) ;

    _stprintf( szCaption, szCapFmt, (LPVOID)CSetupError::GetProductName() );

    LPVOID pMessage;
    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_STRING |
        FORMAT_MESSAGE_ARGUMENT_ARRAY,
        szMsgFmt,
        0,
        0,
        (LPTSTR)&pMessage,
        0,
        (va_list *)m_pArgs
    );

    if ( m_bLogError )
    {
        TCHAR szMsg[] = _T( "Preparing Dialog" );
        LogThis( szMsg, sizeof( szMsg ) );

        LogThis1( _T( "Message: %s" ), (LPCTSTR)pMessage );
    }

    if ( !m_bQuietMode )
	{
        nResponse = ::MessageBox( NULL, (LPCTSTR)pMessage, szCaption, MB_OK | m_nIconType ) ;
	}
	// else print message to stderr
	else
	{
		_ftprintf ( stderr, (LPCTSTR)pMessage ) ;
	}

    LocalFree( pMessage );

    return nResponse;
}

// ==========================================================================
// CSetupError::GetProductName()
//
// Inputs: none
// Purpose:
//  returns productname for SDK or Redist setup. This is a static function.
// ==========================================================================
LPCTSTR CSetupError::
GetProductName()
{

    if ( END_OF_STRING == *s_szProductName )
    {
        switch( g_sm )
        {
        case REDIST:
            ::LoadString( hAppInst, IDS_PRODUCT_REDIST, s_szProductName, LENGTH(s_szProductName) ) ;
            break;
        case SDK:
            ::LoadString( hAppInst, IDS_PRODUCT_SDK, s_szProductName, LENGTH(s_szProductName) ) ;
            break;
        default:
            ::LoadString( hAppInst, IDS_PRODUCT_REDIST, s_szProductName, LENGTH(s_szProductName) ) ;
            break;
        }
    }

    return s_szProductName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\setuperror.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef SETUPERROR_H
#define SETUPERROR_H

#include <windows.h>
#include <tchar.h>
#include "SetupCodes.h"

#define MAX_MSG    4096
// ==========================================================================
// class CSetupError
//
// Purpose:
//  This class handles displaying of (error) messages as well as holding return-code
// ==========================================================================
class CSetupError
{
public:
    // Constructors
    CSetupError();
    CSetupError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode );
    CSetupError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode, bool bLogIt );
    CSetupError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode, LPTSTR pszArg1 );
    void SetError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode );
    void SetError2( UINT nMsg, UINT nIcon, int nRetCode, va_list *pArgs );
    
    // Operations
    int ShowError();
    int ShowError2();
    static LPCTSTR GetProductName();

    // Attributes
    int m_nRetCode;
    bool m_bQuietMode;
    static HINSTANCE hAppInst;
    static TCHAR s_szProductName[MAX_PATH];

private:
    UINT m_nCaption;
    UINT m_nMessage;
    UINT m_nIconType;
    LPTSTR m_pszArg1;
    va_list *m_pArgs;
    bool m_bLogError;
};

// ==========================================================================
// class CSetupCode
//
// Purpose:
//  This class is derived from CSetupError. This has additional method called
//  IsRebootRequired() that indicates if reboot is required.
// ==========================================================================
class CSetupCode : public CSetupError
{
public:
    // Constructors
    CSetupCode() { CSetupError(); };
    void SetReturnCode( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode ) { SetError( nMsg, nCap, nIcon, nRetCode ); };

    // Operations
    bool IsRebootRequired() { return (COR_REBOOT_REQUIRED == (COR_REBOOT_REQUIRED&m_nRetCode)); };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\fxsetuplib\osversion.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/****************************************************************************
FILE:    OSVersion.cpp
PROJECT: UTILS.LIB
DESC:    Implementation of OSVERSION structures and functionality
OWNER:   JoeA

****************************************************************************/

// Let's not use ATL for reading registry
//#include <atlbase.h>
#include <stdlib.h>
#include "OSVer.h"

//defines
const TCHAR g_szWin95[] = _T( "Win 95");
const TCHAR g_szWin98[] = _T( "Win 98");
const TCHAR g_szWinNT[] = _T( "Win NT");
const TCHAR g_szWin2k[] = _T( "Win 2k");
const TCHAR g_szWin31[] = _T( "Win 3.1");
const TCHAR g_szWinME[] = _T( "Win Millenium");

const TCHAR g_szSE[] = _T( "Second Edition");
const TCHAR g_szGold[] = _T( "Gold");

//////////////////////////////////////////////////////////////////////////////
//RECEIVES : LPTSTR [out] - empty string
//           LPTSTR [out] - empty string
//           LPTSTR [out] - empty string
//           BOOL   [out] - empty string
//RETURNS  : OS_Required [out] - enum
//PURPOSE  : Get the Information about the currently running OS, Version and 
//           the service pack number
//////////////////////////////////////////////////////////////////////////////
OS_Required GetOSInfo(LPTSTR pstrOSName, LPTSTR pstrVersion, LPTSTR pstrServicePack, BOOL& bIsServer)
{
    OSVERSIONINFOEX     VersionInfo;
    OS_Required         osiVersion = OSR_ERROR_GETTINGINFO;
    unsigned short      wHigh = 0;
    BOOL                bOsVersionInfoEx;
    BOOL                fGotVersionInfo = TRUE;
    
    //Set the bIsServerFlag to FALSE. if it is a server, the check will set it to true
    bIsServer = FALSE;

    // Try using a OSVERSIONINFOEX structure
    ZeroMemory(&VersionInfo, sizeof(OSVERSIONINFOEX));
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &VersionInfo)) )
        {
        // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.
        //
        VersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (! GetVersionEx ( (OSVERSIONINFO *) &VersionInfo) ) 
            {
            fGotVersionInfo = FALSE;
            }
        }

    if (fGotVersionInfo)
        {
        switch(VersionInfo.dwPlatformId)
            {
            case VER_PLATFORM_WIN32s :      //signifies Win32s on Win3.1
                _tcscpy(pstrOSName, g_szWin31);
                osiVersion =  OSR_OTHER;
                break;
            case VER_PLATFORM_WIN32_WINDOWS: //signifies Win95 or 98 or Millenium
                if(VersionInfo.dwMinorVersion == 0)
                {
                    _tcscpy(pstrOSName, g_szWin95);
                    osiVersion =  OSR_9XOLD;
                }
                else
                {
                    // Modified by jbae: commented out the use of CRegKey from ATL
                    // CRegKey reg;
                    TCHAR szWin98SEKey[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\ICS");
                    _tcscpy(pstrOSName, g_szWin98);

                    //the presence of the reg key indicates Windows 98 SE
                    // LONG lResult = reg.Open( HKEY_LOCAL_MACHINE, szWin98SEKey);
                    HKEY hKey;
                    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szWin98SEKey, 0, KEY_QUERY_VALUE, &hKey);
                    if( ERROR_SUCCESS == lResult )
                    {
                        RegCloseKey( hKey );
                        osiVersion = OSR_98SE;
                        _tcscpy(pstrVersion, g_szSE);
                    }
                    else
                    {   
                        osiVersion =  OSR_98GOLD;
                        _tcscpy(pstrVersion, g_szGold);
                    }
                }
                //Check for the millenium OS
                // Because of a really stupid hack, GetVersionEx will return a 
                // minor version number of "10" if it's being called from an
                // application called "setup.exe"
                // The information about OS version is redundantly available in
                // the high word of the build number. Get that info and use it
                //
                wHigh = HIWORD( VersionInfo.dwBuildNumber );

                if( HIBYTE( wHigh ) == 4 && 
                    LOBYTE( wHigh ) == 90 )
                {
                    _tcscpy(pstrOSName, g_szWinME);
                    osiVersion = OSR_ME;
                }

                    
                //No service pack info is got here as the function returns additional arbit 
                //info about the OS in the member szCSDVersion of the structure 
                break;

            case VER_PLATFORM_WIN32_NT: //signifies WinNT or Win2k
                _tcscpy(pstrOSName, g_szWinNT);

                if (VersionInfo.dwMajorVersion < 4)
                {
                    osiVersion = OSR_NTOLD; // This is Windows NT 3.x
                }
                else if (VersionInfo.dwMajorVersion == 4)
                {
                    // This is Windows NT 4.0

                    osiVersion =  OSR_NT4;

                    TCHAR szTemp[MAX_PATH];
                    ZeroMemory(szTemp, sizeof(szTemp));

                    _itot(VersionInfo.dwMajorVersion, pstrVersion, 10); // copy the major version
                    _tcscat(pstrVersion, _T("."));
                    _itot(VersionInfo.dwMinorVersion, szTemp, 10);      // copy the minor version
                    _tcscat(pstrVersion, szTemp);
                }
                else if ((VersionInfo.dwMajorVersion == 5) && (VersionInfo.dwMinorVersion == 0))
                {
                    osiVersion =  OSR_NT2K; // The OS is Windows 2000
                    _tcscpy(pstrOSName, g_szWin2k);
                }
                else if ((VersionInfo.dwMajorVersion == 5) &&  (VersionInfo.dwMinorVersion == 1))
                {
                    // This is Windows Whistler
                    osiVersion =  OSR_WHISTLER;
                }
                else
                {
                    // This is a later release
                    osiVersion =  OSR_FUNT;
                }

                // Check if the Current OS is a server version
                if ( bOsVersionInfoEx )
                {
                    // If we can, use this information (Win 2k)
                    bIsServer =  ( VersionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER ) || ( VersionInfo.wProductType == VER_NT_SERVER );
                }
                else
                {
                    const static TCHAR szProductOptions[]=TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions");

                    HKEY hKey;
                    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, szProductOptions,&hKey))
                    {
                        TCHAR szProductType[MAX_PATH];
                        DWORD dwSize=MAX_PATH*sizeof(TCHAR);
                        DWORD dwType=REG_SZ;

                        if (ERROR_SUCCESS==RegQueryValueEx(hKey,TEXT("ProductType"),0,&dwType,(LPBYTE)szProductType,&dwSize))
                        {
                            if (_tcsicmp(szProductType,TEXT("ServerNT") )==0 ||
                                _tcsicmp(szProductType,TEXT("LanmanNT")     )==0 ||
                                _tcsicmp(szProductType,TEXT("LANSECNT")     )==0)
                            {
                                bIsServer=true;
                            }
                        }

                        RegCloseKey(hKey);
                    }
                }

                break;
            }
        }

    // Copies the  service pack version number
    _tcscpy(pstrServicePack, VersionInfo.szCSDVersion);

    return osiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\inc\msi.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************\
*                                                                             *
* msi.h - - Interface for external access to Installer Service                *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* NOTES:  All buffers sizes are TCHAR count, null included only on input      *
*         Return argument pointers may be null if not interested in value     *
*                                                                             *
\*****************************************************************************/

#ifndef _MSI_H_
#define _MSI_H_

#ifndef _WIN32_MSI
#if (_WIN32_WINNT >= 0x0500)
#define _WIN32_MSI   110
#else
#define _WIN32_MSI   100
#endif //(_WIN32_WINNT >= 0x0500)
#endif // !_WIN32_MSI

// --------------------------------------------------------------------------
// Installer generic handle definitions
// --------------------------------------------------------------------------

typedef unsigned long MSIHANDLE;     // abstract generic handle, 0 == no handle

#ifdef __cplusplus
extern "C" {
#endif

// Close a open handle of any type
// All handles obtained from API calls must be closed when no longer needed
// Normally succeeds, returning TRUE. 

UINT WINAPI MsiCloseHandle(MSIHANDLE hAny);

// Close all handles open in the process, a diagnostic call
// This should NOT be used as a cleanup mechanism -- use PMSIHANDLE class
// Can be called at termination to assure that all handles have been closed
// Returns 0 if all handles have been close, else number of open handles

UINT WINAPI MsiCloseAllHandles();

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

// C++ wrapper object to automatically free handle when going out of scope

class PMSIHANDLE
{
	MSIHANDLE m_h;
 public:
	PMSIHANDLE():m_h(0){}
	PMSIHANDLE(MSIHANDLE h):m_h(h){}
  ~PMSIHANDLE(){if (m_h!=0) MsiCloseHandle(m_h);}
	void operator =(MSIHANDLE h) {if (m_h) MsiCloseHandle(m_h); m_h=h;}
	operator MSIHANDLE() {return m_h;}
	MSIHANDLE* operator &() {if (m_h) MsiCloseHandle(m_h); m_h = 0; return &m_h;}
};
#endif  //__cplusplus

// Install message type for callback is a combination of the following:
//  A message box style:      MB_*, where MB_OK is the default
//  A message box icon type:  MB_ICON*, where no icon is the default
//  A default button:         MB_DEFBUTTON?, where MB_DEFBUTTON1 is the default
//  One of the following install message types, no default
typedef enum tagINSTALLMESSAGE
{
	INSTALLMESSAGE_FATALEXIT      = 0x00000000L, // premature termination, possibly fatal OOM
	INSTALLMESSAGE_ERROR          = 0x01000000L, // formatted error message
	INSTALLMESSAGE_WARNING        = 0x02000000L, // formatted warning message
	INSTALLMESSAGE_USER           = 0x03000000L, // user request message
	INSTALLMESSAGE_INFO           = 0x04000000L, // informative message for log
	INSTALLMESSAGE_FILESINUSE     = 0x05000000L, // list of files in use that need to be replaced
	INSTALLMESSAGE_RESOLVESOURCE  = 0x06000000L, // request to determine a valid source location
	INSTALLMESSAGE_OUTOFDISKSPACE = 0x07000000L, // insufficient disk space message
	INSTALLMESSAGE_ACTIONSTART    = 0x08000000L, // start of action: action name & description
	INSTALLMESSAGE_ACTIONDATA     = 0x09000000L, // formatted data associated with individual action item
	INSTALLMESSAGE_PROGRESS       = 0x0A000000L, // progress gauge info: units so far, total
	INSTALLMESSAGE_COMMONDATA     = 0x0B000000L, // product info for dialog: language Id, dialog caption
	INSTALLMESSAGE_INITIALIZE     = 0x0C000000L, // sent prior to UI initialization, no string data
	INSTALLMESSAGE_TERMINATE      = 0x0D000000L, // sent after UI termination, no string data
	INSTALLMESSAGE_SHOWDIALOG     = 0x0E000000L, // sent prior to display or authored dialog or wizard
} INSTALLMESSAGE;

// external error handler supplied to installation API functions
typedef int (WINAPI *INSTALLUI_HANDLERA)(LPVOID pvContext, UINT iMessageType, LPCSTR szMessage);
// external error handler supplied to installation API functions
typedef int (WINAPI *INSTALLUI_HANDLERW)(LPVOID pvContext, UINT iMessageType, LPCWSTR szMessage);
#ifdef UNICODE
#define INSTALLUI_HANDLER  INSTALLUI_HANDLERW
#else
#define INSTALLUI_HANDLER  INSTALLUI_HANDLERA
#endif // !UNICODE

typedef enum tagINSTALLUILEVEL
{
	INSTALLUILEVEL_NOCHANGE = 0,    // UI level is unchanged
	INSTALLUILEVEL_DEFAULT  = 1,    // default UI is used
	INSTALLUILEVEL_NONE     = 2,    // completely silent installation
	INSTALLUILEVEL_BASIC    = 3,    // simple progress and error handling
	INSTALLUILEVEL_REDUCED  = 4,    // authored UI, wizard dialogs suppressed
	INSTALLUILEVEL_FULL     = 5,    // authored UI with wizards, progress, errors
	INSTALLUILEVEL_ENDDIALOG    = 0x80, // display success/failure dialog at end of install
	INSTALLUILEVEL_PROGRESSONLY = 0x40, // display only progress dialog
} INSTALLUILEVEL;

typedef enum tagINSTALLSTATE
{
	INSTALLSTATE_NOTUSED      = -7,  // component disabled
	INSTALLSTATE_BADCONFIG    = -6,  // configuration data corrupt
	INSTALLSTATE_INCOMPLETE   = -5,  // installation suspended or in progress
	INSTALLSTATE_SOURCEABSENT = -4,  // run from source, source is unavailable
	INSTALLSTATE_MOREDATA     = -3,  // return buffer overflow
	INSTALLSTATE_INVALIDARG   = -2,  // invalid function argument
	INSTALLSTATE_UNKNOWN      = -1,  // unrecognized product or feature
	INSTALLSTATE_BROKEN       =  0,  // broken
	INSTALLSTATE_ADVERTISED   =  1,  // advertised feature
	INSTALLSTATE_REMOVED      =  1,  // component being removed (action state, not settable)
	INSTALLSTATE_ABSENT       =  2,  // uninstalled (or action state absent but clients remain)
	INSTALLSTATE_LOCAL        =  3,  // installed on local drive
	INSTALLSTATE_SOURCE       =  4,  // run from source, CD or net
	INSTALLSTATE_DEFAULT      =  5,  // use default, local or source
} INSTALLSTATE;

typedef enum tagUSERINFOSTATE
{
	USERINFOSTATE_MOREDATA   = -3,  // return buffer overflow
	USERINFOSTATE_INVALIDARG = -2,  // invalid function argument
	USERINFOSTATE_UNKNOWN    = -1,  // unrecognized product
	USERINFOSTATE_ABSENT     =  0,  // user info and PID not initialized
	USERINFOSTATE_PRESENT    =  1,  // user info and PID initialized
} USERINFOSTATE;

typedef enum tagINSTALLLEVEL
{
	INSTALLLEVEL_DEFAULT = 0,      // install authored default
	INSTALLLEVEL_MINIMUM = 1,      // install only required features
	INSTALLLEVEL_MAXIMUM = 0xFFFF, // install all features
} INSTALLLEVEL;                   // intermediate levels dependent on authoring

typedef enum tagREINSTALLMODE  // bit flags
{
	REINSTALLMODE_REPAIR           = 0x00000001,  // Reserved bit - currently ignored
	REINSTALLMODE_FILEMISSING      = 0x00000002,  // Reinstall only if file is missing
	REINSTALLMODE_FILEOLDERVERSION = 0x00000004,  // Reinstall if file is missing, or older version
	REINSTALLMODE_FILEEQUALVERSION = 0x00000008,  // Reinstall if file is missing, or equal or older version
	REINSTALLMODE_FILEEXACT        = 0x00000010,  // Reinstall if file is missing, or not exact version
	REINSTALLMODE_FILEVERIFY       = 0x00000020,  // checksum executables, reinstall if missing or corrupt
	REINSTALLMODE_FILEREPLACE      = 0x00000040,  // Reinstall all files, regardless of version
	REINSTALLMODE_MACHINEDATA      = 0x00000080,  // insure required machine reg entries
	REINSTALLMODE_USERDATA         = 0x00000100,  // insure required user reg entries
	REINSTALLMODE_SHORTCUT         = 0x00000200,  // validate shortcuts items
	REINSTALLMODE_PACKAGE          = 0x00000400,  // use re-cache source install package
} REINSTALLMODE;

typedef enum tagINSTALLOGMODE  // bit flags for use with MsiEnableLog and MsiSetExternalUI
{
	INSTALLLOGMODE_FATALEXIT      = (1 << (INSTALLMESSAGE_FATALEXIT      >> 24)),
	INSTALLLOGMODE_ERROR          = (1 << (INSTALLMESSAGE_ERROR          >> 24)),
	INSTALLLOGMODE_WARNING        = (1 << (INSTALLMESSAGE_WARNING        >> 24)),
	INSTALLLOGMODE_USER           = (1 << (INSTALLMESSAGE_USER           >> 24)),
	INSTALLLOGMODE_INFO           = (1 << (INSTALLMESSAGE_INFO           >> 24)),
	INSTALLLOGMODE_RESOLVESOURCE  = (1 << (INSTALLMESSAGE_RESOLVESOURCE  >> 24)),
	INSTALLLOGMODE_OUTOFDISKSPACE = (1 << (INSTALLMESSAGE_OUTOFDISKSPACE >> 24)),
	INSTALLLOGMODE_ACTIONSTART    = (1 << (INSTALLMESSAGE_ACTIONSTART    >> 24)),
	INSTALLLOGMODE_ACTIONDATA     = (1 << (INSTALLMESSAGE_ACTIONDATA     >> 24)),
	INSTALLLOGMODE_COMMONDATA     = (1 << (INSTALLMESSAGE_COMMONDATA     >> 24)),
	INSTALLLOGMODE_PROPERTYDUMP   = (1 << (INSTALLMESSAGE_PROGRESS       >> 24)), // log only
	INSTALLLOGMODE_VERBOSE        = (1 << (INSTALLMESSAGE_INITIALIZE     >> 24)), // log only
	INSTALLLOGMODE_PROGRESS       = (1 << (INSTALLMESSAGE_PROGRESS       >> 24)), // external handler only
	INSTALLLOGMODE_INITIALIZE     = (1 << (INSTALLMESSAGE_INITIALIZE     >> 24)), // external handler only
	INSTALLLOGMODE_TERMINATE      = (1 << (INSTALLMESSAGE_TERMINATE      >> 24)), // external handler only
	INSTALLLOGMODE_SHOWDIALOG     = (1 << (INSTALLMESSAGE_SHOWDIALOG     >> 24)), // external handler only
} INSTALLLOGMODE;

typedef enum tagINSTALLLOGATTRIBUTES // flag attributes for MsiEnableLog
{
	INSTALLLOGATTRIBUTES_APPEND            = (1 << 0),
	INSTALLLOGATTRIBUTES_FLUSHEACHLINE     = (1 << 1),
} INSTALLLOGATTRIBUTES;

typedef enum tagINSTALLFEATUREATTRIBUTE // bit flags
{
	INSTALLFEATUREATTRIBUTE_FAVORLOCAL             = 1 << 0,
	INSTALLFEATUREATTRIBUTE_FAVORSOURCE            = 1 << 1,
	INSTALLFEATUREATTRIBUTE_FOLLOWPARENT           = 1 << 2,
	INSTALLFEATUREATTRIBUTE_FAVORADVERTISE         = 1 << 3,
	INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE      = 1 << 4,
	INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE = 1 << 5,
} INSTALLFEATUREATTRIBUTE;

typedef enum tagINSTALLMODE
{
	INSTALLMODE_NOSOURCERESOLUTION   = -3,  // skip source resolution
	INSTALLMODE_NODETECTION          = -2,  // skip detection
	INSTALLMODE_EXISTING             = -1,  // provide, if available
	INSTALLMODE_DEFAULT              =  0,  // install, if absent
} INSTALLMODE;

#define MAX_FEATURE_CHARS  38   // maximum chars in feature name (same as string GUID)


// Product info attributes: advertised information

#define INSTALLPROPERTY_TRANSFORMS            __TEXT("Transforms")
#define INSTALLPROPERTY_LANGUAGE              __TEXT("Language")
#define INSTALLPROPERTY_PRODUCTNAME           __TEXT("ProductName")
#define INSTALLPROPERTY_ASSIGNMENTTYPE        __TEXT("AssignmentType")
#define INSTALLPROPERTY_PACKAGECODE           __TEXT("PackageCode")
#define INSTALLPROPERTY_VERSION               __TEXT("Version")
#if (_WIN32_MSI >=  110)
#define INSTALLPROPERTY_PRODUCTICON           __TEXT("ProductIcon")
#endif //(_WIN32_MSI >=  110)

// Product info attributes: installed information

#define INSTALLPROPERTY_INSTALLEDPRODUCTNAME  __TEXT("InstalledProductName")
#define INSTALLPROPERTY_VERSIONSTRING         __TEXT("VersionString")
#define INSTALLPROPERTY_HELPLINK              __TEXT("HelpLink")
#define INSTALLPROPERTY_HELPTELEPHONE         __TEXT("HelpTelephone")
#define INSTALLPROPERTY_INSTALLLOCATION       __TEXT("InstallLocation")
#define INSTALLPROPERTY_INSTALLSOURCE         __TEXT("InstallSource")
#define INSTALLPROPERTY_INSTALLDATE           __TEXT("InstallDate")
#define INSTALLPROPERTY_PUBLISHER             __TEXT("Publisher")
#define INSTALLPROPERTY_LOCALPACKAGE          __TEXT("LocalPackage")
#define INSTALLPROPERTY_URLINFOABOUT          __TEXT("URLInfoAbout")
#define INSTALLPROPERTY_URLUPDATEINFO         __TEXT("URLUpdateInfo")
#define INSTALLPROPERTY_VERSIONMINOR          __TEXT("VersionMinor")
#define INSTALLPROPERTY_VERSIONMAJOR          __TEXT("VersionMajor")


typedef enum tagINSTALLTYPE
{
	INSTALLTYPE_DEFAULT            =    0,   // set to indicate default behavior
	INSTALLTYPE_NETWORK_IMAGE      =    1,   // set to indicate network install
}INSTALLTYPE;

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------
// Functions to set the UI handling and logging. The UI will be used for error,
// progress, and log messages for all subsequent calls to Installer Service
// API functions that require UI.
// --------------------------------------------------------------------------

// Enable internal UI

INSTALLUILEVEL WINAPI MsiSetInternalUI(
	INSTALLUILEVEL  dwUILevel,     // UI level
	HWND  *phWnd);                   // handle of owner window

// Enable external UI handling, returns any previous handler or NULL if none.
// Messages are designated with a combination of bits from INSTALLLOGMODE enum.

INSTALLUI_HANDLERA WINAPI MsiSetExternalUIA(
	INSTALLUI_HANDLERA puiHandler,   // for progress and error handling 
	DWORD              dwMessageFilter, // bit flags designating messages to handle
	LPVOID             pvContext);   // application context
INSTALLUI_HANDLERW WINAPI MsiSetExternalUIW(
	INSTALLUI_HANDLERW puiHandler,   // for progress and error handling 
	DWORD              dwMessageFilter, // bit flags designating messages to handle
	LPVOID             pvContext);   // application context
#ifdef UNICODE
#define MsiSetExternalUI  MsiSetExternalUIW
#else
#define MsiSetExternalUI  MsiSetExternalUIA
#endif // !UNICODE


// Enable logging to a file for all install sessions for the client process,
// with control over which log messages are passed to the specified log file.
// Messages are designated with a combination of bits from INSTALLLOGMODE enum.

UINT WINAPI MsiEnableLogA(
	DWORD     dwLogMode,           // bit flags designating operations to report
	LPCSTR  szLogFile,           // log file, or NULL to disable logging
	DWORD     dwLogAttributes);    // INSTALLLOGATTRIBUTES flags
UINT WINAPI MsiEnableLogW(
	DWORD     dwLogMode,           // bit flags designating operations to report
	LPCWSTR  szLogFile,           // log file, or NULL to disable logging
	DWORD     dwLogAttributes);    // INSTALLLOGATTRIBUTES flags
#ifdef UNICODE
#define MsiEnableLog  MsiEnableLogW
#else
#define MsiEnableLog  MsiEnableLogA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to query and configure a product as a whole.
// --------------------------------------------------------------------------

// Return the installed state for a product

INSTALLSTATE WINAPI MsiQueryProductStateA(
	LPCSTR  szProduct);
INSTALLSTATE WINAPI MsiQueryProductStateW(
	LPCWSTR  szProduct);
#ifdef UNICODE
#define MsiQueryProductState  MsiQueryProductStateW
#else
#define MsiQueryProductState  MsiQueryProductStateA
#endif // !UNICODE

// Return product info

UINT WINAPI MsiGetProductInfoA(
	LPCSTR   szProduct,      // product code
	LPCSTR   szAttribute,    // attribute name, case-sensitive
	LPSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiGetProductInfoW(
	LPCWSTR   szProduct,      // product code
	LPCWSTR   szAttribute,    // attribute name, case-sensitive
	LPWSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiGetProductInfo  MsiGetProductInfoW
#else
#define MsiGetProductInfo  MsiGetProductInfoA
#endif // !UNICODE

// Install a new product.
// Either may be NULL, but the DATABASE property must be specfied

UINT WINAPI MsiInstallProductA(
	LPCSTR      szPackagePath,    // location of package to install
	LPCSTR      szCommandLine);   // command line <property settings>
UINT WINAPI MsiInstallProductW(
	LPCWSTR      szPackagePath,    // location of package to install
	LPCWSTR      szCommandLine);   // command line <property settings>
#ifdef UNICODE
#define MsiInstallProduct  MsiInstallProductW
#else
#define MsiInstallProduct  MsiInstallProductA
#endif // !UNICODE

// Install/uninstall an advertised or installed product
// No action if installed and INSTALLSTATE_DEFAULT specified

UINT WINAPI MsiConfigureProductA(
	LPCSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
UINT WINAPI MsiConfigureProductW(
	LPCWSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
#ifdef UNICODE
#define MsiConfigureProduct  MsiConfigureProductW
#else
#define MsiConfigureProduct  MsiConfigureProductA
#endif // !UNICODE

// Install/uninstall an advertised or installed product
// No action if installed and INSTALLSTATE_DEFAULT specified

UINT WINAPI MsiConfigureProductExA(
	LPCSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState,    // local/source/default/absent/lock/uncache
	LPCSTR      szCommandLine);   // command line <property settings>
UINT WINAPI MsiConfigureProductExW(
	LPCWSTR      szProduct,        // product code
	int          iInstallLevel,    // how much of the product to install
	INSTALLSTATE eInstallState,    // local/source/default/absent/lock/uncache
	LPCWSTR      szCommandLine);   // command line <property settings>
#ifdef UNICODE
#define MsiConfigureProductEx  MsiConfigureProductExW
#else
#define MsiConfigureProductEx  MsiConfigureProductExA
#endif // !UNICODE

// Reinstall product, used to validate or correct problems

UINT WINAPI MsiReinstallProductA(
	LPCSTR      szProduct,        // product code
	DWORD         szReinstallMode); // one or more REINSTALLMODE modes
UINT WINAPI MsiReinstallProductW(
	LPCWSTR      szProduct,        // product code
	DWORD         szReinstallMode); // one or more REINSTALLMODE modes
#ifdef UNICODE
#define MsiReinstallProduct  MsiReinstallProductW
#else
#define MsiReinstallProduct  MsiReinstallProductA
#endif // !UNICODE


// Return the product code for a registered component, called once by apps

UINT WINAPI MsiGetProductCodeA(
	LPCSTR   szComponent,   // component Id registered for this product
	LPSTR    lpBuf39);      // returned string GUID, sized for 39 characters
UINT WINAPI MsiGetProductCodeW(
	LPCWSTR   szComponent,   // component Id registered for this product
	LPWSTR    lpBuf39);      // returned string GUID, sized for 39 characters
#ifdef UNICODE
#define MsiGetProductCode  MsiGetProductCodeW
#else
#define MsiGetProductCode  MsiGetProductCodeA
#endif // !UNICODE

// Return the registered user information for an installed product

USERINFOSTATE WINAPI MsiGetUserInfoA(
	LPCSTR  szProduct,        // product code, string GUID
	LPSTR   lpUserNameBuf,    // return user name           
	DWORD    *pcchUserNameBuf, // in/out buffer character count
	LPSTR   lpOrgNameBuf,     // return company name           
	DWORD    *pcchOrgNameBuf,  // in/out buffer character count
	LPSTR   lpSerialBuf,      // return product serial number
	DWORD    *pcchSerialBuf);  // in/out buffer character count
USERINFOSTATE WINAPI MsiGetUserInfoW(
	LPCWSTR  szProduct,        // product code, string GUID
	LPWSTR   lpUserNameBuf,    // return user name           
	DWORD    *pcchUserNameBuf, // in/out buffer character count
	LPWSTR   lpOrgNameBuf,     // return company name           
	DWORD    *pcchOrgNameBuf,  // in/out buffer character count
	LPWSTR   lpSerialBuf,      // return product serial number
	DWORD    *pcchSerialBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetUserInfo  MsiGetUserInfoW
#else
#define MsiGetUserInfo  MsiGetUserInfoA
#endif // !UNICODE

// Obtain and store user info and PID from installation wizard (first run)

UINT WINAPI MsiCollectUserInfoA(
	LPCSTR  szProduct);     // product code, string GUID
UINT WINAPI MsiCollectUserInfoW(
	LPCWSTR  szProduct);     // product code, string GUID
#ifdef UNICODE
#define MsiCollectUserInfo  MsiCollectUserInfoW
#else
#define MsiCollectUserInfo  MsiCollectUserInfoA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to patch existing products
// --------------------------------------------------------------------------

// Patch all possible installed products.

UINT WINAPI MsiApplyPatchA(
	LPCSTR      szPatchPackage,   // location of patch package
	LPCSTR      szInstallPackage, // location of package for install to patch <optional>
	INSTALLTYPE   eInstallType,     // type of install to patch
	LPCSTR      szCommandLine);   // command line <property settings>
UINT WINAPI MsiApplyPatchW(
	LPCWSTR      szPatchPackage,   // location of patch package
	LPCWSTR      szInstallPackage, // location of package for install to patch <optional>
	INSTALLTYPE   eInstallType,     // type of install to patch
	LPCWSTR      szCommandLine);   // command line <property settings>
#ifdef UNICODE
#define MsiApplyPatch  MsiApplyPatchW
#else
#define MsiApplyPatch  MsiApplyPatchA
#endif // !UNICODE

// Return patch info

UINT WINAPI MsiGetPatchInfoA(
	LPCSTR   szPatch,        // patch code
	LPCSTR   szAttribute,    // attribute name, case-sensitive
	LPSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiGetPatchInfoW(
	LPCWSTR   szPatch,        // patch code
	LPCWSTR   szAttribute,    // attribute name, case-sensitive
	LPWSTR    lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiGetPatchInfo  MsiGetPatchInfoW
#else
#define MsiGetPatchInfo  MsiGetPatchInfoA
#endif // !UNICODE

// Enumerate all patches for a product

UINT WINAPI MsiEnumPatchesA(
	LPCSTR szProduct,
	DWORD    iPatchIndex,
	LPSTR  lpPatchBuf,
	LPSTR  lpTransformsBuf,
	DWORD    *pcchTransformsBuf);
UINT WINAPI MsiEnumPatchesW(
	LPCWSTR szProduct,
	DWORD    iPatchIndex,
	LPWSTR  lpPatchBuf,
	LPWSTR  lpTransformsBuf,
	DWORD    *pcchTransformsBuf);
#ifdef UNICODE
#define MsiEnumPatches  MsiEnumPatchesW
#else
#define MsiEnumPatches  MsiEnumPatchesA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to query and configure a feature within a product.
// --------------------------------------------------------------------------

// Return the installed state for a product feature

INSTALLSTATE WINAPI MsiQueryFeatureStateA(
	LPCSTR  szProduct,
	LPCSTR  szFeature);
INSTALLSTATE WINAPI MsiQueryFeatureStateW(
	LPCWSTR  szProduct,
	LPCWSTR  szFeature);
#ifdef UNICODE
#define MsiQueryFeatureState  MsiQueryFeatureStateW
#else
#define MsiQueryFeatureState  MsiQueryFeatureStateA
#endif // !UNICODE

// Indicate intent to use a product feature, increments usage count
// Prompts for CD if not loaded, does not install feature

INSTALLSTATE WINAPI MsiUseFeatureA(
	LPCSTR  szProduct,
	LPCSTR  szFeature);
INSTALLSTATE WINAPI MsiUseFeatureW(
	LPCWSTR  szProduct,
	LPCWSTR  szFeature);
#ifdef UNICODE
#define MsiUseFeature  MsiUseFeatureW
#else
#define MsiUseFeature  MsiUseFeatureA
#endif // !UNICODE

// Indicate intent to use a product feature, increments usage count
// Prompts for CD if not loaded, does not install feature
// Allows for bypassing component detection where performance is critical

INSTALLSTATE WINAPI MsiUseFeatureExA(
	LPCSTR  szProduct,          // product code
	LPCSTR  szFeature,          // feature ID
	DWORD     dwInstallMode,      // INSTALLMODE_NODETECTION, else 0
	DWORD     dwReserved);        // reserved, must be 0
INSTALLSTATE WINAPI MsiUseFeatureExW(
	LPCWSTR  szProduct,          // product code
	LPCWSTR  szFeature,          // feature ID
	DWORD     dwInstallMode,      // INSTALLMODE_NODETECTION, else 0
	DWORD     dwReserved);        // reserved, must be 0
#ifdef UNICODE
#define MsiUseFeatureEx  MsiUseFeatureExW
#else
#define MsiUseFeatureEx  MsiUseFeatureExA
#endif // !UNICODE

// Return the usage metrics for a product feature

UINT WINAPI MsiGetFeatureUsageA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szFeature,        // feature ID
	DWORD        *pdwUseCount,     // returned use count
	WORD         *pwDateUsed);     // last date used (DOS date format)
UINT WINAPI MsiGetFeatureUsageW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szFeature,        // feature ID
	DWORD        *pdwUseCount,     // returned use count
	WORD         *pwDateUsed);     // last date used (DOS date format)
#ifdef UNICODE
#define MsiGetFeatureUsage  MsiGetFeatureUsageW
#else
#define MsiGetFeatureUsage  MsiGetFeatureUsageA
#endif // !UNICODE

// Force the installed state for a product feature

UINT WINAPI MsiConfigureFeatureA(
	LPCSTR  szProduct,
	LPCSTR  szFeature,
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
UINT WINAPI MsiConfigureFeatureW(
	LPCWSTR  szProduct,
	LPCWSTR  szFeature,
	INSTALLSTATE eInstallState);   // local/source/default/absent/lock/uncache
#ifdef UNICODE
#define MsiConfigureFeature  MsiConfigureFeatureW
#else
#define MsiConfigureFeature  MsiConfigureFeatureA
#endif // !UNICODE


// Reinstall feature, used to validate or correct problems

UINT WINAPI MsiReinstallFeatureA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szFeature,        // feature ID, NULL for entire product
	DWORD         dwReinstallMode); // one or more REINSTALLMODE modes
UINT WINAPI MsiReinstallFeatureW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szFeature,        // feature ID, NULL for entire product
	DWORD         dwReinstallMode); // one or more REINSTALLMODE modes
#ifdef UNICODE
#define MsiReinstallFeature  MsiReinstallFeatureW
#else
#define MsiReinstallFeature  MsiReinstallFeatureA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to return a path to a particular component.
// The state of the feature being used should have been checked previously.
// --------------------------------------------------------------------------

// Return full component path, performing any necessary installation
// calls MsiQueryFeatureState to detect that all components are installed
// then calls MsiConfigureFeature if any of its components are uninstalled
// then calls MsiLocateComponent to obtain the path the its key file

UINT WINAPI MsiProvideComponentA(
	LPCSTR     szProduct,    // product code in case install required
	LPCSTR     szFeature,    // feature ID in case install required
	LPCSTR     szComponent,  // component ID
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf);// in/out buffer character count
UINT WINAPI MsiProvideComponentW(
	LPCWSTR     szProduct,    // product code in case install required
	LPCWSTR     szFeature,    // feature ID in case install required
	LPCWSTR     szComponent,  // component ID
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPWSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf);// in/out buffer character count
#ifdef UNICODE
#define MsiProvideComponent  MsiProvideComponentW
#else
#define MsiProvideComponent  MsiProvideComponentA
#endif // !UNICODE

// Return full component path for a qualified component, performing any necessary installation. 
// Prompts for source if necessary and increments the usage count for the feature.

UINT WINAPI MsiProvideQualifiedComponentA(
	LPCSTR     szCategory,   // component category ID
	LPCSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
UINT WINAPI MsiProvideQualifiedComponentW(
	LPCWSTR     szCategory,   // component category ID
	LPCWSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPWSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiProvideQualifiedComponent  MsiProvideQualifiedComponentW
#else
#define MsiProvideQualifiedComponent  MsiProvideQualifiedComponentA
#endif // !UNICODE

// Return full component path for a qualified component, performing any necessary installation. 
// Prompts for source if necessary and increments the usage count for the feature.
// The szProduct parameter specifies the product to match that has published the qualified
// component. If null, this API works the same as MsiProvideQualifiedComponent. 

UINT WINAPI MsiProvideQualifiedComponentExA(
	LPCSTR     szCategory,   // component category ID
	LPCSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPCSTR     szProduct,    // the product code 
	DWORD        dwUnused1,    // not used, must be zero
	DWORD        dwUnused2,    // not used, must be zero
	LPSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
UINT WINAPI MsiProvideQualifiedComponentExW(
	LPCWSTR     szCategory,   // component category ID
	LPCWSTR     szQualifier,  // specifies which component to access
	DWORD        dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPCWSTR     szProduct,    // the product code 
	DWORD        dwUnused1,    // not used, must be zero
	DWORD        dwUnused2,    // not used, must be zero
	LPWSTR      lpPathBuf,    // returned path, NULL if not desired
	DWORD       *pcchPathBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiProvideQualifiedComponentEx  MsiProvideQualifiedComponentExW
#else
#define MsiProvideQualifiedComponentEx  MsiProvideQualifiedComponentExA
#endif // !UNICODE

// Return full path to an installed component

INSTALLSTATE WINAPI MsiGetComponentPathA(
	LPCSTR   szProduct,   // product code for client product
	LPCSTR   szComponent, // component Id, string GUID
	LPSTR    lpPathBuf,   // returned path
	DWORD     *pcchBuf);    // in/out buffer character count
INSTALLSTATE WINAPI MsiGetComponentPathW(
	LPCWSTR   szProduct,   // product code for client product
	LPCWSTR   szComponent, // component Id, string GUID
	LPWSTR    lpPathBuf,   // returned path
	DWORD     *pcchBuf);    // in/out buffer character count
#ifdef UNICODE
#define MsiGetComponentPath  MsiGetComponentPathW
#else
#define MsiGetComponentPath  MsiGetComponentPathA
#endif // !UNICODE



// --------------------------------------------------------------------------
// Functions to iterate registered products, features, and components.
// As with reg keys, they accept a 0-based index into the enumeration.
// --------------------------------------------------------------------------

// Enumerate the registered products, either installed or advertised

UINT WINAPI MsiEnumProductsA(
	DWORD     iProductIndex,    // 0-based index into registered products
	LPSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumProductsW(
	DWORD     iProductIndex,    // 0-based index into registered products
	LPWSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumProducts  MsiEnumProductsW
#else
#define MsiEnumProducts  MsiEnumProductsA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// Enumerate products with given upgrade code

UINT WINAPI MsiEnumRelatedProductsA(
	LPCSTR  lpUpgradeCode,    // upgrade code of products to enumerate
	DWORD     dwReserved,       // reserved, must be 0
	DWORD     iProductIndex,    // 0-based index into registered products
	LPSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumRelatedProductsW(
	LPCWSTR  lpUpgradeCode,    // upgrade code of products to enumerate
	DWORD     dwReserved,       // reserved, must be 0
	DWORD     iProductIndex,    // 0-based index into registered products
	LPWSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumRelatedProducts  MsiEnumRelatedProductsW
#else
#define MsiEnumRelatedProducts  MsiEnumRelatedProductsA
#endif // !UNICODE

#endif //(_WIN32_MSI >=  110)

// Enumerate the advertised features for a given product.
// If parent is not required, supplying NULL will improve performance.

UINT WINAPI MsiEnumFeaturesA(
	LPCSTR  szProduct,
	DWORD     iFeatureIndex,  // 0-based index into published features
	LPSTR   lpFeatureBuf,   // feature name buffer,   size=MAX_FEATURE_CHARS+1
	LPSTR   lpParentBuf);   // parent feature buffer, size=MAX_FEATURE_CHARS+1
UINT WINAPI MsiEnumFeaturesW(
	LPCWSTR  szProduct,
	DWORD     iFeatureIndex,  // 0-based index into published features
	LPWSTR   lpFeatureBuf,   // feature name buffer,   size=MAX_FEATURE_CHARS+1
	LPWSTR   lpParentBuf);   // parent feature buffer, size=MAX_FEATURE_CHARS+1
#ifdef UNICODE
#define MsiEnumFeatures  MsiEnumFeaturesW
#else
#define MsiEnumFeatures  MsiEnumFeaturesA
#endif // !UNICODE

// Enumerate the installed components for all products

UINT WINAPI MsiEnumComponentsA(
	DWORD    iComponentIndex,  // 0-based index into installed components
	LPSTR   lpComponentBuf);  // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumComponentsW(
	DWORD    iComponentIndex,  // 0-based index into installed components
	LPWSTR   lpComponentBuf);  // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumComponents  MsiEnumComponentsW
#else
#define MsiEnumComponents  MsiEnumComponentsA
#endif // !UNICODE

// Enumerate the client products for a component

UINT WINAPI MsiEnumClientsA(
	LPCSTR  szComponent,
	DWORD     iProductIndex,    // 0-based index into client products
	LPSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
UINT WINAPI MsiEnumClientsW(
	LPCWSTR  szComponent,
	DWORD     iProductIndex,    // 0-based index into client products
	LPWSTR   lpProductBuf);    // buffer of char count: 39 (size of string GUID)
#ifdef UNICODE
#define MsiEnumClients  MsiEnumClientsW
#else
#define MsiEnumClients  MsiEnumClientsA
#endif // !UNICODE

// Enumerate the qualifiers for an advertised component.

UINT WINAPI MsiEnumComponentQualifiersA(
	LPCSTR   szComponent,         // generic component ID that is qualified
	DWORD     iIndex,	           // 0-based index into qualifiers
	LPSTR    lpQualifierBuf,      // qualifier buffer
	DWORD     *pcchQualifierBuf,   // in/out qualifier buffer character count
	LPSTR    lpApplicationDataBuf,    // description buffer
	DWORD     *pcchApplicationDataBuf); // in/out description buffer character count
UINT WINAPI MsiEnumComponentQualifiersW(
	LPCWSTR   szComponent,         // generic component ID that is qualified
	DWORD     iIndex,	           // 0-based index into qualifiers
	LPWSTR    lpQualifierBuf,      // qualifier buffer
	DWORD     *pcchQualifierBuf,   // in/out qualifier buffer character count
	LPWSTR    lpApplicationDataBuf,    // description buffer
	DWORD     *pcchApplicationDataBuf); // in/out description buffer character count
#ifdef UNICODE
#define MsiEnumComponentQualifiers  MsiEnumComponentQualifiersW
#else
#define MsiEnumComponentQualifiers  MsiEnumComponentQualifiersA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to obtain product or package information.
// --------------------------------------------------------------------------

// Open the installation for a product to obtain detailed information

UINT WINAPI MsiOpenProductA(
	LPCSTR   szProduct,    // product code
	MSIHANDLE  *hProduct);   // returned product handle, must be closed
UINT WINAPI MsiOpenProductW(
	LPCWSTR   szProduct,    // product code
	MSIHANDLE  *hProduct);   // returned product handle, must be closed
#ifdef UNICODE
#define MsiOpenProduct  MsiOpenProductW
#else
#define MsiOpenProduct  MsiOpenProductA
#endif // !UNICODE

// Open a product package in order to access product properties

UINT WINAPI MsiOpenPackageA(
	LPCSTR    szPackagePath,     // path to package, or database handle: #nnnn
	MSIHANDLE  *hProduct);         // returned product handle, must be closed
UINT WINAPI MsiOpenPackageW(
	LPCWSTR    szPackagePath,     // path to package, or database handle: #nnnn
	MSIHANDLE  *hProduct);         // returned product handle, must be closed
#ifdef UNICODE
#define MsiOpenPackage  MsiOpenPackageW
#else
#define MsiOpenPackage  MsiOpenPackageA
#endif // !UNICODE

// Provide the value for an installation property.

UINT WINAPI MsiGetProductPropertyA(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCSTR    szProperty,     // property name, case-sensitive
	LPSTR     lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiGetProductPropertyW(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCWSTR    szProperty,     // property name, case-sensitive
	LPWSTR     lpValueBuf,     // returned value, NULL if not desired
	DWORD      *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiGetProductProperty  MsiGetProductPropertyW
#else
#define MsiGetProductProperty  MsiGetProductPropertyA
#endif // !UNICODE


// Determine whether a file is a package
// Returns ERROR_SUCCESS if file is a package.

UINT WINAPI MsiVerifyPackageA(
	LPCSTR      szPackagePath);   // location of package
UINT WINAPI MsiVerifyPackageW(
	LPCWSTR      szPackagePath);   // location of package
#ifdef UNICODE
#define MsiVerifyPackage  MsiVerifyPackageW
#else
#define MsiVerifyPackage  MsiVerifyPackageA
#endif // !UNICODE


// Provide descriptive information for product feature: title and description.
// Returns the install level for the feature, or -1 if feature is unknown.
//   0 = feature is not available on this machine
//   1 = highest priority, feature installed if parent is installed
//  >1 = decreasing priority, feature installation based on InstallLevel property

UINT WINAPI MsiGetFeatureInfoA(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCSTR    szFeature,      // feature name
	DWORD      *lpAttributes,  // attribute flags for the feature, using INSTALLFEATUREATTRIBUTE
	LPSTR     lpTitleBuf,     // returned localized name, NULL if not desired
	DWORD      *pcchTitleBuf,  // in/out buffer character count
	LPSTR     lpHelpBuf,      // returned description, NULL if not desired
	DWORD      *pcchHelpBuf);  // in/out buffer character count
UINT WINAPI MsiGetFeatureInfoW(
	MSIHANDLE   hProduct,       // product handle obtained from MsiOpenProduct
	LPCWSTR    szFeature,      // feature name
	DWORD      *lpAttributes,  // attribute flags for the feature, using INSTALLFEATUREATTRIBUTE
	LPWSTR     lpTitleBuf,     // returned localized name, NULL if not desired
	DWORD      *pcchTitleBuf,  // in/out buffer character count
	LPWSTR     lpHelpBuf,      // returned description, NULL if not desired
	DWORD      *pcchHelpBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetFeatureInfo  MsiGetFeatureInfoW
#else
#define MsiGetFeatureInfo  MsiGetFeatureInfoA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Functions to access or install missing components and files.
// These should be used as a last resort.
// --------------------------------------------------------------------------

// Install a component unexpectedly missing, provided only for error recovery
// This would typically occur due to failue to establish feature availability
// The product feature having the smallest incremental cost is installed

UINT WINAPI MsiInstallMissingComponentA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szComponent,      // component Id, string GUID
	INSTALLSTATE eInstallState);  // local/source/default, absent invalid
UINT WINAPI MsiInstallMissingComponentW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szComponent,      // component Id, string GUID
	INSTALLSTATE eInstallState);  // local/source/default, absent invalid
#ifdef UNICODE
#define MsiInstallMissingComponent  MsiInstallMissingComponentW
#else
#define MsiInstallMissingComponent  MsiInstallMissingComponentA
#endif // !UNICODE

// Install a file unexpectedly missing, provided only for error recovery
// This would typically occur due to failue to establish feature availability
// The missing component is determined from the product's File table, then
// the product feature having the smallest incremental cost is installed

UINT WINAPI MsiInstallMissingFileA(
	LPCSTR      szProduct,        // product code
	LPCSTR      szFile);          // file name, without path
UINT WINAPI MsiInstallMissingFileW(
	LPCWSTR      szProduct,        // product code
	LPCWSTR      szFile);          // file name, without path
#ifdef UNICODE
#define MsiInstallMissingFile  MsiInstallMissingFileW
#else
#define MsiInstallMissingFile  MsiInstallMissingFileA
#endif // !UNICODE

// Return full path to an installed component without a product code
// This function attempts to determine the product using MsiGetProductCode
// but is not guaranteed to find the correct product for the caller.
// MsiGetComponentPath should always be called when possible.

INSTALLSTATE WINAPI MsiLocateComponentA(
	LPCSTR szComponent,  // component Id, string GUID
	LPSTR  lpPathBuf,    // returned path
	DWORD   *pcchBuf);    // in/out buffer character count
INSTALLSTATE WINAPI MsiLocateComponentW(
	LPCWSTR szComponent,  // component Id, string GUID
	LPWSTR  lpPathBuf,    // returned path
	DWORD   *pcchBuf);    // in/out buffer character count
#ifdef UNICODE
#define MsiLocateComponent  MsiLocateComponentW
#else
#define MsiLocateComponent  MsiLocateComponentA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// --------------------------------------------------------------------------
// Functions used to manage the list of valid sources.
// --------------------------------------------------------------------------

// Opens the list of sources for the specified user's install of the product
// and removes all network sources from the list. A NULL or empty value for
// the user name indicates the per-machine install.

UINT WINAPI MsiSourceListClearAllA(
	LPCSTR szProduct,          // product code
	LPCSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
UINT WINAPI MsiSourceListClearAllW(
	LPCWSTR szProduct,          // product code
	LPCWSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
#ifdef UNICODE
#define MsiSourceListClearAll  MsiSourceListClearAllW
#else
#define MsiSourceListClearAll  MsiSourceListClearAllA
#endif // !UNICODE

// Opens the list of sources for the specified user's install of the product
// and adds the provided source as a new network source. A NULL or empty 
// value for the user name indicates the per-machine install.

UINT WINAPI MsiSourceListAddSourceA(
	LPCSTR szProduct,          // product code
	LPCSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved,         // reserved - must be 0
	LPCSTR szSource);          // new source
UINT WINAPI MsiSourceListAddSourceW(
	LPCWSTR szProduct,          // product code
	LPCWSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved,         // reserved - must be 0
	LPCWSTR szSource);          // new source
#ifdef UNICODE
#define MsiSourceListAddSource  MsiSourceListAddSourceW
#else
#define MsiSourceListAddSource  MsiSourceListAddSourceA
#endif // !UNICODE

// Forces the installer to reevaluate the list of sources the next time that
// the specified product needs a source.

UINT WINAPI MsiSourceListForceResolutionA(
	LPCSTR szProduct,          // product code
	LPCSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
UINT WINAPI MsiSourceListForceResolutionW(
	LPCWSTR szProduct,          // product code
	LPCWSTR szUserName,         // user name or NULL/empty for per-machine
	DWORD    dwReserved);        // reserved - must be 0
#ifdef UNICODE
#define MsiSourceListForceResolution  MsiSourceListForceResolutionW
#else
#define MsiSourceListForceResolution  MsiSourceListForceResolutionA
#endif // !UNICODE
	
#endif //(_WIN32_MSI >=  110)

// --------------------------------------------------------------------------
// Utility functions
// --------------------------------------------------------------------------

// Give the version string and language for a specified file

UINT WINAPI MsiGetFileVersionA(
	LPCSTR    szFilePath,       // path to the file
	LPSTR     lpVersionBuf,     // returned version string
	DWORD      *pcchVersionBuf,   // in/out buffer byte count
	LPSTR     lpLangBuf,        // returned language string
	DWORD       *pcchLangBuf);    // in/out buffer byte count
UINT WINAPI MsiGetFileVersionW(
	LPCWSTR    szFilePath,       // path to the file
	LPWSTR     lpVersionBuf,     // returned version string
	DWORD      *pcchVersionBuf,   // in/out buffer byte count
	LPWSTR     lpLangBuf,        // returned language string
	DWORD       *pcchLangBuf);    // in/out buffer byte count
#ifdef UNICODE
#define MsiGetFileVersion  MsiGetFileVersionW
#else
#define MsiGetFileVersion  MsiGetFileVersionA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// examine a shortcut, and retrieve its descriptor information 
// if available.

UINT WINAPI MsiGetShortcutTargetA(
	LPCSTR    szShortcutPath,    // full file path for the shortcut
	LPSTR     szProductCode,     // returned product code   - GUID
	LPSTR     szFeatureId,       // returned Feature Id.
	LPSTR     szComponentCode);  // returned component code - GUID
UINT WINAPI MsiGetShortcutTargetW(
	LPCWSTR    szShortcutPath,    // full file path for the shortcut
	LPWSTR     szProductCode,     // returned product code   - GUID
	LPWSTR     szFeatureId,       // returned Feature Id.
	LPWSTR     szComponentCode);  // returned component code - GUID
#ifdef UNICODE
#define MsiGetShortcutTarget  MsiGetShortcutTargetW
#else
#define MsiGetShortcutTarget  MsiGetShortcutTargetA
#endif // !UNICODE

#endif //(_WIN32_MSI >=  110)

#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------
// Error codes for installer access functions - until merged to winerr.h
// --------------------------------------------------------------------------

#ifndef ERROR_INSTALL_FAILURE
#define ERROR_INSTALL_USEREXIT      1602L  // User cancel installation.
#define ERROR_INSTALL_FAILURE       1603L  // Fatal error during installation.
#define ERROR_INSTALL_SUSPEND       1604L  // Installation suspended, incomplete.
#define ERROR_UNKNOWN_PRODUCT       1605L  // This action is only valid for products that are currently installed.
#define ERROR_UNKNOWN_FEATURE       1606L  // Feature ID not registered.
#define ERROR_UNKNOWN_COMPONENT     1607L  // Component ID not registered.
#define ERROR_UNKNOWN_PROPERTY      1608L  // Unknown property.
#define ERROR_INVALID_HANDLE_STATE  1609L  // Handle is in an invalid state.
#define ERROR_BAD_CONFIGURATION     1610L  // The configuration data for this product is corrupt.  Contact your support personnel.
#define ERROR_INDEX_ABSENT          1611L  // Component qualifier not present.
#define ERROR_INSTALL_SOURCE_ABSENT 1612L  // The installation source for this product is not available.  Verify that the source exists and that you can access it.
#define ERROR_PRODUCT_UNINSTALLED   1614L  // Product is uninstalled.
#define ERROR_BAD_QUERY_SYNTAX      1615L  // SQL query syntax invalid or unsupported.
#define ERROR_INVALID_FIELD         1616L  // Record field does not exist.
#endif

#ifndef ERROR_INSTALL_SERVICE_FAILURE
#define ERROR_INSTALL_SERVICE_FAILURE      1601L // The Windows Installer service could not be accessed.  Contact your support personnel to verify that the Windows Installer service is properly registered.
#define ERROR_INSTALL_PACKAGE_VERSION      1613L // This installation package cannot be installed by the Windows Installer service.  You must install a Windows service pack that contains a newer version of the Windows Installer service.
#define ERROR_INSTALL_ALREADY_RUNNING      1618L // Another installation is already in progress.  Complete that installation before proceeding with this install.
#define ERROR_INSTALL_PACKAGE_OPEN_FAILED  1619L // This installation package could not be opened.  Verify that the package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer package.
#define ERROR_INSTALL_PACKAGE_INVALID      1620L // This installation package could not be opened.  Contact the application vendor to verify that this is a valid Windows Installer package.
#define ERROR_INSTALL_UI_FAILURE           1621L // There was an error starting the Windows Installer service user interface.  Contact your support personnel.
#define ERROR_INSTALL_LOG_FAILURE          1622L // Error opening installation log file.  Verify that the specified log file location exists and is writable.
#define ERROR_INSTALL_LANGUAGE_UNSUPPORTED 1623L // This language of this installation package is not supported by your system.
#define ERROR_INSTALL_PACKAGE_REJECTED     1625L // The system administrator has set policies to prevent this installation.

#define ERROR_FUNCTION_NOT_CALLED          1626L // Function could not be executed.
#define ERROR_FUNCTION_FAILED              1627L // Function failed during execution.
#define ERROR_INVALID_TABLE                1628L // Invalid or unknown table specified.
#define ERROR_DATATYPE_MISMATCH            1629L // Data supplied is of wrong type.
#define ERROR_UNSUPPORTED_TYPE             1630L // Data of this type is not supported.
#define ERROR_CREATE_FAILED                1631L // The Windows Installer service failed to start.  Contact your support personnel.
#endif

#ifndef ERROR_INSTALL_TEMP_UNWRITABLE      
#define ERROR_INSTALL_TEMP_UNWRITABLE      1632L // The Temp folder is on a drive that is full or is inaccessible. Free up space on the drive or verify that you have write permission on the Temp folder.
#endif

#ifndef ERROR_INSTALL_PLATFORM_UNSUPPORTED
#define ERROR_INSTALL_PLATFORM_UNSUPPORTED 1633L // This installation package is not supported by this processor type. Contact your product vendor.
#endif

#ifndef ERROR_INSTALL_NOTUSED
#define ERROR_INSTALL_NOTUSED              1634L // Component not used on this machine
#endif

#ifndef ERROR_INSTALL_TRANSFORM_FAILURE
#define ERROR_INSTALL_TRANSFORM_FAILURE     1624L // Error applying transforms.  Verify that the specified transform paths are valid.
#endif

#ifndef ERROR_PATCH_PACKAGE_OPEN_FAILED
#define ERROR_PATCH_PACKAGE_OPEN_FAILED    1635L // This patch package could not be opened.  Verify that the patch package exists and that you can access it, or contact the application vendor to verify that this is a valid Windows Installer patch package.
#define ERROR_PATCH_PACKAGE_INVALID        1636L // This patch package could not be opened.  Contact the application vendor to verify that this is a valid Windows Installer patch package.
#define ERROR_PATCH_PACKAGE_UNSUPPORTED    1637L // This patch package cannot be processed by the Windows Installer service.  You must install a Windows service pack that contains a newer version of the Windows Installer service.
#endif

#ifndef ERROR_PRODUCT_VERSION
#define ERROR_PRODUCT_VERSION              1638L // Another version of this product is already installed.  Installation of this version cannot continue.  To configure or remove the existing version of this product, use Add/Remove Programs on the Control Panel.
#endif

#ifndef ERROR_INVALID_COMMAND_LINE
#define ERROR_INVALID_COMMAND_LINE         1639L // Invalid command line argument.  Consult the Windows Installer SDK for detailed command line help.
#endif

// The following three error codes are not returned from MSI version 1.0

#ifndef ERROR_INSTALL_REMOTE_DISALLOWED
#define ERROR_INSTALL_REMOTE_DISALLOWED    1640L // Configuration of this product is not permitted from remote sessions. Contact your administrator.
#endif


#ifndef ERROR_SUCCESS_REBOOT_INITIATED
#define ERROR_SUCCESS_REBOOT_INITIATED     1641L // The requested operation completed successfully.  The system will be restarted so the changes can take effect.
#endif

#ifndef ERROR_PATCH_TARGET_NOT_FOUND
#define ERROR_PATCH_TARGET_NOT_FOUND       1642L // The upgrade patch cannot be installed by the Windows Installer service because the program to be upgraded may be missing, or the upgrade patch may update a different version of the program. Verify that the program to be upgraded exists on your computer and that you have the correct upgrade patch.
#endif

#endif // _MSI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\inc\setupcodes.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// SetupCodes.h
//
// This file contains the errors that the Setup and related tools return
//
//*****************************************************************************
#ifndef SetupCodes_h_
#define SetupCodes_h_

const int COR_REBOOT_REQUIRED           = 0x002000; // (8192) Reboot is required

const int COR_USAGE_ERROR               = 0x001000; // (4096) Improper usage/invalid parameters
const int COR_INSUFFICIENT_PRIVILEGES   = 0x001001; // (4097) On NT, Need Admin rights to (un)install
const int COR_DARWIN_INSTALL_FAILURE    = 0x001002; // (4098) Installation of Darwin components failed
const int COR_DARWIN_NOT_INSTALLED      = 0x001003; // (4099) Windows Installer is not installed properly on machine

const int COR_SINGLE_INSTANCE_FAIL      = 0x001004; // (4100) CreateMutex failed
const int COR_NOT_SINGLE_INSTANCE       = 0x001005; // (4101) Another instance of setup is already running

const int COR_MSI_OPEN_ERROR            = 0x001006; // (4102) Cannot open MSI Database
const int COR_MSI_READ_ERROR            = 0x001007; // (4103) Cannot read from MSI Database

const int COR_CANNOT_GET_TEMP_DIR       = 0x00100F; // (4111) Cannot get Temp directory
const int COR_OLD_FRAMEWORK_EXIST       = 0x001011; // (4113) beta NDP components detected
const int COR_TEMP_DIR_TOO_LONG         = 0x001013; // (4115) Temp directory too long
const int COR_SOURCE_DIR_TOO_LONG       = 0x001014; // (4116) source directory too long
const int COR_CANNOT_WRITE_LOG          = 0x001016; // (4118) Cannot write to log
const int COR_DARWIN_SERVICE_REQ_REBOOT = 0x001017; // (4119) The Darwin service is hung and requires a reboot in order to continue
const int COR_DARWIN_SERVICE_INTERNAL_ERROR = 0x001018; // (4120) An internal error occured while trying to initialize the Darwin Service

const int COR_EXIT_FAILURE              = 0x001FFF; // (8191) Setup Failure - unknown reason

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\globals.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: globals.h
//
// Abstract:    stuff to include in all headers
//
// Author:      JoeA
//
// Notes:
//

#if !defined( NETFX_GLOBALS_H )
#define NETFX_GLOBALS_H

#include <list>
#include <windows.h>
#include <setupapi.h>
#include <assert.h>
#include <ocmanage.h>
#include <tchar.h>
#include "ocmanage.h"


#define countof(x) (sizeof(x) / sizeof(x[0]))
#define BLOCK
#define EMPTY_BUFFER  { L'\0' }

#define  g_chEndOfLine     L'\0'
#define  g_chSectionDelim  L','


BOOL IsAdmin(void);

#endif  //NETFX_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\inc\msiquery.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************\
*                                                                             *
* MsiQuery.h - Interface to running installer for custom actions and tools    *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* NOTES:  All buffers sizes are TCHAR count, null included only on input      *
*         Return argument pointers may be null if not interested in value     *
*         Returned handles of all types must be closed: MsiCloseHandle(h)     *
*         Functions with UINT return type return a system error code          *
*         Designated functions will set or clear the last error record,       *
*         which is then accessible with MsiGetLastErrorRecord. However,       *
*         the following argument errors do not register an error record:      *
*         ERROR_INVALID_HANDLE, ERROR_INVALID_PARAMETER, ERROR_MORE_DATA.     *
*                                                                             *
\*****************************************************************************/

#ifndef _MSIQUERY_H_
#define _MSIQUERY_H_
#include "msi.h"  // INSTALLSTATE

#define MSI_NULL_INTEGER 0x80000000  // integer value reserved for null

// MsiOpenDatabase persist predefine values, otherwise output database path is used
#define MSIDBOPEN_READONLY     (LPCTSTR)0  // database open read-only, no persistent changes
#define MSIDBOPEN_TRANSACT     (LPCTSTR)1  // database read/write in transaction mode
#define MSIDBOPEN_DIRECT       (LPCTSTR)2  // database direct read/write without transaction
#define MSIDBOPEN_CREATE       (LPCTSTR)3  // create new database, transact mode read/write
#define MSIDBOPEN_CREATEDIRECT (LPCTSTR)4  // create new database, direct mode read/write
#define MSIDBOPEN_PATCHFILE    32/sizeof(*MSIDBOPEN_READONLY) // add flag to indicate patch file

typedef enum tagMSIDBSTATE
{
	MSIDBSTATE_ERROR    =-1,  // invalid database handle
	MSIDBSTATE_READ     = 0,  // database open read-only, no persistent changes
	MSIDBSTATE_WRITE    = 1,  // database readable and updatable
} MSIDBSTATE;

typedef enum tagMSIMODIFY
{
	MSIMODIFY_SEEK             =-1,  // reposition to current record primary key
	MSIMODIFY_REFRESH          = 0,  // refetch current record data
	MSIMODIFY_INSERT           = 1,  // insert new record, fails if matching key exists
	MSIMODIFY_UPDATE           = 2,  // update existing non-key data of fetched record
	MSIMODIFY_ASSIGN           = 3,  // insert record, replacing any existing record
	MSIMODIFY_REPLACE          = 4,  // update record, delete old if primary key edit
	MSIMODIFY_MERGE            = 5,  // fails if record with duplicate key not identical
	MSIMODIFY_DELETE           = 6,  // remove row referenced by this record from table
	MSIMODIFY_INSERT_TEMPORARY = 7,  // insert a temporary record
	MSIMODIFY_VALIDATE         = 8,  // validate a fetched record
	MSIMODIFY_VALIDATE_NEW     = 9,  // validate a new record
	MSIMODIFY_VALIDATE_FIELD   = 10, // validate field(s) of an incomplete record
	MSIMODIFY_VALIDATE_DELETE  = 11, // validate before deleting record
} MSIMODIFY;

typedef enum tagMSICOLINFO
{
	MSICOLINFO_NAMES = 0,  // return column names
	MSICOLINFO_TYPES = 1,  // return column definitions, datatype code followed by width
} MSICOLINFO;

typedef enum tagMSICONDITION
{
	MSICONDITION_FALSE = 0,  // expression evaluates to False
	MSICONDITION_TRUE  = 1,  // expression evaluates to True
	MSICONDITION_NONE  = 2,  // no expression present
	MSICONDITION_ERROR = 3,  // syntax error in expression
} MSICONDITION;

typedef enum tagMSICOSTTREE
{
	MSICOSTTREE_SELFONLY = 0,
	MSICOSTTREE_CHILDREN = 1,
	MSICOSTTREE_PARENTS  = 2,
	MSICOSTTREE_RESERVED = 3,	// Reserved for future use
} MSICOSTTREE;

typedef enum tagMSIDBERROR
{
	MSIDBERROR_INVALIDARG        = -3, //  invalid argument
	MSIDBERROR_MOREDATA          = -2, //  buffer too small
	MSIDBERROR_FUNCTIONERROR     = -1, //  function error
	MSIDBERROR_NOERROR           = 0,  //  no error
	MSIDBERROR_DUPLICATEKEY      = 1,  //  new record duplicates primary keys of existing record in table
	MSIDBERROR_REQUIRED          = 2,  //  non-nullable column, no null values allowed
	MSIDBERROR_BADLINK           = 3,  //  corresponding record in foreign table not found
	MSIDBERROR_OVERFLOW          = 4,  //  data greater than maximum value allowed
	MSIDBERROR_UNDERFLOW         = 5,  //  data less than minimum value allowed
	MSIDBERROR_NOTINSET          = 6,  //  data not a member of the values permitted in the set
	MSIDBERROR_BADVERSION        = 7,  //  invalid version string
	MSIDBERROR_BADCASE           = 8,  //  invalid case, must be all upper-case or all lower-case
	MSIDBERROR_BADGUID           = 9,  //  invalid GUID
	MSIDBERROR_BADWILDCARD       = 10, //  invalid wildcardfilename or use of wildcards
	MSIDBERROR_BADIDENTIFIER     = 11, //  bad identifier
	MSIDBERROR_BADLANGUAGE       = 12, //  bad language Id(s)
	MSIDBERROR_BADFILENAME       = 13, //  bad filename
	MSIDBERROR_BADPATH           = 14, //  bad path
	MSIDBERROR_BADCONDITION      = 15, //  bad conditional statement
	MSIDBERROR_BADFORMATTED      = 16, //  bad format string
	MSIDBERROR_BADTEMPLATE       = 17, //  bad template string
	MSIDBERROR_BADDEFAULTDIR     = 18, //  bad string in DefaultDir column of Directory table
	MSIDBERROR_BADREGPATH        = 19, //  bad registry path string
	MSIDBERROR_BADCUSTOMSOURCE   = 20, //  bad string in CustomSource column of CustomAction table
	MSIDBERROR_BADPROPERTY       = 21, //  bad property string
	MSIDBERROR_MISSINGDATA       = 22, //  _Validation table missing reference to column
	MSIDBERROR_BADCATEGORY       = 23, //  Category column of _Validation table for column is invalid
	MSIDBERROR_BADKEYTABLE       = 24, //  table in KeyTable column of _Validation table could not be found/loaded
	MSIDBERROR_BADMAXMINVALUES   = 25, //  value in MaxValue column of _Validation table is less than value in MinValue column
	MSIDBERROR_BADCABINET        = 26, //  bad cabinet name
	MSIDBERROR_BADSHORTCUT       = 27, //  bad shortcut target
	MSIDBERROR_STRINGOVERFLOW    = 28, //  string overflow (greater than length allowed in column def)
	MSIDBERROR_BADLOCALIZEATTRIB = 29  //  invalid localization attribute (primary keys cannot be localized)

} MSIDBERROR;

typedef enum tagMSIRUNMODE
{
	MSIRUNMODE_ADMIN           =  0, // admin mode install, else product install
	MSIRUNMODE_ADVERTISE       =  1, // installing advertisements, else installing or updating product
	MSIRUNMODE_MAINTENANCE     =  2, // modifying an existing installation, else new installation
	MSIRUNMODE_ROLLBACKENABLED =  3, // rollback is enabled
	MSIRUNMODE_LOGENABLED      =  4, // log file active, enabled prior to install session
	MSIRUNMODE_OPERATIONS      =  5, // spooling execute operations, else in determination phase
	MSIRUNMODE_REBOOTATEND     =  6, // reboot needed after successful installation (settable)
	MSIRUNMODE_REBOOTNOW       =  7, // reboot needed to continue installation (settable)
	MSIRUNMODE_CABINET         =  8, // installing files from cabinets and files using Media table
	MSIRUNMODE_SOURCESHORTNAMES=  9, // source LongFileNames suppressed via PID_MSISOURCE summary property
	MSIRUNMODE_TARGETSHORTNAMES= 10, // target LongFileNames suppressed via SHORTFILENAMES property
	MSIRUNMODE_RESERVED11      = 11, // future use
	MSIRUNMODE_WINDOWS9X       = 12, // operating systems is Windows9?, else Windows NT
	MSIRUNMODE_ZAWENABLED      = 13, // operating system supports demand installation
	MSIRUNMODE_RESERVED14      = 14, // future use
	MSIRUNMODE_RESERVED15      = 15, // future use
	MSIRUNMODE_SCHEDULED       = 16, // custom action call from install script execution
	MSIRUNMODE_ROLLBACK        = 17, // custom action call from rollback execution script
	MSIRUNMODE_COMMIT          = 18, // custom action call from commit execution script
} MSIRUNMODE;

#define INSTALLMESSAGE_TYPEMASK = 0xFF000000L  // mask for type code

// Note: INSTALLMESSAGE_ERROR, INSTALLMESSAGE_WARNING, INSTALLMESSAGE_USER are to or'd
// with a message box style to indicate the buttons to display and return:
// MB_OK,MB_OKCANCEL,MB_ABORTRETRYIGNORE,MB_YESNOCANCEL,MB_YESNO,MB_RETRYCANCEL
// the default button (MB_DEFBUTTON1 is normal default):
// MB_DEFBUTTON1, MB_DEFBUTTON2, MB_DEFBUTTON3
// and optionally an icon style:
// MB_ICONERROR, MB_ICONQUESTION, MB_ICONWARNING, MB_ICONINFORMATION

typedef enum tagMSITRANSFORM_ERROR
{
	MSITRANSFORM_ERROR_ADDEXISTINGROW   =  0x00000001,
	MSITRANSFORM_ERROR_DELMISSINGROW    =  0x00000002,
	MSITRANSFORM_ERROR_ADDEXISTINGTABLE =  0x00000004,
	MSITRANSFORM_ERROR_DELMISSINGTABLE  =  0x00000008,
	MSITRANSFORM_ERROR_UPDATEMISSINGROW =  0x00000010,
	MSITRANSFORM_ERROR_CHANGECODEPAGE   =  0x00000020,
	MSITRANSFORM_ERROR_VIEWTRANSFORM    =  0x00000100,
} MSITRANSFORM_ERROR;

typedef enum tagMSITRANSFORM_VALIDATE
{
	MSITRANSFORM_VALIDATE_LANGUAGE                   = 0x00000001,
	MSITRANSFORM_VALIDATE_PRODUCT                    = 0x00000002,
	MSITRANSFORM_VALIDATE_PLATFORM                   = 0x00000004,
	MSITRANSFORM_VALIDATE_MAJORVERSION               = 0x00000008,
	MSITRANSFORM_VALIDATE_MINORVERSION               = 0x00000010,
	MSITRANSFORM_VALIDATE_UPDATEVERSION              = 0x00000020,
	MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION         = 0x00000040,
	MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION    = 0x00000080,
	MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION        = 0x00000100,
	MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION = 0x00000200,
	MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION      = 0x00000400,
	MSITRANSFORM_VALIDATE_UPGRADECODE                = 0x00000800,
} MSITRANSFORM_VALIDATE;

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------
// Installer database access functions
// --------------------------------------------------------------------------

// Prepare a database query, creating a view object
// Returns ERROR_SUCCESS if successful, and the view handle is returned,
// else ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_BAD_QUERY_SYNTAX, ERROR_GEN_FAILURE
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseOpenViewA(MSIHANDLE hDatabase,
	LPCSTR     szQuery,            // SQL query to be prepared
	MSIHANDLE*  phView);            // returned view if TRUE
UINT WINAPI MsiDatabaseOpenViewW(MSIHANDLE hDatabase,
	LPCWSTR     szQuery,            // SQL query to be prepared
	MSIHANDLE*  phView);            // returned view if TRUE
#ifdef UNICODE
#define MsiDatabaseOpenView  MsiDatabaseOpenViewW
#else
#define MsiDatabaseOpenView  MsiDatabaseOpenViewA
#endif // !UNICODE

// Returns the MSIDBERROR enum and name of the column corresponding to the error
// Similar to a GetLastError function, but for the view. NOT the same as MsiGetLastErrorRecord
// Returns errors of MsiViewModify.

MSIDBERROR WINAPI MsiViewGetErrorA(MSIHANDLE hView,
	LPSTR szColumnNameBuffer,  // buffer to hold column name 
	DWORD* pcchBuf);			 // size of buffer
MSIDBERROR WINAPI MsiViewGetErrorW(MSIHANDLE hView,
	LPWSTR szColumnNameBuffer,  // buffer to hold column name 
	DWORD* pcchBuf);			 // size of buffer
#ifdef UNICODE
#define MsiViewGetError  MsiViewGetErrorW
#else
#define MsiViewGetError  MsiViewGetErrorA
#endif // !UNICODE

// Exectute the view query, supplying parameters as required
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_GEN_FAILURE
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiViewExecute(MSIHANDLE hView,
	MSIHANDLE hRecord);             // optional parameter record, or 0 if none

// Fetch the next sequential record from the view
// Result is ERROR_SUCCESS if a row is found, and its handle is returned
// else ERROR_NO_MORE_ITEMS if no records remain, and a null handle is returned
// else result is error: ERROR_INVALID_HANDLE_STATE, ERROR_INVALID_HANDLE, ERROR_GEN_FAILURE

UINT WINAPI MsiViewFetch(MSIHANDLE hView,
	MSIHANDLE  *phRecord);          // returned data record if fetch succeeds

// Modify a database record, parameters must match types in query columns
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE, ERROR_GEN_FAILURE, ERROR_ACCESS_DENIED
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiViewModify(MSIHANDLE hView,
	MSIMODIFY eModifyMode,         // modify action to perform
	MSIHANDLE hRecord);            // record obtained from fetch, or new record

// Return the column names or specifications for the current view
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_PARAMETER, or ERROR_INVALID_HANDLE_STATE

UINT WINAPI MsiViewGetColumnInfo(MSIHANDLE hView,
	MSICOLINFO eColumnInfo,        // retrieve columns names or definitions
	MSIHANDLE *phRecord);          // returned data record containing all names or definitions

// Release the result set for an executed view, to allow re-execution
// Only needs to be called if not all records have been fetched
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_HANDLE_STATE

UINT WINAPI MsiViewClose(MSIHANDLE hView);

// Return a record containing the names of all primary key columns for a given table
// Returns an MSIHANDLE for a record containing the name of each column.
// The field count of the record corresponds to the number of primary key columns.
// Field [0] of the record contains the table name.
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_TABLE

UINT WINAPI MsiDatabaseGetPrimaryKeysA(MSIHANDLE hDatabase,
	LPCSTR    szTableName,       // the name of a specific table <case-sensitive>
	MSIHANDLE  *phRecord);         // returned record if ERROR_SUCCESS
UINT WINAPI MsiDatabaseGetPrimaryKeysW(MSIHANDLE hDatabase,
	LPCWSTR    szTableName,       // the name of a specific table <case-sensitive>
	MSIHANDLE  *phRecord);         // returned record if ERROR_SUCCESS
#ifdef UNICODE
#define MsiDatabaseGetPrimaryKeys  MsiDatabaseGetPrimaryKeysW
#else
#define MsiDatabaseGetPrimaryKeys  MsiDatabaseGetPrimaryKeysA
#endif // !UNICODE

// Return an enum defining the state of the table (temporary, unknown, or persistent).
// Returns MSICONDITION_ERROR, MSICONDITION_FALSE, MSICONDITION_TRUE, MSICONDITION_NONE

MSICONDITION WINAPI MsiDatabaseIsTablePersistentA(MSIHANDLE hDatabase,
	LPCSTR szTableName);         // the name of a specific table
MSICONDITION WINAPI MsiDatabaseIsTablePersistentW(MSIHANDLE hDatabase,
	LPCWSTR szTableName);         // the name of a specific table
#ifdef UNICODE
#define MsiDatabaseIsTablePersistent  MsiDatabaseIsTablePersistentW
#else
#define MsiDatabaseIsTablePersistent  MsiDatabaseIsTablePersistentA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Summary information stream management functions
// --------------------------------------------------------------------------

// Integer Property IDs:    1, 14, 15, 16, 19 
// DateTime Property IDs:   10, 11, 12, 13
// Text Property IDs:       2, 3, 4, 5, 6, 7, 8, 9, 18
// Unsupported Propery IDs: 0 (PID_DICTIONARY), 17 (PID_THUMBNAIL)

// Obtain a handle for the _SummaryInformation stream for an MSI database     
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetSummaryInformationA(MSIHANDLE hDatabase, // 0 if not open
	LPCSTR  szDatabasePath,  // path to database, 0 if database handle supplied
	UINT     uiUpdateCount,    // maximium number of updated values, 0 to open read-only
	MSIHANDLE *phSummaryInfo); // returned handle to summary information data
UINT WINAPI MsiGetSummaryInformationW(MSIHANDLE hDatabase, // 0 if not open
	LPCWSTR  szDatabasePath,  // path to database, 0 if database handle supplied
	UINT     uiUpdateCount,    // maximium number of updated values, 0 to open read-only
	MSIHANDLE *phSummaryInfo); // returned handle to summary information data
#ifdef UNICODE
#define MsiGetSummaryInformation  MsiGetSummaryInformationW
#else
#define MsiGetSummaryInformation  MsiGetSummaryInformationA
#endif // !UNICODE

// Obtain the number of existing properties in the SummaryInformation stream

UINT WINAPI MsiSummaryInfoGetPropertyCount(MSIHANDLE hSummaryInfo,
	UINT *puiPropertyCount); // pointer to location to return total property count

// Set a single summary information property
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_UNKNOWN_PROPERTY

UINT WINAPI MsiSummaryInfoSetPropertyA(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     uiDataType,     // VT_I4, VT_LPSTR, VT_FILETIME, or VT_EMPTY
	INT      iValue,         // integer value, used only if integer property
	FILETIME *pftValue,      // pointer to filetime value, used only if datetime property
	LPCSTR szValue);       // text value, used only if string property
UINT WINAPI MsiSummaryInfoSetPropertyW(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     uiDataType,     // VT_I4, VT_LPSTR, VT_FILETIME, or VT_EMPTY
	INT      iValue,         // integer value, used only if integer property
	FILETIME *pftValue,      // pointer to filetime value, used only if datetime property
	LPCWSTR szValue);       // text value, used only if string property
#ifdef UNICODE
#define MsiSummaryInfoSetProperty  MsiSummaryInfoSetPropertyW
#else
#define MsiSummaryInfoSetProperty  MsiSummaryInfoSetPropertyA
#endif // !UNICODE

// Get a single property from the summary information
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_UNKNOWN_PROPERTY

UINT WINAPI MsiSummaryInfoGetPropertyA(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     *puiDataType,   // returned type: VT_I4, VT_LPSTR, VT_FILETIME, VT_EMPTY
	INT      *piValue,       // returned integer property data
	FILETIME *pftValue,      // returned datetime property data
	LPSTR  szValueBuf,     // buffer to return string property data
	DWORD    *pcchValueBuf); // in/out buffer character count
UINT WINAPI MsiSummaryInfoGetPropertyW(MSIHANDLE hSummaryInfo,
	UINT     uiProperty,     // property ID, one of allowed values for summary information
	UINT     *puiDataType,   // returned type: VT_I4, VT_LPSTR, VT_FILETIME, VT_EMPTY
	INT      *piValue,       // returned integer property data
	FILETIME *pftValue,      // returned datetime property data
	LPWSTR  szValueBuf,     // buffer to return string property data
	DWORD    *pcchValueBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiSummaryInfoGetProperty  MsiSummaryInfoGetPropertyW
#else
#define MsiSummaryInfoGetProperty  MsiSummaryInfoGetPropertyA
#endif // !UNICODE

// Write back changed information to summary information stream

UINT WINAPI MsiSummaryInfoPersist(MSIHANDLE hSummaryInfo);

// --------------------------------------------------------------------------
// Installer database management functions - not used by custom actions
// --------------------------------------------------------------------------

// Open an installer database, specifying the persistance mode, which is a pointer.
// Predefined persist values are reserved pointer values, requiring pointer arithmetic.
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiOpenDatabaseA(
	LPCSTR      szDatabasePath,  // path to database, 0 to create temporary database
	LPCSTR      szPersist,       // output database path or one of predefined values
	MSIHANDLE*   phDatabase);     // location to return database handle
UINT WINAPI MsiOpenDatabaseW(
	LPCWSTR      szDatabasePath,  // path to database, 0 to create temporary database
	LPCWSTR      szPersist,       // output database path or one of predefined values
	MSIHANDLE*   phDatabase);     // location to return database handle
#ifdef UNICODE
#define MsiOpenDatabase  MsiOpenDatabaseW
#else
#define MsiOpenDatabase  MsiOpenDatabaseA
#endif // !UNICODE

// Import an MSI text archive table into an open database
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseImportA(MSIHANDLE hDatabase,
	LPCSTR   szFolderPath,     // folder containing archive files
	LPCSTR   szFileName);      // table archive file to be imported
UINT WINAPI MsiDatabaseImportW(MSIHANDLE hDatabase,
	LPCWSTR   szFolderPath,     // folder containing archive files
	LPCWSTR   szFileName);      // table archive file to be imported
#ifdef UNICODE
#define MsiDatabaseImport  MsiDatabaseImportW
#else
#define MsiDatabaseImport  MsiDatabaseImportA
#endif // !UNICODE

// Export an MSI table from an open database to a text archive file
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseExportA(MSIHANDLE hDatabase,
	LPCSTR   szTableName,      // name of table in database <case-sensitive>
	LPCSTR   szFolderPath,     // folder containing archive files
	LPCSTR   szFileName);      // name of exported table archive file
UINT WINAPI MsiDatabaseExportW(MSIHANDLE hDatabase,
	LPCWSTR   szTableName,      // name of table in database <case-sensitive>
	LPCWSTR   szFolderPath,     // folder containing archive files
	LPCWSTR   szFileName);      // name of exported table archive file
#ifdef UNICODE
#define MsiDatabaseExport  MsiDatabaseExportW
#else
#define MsiDatabaseExport  MsiDatabaseExportA
#endif // !UNICODE

// Merge two database together, allowing duplicate rows
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseMergeA(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseMerge,    // database to be merged into hDatabase
	LPCSTR   szTableName);      // name of non-persistent table to receive errors
UINT WINAPI MsiDatabaseMergeW(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseMerge,    // database to be merged into hDatabase
	LPCWSTR   szTableName);      // name of non-persistent table to receive errors
#ifdef UNICODE
#define MsiDatabaseMerge  MsiDatabaseMergeW
#else
#define MsiDatabaseMerge  MsiDatabaseMergeA
#endif // !UNICODE

// Generate a transform file of differences between two databases
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseGenerateTransformA(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCSTR   szTransformFile,   // name of generated transform file
	int       iReserved1,         // reserved argument, not used
	int       iReserved2);        // reserved argument, not used
UINT WINAPI MsiDatabaseGenerateTransformW(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCWSTR   szTransformFile,   // name of generated transform file
	int       iReserved1,         // reserved argument, not used
	int       iReserved2);        // reserved argument, not used
#ifdef UNICODE
#define MsiDatabaseGenerateTransform  MsiDatabaseGenerateTransformW
#else
#define MsiDatabaseGenerateTransform  MsiDatabaseGenerateTransformA
#endif // !UNICODE

// Apply a transform file containing database difference
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseApplyTransformA(MSIHANDLE hDatabase,
	LPCSTR   szTransformFile,    // name of transform file
	int       iErrorConditions);   // errors to suppress, bits from MSITRANSFORM_ERROR
UINT WINAPI MsiDatabaseApplyTransformW(MSIHANDLE hDatabase,
	LPCWSTR   szTransformFile,    // name of transform file
	int       iErrorConditions);   // errors to suppress, bits from MSITRANSFORM_ERROR
#ifdef UNICODE
#define MsiDatabaseApplyTransform  MsiDatabaseApplyTransformW
#else
#define MsiDatabaseApplyTransform  MsiDatabaseApplyTransformA
#endif // !UNICODE

// Create summary information of existing transform to include validation and error conditions
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiCreateTransformSummaryInfoA(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCSTR   szTransformFile,    // name of generated transform file
	int       iErrorConditions,    // errors to suppress when applied, from MSITRANSFORM_ERROR
	int       iValidation);        // properties validated when applied, MSITRANSFORM_VALIDATE
UINT WINAPI MsiCreateTransformSummaryInfoW(MSIHANDLE hDatabase,
	MSIHANDLE hDatabaseReference, // base database to reference changes
	LPCWSTR   szTransformFile,    // name of generated transform file
	int       iErrorConditions,    // errors to suppress when applied, from MSITRANSFORM_ERROR
	int       iValidation);        // properties validated when applied, MSITRANSFORM_VALIDATE
#ifdef UNICODE
#define MsiCreateTransformSummaryInfo  MsiCreateTransformSummaryInfoW
#else
#define MsiCreateTransformSummaryInfo  MsiCreateTransformSummaryInfoA
#endif // !UNICODE

// Write out all persistent table data, ignored if database opened read-only
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiDatabaseCommit(MSIHANDLE hDatabase);

// Return the update state of a database

MSIDBSTATE WINAPI MsiGetDatabaseState(MSIHANDLE hDatabase);

// --------------------------------------------------------------------------
// Record object functions
// --------------------------------------------------------------------------

// Create a new record object with the requested number of fields
// Field 0, not included in count, is used for format strings and op codes
// All fields are initialized to null
// Returns a handle to the created record, or 0 if memory could not be allocated

MSIHANDLE WINAPI MsiCreateRecord(
	UINT cParams);                   // the number of data fields

// Report whether a record field is NULL
// Returns TRUE if the field is null or does not exist
// Returns FALSE if the field contains data, or the handle is invalid

BOOL WINAPI MsiRecordIsNull(MSIHANDLE hRecord,
	UINT iField);

// Return the length of a record field
// Returns 0 if field is NULL or non-existent
// Returns sizeof(int) if integer data
// Returns character count if string data (not counting null terminator)
// Returns bytes count if stream data

UINT WINAPI MsiRecordDataSize(MSIHANDLE hRecord,
	UINT iField);

// Set a record field to an integer value
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_FIELD

UINT WINAPI MsiRecordSetInteger(MSIHANDLE hRecord,
	UINT iField,
	int iValue);

// Copy a string into the designated field
// A null string pointer and an empty string both set the field to null
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_INVALID_FIELD

UINT WINAPI MsiRecordSetStringA(MSIHANDLE hRecord,
	UINT iField,
	LPCSTR      szValue);
UINT WINAPI MsiRecordSetStringW(MSIHANDLE hRecord,
	UINT iField,
	LPCWSTR      szValue);
#ifdef UNICODE
#define MsiRecordSetString  MsiRecordSetStringW
#else
#define MsiRecordSetString  MsiRecordSetStringA
#endif // !UNICODE

// Return the integer value from a record field
// Returns the value MSI_NULL_INTEGER if the field is null
// or if the field is a string that cannot be converted to an integer

int WINAPI MsiRecordGetInteger(MSIHANDLE hRecord,
	UINT iField);

// Return the string value of a record field
// Integer fields will be converted to a string
// Null and non-existent fields will report a value of 0
// Fields containing stream data will return ERROR_INVALID_DATATYPE
// Returns ERROR_SUCCESS, ERROR_MORE_DATA, 
//         ERROR_INVALID_HANDLE, ERROR_INVALID_FIELD, ERROR_BAD_ARGUMENTS

UINT WINAPI MsiRecordGetStringA(MSIHANDLE hRecord,
	UINT iField,
	LPSTR  szValueBuf,       // buffer for returned value
	DWORD   *pcchValueBuf);   // in/out buffer character count
UINT WINAPI MsiRecordGetStringW(MSIHANDLE hRecord,
	UINT iField,
	LPWSTR  szValueBuf,       // buffer for returned value
	DWORD   *pcchValueBuf);   // in/out buffer character count
#ifdef UNICODE
#define MsiRecordGetString  MsiRecordGetStringW
#else
#define MsiRecordGetString  MsiRecordGetStringA
#endif // !UNICODE

// Returns the number of fields allocated in the record
// Does not count field 0, used for formatting and op codes

UINT WINAPI MsiRecordGetFieldCount(MSIHANDLE hRecord);

// Set a record stream field from a file
// The contents of the specified file will be read into a stream object
// The stream will be persisted if the record is inserted into the database
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiRecordSetStreamA(MSIHANDLE hRecord,
	UINT iField,
	LPCSTR      szFilePath);   // path to file containing stream data
UINT WINAPI MsiRecordSetStreamW(MSIHANDLE hRecord,
	UINT iField,
	LPCWSTR      szFilePath);   // path to file containing stream data
#ifdef UNICODE
#define MsiRecordSetStream  MsiRecordSetStreamW
#else
#define MsiRecordSetStream  MsiRecordSetStreamA
#endif // !UNICODE

// Read bytes from a record stream field into a buffer
// Must set the in/out argument to the requested byte count to read
// The number of bytes transferred is returned through the argument
// If no more bytes are available, ERROR_SUCCESS is still returned

UINT WINAPI MsiRecordReadStream(MSIHANDLE hRecord,
	UINT iField,
	char    *szDataBuf,     // buffer to receive bytes from stream
	DWORD   *pcbDataBuf);   // in/out buffer byte count

// Clears all data fields in a record to NULL

UINT WINAPI MsiRecordClearData(MSIHANDLE hRecord);

// --------------------------------------------------------------------------
// Functions to access a running installation, called from custom actions
// The install handle is the single argument passed to custom actions
// --------------------------------------------------------------------------

// Return a handle to the database currently in use by this installer instance

MSIHANDLE WINAPI MsiGetActiveDatabase(MSIHANDLE hInstall); // returns handle to database, 0 if none active

// Set the value for an installer property
// If the property is not defined, it will be created
// If the value is null or an empty string, the property will be removed
// Returns ERROR_SUCCESS, ERROR_INVALID_HANDLE, ERROR_BAD_ARGUMENTS

UINT WINAPI MsiSetPropertyA(MSIHANDLE hInstall,
	LPCSTR   szName,       // property identifier, case-sensitive
	LPCSTR   szValue);     // property value, null to undefine property
UINT WINAPI MsiSetPropertyW(MSIHANDLE hInstall,
	LPCWSTR   szName,       // property identifier, case-sensitive
	LPCWSTR   szValue);     // property value, null to undefine property
#ifdef UNICODE
#define MsiSetProperty  MsiSetPropertyW
#else
#define MsiSetProperty  MsiSetPropertyA
#endif // !UNICODE

// Get the value for an installer property
// If the property is not defined, it is equivalent to a 0-length value, not error
// Returns ERROR_SUCCESS, ERROR_MORE_DATA, ERROR_INVALID_HANDLE, ERROR_BAD_ARGUMENTS

UINT  WINAPI MsiGetPropertyA(MSIHANDLE hInstall,
	LPCSTR szName,           // property identifier, case-sensitive
	LPSTR  szValueBuf,       // buffer for returned property value
	DWORD   *pcchValueBuf);   // in/out buffer character count
UINT  WINAPI MsiGetPropertyW(MSIHANDLE hInstall,
	LPCWSTR szName,           // property identifier, case-sensitive
	LPWSTR  szValueBuf,       // buffer for returned property value
	DWORD   *pcchValueBuf);   // in/out buffer character count
#ifdef UNICODE
#define MsiGetProperty  MsiGetPropertyW
#else
#define MsiGetProperty  MsiGetPropertyA
#endif // !UNICODE

// Return the numeric language for the currently running install
// Returns 0 if an install not running

LANGID WINAPI MsiGetLanguage(MSIHANDLE hInstall);

// Return one of the boolean internal installer states
// Returns FALSE if the handle is not active or if the mode is not implemented

BOOL WINAPI MsiGetMode(MSIHANDLE hInstall,
	MSIRUNMODE eRunMode);   // particular mode for which the state is returned

// Set an internal install session boolean mode - Note: most modes are read-only
// Returns ERROR_SUCCESS if the mode can be set to the desired state
// Returns ERROR_ACCESS_DENIED if the mode is not settable
// Returns ERROR_INVALID_HANDLE if the handle is not an active install session

UINT WINAPI MsiSetMode(MSIHANDLE hInstall,
	MSIRUNMODE eRunMode,    // particular mode for which state is to be set
	BOOL fState);           // new state for bit flag

// Format record data using a format string containing field markers and/or properties
// Record field 0 must contain the format string
// Other fields must contain data that may be referenced by the format string.

UINT WINAPI MsiFormatRecordA(MSIHANDLE hInstall, // non-zero for property expansion
	MSIHANDLE hRecord,        // handle to record, field 0 contains format string
	LPSTR    szResultBuf,    // buffer to return formatted string
	DWORD    *pcchResultBuf); // in/out buffer character count
UINT WINAPI MsiFormatRecordW(MSIHANDLE hInstall, // non-zero for property expansion
	MSIHANDLE hRecord,        // handle to record, field 0 contains format string
	LPWSTR    szResultBuf,    // buffer to return formatted string
	DWORD    *pcchResultBuf); // in/out buffer character count
#ifdef UNICODE
#define MsiFormatRecord  MsiFormatRecordW
#else
#define MsiFormatRecord  MsiFormatRecordA
#endif // !UNICODE

// Execute another action, either built-in, custom, or UI wizard
// Returns ERROR_FUNCTION_NOT_CALLED if action not found
// Returns ERROR_SUCCESS if action completed succesfully
// Returns ERROR_INSTALL_USEREXIT if user cancelled during action
// Returns ERROR_INSTALL_FAILURE if action failed
// Returns ERROR_INSTALL_SUSPEND if user suspended installation
// Returns ERROR_MORE_DATA if action wishes to skip remaining actions
// Returns ERROR_INVALID_HANDLE_STATE if install session not active
// Returns ERROR_INVALID_DATA if failure calling custom action
// Returns ERROR_INVALID_HANDLE or ERROR_INVALID_PARAMETER if arguments invalid

UINT WINAPI MsiDoActionA(MSIHANDLE hInstall,
	LPCSTR szAction);     // name of action to call, case-sensitive
UINT WINAPI MsiDoActionW(MSIHANDLE hInstall,
	LPCWSTR szAction);     // name of action to call, case-sensitive
#ifdef UNICODE
#define MsiDoAction  MsiDoActionW
#else
#define MsiDoAction  MsiDoActionA
#endif // !UNICODE

// Execute another action sequence, as descibed in the specified table
// Returns the same error codes as MsiDoAction

UINT WINAPI MsiSequenceA(MSIHANDLE hInstall,
	LPCSTR szTable,       // name of table containing action sequence
	INT iSequenceMode);     // for future use, must be 0 in MSI 1.0
UINT WINAPI MsiSequenceW(MSIHANDLE hInstall,
	LPCWSTR szTable,       // name of table containing action sequence
	INT iSequenceMode);     // for future use, must be 0 in MSI 1.0
#ifdef UNICODE
#define MsiSequence  MsiSequenceW
#else
#define MsiSequence  MsiSequenceA
#endif // !UNICODE

// Send an error record to the installer for processing.
// If field 0 (template) is not set, field 1 must be set to the error code,
//   corresponding the the error message in the Error database table,
//   and the message will be formatted using the template from the Error table
//   before passing it to the UI handler for display.
// Returns Win32 button codes: IDOK IDCANCEL IDABORT IDRETRY IDIGNORE IDYES IDNO
//   or 0 if no action taken, or -1 if invalid argument or handle

int WINAPI MsiProcessMessage(MSIHANDLE hInstall,
	INSTALLMESSAGE eMessageType, // type of message
	MSIHANDLE hRecord);          // record containing message format and data

// Evaluate a conditional expression containing property names and values

MSICONDITION WINAPI MsiEvaluateConditionA(MSIHANDLE hInstall,
	LPCSTR  szCondition);
MSICONDITION WINAPI MsiEvaluateConditionW(MSIHANDLE hInstall,
	LPCWSTR  szCondition);
#ifdef UNICODE
#define MsiEvaluateCondition  MsiEvaluateConditionW
#else
#define MsiEvaluateCondition  MsiEvaluateConditionA
#endif // !UNICODE

// Get the installed state and requested action state of a feature
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetFeatureStateA(MSIHANDLE hInstall,
	LPCSTR     szFeature,     // feature name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
UINT WINAPI MsiGetFeatureStateW(MSIHANDLE hInstall,
	LPCWSTR     szFeature,     // feature name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
#ifdef UNICODE
#define MsiGetFeatureState  MsiGetFeatureStateW
#else
#define MsiGetFeatureState  MsiGetFeatureStateA
#endif // !UNICODE

// Request a feature to be set to a specified state
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetFeatureStateA(MSIHANDLE hInstall,
	LPCSTR     szFeature,     // feature name within product
	INSTALLSTATE iState);       // requested state for feature
UINT WINAPI MsiSetFeatureStateW(MSIHANDLE hInstall,
	LPCWSTR     szFeature,     // feature name within product
	INSTALLSTATE iState);       // requested state for feature
#ifdef UNICODE
#define MsiSetFeatureState  MsiSetFeatureStateW
#else
#define MsiSetFeatureState  MsiSetFeatureStateA
#endif // !UNICODE

#if (_WIN32_MSI >=  110)

// Set the attribute bits of a specified feature at runtime.
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetFeatureAttributesA(MSIHANDLE hInstall,
	LPCSTR     szFeature,     // feature name within product
	DWORD dwAttributes);        // attributes bits to set for this feature
UINT WINAPI MsiSetFeatureAttributesW(MSIHANDLE hInstall,
	LPCWSTR     szFeature,     // feature name within product
	DWORD dwAttributes);        // attributes bits to set for this feature
#ifdef UNICODE
#define MsiSetFeatureAttributes  MsiSetFeatureAttributesW
#else
#define MsiSetFeatureAttributes  MsiSetFeatureAttributesA
#endif // !UNICODE

#endif //(_WIN32_MSI >=  110)

// Get the installed state and requested action state of a component
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetComponentStateA(MSIHANDLE hInstall,
	LPCSTR     szComponent,   // component name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
UINT WINAPI MsiGetComponentStateW(MSIHANDLE hInstall,
	LPCWSTR     szComponent,   // component name within product
	INSTALLSTATE *piInstalled,  // returned current install state
	INSTALLSTATE *piAction);    // action taken during install session
#ifdef UNICODE
#define MsiGetComponentState  MsiGetComponentStateW
#else
#define MsiGetComponentState  MsiGetComponentStateA
#endif // !UNICODE

// Request a component to be set to a specified state
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetComponentStateA(MSIHANDLE hInstall,
	LPCSTR     szComponent,   // component name within product
	INSTALLSTATE iState);       // requested state for component
UINT WINAPI MsiSetComponentStateW(MSIHANDLE hInstall,
	LPCWSTR     szComponent,   // component name within product
	INSTALLSTATE iState);       // requested state for component
#ifdef UNICODE
#define MsiSetComponentState  MsiSetComponentStateW
#else
#define MsiSetComponentState  MsiSetComponentStateA
#endif // !UNICODE

// Return the disk cost for a feature and related features
// Can specify either current feature state or proposed state
// Can specify extent of related features to cost
// Note that adding costs for several features may produce an
// excessively large cost due to shared components and parents.
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT  WINAPI MsiGetFeatureCostA(MSIHANDLE hInstall,
	LPCSTR      szFeature,      // name of feature
	MSICOSTTREE  iCostTree,     // portion of tree to cost
	INSTALLSTATE iState,        // requested state, or INSTALLSTATE_UNKNOWN
	INT          *piCost);      // returned cost, in units of 512 bytes
UINT  WINAPI MsiGetFeatureCostW(MSIHANDLE hInstall,
	LPCWSTR      szFeature,      // name of feature
	MSICOSTTREE  iCostTree,     // portion of tree to cost
	INSTALLSTATE iState,        // requested state, or INSTALLSTATE_UNKNOWN
	INT          *piCost);      // returned cost, in units of 512 bytes
#ifdef UNICODE
#define MsiGetFeatureCost  MsiGetFeatureCostW
#else
#define MsiGetFeatureCost  MsiGetFeatureCostA
#endif // !UNICODE

// Set the install level for a full product installation (not a feature request)
// Setting the value to 0 initialized components and features to the default level
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT  WINAPI MsiSetInstallLevel(MSIHANDLE hInstall,
	int iInstallLevel);

// Get the valid install states for a feature, represented by bit flags
// For each valid install state, a bit is set of value: (1 << INSTALLSTATE)
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT  WINAPI MsiGetFeatureValidStatesA(MSIHANDLE hInstall,
	LPCSTR szFeature,
	DWORD  *dwInstallStates);
UINT  WINAPI MsiGetFeatureValidStatesW(MSIHANDLE hInstall,
	LPCWSTR szFeature,
	DWORD  *dwInstallStates);
#ifdef UNICODE
#define MsiGetFeatureValidStates  MsiGetFeatureValidStatesW
#else
#define MsiGetFeatureValidStates  MsiGetFeatureValidStatesA
#endif // !UNICODE

// Return the full source path for a folder in the Directory table
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetSourcePathA(MSIHANDLE hInstall,
	LPCSTR     szFolder,       // folder identifier, primary key into Directory table
	LPSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
UINT WINAPI MsiGetSourcePathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPWSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetSourcePath  MsiGetSourcePathW
#else
#define MsiGetSourcePath  MsiGetSourcePathA
#endif // !UNICODE

// Return the full target path for a folder in the Directory table
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiGetTargetPathA(MSIHANDLE hInstall,
	LPCSTR     szFolder,       // folder identifier, primary key into Directory table
	LPSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
UINT WINAPI MsiGetTargetPathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPWSTR      szPathBuf,      // buffer to return full path
	DWORD       *pcchPathBuf);  // in/out buffer character count
#ifdef UNICODE
#define MsiGetTargetPath  MsiGetTargetPathW
#else
#define MsiGetTargetPath  MsiGetTargetPathA
#endif // !UNICODE

// Set the full target path for a folder in the Directory table
// Execution of this function sets the error record, accessible via MsiGetLastErrorRecord

UINT WINAPI MsiSetTargetPathA(MSIHANDLE hInstall,
	LPCSTR     szFolder,       // folder identifier, primary key into Directory table
	LPCSTR     szFolderPath);  // full path for folder, ending in directory separator
UINT WINAPI MsiSetTargetPathW(MSIHANDLE hInstall,
	LPCWSTR     szFolder,       // folder identifier, primary key into Directory table
	LPCWSTR     szFolderPath);  // full path for folder, ending in directory separator
#ifdef UNICODE
#define MsiSetTargetPath  MsiSetTargetPathW
#else
#define MsiSetTargetPath  MsiSetTargetPathA
#endif // !UNICODE

// Check to see if sufficent disk space is present for the current installation
// Returns ERROR_SUCCESS, ERROR_DISK_FULL, ERROR_INVALID_HANDLE_STATE, or ERROR_INVALID_HANDLE

UINT WINAPI MsiVerifyDiskSpace(MSIHANDLE hInstall);

// --------------------------------------------------------------------------
// Functions for rendering UI dialogs from the database representations.
// Purpose is for product development, not for use during installation.
// --------------------------------------------------------------------------

// Enable UI in preview mode to facilitate authoring of UI dialogs.
// The preview mode will end when the handle is closed.

UINT WINAPI MsiEnableUIPreview(MSIHANDLE hDatabase,
	MSIHANDLE* phPreview);       // returned handle for UI preview capability

// Display any UI dialog as modeless and inactive.
// Supplying a null name will remove any current dialog.

UINT WINAPI MsiPreviewDialogA(MSIHANDLE hPreview,
	LPCSTR szDialogName);      // dialog to display, Dialog table key
UINT WINAPI MsiPreviewDialogW(MSIHANDLE hPreview,
	LPCWSTR szDialogName);      // dialog to display, Dialog table key
#ifdef UNICODE
#define MsiPreviewDialog  MsiPreviewDialogW
#else
#define MsiPreviewDialog  MsiPreviewDialogA
#endif // !UNICODE

// Display a billboard within a host control in the displayed dialog.
// Supplying a null billboard name will remove any billboard displayed.

UINT WINAPI MsiPreviewBillboardA(MSIHANDLE hPreview,
	LPCSTR szControlName,      // name of control that accepts billboards
	LPCSTR szBillboard);       // name of billboard to display
UINT WINAPI MsiPreviewBillboardW(MSIHANDLE hPreview,
	LPCWSTR szControlName,      // name of control that accepts billboards
	LPCWSTR szBillboard);       // name of billboard to display
#ifdef UNICODE
#define MsiPreviewBillboard  MsiPreviewBillboardW
#else
#define MsiPreviewBillboard  MsiPreviewBillboardA
#endif // !UNICODE

// --------------------------------------------------------------------------
// Error handling not associated with any particular object
// --------------------------------------------------------------------------

// Return a record handle to the last function that generated an error record
// Only specified functions will set the error record, or clear it if success
// Field 1 of the record will contain the internal MSI error code
// Other fields will contain data specific to the particular error
// The error record is released internally after this function is executed

MSIHANDLE WINAPI MsiGetLastErrorRecord();  // returns 0 if no cached record

#ifdef __cplusplus
}
#endif

#endif // _MSIQUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\infhelpers.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: infhelpers.cpp
//
// Abstract:
//    class definitions for inf setup helper objects
//
// Author: JoeA
//
// Notes:
//

#include "infhelpers.h"



//////////////////////////////////////////////////////////////////////////////
// CUrtInfSection
// Purpose : Constructor
//
CUrtInfSection::CUrtInfSection( 
                               const HINF hInfName, 
                               const WCHAR* szInfSection, 
                               const WCHAR* szInfKey )
{
    if( hInfName == NULL )
    {
        assert( !L"CUrtInfSection::CUrtInfSection((): Invalid handle to INF file." );
    }

    ::ZeroMemory( m_szSections, sizeof( m_szSections ) );

    assert( NULL != szInfSection );
    assert( NULL != szInfKey );
    assert( m_lSections.empty() );

    DWORD dwResultSize = 0;

    //get the specified line
    //
    SetupGetLineText(
        0,
        hInfName,
        szInfSection,
        szInfKey,
        m_szSections,
        countof( m_szSections ),
        &dwResultSize );

    WCHAR* pStart = m_szSections;
    WCHAR* pEnd = m_szSections;
    BOOL fMoreData = FALSE;

    //parse the line and set a pointer to
    // the beginning of each substring
    while( g_chEndOfLine != *pStart )
    {
        while( g_chEndOfLine != *pEnd &&
               g_chSectionDelim  != *pEnd )
        {
            pEnd = ::CharNext( pEnd );
        }

        if( g_chSectionDelim == *pEnd )
        {
            fMoreData = TRUE;
        }

        m_lSections.push_back( pStart );

        if( fMoreData )
        {
            pStart = CharNext( pEnd );
            *pEnd = g_chEndOfLine;
            pEnd = pStart;

            fMoreData = FALSE;
        }
        else
        {
            pStart = pEnd;
        }
    }
}


//////////////////////////////////////////////////////////////////////////////
// CUrtInfSection
// Purpose : Destructor
//
CUrtInfSection::~CUrtInfSection()
{
      m_lSections.clear();
}


//////////////////////////////////////////////////////////////////////////////
// item
// Receives: UINT   - index or number of item desired
// Returns : WCHAR* - value at that item
// Purpose : Returns the item indexed by the UINT. 
//           This is one-based (vs. zero-based)
//
const WCHAR* CUrtInfSection::item( const UINT ui )
{
    if( 1 > ui )
    {
        return L"";
    }

    std::list<WCHAR*>::iterator it = m_lSections.begin();

    for( UINT i = 1; i < ui; ++i  )
    {
        ++it;
    }

    return *it;
}





//////////////////////////////////////////////////////////////////////////////
// CUrtInfKeys
// Purpose : Constructor
//
CUrtInfKeys::CUrtInfKeys( const HINF hInfName, const WCHAR* szInfSection )
{
    if( hInfName == NULL )
    {
        assert( !L"CUrtInfKeys::CUrtInfKeys((): Invalid handle to INF file." );
    }

    WCHAR szLine[2*_MAX_PATH+1] = EMPTY_BUFFER;
    DWORD dwRequiredSize = 0;
    INFCONTEXT Context;

    //get the context
    //
    BOOL fMoreFiles = SetupFindFirstLine(
        hInfName, 
        szInfSection,
        NULL, 
        &Context );

    while( fMoreFiles )
    {
        //get size
        //
        fMoreFiles = SetupGetLineText(
            &Context, 
            NULL, 
            NULL, 
            NULL, 
            NULL, 
            0, 
            &dwRequiredSize );

        if( dwRequiredSize > countof( szLine ) )
        {
            assert( !L"CUrtInfKeys::CUrtInfKeys() error! Buffer overrun!" );
        }


        //get the line and save it off 
        //
        if( SetupGetLineText(
            &Context, 
            NULL, 
            NULL, 
            NULL, 
            szLine, 
            dwRequiredSize, 
            NULL ) )
        {
            m_lKeys.push_back( string( szLine ) );
        }
 
        fMoreFiles = SetupFindNextLine( &Context, &Context );
   }
}


//////////////////////////////////////////////////////////////////////////////
// CUrtInfKeys
// Purpose : Destructor
//
CUrtInfKeys::~CUrtInfKeys()
{
    m_lKeys.clear();
}


//////////////////////////////////////////////////////////////////////////////
// item
// Receives: UINT   - index or number of item desired
// Returns : WCHAR* - value at that item
// Purpose : Returns the item indexed by the UINT. 
//           This is one-based (vs. zero-based)
//
const WCHAR* CUrtInfKeys::item( const UINT ui )
{
    if( 1 > ui )
    {
        return L"";
    }

    std::list<string>::iterator it = m_lKeys.begin();

    for( UINT i = 1; i < ui; ++i  )
    {
        ++it;
    }

    return (*it).c_str();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\infhelpers.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: infhelpers.cpp
//
// Abstract:
//    class definitions for inf setup helper objects
//
// Author: JoeA
//
// Notes:
//

#if !defined( INFHELPERS_H )
#define INFHELPERS_H

#include "globals.h"


//////////////////////////////////////////////////////////////////////////////
// class CUrtInfSection
// Receives: HINF   - handle to an INF
//           WCHAR* - section in the INF
//           WCHAR* - key from the INF
//
// Purpose : several INF keys have the structure
//              key=item1,item2,item2
//           where itemx is another section in the INF.
//           These sections are parsed out and stored as substrings
//           for later retrieval.
//
class CUrtInfSection
{
public:
    CUrtInfSection( const HINF hInfName, const WCHAR* szInfSection, const WCHAR* szInfKey );
    ~CUrtInfSection();

    UINT count( VOID ) const { return m_lSections.size(); }
    const WCHAR* item( const UINT ui );


protected:
    WCHAR m_szSections[2*_MAX_PATH+1];

    std::list<WCHAR*> m_lSections;

private:
};  //class CUrtInfSection





//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
typedef std::basic_string<wchar_t> string;


//////////////////////////////////////////////////////////////////////////////
// class CUrtInfKeys
// Receives: HINF   - handle to an INF
//           WCHAR* - section in the INF
//
// Purpose : several INF sections contain many lines of data that is passed
//           to other functions; this class reads this information and 
//           stores it to be retrieved through its accessors
//
class CUrtInfKeys
{
public:
    CUrtInfKeys( const HINF hInfName, const WCHAR* szInfSection );
    ~CUrtInfKeys();

    UINT count( VOID ) const { return m_lKeys.size(); }
    const WCHAR* item( const UINT ui );

protected:
    std::list<string> m_lKeys;

private:
};  //class CUrtInfKeys


#endif  //INFHELPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\aspnetocm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: aspnetocm.cpp
//
// Abstract:
//    class definitions for setup object
//
// Author: A-MariaS
//
// Notes:
//

#include "aspnetocm.h"
#include "Imagehlp.h"
#include "resource.h"
#include <atlbase.h>


//strings
const WCHAR* const g_szInstallString     = L"_install";
const WCHAR* const g_szUninstallString   = L"_uninstall";
const WCHAR* const g_szCustActionSection = L"CA";
const WCHAR* const g_szCopyFilesSection  = L"CopyFiles";
const WCHAR* const g_szSharedDlls        = L"Software\\Microsoft\\Windows\\CurrentVersion\\SharedDlls";



// value is set in main, is true if user is an administrator and false otherwise
BOOL g_bIsAdmin = FALSE;



//////////////////////////////////////////////////////////////////////////////
// CUrtOcmSetup
// Purpose : Constructor
//
CUrtOcmSetup::CUrtOcmSetup() :
m_wLang( LANG_ENGLISH )
{
    assert( m_csLogFileName );
    ::GetWindowsDirectory( m_csLogFileName, MAX_PATH );
    ::wcscat( m_csLogFileName, L"\\aspnetocm.log" );

    LogInfo( L"********************************************************************************" );
    LogInfo( L"CUrtOcmSetup()" );
    LogInfo( L"Installs ASPNET component" );

    ::ZeroMemory( &m_InitComponent, sizeof( SETUP_INIT_COMPONENT ) );
}


//////////////////////////////////////////////////////////////////////////////
// OcmSetupProc
// Receives: LPCTSTR - string ... name of component
//           LPCTSTR - string ... name of subcomponent (if applicable)
//           UINT    - ocm function id
//           UINT    - variable data ... dependent on function id
//           PVOID   - variable data ... dependent on function id
// Returns : DWORD
// Purpose : handle callback from OCM setup
//
DWORD CUrtOcmSetup::OcmSetupProc( LPCTSTR szComponentId,
                        LPCTSTR szSubcomponentId,
                        UINT    uiFunction,
                        UINT    uiParam1,
                        PVOID   pvParam2 )
{
    DWORD dwReturnValue = 0;
    BOOL  fState = TRUE;
    WCHAR wszSubComp[_MAX_PATH+1] = EMPTY_BUFFER;

    switch ( uiFunction )
    {
    case OC_PREINITIALIZE:
        ::swprintf( wszSubComp, L"OC_PREINITIALIZE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Called when the component's setup DLL is first loaded. Must be 
        // performed before initialization of the component can occur.
        //
        //Param1 = char width flags
        //Param2 = unused
        //
        //Return value is a flag indicating to OC Manager
        // which char width we want to run in.
        //

        dwReturnValue = OnPreInitialize( uiParam1 );
        break;

    case OC_INIT_COMPONENT:
        ::swprintf( wszSubComp, L"OC_INIT_COMPONENT - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Called soon after the component's setup DLL is loaded. Allows the 
        // component to initialize itself, and supplies the component with 
        // such items as its component ID and a set of callback routines, and 
        // requests certain information from the component.
        //
        //Param1 = unused
        //Param2 = points to SETUP_INIT_COMPONENT structure
        //
        //Return code is Win32 error indicating outcome.
        //
        dwReturnValue = InitializeComponent( 
            static_cast<PSETUP_INIT_COMPONENT>(pvParam2) );

        break;

    case OC_SET_LANGUAGE:
        ::swprintf( wszSubComp, L"OC_SET_LANGUAGE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Instructs the component to change to a given language if it can.
        //
        //Param1 = low 16 bits specify Win32 LANGID
        //Param2 = unused
        //
        //Return code is a boolean indicating whether we think we
        // support the requested language. We remember the language id
        // and say we support the language. A more exact check might involve
        // looking through our resources via EnumResourcesLnguages() for
        // example, or checking our inf to see whether there is a matching
        // or closely matching [strings] section. We don't bother with
        // any of that here.
        //
        dwReturnValue = OnSetLanguage( ( uiParam1 & 0xFFFF ) );
        break;

    case OC_QUERY_IMAGE:
        ::swprintf( wszSubComp, L"OC_QUERY_IMAGE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Requests GDI objects, such as the small icon associated with a 
        // (sub)component (if not specified in the component's .inf file).
        //
        //Param1 = low 16 bits used to specify image to be used
        //Param2 = width (low word) and height (high word) of image
        //
        //Return code is an HBITMAP or NULL on error
        //
        dwReturnValue = OnQueryImage( 
            ( uiParam1 & 0xFFFF ), 
            reinterpret_cast<DWORD>(pvParam2) );
        break;

    case OC_REQUEST_PAGES:
        ::swprintf( wszSubComp, L"OC_REQUEST_PAGES - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Requests a set of wizard page handles from the component.
        //
        //Param1 = unused
        //Param2 = pointer to a variable-size SETUP_REQUEST_PAGES
        //
        //Return code is the number of pages a component wants to return
        //
        dwReturnValue = OnRequestPages( static_cast<PSETUP_REQUEST_PAGES>(pvParam2) );
        break;

    case OC_QUERY_SKIP_PAGE:
        ::swprintf( wszSubComp, L"OC_QUERY_SKIP_PAGE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Asks top-level components whether OC Manager should skip displaying
        // a page it owns.
        //
        //Param1 = specifies the subject page of type OcManagerPage
        //Param2 = unused
        //
        //Return code is BOOLEAN specifying whether component wants to skip 
        // the page
        //
        dwReturnValue = OnQuerySkipPage( static_cast<OcManagerPage>(uiParam1) );
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        ::swprintf( wszSubComp, L"OC_QUERY_CHANGE_SEL_STATE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        //Informs the component that it or one of its subcomponents has been
        // selected/deselected by the user, and requests approval.
        //
        //Param1 = specifies proposed new selection state
        //Param2 = flags encoded as bit field
        //
        //Return code is BOOLEAN specifying whether proposed state s/b accepted
        //
        dwReturnValue = OnQueryChangeSelectionState( uiParam1, reinterpret_cast<UINT>(pvParam2), szSubcomponentId );
        break;

    case OC_CALC_DISK_SPACE:
        ::swprintf( wszSubComp, L"OC_CALC_DISK_SPACE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Directs the component to manipulate a Setup API Disk Space List, 
        // placing files on it or removing files from it, to mirror what will 
        // be actually installed later via a Setup API file queue. This 
        // allows efficient tracking of required disk space.
        //
        //Param1 = 0 if for removing component or non-0 if for adding component
        //Param2 = HDSKSPC to operate on
        //
        //Return value is Win32 error code indicating outcome.
        //
        if( !szSubcomponentId || !*szSubcomponentId )
        {
            LogInfo( L"OnCalculateDiskSpace was not called, since subcomponent is unknown" );
            dwReturnValue = NO_ERROR;
        }
        else if( !g_bIsAdmin )
        {
            LogInfo( L"OnCalculateDiskSpace was not called, since user has no admin privileges" );
            dwReturnValue = NO_ERROR;
        }
        else 
        {
            dwReturnValue = OnCalculateDiskSpace( uiParam1, static_cast<HDSKSPC>(pvParam2), szSubcomponentId );
        }

        break;

    case OC_QUEUE_FILE_OPS:
        ::swprintf( wszSubComp, L"OC_QUEUE_FILE_OPS - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Directs the component to queue file operations for installation, 
        //based on user interaction with the wizard pages and other 
        //component-specific factors.
        //
        //Param1 = unused
        //Param2 = HSPFILEQ to operate on
        //
        //Return value is Win32 error code indicating outcome.
        //
        //OC Manager calls this routine when it is ready for files to be copied
        // to effect the changes the user requested. The component DLL must figure out
        // whether it is being installed or uninstalled and take appropriate action.
        // For this sample, we look in the private data section for this component/
        // subcomponent pair, and get the name of an uninstall section for the
        // uninstall case.
        //
        //Note that OC Manager calls us once for the *entire* component
        // and then once per subcomponent. We ignore the first call.
        //

        fState = TRUE;
        if( !szSubcomponentId || !*szSubcomponentId )
        {
            LogInfo( L"OnQueueFileOperations was not called, since subcomponent is unknown" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !g_bIsAdmin )
        {
            LogInfo( L"OnQueueFileOperations was not called, since user has no admin privileges" );
            dwReturnValue = NO_ERROR;
        }
        else
        {
            dwReturnValue = OnQueueFileOperations( szSubcomponentId, static_cast<HSPFILEQ>(pvParam2) );
        }
        break;

    case OC_NEED_MEDIA:
        ::swprintf( wszSubComp, L"OC_NEED_MEDIA - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Used to pass along the SPFILENOTIFY_NEEDMEDIA Setup API notification 
        // message. Allows components to perform custom media processing, such 
        // as fetching cabinets from the Internet, and so forth. 
        //
        //Param1 = unused
        //Param2 = unused
        //
        //Return code is unused
        //
        dwReturnValue = OnNeedMedia();
        break;

    case OC_QUERY_STEP_COUNT:
        ::swprintf( wszSubComp, L"OC_QUERY_STEP_COUNT - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Asks the component how many steps are associated with a particular 
        // function/phase (such as OC_ABOUT_TO_COMMIT_QUEUE and 
        // OC_COMPLETE_INSTALLATION). Used to set up a progress indicator. 
        //
        //Param1 = unused
        //Param2 = unused
        //
        //Return value is an arbitrary 'step' count or -1 if error.
        //
        //OC Manager calls this routine when it wants to find out how much
        // work the component wants to perform for nonfile operations to
        // install/uninstall a component/subcomponent.
        // It is called once for the *entire* component and then once for
        // each subcomponent in the component.
        //

        fState = TRUE;
        if( !szSubcomponentId || !*szSubcomponentId )
        {
            LogInfo( L"OnQueryStepCount was not called, since subcomponent is unknown" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !g_bIsAdmin )
        {
            LogInfo( L"OnQueryStepCount was not called, since user has no admin privileges" );
            dwReturnValue = NO_ERROR;
        }
        else
        {
            dwReturnValue = OnQueryStepCount( szSubcomponentId );
        }
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        ::swprintf( wszSubComp, L"OC_ABOUT_TO_COMMIT_QUEUE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Notifies the component that the file queue is about to be committed.
        // The component can perform housekeeping actions, and so forth. 
        //
        //Param1 = unused
        //Param2 = unused
        //
        //Return code is Win32 error code indicating outcome
        //

        
        fState = TRUE;
        if( !szSubcomponentId || !*szSubcomponentId )
        {
            LogInfo( L"OnAboutToCommitQueue was not called, since subcomponent is unknown" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !g_bIsAdmin )
        {
            LogInfo( L"OnAboutToCommitQueue was not called, since user has no admin privileges" );
            dwReturnValue = NO_ERROR;
        }
        else
        {
            dwReturnValue = OnAboutToCommitQueue( szSubcomponentId );
        }
        break;

    case OC_COMPLETE_INSTALLATION:
        ::swprintf( wszSubComp, L"OC_COMPLETE_INSTALLATION - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Allows the component to perform any additional operations needed to 
        // complete installation, for example registry manipulations, and so
        // forth.
        //
        //Param1 = unused
        //Param2 = unused
        //
        //Return code is Win32 error code indicating outcome
        //

        fState = TRUE;
        if( !szSubcomponentId || !*szSubcomponentId )
        {
            LogInfo( L"OnCompleteInstallation was not called, since subcomponent is unknown" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !g_bIsAdmin )
        {
            LogInfo( L"OnCompleteInstallation was not called, since user has no admin privileges" );
            dwReturnValue = NO_ERROR;
        }
        else
        {
            dwReturnValue = OnCompleteInstallation( szSubcomponentId );
        }
        break;

    case OC_CLEANUP:
        ::swprintf( wszSubComp, L"OC_CLEANUP - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Informs the component that it is about to be unloaded.
        //
        //Param1 = unused
        //Param2 = unused
        //
        //Return code is unused
        //
        dwReturnValue = OnCleanup();
        break;


    case OC_NOTIFICATION_FROM_QUEUE:
        ::swprintf( wszSubComp, L"OC_NOTIFICATION_FROM_QUEUE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnNotificationFromQueue();
        break;
    case OC_FILE_BUSY:
        ::swprintf( wszSubComp, L"OC_FILE_BUSY - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        dwReturnValue = OnFileBusy();
        break;
    case OC_QUERY_ERROR:
        ::swprintf( wszSubComp, L"OC_QUERY_ERROR - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnQueryError();
        break;
    case OC_PRIVATE_BASE:
        ::swprintf( wszSubComp, L"OC_PRIVATE_BASE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnPrivateBase();
        break;
    case OC_QUERY_STATE:
        ::swprintf( wszSubComp, L"OC_QUERY_STATE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        dwReturnValue = OnQueryState( uiParam1 );
        break;
    case OC_WIZARD_CREATED:
        ::swprintf( wszSubComp, L"OC_WIZARD_CREATED - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnWizardCreated();
        break;
    case OC_EXTRA_ROUTINES:
        ::swprintf( wszSubComp, L"OC_EXTRA_ROUTINES - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnExtraRoutines();
        break;

    default:
        ::swprintf( wszSubComp, L"default... UNRECOGNIZED - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = UNRECOGNIZED;
        break;

   }  // end of switch( uiFunction )

   return dwReturnValue;
}


//////////////////////////////////////////////////////////////////////////////
// OnPreInitialize
// Receives: UINT  - char width flags
// Returns : DWORD - a flag indicating which char width we want to run in
// Purpose : handler for OC_PREINITIALIZE
//
DWORD CUrtOcmSetup::OnPreInitialize( UINT uiCharWidth )
{
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnPreInitialize(), charWidth = %d", uiCharWidth );
    LogInfo( infoString );

#ifdef ANSI
    if( !( uiCharWidth & OCFLAG_ANSI ) )
    {
        assert( !L"CUrtOcmSetup::OnPreInitialize(): Ansi character width not supported!" );
    }

    return OCFLAG_ANSI;
#else
    if( !( uiCharWidth & OCFLAG_UNICODE ) )
    {
        assert( !L"CUrtOcmSetup::OnPreInitialize(): Unicode character width not supported!" );
    }

    return OCFLAG_UNICODE;
#endif
}

//////////////////////////////////////////////////////////////////////////////
// InitializeComponent
// Receives: PSETUP_INIT_COMPONENT - pointer to SETUP_INIT_COMPONENT structure
// Returns : DWORD                 - Win32 error indicating outcome
// Purpose : handler for OC_INIT_COMPONENT
//
DWORD CUrtOcmSetup::InitializeComponent( PSETUP_INIT_COMPONENT pSetupInitComponent )
{
    LogInfo( L"InitializeComponent()" );

    DWORD dwReturnValue = NO_ERROR;

    //Save off a copy of the Component information
    //
    assert( NULL != pSetupInitComponent );
    ::memcpy(
        &m_InitComponent,
        static_cast<PSETUP_INIT_COMPONENT>(pSetupInitComponent),
        sizeof(SETUP_INIT_COMPONENT) );

    //This code segment determines whether the version of OC Manager is
    // correct
    //
    if( OCMANAGER_VERSION <= m_InitComponent.OCManagerVersion )
    {
        //Indicate to OC Manager which version of OC Manager this dll expects
        //
        m_InitComponent.ComponentVersion = OCMANAGER_VERSION;
    }
    else
    {
        dwReturnValue = ERROR_CALL_NOT_IMPLEMENTED;
    }

   

    return dwReturnValue;
}

//////////////////////////////////////////////////////////////////////////////
// OnSetLanguage
// Receives: UINT  - Win32 LANGID
// Returns : DWORD - a boolean indicating whether we think we support the 
//                   requested language
// Purpose : handler for OC_SET_LANGUAGE
//
DWORD CUrtOcmSetup::OnSetLanguage( UINT uiLangID )
{
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnSetLanguage(), languageID = %d", uiLangID );
    LogInfo( infoString );

    BOOL fLangOK = TRUE;

    //REVIEW: 1/30/01 JoeA
    // we are only recognizing English or Neutral strings at this time
    //
    if( LANG_NEUTRAL == PRIMARYLANGID( uiLangID ) )
    {
        m_wLang = LANG_NEUTRAL;
    }
    else if( LANG_ENGLISH == PRIMARYLANGID( uiLangID ) )
    {
        m_wLang = LANG_ENGLISH;
    }
    else
    {
        fLangOK = FALSE;
    }

    return static_cast<DWORD>(fLangOK);
}

//////////////////////////////////////////////////////////////////////////////
// OnQueryImage
// Receives: UINT  - low 16 bits used to specify image to be used
//           DWORD - width (low word) and height (high word) of image
// Returns : DWORD - an HBITMAP or NULL on error
// Purpose : handler for OC_QUERY_IMAGE
//
DWORD CUrtOcmSetup::OnQueryImage( UINT uiImage, DWORD dwImageSize )
{
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnQueryImage(), image = %d, imageSize = %d", uiImage, dwImageSize );
    LogInfo( infoString );

    DWORD_PTR dwOcEntryReturn = (DWORD)NULL;
    dwOcEntryReturn = (DWORD_PTR)::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_ASPNET_ICON));
        
    if (dwOcEntryReturn != NULL)
    {
        ::swprintf( infoString, L"OnQueryImage(), return value is 0x%x", dwOcEntryReturn );
        LogInfo( infoString );
    }
    else
    {
        DWORD dwError = ::GetLastError();
        ::swprintf( infoString, L"Return value of LoadBitmap is NULL, last error is %d", dwError );
        LogInfo( infoString );
    }
    return dwOcEntryReturn;
}

//////////////////////////////////////////////////////////////////////////////
// OnRequestPages
// Receives: PSETUP_REQUEST_PAGES - pointer to variable-sized page structure
// Returns : DWORD - number of pages entered into the structure
// Purpose : handler for OC_REQUEST_PAGES
//
DWORD CUrtOcmSetup::OnRequestPages( PSETUP_REQUEST_PAGES prpPages )
{
    LogInfo( L"OnRequestPages()" );

    UNREFERENCED_PARAMETER( prpPages );

    //we have no custom pages
    //
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// OnQuerySkipPage
// Receives: UINT  - enum of type OcManagerPage
// Returns : DWORD - zero indicates skip page; non-zero indicates not to
// Purpose : handler for OC_QUERY_SKIP_PAGE
//
DWORD CUrtOcmSetup::OnQuerySkipPage( OcManagerPage ocmpPage )
{
    LogInfo( L"OnQuerySkipPage()" );

    UNREFERENCED_PARAMETER( ocmpPage );

    //REVIEW: 1/30/01 JoeA
    // we are a hidden component and have no UI ... we do not care
    // if any or all pages are skipped. Skipping page will not alter
    // the installation functionality
    //
    return !(0);
}

//////////////////////////////////////////////////////////////////////////////
// OnQueryChangeSelectionState
// Receives: UINT    - specifies proposed new selection state 
//                     (0 = not selected; non-0 is selected )
//           PVOID   - flags encoded as bit field
//           LPCTSTR - subcomponent name
// Returns : DWORD - BOOLEAN specifying whether proposed state s/b accepted
//                   if a zero value is returned, the selection state is not 
//                   changed
// Purpose : handler for OC_QUERY_CHANGE_SEL_STATE
//
DWORD CUrtOcmSetup::OnQueryChangeSelectionState( UINT uiNewState, UINT uiFlags, LPCTSTR szComp )
{
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnQueryChangeSelectionState(), newState = %d", uiNewState );
    LogInfo( infoString );

    if( !szComp || !*szComp )
    {
        return NO_ERROR;
    }

    if ( ( (BOOL) uiNewState ) &&
        ( uiFlags  & OCQ_DEPENDENT_SELECTION ) &&
        !( uiFlags & OCQ_ACTUAL_SELECTION )
        )
    {
        // Deny request to change state
        return 0;
    }



    if (!(uiFlags & OCQ_ACTUAL_SELECTION))
    {
        LogInfo(L"OnQueryChangeSelectionState(), flag is different from OCQ_ACTUAL_SELECTION");
        return 1;
    }

    if( NOT_SELECTED == uiNewState )
    {
        LogInfo( L"CUrtOcmSetup::OnQueryChangeSelectionState(): Selection state turned OFF" );      
    }
    else
    {
        LogInfo( L"CUrtOcmSetup::OnQueryChangeSelectionState(): Selection state turned ON" );        
    }

    return 1;
}

//////////////////////////////////////////////////////////////////////////////
// OnCalculateDiskSpace
// Receives: UINT    - 0 if removing component or non-0 if adding component
//           HDSKSPC - HDSKSPC to operate on
//           LPCTSTR - Subcomponent id
// Returns : DWORD   - Return value is Win32 error code indicating outcome
// Purpose : handler for OC_CALC_DISK_SPACE
//
DWORD CUrtOcmSetup::OnCalculateDiskSpace( UINT uiAdd, HDSKSPC hdSpace, LPCTSTR szComp )
{
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnCalculateDiskSpace(), adding = %d", uiAdd );
    LogInfo( infoString );

    if( !szComp || !*szComp )
    {
        return NO_ERROR;
    }

    BOOL fSucceeded = TRUE;
    BOOL fGoodDataFile = TRUE;
    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::OnCalculateDiskSpace(): Invalid handle to INF file." );
        fGoodDataFile = FALSE;
    }

    if( uiAdd && fGoodDataFile )
    {
        //creates section with name like
        // [<szComp>_install]
        WCHAR szInstallSection[MAX_PATH+1] = EMPTY_BUFFER;
        ::wcscpy( szInstallSection, szComp );
        ::wcscat( szInstallSection, g_szInstallString );

        ::swprintf( infoString, L"OnCalculateDiskSpace(), adding size from section %s", szInstallSection );
        LogInfo( infoString );

        fSucceeded = ::SetupAddInstallSectionToDiskSpaceList(
            hdSpace,
            m_InitComponent.ComponentInfHandle,
            NULL,
            szInstallSection,
            0,
            0 );
    }
    
    return ( fSucceeded ) ? NO_ERROR : ::GetLastError();
}

//////////////////////////////////////////////////////////////////////////////
// OnQueueFileOperations
// Receives: LPCTSTR  - Subcomponent id
//           HSPFILEQ - HSPFILEQ to operate on
// Returns : DWORD    - Win32 error code indicating outcome
// Purpose : handler for OC_QUEUE_FILE_OPS
//
DWORD CUrtOcmSetup::OnQueueFileOperations( LPCTSTR szComp, HSPFILEQ pvHFile )
{
    

    LogInfo( L"OnQueueFileOperations()" );

    BOOL fRet = NO_ERROR;
    
    if( !szComp || !*szComp )
    {
        return NO_ERROR;
    }
    
   

    BOOL state = TRUE;
    if (!StateInfo(szComp, &state))
    {
        LogInfo( L"OnQueueFileOperations() - state has not changed, exiting" );
        return NO_ERROR;
    }

    BOOL fGoodDataFile = TRUE;
    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::OnQueueFileOperations(): Invalid handle to INF file." );
        fGoodDataFile = FALSE;
    }
    
    // detect if aspnet component is already installed
    BOOL bComponentInstalled = GetOriginalState(szComp);
    
    // detect if we are installing
    BOOL bInstall = GetNewState(szComp);

    // Copy files on install only and only in case aspnet is not installed by OCM
    BOOL bCopyFiles = FALSE;
    if (bInstall && !bComponentInstalled) 
    {
        bCopyFiles = TRUE;
        LogInfo( L"OnQueueFileOperations() - copy files" );
    }
    else
    {
        LogInfo( L"OnQueueFileOperations() - Do not copy files" );
    }

    
    if( szComp && bCopyFiles && fGoodDataFile )
    {
        //creates section with name like
        // [<szComp>_install]
        WCHAR szInstallSection[MAX_PATH+1] = EMPTY_BUFFER;
        ::wcscpy( szInstallSection, szComp );
        ::wcscat( szInstallSection, g_szInstallString );

        WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
        ::swprintf( infoString, L"OnQueueFileOperations(), adding files from section %s", szInstallSection );
        LogInfo( infoString );

        // queue files to install
        if( !::SetupInstallFilesFromInfSection(
                m_InitComponent.ComponentInfHandle,
                NULL,
                pvHFile,
                szInstallSection,
                NULL,
                SP_COPY_FORCE_NEWER ) )
        {
            fRet = ::GetLastError();
        }
    }

    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
// OnNeedMedia
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_NEED_MEDIA
//
DWORD CUrtOcmSetup::OnNeedMedia( VOID )
{
    LogInfo( L"OnNeedMedia()" );

    return static_cast<DWORD>(FALSE);
}

//////////////////////////////////////////////////////////////////////////////
// OnQueryStepCount
// Receives: LPCTSTR - subcomponent id
// Returns : DWORD   - number of steps to include 
// Purpose : handler for OC_QUERY_STEP_COUNT
//
DWORD CUrtOcmSetup::OnQueryStepCount( LPCTSTR szSubCompId )
{
    LogInfo( L"OnQueryStepCount()" );

    //the return will reflect the number of non-filecopy "steps" (operations?)
    // in the setup. ScriptDebugger used the count of registry lines, ocgen
    // used a hard-coded number.
    //
    DWORD dwRetVal = NO_ERROR;

    return dwRetVal;
}

//////////////////////////////////////////////////////////////////////////////
// OnAboutToCommitQueue
// Receives: LPCTSTR- Subcomponent id
// Returns : DWORD - 
// Purpose : handler for OC_ABOUT_TO_COMMIT_QUEUE
//
DWORD CUrtOcmSetup::OnAboutToCommitQueue( LPCTSTR szComp )
{
    LogInfo( L"OnAboutToCommitQueue()" );

    BOOL fRet = NO_ERROR;
    if( !szComp || !*szComp )
    {
        return NO_ERROR;
    }
   
    BOOL state = TRUE;
    if (!StateInfo(szComp, &state))
    {
        LogInfo( L"OnAboutToCommitQueue() - state has not changed, exiting" );
        return NO_ERROR;
    }
      
    BOOL fGoodDataFile = TRUE;
    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::OnAboutToCommitQueue(): Invalid handle to INF file." );
        fGoodDataFile = FALSE;
    }
 

    BOOL bUninstallAllowed = FALSE;

    // detect if aspnet component is already installed
    BOOL bComponentInstalled = GetOriginalState(szComp);
    
    // detect if we are installing
    BOOL bInstall = GetNewState(szComp);

    if (!bInstall && bComponentInstalled) 
    {
        // Uninstall only if component is turned OFF and component is already installed by OCM
        bUninstallAllowed = TRUE;
        LogInfo( L"OnAboutToCommitQueue() - Uninstall is allowed" );
    }
    
    if( szComp && fGoodDataFile && bUninstallAllowed)
    {
        //creates section with name like
        // [<szComp>_install]
        //
        WCHAR szInstallSection[MAX_PATH+1] = EMPTY_BUFFER;
        ::wcscpy( szInstallSection, szComp );
        ::wcscat( szInstallSection, g_szUninstallString );
        
        //Custom Action registration
        //
        WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
        ::swprintf( infoString, L"OnAboutToCommitQueue(), cycling through custom actions from %s", szInstallSection );
        LogInfo( infoString );

        CUrtInfSection sectCAHs( 
            m_InitComponent.ComponentInfHandle, 
            szInstallSection, 
            g_szCustActionSection );

        for( UINT i = 1; i <= sectCAHs.count(); ++i )
        {
            const WCHAR* sz = sectCAHs.item( i );
            GetAndRunCustomActions( sz, TRUE );  
        }
    }

    LogInfo( L"OnAboutToCommitQueue() finished succesfully" );
    return fRet;


}

//////////////////////////////////////////////////////////////////////////////
// OnCompleteInstallation
// Receives: LPCTSTR- Subcomponent id
// Returns : DWORD - 
// Purpose : handler for OC_COMPLETE_INSTALLATION
//
DWORD CUrtOcmSetup::OnCompleteInstallation( LPCTSTR szComp )
{
    LogInfo( L"OnCompleteInstallation()" );

    //installation is handled in this call
    //
    BOOL fRet = NO_ERROR;
    if( !szComp || !*szComp )
    {
        return NO_ERROR;
    }

    BOOL state = TRUE;
    if (!StateInfo(szComp, &state))
    {
        LogInfo( L"OnCompleteInstallation() - state has not changed, exiting" );
        return NO_ERROR;
    }

    BOOL fGoodDataFile = TRUE;
    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::OnCompleteInstallation(): Invalid handle to INF file." );
        fGoodDataFile = FALSE;
    }

    BOOL bInstallAllowed = FALSE;
    BOOL bUninstallAllowed = FALSE;

    // detect if aspnet component is already installed
    BOOL bComponentInstalled = GetOriginalState(szComp);
    
    // detect if we are installing
    BOOL bInstall = GetNewState(szComp);
    
    if (bInstall && !bComponentInstalled) 
    {
        // Install only if component is turned ON and it is first installation
        bInstallAllowed = TRUE;
        LogInfo( L"OnCompleteInstallation() - Install is allowed" );
    }
    else if (bInstall && bComponentInstalled)
    {
        if( ( m_InitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE ) == SETUPOP_NTUPGRADE )
        {
            bInstallAllowed = TRUE;
            LogInfo( L"OnCompleteInstallation() - Upgrade with ASP.NET OCM component installed: Install is allowed" );
        }
        else
        {
            LogInfo( L"OnCompleteInstallation() - Install is NOT allowed" );
        }
    }
    
    if( szComp && fGoodDataFile && bInstallAllowed)
    {
        //creates section with name like
        // [<szComp>_install]
        //
        WCHAR szInstallSection[MAX_PATH+1] = EMPTY_BUFFER;
        ::wcscpy( szInstallSection, szComp );
        ::wcscat( szInstallSection, g_szInstallString );

        // Increase Reg Count on install only:

        // update HKLM,software\microsoft\windows\currentversion\sharedlls
        // registry values, for all files that we copy
        UpdateSharedDllsRegistryValues( szInstallSection );

                
        //Custom Action registration
        //
        WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
        ::swprintf( infoString, L"OnCompleteInstallation(), cycling through custom actions from %s", szInstallSection );
        LogInfo( infoString );

        CUrtInfSection sectCAHs( 
            m_InitComponent.ComponentInfHandle, 
            szInstallSection, 
            g_szCustActionSection );

        for( UINT i = 1; i <= sectCAHs.count(); ++i )
        {
            const WCHAR* sz = sectCAHs.item( i );

            //REVIEW - 2/15/01 JoeA ... TRUE assumes installation
            //
            GetAndRunCustomActions( sz, TRUE );  
        }
    }

    LogInfo( L"OnCompleteInstallation() finished succesfully" );
    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
// OnCleanup
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_CLEANUP
//
DWORD CUrtOcmSetup::OnCleanup( VOID )
{
    LogInfo( L"OnCleanup()" );

    //at this point, there's nothing to clean up ... I expect some work to
    // happen here
    // Close logs, complete custom action work, restore initial reg settings...
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnNotificationFromQueue
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_NOTIFICATION_FROM_QUEUE
//
DWORD CUrtOcmSetup::OnNotificationFromQueue( VOID )
{
    LogInfo( L"OnNotificationFromQueue()" );

    //using ocgen.dll implementation
    //
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnFileBusy
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_FILE_BUSY
//
DWORD CUrtOcmSetup::OnFileBusy( VOID )
{
    LogInfo( L"OnFileBusy()" );

    //this is neither used in ocgen.dll or other source. Including here 
    // for completeness
    //
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnQueryError
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_QUERY_ERROR
//
DWORD CUrtOcmSetup::OnQueryError( VOID )
{
    LogInfo( L"OnQueryError()" );

    //this is neither used in ocgen.dll or other source. Including here 
    // for completeness
    //
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnPrivateBase
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_PRIVATE_BASE
//
DWORD CUrtOcmSetup::OnPrivateBase( VOID )
{
    LogInfo( L"OnPrivateBase()" );

    //this is neither used in ocgen.dll or other source. Including here 
    // for completeness
    //
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnQueryState
// Receives: UINT  - state value (OCSELSTATETYPE) ... see ocmanage.h for 
//                   definitions
// Returns : DWORD - 
// Purpose : handler for OC_QUERY_STATE
//
DWORD CUrtOcmSetup::OnQueryState( UINT uiState )
{
    LogInfo( L"OnQueryState()" );
    
    DWORD dwRetVal = static_cast<DWORD>( SubcompUseOcManagerDefault );

    if( OCSELSTATETYPE_ORIGINAL == uiState )
    {
        
        LogInfo( L"Called with OCSELSTATETYPE_ORIGINAL ... determining if we were installed previously." );
    }
    else if( OCSELSTATETYPE_CURRENT == uiState )
    {
        LogInfo( L"Called with OCSELSTATETYPE_CURRENT." );


        // automatically reinstall if upgrade and previous version of ASP.NET and IIS is installed
        BOOL bUpgrade = (m_InitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE ) == SETUPOP_NTUPGRADE;
        if (bUpgrade)
        {
            LogInfo( L"Upgrade detected" );
        }
        else
        {
            LogInfo( L"Upgrade not detected" );
        }
        if ( bUpgrade && IISAndASPNETInstalled() )
        {
            LogInfo(L"Upgrade from machine with IIS and ASP.NET, install ASP.NET component by default");
            LogInfo(L"Setting component on in OnQueryState");
            dwRetVal = static_cast<DWORD>( SubcompOn );
        }
    }
    else if( OCSELSTATETYPE_FINAL == uiState )
    {
        // return default
        LogInfo( L"Called with OCSELSTATETYPE_FINAL ... will set subcomponent registry flag." );
    }
    else
    {
        LogInfo( L"Called with unknown state." );
    }

    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnQueryState(),Return Value is  %d", dwRetVal );
    LogInfo( infoString );

    return dwRetVal;
}

//////////////////////////////////////////////////////////////////////////////
// OnWizardCreated
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_WIZARD_CREATED
//
DWORD CUrtOcmSetup::OnWizardCreated( VOID )
{
    LogInfo( L"OnWizardCreated()" );

    //using ocgen.dll implementation
    //
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnExtraRoutines
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_EXTRA_ROUTINES
//
DWORD CUrtOcmSetup::OnExtraRoutines( VOID )
{
    LogInfo( L"OnExtraRoutines()" );

    //using ocgen.dll implementation
    //
    return static_cast<DWORD>(NO_ERROR);
}



//////////////////////////////////////////////////////////////////////////////
// Helper Functions
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// StateInfo
// Receives: LPCTSTR - component name
//           BOOL*   - TRUE if to be installed, FALSE otherwise
// Returns : DWORD - FALSE if no change in state; TRUE otherwise
// Purpose : loads current selection state info into "state" and
//           returns whether the selection state was changed
//
BOOL CUrtOcmSetup::StateInfo( LPCTSTR szCompName, BOOL* state )
{
    BOOL rc = TRUE;

    if( NULL == szCompName )
    {
        assert( !L"CUrtOcmSetup::StateInfo(): Empty component name string passed in." );
    }

    if( NULL == state )
    {
        assert( !L"CUrtOcmSetup::StateInfo(): NULL boolean flag passed in." );
    }

	// otherwise, check for a change in installation state
    OCMANAGER_ROUTINES ohr = m_InitComponent.HelperRoutines;
		
    *state = ohr.QuerySelectionState(ohr.OcManagerContext,
                                     szCompName,
                                     OCSELSTATETYPE_CURRENT);

    if (*state == ohr.QuerySelectionState(ohr.OcManagerContext,
                                          szCompName,
                                          OCSELSTATETYPE_ORIGINAL))
    {
        // no change
        rc = FALSE;
    }

    // if this is gui mode setup, presume the state has changed to force
    // an installation (or uninstallation)
    if (!(m_InitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE) && *state)
    {
        LogInfo( L"StateInfo() - GUI Mode, return true" );
        rc = TRUE;
    }

    // if this is OS Upgrade, presume the state has changed to force
    // an installation (or uninstallation)
    if( ( m_InitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE ) == SETUPOP_NTUPGRADE )
    {
        LogInfo( L"StateInfo() - Upgrade, return true" );
        rc = TRUE;
    }

    return rc;
}


//////////////////////////////////////////////////////////////////////////////
// GetAndRunCustomActions
// Receives: WCHAR* - contains the name of the section from which to retrieve
//                    the custom actions
//           BOOL   - determines installation or removal; TRUE to install
// Returns : VOID
// Purpose : retrieves the list of custom actions to run and spawns them
//
VOID CUrtOcmSetup::GetAndRunCustomActions( const WCHAR* szSection, BOOL fInstall )
{
    //REVIEW: unused boolean parameter - joea 02/20/01

    LogInfo( L"GetAndRunCustomActions()" );

    if( NULL == szSection )
    {
        assert( !L"CUrtOcmSetup::GetAndRunCustomActions(): Empty section string passed in." );
    }

    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::GetAndRunCustomActions(): Invalid handle to INF file." );
    }
    else
    {
        CUrtInfKeys keys( m_InitComponent.ComponentInfHandle, szSection );

        for( UINT i = 1; i <= keys.count(); ++i )
        {
            QuietExec( keys.item( i ) );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// LogInfo
// Receives: LPCTSTR - null terminated string to log
// Returns : VOID
// Purpose : write a string to the logFile (m_csLogFileName) with the date and 
//           time stamps
// 
VOID CUrtOcmSetup::LogInfo( LPCTSTR szInfo )
{
    FILE *logFile = NULL;

    if( NULL == m_csLogFileName )
    {
        assert( !L"CUrtOcmSetup::LogInfo(): NULL string passed in." );
    }

    if( (logFile  = ::_wfopen( m_csLogFileName, L"a" )) != NULL )
    {
        WCHAR dbuffer[10] = EMPTY_BUFFER;
        WCHAR tbuffer[10] = EMPTY_BUFFER;
        
        ::_wstrdate( dbuffer );
        ::_wstrtime( tbuffer );

        ::fwprintf( logFile, L"[%s,%s] %s\n", dbuffer, tbuffer, szInfo );
        ::fclose( logFile );
    }
}

//////////////////////////////////////////////////////////////////////////////
// UpdateSharedDllsRegistryValues
// Receives: VOID
// Returns : VOID
// Purpose : update HKLM,software\microsoft\windows\currentversion\sharedlls
//           registry values, for all files that we copy
VOID CUrtOcmSetup::UpdateSharedDllsRegistryValues( LPCTSTR szInstallSection )
{
    LogInfo( L"UpdateSharedDllsRegistryValues()" );

    HKEY hKey = NULL;
    // open the g_szSharedDlls regKey, if it does not exist, create a new one
    if (::RegCreateKeyExW(HKEY_LOCAL_MACHINE, g_szSharedDlls, 0, NULL,
        REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS, NULL, &hKey, NULL) != ERROR_SUCCESS)
    {
        WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
        ::swprintf( infoString, L"Error: UpdateRegistryValue: Can't create a reg key %s", 
            g_szSharedDlls );
        LogInfo( infoString );
        ::RegCloseKey(hKey);
        return;
    }

    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::UpdateSharedDllsRegistryValues(): Invalid handle to INF file." );
    }
    else
    {
        // create a fullFileName for each file that we copy
        CUrtInfSection sectCopyFiles( 
                m_InitComponent.ComponentInfHandle, 
                szInstallSection, 
                g_szCopyFilesSection );

        WCHAR szDirPath[_MAX_PATH+1] = EMPTY_BUFFER;
        WCHAR szFileStr[_MAX_PATH+1] = EMPTY_BUFFER;

        for( UINT i = 1; i <= sectCopyFiles.count(); ++i )
        {
            const WCHAR *szDirSection = sectCopyFiles.item(i);

            // get a full path of the Directory
            ::ZeroMemory( szDirPath, _MAX_PATH+1);
            if (!::SetupGetTargetPath(m_InitComponent.ComponentInfHandle, NULL, szDirSection, szDirPath, 
                sizeof(szDirPath), NULL))
            {
                LogInfo(L"Error: UpdateSharedDllsRegistryValues: SetupGetTargetPath failed");
                continue;
            }
            
            // open section, get files
            CUrtInfKeys fileKeys( m_InitComponent.ComponentInfHandle, szDirSection );
            for( UINT iFile = 1; iFile <= fileKeys.count(); ++iFile )
            {
                szFileStr[0] = g_chEndOfLine;
                ::wcsncpy(szFileStr, fileKeys.item(iFile), sizeof(szFileStr)/sizeof(szFileStr[0]));
                WCHAR* pComma = NULL;
                pComma = ::wcschr( szFileStr, L',' ); 
                if ( pComma == NULL )
                {
                    WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
                    ::swprintf( infoString, L"Error: UpdateSharedDllsRegistryValues: Wrong format in '%s' string", szFileStr );
                    LogInfo( infoString );
                    continue;
                }
                *pComma = g_chEndOfLine;
                
                WCHAR szFullFileName[_MAX_PATH+1] = EMPTY_BUFFER;
                
                ::wcsncpy(szFullFileName, szDirPath, sizeof(szFullFileName)/sizeof(szFullFileName[0]));
                ::wcsncat(szFullFileName, L"\\", 1);
                ::wcsncat(szFullFileName, szFileStr, szFileStr - pComma);

                // update HKLM,software\microsoft\windows\currentversion\sharedlls value
                UpdateRegistryValue(hKey, szFullFileName);
            }
        }
    }

    // close SharedDlls regkey
    ::RegCloseKey(hKey);
}

//////////////////////////////////////////////////////////////////////////////
// UpdateRegistryValue
// Receives: VOID
// Returns : VOID
// Purpose : helper function for UpdateSharedDllsRegistryValues
VOID CUrtOcmSetup::UpdateRegistryValue( HKEY &hKey, const WCHAR* szFullFileName )
{
    if( szFullFileName == NULL )
    {
        assert( !L"UpdateRegistryValue: szFullFileName is NULL." );
        LogInfo(L"UpdateRegistryValue: szFullFileName is NULL.");
        return;
    }

    DWORD dwValue = 0;
    DWORD dwSize = sizeof(dwValue);
    DWORD dwRegType = REG_DWORD;
    if( ::RegQueryValueExW(
            hKey, 
            szFullFileName, 
            0, 
            &dwRegType, 
            (LPBYTE)&dwValue, 
            &dwSize ) != ERROR_SUCCESS )
    {
        // value does not exist, create a new value
        dwValue = 1;
        dwSize = sizeof(dwValue);
        if( ::RegSetValueExW(
                hKey, 
                szFullFileName, 
                0, 
                REG_DWORD, 
                (LPBYTE)&dwValue, 
                dwSize ) != ERROR_SUCCESS )
        {
            WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
            ::swprintf( 
                infoString, 
                L"Error: UpdateRegistryValue: Can't set value to the new reg key %s", 
                szFullFileName );
            LogInfo( infoString );
        }
    }
    else
    {
        // update the value
        dwValue = dwValue + 1;
        dwSize = sizeof(dwValue);
        if( ::RegSetValueExW(
                hKey, 
                szFullFileName, 
                0, 
                REG_DWORD, 
                (LPBYTE)&dwValue, 
                dwSize ) != ERROR_SUCCESS )
        {
            WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
            ::swprintf( 
                infoString, 
                L"Error: UpdateSharedDllsRegistryValues: Can't set value to the existing reg key %s", 
                szFullFileName );
            LogInfo( infoString );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// IISAndASPNETInstalled
// Receives: VOID
// Returns : BOOL
// Purpose : helper function for OnCompleteInstallation
// return true if previous version of ASP.NET is installed and IIS is installed  
BOOL CUrtOcmSetup::IISAndASPNETInstalled()
{
   
    // check if ASP.NET is installed
    HKEY  hk;
    if (::RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\ASP.NET"), 0, KEY_READ, &hk) != ERROR_SUCCESS)
    {
        // ASP.NET is not installed
        LogInfo( L"IISAndASPNETInstalled() - ASP.NET is not installed" );
        return FALSE;
    }
    else
    {
        LogInfo( L"IISAndASPNETInstalled() - ASP.NET is installed" );
    }
    ::RegCloseKey(hk);

    // check if IIS is installed
    BOOL bIIS = TRUE;
    LONG res = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\W3SVC\\Parameters"), 0, KEY_READ, &hk);
    if (res != ERROR_SUCCESS)
    {
        bIIS = FALSE;
    }
    else 
    {
        // check if MajorVersion regValue exists
        if (::RegQueryValueEx(hk, _T("MajorVersion"), 0, NULL, NULL, NULL) != ERROR_SUCCESS)
        {
            bIIS = FALSE;
        }
    }
    ::RegCloseKey(hk);

    if (!bIIS)
    {
        // IIS is not installed
        LogInfo( L"IISAndASPNETInstalled() - IIS is not installed" );
        return FALSE;
    }
    else
    {
        LogInfo( L"IISAndASPNETInstalled() - IIS is installed" );
    }          
    
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// Helper function: GetOriginalState
// Receives: LPCTSTR - Subcomponent id
// Returns : BOOL
// Purpose : helper function returns the original state of the component  
BOOL CUrtOcmSetup::GetOriginalState(LPCTSTR szComp)
{
    OCMANAGER_ROUTINES ohr = m_InitComponent.HelperRoutines;
    if ( ohr.QuerySelectionState( ohr.OcManagerContext, szComp, OCSELSTATETYPE_ORIGINAL ))
    {
        LogInfo( L"GetOriginalState()- original state is 1" );
        return TRUE;
    }
    else
    {
        LogInfo( L"GetOriginalState()- original state is 0" );
        return FALSE;
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helper function: GetNewState
// Receives: LPCTSTR - Subcomponent id
// Returns : BOOL
// Purpose : helper function returns the new state of the component  
BOOL CUrtOcmSetup::GetNewState(LPCTSTR szComp)
{
    OCMANAGER_ROUTINES ohr = m_InitComponent.HelperRoutines;
    if ( ohr.QuerySelectionState( ohr.OcManagerContext, szComp, OCSELSTATETYPE_CURRENT ))
    {
        LogInfo( L"GetNewState()- New state is 1" );
        return TRUE;
    }
    else
    {
        LogInfo( L"GetNewState()- New state is 0" );
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\isadmin.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: isadmin.cpp
//
// Abstract:
//    function checks if user is an administrator ... derived from MSDN
//
// Author: a-mshn

//
// Notes:
//

#include <windows.h>
#include <stdio.h>

// 
// Make up some private access rights.
// 
#define ACCESS_READ  1
#define ACCESS_WRITE 2

// This function checks the token of the calling thread to see if the caller belongs to
// the Administrators group.
//
BOOL IsAdmin(void) {

   HANDLE hToken = NULL;
   DWORD  dwStatus;
   DWORD  dwAccessMask;
   DWORD  dwAccessDesired;
   DWORD  dwACLSize;
   DWORD  dwStructureSize = sizeof(PRIVILEGE_SET);
   PACL   pACL            = NULL;
   PSID   psidAdmin       = NULL;
   BOOL   bReturn         = FALSE;

   PRIVILEGE_SET   ps;
   GENERIC_MAPPING GenericMapping;

   PSECURITY_DESCRIPTOR     psdAdmin           = NULL;
   SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
   
   __try {

      // AccessCheck() requires an impersonation token.
      ImpersonateSelf(SecurityImpersonation);

      if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {

         if (GetLastError() != ERROR_NO_TOKEN)
            __leave;

         // If the thread does not have an access token, we'll 
         // examine the access token associated with the process.
         if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
            __leave;
      }

      if (!AllocateAndInitializeSid(&SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin))
         __leave;

      psdAdmin = LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
      if (psdAdmin == NULL)
         __leave;

      if (!InitializeSecurityDescriptor(psdAdmin,
            SECURITY_DESCRIPTOR_REVISION))
         __leave;
  
      // Compute size needed for the ACL.
      dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + 
				  GetLengthSid(psidAdmin) - sizeof(DWORD);

      // Allocate memory for ACL.
      pACL = (PACL)LocalAlloc(LPTR, dwACLSize);
      if (pACL == NULL)
         __leave;

      // Initialize the new ACL.
      if (!InitializeAcl(pACL, dwACLSize, ACL_REVISION2))
         __leave;

      dwAccessMask= ACCESS_READ | ACCESS_WRITE;
      
      // Add the access-allowed ACE to the DACL.
      if (!AddAccessAllowedAce(pACL, ACL_REVISION2, dwAccessMask, psidAdmin))
         __leave;

      // Set our DACL to the SD.
      if (!SetSecurityDescriptorDacl(psdAdmin, TRUE, pACL, FALSE))
         __leave;

      // AccessCheck is sensitive about what is in the SD; set
      // the group and owner.
      SetSecurityDescriptorGroup(psdAdmin, psidAdmin, FALSE);
      SetSecurityDescriptorOwner(psdAdmin, psidAdmin, FALSE);

      if (!IsValidSecurityDescriptor(psdAdmin))
         __leave;

      dwAccessDesired = ACCESS_READ;

      // 
      // Initialize GenericMapping structure even though we
      // won't be using generic rights.
      // 
      GenericMapping.GenericRead    = ACCESS_READ;
      GenericMapping.GenericWrite   = ACCESS_WRITE;
      GenericMapping.GenericExecute = 0;
      GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;

      if (!AccessCheck(psdAdmin, hToken, dwAccessDesired, 
          &GenericMapping, &ps, &dwStructureSize, &dwStatus, &bReturn)) 
         __leave;

      RevertToSelf();
   
   } __finally {

      // Cleanup 
       if (pACL != NULL)
       {
           LocalFree(pACL);
       }
       if (psdAdmin != NULL)
       {
           LocalFree(psdAdmin);  
       }
       if (psidAdmin != NULL)
       {
           FreeSid(psidAdmin);
       }
       if (hToken != NULL)
       {
           CloseHandle( hToken);
       }
   }

   return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\aspnetocm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: aspnetocm.h
//
// Abstract:
//    class declarations for setup object
//
// Author: A-MariaS
//
// Notes:
//

#if !defined( CURTOCMSETUP_H )
#define CURTOCMSETUP_H

#include "globals.h"
#include "infhelpers.h"

// global instance handle
extern HMODULE g_hInstance;

extern BOOL g_bIsAdmin;

const DWORD UNRECOGNIZED = 0;
const DWORD DEFAULT_RETURN = 0;

//for use in ChangeSelectionState calls
const UINT  NOT_SELECTED = 0;
const UINT  SELECTED     = 1;


class CUrtOcmSetup
{
public:
    CUrtOcmSetup();

    DWORD OcmSetupProc( LPCTSTR ComponentId,
                        LPCTSTR SubcomponentId,
                        UINT    Function,
                        UINT    Param1,
                        PVOID   Param2 );

private:
    //handler methods
    //
    DWORD OnPreInitialize( UINT uiCharWidth );
    DWORD InitializeComponent( PSETUP_INIT_COMPONENT pSetupInitComponent );
    DWORD OnSetLanguage( UINT uiLangID );
    DWORD OnQueryImage( UINT uiImage, DWORD dwImageSize);
    DWORD OnRequestPages( PSETUP_REQUEST_PAGES prpPages );
    DWORD OnQuerySkipPage( OcManagerPage ocmpPage );
    DWORD OnQueryChangeSelectionState( UINT uiNewState, UINT flags, LPCTSTR szComp );
    DWORD OnCalculateDiskSpace( UINT uiAdd, HDSKSPC hdSpace, LPCTSTR szComp );
    DWORD OnQueueFileOperations( LPCTSTR szComp, HSPFILEQ pvHFile );
    DWORD OnNeedMedia( VOID );
    DWORD OnQueryStepCount( LPCTSTR szSubCompId );
    DWORD OnAboutToCommitQueue( LPCTSTR szComp );
    DWORD OnCompleteInstallation( LPCTSTR szComp );
    DWORD OnCleanup( VOID );
    DWORD OnNotificationFromQueue( VOID );
    DWORD OnFileBusy( VOID );
    DWORD OnQueryError( VOID );
    DWORD OnPrivateBase( VOID );
    DWORD OnQueryState( UINT uiState );
    DWORD OnWizardCreated( VOID );
    DWORD OnExtraRoutines( VOID );

    //helper methods
    //
    // loads current selection state info into "state" and
    // returns whether the selection state was changed
    BOOL StateInfo( LPCTSTR szCompName, BOOL* state );
    BOOL GetOriginalState(LPCTSTR szComp);
    BOOL GetNewState(LPCTSTR szComp);
       
    // update HKLM,software\microsoft\windows\currentversion\sharedlls
    // registry values, for all files that we copy
    VOID UpdateSharedDllsRegistryValues(LPCTSTR szInstallSection);
    VOID UpdateRegistryValue( HKEY &hKey, const WCHAR* szFullFileName );

    VOID GetAndRunCustomActions( const WCHAR* szSection, BOOL fInstall );

    // write a string to the logFile (m_csLogFileName) with the date and time stamps
    VOID LogInfo( LPCTSTR szInfo );

    // CreateProcess and execute the CA
    // implementation is in QuetExec.cpp
    UINT QuietExec( const WCHAR* const szInstallArg );

    //Parse input args
    // expecting something like
    // "exe-file and arguments, unused, path to add as temp env. var"
    // parameters:
    // [in/out] pszString: will contain everything before first comma
    // [out] pPath:        will contain everything after last comma
    VOID ParseArgument( WCHAR *pszString, WCHAR*& pPath );

    // breaks pszString to applicationName (exe-file) and command-line (exefile and arguments)
    // encloses exe-name in quotes (for commandLine only), if it is not quoted already 
    // removes quotes from applicationName if exe-name was quoted
    // returns false if caString is in wrong format (contains one quote only, has no exe-name, etc)
    // Parameters:
    //          [in] pszString - string containing exe-name and arguments
    //                           "my.exe" arg1, arg2
    //                            
    //          [out] pszApplicationName - will contain exe-name
    //          [out] pszCommandLine - same as caString with exe-name qouted
    
    // for example if pszString = "my.exe" arg1 arg2 (OR pszString = my.exe arg1 arg2)
    // then 
    //       pszApplicationName = my.exe 
    //       pszCommandLine = "my.exe" arg1 arg2
    BOOL GetApplicationName( const WCHAR* pszString, 
                             WCHAR* pszApplicationName, 
                             WCHAR* pszCommandLine );

    // helper function:
    // breaks command-line to applicationName and arguments 
    // for path that begins with quote (pszString = "my.exe" arg1 arg2)
    BOOL GetApplicationNameFromQuotedString( const WCHAR* pszString, 
                                             WCHAR* pszApplicationName, 
                                             WCHAR* pszCommandLine );
    // helper function:
    // breaks command-line to applicationName and arguments 
    // for path that does NOT begin with quote (pszString = my.exe arg1 arg2)
    BOOL GetApplicationNameFromNonQuotedString( const WCHAR* pszString, 
                                                WCHAR* pszApplicationName, 
                                                WCHAR* pszCommandLine );
    // helper function:
    // return TRUE if last 4 characters before pBlank are ".exe"
    // return FALSE otherwise
    BOOL IsExeExtention(const WCHAR* pszString, WCHAR *pBlank);

    // helper function for OnCompleteInstallation
    // return true if previous version of ASP.NET is installed and IIS is installed
    BOOL IISAndASPNETInstalled();

    //data
    //
    WORD m_wLang;

    SETUP_INIT_COMPONENT m_InitComponent;

    WCHAR m_csLogFileName[MAX_PATH+1];


}; //class CUrtOcmSetup




#endif  //CURTOCMSETUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\makefile.inc ===
# additional dependencies

aspnet_ocm:
       @if not exist $(TARGETCORBIN)\$(_TGTCPU)                            mkdir $(TARGETCORBIN)\$(_TGTCPU)
       @if not exist $(TARGETCORBIN)\$(_TGTCPU)\$(DDKBUILDENV)             mkdir $(TARGETCORBIN)\$(_TGTCPU)\$(DDKBUILDENV)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: Main.cpp
//
// Abstract:
//    DLL entry for universal runtime ocm setup
//
// Author: JoeA
//
// Notes:
//

#include <windows.h>
#include <tchar.h>
#include "aspnetocm.h"

//global instance handle
//
HMODULE g_hInstance = NULL;

//instance of the setup
//
CUrtOcmSetup uoSetup;



/////////////////////////////////////////////////////////////////////////////
// DllMain
// Receives: HINSTANCE - handle to the DLL Module
//           DWORD     - reason for calling fuction
//           LPVOID    - reserved
// Returns:  TRUE      - no initialization to fail
//
// Purpose: DLL entry point
//
extern "C" BOOL WINAPI DllMain( 
                                IN HINSTANCE  hInstance, 
                                IN DWORD      dwReason, 
                                IN LPVOID     lpReserved )
{

   UNREFERENCED_PARAMETER( lpReserved );

   switch( dwReason )
   {
      case DLL_PROCESS_ATTACH:

         g_hInstance = ( HINSTANCE )hInstance;

         break;

      case DLL_PROCESS_DETACH:

         break;

      default:

         break;
   }

   // check if user is an administrator
   g_bIsAdmin = IsAdmin();

   return TRUE;

} //DllMain




/////////////////////////////////////////////////////////////////////////////
// AspnetOcmProc
// Receives: LPCTSTR - component name from the INF
//           LPCTSTR - subcomponent name where appropriate
//           UINT    - function to switch on
//           UINT    - function-specific values
//           PVOID   - function-specific values
// Returns:  DWORD   - 0 if function unrecognized, else function-specific
//
// Purpose: OCM callback ... see ocm documentation for complete description
//

#include "globals.h"

extern "C" DWORD CALLBACK AspnetOcmProc(
                             IN     LPCTSTR szComponentId,
                             IN     LPCTSTR szSubcomponentId,
                             IN     UINT    uiFunction,
                             IN     UINT    uiParam1,
                             IN OUT PVOID   pvParam2 )
{
    return uoSetup.OcmSetupProc( 
        szComponentId,
        szSubcomponentId,
        uiFunction,
        uiParam1,
        pvParam2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\ocmanage.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    ocmanage.h

Abstract:

    Public header file for Optional Component Manager.

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif

//
// Define type for optional component setup dll interface entry point.
// Note the strings are declared with VOID typing since we don't
// know in advance what the character width is.
//
typedef
DWORD
(*POCSETUPPROC) (
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    );

//
// Define interface function codes.
//
#define OC_PREINITIALIZE                0x00000000
#define OC_INIT_COMPONENT               0x00000001
#define OC_SET_LANGUAGE                 0x00000002
#define OC_QUERY_IMAGE                  0x00000003
#define OC_REQUEST_PAGES                0x00000004
#define OC_QUERY_CHANGE_SEL_STATE       0x00000005
#define OC_CALC_DISK_SPACE              0x00000006
#define OC_QUEUE_FILE_OPS               0x00000007
#define OC_NOTIFICATION_FROM_QUEUE      0x00000008
#define OC_QUERY_STEP_COUNT             0x00000009
#define OC_COMPLETE_INSTALLATION        0x0000000a
#define OC_CLEANUP                      0x0000000b
#define OC_QUERY_STATE                  0x0000000c
#define OC_NEED_MEDIA                   0x0000000d
#define OC_ABOUT_TO_COMMIT_QUEUE        0x0000000e
#define OC_QUERY_SKIP_PAGE              0x0000000f
#define OC_WIZARD_CREATED               0x00000010
#define OC_FILE_BUSY                    0x00000011
#define OC_EXTRA_ROUTINES               0x00000012
#define OC_QUERY_IMAGE_EX               0x00000013

#define OC_QUERY_ERROR                  0x000000FF  // dead

//#define OC_OSSETUP_GET_WIZARD_TITLE     0x00000400
//#define OC_OSSETUP_GET_COMPUTER_NAME    0x00000401
//#define OC_OSSETUP_GET_SERVER_TYPE      0x00000402

#define OC_PRIVATE_BASE                 0x00010000

//
// Define OC Manager directory IDs, available in per-component INFs.
//
#define DIRID_OCM_MASTERINF             987654321       // full path
#define DIRID_OCM_PLATFORM              987654322       // alpha, i386, etc
#define DIRID_OCM_PLATFORM_ALTERNATE    987654323       // alpha, x86, etc
#define DIRID_OCM_COMPONENT             987654324       // component shortname


//
// Define structure used as a table of helper/callback entry points
// into the OC Manager, and the associated function prototypes.
//
typedef
VOID
(CALLBACK *PTICKGAUGE_ROUTINE) (
    IN PVOID OcManagerContext
    );

typedef
VOID
(CALLBACK *PSETPROGRESSTEXT_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR Text
    );

typedef
VOID
(CALLBACK *PSETPROGRESSTEXT_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR Text
    );

typedef
UINT
(CALLBACK *PSETPRIVATEDATA_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR Name,
    IN PVOID  Data,
    IN UINT   Size,
    IN UINT   Type
    );

typedef
UINT
(CALLBACK *PSETPRIVATEDATA_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR Name,
    IN PVOID   Data,
    IN UINT    Size,
    IN UINT    Type
    );

typedef
UINT
(CALLBACK *PGETPRIVATEDATA_ROUTINEA) (
    IN     PVOID  OcManagerContext,
    IN     LPCSTR ComponentId,
    IN     LPCSTR Name,
    OUT    PVOID  Data,         OPTIONAL
    IN OUT PUINT  Size,
    OUT    PUINT  Type
    );

typedef
UINT
(CALLBACK *PGETPRIVATEDATA_ROUTINEW) (
    IN     PVOID   OcManagerContext,
    IN     LPCWSTR ComponentId,
    IN     LPCWSTR Name,
    OUT    PVOID   Data,         OPTIONAL
    IN OUT PUINT   Size,
    OUT    PUINT   Type
    );

typedef
UINT
(CALLBACK *PSETSETUPMODE_ROUTINE) (
    IN PVOID OcManagerContext,
    IN DWORD SetupMode
    );

typedef
UINT
(CALLBACK *PGETSETUPMODE_ROUTINE) (
    IN PVOID OcManagerContext
    );

typedef
BOOL
(CALLBACK *PQUERYSELECTIONSTATE_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR SubcomponentId,
    IN UINT   StateType
    );

typedef
BOOL
(CALLBACK *PQUERYSELECTIONSTATE_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR SubcomponentId,
    IN UINT    StateType
    );

typedef
UINT
(CALLBACK *PCALLPRIVATEFUNCTION_ROUTINEA) (
    IN     PVOID  OcManagerContext,
    IN     LPCSTR ComponentId,
    IN     LPCSTR SubcomponentId,
    IN     UINT   Function,
    IN     UINT   Param1,
    IN OUT PVOID  Param2,
    OUT    PUINT  Result
    );

typedef
UINT
(CALLBACK *PCALLPRIVATEFUNCTION_ROUTINEW) (
    IN     PVOID   OcManagerContext,
    IN     LPCWSTR ComponentId,
    IN     LPCWSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2,
    OUT    PUINT   Result
    );

typedef
BOOL
(CALLBACK *PCONFIRMCANCEL_ROUTINE) (
    IN HWND ParentWindow
    );

typedef
HWND
(CALLBACK *PQUERYWIZARDDIALOGHANDLE_ROUTINE) (
    IN PVOID OcManagerContext
    );

typedef
BOOL
(CALLBACK *PSETREBOOT_ROUTINE) (
    IN PVOID OcManagerContext,
    IN BOOL  Reserved
    );

typedef
HINF
(CALLBACK *PGETINFHANDLE_ROUTINE) (
    IN UINT  InfIndex,
    IN PVOID OcManagerContext
    );

#define INFINDEX_UNATTENDED     1

typedef
BOOL
(__cdecl *PREPORTEXTERNALERROR_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR ComponentId,
    IN LPCSTR SubcomponentId,   OPTIONAL
    IN DWORD_PTR  MessageId,
    IN DWORD  Flags,
    ...
    );

typedef
BOOL
(__cdecl *PREPORTEXTERNALERROR_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR ComponentId,
    IN LPCWSTR SubcomponentId,  OPTIONAL
    IN DWORD_PTR   MessageId,
    IN DWORD   Flags,
    ...
    );

typedef
VOID 
(WINAPI *OCH_SHOWHIDEWIZARDPAGE)(
    IN PVOID   OcManagerContext,
    IN BOOL bShow
    );

#define ERRFLG_SYSTEM_MESSAGE   0x00000001
#define ERRFLG_IGNORE_INSERTS   0x00000002
#define ERRFLG_PREFORMATTED     0x00000004

typedef struct _OCMANAGER_ROUTINESA {
    PVOID OcManagerContext;
    PTICKGAUGE_ROUTINE TickGauge;
    PSETPROGRESSTEXT_ROUTINEA SetProgressText;
    PSETPRIVATEDATA_ROUTINEA SetPrivateData;
    PGETPRIVATEDATA_ROUTINEA GetPrivateData;
    PSETSETUPMODE_ROUTINE SetSetupMode;
    PGETSETUPMODE_ROUTINE GetSetupMode;
    PQUERYSELECTIONSTATE_ROUTINEA QuerySelectionState;
    PCALLPRIVATEFUNCTION_ROUTINEA CallPrivateFunction;
    PCONFIRMCANCEL_ROUTINE ConfirmCancelRoutine;
    PQUERYWIZARDDIALOGHANDLE_ROUTINE QueryWizardDialogHandle;
    PSETREBOOT_ROUTINE SetReboot;
    PGETINFHANDLE_ROUTINE GetInfHandle;
    PREPORTEXTERNALERROR_ROUTINEA ReportExternalError;
    OCH_SHOWHIDEWIZARDPAGE ShowHideWizardPage;
} OCMANAGER_ROUTINESA, *POCMANAGER_ROUTINESA;

typedef struct _OCMANAGER_ROUTINESW {
    PVOID OcManagerContext;
    PTICKGAUGE_ROUTINE TickGauge;
    PSETPROGRESSTEXT_ROUTINEW SetProgressText;
    PSETPRIVATEDATA_ROUTINEW SetPrivateData;
    PGETPRIVATEDATA_ROUTINEW GetPrivateData;
    PSETSETUPMODE_ROUTINE SetSetupMode;
    PGETSETUPMODE_ROUTINE GetSetupMode;
    PQUERYSELECTIONSTATE_ROUTINEW QuerySelectionState;
    PCALLPRIVATEFUNCTION_ROUTINEW CallPrivateFunction;
    PCONFIRMCANCEL_ROUTINE ConfirmCancelRoutine;
    PQUERYWIZARDDIALOGHANDLE_ROUTINE QueryWizardDialogHandle;
    PSETREBOOT_ROUTINE SetReboot;
    PGETINFHANDLE_ROUTINE GetInfHandle;
    PREPORTEXTERNALERROR_ROUTINEW ReportExternalError;
    OCH_SHOWHIDEWIZARDPAGE ShowHideWizardPage;
} OCMANAGER_ROUTINESW, *POCMANAGER_ROUTINESW;

#ifdef UNICODE
typedef OCMANAGER_ROUTINESW OCMANAGER_ROUTINES;
typedef POCMANAGER_ROUTINESW POCMANAGER_ROUTINES;
#else
typedef OCMANAGER_ROUTINESA OCMANAGER_ROUTINES;
typedef POCMANAGER_ROUTINESA POCMANAGER_ROUTINES;
#endif

typedef
BOOL
(__cdecl *PLOGERROR_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN DWORD  ErrorLevel,
    IN LPCSTR Msg,
    ...
    );

typedef
BOOL
(__cdecl *PLOGERROR_ROUTINEW) (
    IN PVOID  OcManagerContext,
    IN DWORD  ErrorLevel,
    IN LPCWSTR Msg,
    ...
    );

typedef struct _EXTRA_ROUTINESA {
    DWORD size;
    PLOGERROR_ROUTINEA LogError;
} EXTRA_ROUTINESA, *PEXTRA_ROUTINESA;

typedef struct _EXTRA_ROUTINESW {
    DWORD size;
    PLOGERROR_ROUTINEW LogError;
} EXTRA_ROUTINESW, *PEXTRA_ROUTINESW;

#ifdef UNICODE
typedef EXTRA_ROUTINESW EXTRA_ROUTINES;
typedef PEXTRA_ROUTINESW PEXTRA_ROUTINES;
#else
typedef EXTRA_ROUTINESA EXTRA_ROUTINES;
typedef PEXTRA_ROUTINESA PEXTRA_ROUTINES;
#endif


// for error handler

typedef enum {
    OcErrLevInfo    = 0x00000000,
    OcErrLevWarning = 0x01000000,
    OcErrLevError   = 0x02000000,
    OcErrLevFatal   = 0x03000000,
    OcErrLevMax     = 0x04000000,
    OcErrBatch      = 0x10000000,
    OcErrMask           = 0xFF000000
} OcErrorLevel;

//
// Flags.
//
#define OCFLAG_UNICODE  0x00000001
#define OCFLAG_ANSI     0x00000002

//
// master component flags
//
#define OCFLAG_NOWIZPAGES   0x00000001
#define OCFLAG_NOQUERYSKIP  0x00000002
#define OCFLAG_NOEXTRAFLAGS 0x00000004

//
// Selection state types (for QuerySelectionState and OC_QUERY_STATE).
//
#define OCSELSTATETYPE_ORIGINAL     0
#define OCSELSTATETYPE_CURRENT      1
#define OCSELSTATETYPE_FINAL        2

//
// Setup data structure. Passed within a SETUP_INIT_COMPONENT structure
// as OC_INIT_COMPONENT time.
//
typedef struct _SETUP_DATAA {
    DWORD SetupMode;
    DWORD ProductType;
    DWORDLONG OperationFlags;
    CHAR SourcePath[MAX_PATH];
    CHAR UnattendFile[MAX_PATH];
} SETUP_DATAA, *PSETUP_DATAA;

typedef struct _SETUP_DATAW {
    DWORD SetupMode;
    DWORD ProductType;
    DWORDLONG OperationFlags;
    WCHAR SourcePath[MAX_PATH];
    WCHAR UnattendFile[MAX_PATH];
} SETUP_DATAW, *PSETUP_DATAW;

#ifdef UNICODE
typedef SETUP_DATAW SETUP_DATA;
typedef PSETUP_DATAW PSETUP_DATA;
#else
typedef SETUP_DATAA SETUP_DATA;
typedef PSETUP_DATAA PSETUP_DATA;
#endif


//
// Values for SetupMode
//
#define SETUPMODE_UNKNOWN       (-1)
#define SETUPMODE_MINIMAL       0
#define SETUPMODE_TYPICAL       1
#define SETUPMODE_LAPTOP        2
#define SETUPMODE_CUSTOM        3

#define SETUPMODE_PRIVATE(x)    ((x) & SETUPMODE_PRIVATE_MASK)

//
// Predefined upgrade modes
//
#define SETUPMODE_UPGRADEONLY   0x20000100
#define SETUPMODE_ADDEXTRACOMPS 0x20000200

//
// Predefined mainteance modes
//
#define SETUPMODE_ADDREMOVE     0x10000100
#define SETUPMODE_REINSTALL     0x10000200
#define SETUPMODE_REMOVEALL     0x10000400

//
// Predefined fresh modes
//
#define SETUPMODE_FRESH         0x00000000
#define SETUPMODE_MAINTENANCE   0x10000000
#define SETUPMODE_UPGRADE       0x20000000

#define SETUPMODE_STANDARD_MASK 0x000000ff
#define SETUPMODE_PRIVATE_MASK  0xffffff00
//
// Flag for NeedMedia Callback, Ored in to
// Return code to allow NeedMedia to return
// FILEOP_ Return Codes
//
#define NEEDMEDIA_USEFILEOP     0x80000000


//
// Values for ProductType. Notice careful definitions
// such that low bit on means some kind of DC.
//
#define PRODUCT_WORKSTATION         0
#define PRODUCT_SERVER_PRIMARY      1
#define PRODUCT_SERVER_STANDALONE   2
#define PRODUCT_SERVER_SECONDARY    3

//
// Bit flags for OperationFlags. Note that this is a 64-bit field.
//
#define SETUPOP_WIN31UPGRADE        0x0000000000000001
#define SETUPOP_WIN95UPGRADE        0x0000000000000002
#define SETUPOP_NTUPGRADE           0x0000000000000004
#define SETUPOP_BATCH               0x0000000000000008
#define SETUPOP_STANDALONE          0x0000000000000010
#define SETUPOP_AMD64_FILES_AVAIL   0x0000000100000000
#define SETUPOP_OBSOLETE1_FILES_AVAIL 0x0000000200000000 
#define SETUPOP_OBSOLETE2_FILES_AVAIL 0x0000000400000000
#define SETUPOP_X86_FILES_AVAIL     0x0000000800000000
#define SETUPOP_IA64_FILES_AVAIL    0x0000001000000000


//
// Component initialization structure, passed at OC_INIT_COMPONENT time.
//
typedef struct _SETUP_INIT_COMPONENTA {
    UINT OCManagerVersion;
    UINT ComponentVersion;
    HINF OCInfHandle;
    HINF ComponentInfHandle;
    SETUP_DATAA SetupData;
    OCMANAGER_ROUTINESA HelperRoutines;
} SETUP_INIT_COMPONENTA, *PSETUP_INIT_COMPONENTA;

typedef struct _SETUP_INIT_COMPONENTW {
    UINT OCManagerVersion;
    UINT ComponentVersion;
    HINF OCInfHandle;
    HINF ComponentInfHandle;
    SETUP_DATAW SetupData;
    OCMANAGER_ROUTINESW HelperRoutines;
} SETUP_INIT_COMPONENTW, *PSETUP_INIT_COMPONENTW;

#ifdef UNICODE
typedef SETUP_INIT_COMPONENTW SETUP_INIT_COMPONENT;
typedef PSETUP_INIT_COMPONENTW PSETUP_INIT_COMPONENT;
#else
typedef SETUP_INIT_COMPONENTA SETUP_INIT_COMPONENT;
typedef PSETUP_INIT_COMPONENTA PSETUP_INIT_COMPONENT;
#endif

//
// Current OC Manager version, major and minor.
//
#define OCVER_MAJOR     5
#define OCVER_MINOR     0

#define OCMANAGER_VERSION   ((DWORD)MAKELONG(OCVER_MINOR,OCVER_MAJOR))

//
// Wizard page request structure, used with OC_REQUEST_PAGES.
//
typedef struct _SETUP_REQUEST_PAGES {
    UINT MaxPages;
    HPROPSHEETPAGE Pages[ANYSIZE_ARRAY];
} SETUP_REQUEST_PAGES, *PSETUP_REQUEST_PAGES;


//
// Flags used in Param2 of OC_QUERY_CHANGE_SEL_STATE notification
//
#define OCQ_ACTUAL_SELECTION    0x00000001
#define OCQ_DEPENDENT_SELECTION 0x80000000

//
// Enumerated types.
//

typedef enum {
    SubCompInfoSmallIcon,   // the small icon associated with the subcomponent
    SubCompInfoWatermark    // the watermark image at the top of the wizard
} SubComponentInfo;

typedef struct _OC_QUERY_IMAGE_INFO {
        DWORD   SizeOfStruct;
        SubComponentInfo ComponentInfo;
    UINT    DesiredWidth;      
    UINT    DesiredHeight;
} OC_QUERY_IMAGE_INFO, *POC_QUERY_IMAGE_INFO;


typedef enum {
    WizPagesWelcome,        // welcome page
    WizPagesMode,           // setup mode page
    WizPagesEarly,          // pages that come after the mode page and before prenet pages
    WizPagesPrenet,         // pages that come before network setup
    WizPagesPostnet,        // pages that come after network setup
    WizPagesLate,           // pages that come after postnet pages and before the final page
    WizPagesFinal,          // final page
    WizPagesTypeMax
} WizardPagesType;

typedef enum {
    SubcompUseOcManagerDefault,
    SubcompOn,
    SubcompOff
} SubComponentState;

typedef enum {
    OcPageComponentHierarchy,
    OcPageMax
} OcManagerPage;


// use the assert from SetupAPI
#define sapiAssert MYASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\infhelpers.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: infhelpers.cpp
//
// Abstract:
//    class definitions for inf setup helper objects
//
// Author: JoeA
//
// Notes:
//

#include "infhelpers.h"



//////////////////////////////////////////////////////////////////////////////
// CUrtInfSection
// Purpose : Constructor
//
CUrtInfSection::CUrtInfSection( 
                               const HINF hInfName, 
                               const WCHAR* szInfSection, 
                               const WCHAR* szInfKey )
{
    if( hInfName == NULL )
    {
        assert( !L"CUrtInfSection::CUrtInfSection((): Invalid handle to INF file." );
    }

    ::ZeroMemory( m_szSections, sizeof( m_szSections ) );

    assert( NULL != szInfSection );
    assert( NULL != szInfKey );
    assert( m_lSections.empty() );

    DWORD dwResultSize = 0;

    //get the specified line
    //
    SetupGetLineText(
        0,
        hInfName,
        szInfSection,
        szInfKey,
        m_szSections,
        countof( m_szSections ),
        &dwResultSize );

    WCHAR* pStart = m_szSections;
    WCHAR* pEnd = m_szSections;
    BOOL fMoreData = FALSE;

    //parse the line and set a pointer to
    // the beginning of each substring
    while( g_chEndOfLine != *pStart )
    {
        while( g_chEndOfLine != *pEnd &&
               g_chSectionDelim  != *pEnd )
        {
            pEnd = ::CharNext( pEnd );
        }

        if( g_chSectionDelim == *pEnd )
        {
            fMoreData = TRUE;
        }

        m_lSections.push_back( pStart );

        if( fMoreData )
        {
            pStart = CharNext( pEnd );
            *pEnd = g_chEndOfLine;
            pEnd = pStart;

            fMoreData = FALSE;
        }
        else
        {
            pStart = pEnd;
        }
    }
}


//////////////////////////////////////////////////////////////////////////////
// CUrtInfSection
// Purpose : Destructor
//
CUrtInfSection::~CUrtInfSection()
{
      m_lSections.clear();
}


//////////////////////////////////////////////////////////////////////////////
// item
// Receives: UINT   - index or number of item desired
// Returns : WCHAR* - value at that item
// Purpose : Returns the item indexed by the UINT. 
//           This is one-based (vs. zero-based)
//
const WCHAR* CUrtInfSection::item( const UINT ui )
{
    if( 1 > ui )
    {
        return L"";
    }

    std::list<WCHAR*>::iterator it = m_lSections.begin();

    for( UINT i = 1; i < ui; ++i  )
    {
        ++it;
    }

    return *it;
}





//////////////////////////////////////////////////////////////////////////////
// CUrtInfKeys
// Purpose : Constructor
//
CUrtInfKeys::CUrtInfKeys( const HINF hInfName, const WCHAR* szInfSection )
{
    if( hInfName == NULL )
    {
        assert( !L"CUrtInfKeys::CUrtInfKeys((): Invalid handle to INF file." );
    }

    WCHAR szLine[2*_MAX_PATH+1] = EMPTY_BUFFER;
    DWORD dwRequiredSize = 0;
    INFCONTEXT Context;

    //get the context
    //
    BOOL fMoreFiles = SetupFindFirstLine(
        hInfName, 
        szInfSection,
        NULL, 
        &Context );

    while( fMoreFiles )
    {
        //get size
        //
        fMoreFiles = SetupGetLineText(
            &Context, 
            NULL, 
            NULL, 
            NULL, 
            NULL, 
            0, 
            &dwRequiredSize );

        if( dwRequiredSize > countof( szLine ) )
        {
            assert( !L"CUrtInfKeys::CUrtInfKeys() error! Buffer overrun!" );
        }


        //get the line and save it off 
        //
        if( SetupGetLineText(
            &Context, 
            NULL, 
            NULL, 
            NULL, 
            szLine, 
            dwRequiredSize, 
            NULL ) )
        {
            m_lKeys.push_back( string( szLine ) );
        }
 
        fMoreFiles = SetupFindNextLine( &Context, &Context );
   }
}


//////////////////////////////////////////////////////////////////////////////
// CUrtInfKeys
// Purpose : Destructor
//
CUrtInfKeys::~CUrtInfKeys()
{
    m_lKeys.clear();
}


//////////////////////////////////////////////////////////////////////////////
// item
// Receives: UINT   - index or number of item desired
// Returns : WCHAR* - value at that item
// Purpose : Returns the item indexed by the UINT. 
//           This is one-based (vs. zero-based)
//
const WCHAR* CUrtInfKeys::item( const UINT ui )
{
    if( 1 > ui )
    {
        return L"";
    }

    std::list<string>::iterator it = m_lKeys.begin();

    for( UINT i = 1; i < ui; ++i  )
    {
        ++it;
    }

    return (*it).c_str();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\processenvvar.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: processenvvar.h
//
// Abstract:
//    class CProcessEnvVar (class for handling the environment variable changes)
//
// Author: a-mshn
//
// Notes:
//

#if !defined( PROCESSENVVAR_H )
#define PROCESSENVVAR_H

#include "globals.h"
#include <string>
#include <wchar.h>

#ifdef _UNICODE
	typedef std::basic_string<wchar_t> tstring;
#else
	typedef std::basic_string<char> tstring;
#endif

class CProcessEnvVar
{
public:
    // constructor
    CProcessEnvVar( const TCHAR* pwz );
    ~CProcessEnvVar() {};

    // copy constructor
    CProcessEnvVar( const CProcessEnvVar& procEnvVar );

    CProcessEnvVar& operator+=( const TCHAR* pwz );

    // append: appends the EnvVar (the same as +=)
    CProcessEnvVar& Append( const TCHAR* pwz );

    // prepends the EnvVar
    CProcessEnvVar& Prepend( const TCHAR* pwz );

    // returns current EnvVar
    const tstring& GetData( VOID ) const ;

    // restores original EnvVar
    BOOL RestoreOrigData( VOID );

    VOID LogInfo( LPCTSTR szInfo );

private:
    // sets environment variable
    BOOL SetEnvVar( const TCHAR* pwz );

    tstring         m_strEnvVar;
    tstring         m_strOrigData;
    tstring         m_strCurrentData;

    bool            m_bEnvVarChanged;
};

#endif // PROCESSENVVAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\isadmin.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: isadmin.cpp
//
// Abstract:
//    function checks if user is an administrator ... derived from MSDN
//
// Author: a-mshn

//
// Notes:
//

#include <windows.h>
#include <stdio.h>

// 
// Make up some private access rights.
// 
#define ACCESS_READ  1
#define ACCESS_WRITE 2

// This function checks the token of the calling thread to see if the caller belongs to
// the Administrators group.
//
BOOL IsAdmin(void) {

   HANDLE hToken = NULL;
   DWORD  dwStatus;
   DWORD  dwAccessMask;
   DWORD  dwAccessDesired;
   DWORD  dwACLSize;
   DWORD  dwStructureSize = sizeof(PRIVILEGE_SET);
   PACL   pACL            = NULL;
   PSID   psidAdmin       = NULL;
   BOOL   bReturn         = FALSE;

   PRIVILEGE_SET   ps;
   GENERIC_MAPPING GenericMapping;

   PSECURITY_DESCRIPTOR     psdAdmin           = NULL;
   SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
   
   __try {

      // AccessCheck() requires an impersonation token.
      ImpersonateSelf(SecurityImpersonation);

      if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {

         if (GetLastError() != ERROR_NO_TOKEN)
            __leave;

         // If the thread does not have an access token, we'll 
         // examine the access token associated with the process.
         if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
            __leave;
      }

      if (!AllocateAndInitializeSid(&SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin))
         __leave;

      psdAdmin = LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
      if (psdAdmin == NULL)
         __leave;

      if (!InitializeSecurityDescriptor(psdAdmin,
            SECURITY_DESCRIPTOR_REVISION))
         __leave;
  
      // Compute size needed for the ACL.
      dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + 
				  GetLengthSid(psidAdmin) - sizeof(DWORD);

      // Allocate memory for ACL.
      pACL = (PACL)LocalAlloc(LPTR, dwACLSize);
      if (pACL == NULL)
         __leave;

      // Initialize the new ACL.
      if (!InitializeAcl(pACL, dwACLSize, ACL_REVISION2))
         __leave;

      dwAccessMask= ACCESS_READ | ACCESS_WRITE;
      
      // Add the access-allowed ACE to the DACL.
      if (!AddAccessAllowedAce(pACL, ACL_REVISION2, dwAccessMask, psidAdmin))
         __leave;

      // Set our DACL to the SD.
      if (!SetSecurityDescriptorDacl(psdAdmin, TRUE, pACL, FALSE))
         __leave;

      // AccessCheck is sensitive about what is in the SD; set
      // the group and owner.
      SetSecurityDescriptorGroup(psdAdmin, psidAdmin, FALSE);
      SetSecurityDescriptorOwner(psdAdmin, psidAdmin, FALSE);

      if (!IsValidSecurityDescriptor(psdAdmin))
         __leave;

      dwAccessDesired = ACCESS_READ;

      // 
      // Initialize GenericMapping structure even though we
      // won't be using generic rights.
      // 
      GenericMapping.GenericRead    = ACCESS_READ;
      GenericMapping.GenericWrite   = ACCESS_WRITE;
      GenericMapping.GenericExecute = 0;
      GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;

      if (!AccessCheck(psdAdmin, hToken, dwAccessDesired, 
          &GenericMapping, &ps, &dwStructureSize, &dwStatus, &bReturn)) 
         __leave;

      RevertToSelf();
   
   } __finally {

      // Cleanup 
       if (pACL != NULL)
       {
           LocalFree(pACL);
       }
       if (psdAdmin != NULL)
       {
           LocalFree(psdAdmin);  
       }
       if (psidAdmin != NULL)
       {
           FreeSid(psidAdmin);
       }
       if (hToken != NULL)
       {
           CloseHandle( hToken);
       }
   }

   return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\processenvvar.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: processenvvar.cpp
//
// Abstract:
//    implementation of CProcessEnvVar methods (class for handling the environment variable changes)
//
// Author: a-mshn
//
// Notes:
//

#include "processenvvar.h"

// implementation of CProcessEnvVar methods
CProcessEnvVar::CProcessEnvVar( const TCHAR* pwz ) : m_strEnvVar(pwz), m_bEnvVarChanged(false)
{
    DWORD dwRet = ::GetEnvironmentVariable( m_strEnvVar.c_str(), NULL, 0 );
    
    UINT cBufSize = dwRet+1;
    TCHAR* pBuffer = new TCHAR[cBufSize];
    ::ZeroMemory( pBuffer, cBufSize * sizeof(TCHAR) );
    
    dwRet = ::GetEnvironmentVariable( m_strEnvVar.c_str(), pBuffer, cBufSize );
    assert( dwRet < cBufSize );
    
    m_strOrigData = pBuffer;
    m_strCurrentData = pBuffer;
    
    delete [] pBuffer;
}

// copy constructor
CProcessEnvVar::CProcessEnvVar( const CProcessEnvVar& procEnvVar )
{
    m_strOrigData = procEnvVar.m_strOrigData;
    m_strCurrentData = procEnvVar.m_strCurrentData;
    m_strEnvVar = procEnvVar.m_strEnvVar;
    m_bEnvVarChanged = procEnvVar.m_bEnvVarChanged;
}

// append the EnvVar
CProcessEnvVar& CProcessEnvVar::operator+=( const TCHAR* pwz )
{
    return this->Append(pwz);
}

// append: appends the EnvVar (the same as +=)
CProcessEnvVar& CProcessEnvVar::Append( const TCHAR* pwz )
{
    m_strCurrentData += pwz;
    SetEnvVar( m_strCurrentData.c_str() );
    return *this;
}

// prepends the EnvVar
CProcessEnvVar& CProcessEnvVar::Prepend( const TCHAR* pwz )
{
    WCHAR infoString[10*_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"Env Path before prepending is %s", m_strCurrentData.c_str() );
    LogInfo( infoString );
    m_strCurrentData.insert( 0, _T( ";" ) );
    m_strCurrentData.insert( 0, pwz );
    SetEnvVar( m_strCurrentData.c_str() );
    ::swprintf( infoString, L"Env Path after prepending is %s", m_strCurrentData.c_str() );
    LogInfo( infoString );
    return *this;
}

// returns current EnvVar
const tstring& CProcessEnvVar::GetData( VOID ) const
{
    return m_strCurrentData;
}

// restores original EnvVar
BOOL CProcessEnvVar::RestoreOrigData( VOID )
{
    if (m_bEnvVarChanged)
    {
        return ::SetEnvironmentVariable( m_strEnvVar.c_str(), m_strOrigData.c_str() );
    }
    else
    {
        // path has not changed, nothing should be done
        return true;
    }
}

// set environment variable (helper method)
BOOL CProcessEnvVar::SetEnvVar( const TCHAR* pwz )
{
    m_bEnvVarChanged = true;
    return ::SetEnvironmentVariable( m_strEnvVar.c_str(), pwz );
}

VOID CProcessEnvVar::LogInfo( LPCTSTR szInfo )
{
    WCHAR csLogFileName[MAX_PATH+1];

    ::GetWindowsDirectory( csLogFileName, MAX_PATH );
    ::wcscat( csLogFileName, L"\\netfxocm.log" );

    FILE *logFile = NULL;

    if( NULL == csLogFileName )
    {
        assert( !L"CProcessEnvVar::LogInfo(): NULL string passed in." );
    }

    if( (logFile  = ::_wfopen( csLogFileName, L"a" )) != NULL )
    {
        WCHAR dbuffer[10] = EMPTY_BUFFER;
        WCHAR tbuffer[10] = EMPTY_BUFFER;
        
        ::_wstrdate( dbuffer );
        ::_wstrtime( tbuffer );

        ::fwprintf( logFile, L"[%s,%s] %s\n", dbuffer, tbuffer, szInfo );
        ::fclose( logFile );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by urtocm.rc
//
#define IDS_STRING1                     1
#define IDB_ASPNET_ICON                 12

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\globals.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: globals.h
//
// Abstract:    stuff to include in all headers
//
// Author:      JoeA
//
// Notes:
//

#if !defined( NETFX_GLOBALS_H )
#define NETFX_GLOBALS_H

#include <list>
#include <windows.h>
#include <setupapi.h>
#include <assert.h>
#include <ocmanage.h>
#include <tchar.h>
#include "ocmanage.h"


#define countof(x) (sizeof(x) / sizeof(x[0]))
#define BLOCK
#define EMPTY_BUFFER  { L'\0' }

#define  g_chEndOfLine     L'\0'
#define  g_chSectionDelim  L','
#define  MAX_SECTION_LENGTH 4000


BOOL IsAdmin(void);

#endif  //NETFX_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "NetFXOcm.dll"
#define VER_FILEDESCRIPTION_STR "Universal Runtime OCM Setup\0"
#define VER_ORIGFILENAME_STR    "netfxocm.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\aspnet\quietexec.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: quietexec.cpp
//
// Abstract:
//    function for launching custom actions ... derived from MSI code by jbae
//
// Author: JoeA
//
// Notes:
//

#include <windows.h>
#include <assert.h>
#include "globals.h"
#include "aspnetocm.h"
#include "processenvvar.h"

#ifdef DEBUG
#define VERIFY(exp) assert(exp)
#else
#define VERIFY(exp) exp
#endif


#define ERROR_FUNCTION_NOT_CALLED          1626L // Function could not be executed.
const WCHAR* const wczPathEnvVar = L"PATH";



UINT CUrtOcmSetup::QuietExec( const WCHAR* const szInstallArg )
{
    if( NULL == szInstallArg )
    {
        LogInfo( L"QuietExec Error! Input string null." );
        assert( !L"QuietExec Error! Input string null." );
        return E_POINTER;
    }

    //we may have to manipulate the string
    //
    WCHAR* pszString = NULL;
    VERIFY( pszString = ::_wcsdup( szInstallArg ) );

    BOOL  bReturnVal = FALSE;
    UINT  uRetCode   = ERROR_FUNCTION_NOT_CALLED;
    
    // get original path 
    CProcessEnvVar pathEnvVar(wczPathEnvVar);


    //Parse input args
    // expecting something like
    // mofcomp.exe C:\WINNT\Microsoft.NET\Framework\v7.1.0.9102\netfxcfgprov.mfl,netfxcfgprov.mfl,c:\winnt\system32\wbem
    // exe-file and arguments                                                   ,unused          ,path to add as temp env. var
    //
    WCHAR* pPath = NULL;
    ParseArgument( pszString, pPath);
    if ( pPath != NULL )
    {
        // change the path by prepending
        pathEnvVar.Prepend(pPath);
    }
    if ( pszString == NULL )
    {
        LogInfo( L"QuietExec Error! ParseArgument returned null." );
        assert( !L"QuietExec Error! ParseArgument returned null." );
        return E_POINTER;
    }

    
    //Create the process and wait on it if we're told to
    //
    STARTUPINFO  si ;
    ::ZeroMemory( &si, sizeof( si ) );
    si.cb = sizeof( si );

    // extract the aplication name 
    WCHAR pszApplicationName[_MAX_PATH+1] = EMPTY_BUFFER;
    WCHAR pszCommandLine[_MAX_PATH+1] = EMPTY_BUFFER;
    
    if (GetApplicationName(pszString, pszApplicationName, pszCommandLine))
    { 
        // consider special case: applicationName = mofcomp.exe, in this case change it to be
        // pPath\mofcomp.exe 
        if ( ::_wcsicmp(pszApplicationName, L"mofcomp.exe" ) == 0 && pPath )
        {
            ::wcscpy( pszApplicationName, pPath );
            ::wcscat( pszApplicationName, L"\\mofcomp.exe" );

            FILE *fp = ::_wfopen(pszApplicationName, L"r");

            if (!fp)
            {
                DWORD dwError = GetLastError();
                WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
                ::swprintf( infoString, 
                    L"fopen on file %s returned Last Error %d", pszApplicationName,
                    dwError );
                LogInfo ( infoString );
            }
            else
            {
                WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
                ::swprintf( infoString, 
                    L"file %s opened successfully", pszApplicationName);            
                LogInfo ( infoString );
                fclose(fp);
            }
            WCHAR pszArg[_MAX_PATH+1] = EMPTY_BUFFER;
            ::wcscpy( pszArg, pszCommandLine + 15 );
            int iLen = ::wcslen(pszArg);
            pszArg[iLen - 1] = L'\0';
            fp = ::_wfopen(pszArg, L"r");
            if (!fp)
            {
                DWORD dwError = GetLastError();
                WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
                ::swprintf( infoString, 
                    L"fopen on file %s returned Last Error %d", pszArg,
                    dwError );
                LogInfo ( infoString );
            }
            else
            {
                WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
                ::swprintf( infoString, 
                    L"file %s opened successfully", pszArg);            
                LogInfo ( infoString );
                fclose(fp);
            }
        }

        
        WCHAR pszInfoString[2*_MAX_PATH+1] = L"CUrtOcmSetup::QuietExec(): call CreateProcess: applicationName = ";
        ::wcscat( pszInfoString, pszApplicationName );
        ::wcscat( pszInfoString, L", command-line parameter = ");
        ::wcscat( pszInfoString, pszCommandLine );
        LogInfo ( pszInfoString );

        
        
        PROCESS_INFORMATION process_info ;
        bReturnVal = ::CreateProcess(
            pszApplicationName, 
            pszCommandLine, 
            NULL, 
            NULL, 
            FALSE, 
            DETACHED_PROCESS, 
            NULL, 
            NULL, 
            &si, 
            &process_info );
        
        
        if( bReturnVal )
        {
            DWORD dwExitCode = 0;

            ::CloseHandle( process_info.hThread );
            ::WaitForSingleObject( process_info.hProcess, INFINITE );
            ::GetExitCodeProcess( process_info.hProcess, &dwExitCode );
            ::CloseHandle( process_info.hProcess );

            if( dwExitCode == 0 )
            {
                uRetCode = ERROR_SUCCESS;
                LogInfo ( L"CUrtOcmSetup::QuietExec(): CreateProcess succeeded" );
            }
            else 
            {
                WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
                ::swprintf( infoString, 
                    L"CUrtOcmSetup::QuietExec(): GetExitCodeProcess returned termination status = %d", 
                    dwExitCode );
                LogInfo ( infoString );

                if (::wcsstr(pszCommandLine, L"mofcomp.exe") != 0)
                {
                    LogInfo(L"mofcompexe failed  - trying to call again with different parameters:");

                    WCHAR pszCommandLine2[_MAX_PATH+1] = EMPTY_BUFFER;
                    ::wcscpy( pszCommandLine2, L"\"" );
                    ::wcscat( pszCommandLine2, pPath );
                    ::wcscat( pszCommandLine2, L"\\");
                    ::wcscat( pszCommandLine2, pszCommandLine + 1);
                    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
                    ::swprintf( infoString, L"CL2 = %s", pszCommandLine2 );
                    LogInfo ( infoString );

                    // Running CreateProcess again
                    LogInfo(L"Second CreateProcess starteded");

                    PROCESS_INFORMATION process_info ;
                    bReturnVal = ::CreateProcess(
                        pszApplicationName, 
                        pszCommandLine2, 
                        NULL, 
                        NULL, 
                        FALSE, 
                        DETACHED_PROCESS, 
                        NULL, 
                        NULL, 
                        &si, 
                        &process_info );


                    if( bReturnVal )
                    {
                        DWORD dwExitCode = 0;

                        ::CloseHandle( process_info.hThread );
                        ::WaitForSingleObject( process_info.hProcess, INFINITE );
                        ::GetExitCodeProcess( process_info.hProcess, &dwExitCode );
                        ::CloseHandle( process_info.hProcess );

                        if( dwExitCode == 0 )
                        {
                            uRetCode = ERROR_SUCCESS;
                            LogInfo ( L"CUrtOcmSetup::QuietExec(): CreateProcess succeeded" );
                        }
                        else 
                        {
                            WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
                            ::swprintf( infoString, 
                                L"CUrtOcmSetup::QuietExec(): GetExitCodeProcess returned termination status = %d", 
                                dwExitCode );
                            LogInfo ( infoString );
                        }
                    }
                    LogInfo(L"Second CreateProcess finished");
                }
            }
        }
        else
        {
            DWORD dwError = GetLastError();

            WCHAR pszInfoString[_MAX_PATH+1];
            ::swprintf( pszInfoString, 
                L"CUrtOcmSetup::QuietExec(): CreateProcess failed, GetLastError = %d", 
                dwError );
            LogInfo( pszInfoString );
        }    
    } 
    else // GetApplicationName returned false
    {
        WCHAR pszInfoString[2*_MAX_PATH+1] = L"Invalid format in ";
        ::wcscat( pszInfoString, pszString );
        LogInfo ( pszInfoString );  
    }

    // restore the path
    pathEnvVar.RestoreOrigData();
   
    ::free ( pszString );
    return uRetCode;
}

// breaks pszString to applicationName (exe-file) and command-line (exefile and arguments)
// encloses exe-name in quotes (for commandLine only), if it is not quoted already 
// removes quotes from applicationName if exe-name was quoted
// returns false if caString is in wrong format (contains one quote only, has no exe-name, etc)
// Parameters:
//          [in] pszString - string containing exe-name and arguments
//                           "my.exe" arg1, arg2
//                            
//          [out] pszApplicationName - will contain exe-name
//          [out] pszCommandLine - same as caString with exe-name qouted

// for example if pszString = "my.exe" arg1 arg2 (OR pszString = my.exe arg1 arg2)
// then 
//       pszApplicationName = my.exe 
//       pszCommandLine = "my.exe" arg1 arg2
BOOL CUrtOcmSetup::GetApplicationName( const WCHAR* pszString, 
                                      WCHAR* pszApplicationName, 
                                      WCHAR* pszCommandLine )
{
    
    BOOL bRes = FALSE;

    if ( pszString == NULL )
    {
        LogInfo( L"GetApplicationName Error! pszString is null." );
        assert( !L"GetApplicationName Error! pszString is null." );
        return bRes;
    }


    if ( pszString && pszString[0] == L'\"' )
    {
        bRes  = GetApplicationNameFromQuotedString(pszString, 
                                                   pszApplicationName, 
                                                   pszCommandLine);
    }
    else
    {
        bRes  = GetApplicationNameFromNonQuotedString(pszString, 
                                                      pszApplicationName, 
                                                      pszCommandLine);
    }
    
    return bRes;
}


// helper function
// breaks command-line to applicationName and arguments 
// for path begins with quote (pszString = "my.exe" arg1 arg2)
BOOL CUrtOcmSetup::GetApplicationNameFromQuotedString( const WCHAR* pszString, 
                                                       WCHAR* pszApplicationName, 
                                                       WCHAR* pszCommandLine )
{
    // command line begins with qoute:
    // make commandLine to be equal to caString,
    // applName should contain exe-name without quotes
    ::wcscpy( pszCommandLine, pszString );
    
    // copy beginning with next symbol after quote
    ::wcscpy( pszApplicationName, &pszString[1] );
    
    // search for the second quote, assign to applName
    WCHAR* pQuotes = ::wcschr( pszApplicationName, L'\"' );
    if ( pQuotes != NULL )
    {
        *pQuotes = g_chEndOfLine;
        return TRUE;
    }
    else 
    {
        return FALSE;
    }
}


// helper function:
// breaks command-line to applicationName and arguments 
// for path that does NOT begin with quote (pszString = my.exe arg1 arg2)
BOOL CUrtOcmSetup::GetApplicationNameFromNonQuotedString( const WCHAR* pszString, 
                                                          WCHAR* pszApplicationName, 
                                                          WCHAR* pszCommandLine )
{
    // find the blankspace, such that the 4 chars before it are ".exe"
    WCHAR* pBlank = NULL;
    pBlank = ::wcschr( pszString, L' ' ); 
    if ( pBlank == NULL )
    {
        // whole string is exe, no quotes are necessary: 
        ::wcscpy( pszApplicationName, pszString );
        ::wcscpy( pszCommandLine, pszString );
        return TRUE;
    }
    
    // pBlank point to the first blank space
    BOOL bExenameFound = FALSE;
    
    do
    {
        if (IsExeExtention(pszString, pBlank))
        {
            bExenameFound = TRUE;
            break;
        }
        pBlank = ::CharNext( pBlank );
        pBlank = ::wcschr( pBlank, L' ');
        
    } while (pBlank != NULL); 
    
    if ( bExenameFound == TRUE)
    {
        
        int exeNameLen = pBlank - pszString;
        ::wcsncpy(pszApplicationName, pszString, exeNameLen);
        pszApplicationName[exeNameLen] = g_chEndOfLine;
        
        // commandline should contain qouted exe-name and args
        ::wcscpy( pszCommandLine, L"\"" );
        ::wcscat( pszCommandLine, pszApplicationName );
        ::wcscat( pszCommandLine, L"\"" );
        ::wcscat( pszCommandLine, pBlank );
        
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

// helper function:
// return TRUE if last 4 characters before pBlank are ".exe"
// return FALSE otherwise
BOOL CUrtOcmSetup::IsExeExtention(const WCHAR* pszString, WCHAR *pBlank)
{
    WCHAR chCheckChars[] = {L'e', L'x', L'e', L'.', g_chEndOfLine };
    WCHAR *pExtChar = ::CharPrev(pszString, pBlank);
    WCHAR *pCheckChar = chCheckChars;
    while (*pCheckChar != g_chEndOfLine && 
        (*pExtChar == *pCheckChar || *pExtChar == towupper(*pCheckChar)))
    {
        pCheckChar++;
        pExtChar = ::CharPrev(pszString, pExtChar);
    }
    
    if ( *pCheckChar == g_chEndOfLine)
    {
        return TRUE;
    }
    else 
    {
        return FALSE;
    }
}        

//Parse input args
// expecting something like
// "exe-file and arguments, unused, path to add as temp env. var"
// parameters:
// [in/out] pszString: will contain everything before first comma
// [out] pPath:        will contain everything after last comma
VOID CUrtOcmSetup::ParseArgument( WCHAR *pszString, WCHAR*& pPath )
{
    WCHAR* pRec  = NULL;

    if ( pszString == NULL )
    {
        LogInfo( L"ParseArgument Error! pszString is null." );
        assert( !L"ParseArgument Error! pszString is null." );
    }
    else
    {
        pRec = ::wcsstr( pszString, L"," );
    }

    if ( pRec != NULL )
    {
        pPath = pRec;
        pPath = ::CharNext( pPath );
    
        *pRec = L'\0';
        pRec = pPath;

        pPath = ::wcsstr( pRec, L"," );
        
        if( pPath != NULL )
        {
            pPath = ::CharNext( pPath );
            
        }
    }
    else
    {
        pPath = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: Main.cpp
//
// Abstract:
//    DLL entry for universal runtime ocm setup
//
// Author: JoeA
//
// Notes:
//

#include <windows.h>
#include <tchar.h>
#include "urtocm.h"

//global instance handle
//
HMODULE g_hInstance = NULL;

//instance of the setup
//
CUrtOcmSetup uoSetup;



/////////////////////////////////////////////////////////////////////////////
// DllMain
// Receives: HINSTANCE - handle to the DLL Module
//           DWORD     - reason for calling fuction
//           LPVOID    - reserved
// Returns:  TRUE      - no initialization to fail
//
// Purpose: DLL entry point
//
extern "C" BOOL WINAPI DllMain( 
                                IN HINSTANCE  hInstance, 
                                IN DWORD      dwReason, 
                                IN LPVOID     lpReserved )
{

   UNREFERENCED_PARAMETER( lpReserved );

   switch( dwReason )
   {
      case DLL_PROCESS_ATTACH:

         g_hInstance = ( HINSTANCE )hInstance;

         break;

      case DLL_PROCESS_DETACH:

         break;

      default:

         break;
   }

   // check if user is an administrator
   g_bIsAdmin = IsAdmin();

   return TRUE;

} //DllMain




/////////////////////////////////////////////////////////////////////////////
// UrtOcmProc
// Receives: LPCTSTR - component name from the INF
//           LPCTSTR - subcomponent name where appropriate
//           UINT    - function to switch on
//           UINT    - function-specific values
//           PVOID   - function-specific values
// Returns:  DWORD   - 0 if function unrecognized, else function-specific
//
// Purpose: OCM callback ... see ocm documentation for complete description
//

#include "globals.h"

extern "C" DWORD CALLBACK UrtOcmProc(
                             IN     LPCTSTR szComponentId,
                             IN     LPCTSTR szSubcomponentId,
                             IN     UINT    uiFunction,
                             IN     UINT    uiParam1,
                             IN OUT PVOID   pvParam2 )
{
    return uoSetup.OcmSetupProc( 
        szComponentId,
        szSubcomponentId,
        uiFunction,
        uiParam1,
        pvParam2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\infhelpers.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: infhelpers.cpp
//
// Abstract:
//    class definitions for inf setup helper objects
//
// Author: JoeA
//
// Notes:
//

#if !defined( INFHELPERS_H )
#define INFHELPERS_H

#include "globals.h"


//////////////////////////////////////////////////////////////////////////////
// class CUrtInfSection
// Receives: HINF   - handle to an INF
//           WCHAR* - section in the INF
//           WCHAR* - key from the INF
//
// Purpose : several INF keys have the structure
//              key=item1,item2,item2
//           where itemx is another section in the INF.
//           These sections are parsed out and stored as substrings
//           for later retrieval.
//
class CUrtInfSection
{
public:
    CUrtInfSection( const HINF hInfName, const WCHAR* szInfSection, const WCHAR* szInfKey );
    ~CUrtInfSection();

    UINT count( VOID ) const { return m_lSections.size(); }
    const WCHAR* item( const UINT ui );


protected:
    WCHAR m_szSections[MAX_SECTION_LENGTH];

    std::list<WCHAR*> m_lSections;

private:
};  //class CUrtInfSection





//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
typedef std::basic_string<wchar_t> string;


//////////////////////////////////////////////////////////////////////////////
// class CUrtInfKeys
// Receives: HINF   - handle to an INF
//           WCHAR* - section in the INF
//
// Purpose : several INF sections contain many lines of data that is passed
//           to other functions; this class reads this information and 
//           stores it to be retrieved through its accessors
//
class CUrtInfKeys
{
public:
    CUrtInfKeys( const HINF hInfName, const WCHAR* szInfSection );
    ~CUrtInfKeys();

    UINT count( VOID ) const { return m_lKeys.size(); }
    const WCHAR* item( const UINT ui );

protected:
    std::list<string> m_lKeys;

private:
};  //class CUrtInfKeys


#endif  //INFHELPERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\makefile.inc ===
# additional dependencies

ndp_ocm:
       @if not exist $(TARGETCORBIN)\$(_TGTCPU)                            mkdir $(TARGETCORBIN)\$(_TGTCPU)
       @if not exist $(TARGETCORBIN)\$(_TGTCPU)\$(DDKBUILDENV)             mkdir $(TARGETCORBIN)\$(_TGTCPU)\$(DDKBUILDENV)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\ocmanage.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    ocmanage.h

Abstract:

    Public header file for Optional Component Manager.

Revision History:

--*/

#if _MSC_VER > 1000
#pragma once
#endif

//
// Define type for optional component setup dll interface entry point.
// Note the strings are declared with VOID typing since we don't
// know in advance what the character width is.
//
typedef
DWORD
(*POCSETUPPROC) (
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    );

//
// Define interface function codes.
//
#define OC_PREINITIALIZE                0x00000000
#define OC_INIT_COMPONENT               0x00000001
#define OC_SET_LANGUAGE                 0x00000002
#define OC_QUERY_IMAGE                  0x00000003
#define OC_REQUEST_PAGES                0x00000004
#define OC_QUERY_CHANGE_SEL_STATE       0x00000005
#define OC_CALC_DISK_SPACE              0x00000006
#define OC_QUEUE_FILE_OPS               0x00000007
#define OC_NOTIFICATION_FROM_QUEUE      0x00000008
#define OC_QUERY_STEP_COUNT             0x00000009
#define OC_COMPLETE_INSTALLATION        0x0000000a
#define OC_CLEANUP                      0x0000000b
#define OC_QUERY_STATE                  0x0000000c
#define OC_NEED_MEDIA                   0x0000000d
#define OC_ABOUT_TO_COMMIT_QUEUE        0x0000000e
#define OC_QUERY_SKIP_PAGE              0x0000000f
#define OC_WIZARD_CREATED               0x00000010
#define OC_FILE_BUSY	                0x00000011
#define OC_EXTRA_ROUTINES               0x00000012

#define OC_QUERY_ERROR                  0x000000FF  // dead

//#define OC_OSSETUP_GET_WIZARD_TITLE     0x00000400
//#define OC_OSSETUP_GET_COMPUTER_NAME    0x00000401
//#define OC_OSSETUP_GET_SERVER_TYPE      0x00000402

#define OC_PRIVATE_BASE                 0x00010000

//
// Define OC Manager directory IDs, available in per-component INFs.
//
#define DIRID_OCM_MASTERINF             987654321       // full path
#define DIRID_OCM_PLATFORM              987654322       // alpha, i386, etc
#define DIRID_OCM_PLATFORM_ALTERNATE    987654323       // alpha, x86, etc
#define DIRID_OCM_COMPONENT             987654324       // component shortname


//
// Define structure used as a table of helper/callback entry points
// into the OC Manager, and the associated function prototypes.
//
typedef
VOID
(CALLBACK *PTICKGAUGE_ROUTINE) (
    IN PVOID OcManagerContext
    );

typedef
VOID
(CALLBACK *PSETPROGRESSTEXT_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR Text
    );

typedef
VOID
(CALLBACK *PSETPROGRESSTEXT_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR Text
    );

typedef
UINT
(CALLBACK *PSETPRIVATEDATA_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR Name,
    IN PVOID  Data,
    IN UINT   Size,
    IN UINT   Type
    );

typedef
UINT
(CALLBACK *PSETPRIVATEDATA_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR Name,
    IN PVOID   Data,
    IN UINT    Size,
    IN UINT    Type
    );

typedef
UINT
(CALLBACK *PGETPRIVATEDATA_ROUTINEA) (
    IN     PVOID  OcManagerContext,
    IN     LPCSTR ComponentId,
    IN     LPCSTR Name,
    OUT    PVOID  Data,         OPTIONAL
    IN OUT PUINT  Size,
    OUT    PUINT  Type
    );

typedef
UINT
(CALLBACK *PGETPRIVATEDATA_ROUTINEW) (
    IN     PVOID   OcManagerContext,
    IN     LPCWSTR ComponentId,
    IN     LPCWSTR Name,
    OUT    PVOID   Data,         OPTIONAL
    IN OUT PUINT   Size,
    OUT    PUINT   Type
    );

typedef
UINT
(CALLBACK *PSETSETUPMODE_ROUTINE) (
    IN PVOID OcManagerContext,
    IN DWORD SetupMode
    );

typedef
UINT
(CALLBACK *PGETSETUPMODE_ROUTINE) (
    IN PVOID OcManagerContext
    );

typedef
BOOL
(CALLBACK *PQUERYSELECTIONSTATE_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR SubcomponentId,
    IN UINT   StateType
    );

typedef
BOOL
(CALLBACK *PQUERYSELECTIONSTATE_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR SubcomponentId,
    IN UINT    StateType
    );

typedef
UINT
(CALLBACK *PCALLPRIVATEFUNCTION_ROUTINEA) (
    IN     PVOID  OcManagerContext,
    IN     LPCSTR ComponentId,
    IN     LPCSTR SubcomponentId,
    IN     UINT   Function,
    IN     UINT   Param1,
    IN OUT PVOID  Param2,
    OUT    PUINT  Result
    );

typedef
UINT
(CALLBACK *PCALLPRIVATEFUNCTION_ROUTINEW) (
    IN     PVOID   OcManagerContext,
    IN     LPCWSTR ComponentId,
    IN     LPCWSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2,
    OUT    PUINT   Result
    );

typedef
BOOL
(CALLBACK *PCONFIRMCANCEL_ROUTINE) (
    IN HWND ParentWindow
    );

typedef
HWND
(CALLBACK *PQUERYWIZARDDIALOGHANDLE_ROUTINE) (
    IN PVOID OcManagerContext
    );

typedef
BOOL
(CALLBACK *PSETREBOOT_ROUTINE) (
    IN PVOID OcManagerContext,
    IN BOOL  Reserved
    );

typedef
HINF
(CALLBACK *PGETINFHANDLE_ROUTINE) (
    IN UINT  InfIndex,
    IN PVOID OcManagerContext
    );

#define INFINDEX_UNATTENDED     1

typedef
BOOL
(*PREPORTEXTERNALERROR_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN LPCSTR ComponentId,
    IN LPCSTR SubcomponentId,   OPTIONAL
    IN DWORD_PTR  MessageId,
    IN DWORD  Flags,
    ...
    );

typedef
BOOL
(*PREPORTEXTERNALERROR_ROUTINEW) (
    IN PVOID   OcManagerContext,
    IN LPCWSTR ComponentId,
    IN LPCWSTR SubcomponentId,  OPTIONAL
    IN DWORD_PTR   MessageId,
    IN DWORD   Flags,
    ...
    );

#define ERRFLG_SYSTEM_MESSAGE   0x00000001
#define ERRFLG_IGNORE_INSERTS   0x00000002
#define ERRFLG_PREFORMATTED     0x00000004

typedef struct _OCMANAGER_ROUTINESA {
    PVOID OcManagerContext;
    PTICKGAUGE_ROUTINE TickGauge;
    PSETPROGRESSTEXT_ROUTINEA SetProgressText;
    PSETPRIVATEDATA_ROUTINEA SetPrivateData;
    PGETPRIVATEDATA_ROUTINEA GetPrivateData;
    PSETSETUPMODE_ROUTINE SetSetupMode;
    PGETSETUPMODE_ROUTINE GetSetupMode;
    PQUERYSELECTIONSTATE_ROUTINEA QuerySelectionState;
    PCALLPRIVATEFUNCTION_ROUTINEA CallPrivateFunction;
    PCONFIRMCANCEL_ROUTINE ConfirmCancelRoutine;
    PQUERYWIZARDDIALOGHANDLE_ROUTINE QueryWizardDialogHandle;
    PSETREBOOT_ROUTINE SetReboot;
    PGETINFHANDLE_ROUTINE GetInfHandle;
    PREPORTEXTERNALERROR_ROUTINEA ReportExternalError;
} OCMANAGER_ROUTINESA, *POCMANAGER_ROUTINESA;

typedef struct _OCMANAGER_ROUTINESW {
    PVOID OcManagerContext;
    PTICKGAUGE_ROUTINE TickGauge;
    PSETPROGRESSTEXT_ROUTINEW SetProgressText;
    PSETPRIVATEDATA_ROUTINEW SetPrivateData;
    PGETPRIVATEDATA_ROUTINEW GetPrivateData;
    PSETSETUPMODE_ROUTINE SetSetupMode;
    PGETSETUPMODE_ROUTINE GetSetupMode;
    PQUERYSELECTIONSTATE_ROUTINEW QuerySelectionState;
    PCALLPRIVATEFUNCTION_ROUTINEW CallPrivateFunction;
    PCONFIRMCANCEL_ROUTINE ConfirmCancelRoutine;
    PQUERYWIZARDDIALOGHANDLE_ROUTINE QueryWizardDialogHandle;
    PSETREBOOT_ROUTINE SetReboot;
    PGETINFHANDLE_ROUTINE GetInfHandle;
    PREPORTEXTERNALERROR_ROUTINEW ReportExternalError;
} OCMANAGER_ROUTINESW, *POCMANAGER_ROUTINESW;

#ifdef UNICODE
typedef OCMANAGER_ROUTINESW OCMANAGER_ROUTINES;
typedef POCMANAGER_ROUTINESW POCMANAGER_ROUTINES;
#else
typedef OCMANAGER_ROUTINESA OCMANAGER_ROUTINES;
typedef POCMANAGER_ROUTINESA POCMANAGER_ROUTINES;
#endif

typedef
BOOL
(*PLOGERROR_ROUTINEA) (
    IN PVOID  OcManagerContext,
    IN DWORD  ErrorLevel,
    IN LPCSTR Msg,
    ...
    );

typedef
BOOL
(*PLOGERROR_ROUTINEW) (
    IN PVOID  OcManagerContext,
    IN DWORD  ErrorLevel,
    IN LPCWSTR Msg,
    ...
    );

typedef struct _EXTRA_ROUTINESA {
    DWORD size;
    PLOGERROR_ROUTINEA LogError;
} EXTRA_ROUTINESA, *PEXTRA_ROUTINESA;

typedef struct _EXTRA_ROUTINESW {
    DWORD size;
    PLOGERROR_ROUTINEW LogError;
} EXTRA_ROUTINESW, *PEXTRA_ROUTINESW;

#ifdef UNICODE
typedef EXTRA_ROUTINESW EXTRA_ROUTINES;
typedef PEXTRA_ROUTINESW PEXTRA_ROUTINES;
#else
typedef EXTRA_ROUTINESA EXTRA_ROUTINES;
typedef PEXTRA_ROUTINESA PEXTRA_ROUTINES;
#endif


// for error handler

typedef enum {
    OcErrLevInfo    = 0x00000000,
    OcErrLevWarning = 0x01000000,
    OcErrLevError   = 0x02000000,
    OcErrLevFatal   = 0x03000000,
    OcErrLevMax     = 0x04000000,
    OcErrBatch      = 0x10000000,
    OcErrMask		= 0xFF000000
} OcErrorLevel;

//
// Flags.
//
#define OCFLAG_UNICODE  0x00000001
#define OCFLAG_ANSI     0x00000002

//
// master component flags
//
#define OCFLAG_NOWIZPAGES   0x00000001
#define OCFLAG_NOQUERYSKIP  0x00000002
#define OCFLAG_NOEXTRAFLAGS 0x00000004

//
// Selection state types (for QuerySelectionState and OC_QUERY_STATE).
//
#define OCSELSTATETYPE_ORIGINAL     0
#define OCSELSTATETYPE_CURRENT      1
#define OCSELSTATETYPE_FINAL        2

//
// Setup data structure. Passed within a SETUP_INIT_COMPONENT structure
// as OC_INIT_COMPONENT time.
//
typedef struct _SETUP_DATAA {
    DWORD SetupMode;
    DWORD ProductType;
    DWORDLONG OperationFlags;
    CHAR SourcePath[MAX_PATH];
    CHAR UnattendFile[MAX_PATH];
} SETUP_DATAA, *PSETUP_DATAA;

typedef struct _SETUP_DATAW {
    DWORD SetupMode;
    DWORD ProductType;
    DWORDLONG OperationFlags;
    WCHAR SourcePath[MAX_PATH];
    WCHAR UnattendFile[MAX_PATH];
} SETUP_DATAW, *PSETUP_DATAW;

#ifdef UNICODE
typedef SETUP_DATAW SETUP_DATA;
typedef PSETUP_DATAW PSETUP_DATA;
#else
typedef SETUP_DATAA SETUP_DATA;
typedef PSETUP_DATAA PSETUP_DATA;
#endif


//
// Values for SetupMode
//
#define SETUPMODE_UNKNOWN       (-1)
#define SETUPMODE_MINIMAL       0
#define SETUPMODE_TYPICAL       1
#define SETUPMODE_LAPTOP        2
#define SETUPMODE_CUSTOM        3

#define SETUPMODE_PRIVATE(x)    ((x) & SETUPMODE_PRIVATE_MASK)

//
// Predefined upgrade modes
//
#define SETUPMODE_UPGRADEONLY   0x20000100
#define SETUPMODE_ADDEXTRACOMPS 0x20000200

//
// Predefined mainteance modes
//
#define SETUPMODE_ADDREMOVE     0x10000100
#define SETUPMODE_REINSTALL     0x10000200
#define SETUPMODE_REMOVEALL     0x10000400

//
// Predefined fresh modes
//
#define SETUPMODE_FRESH         0x00000000
#define SETUPMODE_MAINTENANCE   0x10000000
#define SETUPMODE_UPGRADE       0x20000000

#define SETUPMODE_STANDARD_MASK 0x000000ff
#define SETUPMODE_PRIVATE_MASK  0xffffff00
//
// Flag for NeedMedia Callback, Ored in to
// Return code to allow NeedMedia to return
// FILEOP_ Return Codes
//
#define NEEDMEDIA_USEFILEOP     0x80000000


//
// Values for ProductType. Notice careful definitions
// such that low bit on means some kind of DC.
//
#define PRODUCT_WORKSTATION         0
#define PRODUCT_SERVER_PRIMARY      1
#define PRODUCT_SERVER_STANDALONE   2
#define PRODUCT_SERVER_SECONDARY    3

//
// Bit flags for OperationFlags. Note that this is a 64-bit field.
//
#define SETUPOP_WIN31UPGRADE        0x0000000000000001
#define SETUPOP_WIN95UPGRADE        0x0000000000000002
#define SETUPOP_NTUPGRADE           0x0000000000000004
#define SETUPOP_BATCH               0x0000000000000008
#define SETUPOP_STANDALONE          0x0000000000000010
#define SETUPOP_ALPHA_FILES_AVAIL   0x0000000100000000
#define SETUPOP_MIPS_FILES_AVAIL    0x0000000200000000
#define SETUPOP_PPC_FILES_AVAIL     0x0000000400000000
#define SETUPOP_X86_FILES_AVAIL     0x0000000800000000


//
// Component initialization structure, passed at OC_INIT_COMPONENT time.
//
typedef struct _SETUP_INIT_COMPONENTA {
    UINT OCManagerVersion;
    UINT ComponentVersion;
    HINF OCInfHandle;
    HINF ComponentInfHandle;
    SETUP_DATAA SetupData;
    OCMANAGER_ROUTINESA HelperRoutines;
} SETUP_INIT_COMPONENTA, *PSETUP_INIT_COMPONENTA;

typedef struct _SETUP_INIT_COMPONENTW {
    UINT OCManagerVersion;
    UINT ComponentVersion;
    HINF OCInfHandle;
    HINF ComponentInfHandle;
    SETUP_DATAW SetupData;
    OCMANAGER_ROUTINESW HelperRoutines;
} SETUP_INIT_COMPONENTW, *PSETUP_INIT_COMPONENTW;

#ifdef UNICODE
typedef SETUP_INIT_COMPONENTW SETUP_INIT_COMPONENT;
typedef PSETUP_INIT_COMPONENTW PSETUP_INIT_COMPONENT;
#else
typedef SETUP_INIT_COMPONENTA SETUP_INIT_COMPONENT;
typedef PSETUP_INIT_COMPONENTA PSETUP_INIT_COMPONENT;
#endif

//
// Current OC Manager version, major and minor.
//
#define OCVER_MAJOR     5
#define OCVER_MINOR     0

#define OCMANAGER_VERSION   ((DWORD)MAKELONG(OCVER_MINOR,OCVER_MAJOR))

//
// Wizard page request structure, used with OC_REQUEST_PAGES.
//
typedef struct _SETUP_REQUEST_PAGES {
    UINT MaxPages;
    HPROPSHEETPAGE Pages[ANYSIZE_ARRAY];
} SETUP_REQUEST_PAGES, *PSETUP_REQUEST_PAGES;


//
// Flags used in Param2 of OC_QUERY_CHANGE_SEL_STATE notification
//
#define OCQ_ACTUAL_SELECTION    0x00000001


//
// Enumerated types.
//

typedef enum {
    SubCompInfoSmallIcon,   // the small icon associated with the subcomponent
    SubCompInfoWatermark    // the watermark image at the top of the wizard
} SubComponentInfo;

typedef enum {
    WizPagesWelcome,        // welcome page
    WizPagesMode,           // setup mode page
    WizPagesEarly,          // pages that come after the mode page and before prenet pages
    WizPagesPrenet,         // pages that come before network setup
    WizPagesPostnet,        // pages that come after network setup
    WizPagesLate,           // pages that come after postnet pages and before the final page
    WizPagesFinal,          // final page
    WizPagesTypeMax
} WizardPagesType;

typedef enum {
    SubcompUseOcManagerDefault,
    SubcompOn,
    SubcompOff
} SubComponentState;

typedef enum {
    OcPageComponentHierarchy,
    OcPageMax
} OcManagerPage;

// use the assert from SetupAPI
#define sapiAssert MYASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\processenvvar.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: processenvvar.cpp
//
// Abstract:
//    implementation of CProcessEnvVar methods (class for handling the environment variable changes)
//
// Author: a-mshn
//
// Notes:
//

#include "processenvvar.h"

// implementation of CProcessEnvVar methods
CProcessEnvVar::CProcessEnvVar( const TCHAR* pwz ) : m_strEnvVar(pwz), m_bEnvVarChanged(false)
{
    DWORD dwRet = ::GetEnvironmentVariable( m_strEnvVar.c_str(), NULL, 0 );
    
    UINT cBufSize = dwRet+1;
    TCHAR* pBuffer = new TCHAR[cBufSize];
    ::ZeroMemory( pBuffer, cBufSize * sizeof(TCHAR) );
    
    dwRet = ::GetEnvironmentVariable( m_strEnvVar.c_str(), pBuffer, cBufSize );
    assert( dwRet < cBufSize );
    
    m_strOrigData = pBuffer;
    m_strCurrentData = pBuffer;
    
    delete [] pBuffer;
}

// copy constructor
CProcessEnvVar::CProcessEnvVar( const CProcessEnvVar& procEnvVar )
{
    m_strOrigData = procEnvVar.m_strOrigData;
    m_strCurrentData = procEnvVar.m_strCurrentData;
    m_strEnvVar = procEnvVar.m_strEnvVar;
    m_bEnvVarChanged = procEnvVar.m_bEnvVarChanged;
}

// append the EnvVar
CProcessEnvVar& CProcessEnvVar::operator+=( const TCHAR* pwz )
{
    return this->Append(pwz);
}

// append: appends the EnvVar (the same as +=)
CProcessEnvVar& CProcessEnvVar::Append( const TCHAR* pwz )
{
    m_strCurrentData += pwz;
    SetEnvVar( m_strCurrentData.c_str() );
    return *this;
}

// prepends the EnvVar
CProcessEnvVar& CProcessEnvVar::Prepend( const TCHAR* pwz )
{
    m_strCurrentData.insert( 0, _T( ";" ) );
    m_strCurrentData.insert( 0, pwz );
    SetEnvVar( m_strCurrentData.c_str() );
    return *this;
}

// returns current EnvVar
const tstring& CProcessEnvVar::GetData( VOID ) const
{
    return m_strCurrentData;
}

// restores original EnvVar
BOOL CProcessEnvVar::RestoreOrigData( VOID )
{
    if (m_bEnvVarChanged)
    {
        return ::SetEnvironmentVariable( m_strEnvVar.c_str(), m_strOrigData.c_str() );
    }
    else
    {
        // path has not changed, nothing should be done
        return true;
    }
}

// set environment variable (helper method)
BOOL CProcessEnvVar::SetEnvVar( const TCHAR* pwz )
{
    m_bEnvVarChanged = true;
    return ::SetEnvironmentVariable( m_strEnvVar.c_str(), pwz );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE            VFT_DLL
#define VER_INTERNALNAME_STR    "NetFXOcm.dll"
#define VER_FILEDESCRIPTION_STR "Universal Runtime OCM Setup\0"
#define VER_ORIGFILENAME_STR    "netfxocm.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by urtocm.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\processenvvar.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: processenvvar.h
//
// Abstract:
//    class CProcessEnvVar (class for handling the environment variable changes)
//
// Author: a-mshn
//
// Notes:
//

#if !defined( PROCESSENVVAR_H )
#define PROCESSENVVAR_H

#include "globals.h"
#include <string>
#include <wchar.h>

#ifdef _UNICODE
	typedef std::basic_string<wchar_t> tstring;
#else
	typedef std::basic_string<char> tstring;
#endif

class CProcessEnvVar
{
public:
    // constructor
    CProcessEnvVar( const TCHAR* pwz );
    ~CProcessEnvVar() {};

    // copy constructor
    CProcessEnvVar( const CProcessEnvVar& procEnvVar );

    CProcessEnvVar& operator+=( const TCHAR* pwz );

    // append: appends the EnvVar (the same as +=)
    CProcessEnvVar& Append( const TCHAR* pwz );

    // prepends the EnvVar
    CProcessEnvVar& Prepend( const TCHAR* pwz );

    // returns current EnvVar
    const tstring& GetData( VOID ) const ;

    // restores original EnvVar
    BOOL RestoreOrigData( VOID );

private:
    // sets environment variable
    BOOL SetEnvVar( const TCHAR* pwz );

    tstring         m_strEnvVar;
    tstring         m_strOrigData;
    tstring         m_strCurrentData;

    bool            m_bEnvVarChanged;
};

#endif // PROCESSENVVAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\quietexec.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: quietexec.cpp
//
// Abstract:
//    function for launching custom actions ... derived from MSI code by jbae
//
// Author: JoeA
//
// Notes:
//

#include <windows.h>
#include <assert.h>
#include "globals.h"
#include "urtocm.h"
#include "processenvvar.h"

#ifdef DEBUG
#define VERIFY(exp) assert(exp)
#else
#define VERIFY(exp) exp
#endif


#define ERROR_FUNCTION_NOT_CALLED          1626L // Function could not be executed.
const WCHAR* const wczPathEnvVar = L"PATH";



UINT CUrtOcmSetup::QuietExec( const WCHAR* const szInstallArg )
{
    if( NULL == szInstallArg )
    {
        LogInfo( L"QuietExec Error! Input string null." );
        assert( !L"QuietExec Error! Input string null." );
        return E_POINTER;
    }

    //we may have to manipulate the string
    //
    WCHAR* pszString = NULL;
    VERIFY( pszString = ::_wcsdup( szInstallArg ) );

    BOOL  bReturnVal = FALSE;
    UINT  uRetCode   = ERROR_FUNCTION_NOT_CALLED;
    
    // get original path 
    CProcessEnvVar pathEnvVar(wczPathEnvVar);


    //Parse input args
    // expecting something like
    // mofcomp.exe C:\WINNT\Microsoft.NET\Framework\v7.1.0.9102\netfxcfgprov.mfl,netfxcfgprov.mfl,c:\winnt\system32\wbem
    // exe-file and arguments                                                   ,unused          ,path to add as temp env. var
    //
    WCHAR* pPath = NULL;
    ParseArgument( pszString, pPath);
    if ( pPath != NULL )
    {
        // change the path by prepending
        pathEnvVar.Prepend(pPath);
    }
    if ( pszString == NULL )
    {
        LogInfo( L"QuietExec Error! ParseArgument returned null." );
        assert( !L"QuietExec Error! ParseArgument returned null." );
        return E_POINTER;
    }

    
    //Create the process and wait on it if we're told to
    //
    STARTUPINFO  si ;
    ::ZeroMemory( &si, sizeof( si ) );
    si.cb = sizeof( si );

    // extract the aplication name 
    WCHAR pszApplicationName[_MAX_PATH+1] = EMPTY_BUFFER;
    WCHAR pszCommandLine[_MAX_PATH+1] = EMPTY_BUFFER;
    
    if (GetApplicationName(pszString, pszApplicationName, pszCommandLine))
    { 
        // consider special case: applicationName = mofcomp.exe, in this case change it to be
        // pPath\mofcomp.exe 
        if ( ::_wcsicmp(pszApplicationName, L"mofcomp.exe" ) == 0 && pPath )
        {
            ::wcscpy( pszApplicationName, pPath );
            ::wcscat( pszApplicationName, L"\\mofcomp.exe" );
        }
        
        
        WCHAR pszInfoString[2*_MAX_PATH+1] = L"CUrtOcmSetup::QuietExec(): call CreateProcess: applicationName = ";
        ::wcscat( pszInfoString, pszApplicationName );
        ::wcscat( pszInfoString, L", command-line parameter = ");
        ::wcscat( pszInfoString, pszCommandLine );
        LogInfo ( pszInfoString );
        
        PROCESS_INFORMATION process_info ;
        bReturnVal = ::CreateProcess(
            pszApplicationName, 
            pszCommandLine, 
            NULL, 
            NULL, 
            FALSE, 
            DETACHED_PROCESS, 
            NULL, 
            NULL, 
            &si, 
            &process_info );
        
        
        if( bReturnVal )
        {
            DWORD dwExitCode = 0;
            
            ::CloseHandle( process_info.hThread );
            ::WaitForSingleObject( process_info.hProcess, INFINITE );
            ::GetExitCodeProcess( process_info.hProcess, &dwExitCode );
            ::CloseHandle( process_info.hProcess );
            
            if( dwExitCode == 0 )
            {
                uRetCode = ERROR_SUCCESS;
                LogInfo ( L"CUrtOcmSetup::QuietExec(): CreateProcess succeeded" );
            }
            else 
            {
                WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
                ::swprintf( infoString, 
                            L"CUrtOcmSetup::QuietExec(): GetExitCodeProcess returned termination status = %d", 
                            dwExitCode );
                LogInfo ( infoString );
            }
        }
        else
        {
            DWORD dwError = GetLastError();
            
            WCHAR pszInfoString[_MAX_PATH+1];
            ::swprintf( pszInfoString, 
                        L"CUrtOcmSetup::QuietExec(): CreateProcess failed, GetLastError = %d", 
                        dwError );
            LogInfo( pszInfoString );
        }    
    } 
    else // GetApplicationName returned false
    {
        WCHAR pszInfoString[2*_MAX_PATH+1] = L"Invalid format in ";
        ::wcscat( pszInfoString, pszString );
        LogInfo ( pszInfoString );  
    }
    
    // restore the path
    pathEnvVar.RestoreOrigData();
   
    ::free ( pszString );
    return uRetCode;
}

// breaks pszString to applicationName (exe-file) and command-line (exefile and arguments)
// encloses exe-name in quotes (for commandLine only), if it is not quoted already 
// removes quotes from applicationName if exe-name was quoted
// returns false if caString is in wrong format (contains one quote only, has no exe-name, etc)
// Parameters:
//          [in] pszString - string containing exe-name and arguments
//                           "my.exe" arg1, arg2
//                            
//          [out] pszApplicationName - will contain exe-name
//          [out] pszCommandLine - same as caString with exe-name qouted

// for example if pszString = "my.exe" arg1 arg2 (OR pszString = my.exe arg1 arg2)
// then 
//       pszApplicationName = my.exe 
//       pszCommandLine = "my.exe" arg1 arg2
BOOL CUrtOcmSetup::GetApplicationName( const WCHAR* pszString, 
                                      WCHAR* pszApplicationName, 
                                      WCHAR* pszCommandLine )
{
    
    BOOL bRes = FALSE;

    if ( pszString == NULL )
    {
        LogInfo( L"GetApplicationName Error! pszString is null." );
        assert( !L"GetApplicationName Error! pszString is null." );
        return bRes;
    }


    if ( pszString && pszString[0] == L'\"' )
    {
        bRes  = GetApplicationNameFromQuotedString(pszString, 
                                                   pszApplicationName, 
                                                   pszCommandLine);
    }
    else
    {
        bRes  = GetApplicationNameFromNonQuotedString(pszString, 
                                                      pszApplicationName, 
                                                      pszCommandLine);
    }
    
    return bRes;
}


// helper function
// breaks command-line to applicationName and arguments 
// for path begins with quote (pszString = "my.exe" arg1 arg2)
BOOL CUrtOcmSetup::GetApplicationNameFromQuotedString( const WCHAR* pszString, 
                                                       WCHAR* pszApplicationName, 
                                                       WCHAR* pszCommandLine )
{
    // command line begins with qoute:
    // make commandLine to be equal to caString,
    // applName should contain exe-name without quotes
    ::wcscpy( pszCommandLine, pszString );
    
    // copy beginning with next symbol after quote
    ::wcscpy( pszApplicationName, &pszString[1] );
    
    // search for the second quote, assign to applName
    WCHAR* pQuotes = ::wcschr( pszApplicationName, L'\"' );
    if ( pQuotes != NULL )
    {
        *pQuotes = g_chEndOfLine;
        return TRUE;
    }
    else 
    {
        return FALSE;
    }
}


// helper function:
// breaks command-line to applicationName and arguments 
// for path that does NOT begin with quote (pszString = my.exe arg1 arg2)
BOOL CUrtOcmSetup::GetApplicationNameFromNonQuotedString( const WCHAR* pszString, 
                                                          WCHAR* pszApplicationName, 
                                                          WCHAR* pszCommandLine )
{
    // find the blankspace, such that the 4 chars before it are ".exe"
    WCHAR* pBlank = NULL;
    pBlank = ::wcschr( pszString, L' ' ); 
    if ( pBlank == NULL )
    {
        // whole string is exe, no quotes are necessary: 
        ::wcscpy( pszApplicationName, pszString );
        ::wcscpy( pszCommandLine, pszString );
        return TRUE;
    }
    
    // pBlank point to the first blank space
    BOOL bExenameFound = FALSE;
    
    do
    {
        if (IsExeExtention(pszString, pBlank))
        {
            bExenameFound = TRUE;
            break;
        }
        pBlank = ::CharNext( pBlank );
        pBlank = ::wcschr( pBlank, L' ');
        
    } while (pBlank != NULL); 
    
    if ( bExenameFound == TRUE)
    {
        
        int exeNameLen = pBlank - pszString;
        ::wcsncpy(pszApplicationName, pszString, exeNameLen);
        pszApplicationName[exeNameLen] = g_chEndOfLine;
        
        // commandline should contain qouted exe-name and args
        ::wcscpy( pszCommandLine, L"\"" );
        ::wcscat( pszCommandLine, pszApplicationName );
        ::wcscat( pszCommandLine, L"\"" );
        ::wcscat( pszCommandLine, pBlank );
        
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

// helper function:
// return TRUE if last 4 characters before pBlank are ".exe"
// return FALSE otherwise
BOOL CUrtOcmSetup::IsExeExtention(const WCHAR* pszString, WCHAR *pBlank)
{
    WCHAR chCheckChars[] = {L'e', L'x', L'e', L'.', g_chEndOfLine };
    WCHAR *pExtChar = ::CharPrev(pszString, pBlank);
    WCHAR *pCheckChar = chCheckChars;
    while (*pCheckChar != g_chEndOfLine && 
        (*pExtChar == *pCheckChar || *pExtChar == towupper(*pCheckChar)))
    {
        pCheckChar++;
        pExtChar = ::CharPrev(pszString, pExtChar);
    }
    
    if ( *pCheckChar == g_chEndOfLine)
    {
        return TRUE;
    }
    else 
    {
        return FALSE;
    }
}        

//Parse input args
// expecting something like
// "exe-file and arguments, unused, path to add as temp env. var"
// parameters:
// [in/out] pszString: will contain everything before first comma
// [out] pPath:        will contain everything after last comma
VOID CUrtOcmSetup::ParseArgument( WCHAR *pszString, WCHAR*& pPath )
{
    WCHAR* pRec  = NULL;

    if ( pszString == NULL )
    {
        LogInfo( L"ParseArgument Error! pszString is null." );
        assert( !L"ParseArgument Error! pszString is null." );
    }
    else
    {
        pRec = ::wcsstr( pszString, L"," );
    }

    if ( pRec != NULL )
    {
        pPath = pRec;
        pPath = ::CharNext( pPath );
    
        *pRec = L'\0';
        pRec = pPath;

        pPath = ::wcsstr( pRec, L"," );
        
        if( pPath != NULL )
        {
            pPath = ::CharNext( pPath );
            
        }
    }
    else
    {
        pPath = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\redist\msireader.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     MsiReader.cpp
// Owner:    jbae
// Purpose:  opens MSI and read necessary properties from Property table
//                              
// History:
//  03/07/2001: jbae, created

#include "MsiReader.h"
#include "SetupError.h"
#include "MsiWrapper.h"
#include "fxsetuplib.h"

//defines
//
#define EMPTY_BUFFER { _T('\0') }

// Constructors
//
// ==========================================================================
// CMsiReader::CMsiReader()
//
// Inputs:
//  LPTSTR pszMsiFile: path to MSI
// Purpose:
// ==========================================================================
CMsiReader::
CMsiReader()
: m_pszMsiFile(NULL)
{
}

// ==========================================================================
// CMsiReader::~CMsiReader()
//
// Inputs:
//  LPTSTR pszMsiFile: path to MSI
// Purpose:
// ==========================================================================
CMsiReader::
~CMsiReader()
{
    if ( m_pszMsiFile )
        delete [] m_pszMsiFile;
}

// Implementations
//
void CMsiReader::
SetMsiFile( LPCTSTR pszSourceDir, LPCTSTR pszMsiFile )
{
    if ( NULL == pszSourceDir )
    {
        m_pszMsiFile = new TCHAR[ _tcslen(pszMsiFile) + 1 ];
        _tcscpy( m_pszMsiFile, pszMsiFile );
    }
    else
    {
        m_pszMsiFile = new TCHAR[ _tcslen(pszSourceDir) + _tcslen(pszMsiFile) + 1 ];
        _tcscpy( m_pszMsiFile, pszSourceDir );
        _tcscat( m_pszMsiFile, pszMsiFile );
    }
}

// ==========================================================================
// CMsiReader::GetProperty()
//
// Purpose:
//  opens MSI and read given property from Property table
// Inputs:
//  LPTSTR pszName: name of the property
// Returns:
//  LPCTSTR m_pszPropertyValue: value of the named property to be read
// ==========================================================================
LPCTSTR CMsiReader::
GetProperty( LPCTSTR pszName )
{
    TCHAR szQry[1024] = "Select Value from Property where Property = ?";
    MSIHANDLE hMsi;
    MSIHANDLE hView;
    MSIHANDLE hRec;
    MSIHANDLE hRec1;
    UINT uRet;
    DWORD dwSize = 0;
    LPTSTR pszRet = NULL;

    CMsiWrapper msi;
    msi.LoadMsi();

    PFNMSICLOSEHANDLE pFnClose = (PFNMSICLOSEHANDLE)msi.GetFn(_T("MsiCloseHandle"));

try
{    
    uRet = (*(PFNMSIOPENDATABASE)msi.GetFn(_T("MsiOpenDatabaseA")))( m_pszMsiFile, MSIDBOPEN_READONLY, &hMsi );
    if ( ERROR_SUCCESS != uRet )
    {
        CSetupError se( IDS_CANNOT_OPEN_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_OPEN_ERROR );
        throw se;
    }

    uRet = (*(PFNMSIDATABASEOPENVIEW)msi.GetFn(_T("MsiDatabaseOpenViewA")))( hMsi, szQry, &hView );
    if ( ERROR_SUCCESS != uRet )
    {
        CSetupError se( IDS_CANNOT_READ_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_READ_ERROR );
        throw se;
    }
     
    hRec1 = (*(PFNMSICREATERECORD)msi.GetFn(_T("MsiCreateRecord")))( 1 );
    (*(PFNMSIRECORDSETSTRING)msi.GetFn(_T("MsiRecordSetStringA")))( hRec1, 1, (LPTSTR)pszName );

    uRet = (*(PFNMSIVIEWEXECUTE)msi.GetFn(_T("MsiViewExecute")))( hView, hRec1 );
    if ( ERROR_SUCCESS != uRet ) 
    {
        CSetupError se( IDS_CANNOT_READ_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_READ_ERROR );
        throw se;
    }
   
    uRet = (*(PFNMSIVIEWFETCH)msi.GetFn(_T("MsiViewFetch")))( hView, &hRec );
    if ( ERROR_NO_MORE_ITEMS == uRet )
    {
        CSetupError se( IDS_CANNOT_READ_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_READ_ERROR );
        throw se;
    }
    dwSize = 0;
    uRet = (*(PFNMSIRECORDGETSTRING)msi.GetFn(_T("MsiRecordGetStringA")))( hRec, 1, _T(""), &dwSize );
    if ( ERROR_MORE_DATA == uRet )
    {
        LPTSTR pszPropVal = new TCHAR[ ++dwSize ];
        uRet = (*(PFNMSIRECORDGETSTRING)msi.GetFn(_T("MsiRecordGetStringA")))( hRec, 1, pszPropVal, &dwSize );
        if ( ERROR_SUCCESS != uRet ) 
        {
            delete [] pszPropVal;
            CSetupError se( IDS_CANNOT_READ_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_READ_ERROR );
            throw se;
        }
        else
        {
            pszRet = m_Props.Enqueue( pszPropVal );
            delete [] pszPropVal;
        }
    }
    else
    {
        CSetupError se( IDS_CANNOT_READ_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_READ_ERROR );
        throw se;
    }

    if ( hMsi )
    {
        (*pFnClose)( hMsi );
    }
    if ( hView )
    {
        (*pFnClose)( hView );
    }
    if ( hRec )
    {
        (*pFnClose)( hRec );
    }
    if ( hRec1 )
    {
        (*pFnClose)( hRec1 );
    }
}
catch( CSetupError& se )
{
    if ( hMsi )
    {
        (*pFnClose)( hMsi );
    }
    if ( hView )
    {
        (*pFnClose)( hView );
    }
    if ( hRec )
    {
        (*pFnClose)( hRec );
    }
    if ( hRec1 )
    {
        (*pFnClose)( hRec1 );
    }
    throw( se );
}
    return pszRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\redist\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     main.cpp
// Owner:    jbae
// Purpose:  This contains top-level function (WinMain) for .NET Framework Setup.
//          This is a redist package and it supports ref-counting of 
//                  (<PackageType>, <Version>, <LanguageCode>)
//          of .NET Framework where <PackageType> is one of (Full, Control) and <Version>
//          looks like v1.0.2510 and <LanguageCode> is something like 1033.
//
//          This file contains only the WinMain function.  The remaining are in Redist.cpp.    
//           WinMain first verfies the config of the machine to ensure it does meet out min.    
//            config requirements.  It then installs Darwin (if necessary) and then commences    
//            with the core setup.  Finally, it sets a few settings before exiting.              
//                                                                                               
//            This setup can be executed from command line.  The syntax is:                      
//                                                                                               
//               Setup.exe [/q:a] [/c:"Install.exe [/h] [/p <ProductName>] [/q] [/u]"]           
//                                                                                               
//            where  /q      for quiet uncabbing. Combine with /q:a to give fully quiet uncabbing
//                   /h      gives the syntax info (ignores all other switches)                  
//                   /p      specifies name of the product that installs .NET Framework          
//                   /q      for post cabbing quiet installation                                 
//                   /u      uninstall (must be used with /p)                                    
//                                                                                               
//   Returns: See SetupCodes.h for all the return codes.                                         
//
// History:
//  long ago, anantag:  Created
//  01/10/01, jbae: Many changes to support ref-counting of Framework
//  07/18/01, joea: adding logging functionality
//  07/19/01, joea: added single instance support

#include "redist.h"
#include "SetupError.h"
#include "ReadFlags.h"
#include "AdminPrivs.h"
#include "DetectBeta.h"
#include "MsiReader.h"

// global variables
HINSTANCE g_AppInst ;                   // used in InstallDarwin() only

//defines
//
#define EMPTY_BUFFER { _T('\0') }

// constants
//
const int MAX_CMDLINE = 255; // this should be enough. Check this whenever adding new property.
HINSTANCE CSetupError::hAppInst;
TCHAR CSetupError::s_szProductName[MAX_PATH] = EMPTY_BUFFER;

//single instance data
//
TCHAR g_tszRedistMutexName[] = _T( "NDP Redist Setup" );
const TCHAR *g_szLogName     = _T( "dotNetFx.log" );


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    UINT        uRetCode ;                          // See SetupCodes.h for possible Return Values
    UINT        uMsiSetupRetCode = ERROR_SUCCESS;    // Returncode from InstMsi.exe

    //buffer for logging calls
    //
    TCHAR szLog[_MAX_PATH+1] = EMPTY_BUFFER;

    // install new() handler
    _set_new_handler( (_PNH)MyNewHandler );

    g_AppInst = hInstance;

    CSetupError::hAppInst = hInstance;

    g_sm = REDIST;
    CReadFlags rf( GetCommandLine(), PACKAGENAME );

    CSetupCode sc;

    //setup single instance
    //
    CSingleInstance si( g_tszRedistMutexName );

    try
    {
        TCHAR szStartMsg[] = _T( "Starting Install.exe" );
        LogThis( szStartMsg, sizeof( szStartMsg ) );

        //validate single instance
        //
        if( !si.IsUnique() )
        {
            CSetupError se( IDS_NOT_SINGLE_INSTANCE, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_NOT_SINGLE_INSTANCE );
            throw( se );
        }
        else if( !si.IsHandleOK() )
        {
            CSetupError se( IDS_SINGLE_INSTANCE_FAIL, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_SINGLE_INSTANCE_FAIL );
            throw( se );
        }

        // Convert command line parameters to flags
        LogThis1( _T( "Parsing switches from commandline: %s" ), GetCommandLine() );
        
        rf.Parse();

        // Make sure user has Admin Privileges so that we can read/write system registry
        if ( !UserHasPrivileges() )
        {
            CSetupError se( IDS_INSUFFICIENT_PRIVILEGES, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_INSUFFICIENT_PRIVILEGES );
            throw( se );
        }

        TCHAR szMsiPath[_MAX_PATH] = { _T('\0') };
        // since SourceDir is checked, this should be redundent but double-check it.
        if ( _MAX_PATH <= (_tcslen(rf.GetSourceDir()) + _tcslen(PACKAGENAME)) )
        {
            sc.SetError( IDS_SOURCE_DIR_TOO_LONG, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_SOURCE_DIR_TOO_LONG );
            throw ( sc );
        }

        _tcscpy( szMsiPath, rf.GetSourceDir() );
        _tcscat( szMsiPath, PACKAGENAME );

        if ( !rf.IsInstalling() )
        {
            // /u given so uninstall it...
            LogThis( _T( "Uninstall started" ) );
        
            SetTSInInstallMode();
            InstallProduct( &rf, szMsiPath, (LPTSTR)UNINSTALL_COMMANDLINE, &sc ) ;
        }
        else
        {
            // /u not given so install it...
            LogThis( _T( "Install started" ) );

            // Verify the system meets the min. config. requirements
            TCHAR szSystemReqs[] = _T( "Checking system requirements" );
            LogThis( szSystemReqs, sizeof( szSystemReqs ) );

            ConfigCheck( ) ;

            TCHAR szSystemReqsSuccess[] = _T( "System meets minimum requirements" );
            LogThis( szSystemReqsSuccess, sizeof( szSystemReqsSuccess ) );

            // Verify Darwin is on the system
            UINT uMsiChk = CheckDarwin();
            if ( ERROR_SUCCESS == uMsiChk || DARWIN_VERSION_OLD == uMsiChk ) // darwin detected
            {
                LPCTSTR pszProducts = NULL;

                CDetectBeta db( LogThis1 );
                pszProducts = db.FindProducts();
                if ( pszProducts ) // found beta NDP components
                {
                    LPVOID pArgs[] = { (LPVOID)pszProducts };
                    sc.m_bQuietMode |= rf.IsQuietMode();
                    sc.SetError2( IDS_OLD_FRAMEWORK_EXIST, MB_OK|MB_ICONEXCLAMATION, COR_OLD_FRAMEWORK_EXIST, (va_list *)pArgs );
                    sc.ShowError2();
                    sc.m_bQuietMode = true;
                    throw( sc );
                }
            }
            SetTSInInstallMode();
            // update darwin if necessary
            if ( DARWIN_VERSION_OLD == uMsiChk || DARWIN_VERSION_NONE == uMsiChk )
            {
                uMsiSetupRetCode = InstallDarwin( rf.IsQuietMode() );
                if ( ERROR_SUCCESS_REBOOT_REQUIRED == uMsiSetupRetCode ||
                    ERROR_SUCCESS == uMsiSetupRetCode )
                {
                    sc.SetReturnCode( IDS_SETUP_COMPLETE, IDS_DIALOG_CAPTION, MB_ICONINFORMATION, uMsiSetupRetCode );
                }
                else
                {
                    sc.SetError( IDS_DARWIN_INSTALL_FAILURE, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_INSTALL_FAILURE );
                    throw( sc );
                }
            }

            // See if OCM installed this version of ndp
            CMsiReader mr;
            mr.SetMsiFile( NULL, szMsiPath );
            LPCTSTR pszURTVersion = mr.GetProperty( URTVERSION_PROP );
            LPTSTR pszRegKey = new TCHAR[ _tcslen( pszURTVersion ) + _tcslen( OCM_REGKEY ) + 1 ];
            _tcscpy( pszRegKey, OCM_REGKEY );
            _tcscat( pszRegKey, pszURTVersion );

            HKEY hKey = NULL;
            LONG lRet = -1;
            lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszRegKey, 0, KEY_READ, &hKey );
            delete [] pszRegKey;
            if ( ERROR_SUCCESS == lRet )
            {                   
                _ASSERTE( NULL != hKey );
                DWORD dwData = 0;
                DWORD dwSize = sizeof( dwData );
                lRet = RegQueryValueEx( hKey, OCM_REGNAME, NULL, NULL, (BYTE*)&dwData, &dwSize );
                RegCloseKey( hKey );
                if ( ERROR_SUCCESS == lRet && OCM_REGDATA == dwData )
                {
                    CSetupError se( IDS_OCM_FOUND, IDS_DIALOG_CAPTION, MB_ICONWARNING, ERROR_SUCCESS );
                    throw( se );
                }
            }


            LogThis1( _T( "Installing: %s" ), szMsiPath );
            TCHAR szCmdLine[MAX_CMDLINE];
            _tcscpy( szCmdLine, REBOOT_PROP );
            if ( rf.IsNoARP() )
            {
                _tcscat( szCmdLine, _T(" ") );
                _tcscat( szCmdLine, NOARP_PROP );
            }
            if ( rf.IsNoASPUpgrade() )
            {
                _tcscat( szCmdLine, _T(" ") );
                _tcscat( szCmdLine, NOASPUPGRADE_PROP );
            }
            InstallProduct( &rf, szMsiPath, szCmdLine, &sc ) ;
        }

        // the final dialogbox and returncode
        // if quietmode is set by user or sc, we don't show ui
        sc.m_bQuietMode |= rf.IsQuietMode();
        uRetCode = sc.m_nRetCode;
        sc.ShowError();

    }
    catch( CSetupError se )
    {
        se.m_bQuietMode |= rf.IsQuietMode();
        uRetCode = se.m_nRetCode | sc.m_nRetCode;
        se.ShowError();
    }
    catch( ... )
    {
        CSetupError se( IDS_SETUP_FAILURE, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_EXIT_FAILURE );
        se.m_bQuietMode |= rf.IsQuietMode();
        uRetCode = se.m_nRetCode | sc.m_nRetCode;
        se.ShowError();
    }
    
    uRetCode = ( COR_REBOOT_REQUIRED == uRetCode ) ? ERROR_SUCCESS_REBOOT_REQUIRED : uRetCode;

    // make sure we can write to log
    if ( ((uRetCode & COR_CANNOT_GET_TEMP_DIR) != COR_CANNOT_GET_TEMP_DIR) &&
         ((uRetCode & COR_TEMP_DIR_TOO_LONG) != COR_TEMP_DIR_TOO_LONG) && 
         ((uRetCode & COR_CANNOT_WRITE_LOG) != COR_CANNOT_WRITE_LOG) ) 
    {
        LogThisDWORD( _T("Install.exe returning %d"), uRetCode );
        LogThisDWORD( _T("\r\n[Install.exe]\r\nReturnCode=%d"), uRetCode );
    }

    // prompt for reboot if we need to
    if( sc.IsRebootRequired() )
    {
        // Darwin says we need to reboot
        if( !(rf.IsQuietMode()) )
        {
            // Not quiet mode so we can prompt reboot
            ::SetupPromptReboot(NULL, NULL, 0) ;
        }
    }

    return uRetCode ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\urtocm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: urtocm.cpp
//
// Abstract:
//    class definitions for setup object
//
// Author: JoeA
//
// Notes:
//

#include "urtocm.h"
#include "Imagehlp.h"
#include <atlbase.h>


//strings
const WCHAR* const g_szInstallString     = L"_install";
const WCHAR* const g_szUninstallString   = L"_uninstall";
const WCHAR* const g_szRegisterSection   = L"RegServer";
const WCHAR* const g_szUnregisterSection = L"UnregServer";
const WCHAR* const g_szRegistrySection   = L"AddReg";
const WCHAR* const g_szTypeLibSection    = L"RegisterTlbs";
const WCHAR* const g_szCustActionSection = L"CA";
const WCHAR* const g_szCopyFilesSection  = L"CopyFiles";
const WCHAR* const g_szWwwRootRegKey     = L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots";
const WCHAR* const g_szDefaultWWWRoot    = L"Inetpub\\wwwroot";
const WCHAR* const g_szTempSection       = L"temp_files_delete";
const WCHAR* const g_szBindImageSection  = L"BindImage";
const WCHAR* const g_szSbsComponentSection  = L"Sbs component";
const WCHAR* const g_szSharedDlls        = L"Software\\Microsoft\\Windows\\CurrentVersion\\SharedDlls";
const WCHAR* const g_szMigrationCA       = L"migpolwin.exe";
const WCHAR* const g_szEverettRegKey     = L"SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\";
const WCHAR* const g_szURTVersionSection = L"URTVersion" ;   
const WCHAR* const g_szConfigFilesSection = L"ConfigFiles";   

const DWORD  g_dwInetPubsDirID    = 35000;  //this is the inetpubs dir token

// value is set in main, is true if user is an administrator and false otherwise
BOOL g_bIsAdmin;
BOOL g_bInstallOK;
BOOL g_bInstallComponent;
BOOL g_bIsEverettInstalled;


//////////////////////////////////////////////////////////////////////////////
// CUrtOcmSetup
// Purpose : Constructor
//
CUrtOcmSetup::CUrtOcmSetup() :
m_wLang( LANG_ENGLISH )
{
    assert( m_csLogFileName );
    ::GetWindowsDirectory( m_csLogFileName, MAX_PATH );
    ::wcscat( m_csLogFileName, L"\\netfxocm.log" );

    LogInfo( L"********************************************************************************" );
    LogInfo( L"CUrtOcmSetup()" );
    LogInfo( L"Installs NETFX component" );

    ::ZeroMemory( &m_InitComponent, sizeof( SETUP_INIT_COMPONENT ) );

    //we will not install unless we are on a server box or if someone 
    // calls us with a request to install
    //
    g_bInstallComponent = TRUE;

    OSVERSIONINFOEX osvi;
    osvi.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
    ::GetVersionEx( (OSVERSIONINFO*)&osvi );

    g_bInstallOK = ( VER_NT_WORKSTATION != osvi.wProductType ) ? TRUE : FALSE;
    if( g_bInstallOK )
    {
        LogInfo( L"OS Edition is Server. Initially marked for installation." );
    }
    else
    {
        LogInfo( L"OS Edition is not Server. Initially not marked for installation." );
    }
    
}

//////////////////////////////////////////////////////////////////////////////
// OcmSetupProc
// Receives: LPCTSTR - string ... name of component
//           LPCTSTR - string ... name of subcomponent (if applicable)
//           UINT    - ocm function id
//           UINT    - variable data ... dependent on function id
//           PVOID   - variable data ... dependent on function id
// Returns : DWORD
// Purpose : handle callback from OCM setup
//
DWORD CUrtOcmSetup::OcmSetupProc( LPCTSTR szComponentId,
                        LPCTSTR szSubcomponentId,
                        UINT    uiFunction,
                        UINT    uiParam1,
                        PVOID   pvParam2 )
{
    DWORD dwReturnValue = 0;

    if( ( !g_bInstallComponent ) && ( uiFunction != OC_QUERY_STATE ) )
    {
        return dwReturnValue;
    }

    BOOL  fState = TRUE;
    WCHAR wszSubComp[_MAX_PATH+1] = EMPTY_BUFFER;

    switch ( uiFunction )
    {
    case OC_PREINITIALIZE:
        ::swprintf( wszSubComp, L"OC_PREINITIALIZE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Called when the component's setup DLL is first loaded. Must be 
        // performed before initialization of the component can occur.
        //
        //Param1 = char width flags
        //Param2 = unused
        //
        //Return value is a flag indicating to OC Manager
        // which char width we want to run in.
        //

        dwReturnValue = OnPreInitialize( uiParam1 );
        break;

    case OC_INIT_COMPONENT:
        ::swprintf( wszSubComp, L"OC_INIT_COMPONENT - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Called soon after the component's setup DLL is loaded. Allows the 
        // component to initialize itself, and supplies the component with 
        // such items as its component ID and a set of callback routines, and 
        // requests certain information from the component.
        //
        //Param1 = unused
        //Param2 = points to SETUP_INIT_COMPONENT structure
        //
        //Return code is Win32 error indicating outcome.
        //
        dwReturnValue = InitializeComponent( 
            static_cast<PSETUP_INIT_COMPONENT>(pvParam2) );

        break;

    case OC_SET_LANGUAGE:
        ::swprintf( wszSubComp, L"OC_SET_LANGUAGE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Instructs the component to change to a given language if it can.
        //
        //Param1 = low 16 bits specify Win32 LANGID
        //Param2 = unused
        //
        //Return code is a boolean indicating whether we think we
        // support the requested language. We remember the language id
        // and say we support the language. A more exact check might involve
        // looking through our resources via EnumResourcesLnguages() for
        // example, or checking our inf to see whether there is a matching
        // or closely matching [strings] section. We don't bother with
        // any of that here.
        //
        dwReturnValue = OnSetLanguage( ( uiParam1 & 0xFFFF ) );
        break;

    case OC_QUERY_IMAGE:
        ::swprintf( wszSubComp, L"OC_QUERY_IMAGE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Requests GDI objects, such as the small icon associated with a 
        // (sub)component (if not specified in the component's .inf file).
        //
        //Param1 = low 16 bits used to specify image to be used
        //Param2 = width (low word) and height (high word) of image
        //
        //Return code is an HBITMAP or NULL on error
        //
        dwReturnValue = OnQueryImage( 
            ( uiParam1 & 0xFFFF ), 
            reinterpret_cast<DWORD>(pvParam2) );
        break;

    case OC_REQUEST_PAGES:
        ::swprintf( wszSubComp, L"OC_REQUEST_PAGES - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Requests a set of wizard page handles from the component.
        //
        //Param1 = unused
        //Param2 = pointer to a variable-size SETUP_REQUEST_PAGES
        //
        //Return code is the number of pages a component wants to return
        //
        dwReturnValue = OnRequestPages( static_cast<PSETUP_REQUEST_PAGES>(pvParam2) );
        break;

    case OC_QUERY_SKIP_PAGE:
        ::swprintf( wszSubComp, L"OC_QUERY_SKIP_PAGE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Asks top-level components whether OC Manager should skip displaying
        // a page it owns.
        //
        //Param1 = specifies the subject page of type OcManagerPage
        //Param2 = unused
        //
        //Return code is BOOLEAN specifying whether component wants to skip 
        // the page
        //
        dwReturnValue = OnQuerySkipPage( static_cast<OcManagerPage>(uiParam1) );
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        ::swprintf( wszSubComp, L"OC_QUERY_CHANGE_SEL_STATE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        //Informs the component that it or one of its subcomponents has been
        // selected/deselected by the user, and requests approval.
        //
        //Param1 = specifies proposed new selection state
        //Param2 = flags encoded as bit field
        //
        //Return code is BOOLEAN specifying whether proposed state s/b accepted
        //
        dwReturnValue = OnQueryChangeSelectionState( uiParam1, pvParam2, szSubcomponentId );
        break;

    case OC_CALC_DISK_SPACE:
        ::swprintf( wszSubComp, L"OC_CALC_DISK_SPACE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Directs the component to manipulate a Setup API Disk Space List, 
        // placing files on it or removing files from it, to mirror what will 
        // be actually installed later via a Setup API file queue. This 
        // allows efficient tracking of required disk space.
        //
        //Param1 = 0 if for removing component or non-0 if for adding component
        //Param2 = HDSKSPC to operate on
        //
        //Return value is Win32 error code indicating outcome.
        //

        // workaround for bug VS7 - 223124:
        // We should call OnCalculateDiskSpace twice: first time for calculation the cost 
        // of the component and second time for calculating total disk space
        // for some reason, the first time we fall into case OC_CALC_DISK_SPACE, 
        // StateChanged returns false, even if it is first time instalation.
        // therefore the cost of the component is 0 MB, which is not true.
        // So, we are removing condition on StateChanged from here

        if( !szSubcomponentId || !*szSubcomponentId )
        {
            LogInfo( L"OnCalculateDiskSpace was not called, since subcomponent is unknown" );
            dwReturnValue = NO_ERROR;
        }
        else if( !g_bIsAdmin )
        {
            LogInfo( L"OnCalculateDiskSpace was not called, since user has no admin privileges" );
            dwReturnValue = NO_ERROR;
        }
        else 
        {
            dwReturnValue = OnCalculateDiskSpace( uiParam1, static_cast<HDSKSPC>(pvParam2), szSubcomponentId );
        }

        break;

    case OC_QUEUE_FILE_OPS:
        ::swprintf( wszSubComp, L"OC_QUEUE_FILE_OPS - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Directs the component to queue file operations for installation, 
        //based on user interaction with the wizard pages and other 
        //component-specific factors.
        //
        //Param1 = unused
        //Param2 = HSPFILEQ to operate on
        //
        //Return value is Win32 error code indicating outcome.
        //
        //OC Manager calls this routine when it is ready for files to be copied
        // to effect the changes the user requested. The component DLL must figure out
        // whether it is being installed or uninstalled and take appropriate action.
        // For this sample, we look in the private data section for this component/
        // subcomponent pair, and get the name of an uninstall section for the
        // uninstall case.
        //
        //Note that OC Manager calls us once for the *entire* component
        // and then once per subcomponent. We ignore the first call.
        //

        //we don't intend on allowing a reinstall ... if the state hasn't changed,
        // we must already be installed. Do not install in this case.
        //

        fState = TRUE;
        if( !szSubcomponentId || !*szSubcomponentId )
        {
            LogInfo( L"OnQueueFileOperations was not called, since subcomponent is unknown" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !StateChanged( szSubcomponentId, &fState ) )
        {
            LogInfo( L"OnQueueFileOperations was not called, since reinstallation is not allowed" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !g_bIsAdmin )
        {
            LogInfo( L"OnQueueFileOperations was not called, since user has no admin privileges" );
            dwReturnValue = NO_ERROR;
        }
        else
        {
            dwReturnValue = OnQueueFileOperations( szSubcomponentId, static_cast<HSPFILEQ>(pvParam2) );
        }
        break;

    case OC_NEED_MEDIA:
        ::swprintf( wszSubComp, L"OC_NEED_MEDIA - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Used to pass along the SPFILENOTIFY_NEEDMEDIA Setup API notification 
        // message. Allows components to perform custom media processing, such 
        // as fetching cabinets from the Internet, and so forth. 
        //
        //Param1 = unused
        //Param2 = unused
        //
        //Return code is unused
        //
        dwReturnValue = OnNeedMedia();
        break;

    case OC_QUERY_STEP_COUNT:
        ::swprintf( wszSubComp, L"OC_QUERY_STEP_COUNT - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Asks the component how many steps are associated with a particular 
        // function/phase (such as OC_ABOUT_TO_COMMIT_QUEUE and 
        // OC_COMPLETE_INSTALLATION). Used to set up a progress indicator. 
        //
        //Param1 = unused
        //Param2 = unused
        //
        //Return value is an arbitrary 'step' count or -1 if error.
        //
        //OC Manager calls this routine when it wants to find out how much
        // work the component wants to perform for nonfile operations to
        // install/uninstall a component/subcomponent.
        // It is called once for the *entire* component and then once for
        // each subcomponent in the component.
        //

        //we don't intend on allowing a reinstall ... if the state hasn't changed,
        // we must already be installed. Do not install in this case.
        //
        fState = TRUE;
        if( !szSubcomponentId || !*szSubcomponentId )
        {
            LogInfo( L"OnQueryStepCount was not called, since subcomponent is unknown" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !StateChanged( szSubcomponentId, &fState ) )
        {
            LogInfo( L"OnQueryStepCount was not called, since reinstallation is not allowed" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !g_bIsAdmin )
        {
            LogInfo( L"OnQueryStepCount was not called, since user has no admin privileges" );
            dwReturnValue = NO_ERROR;
        }
        else
        {
            dwReturnValue = OnQueryStepCount( szSubcomponentId );
        }
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        ::swprintf( wszSubComp, L"OC_ABOUT_TO_COMMIT_QUEUE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Notifies the component that the file queue is about to be committed.
        // The component can perform housekeeping actions, and so forth. 
        //
        //Param1 = unused
        //Param2 = unused
        //
        //Return code is Win32 error code indicating outcome
        //

        //we don't intend on allowing a reinstall ... if the state hasn't changed,
        // we must already be installed. Do not install in this case.
        //
        fState = TRUE;
        if( !szSubcomponentId || !*szSubcomponentId )
        {
            LogInfo( L"OnAboutToCommitQueue was not called, since subcomponent is unknown" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !StateChanged( szSubcomponentId, &fState ) )
        {
            LogInfo( L"OnAboutToCommitQueue was not called, since reinstallation is not allowed" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !g_bIsAdmin )
        {
            LogInfo( L"OnAboutToCommitQueue was not called, since user has no admin privileges" );
            dwReturnValue = NO_ERROR;
        }
        else
        {
            dwReturnValue = OnAboutToCommitQueue();
        }
        break;

    case OC_COMPLETE_INSTALLATION:
        ::swprintf( wszSubComp, L"OC_COMPLETE_INSTALLATION - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Allows the component to perform any additional operations needed to 
        // complete installation, for example registry manipulations, and so
        // forth.
        //
        //Param1 = unused
        //Param2 = unused
        //
        //Return code is Win32 error code indicating outcome
        //


        //we don't intend on allowing a reinstall ... if the state hasn't changed,
        // we must already be installed. Do not install in this case.
        //
        fState = TRUE;
       if( !szSubcomponentId || !*szSubcomponentId )
        {
            LogInfo( L"OnCompleteInstallation was not called, since subcomponent is unknown" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !StateChanged( szSubcomponentId, &fState ) )
        {
            LogInfo( L"OnCompleteInstallation was not called, since reinstallation is not allowed" );
            dwReturnValue = NO_ERROR;
        }
        else if ( !g_bIsAdmin )
        {
            LogInfo( L"OnCompleteInstallation was not called, since user has no admin privileges" );
            dwReturnValue = NO_ERROR;
        }
        else
        {
            dwReturnValue = OnCompleteInstallation( szSubcomponentId );
        }

        break;

    case OC_CLEANUP:
        ::swprintf( wszSubComp, L"OC_CLEANUP - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        //Informs the component that it is about to be unloaded.
        //
        //Param1 = unused
        //Param2 = unused
        //
        //Return code is unused
        //
        dwReturnValue = OnCleanup();
        break;


    case OC_NOTIFICATION_FROM_QUEUE:
        ::swprintf( wszSubComp, L"OC_NOTIFICATION_FROM_QUEUE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnNotificationFromQueue();
        break;
    case OC_FILE_BUSY:
        ::swprintf( wszSubComp, L"OC_FILE_BUSY - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );
        
        dwReturnValue = OnFileBusy();
        break;
    case OC_QUERY_ERROR:
        ::swprintf( wszSubComp, L"OC_QUERY_ERROR - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnQueryError();
        break;
    case OC_PRIVATE_BASE:
        ::swprintf( wszSubComp, L"OC_PRIVATE_BASE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnPrivateBase();
        break;
    case OC_QUERY_STATE:
        ::swprintf( wszSubComp, L"OC_QUERY_STATE - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnQueryState( uiParam1 );
        break;
    case OC_WIZARD_CREATED:
        ::swprintf( wszSubComp, L"OC_WIZARD_CREATED - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnWizardCreated();
        break;
    case OC_EXTRA_ROUTINES:
        ::swprintf( wszSubComp, L"OC_EXTRA_ROUTINES - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = OnExtraRoutines();
        break;

    case NOTIFY_NDPINSTALL:
        ::swprintf( wszSubComp, L"NOTIFY_NDPINSTALL - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        //Private Function Call set up to communicate that another component
        // wishes us to either install or not
        //
        dwReturnValue = OnNdpInstall( szSubcomponentId, uiParam1, pvParam2 );
        break;

    default:
        ::swprintf( wszSubComp, L"default... UNRECOGNIZED - SubComponent: %s", szSubcomponentId );
        LogInfo( wszSubComp );

        dwReturnValue = UNRECOGNIZED;
        break;

   }  // end of switch( uiFunction )

   return dwReturnValue;
}


//////////////////////////////////////////////////////////////////////////////
// OnPreInitialize
// Receives: UINT  - char width flags
// Returns : DWORD - a flag indicating which char width we want to run in
// Purpose : handler for OC_PREINITIALIZE
//
DWORD CUrtOcmSetup::OnPreInitialize( UINT uiCharWidth )
{
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnPreInitialize(), charWidth = %d", uiCharWidth );
    LogInfo( infoString );

#ifdef ANSI
    if( !( uiCharWidth & OCFLAG_ANSI ) )
    {
        assert( !L"CUrtOcmSetup::OnPreInitialize(): Ansi character width not supported!" );
    }

    return OCFLAG_ANSI;
#else
    if( !( uiCharWidth & OCFLAG_UNICODE ) )
    {
        assert( !L"CUrtOcmSetup::OnPreInitialize(): Unicode character width not supported!" );
    }

    return OCFLAG_UNICODE;
#endif
}

//////////////////////////////////////////////////////////////////////////////
// InitializeComponent
// Receives: PSETUP_INIT_COMPONENT - pointer to SETUP_INIT_COMPONENT structure
// Returns : DWORD                 - Win32 error indicating outcome
// Purpose : handler for OC_INIT_COMPONENT
//
DWORD CUrtOcmSetup::InitializeComponent( PSETUP_INIT_COMPONENT pSetupInitComponent )
{
    LogInfo( L"InitializeComponent()" );

    DWORD dwReturnValue = NO_ERROR;

    //Save off a copy of the Component information
    //
    assert( NULL != pSetupInitComponent );
    ::memcpy(
        &m_InitComponent,
        static_cast<PSETUP_INIT_COMPONENT>(pSetupInitComponent),
        sizeof(SETUP_INIT_COMPONENT) );

    //This code segment determines whether the version of OC Manager is
    // correct
    //
    if( OCMANAGER_VERSION <= m_InitComponent.OCManagerVersion )
    {
        //Indicate to OC Manager which version of OC Manager this dll expects
        //
        m_InitComponent.ComponentVersion = OCMANAGER_VERSION;
    }
    else
    {
        dwReturnValue = ERROR_CALL_NOT_IMPLEMENTED;
    }

    return dwReturnValue;
}

//////////////////////////////////////////////////////////////////////////////
// OnSetLanguage
// Receives: UINT  - Win32 LANGID
// Returns : DWORD - a boolean indicating whether we think we support the 
//                   requested language
// Purpose : handler for OC_SET_LANGUAGE
//
DWORD CUrtOcmSetup::OnSetLanguage( UINT uiLangID )
{
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnSetLanguage(), languageID = %d", uiLangID );
    LogInfo( infoString );

    BOOL fLangOK = TRUE;

    //REVIEW: 1/30/01 JoeA
    // we are only recognizing English or Neutral strings at this time
    //
    if( LANG_NEUTRAL == PRIMARYLANGID( uiLangID ) )
    {
        m_wLang = LANG_NEUTRAL;
    }
    else if( LANG_ENGLISH == PRIMARYLANGID( uiLangID ) )
    {
        m_wLang = LANG_ENGLISH;
    }
    else
    {
        fLangOK = FALSE;
    }

    return static_cast<DWORD>(fLangOK);
}

//////////////////////////////////////////////////////////////////////////////
// OnQueryImage
// Receives: UINT  - low 16 bits used to specify image to be used
//           DWORD - width (low word) and height (high word) of image
// Returns : DWORD - an HBITMAP or NULL on error
// Purpose : handler for OC_QUERY_IMAGE
//
DWORD CUrtOcmSetup::OnQueryImage( UINT uiImage, DWORD dwImageSize )
{
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnQueryImage(), image = %d, imageSize = %d", uiImage, dwImageSize );
    LogInfo( infoString );

    UNREFERENCED_PARAMETER( uiImage );
    UNREFERENCED_PARAMETER( dwImageSize );

    //Assuming OCM will clean up the bitmap handle
    //  ... arbitrarily picking bitmap "4" ... diamond shape
    //
    return reinterpret_cast<DWORD>(::LoadBitmap( NULL, MAKEINTRESOURCE( 4 )) );
}

//////////////////////////////////////////////////////////////////////////////
// OnRequestPages
// Receives: PSETUP_REQUEST_PAGES - pointer to variable-sized page structure
// Returns : DWORD - number of pages entered into the structure
// Purpose : handler for OC_REQUEST_PAGES
//
DWORD CUrtOcmSetup::OnRequestPages( PSETUP_REQUEST_PAGES prpPages )
{
    LogInfo( L"OnRequestPages()" );

    UNREFERENCED_PARAMETER( prpPages );

    //we have no custom pages
    //
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// OnQuerySkipPage
// Receives: UINT  - enum of type OcManagerPage
// Returns : DWORD - zero indicates skip page; non-zero indicates not to
// Purpose : handler for OC_QUERY_SKIP_PAGE
//
DWORD CUrtOcmSetup::OnQuerySkipPage( OcManagerPage ocmpPage )
{
    LogInfo( L"OnQuerySkipPage()" );

    UNREFERENCED_PARAMETER( ocmpPage );

    //REVIEW: 1/30/01 JoeA
    // we are a hidden component and have no UI ... we do not care
    // if any or all pages are skipped. Skipping page will not alter
    // the installation functionality
    //
    return !(0);
}

//////////////////////////////////////////////////////////////////////////////
// OnQueryChangeSelectionState
// Receives: UINT    - specifies proposed new selection state 
//                     (0 = not selected; non-0 is selected )
//           PVOID   - flags encoded as bit field
//           LPCTSTR - subcomponent name
// Returns : DWORD - BOOLEAN specifying whether proposed state s/b accepted
//                   if a zero value is returned, the selection state is not 
//                   changed
// Purpose : handler for OC_QUERY_CHANGE_SEL_STATE
//
DWORD CUrtOcmSetup::OnQueryChangeSelectionState( UINT uiNewState, PVOID pvFlags, LPCTSTR szComp )
{
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnQueryChangeSelectionState(), newState = %d", uiNewState );
    LogInfo( infoString );

    if( !szComp || !*szComp )
    {
        return NO_ERROR;
    }

    UNREFERENCED_PARAMETER( pvFlags );

    DWORD dwRet = 0;

    //REVIEW: 1/30/01 JoeA
    // we are a hidden component ... the user should never be able to turn
    // us off
    //
    if( NOT_SELECTED == uiNewState )
    {
        LogInfo( L"CUrtOcmSetup::OnQueryChangeSelectionState(): Selection state turned off! Not expected!" );
    }
    else
    {
        dwRet = 1;
    }

    return dwRet;
}

//////////////////////////////////////////////////////////////////////////////
// OnCalculateDiskSpace
// Receives: UINT    - 0 if removing component or non-0 if adding component
//           HDSKSPC - HDSKSPC to operate on
//           LPCTSTR - Subcomponent id
// Returns : DWORD   - Return value is Win32 error code indicating outcome
// Purpose : handler for OC_CALC_DISK_SPACE
//
DWORD CUrtOcmSetup::OnCalculateDiskSpace( UINT uiAdd, HDSKSPC hdSpace, LPCTSTR szComp )
{
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnCalculateDiskSpace(), adding = %d", uiAdd );
    LogInfo( infoString );

    if( !szComp || !*szComp )
    {
        return NO_ERROR;
    }

    //set dirs
    //
    SetVariableDirs();

    BOOL fSucceeded = TRUE;
    BOOL fGoodDataFile = TRUE;
    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::OnCalculateDiskSpace(): Invalid handle to INF file." );
        fGoodDataFile = FALSE;
    }

    if( uiAdd && fGoodDataFile )
    {
        //creates section with name like
        // [<szComp>_install]
        WCHAR szInstallSection[MAX_PATH+1] = EMPTY_BUFFER;
        ::wcscpy( szInstallSection, szComp );
        ::wcscat( szInstallSection, g_szInstallString );

        ::swprintf( infoString, L"OnCalculateDiskSpace(), adding size from section %s", szInstallSection );
        LogInfo( infoString );

        fSucceeded = ::SetupAddInstallSectionToDiskSpaceList(
            hdSpace,
            m_InitComponent.ComponentInfHandle,
            NULL,
            szInstallSection,
            0,
            0 );
    }
    
    return ( fSucceeded ) ? NO_ERROR : ::GetLastError();
}

//////////////////////////////////////////////////////////////////////////////
// OnQueueFileOperations
// Receives: LPCTSTR  - Subcomponent id
//           HSPFILEQ - HSPFILEQ to operate on
// Returns : DWORD    - Win32 error code indicating outcome
// Purpose : handler for OC_QUEUE_FILE_OPS
//
DWORD CUrtOcmSetup::OnQueueFileOperations( LPCTSTR szComp, HSPFILEQ pvHFile )
{
    LogInfo( L"OnQueueFileOperations()" );

    BOOL fRet = NO_ERROR;

    if( !szComp || !*szComp )
    {
        return NO_ERROR;
    }

    BOOL fGoodDataFile = TRUE;
    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::OnQueueFileOperations(): Invalid handle to INF file." );
        fGoodDataFile = FALSE;
    }

    //is component currently selected for installation
    //
    if(!g_bInstallOK)
    {
        //g_bInstallComponent is set to FALSE because netfx is not being called by any component 
        //to set to install so far. g_bInstallOK is true only if the setup is being run on server
        //or some component has called netfx with a requetst to install.
        
        g_bInstallComponent = g_bInstallOK;     
        LogInfo( L"Netfx is not set to install" );
        fRet = NO_ERROR;
    }
    else
    {
    
        OCMANAGER_ROUTINES ohr = m_InitComponent.HelperRoutines;
        BOOL bCurrentState = ohr.QuerySelectionState( 
            ohr.OcManagerContext,szComp, 
            OCSELSTATETYPE_CURRENT );

        if( szComp && bCurrentState && fGoodDataFile )
        {
            //creates section with name like
            // [<szComp>_install]
            WCHAR szInstallSection[MAX_PATH+1] = EMPTY_BUFFER;
            ::wcscpy( szInstallSection, szComp );
            ::wcscat( szInstallSection, g_szInstallString );

            WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
            ::swprintf( infoString, L"OnQueueFileOperations(), adding files from section %s", szInstallSection );
            LogInfo( infoString );

            // queue files to install
            if( !::SetupInstallFilesFromInfSection(
                    m_InitComponent.ComponentInfHandle,
                    NULL,
                    pvHFile,
                    szInstallSection,
                    NULL,
                    SP_COPY_FORCE_NEWER ) )
            {
                fRet = ::GetLastError();
            }
        }
    }

    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
// OnNeedMedia
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_NEED_MEDIA
//
DWORD CUrtOcmSetup::OnNeedMedia( VOID )
{
    LogInfo( L"OnNeedMedia()" );

    return static_cast<DWORD>(FALSE);
}

//////////////////////////////////////////////////////////////////////////////
// OnQueryStepCount
// Receives: LPCTSTR - subcomponent id
// Returns : DWORD   - number of steps to include 
// Purpose : handler for OC_QUERY_STEP_COUNT
//
DWORD CUrtOcmSetup::OnQueryStepCount( LPCTSTR szSubCompId )
{
    LogInfo( L"OnQueryStepCount()" );

    //the return will reflect the number of non-filecopy "steps" (operations?)
    // in the setup. ScriptDebugger used the count of registry lines, ocgen
    // used a hard-coded number.
    //
    DWORD dwRetVal = NO_ERROR;

    return dwRetVal;
}

//////////////////////////////////////////////////////////////////////////////
// OnAboutToCommitQueue
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_ABOUT_TO_COMMIT_QUEUE
//
DWORD CUrtOcmSetup::OnAboutToCommitQueue( VOID )
{
    LogInfo( L"OnAboutToCommitQueue()" );

    return DEFAULT_RETURN;
}

//////////////////////////////////////////////////////////////////////////////
// OnCompleteInstallation
// Receives: LPCTSTR- Subcomponent id
// Returns : DWORD - 
// Purpose : handler for OC_COMPLETE_INSTALLATION
//
DWORD CUrtOcmSetup::OnCompleteInstallation( LPCTSTR szComp )
{
    LogInfo( L"OnCompleteInstallation()" );
    
    g_bIsEverettInstalled = IsEverettInstalled();

    //installation is handled in this call
    //
    BOOL fRet = NO_ERROR;
    if( !szComp || !*szComp )
    {
        return NO_ERROR;
    }

    BOOL fGoodDataFile = TRUE;
    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::OnCompleteInstallation(): Invalid handle to INF file." );
        fGoodDataFile = FALSE;
    }

    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;

    if( szComp && fGoodDataFile )
    {
        //creates section with name like
        // [<szComp>_install]
        //
        WCHAR szInstallSection[MAX_PATH+1] = EMPTY_BUFFER;
        ::wcscpy( szInstallSection, szComp );
        ::wcscat( szInstallSection, g_szInstallString );

        // update HKLM,software\microsoft\windows\currentversion\sharedlls
        // registry values, for all files that we copy
        UpdateSharedDllsRegistryValues( szInstallSection );

        //Handle registration details (AddReg, DelReg, and RegisterDlls) and ProfileItems
        //
        ::swprintf( infoString, L"OnCompleteInstallation(), cycling through registration actions from %s", szInstallSection );
        LogInfo( infoString );

        if( !::SetupInstallFromInfSection( 
            0,
            m_InitComponent.ComponentInfHandle,
            szInstallSection,
            SPINST_REGISTRY | SPINST_REGSVR | SPINST_PROFILEITEMS,
            0,0,0,0,0,0,0 ) )
        {
            fRet = GetLastError();
        }

        //TypeLib registration ... cycle through sections
        //
        ::swprintf( infoString, L"OnCompleteInstallation(), cycling through typelib actions from %s", szInstallSection );
        LogInfo( infoString );

        CUrtInfSection sectTypeLibs( 
            m_InitComponent.ComponentInfHandle, 
            szInstallSection, 
            g_szTypeLibSection );

        for( UINT i = 1; i <= sectTypeLibs.count(); ++i )
        {
            const WCHAR* sz = sectTypeLibs.item( i );

            //REVIEW - 2/15/01 JoeA ... TRUE assumes installation
            //
            GetAndRegisterTypeLibs( sz, TRUE );
        }

        //Custom Action registration
        //
        ::swprintf( infoString, L"OnCompleteInstallation(), cycling through custom actions from %s", szInstallSection );
        LogInfo( infoString );

        CUrtInfSection sectCAHs( 
            m_InitComponent.ComponentInfHandle, 
            szInstallSection, 
            g_szCustActionSection );

        for( UINT i = 1; i <= sectCAHs.count(); ++i )
        {
            const WCHAR* sz = sectCAHs.item( i );

            //REVIEW - 2/15/01 JoeA ... TRUE assumes installation
            //
            GetAndRunCustomActions( sz, TRUE );  
        }

        // delete files from [temp_files] section
        DeleteTempFiles();

        //Binding Actions
        //
        CUrtInfSection sectBind( 
            m_InitComponent.ComponentInfHandle, 
            szInstallSection, 
            g_szBindImageSection );
        
        const WCHAR* sz = NULL;

        for( UINT i = 1; i <= sectBind.count(); ++i )
        {
            sz = sectBind.item( i );
            BindImageFiles( sz );
        }
   }

   LogInfo(L"processing config files");
   ProcessConfigFiles();

   LogInfo( L"OnCompleteInstallation() finished succesfully" );
   return fRet;
}

//////////////////////////////////////////////////////////////////////////////
// OnCleanup
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_CLEANUP
//
DWORD CUrtOcmSetup::OnCleanup( VOID )
{
    LogInfo( L"OnCleanup()" );

    //at this point, there's nothing to clean up ... I expect some work to
    // happen here
    // Close logs, complete custom action work, restore initial reg settings...
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnNotificationFromQueue
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_NOTIFICATION_FROM_QUEUE
//
DWORD CUrtOcmSetup::OnNotificationFromQueue( VOID )
{
    LogInfo( L"OnNotificationFromQueue()" );

    //using ocgen.dll implementation
    //
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnFileBusy
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_FILE_BUSY
//
DWORD CUrtOcmSetup::OnFileBusy( VOID )
{
    LogInfo( L"OnFileBusy()" );

    //this is neither used in ocgen.dll or other source. Including here 
    // for completeness
    //
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnQueryError
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_QUERY_ERROR
//
DWORD CUrtOcmSetup::OnQueryError( VOID )
{
    LogInfo( L"OnQueryError()" );

    //this is neither used in ocgen.dll or other source. Including here 
    // for completeness
    //
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnPrivateBase
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_PRIVATE_BASE
//
DWORD CUrtOcmSetup::OnPrivateBase( VOID )
{
    LogInfo( L"OnPrivateBase()" );

    //this is neither used in ocgen.dll or other source. Including here 
    // for completeness
    //
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnQueryState
// Receives: UINT  - state value (OCSELSTATETYPE) ... see ocmanage.h for 
//                   definitions
// Returns : DWORD - 
// Purpose : handler for OC_QUERY_STATE
//
DWORD CUrtOcmSetup::OnQueryState( UINT uiState )
{
    LogInfo( L"OnQueryState()" );
    
    DWORD dwRetVal = static_cast<DWORD>( SubcompUseOcManagerDefault );

    if( OCSELSTATETYPE_ORIGINAL == uiState )
    {
        LogInfo( L"Called with OCSELSTATETYPE_ORIGINAL ... determining if we were installed previously." );
    }
    else if( OCSELSTATETYPE_CURRENT == uiState )
    {
        LogInfo( L"Called with OCSELSTATETYPE_CURRENT." );
        dwRetVal = static_cast<DWORD>( SubcompOn );
    }
    else if( OCSELSTATETYPE_FINAL == uiState )
    {
        //this is the "last call" where we decide if we persist as 
        // installed or removed!
        LogInfo( L"Called with OCSELSTATETYPE_FINAL ... will set subcomponent registry flag." );
        if(!g_bInstallOK)
        {
            LogInfo( L"Netfx is not set to install" );
            dwRetVal = static_cast<DWORD>( SubcompOff );
        }
    }
    else
    {
        LogInfo( L"Called with unknown state." );
    }

    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnQueryState(),Return Value is  %d", dwRetVal );
    LogInfo( infoString );

    return dwRetVal;
}

//////////////////////////////////////////////////////////////////////////////
// OnWizardCreated
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_WIZARD_CREATED
//
DWORD CUrtOcmSetup::OnWizardCreated( VOID )
{
    LogInfo( L"OnWizardCreated()" );

    //using ocgen.dll implementation
    //
    return static_cast<DWORD>(NO_ERROR);
}

//////////////////////////////////////////////////////////////////////////////
// OnExtraRoutines
// Receives: VOID
// Returns : DWORD - 
// Purpose : handler for OC_EXTRA_ROUTINES
//
DWORD CUrtOcmSetup::OnExtraRoutines( VOID )
{
    LogInfo( L"OnExtraRoutines()" );

    //using ocgen.dll implementation
    //
    return static_cast<DWORD>(NO_ERROR);
}



//////////////////////////////////////////////////////////////////////////////
// Helper Functions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// StateChanged
// Receives: LPCTSTR - component name
//           BOOL*   - TRUE if to be installed, FALSE otherwise
// Returns : DWORD - FALSE if no change in state; TRUE otherwise
// Purpose : determines if installation state has changed from original mode
//
BOOL CUrtOcmSetup::StateChanged( LPCTSTR szCompName, BOOL* pfChanged )
{
    BOOL rc = TRUE;

    if( NULL == szCompName )
    {
        assert( !L"CUrtOcmSetup::StateChanged(): Empty component name string passed in." );
    }

    if( NULL == pfChanged )
    {
        assert( !L"CUrtOcmSetup::StateChanged(): NULL boolean flag passed in." );
    }

    OCMANAGER_ROUTINES ohr = m_InitComponent.HelperRoutines;
    BOOL fOrigState = ohr.QuerySelectionState( 
                                        ohr.OcManagerContext, 
                                        szCompName, 
                                        OCSELSTATETYPE_ORIGINAL );

    // make sure it's already installed
    //
    if( fOrigState )
    {
        // Fix bug 249593: StateChanged should return TRUE if we upgrade
        if( ( m_InitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE ) == SETUPOP_NTUPGRADE )
        {
            return rc;
        }
    }

    // otherwise, check for a change in installation state
    //
    *pfChanged = ohr.QuerySelectionState( 
                                        ohr.OcManagerContext, 
                                        szCompName, 
                                        OCSELSTATETYPE_CURRENT );


    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"StateChanged() Original=%d, Current=%d", *pfChanged, fOrigState );
    LogInfo( infoString );

    if( *pfChanged == fOrigState )
    {
        //no change
        //
        rc = FALSE;
    }

    return rc;
}


//////////////////////////////////////////////////////////////////////////////
// RegTypeLibrary
// Receives: WCHAR* - pointer to fully qualified path to the TLB file
//           WCHAR* - pointer to fully qualified path to the help directory
// Returns : VOID
// Purpose : registers TLBs
//
VOID CUrtOcmSetup::RegTypeLibrary( const WCHAR* wzFilename, const WCHAR* wzHelpDir )
{
//review ... oleinitialize?
    WCHAR wszFile[_MAX_PATH*2+1] = EMPTY_BUFFER;
    ::swprintf( wszFile, L"RegTypeLibrary() - File: %s", wzFilename );
    LogInfo( wszFile );

    if( NULL == wzFilename )
    {
        assert( !L"CUrtOcmSetup::RegTypeLibrary(): Empty filename string passed in." );
    }

    if( NULL == wzHelpDir )
    {
        assert( !L"CUrtOcmSetup::RegTypeLibrary(): Empty help directory string passed in." );
    }

    ITypeLib* pTypeLib = NULL;

    HRESULT hr = ::LoadTypeLib( wzFilename, &pTypeLib );

    if( SUCCEEDED(hr) )
    {
        //have to case away constness ... 
        //
        hr = ::RegisterTypeLib( 
            pTypeLib, 
            const_cast<WCHAR*>(wzFilename), 
            const_cast<WCHAR*>(wzHelpDir) );
    }
}


//////////////////////////////////////////////////////////////////////////////
// SetVariableDirs
// Receives: VOID
// Returns : VOID
// Purpose : sets the INF data for variable dirs
//
VOID CUrtOcmSetup::SetVariableDirs( VOID )
{

    static int once = 0;

    if (once)
    {
        return;
    }
    once = 1;

    LogInfo( L"SetVariableDirs()" );
    
    WCHAR szBuf[_MAX_PATH+1] = EMPTY_BUFFER;
    WCHAR *pCh = NULL;
    WCHAR *pNewStart = NULL;
    DWORD dwLen = sizeof(szBuf);
    HKEY hKey = 0;
    
    try
    {
        if( ::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            g_szWwwRootRegKey,
            0,
            KEY_QUERY_VALUE,
            &hKey) != ERROR_SUCCESS )
            throw("cannot open Reg Key");
        
        if( ::RegQueryValueEx(hKey,
            L"/",
            NULL,
            NULL,
            (LPBYTE)szBuf,
            &dwLen
            ) != ERROR_SUCCESS )
        {
            ::RegCloseKey(hKey);
            throw("cannot read Reg Key");
        }
        
        ::RegCloseKey(hKey);

        // Try to find ',' and throw away everything beyond the comma
        pCh = szBuf;
        while(*pCh != g_chEndOfLine && *pCh != ',') 
        {
            pCh = ::CharNext(pCh);
        }
        if (*pCh == g_chEndOfLine) 
        {
            // there's no comma. must be bad format
            throw("bad format");
        }
        *pCh = g_chEndOfLine;


        // cut everything before first backslash:
        pCh = szBuf;
        while(*pCh != g_chEndOfLine && *pCh != '\\') 
        {
            pCh = ::CharNext(pCh);
        }
        if (*pCh == g_chEndOfLine) 
        {
            // there's no backslash must be bad format
            throw("bad format");
        }
        // go one symbol after backslash
        pCh = ::CharNext(pCh);

        // start copying everything beyond the backslash to the beginning of the buffer
        pNewStart = szBuf;
        while (*pCh != g_chEndOfLine)
        {
            *pNewStart = *pCh;
            
            pNewStart = ::CharNext(pNewStart);
            pCh = ::CharNext(pCh);
        }

        *pNewStart = g_chEndOfLine;
    }
    catch(char *)
    {
        ::wcscpy( szBuf, g_szDefaultWWWRoot );
    }

    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::SetVariableDirs(): Invalid handle to INF file." );
    }
    else
    {
        //Setting the directory ID for inetpubs path
        //
        //REVIEW: 2/14/01  -joea
        // not checking for return ... if we can't make directory we should do something
        // when we make this variable, we should do something
        ::SetupSetDirectoryIdEx(
            m_InitComponent.ComponentInfHandle,   // handle to the INF file
            g_dwInetPubsDirID,                    // DIRID to assign to Directory
            szBuf,                                // directory to map to identifier
            SETDIRID_NOT_FULL_PATH,               // flags ... only available is "SETDIRID_NOT_FULL_PATH"
                                                  //  if you use "0", this sets fully qualified path
            0,                                    // unused
            0 );                                  // unused
    }
}


//////////////////////////////////////////////////////////////////////////////
// GetAndRegisterTypeLibs
// Receives: WCHAR* - string of type lib section to register
//           BOOL   - determines installation or removal; TRUE to install
// Returns : VOID
 // Purpose : gets tlib reg calls from the INF and registers them
//
// Expecting INF section that looks like this
//      [TypeLib]
//      %10%\Microsoft.NET\Framework\v1.0.2609\Microsoft.ComServices.tlb, %10%\Microsoft.NET\Framework\v1.0.2609
//
VOID CUrtOcmSetup::GetAndRegisterTypeLibs( const WCHAR* szTLibSection, BOOL fInstall )
{
    //REVIEW: unused boolean parameter - joea 02/20/01

    LogInfo( L"GetAndRegisterTypeLibs()" );

    if( NULL == szTLibSection )
    {
        assert( !L"CUrtOcmSetup::GetAndRegisterTypeLibs(): Empty section string passed in." );
    }

    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::GetAndRegisterTypeLibs(): Invalid handle to INF file." );
    }
    else
    {
        CUrtInfKeys keys( m_InitComponent.ComponentInfHandle, szTLibSection );

        for( UINT i = 1; i <= keys.count(); ++i )
        {
            //parse string for directory
            //
            WCHAR szBuffer[_MAX_PATH+1] = EMPTY_BUFFER;
            ::wcscpy( szBuffer, keys.item( i ) );
            WCHAR* pszEnd = ::wcschr( szBuffer, L',' );
            WCHAR* pszDir = NULL;

            if( pszEnd )
            {
                pszDir = ::CharNext( pszEnd );
                *pszEnd = L'\0';
            }

            RegTypeLibrary( szBuffer, pszDir ? pszDir : L"" );
        }
    }
}



//////////////////////////////////////////////////////////////////////////////
// GetAndRunCustomActions
// Receives: WCHAR* - contains the name of the section from which to retrieve
//                    the custom actions
//           BOOL   - determines installation or removal; TRUE to install
// Returns : VOID
// Purpose : retrieves the list of custom actions to run and spawns them. 
//
VOID CUrtOcmSetup::GetAndRunCustomActions( const WCHAR* szSection, BOOL fInstall )
{
    //REVIEW: unused boolean parameter - joea 02/20/01

    LogInfo( L"GetAndRunCustomActions()" );
    
    
    if( NULL == szSection )
    {
        assert( !L"CUrtOcmSetup::GetAndRunCustomActions(): Empty section string passed in." );
    }

    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::GetAndRunCustomActions(): Invalid handle to INF file." );
    }
    else
    {
        CUrtInfKeys keys( m_InitComponent.ComponentInfHandle, szSection );

        for( UINT i = 1; i <= keys.count(); ++i )
        {
            const WCHAR *pszCustomActionName = keys.item( i );

            if( g_bIsEverettInstalled )
            {
                WCHAR *pszMigrationPos = ::wcsstr( pszCustomActionName, g_szMigrationCA );
                if( NULL != pszMigrationPos )
                {
                    WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
                    ::swprintf( infoString, L"Everett is already installed. Not Executing: %s", 
                        pszCustomActionName);
                    LogInfo( infoString );
                }
                else
                {
                    QuietExec( pszCustomActionName );
                }
            }

            else // Everett is not installed
            {
                QuietExec( pszCustomActionName );
            }

        }
    }
}





//////////////////////////////////////////////////////////////////////////////
// LogInfo
// Receives: LPCTSTR - null terminated string to log
// Returns : VOID
// Purpose : write a string to the logFile (m_csLogFileName) with the date and 
//           time stamps
// 
VOID CUrtOcmSetup::LogInfo( LPCTSTR szInfo )
{
    FILE *logFile = NULL;

    if( NULL == m_csLogFileName )
    {
        assert( !L"CUrtOcmSetup::LogInfo(): NULL string passed in." );
    }

    if( (logFile  = ::_wfopen( m_csLogFileName, L"a" )) != NULL )
    {
        WCHAR dbuffer[10] = EMPTY_BUFFER;
        WCHAR tbuffer[10] = EMPTY_BUFFER;
        
        ::_wstrdate( dbuffer );
        ::_wstrtime( tbuffer );

        ::fwprintf( logFile, L"[%s,%s] %s\n", dbuffer, tbuffer, szInfo );
        ::fclose( logFile );
    }
}

//////////////////////////////////////////////////////////////////////////////
// DeleteTempFiles
// Receives: VOID
// Returns : VOID
// Purpose : delete files from the [temp_files_delete] section
// 
VOID CUrtOcmSetup::DeleteTempFiles( VOID )
{
    LogInfo( L"DeleteTempFiles()" );

    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::DeleteTempFiles(): Invalid handle to INF file." );
    }
    else
    {
        CUrtInfKeys keys( m_InitComponent.ComponentInfHandle, g_szTempSection );
      
        WCHAR pszFileName[_MAX_PATH+1] = EMPTY_BUFFER;
        WCHAR pszDirName[_MAX_PATH+1] = EMPTY_BUFFER;
        for( UINT i = 1; i <= keys.count(); ++i )
        {   
            ::wcscpy( pszFileName, keys.item( i ) );

            // delete file (change first attributes from read-only to normal)
            if ((::GetFileAttributes( pszFileName ) & FILE_ATTRIBUTE_READONLY) == FILE_ATTRIBUTE_READONLY)
            {
                ::SetFileAttributes( pszFileName, FILE_ATTRIBUTE_NORMAL);
            }
            if ( ::DeleteFile( pszFileName ) == 0 )
            {
                DWORD dwError = ::GetLastError();

                WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
                ::swprintf( infoString, L"Cannot delete file: %s, GetLastError = %d", 
                    pszFileName, dwError);
                LogInfo( infoString );
            }              
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// BindImageFiles
// Receives: WCHAR* - string of file section to bind
// Returns : VOID
// Purpose : Bind files from the given section
// 
VOID CUrtOcmSetup::BindImageFiles( const WCHAR* szSection )
{
    LogInfo( L"BindImageFiles()" );


    if( NULL == szSection )
    {
        assert( !L"CUrtOcmSetup::BindImageFiles(): Empty section string passed in." );
    }

    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::BindImageFiles(): Invalid handle to INF file." );
    }
    else
    {
        WCHAR pszFileName[_MAX_PATH+1] = EMPTY_BUFFER;
        WCHAR pszDirName[_MAX_PATH+1] = EMPTY_BUFFER;
        LPSTR pFileName = NULL;
        LPSTR pDirName = NULL;

        USES_CONVERSION; // to be able to use ATL macro W2A

        CUrtInfKeys keys( m_InitComponent.ComponentInfHandle, szSection );
        for( UINT i = 1; i <= keys.count(); ++i )
        {
            ::wcscpy( pszFileName, keys.item( i ) );
            ::wcscpy( pszDirName, keys.item( i ) );
            WCHAR* pBackslash = NULL;
            pBackslash = ::wcsrchr( pszDirName, L'\\' );
            if( pBackslash != NULL )
            {
                *pBackslash = L'\0'; // now pszDirName contains directory name

                // change first attributes from read-only to normal
                DWORD fileAtributes = 0;
                fileAtributes = ::GetFileAttributes( pszFileName );
                if ((fileAtributes & FILE_ATTRIBUTE_READONLY) == FILE_ATTRIBUTE_READONLY)
                {
                    ::SetFileAttributes( pszFileName, FILE_ATTRIBUTE_NORMAL);
                }

                pFileName = W2A(pszFileName);
                pDirName = W2A(pszDirName);

                if ( ::BindImage( pFileName, pDirName, pDirName ) == FALSE )
                {
                    DWORD dwError = ::GetLastError();
                    
                    WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
                    ::swprintf( infoString, 
                        L"Cannot Bind file: %s, GetLastError = %d", 
                        pszFileName, 
                        dwError );
                    LogInfo( infoString );
                }
                else
                {
                    WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
                    ::swprintf( infoString, 
                        L"BindImage file: %s finished successfully", 
                        pszFileName );
                    LogInfo( infoString );
                }
                    
                // change back files attributes
                if (fileAtributes)
                {
                    ::SetFileAttributes( pszFileName, fileAtributes );
                }
            }
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// UpdateSharedDllsRegistryValues
// Receives: VOID
// Returns : VOID
// Purpose : update HKLM,software\microsoft\windows\currentversion\sharedlls
//           registry values, for all files that we copy
VOID CUrtOcmSetup::UpdateSharedDllsRegistryValues( LPCTSTR szInstallSection )
{
    LogInfo( L"UpdateSharedDllsRegistryValues()" );

    HKEY hKey = NULL;
    // open the g_szSharedDlls regKey, if it does not exist, create a new one
    if (::RegCreateKeyExW(HKEY_LOCAL_MACHINE, g_szSharedDlls, 0, NULL,
        REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS, NULL, &hKey, NULL) != ERROR_SUCCESS)
    {
        WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
        ::swprintf( infoString, L"Error: UpdateRegistryValue: Can't create a reg key %s", 
            g_szSharedDlls );
        LogInfo( infoString );
        ::RegCloseKey(hKey);
        return;
    }

    if( m_InitComponent.ComponentInfHandle == NULL )
    {
        LogInfo( L"CUrtOcmSetup::UpdateSharedDllsRegistryValues(): Invalid handle to INF file." );
    }
    else
    {
        // create a fullFileName for each file that we copy
        CUrtInfSection sectCopyFiles( 
                m_InitComponent.ComponentInfHandle, 
                szInstallSection, 
                g_szCopyFilesSection );

        WCHAR szDirPath[_MAX_PATH+1] = EMPTY_BUFFER;
        WCHAR szFileStr[_MAX_PATH+1] = EMPTY_BUFFER;

        for( UINT i = 1; i <= sectCopyFiles.count(); ++i )
        {
            const WCHAR *szDirSection = sectCopyFiles.item(i);

            // get a full path of the Directory
            ::ZeroMemory( szDirPath, _MAX_PATH+1);
            if (!::SetupGetTargetPath(m_InitComponent.ComponentInfHandle, NULL, szDirSection, szDirPath, 
                sizeof(szDirPath), NULL))
            {
                LogInfo(L"Error: UpdateSharedDllsRegistryValues: SetupGetTargetPath failed");
                continue;
            }
            
            // open section, get files
            CUrtInfKeys fileKeys( m_InitComponent.ComponentInfHandle, szDirSection );
            for( UINT iFile = 1; iFile <= fileKeys.count(); ++iFile )
            {
                szFileStr[0] = g_chEndOfLine;
                ::wcsncpy(szFileStr, fileKeys.item(iFile), sizeof(szFileStr)/sizeof(szFileStr[0]));
                WCHAR* pComma = NULL;
                pComma = ::wcschr( szFileStr, L',' ); 
                if ( pComma == NULL )
                {
                    WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
                    ::swprintf( infoString, L"Error: UpdateSharedDllsRegistryValues: Wrong format in '%s' string", szFileStr );
                    LogInfo( infoString );
                    continue;
                }
                *pComma = g_chEndOfLine;

                // do not update ref count for policy files
                if (::_wcsnicmp(szFileStr, L"policy.", 7) == 0)
                {
                   continue; 
                }
                
                WCHAR szFullFileName[_MAX_PATH+1] = EMPTY_BUFFER;
                
                ::wcsncpy(szFullFileName, szDirPath, sizeof(szFullFileName)/sizeof(szFullFileName[0]));
                ::wcsncat(szFullFileName, L"\\", 1);
                ::wcsncat(szFullFileName, szFileStr, szFileStr - pComma);

                // update HKLM,software\microsoft\windows\currentversion\sharedlls value
                UpdateRegistryValue(hKey, szFullFileName);
            }
        }

        CUrtInfKeys SBSkeys( m_InitComponent.ComponentInfHandle, g_szSbsComponentSection );
      
        WCHAR pszFileName[_MAX_PATH+1] = EMPTY_BUFFER;
        
        for( UINT i = 1; i <= SBSkeys.count(); ++i )
        {   
            ::wcscpy( pszFileName, SBSkeys.item( i ) );           
            UpdateRegistryValue(hKey, pszFileName);

            WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
            ::swprintf( infoString, L"UpdateSharedDllsRegistryValues: Writing shared dll registry for '%s' file", pszFileName );
            LogInfo( infoString );
        }

    }

    // close SharedDlls regkey
    ::RegCloseKey(hKey);
}

//////////////////////////////////////////////////////////////////////////////
// UpdateRegistryValue
// Receives: VOID
// Returns : VOID
// Purpose : helper function for UpdateSharedDllsRegistryValues
VOID CUrtOcmSetup::UpdateRegistryValue( HKEY &hKey, const WCHAR* szFullFileName )
{
    if( szFullFileName == NULL )
    {
        assert( !L"UpdateRegistryValue: szFullFileName is NULL." );
        LogInfo(L"UpdateRegistryValue: szFullFileName is NULL.");
        return;
    }

    DWORD dwValue = 0;
    DWORD dwSize = sizeof(dwValue);
    DWORD dwRegType = REG_DWORD;
    if( ::RegQueryValueExW(
            hKey, 
            szFullFileName, 
            0, 
            &dwRegType, 
            (LPBYTE)&dwValue, 
            &dwSize ) != ERROR_SUCCESS )
    {
        // value does not exist, create a new value
        dwValue = 1;
        dwSize = sizeof(dwValue);
        if( ::RegSetValueExW(
                hKey, 
                szFullFileName, 
                0, 
                REG_DWORD, 
                (LPBYTE)&dwValue, 
                dwSize ) != ERROR_SUCCESS )
        {
            WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
            ::swprintf( 
                infoString, 
                L"Error: UpdateRegistryValue: Can't set value to the new reg key %s", 
                szFullFileName );
            LogInfo( infoString );
        }
    }
    else
    {
        // update the value
        dwValue = dwValue + 1;
        dwSize = sizeof(dwValue);
        if( ::RegSetValueExW(
                hKey, 
                szFullFileName, 
                0, 
                REG_DWORD, 
                (LPBYTE)&dwValue, 
                dwSize ) != ERROR_SUCCESS )
        {
            WCHAR infoString[2*_MAX_PATH+1] = EMPTY_BUFFER;
            ::swprintf( 
                infoString, 
                L"Error: UpdateSharedDllsRegistryValues: Can't set value to the existing reg key %s", 
                szFullFileName );
            LogInfo( infoString );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// OnNdpInstall
// Receives: LPCTSTR - subcomponent identifier
//           UINT    - whether we should install or not (as far as eHome 
//                     or tablet pc cares)
//           PVOID   - name of the calling component
// Returns : DWORD   - success or failure
// Purpose : handler for NOTIFY_NDPINSTALL
//
DWORD CUrtOcmSetup::OnNdpInstall( LPCTSTR szSubcomponentId, UINT uiParam1, PVOID pvParam2 )
{

    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
    ::swprintf( infoString, L"OnNdpInstall(), subcomponent %s with flag = %d", szSubcomponentId, uiParam1 );
    LogInfo( infoString );
 
    //test that we have a valid calling component
    //
    if( NULL == pvParam2 ||
        0 == wcslen( reinterpret_cast<WCHAR*>(pvParam2) ) )
    {

        LogInfo( L"Calling component not named; aborting installation." );
        return ERROR_INVALID_DATA;
    }
    else
    {
        ::swprintf( infoString, L"...called by component %s", reinterpret_cast<WCHAR*>(pvParam2) );
        LogInfo( infoString );
    }

    DWORD dwReturnValue = NO_ERROR;
    
    if( g_bInstallOK )
    {
        LogInfo( L"Netfx component is already marked for installation" );
    }
    else
    {
        //determine if eHome or TabletPC are being installed or not
        //

        if( NDP_INSTALL == uiParam1 )
        {
            LogInfo( L"Dependent component telling us to install." );
            g_bInstallOK = TRUE;
        }
        else
        {
            if( NDP_NOINSTALL != uiParam1 )
            {
                //this is unexpected and should never happen but ...
                //
                LogInfo( L"OnNdpInstall(), passed in parameter not understood; expecting 0 or 1." );
            }

            LogInfo( L"Dependent component telling us not to install ... they will not be installing on this machine." );
        }


    }

    return dwReturnValue;
}



//////////////////////////////////////////////////////////////////////////////
// ProcessConfigFiles
// Receives: None
// Returns : None
// Purpose : Reads the name of config file from config file section and 
//           tries to copy .config.orig file on top of .config files
//           FileCopy fails if the .config file alreads exists. 
//           After Filecopy it deletes the .orig file.

VOID CUrtOcmSetup::ProcessConfigFiles()
{
    
    
    WCHAR szConfigFileName[_MAX_PATH+1] = EMPTY_BUFFER;
    WCHAR szFileNameOrig[_MAX_PATH+1] = EMPTY_BUFFER;
    WCHAR infoString[_MAX_PATH+1] = EMPTY_BUFFER;
     
    CUrtInfKeys ConfigFileSection( m_InitComponent.ComponentInfHandle, g_szConfigFilesSection );
    
    UINT i = 1;
    while ( i <= ConfigFileSection.count() )
    {
        ::wcscpy( szConfigFileName, ConfigFileSection.item( i ) );
        ::wcscpy( szFileNameOrig, szConfigFileName);
        ::wcscat( szFileNameOrig, L".orig");
        
        if ( ::CopyFile( szFileNameOrig, szConfigFileName, TRUE) == 0)
        {
           ::swprintf( infoString, L"%s already exists. Not Replacing it. ", szConfigFileName );
            LogInfo( infoString );
        }
        else
        {
            ::swprintf( infoString, L"Copying %s on the machine. ", szConfigFileName );
            LogInfo( infoString );
        }

        if ( ::DeleteFile( szFileNameOrig ) == 0 )
        {
            ::swprintf( infoString, L"Can not delete %s. Please try to remove it manually. ", szFileNameOrig );
            LogInfo( infoString );
        }
        i++;

    }

}

//////////////////////////////////////////////////////////////////////////////
// IsEverettInstalled
// Receives: None
// Returns : None
// Purpose : Checks the registry key 
//           HKLM\SOFTWARE\Microsoft\NET Framework Setup\NDP\[Everett URTVersion]
//           if this key exist We assume Everett is installed.


BOOL CUrtOcmSetup::IsEverettInstalled()
{
    HKEY hKey;
    DWORD dwValue = 0;
    DWORD dwSize = sizeof(dwValue);
    DWORD dwRegType = REG_DWORD;
    WCHAR szRegistryKey[2*_MAX_PATH+1] =  EMPTY_BUFFER;
          
    CUrtInfKeys UrtVersionSection( m_InitComponent.ComponentInfHandle, g_szURTVersionSection );
    if( 1 > UrtVersionSection.count() )
    {
        LogInfo( L"The URTVersion section is Empty" );
        return FALSE;
    }
    
    ::wcscpy( szRegistryKey, g_szEverettRegKey );
    ::wcscat( szRegistryKey, UrtVersionSection.item( 1 ) );

    if( ::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
       szRegistryKey,
       0,
       KEY_QUERY_VALUE,
       &hKey ) != ERROR_SUCCESS ) 
    {
        LogInfo( L"Everett Install Registry key does not exist." );
        return FALSE;
    }

    LogInfo( L"Everett is Installed on the Machine." );
    ::RegCloseKey(hKey);
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\redist\makefile.inc ===
# additional dependencies

ndp_redist:
       @if not exist .\$(_TGTCPU)                     mkdir .\$(_TGTCPU)
       @if not exist .\$(_TGTCPU)\$(DDKBUILDENV)      mkdir .\$(_TGTCPU)\$(DDKBUILDENV)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\redist\msireader.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     MsiReader.h
// Owner:    jbae
// Purpose:  defines class CMsiReader
//                              
// History:
//  03/07/2002, jbae: created

#ifndef MSIREADER_H
#define MSIREADER_H

#include <windows.h>
#include "msiquery.h"
#include "StringUtil.h"

typedef UINT (CALLBACK* PFNMSIOPENDATABASE)(LPCTSTR, LPCTSTR, MSIHANDLE *);              // MsiOpenDatabase()
typedef UINT (CALLBACK* PFNMSIDATABASEOPENVIEW)(MSIHANDLE, LPCTSTR, MSIHANDLE *);        // MsiDatabaseOpenView()
typedef UINT (CALLBACK* PFNMSICREATERECORD)(unsigned int);                               // MsiCreateRecord()
typedef UINT (CALLBACK* PFNMSIVIEWEXECUTE)(MSIHANDLE, MSIHANDLE);                        // MsiViewExecute()
typedef UINT (CALLBACK* PFNMSIRECORDGETSTRING)(MSIHANDLE, unsigned int, LPTSTR, DWORD *);// MsiRecordGetString()
typedef UINT (CALLBACK* PFNMSIRECORDSETSTRING)(MSIHANDLE, unsigned int, LPTSTR);         // MsiRecordSetString()
typedef UINT (CALLBACK* PFNMSIVIEWFETCH)(MSIHANDLE, MSIHANDLE *);                        // MsiViewExecute()
typedef UINT (CALLBACK* PFNMSICLOSEHANDLE)(MSIHANDLE);                                   // MsiCLoseHandle()

// ==========================================================================
// class CMsiReader
//
// Purpose:
//  read properties from MSI
// ==========================================================================
class CMsiReader
{
public:
    // Constructor
    CMsiReader();
    ~CMsiReader();

protected:
    // Attributes
    LPTSTR m_pszMsiFile;
    CStringQueue m_Props;

public:
    void SetMsiFile( LPCTSTR pszSourceDir, LPCTSTR pszMsiFile );
    LPCTSTR GetProperty( LPCTSTR pszName );
    LPCTSTR GetMsiFile() const { return m_pszMsiFile; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\redist\stringutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "StringUtil.h"
#include <crtdbg.h>

CStringQueue::
~CStringQueue()
{
    PQUEUENODE pTmp;
    while( m_pHead )
    {
        pTmp = m_pHead;
        m_pHead = pTmp->pNext;
        delete pTmp;
    }
}

LPTSTR CStringQueue::
Enqueue( LPTSTR pszStr )
{
    if ( NULL == pszStr ) return NULL;
    if ( _T('\0') == *pszStr ) return NULL;

    PQUEUENODE pNode = new QUEUENODE( pszStr );
    _ASSERTE( pNode );
    m_nSize += _tcslen( pszStr );

    if ( NULL == m_pHead )
    {
        m_pHead = pNode;
        m_pHead->pNext = NULL;
    }
    else
    {
        PQUEUENODE pTmp = m_pHead;
        while( pTmp->pNext )
            pTmp = pTmp->pNext;

        pNode->pNext = NULL;
        pTmp->pNext = pNode;
    }
    return pNode->pszString;
}

LPTSTR CStringQueue::
Concat()
{
    if ( NULL == m_pHead ) return NULL;

    PQUEUENODE pNode = m_pHead;
    LPTSTR pszStr = new TCHAR[ m_nSize + 1 ];
    *pszStr = _T('\0');
    while( pNode )
    {
        _tcscat( pszStr, pNode->pszString );
        pNode = pNode->pNext;
    }
    Enqueue( pszStr );
    return pszStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\ocm\urt\urtocm.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
// Module Name: urtocm.h
//
// Abstract:
//    class declarations for setup object
//
// Author: JoeA
//
// Notes:
//

#if !defined( CURTOCMSETUP_H )
#define CURTOCMSETUP_H

#include "globals.h"
#include "infhelpers.h"

extern BOOL g_bIsAdmin;
extern BOOL g_bInstallOK;
extern BOOL g_bInstallComponent;


const DWORD UNRECOGNIZED = 0;
const DWORD DEFAULT_RETURN = 0;

//for use in ChangeSelectionState calls
const UINT  NOT_SELECTED = 0;
const UINT  SELECTED     = 1;

//for communication with eHome and TabletPC
//
#define NOTIFY_NDPINSTALL               OC_PRIVATE_BASE + 2
const UINT NDP_INSTALL   = 1;
const UINT NDP_NOINSTALL = 0;



class CUrtOcmSetup
{
public:
    CUrtOcmSetup();

    DWORD OcmSetupProc( LPCTSTR ComponentId,
                        LPCTSTR SubcomponentId,
                        UINT    Function,
                        UINT    Param1,
                        PVOID   Param2 );

private:
    //handler methods
    //
    DWORD OnPreInitialize( UINT uiCharWidth );
    DWORD InitializeComponent( PSETUP_INIT_COMPONENT pSetupInitComponent );
    DWORD OnSetLanguage( UINT uiLangID );
    DWORD OnQueryImage( UINT uiImage, DWORD dwImageSize);
    DWORD OnRequestPages( PSETUP_REQUEST_PAGES prpPages );
    DWORD OnQuerySkipPage( OcManagerPage ocmpPage );
    DWORD OnQueryChangeSelectionState( UINT uiNewState, PVOID pvFlags, LPCTSTR szComp );
    DWORD OnCalculateDiskSpace( UINT uiAdd, HDSKSPC hdSpace, LPCTSTR szComp );
    DWORD OnQueueFileOperations( LPCTSTR szComp, HSPFILEQ pvHFile );
    DWORD OnNeedMedia( VOID );
    DWORD OnQueryStepCount( LPCTSTR szSubCompId );
    DWORD OnAboutToCommitQueue( VOID );
    DWORD OnCompleteInstallation( LPCTSTR szComp );
    DWORD OnCleanup( VOID );
    DWORD OnNotificationFromQueue( VOID );
    DWORD OnFileBusy( VOID );
    DWORD OnQueryError( VOID );
    DWORD OnPrivateBase( VOID );
    DWORD OnQueryState( UINT uiState );
    DWORD OnWizardCreated( VOID );
    DWORD OnExtraRoutines( VOID );
    DWORD OnNdpInstall( LPCTSTR szSubcomponentId, UINT uiParam1, PVOID pvParam2 );

    //helper methods
    //
    BOOL StateChanged( LPCTSTR szCompName, BOOL* pfChanged );
    VOID RegTypeLibrary( const WCHAR* wzFilename, const WCHAR* wzHelpDir );
    VOID SetVariableDirs( VOID );
    
    // update HKLM,software\microsoft\windows\currentversion\sharedlls
    // registry values, for all files that we copy
    VOID UpdateSharedDllsRegistryValues(LPCTSTR szInstallSection);
    VOID UpdateRegistryValue( HKEY &hKey, const WCHAR* szFullFileName );

    VOID GetAndRegisterTypeLibs( const WCHAR* szTLibSection, BOOL fInstall );
    VOID GetAndRunCustomActions( const WCHAR* szSection, BOOL fInstall );

    // delete files from the [temp_files_delete] section
    VOID DeleteTempFiles( VOID );

    // write a string to the logFile (m_csLogFileName) with the date and time stamps
    VOID LogInfo( LPCTSTR szInfo );

    // CreateProcess and execute the CA
    // implementation is in QuetExec.cpp
    UINT QuietExec( const WCHAR* const szInstallArg );

    // Bind files from the [BindImage_files] section
    VOID BindImageFiles( const WCHAR* szSection );

    //Parse input args
    // expecting something like
    // "exe-file and arguments, unused, path to add as temp env. var"
    // parameters:
    // [in/out] pszString: will contain everything before first comma
    // [out] pPath:        will contain everything after last comma
    VOID ParseArgument( WCHAR *pszString, WCHAR*& pPath );

    // breaks pszString to applicationName (exe-file) and command-line (exefile and arguments)
    // encloses exe-name in quotes (for commandLine only), if it is not quoted already 
    // removes quotes from applicationName if exe-name was quoted
    // returns false if caString is in wrong format (contains one quote only, has no exe-name, etc)
    // Parameters:
    //          [in] pszString - string containing exe-name and arguments
    //                           "my.exe" arg1, arg2
    //                            
    //          [out] pszApplicationName - will contain exe-name
    //          [out] pszCommandLine - same as caString with exe-name qouted
    
    // for example if pszString = "my.exe" arg1 arg2 (OR pszString = my.exe arg1 arg2)
    // then 
    //       pszApplicationName = my.exe 
    //       pszCommandLine = "my.exe" arg1 arg2
    BOOL GetApplicationName( const WCHAR* pszString, 
                             WCHAR* pszApplicationName, 
                             WCHAR* pszCommandLine );

    // helper function:
    // breaks command-line to applicationName and arguments 
    // for path that begins with quote (pszString = "my.exe" arg1 arg2)
    BOOL GetApplicationNameFromQuotedString( const WCHAR* pszString, 
                                             WCHAR* pszApplicationName, 
                                             WCHAR* pszCommandLine );
    // helper function:
    // breaks command-line to applicationName and arguments 
    // for path that does NOT begin with quote (pszString = my.exe arg1 arg2)
    BOOL GetApplicationNameFromNonQuotedString( const WCHAR* pszString, 
                                                WCHAR* pszApplicationName, 
                                                WCHAR* pszCommandLine );
    // helper function:
    BOOL IsEverettInstalled();

    // helper function:
    // return TRUE if last 4 characters before pBlank are ".exe"
    // return FALSE otherwise
    BOOL IsExeExtention(const WCHAR* pszString, WCHAR *pBlank);

    // helper function:
    // Fix for DCR BUG#563183
    // Copies .config.orig file to .config files at the install location if it does not exist
    // Deletes the .config.orig file.

    VOID ProcessConfigFiles();


    //data
    //
    WORD m_wLang;

    SETUP_INIT_COMPONENT m_InitComponent;

    WCHAR m_csLogFileName[MAX_PATH+1];


}; //class CUrtOcmSetup




#endif  //CURTOCMSETUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\redist\redist.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     Redist.h
// Owner:    jbae
// Purpose:  defines helper functions for Redist setup
//                              
// History:
//  03/06/01, jbae: moved most of functions to fxsetuplib.cpp for sharing in SDK and Redist

#ifndef REDIST_H
#define REDIST_H

#include "fxsetuplib.h"

// constants
const TCHAR INSTALL_COMMANDLINE[]   = _T("REBOOT=ReallySuppress");
const TCHAR UNINSTALL_COMMANDLINE[] = _T("REMOVE=ALL");
const TCHAR NOASPUPGRADE_PROP[]     = _T("NOASPUPGRADE=1");
const TCHAR URTVERSION_PROP[]       = _T("URTVersion");

const TCHAR OCM_REGKEY[]            = _T("SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\");
const TCHAR OCM_REGNAME[]           = _T("OCM");
const DWORD OCM_REGDATA             = 1;

// For now, let's hard-code MsiName for Redist
// We need to figure out how to handle Control redist later.
const LPCTSTR PACKAGENAME	  = _T("netfx.msi") ;

#endif // REDIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\redist\stringutil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef STRINGUTIL_H
#define STRINGUTIL_H

#include <windows.h>
#include <tchar.h>

class CStringQueue
{
    typedef struct _QUEUENODE
    {
        LPTSTR pszString;
        _QUEUENODE *pNext;
        _QUEUENODE( LPTSTR pszStr ) { pszString = new TCHAR[ _tcslen( pszStr ) + 1 ]; _tcscpy( pszString, pszStr ); };
        ~_QUEUENODE() { delete [] pszString; }
    } QUEUENODE, *PQUEUENODE;

public:
    CStringQueue() : m_nSize(0), m_pHead(NULL) {};
    ~CStringQueue();
    LPTSTR Enqueue( LPTSTR pszStr );
    LPTSTR Concat();
    unsigned int GetSize() { return m_nSize; };

private:
    PQUEUENODE m_pHead;
    unsigned int m_nSize;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\redist\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "Install.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Bootstrapper\0"
#define VER_ORIGFILENAME_STR    "Install.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\sdk\makefile.inc ===
# additional dependencies

ndp_sdk:
       @if not exist .\$(_TGTCPU)                     mkdir .\$(_TGTCPU)
       @if not exist .\$(_TGTCPU)\$(DDKBUILDENV)      mkdir .\$(_TGTCPU)\$(DDKBUILDENV)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\msireader.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     MsiReader.h
// Owner:    jbae
// Purpose:  defines class CMsiReader
//                              
// History:
//  03/07/2002, jbae: created

#ifndef MSIREADER_H
#define MSIREADER_H

#include <windows.h>
#include "msiquery.h"
#include "StringUtil.h"

typedef UINT (CALLBACK* PFNMSIOPENDATABASE)(LPCTSTR, LPCTSTR, MSIHANDLE *);              // MsiOpenDatabase()
typedef UINT (CALLBACK* PFNMSIDATABASEOPENVIEW)(MSIHANDLE, LPCTSTR, MSIHANDLE *);        // MsiDatabaseOpenView()
typedef UINT (CALLBACK* PFNMSICREATERECORD)(unsigned int);                               // MsiCreateRecord()
typedef UINT (CALLBACK* PFNMSIVIEWEXECUTE)(MSIHANDLE, MSIHANDLE);                        // MsiViewExecute()
typedef UINT (CALLBACK* PFNMSIRECORDGETSTRING)(MSIHANDLE, unsigned int, LPTSTR, DWORD *);// MsiRecordGetString()
typedef UINT (CALLBACK* PFNMSIRECORDSETSTRING)(MSIHANDLE, unsigned int, LPTSTR);         // MsiRecordSetString()
typedef UINT (CALLBACK* PFNMSIVIEWFETCH)(MSIHANDLE, MSIHANDLE *);                        // MsiViewExecute()
typedef UINT (CALLBACK* PFNMSICLOSEHANDLE)(MSIHANDLE);                                   // MsiCLoseHandle()

// ==========================================================================
// class CMsiReader
//
// Purpose:
//  read properties from MSI
// ==========================================================================
class CMsiReader
{
public:
    // Constructor
    CMsiReader();
    ~CMsiReader();

protected:
    // Attributes
    LPTSTR m_pszMsiFile;
    CStringQueue m_Props;

public:
    void SetMsiFile( LPCTSTR pszSourceDir, LPCTSTR pszMsiFile );
    LPCTSTR GetProperty( LPCTSTR pszName );
    LPCTSTR GetMsiFile() const { return m_pszMsiFile; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\sdk\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "Install.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework SDK Setup Bootstrapper\0"
#define VER_ORIGFILENAME_STR    "Install.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\sdk\sdk.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     sdk.h
// Owner:    jbae
// Purpose:  defines constants for SDK setup
//                              
// History:
//  03/06/01, jbae: moved most of functions to fxsetuplib.cpp for sharing in SDK and Redist

#ifndef SDK_H
#define SDK_H

#include <tchar.h>
#include <windows.h>

// constants
const TCHAR UNINSTALL_COMMANDLINE[] = _T("REMOVE=ALL");

const LPCTSTR SDKDIR_ID       = "FRAMEWORKSDK.3643236F_FC70_11D3_A536_0090278A1BB8_RO";
const LPCTSTR PACKAGENAME	  = "netfxsdk.msi" ;

#endif // SDK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\msiwrapper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     MsiWrapper.h
// Owner:    jbae
// Purpose:  definition of CMsiWrapper
//                              
// History:
//  03/06/01, jbae: created

#ifndef MSIWRAPPER_H
#define MSIWRAPPER_H

#include <windows.h>
#include <tchar.h>

// ==========================================================================
// class CMsiWrapper
//
// Purpose:
//  this class loads msi.dll and returns pointer to functions in msi.dll
// ==========================================================================
class CMsiWrapper
{
public:
    // Constructor
    //
    CMsiWrapper();

    // Destructor
    //
    ~CMsiWrapper();

    // Operations
    //
    void LoadMsi();
    void *GetFn( LPTSTR pszFnName );

protected:
    // Attributes
    //
    HMODULE m_hMsi; // handle to msi.dll
    void *m_pFn;    // pointer to a function
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:    main.cpp
// Owner:   jbae
// Purpose: This contains top-level function (WinMain()) for .NET Framework-related setup such
//          as Policy setup, J# setup. This wrapper can be used for general purpose msi-based setups.
//          It uses darwin (Windows Installer) to install files and configure user's machine.
//          It loads msi.dll from the location specified in registry for darwin calls.
//
//          setup.ini is used for initialization file.
//          current data:
//          [Setup]
//          PackageName=<packagename> ; name of the msi
//
//          Command line switches are:
//
//          Inst.exe [/h][/?][/q[b]][/u][/l <logfile>]
//                                                                                            
//    where /h, /?         gives the syntax info (ignores all other switches)                 
//          /q[b]          for quiet installation. /qb for progress bar only                                
//          /u             uninstall
//          /l [<logfile>] path to darwin log filename
//                                                                                              
//          We cab all setup files into a single file called Setup.exe using IExpress. To pass
//          switches to Install.exe when calling Setup.exe, users can use /c switch.
//          For example:
//
//          Setup.exe /c:"Inst.exe /l" 
//
// Returns: Return codes can be coming from msi.h, winerror.h, or SetupCodes.h. For success, it
//          returns ERROR_SUCCESS (0) or ERROR_SUCCESS_REBOOT_REQUIRED (3010).
// History:
//  03/06/02, jbae: created

#include "fxsetuplib.h"
#include "ProfileReader.h"
#include "MsiReader.h"
#include "setupapi.h"

//defines
//
#define EMPTY_BUFFER { _T('\0') }

// constants
//
const int MAX_CMDLINE = 255; // this should be enough. Check this whenever adding new property.
// Darwin properties
LPCTSTR REBOOT_PROP = _T("REBOOT=ReallySuppress");
LPCTSTR NOARP_PROP  = _T("ARPSYSTEMCOMPONENT=1 ARPNOREMOVE=1");

LPCTSTR OCM_SECTION     = _T("OCM");
LPCTSTR OCM_KEY_REGKEY  = _T("Key");
LPCTSTR OCM_KEY_REGNAME = _T("Name");
LPCTSTR OCM_KEY_REGDATA = _T("Data");

LPCTSTR g_szSetupLogNameFmt = _T( "%sSetup.log" ); // <msiname>Setup.log
LPCTSTR g_szMsiLogNameFmt   = _T( "%sMsi.log" );   // <msiname>Msi.log
LPCTSTR g_szIniFileName     = _T( "setup.ini" );

TCHAR g_szSetupLogName[_MAX_PATH+10] = EMPTY_BUFFER;
TCHAR g_szMsiLogName[_MAX_PATH+10]   = EMPTY_BUFFER;


HINSTANCE CSetupError::hAppInst;
TCHAR CSetupError::s_szProductGeneric[] = EMPTY_BUFFER;
LPTSTR CSetupError::s_pszProductName = NULL;

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    UINT        uRetCode = ERROR_SUCCESS;            // See SetupCodes.h for possible Return Values

    // install new() handler
    _set_new_handler( (_PNH)MyNewHandler );
    CSetupError::hAppInst = hInstance;
    CReadFlags rf( GetCommandLine() ) ;
    CSetupCode sc;
    CMsiReader mr;

try
{
    rf.ParseSourceDir(); // get SourceDir
    // get the filename of msi from ini file
    CProfileReader pr( rf.GetSourceDir(), g_szIniFileName, &mr );
    LPTSTR pszPackage = (LPTSTR)pr.GetProfile( _T("Setup"), _T("PackageName") );
    if ( !pszPackage )
    { // cannot get package name (filename of msi)
        CSetupError se( IDS_CANNOT_GET_MSI_NAME, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_CANNOT_GET_MSI_NAME );
        throw( se );
    }

    // get msiname from <msiname>.msi 
    TCHAR szMsiName[_MAX_PATH];
    if ( LENGTH(szMsiName) <= _tcslen(pszPackage) )
    {
        CSetupError se( IDS_MSI_NAME_TOO_LONG, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_NAME_TOO_LONG );
        throw( se );
    }
    _tcscpy( szMsiName, pszPackage );
    LPTSTR pChar = _tcsrchr( szMsiName, _T('.') );
    if ( pChar )
    {
        *pChar = _T('\0');
    }

    // set log filenames for setup log and darwin log
    _stprintf( g_szSetupLogName, g_szSetupLogNameFmt, szMsiName );
    _stprintf( g_szMsiLogName, g_szMsiLogNameFmt, szMsiName );

    // setup log can start from here
    LogThis( _T("Starting Install.exe") );

    // get ProductName -- used to display caption for setup UI
    if ( NULL == rf.GetSourceDir() )
        LogThis( _T( "SourceDir is Empty" ) );
    else
        LogThis( _T( "SourceDir: %s" ), rf.GetSourceDir() );
    LogThis( _T( "Package: %s" ), pszPackage );
    mr.SetMsiFile( rf.GetSourceDir(), pszPackage );
    CSetupError::s_pszProductName = (LPTSTR)mr.GetProperty( _T("ProductName") );

    // Convert command line parameters to flags
    LogThis( _T( "Switches: %s" ), rf.m_pszSwitches );
    rf.SetMsiName( pszPackage );
    rf.Parse();

    if ( !rf.IsInstalling() )
    {
        // /u given so uninstall it...
        LogThis( _T( "Uninstall started" ) );
        LPCTSTR pszProductCode = mr.GetProperty( _T("ProductCode" ) );
        UninstallProduct( &rf, pszProductCode, &sc ) ;                
    }
    else
    {
        LogThis( _T( "Install started" ) );
        LogThis( _T( "Installing: %s" ), mr.GetMsiFile() );

        LPTSTR pszOCMKey = (LPTSTR)pr.GetProfile( OCM_SECTION, OCM_KEY_REGKEY );
        if ( pszOCMKey )
        {
            bool bOCMInstalled = true;
            HKEY hKey = NULL;
            LONG lRet = -1;
            LPTSTR pszOCMName = (LPTSTR)pr.GetProfile( OCM_SECTION, OCM_KEY_REGNAME );
            LPTSTR pszOCMData = (LPTSTR)pr.GetProfile( OCM_SECTION, OCM_KEY_REGDATA );
            lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszOCMKey, 0, KEY_READ, &hKey );
            if ( ERROR_SUCCESS == lRet )
            {                   
                _ASSERTE( NULL != hKey );
                if ( pszOCMName )
                {
                    DWORD dwData = 0;
                    DWORD dwSize = sizeof( dwData );
                    if ( pszOCMData )
                    {
                        lRet = RegQueryValueEx( hKey, pszOCMName, NULL, NULL, (BYTE*)&dwData, &dwSize );
                        if ( ERROR_SUCCESS != lRet || dwData != atoi( pszOCMData ) )
                            bOCMInstalled = false;
                    }
                    else
                    {
                        lRet = RegQueryValueEx( hKey, pszOCMName, NULL, NULL, NULL, NULL );
                        if ( ERROR_SUCCESS != lRet )
                            bOCMInstalled = false;
                    }
                }
                RegCloseKey( hKey );
            }
            else
                bOCMInstalled = false;

            if ( bOCMInstalled )
            {
                CSetupError se( IDS_OCM_FOUND, IDS_DIALOG_CAPTION, MB_ICONWARNING, ERROR_SUCCESS );
                throw( se );
            } 
        }

        TCHAR szCmdLine[MAX_CMDLINE];
        _tcscpy( szCmdLine, REBOOT_PROP );
        if ( rf.IsNoARP() )
        {
            _tcscat( szCmdLine, _T(" ") );
            _tcscat( szCmdLine, NOARP_PROP );
        }

        InstallProduct( &rf, mr.GetMsiFile(), szCmdLine, &sc ) ;
    }

    // the final dialogbox and returncode
    // if quietmode is set by user or sc, we don't show ui
    sc.m_bQuietMode |= rf.IsQuietMode();
    uRetCode = sc.m_nRetCode;
    sc.ShowError();
}
catch( CSetupError& se )
{
    se.m_bQuietMode |= rf.IsQuietMode();
    uRetCode = se.m_nRetCode;
    se.ShowError();
}
catch( ... )
{
    CSetupError se( IDS_SETUP_FAILURE, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_EXIT_FAILURE );
    se.m_bQuietMode |= rf.IsQuietMode();
    uRetCode = se.m_nRetCode;
    se.ShowError();
}

    // make sure we can write to log
    if ( !(uRetCode & COR_INIT_ERROR) )
    {
        LogThisDWORD( _T("Install.exe returning %d"), uRetCode );
        LogThisDWORD( _T("\r\n[Install.exe]\r\nReturnCode=%d"), uRetCode );
    }

    // prompt for reboot if we need to
    if( ERROR_SUCCESS_REBOOT_REQUIRED == uRetCode )
    {
        // Darwin says we need to reboot
        if( !(rf.IsQuietMode()) )
        {
            // Not quiet mode so we can prompt reboot
            ::SetupPromptReboot( NULL, NULL, 0 ) ;
        }
    }

    return uRetCode ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\msireader.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     MsiReader.cpp
// Owner:    jbae
// Purpose:  opens MSI and read necessary properties from Property table
//                              
// History:
//  03/07/2001: jbae, created

#include "MsiReader.h"
#include "SetupError.h"
#include "MsiWrapper.h"
#include "fxsetuplib.h"

//defines
//
#define EMPTY_BUFFER { _T('\0') }

// Constructors
//
// ==========================================================================
// CMsiReader::CMsiReader()
//
// Inputs:
//  LPTSTR pszMsiFile: path to MSI
// Purpose:
// ==========================================================================
CMsiReader::
CMsiReader()
: m_pszMsiFile(NULL)
{
}

// ==========================================================================
// CMsiReader::~CMsiReader()
//
// Inputs:
//  LPTSTR pszMsiFile: path to MSI
// Purpose:
// ==========================================================================
CMsiReader::
~CMsiReader()
{
    if ( m_pszMsiFile )
        delete [] m_pszMsiFile;
}

// Implementations
//
void CMsiReader::
SetMsiFile( LPCTSTR pszSourceDir, LPCTSTR pszMsiFile )
{
    if ( NULL == pszSourceDir )
    {
        m_pszMsiFile = new TCHAR[ _tcslen(pszMsiFile) + 1 ];
        _tcscpy( m_pszMsiFile, pszMsiFile );
    }
    else
    {
        m_pszMsiFile = new TCHAR[ _tcslen(pszSourceDir) + _tcslen(pszMsiFile) + 1 ];
        _tcscpy( m_pszMsiFile, pszSourceDir );
        _tcscat( m_pszMsiFile, pszMsiFile );
    }
}

// ==========================================================================
// CMsiReader::GetProperty()
//
// Purpose:
//  opens MSI and read given property from Property table
// Inputs:
//  LPTSTR pszName: name of the property
// Returns:
//  LPCTSTR m_pszPropertyValue: value of the named property to be read
// ==========================================================================
LPCTSTR CMsiReader::
GetProperty( LPCTSTR pszName )
{
    TCHAR szQry[1024] = "Select Value from Property where Property = ?";
    MSIHANDLE hMsi;
    MSIHANDLE hView;
    MSIHANDLE hRec;
    MSIHANDLE hRec1;
    UINT uRet;
    DWORD dwSize = 0;
    LPTSTR pszRet = NULL;

    CMsiWrapper msi;
    msi.LoadMsi();

    PFNMSICLOSEHANDLE pFnClose = (PFNMSICLOSEHANDLE)msi.GetFn(_T("MsiCloseHandle"));

try
{    
    uRet = (*(PFNMSIOPENDATABASE)msi.GetFn(_T("MsiOpenDatabaseA")))( m_pszMsiFile, MSIDBOPEN_READONLY, &hMsi );
    if ( ERROR_SUCCESS != uRet )
    {
        LPVOID pArgs[] = { (LPVOID)m_pszMsiFile };
        CSetupError se( IDS_CANNOT_OPEN_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_OPEN_ERROR, (va_list*)pArgs );
        throw se;
    }

    uRet = (*(PFNMSIDATABASEOPENVIEW)msi.GetFn(_T("MsiDatabaseOpenViewA")))( hMsi, szQry, &hView );
    if ( ERROR_SUCCESS != uRet )
    {
        CSetupError se( IDS_CANNOT_READ_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_READ_ERROR );
        throw se;
    }
     
    hRec1 = (*(PFNMSICREATERECORD)msi.GetFn(_T("MsiCreateRecord")))( 1 );
    (*(PFNMSIRECORDSETSTRING)msi.GetFn(_T("MsiRecordSetStringA")))( hRec1, 1, (LPTSTR)pszName );

    uRet = (*(PFNMSIVIEWEXECUTE)msi.GetFn(_T("MsiViewExecute")))( hView, hRec1 );
    if ( ERROR_SUCCESS != uRet ) 
    {
        CSetupError se( IDS_CANNOT_READ_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_READ_ERROR );
        throw se;
    }
   
    uRet = (*(PFNMSIVIEWFETCH)msi.GetFn(_T("MsiViewFetch")))( hView, &hRec );
    if ( ERROR_NO_MORE_ITEMS == uRet )
    {
        CSetupError se( IDS_CANNOT_READ_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_READ_ERROR );
        throw se;
    }
    dwSize = 0;
    uRet = (*(PFNMSIRECORDGETSTRING)msi.GetFn(_T("MsiRecordGetStringA")))( hRec, 1, _T(""), &dwSize );
    if ( ERROR_MORE_DATA == uRet )
    {
        LPTSTR pszPropVal = new TCHAR[ ++dwSize ];
        uRet = (*(PFNMSIRECORDGETSTRING)msi.GetFn(_T("MsiRecordGetStringA")))( hRec, 1, pszPropVal, &dwSize );
        if ( ERROR_SUCCESS != uRet ) 
        {
            delete [] pszPropVal;
            CSetupError se( IDS_CANNOT_READ_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_READ_ERROR );
            throw se;
        }
        else
        {
            pszRet = m_Props.Enqueue( pszPropVal );
            delete [] pszPropVal;
        }
    }
    else
    {
        CSetupError se( IDS_CANNOT_READ_MSI, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_MSI_READ_ERROR );
        throw se;
    }

    if ( hMsi )
    {
        (*pFnClose)( hMsi );
    }
    if ( hView )
    {
        (*pFnClose)( hView );
    }
    if ( hRec )
    {
        (*pFnClose)( hRec );
    }
    if ( hRec1 )
    {
        (*pFnClose)( hRec1 );
    }
}
catch( CSetupError& se )
{
    if ( hMsi )
    {
        (*pFnClose)( hMsi );
    }
    if ( hView )
    {
        (*pFnClose)( hView );
    }
    if ( hRec )
    {
        (*pFnClose)( hRec );
    }
    if ( hRec1 )
    {
        (*pFnClose)( hRec1 );
    }
    throw( se );
}
    return pszRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\sdk\main.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:    main.cpp
// Owner:   jbae
// Purpose: This contains top-level function (WinMain()) for .NET Framework SDK setup.
//          It uses darwin (Windows Installer) to install files and configure user's machine.
//          Since we upgrade darwin if the version on the machine is lower, this will require
//          reboot. Because darwin 1.5 supports delayed reboot, we can delay reboot until we
//          finish installing .NET Framework. To support this scenario, we need to get the
//          location of msi.dll from registry and load all the functions we need during 
//          installation.

//          Command line switches are:
//
//          Install.exe [/h][/?][/q][/sdkdir <target>][/u][/l <logfile>]
//                                                                                            
//    where /h, /?         gives the syntax info (ignores all other switches)                 
//          /q             for quiet installation                                
//          /u             uninstall
//          /sdkdir <dir>  specifies the target dir and overrides the default                 
//          /l <logfile>   path to darwin log filename
//                                                                                              
//          We cab all setup files into a single file called Setup.exe using IExpress. To pass
//          switches to Install.exe when calling Setup.exe, users can use /c switch.
//          For example:
//
//          Setup.exe /c:"Install.exe /l" 
//
// Returns: Return codes can be coming from msi.h, winerror.h, or SetupCodes.h. For success, it
//          returns ERROR_SUCCESS (0) or ERROR_SUCCESS_REBOOT_REQUIRED (3010).
//          When InstMsi(w).exe returns 3010 and some error occurs durning Framework install,
//          the return code will be COR_REBOOT_REQUIRED (8192) + error. So when return code is
//          greater than 8192, subtract 8192 from it and the result will be error code from 
//          Framework install.
//
// History:
//  long ago, anantag:  Created
//  01/10/01, jbae: Many changes to support ref-counting of Framework
//  03/09/01, jbae: re-factoring to share code in SDK and Redist setup
//  07/18/01, joea: adding logging functionality
//  07/19/01, joea: added single instance support
//

#include "sdk.h"
#include "fxsetuplib.h"
#include "AdminPrivs.h"
#include "DetectBeta.h"

//defines
//
#define EMPTY_BUFFER { _T('\0') }

//single instance data
//
TCHAR  g_tszSDKMutexName[] = _T( "NDP SDK Setup" );
const TCHAR *g_szLogName   = _T( "dotNetFxSDK.log" );

// global variables.  Justification provided for each!
HINSTANCE g_AppInst ;                   // Legacy. Not really used anywhere
HINSTANCE CSetupError::hAppInst;
TCHAR CSetupError::s_szProductName[MAX_PATH] = EMPTY_BUFFER;


int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    UINT        uRetCode = ERROR_SUCCESS;            // See SetupCodes.h for possible Return Values
    UINT        uMsiSetupRetCode = ERROR_SUCCESS;    // Returncode from InstMsi.exe

    //buffer for logging calls
    //
    TCHAR szLog[_MAX_PATH+1] = EMPTY_BUFFER;

    // install new() handler
    _set_new_handler( (_PNH)MyNewHandler );

    g_AppInst = hInstance ;

    CSetupError::hAppInst = hInstance;
    g_sm = SDK;

    CReadFlags rf( GetCommandLine(), PACKAGENAME ) ;
    CSetupCode sc;

    //setup single instance
    //
    CSingleInstance si( g_tszSDKMutexName );

try
{
    TCHAR szStartMsg[] = _T( "Starting Install.exe" );
    LogThis( szStartMsg, sizeof( szStartMsg ) );

    //Validate single instance
    //
    if( !si.IsUnique() )
    {
        CSetupError se( IDS_NOT_SINGLE_INSTANCE, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_NOT_SINGLE_INSTANCE );
        throw( se );
    }
    else if( !si.IsHandleOK() )
    {
        CSetupError se( IDS_SINGLE_INSTANCE_FAIL, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_SINGLE_INSTANCE_FAIL );
        throw( se );
    }

    // Convert command line parameters to flags
    LogThis1( _T( "Parsing switches from commandline: %s" ), GetCommandLine() );
    rf.Parse();

    // Make sure user has Admin Privileges so that we can read/write system registry
    if ( !UserHasPrivileges() )
    {
        CSetupError se( IDS_INSUFFICIENT_PRIVILEGES, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_INSUFFICIENT_PRIVILEGES );
        throw( se );
    }

    TCHAR szMsiPath[_MAX_PATH] = { _T('\0') };
    // since SourceDir is checked, this should be redundent but double-check it.
    if ( _MAX_PATH <= (_tcslen(rf.GetSourceDir()) + _tcslen(PACKAGENAME)) )
    {
        sc.SetError( IDS_SOURCE_DIR_TOO_LONG, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_SOURCE_DIR_TOO_LONG );
        throw ( sc );
    }

    _tcscpy( szMsiPath, rf.GetSourceDir() );
    _tcscat( szMsiPath, PACKAGENAME );

    if ( !rf.IsInstalling() )
    {
        // /u given so uninstall it...
        TCHAR szUninstallMsg[] = _T( "Uninstall started" );
        LogThis( szUninstallMsg, sizeof( szUninstallMsg ) );
        SetTSInInstallMode();
        InstallProduct( &rf, szMsiPath, (LPTSTR)UNINSTALL_COMMANDLINE, &sc ) ;
    }
    else
    {
        TCHAR szInstallMsg[] = _T( "Install started" );
        LogThis( szInstallMsg, sizeof( szInstallMsg ) );

        // Verify the system meets the min. config. requirements
        TCHAR szSystemReqs[] = _T( "Checking system requirements" );
        LogThis( szSystemReqs, sizeof( szSystemReqs ) );

        ConfigCheck() ;

        TCHAR szSystemReqsSuccess[] = _T( "System meets minimum requirements" );
        LogThis( szSystemReqsSuccess, sizeof( szSystemReqsSuccess ) );

        // Verify Darwin is on the system
        UINT uMsiChk = CheckDarwin();
        if ( ERROR_SUCCESS == uMsiChk || DARWIN_VERSION_OLD == uMsiChk ) // darwin detected
        {
            LPCTSTR pszProducts = NULL;

            CDetectBeta db( LogThis1 );
            pszProducts = db.FindProducts();
            if ( pszProducts ) // found beta NDP components
            {
                LPVOID pArgs[] = { (LPVOID)pszProducts };
                sc.m_bQuietMode |= rf.IsQuietMode();
                sc.SetError2( IDS_OLD_FRAMEWORK_EXIST, MB_OK|MB_ICONEXCLAMATION, COR_OLD_FRAMEWORK_EXIST, (va_list *)pArgs );
                sc.ShowError2();
                sc.m_bQuietMode = true;
                throw( sc );
            }
        }
        SetTSInInstallMode();
        // update darwin if necessary
        if ( DARWIN_VERSION_OLD == uMsiChk || DARWIN_VERSION_NONE == uMsiChk )
        {
            uMsiSetupRetCode = InstallDarwin( rf.IsQuietMode() );
            if ( ERROR_SUCCESS_REBOOT_REQUIRED == uMsiSetupRetCode ||
                ERROR_SUCCESS == uMsiSetupRetCode )
            {
                sc.SetReturnCode( IDS_SETUP_COMPLETE, IDS_DIALOG_CAPTION, MB_ICONINFORMATION, uMsiSetupRetCode );
            }
            else
            {
                sc.SetError( IDS_DARWIN_INSTALL_FAILURE, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_INSTALL_FAILURE );
                throw( sc );
            }
        }

        // Install SDK Components on to the system

        // Form commandline for MsiInstallProduct()
        LPTSTR pszCmdLine = NULL;
        unsigned int nSize = 255; // size of fixed part (should be enough)
        if ( rf.GetSDKDir() )
        {
            nSize += _tcslen( rf.GetSDKDir() );
        }
        pszCmdLine = new TCHAR[ nSize ];

        _tcscpy( pszCmdLine, REBOOT_PROP ) ;

        // if /sdkdir argument, install in that location
        if( NULL != rf.GetSDKDir() )
        {
            _tcscat( pszCmdLine, _T(" ") );
            _tcscat( pszCmdLine, SDKDIR_ID );
            _tcscat( pszCmdLine, _T("=\"") );
            _tcscat( pszCmdLine, rf.GetSDKDir() );
            _tcscat( pszCmdLine, _T("\"") );
        }

        // If we're in a quiet install, we need to turn this property
        // to install all by default
        if( rf.IsQuietMode() )
        {
            _tcscat( pszCmdLine, _T(" ADDLOCAL=All") );
        }

        if ( rf.IsNoARP() )
        {
            _tcscat( pszCmdLine, _T(" ") );
            _tcscat( pszCmdLine, NOARP_PROP );
        }

        LogThis1( _T( "Commandline: %s" ), pszCmdLine );

        LogThis1( _T( "Installing: %s" ), szMsiPath );

        InstallProduct( &rf, szMsiPath, pszCmdLine, &sc ) ;
        // BUGBUG: when exception is raised by InstallProduct(), this is not deleted until program ends.
        delete [] pszCmdLine;
    }

    // the final dialogbox and returncode
    // if quietmode is set by user or sc, we don't show ui
    sc.m_bQuietMode |= rf.IsQuietMode();
    uRetCode = sc.m_nRetCode;
    sc.ShowError();

}
catch( CSetupError se )
{
    se.m_bQuietMode |= rf.IsQuietMode();
    uRetCode = se.m_nRetCode | sc.m_nRetCode;
    se.ShowError();
}
catch( ... )
{
    CSetupError se( IDS_SETUP_FAILURE, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_EXIT_FAILURE );
    se.m_bQuietMode |= rf.IsQuietMode();
    uRetCode = se.m_nRetCode | sc.m_nRetCode;
    se.ShowError();
}
    uRetCode = ( COR_REBOOT_REQUIRED == uRetCode ) ? ERROR_SUCCESS_REBOOT_REQUIRED : uRetCode;

    // make sure we can write to log
    if ( ((uRetCode & COR_CANNOT_GET_TEMP_DIR) != COR_CANNOT_GET_TEMP_DIR) &&
         ((uRetCode & COR_TEMP_DIR_TOO_LONG) != COR_TEMP_DIR_TOO_LONG) && 
         ((uRetCode & COR_CANNOT_WRITE_LOG) != COR_CANNOT_WRITE_LOG) ) 
    {
        LogThisDWORD( _T("Install.exe returning %d"), uRetCode );
        LogThisDWORD( _T("\r\n[Install.exe]\r\nReturnCode=%d"), uRetCode );
    }

    // prompt for reboot if we need to
    if( sc.IsRebootRequired() )
    {
        // Darwin says we need to reboot
        if( !(rf.IsQuietMode()) )
        {
            // Not quiet mode so we can prompt reboot
            ::SetupPromptReboot(NULL, NULL, 0) ;
        }
    }

    return uRetCode ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\fxsetuplib.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     fxsetuplib.cpp
// Owner:    jbae
// Purpose:  Implements common library functions for .NET Framework-related setup wrapper
//
// History:
//  03/07/2002: jbae, created

#include "SetupError.h"
#include "fxsetuplib.h"
#include "MsiWrapper.h"
#include <time.h>         //for LogThis() function

//defines
//
#define EMPTY_BUFFER { _T('\0') }
#define END_OF_STRING  _T( '\0' )

// Somehow including windows.h or winuser.h didn't find this constant
// I found that CLR files hard-code them as below so I am following it.
#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION 0x1000
#endif

extern TCHAR g_szSetupLogName[];

// ==========================================================================
// InstallProduct()
//
// Purpose:
//  Installs given MSI package on a machine that should now be Darwin
//  enabled.  
// Inputs:
//  CReadFlags *rf: commandline switches
//  LPTSTR psaPackageName: path to MSI
//  LPTSTR pszCmdLine: commandline to MsiInstallProduct()
// Outputs:
//  CSetupCode *sc: will contain returncode, message and icon to display.
//                  Also used to raise exception
// Dependencies:
//  None
// Notes:
// ==========================================================================
UINT InstallProduct( const CReadFlags *rf, LPCTSTR pszPackageName, LPCTSTR pszCmdLine, CSetupCode *sc )
{
    _ASSERTE( NULL != rf );
    _ASSERTE( NULL != pszPackageName );
    _ASSERTE( NULL != sc );

    UINT uDarCode = ERROR_SUCCESS;
    CMsiWrapper msi;

    msi.LoadMsi();

    // turn on logging if logfile is given
    // it flushes every 20 lines
    if ( NULL != rf->GetLogFileName() )
    {
        LogThis( _T("Darwin log: %s"), rf->GetLogFileName() );
        (*(PFNMSIENABLELOG)msi.GetFn(_T("MsiEnableLogA")))( DARWIN_LOG_FLAG, rf->GetLogFileName(), INSTALLLOGATTRIBUTES_APPEND );
    }

    // Tell Darwin to use the appropriate UI Level
    // If we're in a quiet install, don't use a UI.
    if ( rf->IsProgressOnly() )
    {
        LogThis( _T("Basic+ProgressOnly UI"), _T("") );
        (*(PFNMSISETINTERNALUI)msi.GetFn(_T("MsiSetInternalUI")))(INSTALLUILEVEL_BASIC|INSTALLUILEVEL_PROGRESSONLY,NULL) ;
    }
    else if( rf->IsQuietMode() )
    {
        LogThis( _T("No UI"), _T("") );
        (*(PFNMSISETINTERNALUI)msi.GetFn(_T("MsiSetInternalUI")))(INSTALLUILEVEL_NONE,NULL) ;
    }
    else
    {
        LogThis( _T("Full UI"), _T("") );
        (*(PFNMSISETINTERNALUI)msi.GetFn(_T("MsiSetInternalUI")))(INSTALLUILEVEL_FULL,NULL) ;
    }

    LogThis( _T("Calling MsiInstallProduct() with commandline: %s"), pszCmdLine );
    // Tell Darwin to actually install the product
    uDarCode = (*(PFNMSIINSTALLPRODUCT)msi.GetFn(_T("MsiInstallProductA")))( pszPackageName, pszCmdLine ) ;

    LogThisDWORD( _T("MsiInstallProduct() returned %d"), uDarCode );
    LogThisDWORD( _T("\r\n[MsiInstallProduct]\r\nReturnCode=%d"), uDarCode );

    switch ( uDarCode )
    {
        case ERROR_SUCCESS :
             sc->SetReturnCode( IDS_SETUP_COMPLETE, IDS_DIALOG_CAPTION, MB_ICONINFORMATION, ERROR_SUCCESS );
             sc->m_bQuietMode = true;
             break ;
        case ERROR_SUCCESS_REBOOT_REQUIRED :
             sc->SetReturnCode( IDS_SETUP_COMPLETE, IDS_DIALOG_CAPTION, MB_ICONINFORMATION, ERROR_SUCCESS_REBOOT_REQUIRED );
             sc->m_bQuietMode = true;
             break ;
        case ERROR_INSTALL_USEREXIT :
             sc->SetError( IDS_SETUP_CANCELLED, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, ERROR_INSTALL_USEREXIT );
             sc->m_bQuietMode = true;
             throw (*sc);
             break ;
        case ERROR_INSTALL_PLATFORM_UNSUPPORTED :
             sc->SetError( IDS_UNSUPPORTED_PLATFORM, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
             throw (*sc);
             break ;
        case ERROR_PRODUCT_VERSION :
             sc->SetError( IDS_ERROR_PRODUCT_VERSION, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_PRODUCT_VERSION );
             throw (*sc);
             break ;
        default :
             sc->SetError( IDS_SETUP_FAILURE, IDS_DIALOG_CAPTION, MB_ICONERROR, uDarCode );
             throw (*sc);
             break ;
    }

    return ERROR_SUCCESS;
}  // End of InstallProduct


// ==========================================================================
// UninstallProduct()
//
// Purpose:
//  Uninstall Framework
// Inputs:
//  CReadFlags *rf: commandline switches
//  LPTSTR pszProductCode: ProductCode to uninstall
// Outputs:
//  CSetupCode *sc: will contain returncode, message and icon to display.
//                  Also used to raise exception
// Dependencies:
// Notes:
// ==========================================================================
UINT UninstallProduct( const CReadFlags *rf, LPCTSTR pszProductCode, CSetupCode *sc )
{
    _ASSERTE( NULL != rf );
    _ASSERTE( NULL != pszProductCode );
    _ASSERTE( NULL != sc );

    UINT  uDarCode = ERROR_SUCCESS;

    CMsiWrapper msi;
    msi.LoadMsi();

    // turn on logging if logfile is given
    if ( NULL != rf->GetLogFileName() )
    {
        LogThis( _T("Darwin log: %s"), rf->GetLogFileName() );
        (*(PFNMSIENABLELOG)msi.GetFn(_T("MsiEnableLogA")))( DARWIN_LOG_FLAG, rf->GetLogFileName(), INSTALLLOGATTRIBUTES_FLUSHEACHLINE );
    }

    // Tell Darwin to use the appropriate UI Level
    // If we're in a quiet install, don't use a UI.
    if ( rf->IsProgressOnly() )
    {
        LogThis( _T("Basic+ProgressOnly UI") );
        (*(PFNMSISETINTERNALUI)msi.GetFn(_T("MsiSetInternalUI")))(INSTALLUILEVEL_BASIC|INSTALLUILEVEL_PROGRESSONLY,NULL) ;
    }
    else if( rf->IsQuietMode() )
    {
        LogThis( _T("No UI") );
        (*(PFNMSISETINTERNALUI)msi.GetFn(_T("MsiSetInternalUI")))(INSTALLUILEVEL_NONE,NULL) ;
    }
    else
    {
        LogThis( _T("Basic UI") );
        (*(PFNMSISETINTERNALUI)msi.GetFn(_T("MsiSetInternalUI")))(INSTALLUILEVEL_BASIC,NULL) ;
    }

    LogThis( _T("Calling MsiConfigureProduct() for ProductCode %s"), pszProductCode );
    uDarCode = (*(PFNMSICONFIGUREPRODUCT)msi.GetFn(_T("MsiConfigureProductA")))( pszProductCode, INSTALLLEVEL_DEFAULT, INSTALLSTATE_ABSENT );

    switch ( uDarCode )
    {
        case ERROR_SUCCESS :
             sc->SetReturnCode( IDS_SETUP_COMPLETE, IDS_DIALOG_CAPTION, MB_ICONINFORMATION, ERROR_SUCCESS );
             break ;
        case ERROR_SUCCESS_REBOOT_REQUIRED :
             sc->SetReturnCode( IDS_SETUP_COMPLETE, IDS_DIALOG_CAPTION, MB_ICONINFORMATION, ERROR_SUCCESS_REBOOT_REQUIRED );
             break ;
        case ERROR_UNKNOWN_PRODUCT :
             sc->SetError( IDS_UNKNOWN_PRODUCT, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, ERROR_UNKNOWN_PRODUCT );
             throw (*sc);
             break ;
        case ERROR_INSTALL_USEREXIT :
             sc->SetError( IDS_SETUP_CANCELLED, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, ERROR_INSTALL_USEREXIT );
             throw (*sc);
             break ;
        case ERROR_INSTALL_PLATFORM_UNSUPPORTED :
             sc->SetError( IDS_UNSUPPORTED_PLATFORM, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_INSTALL_PLATFORM_UNSUPPORTED );
             throw (*sc);
             break ;
        default :
             sc->SetError( IDS_SETUP_FAILURE, IDS_DIALOG_CAPTION, MB_ICONERROR, uDarCode );
             throw (*sc);
             break ;
    }

    return ERROR_SUCCESS;
}  // End of UninstallProduct

// ==========================================================================
// LoadDarwinLibrary()
//
// Purpose:
//  loads msi.dll after getting location from registry
// Inputs:
//  none
// Outputs:
//  none
// Returns:
//  HMODULE hMsi: handle to msi.dll
// Notes:
// ==========================================================================
HMODULE LoadDarwinLibrary()
{
    HKEY hKey = NULL;
    LONG lRet = -1;
    TCHAR szMsiPath[_MAX_PATH] = EMPTY_BUFFER;
    DWORD dwRet = sizeof(szMsiPath); 
    HMODULE hMsi = NULL;
    
    TCHAR szLoadMsi[] = _T( "Trying to load msi.dll" );
    LogThis( szLoadMsi );

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE, DARWIN_REGKEY, 0, KEY_READ, &hKey );
    if ( ERROR_SUCCESS == lRet )
    {                   
        _ASSERTE( NULL != hKey );
        lRet = RegQueryValueEx( hKey, DARWIN_REGNAME, NULL, NULL, (LPBYTE)szMsiPath, &dwRet );
        RegCloseKey( hKey );
        if ( ERROR_SUCCESS == lRet )
        {
            _tcscat( szMsiPath, _T("\\msi.dll") );
        }
        else
        {
            _tcscpy( szMsiPath, _T("msi.dll") );
        }
    }
    else
    {
        _tcscpy( szMsiPath, _T("msi.dll") );
    }

    LogThis( _T( "Loading: %s" ), szMsiPath );

    hMsi = ::LoadLibrary( szMsiPath ) ;

    return hMsi;
}

// ==========================================================================
// MyNewHandler()
//
// Purpose:
//  this is handler for new()
//  It throws exception with error ERROR_NOT_ENOUGH_MEMORY
// Inputs:
//  none
// Outputs:
//  none
// ==========================================================================
int MyNewHandler( size_t size )
{
    CSetupError se( IDS_NOT_ENOUGH_MEMORY, IDS_DIALOG_CAPTION, MB_ICONERROR, ERROR_NOT_ENOUGH_MEMORY );
    throw( se );
    return 0;
}

// ==========================================================================
// LogThis()
//
// Purpose:
//  Adds a string to a log file. It calls LogThis()
// Inputs:
//  LPCTSTR pszFormat: format string with %s
//  LPCTSTR pszArg: argument to format
// Outputs:
//  void
// ==========================================================================
void LogThis( LPCTSTR pszFormat, LPCTSTR pszArg )
{
    _ASSERTE( pszFormat );
    _ASSERTE( pszArg );

    LPTSTR pszData = new TCHAR[ _tcslen(pszFormat) + _tcslen(pszArg) + 1];
    _stprintf( pszData, pszFormat, pszArg );
    LogThis( pszData, _tcslen(pszData) );
    delete [] pszData;
}

// ==========================================================================
// LogThisDWORD()
//
// Purpose:
//  Adds a string to a log file. It calls LogThis()
// Inputs:
//  LPCTSTR pszFormat: format string with %s
//  LPCTSTR pszArg: argument to format
// Outputs:
//  void
// ==========================================================================
void LogThisDWORD( LPCTSTR pszFormat, DWORD dwNum )
{
    _ASSERTE( pszFormat );

    LPTSTR pszData = new TCHAR[ _tcslen(pszFormat) + 20 ]; // 20 should cover enough digits for DWORD
    _stprintf( pszData, pszFormat, dwNum );
    LogThis( pszData, _tcslen(pszData) );
    delete [] pszData;
}

// LogThis()
//
// Purpose:
//  Adds a string to a log file. It calls LogThis()
// Inputs:
//  LPCTSTR pszMessage: string to log
// Outputs:
//  void
// ==========================================================================
void LogThis( LPCTSTR pszMessage )
{
    _ASSERTE( pszMessage );
    LogThis( pszMessage, _tcslen(pszMessage) );
}


// ==========================================================================
// LogThis()
//
// Purpose:
//  Adds a string to a log file.
//  Log file will have a static name, always be created in the %temp% dir,
//  and will be over-written each install. 
// Inputs:
//  LPCTSTR szData:  null terminated string to log
//  size_t  nLength: number of bytes in szData
// Outputs:
//  void
// ==========================================================================
//defines
void LogThis( LPCTSTR szData, size_t nLength )
{
    _ASSERTE( FALSE == IsBadReadPtr( szData, nLength ) );

    //determines if we should create or nulify existing content
    // versus appending ... the first time this is called in any
    // session, we will create, otherwise we append
    //
    static bool fFirstPass = true;
    static CTempLogPath templog( g_szSetupLogName );

    FILE* fp = ::_tfopen( 
        (LPCTSTR)templog, 
        fFirstPass ? _T( "w" ) : _T( "a" ) );

    if( fp )
    {
        //date and time stamps are added to all entries
        //
        TCHAR dbuffer[10] = EMPTY_BUFFER;
        TCHAR tbuffer[10] = EMPTY_BUFFER;
        
        ::_tstrdate( dbuffer );
        ::_tstrtime( tbuffer );
        
        ::_ftprintf( 
            fp, 
            _T( "[%s,%s] %s\n" ), 
            dbuffer, 
            tbuffer, 
            szData );
        
        ::fclose( fp );
        fp = NULL;
    }
    else
    {
        LPVOID pArgs[] = { (LPVOID)(LPCTSTR)templog };
        CSetupError se( IDS_CANNOT_WRITE_LOG, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_CANNOT_WRITE_LOG, (va_list *)pArgs );
        throw se;
    }

    if( fFirstPass )
    {
        fFirstPass = false;
    }
}

// ==========================================================================
// CTempLogPath::CTempLogPath()
//
// Purpose:
//  Constructor for CTempLogPath. It finds %TEMP% dir and appends pszLogName.
//  If the path is too long or anything fails, it raises exception.
// Inputs: 
//  pszLogName: name of the log file
// Outputs: none
// ==========================================================================
CTempLogPath::
CTempLogPath( LPCTSTR pszLogName ) : m_pszLogPath(NULL) 
{
    DWORD dwBufSize = 0;
    DWORD dwBufSize2 = 0;

    // see how much space we need to store %TEMP% path
    dwBufSize = GetTempPath( 0, m_pszLogPath );
    // raise exception if GetTempPath fails
    if ( 0 == dwBufSize ) 
    {
        CSetupError se( IDS_CANNOT_GET_TEMP_DIR, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_CANNOT_GET_TEMP_DIR );
        throw se;
    }
    dwBufSize++;
    dwBufSize*=2;

    dwBufSize += _tcslen(pszLogName);
    if ( _MAX_PATH < dwBufSize )
    {
        CSetupError se( IDS_TEMP_DIR_TOO_LONG, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_TEMP_DIR_TOO_LONG );
        throw se;
    }

    m_pszLogPath = new TCHAR[ dwBufSize+1 ];
    // initialize the buffer with zeros 
    memset( m_pszLogPath, 0, dwBufSize );
    dwBufSize2 = GetTempPath( dwBufSize, m_pszLogPath );
    if ( 0 == dwBufSize || dwBufSize2+_tcslen(pszLogName)  >= dwBufSize  ) 
    {
        CSetupError se( IDS_CANNOT_GET_TEMP_DIR, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_CANNOT_GET_TEMP_DIR );
        throw se;
    }

    // if we're not in a TS session, return
    if( !GetSystemMetrics(SM_REMOTESESSION) )
    {
        _tcscat( m_pszLogPath, pszLogName );
        return;
    }

    // we're in a TS session -- check for the 2 possible ways to turn off per-session temp dirs
    BOOL bOff1 = FALSE;
    BOOL bOff2 = FALSE;
    HKEY h;
    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\Terminal Server"), NULL, KEY_READ, &h) == ERROR_SUCCESS )
    {
        DWORD dwData = 0;
        DWORD dwSize = sizeof( dwData );
        if( RegQueryValueEx(h, _T("PerSessionTempDir"), NULL, NULL, (BYTE*)&dwData, &dwSize) == ERROR_SUCCESS )
        {
            bOff1 = !dwData;
        }
        RegCloseKey( h );
    }

    if( RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\Terminal Server"), NULL, KEY_READ, &h) == ERROR_SUCCESS )
    {
        TCHAR szData[1024];
        DWORD dwSize = 1024;
        if( RegQueryValueEx(h, _T("FlatTempDir"), NULL, NULL, (BYTE*)szData, &dwSize) == ERROR_SUCCESS )
        {
            bOff2 = _ttoi( szData );
        }
        RegCloseKey( h );
    }

    // if either are set to TRUE, return
    if( bOff1 || bOff2 )
    {
        _tcscat( m_pszLogPath, pszLogName );
        return;
    }

    // per-session is on, so take the reutrn from GetTempPath, remove the last '\', and return that
    //  NOTE: since GTP() returns w/a '\' on the end, remove it first
    TCHAR* pszLast = &m_pszLogPath[_tcslen(m_pszLogPath) - 1];
    *pszLast = END_OF_STRING;
    
    // find the last \ + 1 and return (still need to return w/a trailing '\'
    pszLast = _tcsrchr( m_pszLogPath, _T('\\') ) + 1;
    if( pszLast )
    {
        *pszLast = END_OF_STRING;
    }
    _tcscat( m_pszLogPath, pszLogName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\fxsetuplib.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:    fxsetuplib.h
// Owner:   jbae
// Purpose: defines some library functions
// History:
//  03/07/2002, jbae: created

#ifndef FXSETUPLIB_H
#define FXSETUPLIB_H

// standard include files
#include <stdlib.h>
#include <stdio.h>          // for fprintf()
#include "windows.h"
#include <new.h>

// additional include files
#include "msi.h"
#include "msiquery.h"
#include "resource.h"
#include "SetupCodes.h"
#include <TCHAR.H>
#include <crtdbg.h>
#include "SetupError.h"
#include "ReadFlags.h"

#define LENGTH(A) (sizeof(A)/sizeof(A[0]))

const TCHAR   DARWIN_REGKEY[]      = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer");
const TCHAR   DARWIN_REGNAME[]     = _T("InstallerLocation");
const DWORD DARWIN_LOG_FLAG         = INSTALLLOGMODE_FATALEXIT |
                                      INSTALLLOGMODE_ERROR |
                                      INSTALLLOGMODE_WARNING |
                                      INSTALLLOGMODE_USER |
                                      INSTALLLOGMODE_INFO |
                                      INSTALLLOGMODE_RESOLVESOURCE |
                                      INSTALLLOGMODE_OUTOFDISKSPACE |
                                      INSTALLLOGMODE_ACTIONSTART |
                                      INSTALLLOGMODE_ACTIONDATA |
                                      INSTALLLOGMODE_COMMONDATA |
                                      INSTALLLOGMODE_PROPERTYDUMP |
                                      INSTALLLOGMODE_VERBOSE;

// function prototypes
typedef UINT (CALLBACK* PFNMSIINSTALLPRODUCT)( LPCTSTR,LPCTSTR ); // MsiInstallProduct()
typedef UINT (CALLBACK* PFNMSIENABLELOG)( DWORD, LPCTSTR, DWORD );// MsiEnableLog()
typedef DWORD (CALLBACK* PFNMSISETINTERNALUI)( DWORD, HWND* );    // MsiSetInternalUI()
typedef UINT (CALLBACK* PFNMSICONFIGUREPRODUCT)(LPCTSTR, int, INSTALLSTATE); // MsiConfigureProduct()

HMODULE LoadDarwinLibrary();                             // Load msi.dll
int MyNewHandler( size_t size );                         // new() handler
void LogThis( LPCTSTR pszMessage );                      // log message
void LogThis( LPCTSTR szData, size_t nLength );          // Enters text into wrapper logfile
void LogThis( LPCTSTR pszFormat, LPCTSTR pszArg );      // log using format and arg
void LogThisDWORD( LPCTSTR pszFormat, DWORD dwNum );     // log with a DWORD argument
UINT  InstallProduct( const CReadFlags *, LPCTSTR, LPCTSTR, CSetupCode * ) ; // Installs package
UINT  UninstallProduct( const CReadFlags *, LPCTSTR, CSetupCode * ) ;  // Uninstall product

class CTempLogPath
{
    LPTSTR m_pszLogPath;
 public:
    CTempLogPath( LPCTSTR pszLogName );
    ~CTempLogPath(){if (m_pszLogPath) delete [] m_pszLogPath;}
    operator LPCTSTR() {return (LPCTSTR)m_pszLogPath;}
};

#endif // FXSETUPLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\msiwrapper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     MsiWrapper.cpp
// Owner:    jbae
// Purpose:  This class wraps function calls to msi.dll. To support delayed reboot,
//           we need to load msi.dll from the location specified in registry.
//                              
// History:
//  03/06/01, jbae: created

#include "MsiWrapper.h"
#include "SetupError.h"
#include "fxsetuplib.h"

// Constructors
//
// ==========================================================================
// CMsiWrapper::CMsiWrapper()
//
// Inputs: none
// Purpose:
//  Initialize m_hMsi and m_pFn to NULL
// ==========================================================================
CMsiWrapper::
CMsiWrapper()
: m_hMsi(NULL), m_pFn(NULL)
{
}

// ==========================================================================
// CMsiWrapper::~CMsiWrapper()
//
// Inputs: none
// Purpose:
//  frees m_hMsi
// ==========================================================================
CMsiWrapper::
~CMsiWrapper()
{
    ::FreeLibrary( m_hMsi );
}

// Implementations
//
// ==========================================================================
// CMsiReader::LoadMsi()
//
// Purpose:
//  Loads msi.dll by calling LoadDarwinLibrary().
// Inputs:
//  none
// Outputs:
//  sets m_hMsi
// ==========================================================================
void CMsiWrapper::
LoadMsi()
{
    m_hMsi = LoadDarwinLibrary();
    if ( NULL == m_hMsi )
    {
        CSetupError se( IDS_DARWIN_NOT_INSTALLED, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_NOT_INSTALLED );
        throw( se );
    }
}

// ==========================================================================
// CMsiReader::GetFn()
//
// Purpose:
//  Returns pointer to the function name passed in
// Inputs:
//  LPTSTR pszFnName: name of the function to call
// Outputs:
//  sets m_pFn
// Returns:
//  pointer to a function
// ==========================================================================
void *CMsiWrapper::
GetFn( LPTSTR pszFnName )
{
    _ASSERTE( NULL != m_hMsi );
    m_pFn = ::GetProcAddress( m_hMsi, pszFnName );
    if ( NULL == m_pFn )
    {
        // TODO: need proper message
        CSetupError se( IDS_DARWIN_NOT_INSTALLED, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_DARWIN_NOT_INSTALLED );
        throw( se );
    }

    return m_pFn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\profilereader.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     ProfileReader.h
// Owner:    jbae
// Purpose:  definition of CProfileReader
//                              
// History:
//  03/04/02, jbae: created

#ifndef PROFILEREADER_H
#define PROFILEREADER_H

#include <windows.h>
#include <tchar.h>
#include "MsiReader.h"
#include "StringUtil.h"

const int ALLOC_BUF_UNIT = 256;

// ==========================================================================
// class CProfileReader
//
// Purpose:
//  this class read Profile strings
// ==========================================================================
class CProfileReader
{
public:
    // Constructor
    //
    CProfileReader( LPCTSTR pszDir, LPCTSTR pszFileName, CMsiReader* pMR = NULL );

    // Destructor
    //
    ~CProfileReader();

    // Operations
    //
    LPCTSTR GetProfile( LPCTSTR pszSection, LPCTSTR pszKeyName );

protected:
    // Attributes
    //
    LPTSTR m_pszFileName; // initialization filename
    CStringQueue m_ProfileStrings;
    CMsiReader* m_pMsiReader;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\profilereader.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     ProfileReader.cpp
// Owner:    jbae
// Purpose:  This class wraps function calls to msi.dll. To support delayed reboot,
//           we need to load msi.dll from the location specified in registry.
//                              
// History:
//  03/06/01, jbae: created

#include "ProfileReader.h"
#include "SetupError.h"
#include "fxsetuplib.h"

// Constructors
//
// ==========================================================================
// CProfileReader::CProfileReader()
//
// Inputs: none
// Purpose:
// ==========================================================================
CProfileReader::
CProfileReader( LPCTSTR pszDir, LPCTSTR pszFileName, CMsiReader* pMR )
: m_pMsiReader(pMR)
{
    if ( NULL == pszDir )
    {
        m_pszFileName = new TCHAR[ _tcslen(pszFileName) + 3 ];
        _tcscpy( m_pszFileName, _T(".\\") );
    }
    else if (  _T('\0') == *pszDir )
    {
        m_pszFileName = new TCHAR[ _tcslen(pszFileName) + 3 ];
        _tcscpy( m_pszFileName, _T(".\\") );
    }
    else
    {
        m_pszFileName = new TCHAR[ _tcslen(pszDir) + _tcslen(pszFileName) + 1 ];
        _tcscpy( m_pszFileName, pszDir );
    }
    _tcscat( m_pszFileName, pszFileName );
}

// ==========================================================================
// CProfileReader::~CProfileReader()
//
// Inputs: none
// Purpose:
//  frees m_hMsi
// ==========================================================================
CProfileReader::
~CProfileReader()
{
    delete [] m_pszFileName;
}

// Implementations
//
// ==========================================================================
// CProfileReader::GetProfile()
//
// Purpose:
//  Loads msi.dll by calling LoadDarwinLibrary().
// Inputs:
//  none
// Outputs:
//  sets m_hMsi
// ==========================================================================
LPCTSTR CProfileReader::
GetProfile( LPCTSTR pszSection, LPCTSTR pszKeyName )
{
    DWORD ctChar = 0;
    unsigned int nSize = ALLOC_BUF_UNIT;
    LPTSTR pszRet;
    LPTSTR pszStr = new TCHAR[ nSize ];
    while( true )
    {
        ctChar = GetPrivateProfileString( pszSection, 
                                pszKeyName, 
                                _T(""), 
                                pszStr,
                                nSize, 
                                m_pszFileName );
        if ( 0 == ctChar )
            return NULL;

        if ( ctChar >= nSize-2 )
        {
            delete pszStr;
            nSize += ALLOC_BUF_UNIT;
            pszStr = new TCHAR[ nSize ];
            continue;
        }

        _ASSERTE( pszStr );
        _ASSERTE( *pszStr );
        if ( NULL != m_pMsiReader && NULL != _tcschr( pszStr, _T('[') ) )
        {
            LPTSTR pStr, pChr;
            CStringQueue sq;
            int state = 0;
            pStr = pszStr;
            pChr = pszStr;
            while ( *pChr != _T('\0') && -1 != state )
            {
                switch ( state )
                {
                case 0:
                    if ( _T('[') == *pChr )
                    {
                        state = 1;
                        *pChr = _T('\0');
                        sq.Enqueue( pStr );
                        pChr = _tcsinc( pChr );
                        pStr = pChr;
                    }
                    else if ( _T(']') == *pChr )
                        state = -1;
                    else
                        pChr = _tcsinc( pChr );

                    break;
                case 1:
                    if ( _T('[') == *pChr )
                        state = -1;
                    else if ( _T(']') == *pChr )
                    {
                        state = 0;
                        *pChr = _T('\0');
                        LPTSTR pTmp = NULL;
                        try
                        {
                            pTmp = (LPTSTR)m_pMsiReader->GetProperty( pStr );
                        }
                        catch( ... )
                        {
                            state = -1;
                        }
                        if ( pTmp ) sq.Enqueue( pTmp );
                        pChr = _tcsinc( pChr );
                        pStr = pChr;
                    }
                    else
                        pChr = _tcsinc( pChr );
                    break;
                default:
                    break;
                }
            }
            if ( 0 != state )
            {
                CSetupError se( IDS_BAD_INI_FILE, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_BAD_INI_FILE );
                throw( se );
            }
            else
            {
                sq.Enqueue( pStr );
                pszRet = sq.Concat();
            }
        }
        else
            pszRet = pszStr;

         break;
    } // while(true)

    pszRet = m_ProfileStrings.Enqueue( pszRet );
    delete [] pszStr;
    return pszRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\stringutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "StringUtil.h"
#include <crtdbg.h>

CStringQueue::
~CStringQueue()
{
    PQUEUENODE pTmp;
    while( m_pHead )
    {
        pTmp = m_pHead;
        m_pHead = pTmp->pNext;
        delete pTmp;
    }
}

LPTSTR CStringQueue::
Enqueue( LPTSTR pszStr )
{
    if ( NULL == pszStr ) return NULL;
    if ( _T('\0') == *pszStr ) return NULL;

    PQUEUENODE pNode = new QUEUENODE( pszStr );
    _ASSERTE( pNode );
    m_nSize += _tcslen( pszStr );

    if ( NULL == m_pHead )
    {
        m_pHead = pNode;
        m_pHead->pNext = NULL;
    }
    else
    {
        PQUEUENODE pTmp = m_pHead;
        while( pTmp->pNext )
            pTmp = pTmp->pNext;

        pNode->pNext = NULL;
        pTmp->pNext = pNode;
    }
    return pNode->pszString;
}

LPTSTR CStringQueue::
Concat()
{
    if ( NULL == m_pHead ) return NULL;

    PQUEUENODE pNode = m_pHead;
    LPTSTR pszStr = new TCHAR[ m_nSize + 1 ];
    *pszStr = _T('\0');
    while( pNode )
    {
        _tcscat( pszStr, pNode->pszString );
        pNode = pNode->pNext;
    }
    Enqueue( pszStr );
    return pszStr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\readflags.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     ReadFlags.h
// Owner:    jbae
// Purpose:  definition of CReadFlags
//                              
// History:
//  03/07/2002, jbae: created

#ifndef READFLAGS_H
#define READFLAGS_H

#include <windows.h>
#include <tchar.h>

const int MAX_SOURCEDIR       = 247; // max size of source dir

// ==========================================================================
// class CReadFlags
//
// Purpose:
//  this class parses commandline and stores them into member variables
// ==========================================================================
class CReadFlags
{
public:
    // Constructor and destructor
    //
    CReadFlags( LPTSTR szCommandLine );
    ~CReadFlags();

    // Operations
    //
    void Parse();
    void ParseSourceDir();
    bool IsQuietMode() const { return m_bQuietMode; }
    bool IsProgressOnly() const { return m_bProgressOnly; }
    bool IsInstalling() const { return m_bInstalling; }
    bool IsNoARP() const { return m_bNoARP; }
    LPCTSTR GetLogFileName() const;
    LPCTSTR GetSourceDir() const; 
    void SetMsiName( LPCTSTR pszMsiName ) { m_pszMsiName = pszMsiName; };

    LPTSTR m_pszSwitches; // holds commandline switches

protected:
    // Attributes
    //
    LPCTSTR m_pszMsiName;
    bool m_bQuietMode;
    bool m_bProgressOnly;
    bool m_bInstalling;
    LPTSTR m_pszLogFileName;
    LPTSTR m_pszSourceDir;
    bool m_bNoARP;

private:
    // Implementations
    //
    void ThrowUsageException();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\stringutil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef STRINGUTIL_H
#define STRINGUTIL_H

#include <windows.h>
#include <tchar.h>

class CStringQueue
{
    typedef struct _QUEUENODE
    {
        LPTSTR pszString;
        _QUEUENODE *pNext;
        _QUEUENODE( LPTSTR pszStr ) { pszString = new TCHAR[ _tcslen( pszStr ) + 1 ]; _tcscpy( pszString, pszStr ); };
        ~_QUEUENODE() { delete [] pszString; }
    } QUEUENODE, *PQUEUENODE;

public:
    CStringQueue() : m_nSize(0), m_pHead(NULL) {};
    ~CStringQueue();
    LPTSTR Enqueue( LPTSTR pszStr );
    LPTSTR Concat();
    unsigned int GetSize() { return m_nSize; };

private:
    PQUEUENODE m_pHead;
    unsigned int m_nSize;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by fxsetuplib.rc
//
#define IDS_SETUP_FAILURE               1
#define IDS_UNKNOWN_PRODUCT             2
#define IDS_UNSUPPORTED_PLATFORM        3
#define IDS_PRODUCT_GENERIC             4
#define IDS_DIALOG_CAPTION              5
#define IDS_USAGE_TEXT                  6
#define IDS_MSI_NAME_TOO_LONG           7
#define IDS_SETUP_COMPLETE              8
#define IDS_SETUP_CANCELLED             9
#define IDS_CANNOT_GET_MSI_NAME         10
#define IDS_CANNOT_OPEN_MSI             11
#define IDS_CANNOT_READ_MSI             12
#define IDS_DARWIN_NOT_INSTALLED        13
#define IDS_ERROR_PRODUCT_VERSION       14
#define IDS_NOT_ENOUGH_MEMORY           15
#define IDS_CANNOT_GET_TEMP_DIR         16
#define IDS_TEMP_DIR_TOO_LONG           17
#define IDS_SOURCE_DIR_TOO_LONG         18
#define IDS_CANNOT_WRITE_LOG            19
#define IDS_BAD_INI_FILE                20
#define IDS_OCM_FOUND                   21

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\setupcodes.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// SetupCodes.h
//
// This file contains the errors that the Setup and related tools return
//
//*****************************************************************************
#ifndef SetupCodes_h_
#define SetupCodes_h_

const int COR_USAGE_ERROR               = 0x001000; // (4096) Improper usage/invalid parameters
const int COR_DARWIN_NOT_INSTALLED      = 0x001001; // (4097) Windows Installer is not installed properly on machine
const int COR_MSI_OPEN_ERROR            = 0x001002; // (4098) Cannot open MSI Database
const int COR_MSI_READ_ERROR            = 0x001003; // (4099) Cannot read from MSI Database
const int COR_SOURCE_DIR_TOO_LONG       = 0x001004; // (4100) source directory too long 

// initialization error -- these errors cannot be logged (0x0011XX)
const int COR_INIT_ERROR                = 0x001100; // (4352) initialization error -- cannot be logged

const int COR_CANNOT_GET_MSI_NAME       = 0x001101; // (4353) cannot get package name from setup.ini
const int COR_MSI_NAME_TOO_LONG         = 0x001102; // (4354) msi filename is too long
const int COR_TEMP_DIR_TOO_LONG         = 0x001103; // (4355) Temp directory too long
const int COR_CANNOT_GET_TEMP_DIR       = 0x001104; // (4356) Cannot get Temp directory
const int COR_CANNOT_WRITE_LOG          = 0x001105; // (4357) Cannot write to log
const int COR_BAD_INI_FILE              = 0x001106; // (4358) INI file is missing or corrupt

const int COR_EXIT_FAILURE              = 0x001FFF; // (8191) Setup Failure - unknown reason

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\readflags.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     ReadFlags.cpp
// Owner:    jbae
// Purpose:  reads commandline switches and stores those information
//                              
// History:
//  03/07/2002, jbae: created

#include "fxsetuplib.h"
#include "ReadFlags.h"
#include "SetupError.h"

//defines
//
#define EMPTY_BUFFER { _T( '\0' ) }
#define END_OF_STRING  _T( '\0' )

extern TCHAR g_szMsiLogName[];

// Constructor
//
// ==========================================================================
// CReadFlags::CReadFlags()
//
// Inputs:
//  LPTSTR pszCommandLine: commandline passed in by system. It must inclue path to
//  the wrapper (Install.exe).
//
// Purpose:
//  initializes member varialbes.
// ==========================================================================
CReadFlags::
CReadFlags( LPTSTR pszCommandLine )
: m_pszSourceDir(pszCommandLine), m_pszSwitches(NULL), m_bQuietMode(false), m_bInstalling(true),
  m_pszLogFileName(NULL), m_bProgressOnly(false), m_bNoARP(false)
{
    _ASSERTE( NULL != pszCommandLine );
}

CReadFlags::
~CReadFlags()
{
    if ( m_pszLogFileName )
        delete [] m_pszLogFileName;
}

// Operations
//
// ==========================================================================
// CReadFlags::ParseSourceDir()
//
// Purpose:
//  parses commandline to find SourceDir.
// ==========================================================================
void CReadFlags::
ParseSourceDir()
{
    TCHAR *pszTmp = NULL;
    TCHAR *pszTmp2 = NULL;

    _ASSERTE( NULL != m_pszSourceDir );
    // First, we need to get the directory Install.exe lies
    if ( _T('"') == *m_pszSourceDir )
    {
        // if started with double-quote, we need to find the matching one.
        m_pszSourceDir = _tcsinc( m_pszSourceDir );
        pszTmp = _tcschr( m_pszSourceDir, _T('"') );
        if ( NULL == pszTmp )
        { // if there's no matching double-quote, ignore it
            pszTmp = _tcschr( m_pszSourceDir, _T(' ') );
            if ( NULL == pszTmp )
            {
                pszTmp = _tcschr( m_pszSourceDir, END_OF_STRING );
            }
            else
            {
                *pszTmp = END_OF_STRING;
                pszTmp = _tcsinc( pszTmp );    
            }
        }
        else
        {
            *pszTmp = END_OF_STRING;
            pszTmp = _tcsinc( pszTmp );    
        }
    }
    else
    {
        pszTmp = _tcschr( m_pszSourceDir, _T(' ') );
        if ( NULL == pszTmp )
        {
            pszTmp = _tcschr( m_pszSourceDir, END_OF_STRING );
        }
        else
        {
            *pszTmp = END_OF_STRING;
            pszTmp = _tcsinc( pszTmp );    
        }
    }

    // If there's \ before Install.exe, we have SourceDir
    // otherwise, SourceDir is empty
    pszTmp2 = _tcsrchr( m_pszSourceDir, _T('\\') );
    if ( NULL == pszTmp2 )
    {
        m_pszSourceDir = NULL;
    }
    else
    {
        pszTmp2 = _tcsinc( pszTmp2 ); // leave trailing backslash
        *pszTmp2 = END_OF_STRING;
        if ( MAX_SOURCEDIR < _tcslen(m_pszSourceDir) )
        {
            CSetupError se( IDS_SOURCE_DIR_TOO_LONG, IDS_DIALOG_CAPTION, MB_ICONERROR, COR_SOURCE_DIR_TOO_LONG );
            throw se;
        }
    }

    // Now pszTmp points to switches only
    // remove white spaces before switches
    while( iswspace( *pszTmp ) )
    {
        pszTmp = _tcsinc( pszTmp );
    }
    m_pszSwitches = pszTmp;
}

// ==========================================================================
// CReadFlags::Parse()
//
// Purpose:
//  parses commandline switches and stores them into member variables.
// ==========================================================================
void CReadFlags::
Parse()
{
    TCHAR *pszBuf = NULL;
    TCHAR *pszTmp = NULL;
    TCHAR *pszTmp2 = NULL;
    TCHAR szSwitch[] = _T("/-");

    pszTmp = _tcstok( m_pszSwitches, szSwitch );
    while ( NULL != pszTmp )
    {
        switch ( *pszTmp )
        {
        case _T('q'):
        case _T('Q'):
            pszBuf = _tcsinc( pszTmp );
            if ( _T('b') == *pszBuf || _T('B') == *pszBuf )
            {
                // Basic and progress bar only
                // INSTALLUILEVEL_BASIC | INSTALLUILEVEL_PROGRESSONLY
                m_bProgressOnly = true;
                pszBuf = _tcsinc( pszBuf );
            }

            while( iswspace( *pszBuf ) )
                pszBuf = _tcsinc( pszBuf );
            if ( END_OF_STRING == *pszBuf )
                m_bQuietMode = true;
            else
                ThrowUsageException();
            break;
        case _T('u'):
        case _T('U'):
    		m_bInstalling = false;
            break;
        case _T('l'):
        case _T('L'): // Hidden switch for darwin logging
            pszBuf = _tcsinc( pszTmp );
            while( iswspace( *pszBuf ) )
            {
                pszBuf = _tcsinc( pszBuf );
            }
            if ( END_OF_STRING != *pszBuf )
            { // we have some non-white characters
                pszTmp2 = _tcschr( pszBuf, END_OF_STRING );
                pszTmp2 = _tcsdec( pszBuf, pszTmp2 );
                while( iswspace( *pszTmp2 ) )
                {
                    pszTmp2 = _tcsdec( pszBuf, pszTmp2 );
                }
                pszTmp2 = _tcsinc( pszTmp2 );
                *pszTmp2 = END_OF_STRING;
                // now white spaces are gone
                m_pszLogFileName = new TCHAR[ _tcslen(pszBuf) + 1 ];
                if ( _T('"') == *pszBuf )
                {
                    pszBuf = _tcsinc( pszBuf );
                    pszTmp2 = _tcschr( pszBuf, END_OF_STRING );
                    pszTmp2 = _tcsdec( pszBuf, pszTmp2 );
                    if ( _T('"') == *pszTmp2 )
                    {
                        *pszTmp2 = END_OF_STRING;
                        _tcscpy( m_pszLogFileName, pszBuf );
                    }
                }
                else
                {
                    _tcscpy( m_pszLogFileName, pszBuf );
                }
            }
            else
            {   // /l switch given but no <logfile> given
                CTempLogPath templog( g_szMsiLogName );
                m_pszLogFileName = new TCHAR[ _tcslen((LPCTSTR)templog) + 1 ];
                _tcscpy( m_pszLogFileName, (LPCTSTR)templog );
            }
            break;

        case _T('n'):
        case _T('N'):
            // Remove trailing whitespace
            pszTmp2 = _tcschr( pszTmp, END_OF_STRING );
            pszTmp2 = _tcsdec( pszTmp, pszTmp2 );
            while( iswspace( *pszTmp2 ) )
            {
                pszTmp2 = _tcsdec( pszTmp, pszTmp2 );
            }
            pszTmp2 = _tcsinc( pszTmp2 );
            *pszTmp2 = END_OF_STRING;

            if ( 0 == _tcsicmp( _T("noarp"), pszTmp ) )
            {
                LogThis( _T( "Will not add to ARP" ) );
                m_bNoARP = true;
            }
            break;

        case _T('?'):
        case _T('h'):
        case _T('H'):
        default:
            ThrowUsageException();
        }
        
        pszTmp = _tcstok( NULL, szSwitch );
    }
}

// ==========================================================================
// CReadFlags::GetLogFileName()
//
// Inputs: none
// Returns: 
//  LPTSTR: returns NULL if logfile is not given otherwise
//          returns the name of the logfile.
// Purpose:
//  returns logfile name.
// ==========================================================================
LPCTSTR CReadFlags::
GetLogFileName() const
{
    return const_cast<LPCTSTR>( m_pszLogFileName );
}

// ==========================================================================
// CReadFlags::GetSourceDir()
//
// Inputs: none
// Returns: 
//  LPTSTR: returns source dir
// ==========================================================================
LPCTSTR CReadFlags::
GetSourceDir() const
{
    return const_cast<LPCTSTR>( m_pszSourceDir );
}

void CReadFlags::
ThrowUsageException()
{
    CSetupError se;

    se.SetError( IDS_USAGE_TEXT, IDS_DIALOG_CAPTION, MB_ICONEXCLAMATION, COR_USAGE_ERROR );
    throw se;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\format\format.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/***************************************************************************/
/* routines for parsing file format stuff ... */

#include "..\\inc\\corhlpr.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\format\makefile.inc ===
copy_to_urttarget: $(TARGETPATH)\$(CPU)\$(TARGETNAME).lib
	xcopy /fy $(TARGETPATH)\$(CPU)\$(TARGETNAME).lib $(URTTARGET)\sdk\lib\
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_APP
#define VER_INTERNALNAME_STR    "Inst.exe"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Setup Bootstrapper\0"
#define VER_ORIGFILENAME_STR    "Inst.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\fusion.inc ===
MSC_WARNING_LEVEL = /W3 /WX
NO_NTDLL=1
USE_MSVCRT=1

!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) 
!else
C_DEFINES = $(C_DEFINES) -DDEBUG
!endif

C_DEFINES = $(C_DEFINES) -DFUSION_QUALIFYASSEMBLY_ENABLED -DFUSION_PARTIAL_BIND_DEBUG -DFUSION_RETAIL_LOGGING -DFUSION_CODE_DOWNLOAD_ENABLED -DFUSION_REDEFINE_ASSERT=1 -DMSOERT_NO_PROTSTOR=1

!ifdef FUSIONBBT
LINKER_FLAGS=$(LINKER_FLAGS) /debug /debugtype:cv,fixup /opt:ref /incremental:no
!endif

#
# Set private include paths
#

NO_BROWSER_FILE=1

FUSION_PATH = $(CORBASE)\src\fusion

FUSION_ALL_INC_PATH = $(FUSION_PATH)\inc
FUSION_URT_INC_PATH = $(FUSION_PATH)\inc\urt

FUSION_WRAPPER_INC_PATH=$(FUSION_PATH)\wrappers

FUSION_ALL_DIRECTDB_INC_DEST=$(FUSION_PATH)\directdb\inc

FUSION_URT_LIB_DEST = $(FUSION_PATH)\urtobj\$(_OBJ_DIR)
FUSION_URT_LIB_PATH = $(FUSION_URT_LIB_DEST)\*

FUSION_LIB_DEST = $(FUSION_URT_LIB_DEST)
FUSION_INC_PATH=$(FUSION_ALL_INC_PATH)
FUSION_BUILD_TYPE_PREFIX=
FUSION_DIRECTDB_INC_DEST=$(FUSION_ALL_DIRECTDB_INC_DEST)
USE_RTTI=1

INCLUDES        = .; \
    $(FUSION_PATH)\inc; \
    $(FUSION_PATH)\external\inc; \
    $(FUSION_PATH)\idl\$(O); \
    $(FUSION_PATH)\directdb\inc; \
    $(FUSION_PATH)\directdb\inc\$(O); \
    $(FUSION_PATH)\directdb\engine; \
    $(WINDOWS_INC_PATH);\
    $(BASE_INC_PATH);\
    $(SDK_INC_PATH);\
    $(NET_INC_PATH);\
    $(CORBASE)\src\inc; \
    $(INCLUDES)

!ifndef FUSION_MBCS
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

#USE_FUSION_WRAPPERS=1
!ifdef USE_FUSION_WRAPPERS
C_DEFINES = $(C_DEFINES) -D_WIN32_IE=0x0500 -DUSE_FUSWRAPPERS
INCLUDES        = \
    $(CORBASE)\src\fusion\wrappers; \
    $(INCLUDES)
!endif

!include $(NTMAKEENV)\sources.cor
SOURCES_USED=$(SOURCES_USED) $(NTMAKEENV)\sources.cor

!ifdef USE_PERFTAGS
C_DEFINES = $(C_DEFINES) -DPERFTAGS
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\setuperror.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/// ==========================================================================
// Name:     SetupError.cpp
// Owner:    jbae
// Purpose:  handles displaying of messagebox and stores return-code from WinMain()
//                              
// History:
//  03/07/2002, jbae: created

#include "SetupError.h"
#include "fxsetuplib.h"

//defines
//
#define EMPTY_BUFFER { _T( '\0' ) }
#define END_OF_STRING  _T( '\0' )

// Constructors
//
// ==========================================================================
// CSetupError::CSetupError()
//
// Purpose:
//  constructs CSetupError object with no parameter. Sets QuietMode to false by default
// ==========================================================================
CSetupError::
CSetupError()
: m_nRetCode(ERROR_SUCCESS), m_bQuietMode(false)
{
}

// ==========================================================================
// CSetupError::CSetupError()
//
// Inputs:
//  UINT nMsg: resourceId for the message to display
//  UINT nCap: resourceId for the caption to display
//  UINT nIcon: icon to use
//  int nRetCode: return code to be returned to the caller of the wrapper
// Purpose:
//  constructs CSetupError object with initial values
// ==========================================================================
CSetupError::
CSetupError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode )
: m_nMessage(nMsg), m_nCaption(nCap), m_nIconType(nIcon), m_bQuietMode(false), m_nRetCode(nRetCode)
{
}

CSetupError::
CSetupError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode, va_list *pArgs )
: m_nMessage(nMsg), m_nCaption(nCap), m_nIconType(nIcon), m_bQuietMode(false), m_pArgs(pArgs),
  m_nRetCode(nRetCode)
{
}

// ==========================================================================
// CSetupError::SetError()
//
// Inputs:
//  UINT nMsg: resourceId for the message to display
//  UINT nCap: resourceId for the caption to display
//  UINT nIcon: icon to use
//  int nRetCode: return code to be returned to the caller of the wrapper
// Purpose:
//  initializes attributes
// ==========================================================================
void CSetupError::
SetError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode )
{
    m_nMessage = nMsg;
    m_nCaption = nCap;
    m_nIconType = nIcon;
    m_nRetCode = nRetCode;
}

// ==========================================================================
// CSetupError::SetError()
//
// Inputs:
//  UINT nMsg: resourceId for the message to display
//  UINT nIcon: icon to use
//  int nRetCode: return code to be returned to the caller of the wrapper
//  va_list *pArgs: arguments to be inserted
// Purpose:
//  initializes attributes
// ==========================================================================
void CSetupError::
SetError( UINT nMsg, UINT nIcon, int nRetCode, va_list *pArgs )
{
    m_nMessage = nMsg;
    m_nIconType = nIcon;
    m_nRetCode = nRetCode;
    m_pArgs = pArgs;
}

// Operations
// ==========================================================================
// CSetupError::ShowError()
//
// Inputs: none
// Purpose:
//  displays messagebox with message loaded from resource if non-quiet mode
// ==========================================================================
int CSetupError
::ShowError()
{
    int nResponse = IDNO;
    TCHAR szCapFmt[_MAX_PATH]  = EMPTY_BUFFER;
    TCHAR szMsgFmt[MAX_MSG]   = EMPTY_BUFFER;
  
    ::LoadString( hAppInst, IDS_DIALOG_CAPTION, szCapFmt, LENGTH(szCapFmt) );
    ::LoadString( hAppInst, m_nMessage, szMsgFmt, LENGTH(szMsgFmt) ) ;

    LPVOID pArgs[] = { (LPVOID)GetProductName() };
    LPVOID pCaption;
    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_STRING |
        FORMAT_MESSAGE_ARGUMENT_ARRAY,
        szCapFmt,
        0,
        0,
        (LPTSTR)&pCaption,
        0,
        (va_list *)pArgs
    );

    LPVOID pMessage;
    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_STRING |
        FORMAT_MESSAGE_ARGUMENT_ARRAY,
        szMsgFmt,
        0,
        0,
        (LPTSTR)&pMessage,
        0,
        (va_list *)m_pArgs
    );

    if ( !(m_nRetCode & COR_INIT_ERROR) )
    {
        LogThis( _T( "Preparing Dialog" ) );
        LogThis( _T( "Message: %s" ), (LPCTSTR)pMessage );
    }

    if ( !m_bQuietMode )
	{
        nResponse = ::MessageBox( NULL, (LPCTSTR)pMessage, (LPCTSTR)pCaption, MB_OK | m_nIconType ) ;
	}
	else
	{
		_ftprintf ( stderr, (LPCTSTR)pMessage ) ;
	}

    LocalFree( pMessage );
    LocalFree( pCaption );

    return nResponse;
}

// ==========================================================================
// CSetupError::GetProductName()
//
// Inputs: none
// Purpose:
//  returns productname. This is a static function.
// ==========================================================================
LPCTSTR CSetupError::
GetProductName()
{
    if ( !s_pszProductName )
    {
        ::LoadString( hAppInst, IDS_PRODUCT_GENERIC, s_szProductGeneric, LENGTH(s_szProductGeneric) ) ;
        s_pszProductName = s_szProductGeneric;
    }
    return s_pszProductName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fldbwrapper\simplewrapper\setuperror.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef SETUPERROR_H
#define SETUPERROR_H

#include <windows.h>
#include <tchar.h>
#include "SetupCodes.h"

#define MAX_MSG    4096
// ==========================================================================
// class CSetupError
//
// Purpose:
//  This class handles displaying of (error) messages as well as holding return-code
// ==========================================================================
class CSetupError
{
public:
    // Constructors
    CSetupError();
    CSetupError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode );
    CSetupError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode, va_list *pArgs );
    void SetError( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode );
    void SetError( UINT nMsg, UINT nIcon, int nRetCode, va_list *pArgs );
    
    // Operations
    int ShowError();
    static LPCTSTR GetProductName();

    // Attributes
    int m_nRetCode;
    bool m_bQuietMode;
    static HINSTANCE hAppInst;
    static LPTSTR s_pszProductName;
    static TCHAR s_szProductGeneric[256];

private:
    UINT m_nCaption;
    UINT m_nMessage;
    UINT m_nIconType;
    va_list *m_pArgs;
};

// ==========================================================================
// class CSetupCode
//
// Purpose:
//  This class is derived from CSetupError. This has additional method called
//  IsRebootRequired() that indicates if reboot is required.
// ==========================================================================
class CSetupCode : public CSetupError
{
public:
    // Constructors
    CSetupCode() { CSetupError(); };
    void SetReturnCode( UINT nMsg, UINT nCap, UINT nIcon, int nRetCode ) { SetError( nMsg, nCap, nIcon, nRetCode ); };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\fusionwarnings.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// C4100: 'identifier' : unreferenced formal parameter
#pragma warning(disable: 4100)

// C4201: nonstandard extension used: nameless struct/union
#pragma warning(disable: 4201)

// C4706: assignment within conditional expression
#pragma warning(disable: 4706)

// C4211: nonstandard extension used: redefined extern to static
#pragma warning(disable: 4211)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\asmint.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


#include "asmint.h"
#include "helpers.h"
#include "lock.h"

CModuleHashNode::CModuleHashNode ( )
{
    _dwSig = 'NDOM';
    _szPath[0] = '\0';
    _cbHash = MAX_HASH_LEN;
    _bHashGen = 0;
    _bHashFound = 0;
    _aAlgId   = 0;
}

CModuleHashNode::~CModuleHashNode ( )
{
    // if(_pNext)   delete _pNext; BUGBUG This would leak memory !!
}

void CModuleHashNode::Init ( LPTSTR szPath, ALG_ID aAlgId, DWORD cbHash, BYTE *pHash)
{
    if(lstrlen(szPath) <= MAX_PATH)
        StrCpy(_szPath, szPath);
    _aAlgId   = aAlgId;
    if(_aAlgId && (cbHash <= MAX_HASH_LEN ) )
    {
        memcpy(_bHash, pHash, cbHash);
        _cbHash = cbHash;
        _bHashGen = TRUE;
    }
    else
    {
        _bHashGen = FALSE;
    }
}


void
CModuleHashNode::AddToList(CModuleHashNode **pHead)
{
    // Is it possible that a node for this file already exists ??
    // If yes check szPath to avoid duplicates !!

    _pNext = *pHead;
    *pHead = this;
}


void
CModuleHashNode::DestroyList()
{
    CModuleHashNode *pModList = this, *pTemp;

    while ( pModList ) 
    {
        pTemp = pModList;
        pModList = pModList->_pNext;
        delete pTemp;
    }

}


BOOL 
CompareHashs(DWORD cbHash, PBYTE pHash1, PBYTE pHash2)
{
    DWORD * pdwHash1 = (DWORD *)pHash1, *pdwHash2 = (DWORD *)pHash2;

    // Here the assumption is cbHash will always be a multiple of sizeof(DWORD).
    while (cbHash > 0 )
    {
        if( *pdwHash1 != *pdwHash2 )
        {
            return FALSE;
        }

        pdwHash1++; pdwHash2++; cbHash -= sizeof (DWORD);
    }

    return TRUE;
}


HRESULT GetHash(LPCTSTR szFileName, ALG_ID iHashAlg, PBYTE pbHash, DWORD *pdwHash)
{

#define MAX_ARRAY_SIZE  16384
#define HASH_BUFFER_SIZE (MAX_ARRAY_SIZE-4)

    HRESULT    hr = E_FAIL;
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    DWORD      dwHash=0;
    DWORD      dwBufferLen;
    BYTE      *pbBuffer = NULL;
    HANDLE     hSourceFile = INVALID_HANDLE_VALUE; 

    pbBuffer = NEW(BYTE[MAX_ARRAY_SIZE]);
    if (!pbBuffer) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // BUGBUG: Temp hack for Win9x. W version is not suppoted in 9x.
    // We are not passing any strings here !!
    if(!CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) 
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    if(!CryptCreateHash(hProv, iHashAlg, 0, 0, &hHash)) 
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    // Open source file.
    hSourceFile = CreateFile (szFileName, GENERIC_READ, FILE_SHARE_READ,
        NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hSourceFile == INVALID_HANDLE_VALUE)
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    while ( ReadFile (hSourceFile, pbBuffer, HASH_BUFFER_SIZE, &dwBufferLen, NULL) && dwBufferLen )
    {
        // Add data to hash object.
        if(!CryptHashData(hHash, pbBuffer, dwBufferLen, 0)) {
            goto exit;
        }
    }

    if(!CryptGetHashParam(hHash, HP_HASHVAL, pbHash, pdwHash, 0)) 
        goto exit;

    hr = S_OK;

 exit:
    SAFEDELETEARRAY(pbBuffer);

    if (hHash)
        CryptDestroyHash(hHash);
    if (hProv)
        CryptReleaseContext(hProv,0);
    if (hSourceFile != INVALID_HANDLE_VALUE)
        CloseHandle(hSourceFile);

    return hr;
}


BOOL
CModuleHashNode::FindMatchingHashInList ( CModuleHashNode *pStreamList, DWORD cbHash, PBYTE pHash, ALG_ID aAlgId, CModuleHashNode **ppMachingModNode )
{
    CModuleHashNode *pModList = pStreamList;
    HRESULT hr = S_OK;

    while ( pModList ) 
    {
        // Calculate hash for this file if hash is not found or ALG_ID is diff.
        if( (!pModList->_bHashFound) && 
            ((!pModList->_bHashGen) || (pModList->_aAlgId != aAlgId)) )
        {
            pModList->_cbHash = MAX_HASH_LEN;
            hr = GetHash(pModList->_szPath, aAlgId, pModList->_bHash, &(pModList->_cbHash) ); 
            if( SUCCEEDED(hr) )
            {
                pModList->_bHashGen = 1;
                pModList->_aAlgId = aAlgId;
            }
            else
            {
                pModList->_cbHash = 0;
                pModList->_bHashGen = 0;
            }
        }
        
        if(    (!pModList->_bHashFound) && pModList->_cbHash && 
                        (pModList->_cbHash == cbHash) )
        {
            if (CompareHashs( cbHash, pHash, pModList->_bHash ))
            {
                pModList->_bHashFound=1;

                *ppMachingModNode = pModList; 
                return TRUE;
            }
        }

        pModList = pModList->_pNext;
    }

    return FALSE;
}

BOOL
CModuleHashNode::HashesForAllModulesFound(CModuleHashNode *pStreamList)
{

    CModuleHashNode *pModList = pStreamList;
    BOOL bAllModsFound = TRUE;

    while ( pModList ) 
    {
        if( !(pModList->_bHashFound) )
        {
            // try to return error code here.
            DeleteFile(pModList->_szPath);
            bAllModsFound = FALSE;
        }

        pModList = pModList->_pNext;
    }

    return bAllModsFound;
}

HRESULT
CModuleHashNode::RectifyFileName(LPCTSTR pszPath, DWORD cbPath) 
{
    HRESULT hr = S_OK;
    TCHAR   szBuf[MAX_PATH+1], *pszTemp;

    StrCpy(szBuf, _szPath);
    pszTemp = PathFindFileName (szBuf);

    if (pszTemp <= szBuf)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
        goto exit;
    }

    *(pszTemp) = TEXT('\0');

    
    if( (lstrlen(szBuf) + cbPath) > MAX_PATH )
    {
        hr =  HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME );
        goto exit;
    }

    StrCat(szBuf, pszPath);

    if ( !MoveFile(_szPath, szBuf) )
    {
        hr = FusionpHresultFromLastError();
        if( GetFileAttributes(szBuf) != -1 )
        {
            // someone else already downloaded this file.
            DeleteFile(_szPath);
            hr = S_OK;
        }
    }

exit :

    return hr;

}


HRESULT
CModuleHashNode::DoIntegrityCheck( CModuleHashNode *pStreamList, IAssemblyManifestImport *pManifestImport, BOOL *pbDownLoadComplete )
{

    CModuleHashNode *pModList = pStreamList, *pMatchingModNode;
    HRESULT hr = S_OK;
    BYTE    bHash[MAX_HASH_LEN];
    DWORD   cbHash=0, dwIndex=0, dwAlgId=0;
    IAssemblyModuleImport *pModImport=NULL;

    if ( !pManifestImport)
    {
        hr = COR_E_MISSINGMANIFESTRESOURCE;
        goto exit;
    }

    pModList = pStreamList;
    dwIndex = 0;


    while ( SUCCEEDED(hr = pManifestImport->GetNextAssemblyModule(dwIndex, &pModImport) ))
    {
        hr = pModImport->GetHashAlgId( &dwAlgId );

        if(!SUCCEEDED(hr) )
            goto exit;

        cbHash = MAX_HASH_LEN; 
        hr = pModImport->GetHashValue(bHash, &cbHash);
        
        if(!SUCCEEDED(hr) )
            goto exit;

        if ( FindMatchingHashInList(pStreamList, cbHash, bHash, dwAlgId, &pMatchingModNode) )
        {
            TCHAR   szPath[MAX_PATH+1];
            DWORD   cbPath=MAX_PATH;

            hr = pModImport->GetModuleName(szPath, &cbPath);
            if(!SUCCEEDED(hr) )
                goto exit;

            hr = pMatchingModNode->RectifyFileName(szPath, cbPath);
            if(!SUCCEEDED(hr) )
                goto exit;

        }
        else
        { 
            // Atleast one module is missing !!
            *pbDownLoadComplete = FALSE;
        }

        pModImport->Release();
        pModImport = NULL;
        dwIndex++;
    }

    hr = S_OK; 

    if(!HashesForAllModulesFound(pStreamList))
        hr = FUSION_E_UNEXPECTED_MODULE_FOUND;
exit :

    if(pModImport)
        pModImport->Release();

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\asmcache.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "asmcache.h"
#include "asmitem.h"
#include "naming.h"
#include "debmacro.h"
#include "appctx.h"
#include "helpers.h"
#include "asm.h"
#include "asmimprt.h"
#include "policy.h"
#include "dbglog.h"
#include "scavenger.h"
#include "util.h"
#include "cache.h"
#include "cacheUtils.h"
#include "refcount.h"

extern BOOL g_bRunningOnNT;

// ---------------------------------------------------------------------------
// ValidateAssembly
// ---------------------------------------------------------------------------
HRESULT ValidateAssembly(LPCTSTR pszManifestFilePath, IAssemblyName *pName)
{
    HRESULT                    hr = S_OK;
    BYTE                       abCurHash[MAX_HASH_LEN];
    BYTE                       abFileHash[MAX_HASH_LEN];
    DWORD                      cbModHash;
    DWORD                      cbFileHash;
    DWORD                      dwAlgId;
    WCHAR                      wzDir[MAX_PATH+1];
    LPWSTR                     pwzTmp = NULL;
    WCHAR                      wzModName[MAX_PATH+1];
    WCHAR                      wzModPath[MAX_PATH+1];
    DWORD                      idx = 0;
    DWORD                      cbLen=0;
    IAssemblyManifestImport   *pManifestImport=NULL;
    IAssemblyModuleImport     *pCurModImport = NULL;
    BOOL                       bExists;

    hr = CheckFileExistence(pszManifestFilePath, &bExists);
    if (FAILED(hr)) {
        goto exit;
    }
    else if (!bExists) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto exit;
    }

    if (FAILED(hr = CreateAssemblyManifestImport((LPTSTR)pszManifestFilePath, &pManifestImport))) 
    {
        goto exit;
    }

    // Integrity checking
    // Walk all modules to make sure they are there (and are valid)

    lstrcpyW(wzDir, pszManifestFilePath);
    pwzTmp = PathFindFileName(wzDir);
    *pwzTmp = L'\0';

    while (SUCCEEDED(hr = pManifestImport->GetNextAssemblyModule(idx++, &pCurModImport)))
    {
        cbLen = MAX_PATH;
        if (FAILED(hr = pCurModImport->GetModuleName(wzModName, &cbLen)))
            goto exit;

        wnsprintfW(wzModPath, MAX_PATH, L"%s%s", wzDir, wzModName);
        hr = CheckFileExistence(wzModPath, &bExists);
        if (FAILED(hr)) {
            goto exit;
        }
        else if (!bExists) {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto exit;
        }

        // Get the hash of this module from manifest
        if(FAILED(hr = pCurModImport->GetHashAlgId(&dwAlgId)))
            goto exit;

        cbModHash = MAX_HASH_LEN; 
        if(FAILED(hr = pCurModImport->GetHashValue(abCurHash, &cbModHash)))
            goto exit;

        cbFileHash = MAX_HASH_LEN;
        // BUGBUG: Assumes TCHAR==WCHAR
        if(FAILED(hr = GetHash(wzModPath, (ALG_ID)dwAlgId, abFileHash, &cbFileHash)))
            goto exit;

        if ((cbModHash != cbFileHash) || !CompareHashs(cbModHash, abCurHash, abFileHash)) 
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto exit;
        }

        SAFERELEASE(pCurModImport);
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) 
    {
        hr = S_OK;
    }

exit:

    SAFERELEASE(pManifestImport);
    SAFERELEASE(pCurModImport);

    return hr;
}

// ---------------------------------------------------------------------------
// FusionGetFileVersionInfo
// ---------------------------------------------------------------------------
HRESULT FusionGetFileVersionInfo(LPWSTR pszManifestPath, ULARGE_INTEGER *puliFileVerNo)
{
    HRESULT hr = S_OK;
    DWORD   dwHandle;
    PBYTE   pVersionInfoBuffer=NULL;
    LPSTR  pszaManifestPath=NULL;
    BOOL    fRet;
    DWORD   cbBuf;
    
    ASSERT(pszManifestPath && puliFileVerNo);

    if(g_bRunningOnNT) {
        cbBuf = GetFileVersionInfoSizeW(pszManifestPath,  &dwHandle);
    }
    else {
        hr = Unicode2Ansi(pszManifestPath, &pszaManifestPath);
        if(FAILED(hr)) {
            goto exit;
        }

        cbBuf = GetFileVersionInfoSizeA(pszaManifestPath,  &dwHandle);
    }

    if(cbBuf) {
        pVersionInfoBuffer = NEW(BYTE[cbBuf]);
        if (!pVersionInfoBuffer) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }
    else {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    if(g_bRunningOnNT) {
        fRet = GetFileVersionInfoW(pszManifestPath, dwHandle, cbBuf, pVersionInfoBuffer);
    }
    else {
        fRet = GetFileVersionInfoA(pszaManifestPath, dwHandle, cbBuf, pVersionInfoBuffer);
    }

    if (fRet) {
        UINT cbLen;
        VS_FIXEDFILEINFO * pvsfFileInfo;

        if(g_bRunningOnNT) {
            fRet = VerQueryValueW(pVersionInfoBuffer, L"\\",(void * *)&pvsfFileInfo, &cbLen);
        }
        else {
            fRet = VerQueryValueA(pVersionInfoBuffer, "\\",(void * *)&pvsfFileInfo, &cbLen);
        }

        if (fRet && cbLen > 0) {
            puliFileVerNo->HighPart = pvsfFileInfo->dwFileVersionMS;
            puliFileVerNo->LowPart = pvsfFileInfo->dwFileVersionLS;
            goto exit;
        }
    }
    
    hr = FusionpHresultFromLastError();

exit:

    if(!g_bRunningOnNT) {
        SAFEDELETEARRAY(pszaManifestPath);
    }

    SAFEDELETEARRAY(pVersionInfoBuffer);
    return hr;
}

// ---------------------------------------------------------------------------
// CompareFileVersion
// ---------------------------------------------------------------------------
BOOL CompareFileVersion( ULARGE_INTEGER uliNewVersionNo,
                         ULARGE_INTEGER uliExistingVersionNo,
                         int *piNewer)
{
    BOOL              bRet = FALSE;

    if( uliNewVersionNo.QuadPart > uliExistingVersionNo.QuadPart)
    {
        bRet = TRUE;
        *piNewer = 1; // file-version is greater
        goto exit;
    }

    if( uliNewVersionNo.QuadPart == uliExistingVersionNo.QuadPart)
    {
        *piNewer = 0; // file-version is same
        goto exit;
    }

    *piNewer = -1; // file-version is lesser.

exit :
    return bRet;
}

// ---------------------------------------------------------------------------
// IsNewerFileVersion
// ---------------------------------------------------------------------------
BOOL IsNewerFileVersion( LPWSTR pszNewManifestPath, LPWSTR pszExistingManifestPath, int *piNewer)
{
    BOOL              bRet = FALSE;
    ULARGE_INTEGER    uliExistingVersionNo;
    ULARGE_INTEGER    uliNewVersionNo;

    ASSERT(piNewer);

    memset( &uliExistingVersionNo, 0, sizeof(ULARGE_INTEGER));
    memset( &uliNewVersionNo,      0, sizeof(ULARGE_INTEGER));

    if(FAILED(FusionGetFileVersionInfo(pszNewManifestPath, &uliNewVersionNo)))
        goto exit;

    if(FAILED(FusionGetFileVersionInfo(pszExistingManifestPath, &uliExistingVersionNo)))
        goto exit;

    bRet = CompareFileVersion( uliNewVersionNo, uliExistingVersionNo, piNewer);

    if(!(*piNewer))
    {
        // if file version is same see if it is valid.
        if(ValidateAssembly(pszExistingManifestPath, NULL) != S_OK)
            bRet = TRUE;
    }

exit :
    return bRet;
}

// ---------------------------------------------------------------------------
// CopyAssemblyFile
// ---------------------------------------------------------------------------
HRESULT CopyAssemblyFile
    (IAssemblyCacheItem *pasm, LPCOLESTR pszSrcFile, DWORD dwFormat)
{
    HRESULT hr;
    IStream* pstm    = NULL;
    HANDLE hf        = INVALID_HANDLE_VALUE;
    LPBYTE pBuf      = NULL;
    DWORD cbBuf      = 0x4000;
    DWORD cbRootPath = 0;
    TCHAR *pszName   = NULL;
    
    // Find root path length
    pszName = PathFindFileName(pszSrcFile);

    cbRootPath = (DWORD) (pszName - pszSrcFile);
    ASSERT(cbRootPath < MAX_PATH);
    
    hr = pasm->CreateStream (0, pszSrcFile+cbRootPath, 
        dwFormat, 0, &pstm, NULL);

    if (hr != S_OK)
        goto exit;

    pBuf = NEW(BYTE[cbBuf]);
    if (!pBuf)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    DWORD dwWritten, cbRead;
    hf = CreateFile (pszSrcFile, GENERIC_READ, FILE_SHARE_READ,
        NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hf == INVALID_HANDLE_VALUE)
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    while (ReadFile (hf, pBuf, cbBuf, &cbRead, NULL) && cbRead)
    {
        hr = pstm->Write (pBuf, cbRead, &dwWritten);
        if (hr != S_OK)
            goto exit;
    }

    hr = pstm->Commit(0);
    if (hr != S_OK)
        goto exit;

exit:

    SAFERELEASE(pstm);
    SAFEDELETEARRAY(pBuf);

    if (hf != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hf);
    }
    return hr;
}





/*--------------------- CAssemblyCache defines -----------------------------*/


CAssemblyCache::CAssemblyCache()
{
    _dwSig = 'CMSA';
    _cRef = 1;
}

CAssemblyCache::~CAssemblyCache()
{

}


STDMETHODIMP CAssemblyCache::InstallAssembly( // if you use this, fusion will do the streaming & commit.
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszManifestFilePath, 
        /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData)
{
    HRESULT                            hr=S_OK;
    LPWSTR                             szFullCodebase=NULL;
    LPWSTR                             szFullManifestFilePath=NULL;
    DWORD                              dwLen=0;
    DWORD                              dwIdx = 0;
    WCHAR                              wzDir[MAX_PATH+1];
    WCHAR                              wzModPath[MAX_PATH+1];
    WCHAR                              wzModName[MAX_PATH+1];
    LPWSTR                             pwzTmp = NULL;

    IAssemblyManifestImport           *pManifestImport=NULL;
    IAssemblyModuleImport             *pModImport = NULL;
    IAssemblyName                     *pName = NULL;
    CAssemblyCacheItem                *pAsmItem    = NULL;
    FILETIME                          ftLastModTime;
    BOOL                              bExists;

    if(!IsGACWritable())
    {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    /*
    if(!pRefData)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    */

    hr = ValidateOSInstallReference(pRefData);
    if (FAILED(hr))
        goto exit;
            
    hr = CheckFileExistence(pszManifestFilePath, &bExists);
    if (FAILED(hr)) {
        goto exit;
    }
    else if (!bExists) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto exit;
    }

    if(FAILED(hr = GetFileLastModified((LPWSTR) pszManifestFilePath, &ftLastModTime)))
        goto exit;

    szFullCodebase = NEW(WCHAR[MAX_URL_LENGTH*2+2]);
    if (!szFullCodebase)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    szFullManifestFilePath = szFullCodebase + MAX_URL_LENGTH +1;

    if (PathIsRelative(pszManifestFilePath) ||
            ((PathGetDriveNumber(pszManifestFilePath) == -1) && !PathIsUNC(pszManifestFilePath)))
    {
        // szPath is relative! Combine this with the CWD
        // Canonicalize codebase with CWD if needed.
        TCHAR szCurrentDir[MAX_PATH+1];

        if (!GetCurrentDirectory(MAX_PATH, szCurrentDir)) {
            hr = FusionpHresultFromLastError();
            goto exit;
        }

        if(szCurrentDir[lstrlenW(szCurrentDir)-1] != DIR_SEPARATOR_CHAR)
        {
            // Add trailing backslash
            hr = PathAddBackslashWrap(szCurrentDir, MAX_PATH);
            if (FAILED(hr)) {
                goto exit;
            }
        }

        dwLen = MAX_URL_LENGTH;
        hr = UrlCombineUnescape(szCurrentDir, pszManifestFilePath, szFullCodebase, &dwLen, 0);
        if (FAILED(hr)) {
            goto exit;
        }

        if(lstrlen(szCurrentDir) + lstrlen(pszManifestFilePath) > MAX_URL_LENGTH)
        {
            hr = E_FAIL;
            goto exit;
        }
        
        if(!PathCombine(szFullManifestFilePath, szCurrentDir, pszManifestFilePath))
        {
            hr = FUSION_E_INVALID_NAME;
            goto exit;
        }

    }
    else 
    {
        dwLen = MAX_URL_LENGTH;
        hr = UrlCanonicalizeUnescape(pszManifestFilePath, szFullCodebase, &dwLen, 0);
        if (FAILED(hr)) {
            goto exit;
        }

        StrCpy(szFullManifestFilePath, pszManifestFilePath);
    }

    if (FAILED(hr = CreateAssemblyManifestImport((LPTSTR)szFullManifestFilePath, &pManifestImport))) 
    {
        goto exit;
    }

    lstrcpyW(wzDir, szFullManifestFilePath);
    pwzTmp = PathFindFileName(wzDir);
    *pwzTmp = L'\0';


    // Create the assembly cache item.
    if (FAILED(hr = CAssemblyCacheItem::Create(NULL, NULL, (LPTSTR) szFullCodebase, 
        &ftLastModTime, ASM_CACHE_GAC, pManifestImport, NULL,
        (IAssemblyCacheItem**) &pAsmItem)))
        goto exit;    


    // Copy to cache.
    if (FAILED(hr = CopyAssemblyFile (pAsmItem, szFullManifestFilePath, 
        STREAM_FORMAT_MANIFEST)))
        goto exit;

    while (SUCCEEDED(hr = pManifestImport->GetNextAssemblyModule(dwIdx++, &pModImport))) 
    {
        dwLen = MAX_PATH;
        hr = pModImport->GetModuleName(wzModName, &dwLen);

        if (FAILED(hr))
        {
                goto exit;
        }

        wnsprintfW(wzModPath, MAX_PATH, L"%s%s", wzDir, wzModName);
        hr = CheckFileExistence(wzModPath, &bExists);
        if (FAILED(hr)) {
            goto exit;
        }
        else if (!bExists) {
            hr = FUSION_E_ASM_MODULE_MISSING;
            goto exit;
        }

        // Copy to cache.
        if (FAILED(hr = CopyAssemblyFile (pAsmItem, wzModPath, 0)))
            goto exit;

        SAFERELEASE(pModImport);
    }

    DWORD dwCommitFlags=0;

    // don't enforce this flag for now. i.e always replace bits.
    // if(dwFlags & IASSEMBLYCACHE_INSTALL_FLAG_REFRESH)
    {
        dwCommitFlags |= IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH; 
    }

    if(dwFlags & IASSEMBLYCACHE_INSTALL_FLAG_FORCE_REFRESH)
    {
        dwCommitFlags |= IASSEMBLYCACHEITEM_COMMIT_FLAG_FORCE_REFRESH; 
    }

    //  Do a force install. This will delete the existing entry(if any)
    if (FAILED(hr = pAsmItem->Commit(dwCommitFlags, NULL)))
    {
        goto exit;        
    }

    if(pRefData)
    {
        hr = GACAssemblyReference( szFullManifestFilePath, NULL, pRefData, TRUE);
    }

    CleanupTempDir(ASM_CACHE_GAC, NULL);

exit:

    SAFERELEASE(pAsmItem);
    SAFERELEASE(pModImport);
    SAFERELEASE(pManifestImport);
    SAFEDELETEARRAY(szFullCodebase);
    return hr;
}

STDMETHODIMP CAssemblyCache::UninstallAssembly(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszAssemblyName, 
        /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData, 
        /* [out, optional] */ ULONG *pulDisposition)
{
    HRESULT hr=S_OK;
    IAssemblyName *pName = NULL;
    CTransCache *pTransCache = NULL;
    CCache *pCache = NULL;
    DWORD   i=0;
    DWORD dwCacheFlags;
    BOOL bHasActiveRefs = FALSE;
    BOOL bRefNotFound = FALSE;

    if(!IsGACWritable())
    {
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    if(!pszAssemblyName)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // disallow uninstall of os assemblies
    if (pRefData && pRefData->guidScheme == FUSION_REFCOUNT_OSINSTALL_GUID)
    {
        hr = FUSION_E_UNINSTALL_DISALLOWED;
        goto exit;
    }

    if (FAILED(hr = CCache::Create(&pCache, NULL)))
        goto exit;

    if (FAILED(hr = CreateAssemblyNameObject(&pName, pszAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0)))
        goto exit;

    dwCacheFlags = CCache::IsCustom(pName) ? ASM_CACHE_ZAP : ASM_CACHE_GAC;

    hr = pCache->RetrieveTransCacheEntry(pName, dwCacheFlags, &pTransCache);

        if ((hr != S_OK) && (hr != DB_S_FOUND))
            goto exit;

    if(pRefData)
    {
        hr = GACAssemblyReference( pTransCache->_pInfo->pwzPath, NULL, pRefData, FALSE);
        if( (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )  
               || (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)) )
        {
            bRefNotFound = TRUE;
            goto exit;
        }
    }

    if(dwCacheFlags & ASM_CACHE_GAC)
    {
        if(FAILED(hr = ActiveRefsToAssembly( pName, &bHasActiveRefs)))
            goto  exit;

        if(bHasActiveRefs)
        {
            goto exit;
        }
    }

    hr = CScavenger::DeleteAssembly(pTransCache->GetCacheType(), NULL,
                                    pTransCache->_pInfo->pwzPath, FALSE);

    if(FAILED(hr))
        goto exit;

    if (SUCCEEDED(hr) && dwCacheFlags == ASM_CACHE_GAC) {
        // If we uninstalled a policy assembly, touch the last modified
        // time of the policy timestamp file.
        UpdatePublisherPolicyTimeStampFile(pName);
    }

    CleanupTempDir(pTransCache->GetCacheType(), NULL);

exit:

    if(pulDisposition)
    {
        *pulDisposition = 0;
        if(bRefNotFound)
        {
            *pulDisposition |= IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND;
            hr = S_FALSE;
        }
        else if(bHasActiveRefs)
        {
            *pulDisposition |= IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES;
            hr = S_FALSE;
        }
        else if(hr == S_OK)
        {
            *pulDisposition |= IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED;
        }
        else if(hr == S_FALSE)
        {
            *pulDisposition |= IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED;
        }
        else if(hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
        {
            *pulDisposition |= IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE;
        }
    }

    SAFERELEASE(pTransCache);
    SAFERELEASE(pCache);
    SAFERELEASE(pName);
    return hr;
}

STDMETHODIMP CAssemblyCache::QueryAssemblyInfo(
        /* [in] */ DWORD dwFlags,
        /* [in] */ LPCWSTR pszAssemblyName,
        /* [in, out] */ ASSEMBLY_INFO *pAsmInfo)
{
    HRESULT hr = S_OK;
    LPTSTR  pszPath=NULL;
    DWORD   cbPath=0;
    IAssemblyName *pName = NULL;
    CAssemblyName *pCName = NULL;
    ULARGE_INTEGER    uliExistingVersionNo;
    ULARGE_INTEGER    uliNewVersionNo;
    int                           iNewer;
    CTransCache           *pTransCache = NULL;
    CCache                   *pCache = NULL;
    DWORD                   dwSize = 0;
    BOOL                    bExists;

    if (FAILED(hr = CreateAssemblyNameObject(&pName, pszAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0))) {
        goto exit;
    }

    if (FAILED(hr = CCache::Create(&pCache, NULL))) {
        goto exit;
    }

    hr = pCache->RetrieveTransCacheEntry(pName, CCache::IsCustom(pName) ? ASM_CACHE_ZAP : ASM_CACHE_GAC, &pTransCache);
    if( (hr != S_OK) && (hr != DB_S_FOUND) ) {
        goto exit;
    }

    pszPath = pTransCache->_pInfo->pwzPath;
    pCName = static_cast<CAssemblyName*> (pName);

    hr = CheckFileExistence(pszPath, &bExists);
    if (FAILED(hr)) {
        goto exit;
    }
    else if (!bExists) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto exit;
    }

    // Check to see if FileVersion exists prior to doing comparison
    pName->GetProperty(ASM_NAME_FILE_MAJOR_VERSION, NULL, &dwSize);
    if(dwSize) {
        hr = FusionGetFileVersionInfo(pszPath, &uliExistingVersionNo);
        if(hr != S_OK) {
            goto exit;
        }
        
        hr = pCName->GetFileVersion(&uliNewVersionNo.HighPart , &uliNewVersionNo.LowPart );
        if(hr != S_OK) {
            goto exit;
        }

        if(CompareFileVersion( uliNewVersionNo, uliExistingVersionNo, &iNewer)) {
            // new bits have higher version #, so retrun not found, to replace the old bits
            hr = S_FALSE; // DB_S_NOTFOUND.
            goto exit;
        }
    }

    // Check Asm hash
    if ( dwFlags & QUERYASMINFO_FLAG_VALIDATE) {
        hr = ValidateAssembly(pszPath, pName);
    }

    if(pAsmInfo && SUCCEEDED(hr))
    {
        LPWSTR szPath = pAsmInfo->pszCurrentAssemblyPathBuf;

       // if requested return the assembly path in cache.
        cbPath = lstrlen(pszPath);

        if(szPath && (pAsmInfo->cchBuf > cbPath)) {
                StrCpy(szPath, pszPath );
        }
        else {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }

        pAsmInfo->cchBuf =  cbPath+1;
        pAsmInfo->dwAssemblyFlags = ASSEMBLYINFO_FLAG_INSTALLED;

        if(dwFlags & QUERYASMINFO_FLAG_GETSIZE)
        {
            hr = GetAssemblyKBSize(pTransCache->_pInfo->pwzPath, &(pTransCache->_pInfo->dwKBSize), NULL, NULL);
            pAsmInfo->uliAssemblySizeInKB.QuadPart = pTransCache->_pInfo->dwKBSize;
        }
    }

exit:

    if (hr == DB_S_NOTFOUND) {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if(hr == DB_S_FOUND) {
        hr = S_OK;
    }

    SAFERELEASE(pTransCache);
    SAFERELEASE(pCache);
    SAFERELEASE(pName);
    
    return hr;
}

STDMETHODIMP   CAssemblyCache::CreateAssemblyCacheItem(
        /* [in] */ DWORD dwFlags,
        /* [in] */ PVOID pvReserved,
        /* [out] */ IAssemblyCacheItem **ppAsmItem,
        /* [in, optional] */ LPCWSTR pszAssemblyName)  // uncanonicalized, comma separted name=value pairs.
{

    if(!ppAsmItem)
        return E_INVALIDARG;

    return CAssemblyCacheItem::Create(NULL, NULL, NULL, NULL, ASM_CACHE_GAC, NULL, pszAssemblyName, ppAsmItem);

}


STDMETHODIMP  CAssemblyCache::CreateAssemblyScavenger(
        /* [out] */ IUnknown **ppAsmScavenger )
{

    if(!ppAsmScavenger)
        return E_INVALIDARG;

    return CreateScavenger( ppAsmScavenger );
}

//
// IUnknown boilerplate...
//

STDMETHODIMP
CAssemblyCache::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyCache)
       )
    {
        *ppvObj = static_cast<IAssemblyCache*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
CAssemblyCache::AddRef()
{
    return InterlockedIncrement (&_cRef);
}

STDMETHODIMP_(ULONG)
CAssemblyCache::Release()
{
    ULONG lRet = InterlockedDecrement (&_cRef);
    if (!lRet)
        delete this;
    return lRet;
}


STDAPI CreateAssemblyCache(IAssemblyCache **ppAsmCache,
                           DWORD dwReserved)
{
    HRESULT                       hr = S_OK;

    if (!ppAsmCache) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *ppAsmCache = NEW(CAssemblyCache);

    if (!ppAsmCache) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\cache.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "cache.h"
#include "naming.h"
#include "asmstrm.h"
#include "util.h"
#include "helpers.h"
#include "transprt.h"


HRESULT VerifySignatureHelper(CTransCache *pTC, DWORD dwVerifyFlags);

// ---------------------------------------------------------------------------
// CCache  ctor
// ---------------------------------------------------------------------------
CCache::CCache(IApplicationContext *pAppCtx)
: _cRef(1)
{
    DWORD ccCachePath = 0;

    _hr = S_OK;
    
    _dwSig = 'HCAC';

    // Store the custom cache path
    _wzCachePath[0] = L'\0';
    if (pAppCtx)
    {
        _hr = pAppCtx->GetAppCacheDirectory(NULL, &ccCachePath);
        
        if (_hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
        {
            // Path not found, but it's ok
            _hr = S_OK;
        }
        else
        {
            if (ccCachePath && ccCachePath <= MAX_PATH)
            {
                _hr = pAppCtx->GetAppCacheDirectory(_wzCachePath, &ccCachePath);
            }
            else
            {
                // Else path too long
                _hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
            }
        }
    }
}

// ---------------------------------------------------------------------------
// CCache  dtor
// ---------------------------------------------------------------------------
CCache::~CCache()
{

}

STDMETHODIMP_(ULONG) CCache::AddRef()
{
    return InterlockedIncrement (&_cRef);
}

STDMETHODIMP_(ULONG) CCache::Release()
{
    ULONG lRet = InterlockedDecrement (&_cRef);
    if (!lRet)
        delete this;
    return lRet;
}

HRESULT CCache::QueryInterface(REFIID iid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    // Does not actually implement any interface at all

    return hr;
}    

// ---------------------------------------------------------------------------
// CCache::Create
//---------------------------------------------------------------------------
HRESULT CCache::Create(CCache **ppCache, IApplicationContext *pAppCtx)
{
    HRESULT hr=S_OK;
    CCache *pCache = NULL;
    DWORD   cb = 0;

    // Check to see if an instance of CCache is in pAppCtx.
    // Assume, if it is present, it means if a custom path is
    // also present, that the CCache pointer points to a
    // CCache with the custom path as specified by
    // ACTAG_APP_CUSTOM_CACHE_PATH in pAppCtx.
    // (assumes the custom cache path cannot be not modified)

    if (pAppCtx)
    {
        cb = sizeof(void*);
        hr = pAppCtx->Get(ACTAG_APP_CACHE, (void*)&pCache, &cb, APP_CTX_FLAGS_INTERFACE);
        if (hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
        {
            if (SUCCEEDED(hr))
            {
                *ppCache = pCache;
                (*ppCache)->AddRef();

                //Already AddRef-ed in pAppCtx->Get()
            }
            goto exit;
        }
    }

    // Not found, create a new CCache
    pCache = NEW(CCache(pAppCtx));
    if (!pCache)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pCache->_hr;
    if (SUCCEEDED(hr))
    {
        *ppCache = pCache;
        (*ppCache)->AddRef();
    }
    else
    {
        goto exit;
    }

    if (pAppCtx)
    {
        // Set the new CCache to the AppCtx
        hr = pAppCtx->Set(ACTAG_APP_CACHE, (void*)pCache, sizeof(void*), APP_CTX_FLAGS_INTERFACE);
    }

exit:
    SAFERELEASE(pCache);

    return hr;
}

// ---------------------------------------------------------------------------
// CCache::GetCustomPath
//---------------------------------------------------------------------------

LPCWSTR CCache::GetCustomPath()
{
    // Return custom cache path if present
    return (_wzCachePath[0] != L'\0') ? _wzCachePath : NULL;
}


//------------------- Transport Cache APIs ------------------------------------


// ---------------------------------------------------------------------------
// CCache::InsertTransCacheEntry
//---------------------------------------------------------------------------
HRESULT CCache::InsertTransCacheEntry(IAssemblyName *pName,
    LPTSTR szPath, DWORD dwKBSize, DWORD dwFlags,
    DWORD dwCommitFlags, DWORD dwPinBits, CTransCache **ppTransCache)
{
    HRESULT hr;
    DWORD cb, dwCacheId;
    TRANSCACHEINFO *pTCInfo = NULL;
    CTransCache *pTransCache = NULL;
    LPWSTR pwzCodebaseUrl = NULL;
    WCHAR pwzCanonicalized[MAX_URL_LENGTH];
    
    
    // Determine which cache index to insert to.
    if (FAILED(hr = ResolveCacheIndex(pName, dwFlags, &dwCacheId)))
        goto exit;

    // Construct new CTransCache object.
    if(FAILED(hr = CreateTransCacheEntry(dwCacheId, &pTransCache)))
        goto exit;
    

    // Cast pTransCache base info ptr to TRANSCACHEINFO ptr
    pTCInfo = (TRANSCACHEINFO*) pTransCache->_pInfo;
    
    // Downcased text name from target
    if (FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_NAME,
            (LPBYTE*) &pTCInfo->pwzName, &(cb = 0))) 
    
        // Version
        || FAILED(hr = pName->GetVersion(&pTCInfo->dwVerHigh, &pTCInfo->dwVerLow))

        // Culture (downcased)
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CULTURE,
            (LPBYTE*) &pTCInfo->pwzCulture, &cb))
            || (pTCInfo->pwzCulture && !_wcslwr(pTCInfo->pwzCulture))

        // PublicKeyToken
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_PUBLIC_KEY_TOKEN, 
            &pTCInfo->blobPKT.pBlobData, &pTCInfo->blobPKT.cbSize))

        // Custom
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CUSTOM, 
            &pTCInfo->blobCustom.pBlobData, &pTCInfo->blobCustom.cbSize))

        // Signature Blob
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_SIGNATURE_BLOB,
            &pTCInfo->blobSignature.pBlobData, &pTCInfo->blobSignature.cbSize))

        // MVID
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_MVID,
            &pTCInfo->blobMVID.pBlobData, &pTCInfo->blobMVID.cbSize))
    
        // Codebase url if any from target
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CODEBASE_URL, 
            (LPBYTE*)&pwzCodebaseUrl, &(cb = 0)))

        // Codebase last modified time if any from target.
        || FAILED(hr = pName->GetProperty(ASM_NAME_CODEBASE_LASTMOD,
            &pTCInfo->ftLastModified, &(cb = sizeof(FILETIME))))

        // PK if any from source.
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_PUBLIC_KEY, 
            &pTCInfo->blobPK.pBlobData, &pTCInfo->blobPK.cbSize))

        // OSINFO array from source
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_OSINFO_ARRAY, 
            &pTCInfo->blobOSInfo.pBlobData, &pTCInfo->blobOSInfo.cbSize))

        // CPUID array from source.
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_PROCESSOR_ID_ARRAY, 
            &pTCInfo->blobCPUID.pBlobData, &pTCInfo->blobCPUID.cbSize)))

    {
        goto exit;
    }

    if (pwzCodebaseUrl)
    {
        cb = MAX_URL_LENGTH;
        hr = UrlCanonicalizeUnescape(pwzCodebaseUrl, pwzCanonicalized, &cb, 0);
        if (FAILED(hr)) {
            goto exit;
        }

        pTCInfo->pwzCodebaseURL = WSTRDupDynamic(pwzCanonicalized);
        if (!pTCInfo->pwzCodebaseURL) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }
    else
    {
        pTCInfo->pwzCodebaseURL = NULL;
    }

    // Copy in path.
    if (!(pTCInfo->pwzPath = TSTRDupDynamic(szPath)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // File size
    pTCInfo->dwKBSize = dwKBSize;

    // Set pin Bits
    pTCInfo->dwPinBits = dwPinBits;        
             
exit:
    SAFEDELETEARRAY(pwzCodebaseUrl);

    // Base destructor takes care
    // of everything.
    if (!ppTransCache 
        || (FAILED(hr) && (hr != DB_E_DUPLICATE)))    
    {
        SAFERELEASE(pTransCache);
    }
    else 
    {
        *ppTransCache = pTransCache;
    }
    return hr;
}


// ---------------------------------------------------------------------------
// CCache::RetrievTransCacheEntry
// Retrieves transport entry from transport cache
//---------------------------------------------------------------------------
HRESULT CCache::RetrieveTransCacheEntry(IAssemblyName *pName,
    DWORD dwFlags, CTransCache **ppTransCache)
{
    HRESULT hr;
    DWORD dwCmpMask = 0;
    DWORD dwVerifyFlags;
    CTransCache *pTransCache = NULL;
    CTransCache *pTransCacheMax = NULL;

    if ((dwFlags & ASM_CACHE_GAC) || (dwFlags & ASM_CACHE_ZAP)) {
        dwVerifyFlags = SN_INFLAG_ADMIN_ACCESS;
    }
    else {
        ASSERT(dwFlags & ASM_CACHE_DOWNLOAD);
        dwVerifyFlags = SN_INFLAG_USER_ACCESS;
    }
    
    // Fully specified - direct lookup.
    // Partial - enum global cache only.

    // If fully specified, do direct lookup.
    if (!(CAssemblyName::IsPartial(pName, &dwCmpMask)))
    {    
        // Create a transcache entry from name.
        if (FAILED(hr = TransCacheEntryFromName(pName, dwFlags, &pTransCache)))
            goto exit;
    
        // Retrieve this record from the database.
        if (FAILED(hr = pTransCache->Retrieve()))
            goto exit;

    }
    // Ref is partial - enum global cache.
    else
    {
        // Should only be in here if enumerating global cache or retrieving custom assembly.
        ASSERT ((dwFlags & ASM_CACHE_GAC) ||  (dwFlags & ASM_CACHE_ZAP)
            || (dwCmpMask & ASM_CMPF_CUSTOM));
                
        // Create a transcache entry from name.
        if (FAILED(hr = TransCacheEntryFromName(pName, dwFlags, &pTransCache)))
            goto exit;

        // Retrieve the max entry.
        if (FAILED(hr = pTransCache->Retrieve(&pTransCacheMax, dwCmpMask)))
            goto exit;            
    }
    
    // If the assembly was comitted as delay-signed, re-verify.
    CTransCache *pTC;
    pTC = pTransCacheMax ? pTransCacheMax : pTransCache;
    if (pTC && (pTC->_pInfo->dwType & ASM_DELAY_SIGNED))
    {
        hr = VerifySignatureHelper(pTC, dwVerifyFlags);
    }

exit:

    // Failure.
    if (FAILED(hr) || (hr == DB_S_NOTFOUND))    
    {
        SAFERELEASE(pTransCache);
        SAFERELEASE(pTransCacheMax);
    }
    // Success.
    else
    {
        if (pTransCacheMax)
        {
            *ppTransCache = pTransCacheMax;
            SAFERELEASE(pTransCache);
        }
        else
        {
            *ppTransCache = pTransCache;
        }
    }
    
    return hr;    
}

// ---------------------------------------------------------------------------
// CCache::IsStronglyNamed
//---------------------------------------------------------------------------
BOOL CCache::IsStronglyNamed(IAssemblyName *pName)
{
    DWORD   cb, dw;
    HRESULT hr;
    BOOL   fRet = FALSE;

    hr = pName->GetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, &(dw = 0), &(cb = 0));    
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        fRet = TRUE;

    return fRet;
}    

// ---------------------------------------------------------------------------
// CCache::IsCustom
// Tests for custom data set (ref or def case) OR custom
// data specifically wildcarded (ref case only), so semantics
// is slightly different from IsStronglyNamed.
//---------------------------------------------------------------------------
BOOL CCache::IsCustom(IAssemblyName *pName)
{
    DWORD   cb;
    HRESULT hr;
    DWORD dwCmpMask = 0;
    BOOL   fRet = FALSE;
    
    hr = pName->GetProperty(ASM_NAME_CUSTOM, NULL, &(cb = 0));    
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
        || (CAssemblyName::IsPartial(pName, &dwCmpMask) 
            && !(dwCmpMask & ASM_CMPF_CUSTOM)))
    {
        fRet = TRUE;
    }
    return fRet;
}    


// ---------------------------------------------------------------------------
// CCache::GetGlobalMax
//---------------------------------------------------------------------------
HRESULT CCache::GetGlobalMax(IAssemblyName *pName, 
    IAssemblyName **ppNameGlobal, CTransCache **ppTransCache)
{
    HRESULT         hr = NOERROR;
    DWORD           dwCmpMask = 0;
    BOOL            fIsPartial = FALSE;
    CTransCache    *pTransCache = NULL, *pTransCacheMax = NULL;
    IAssemblyName  *pNameGlobal = NULL;
    CCache         *pCache = NULL;

    if (FAILED(hr = Create(&pCache, NULL)))
        goto exit;
        
    // Create query trans cache object.
    if (FAILED(hr = pCache->TransCacheEntryFromName(
        pName, ASM_CACHE_GAC, &pTransCache)))
        goto exit;

    // For both full and partially specified, mask off version.
    fIsPartial = CAssemblyName::IsPartial(pName, &dwCmpMask);
    if (!fIsPartial)
        dwCmpMask = ASM_CMPF_NAME | ASM_CMPF_CULTURE | ASM_CMPF_PUBLIC_KEY_TOKEN | ASM_CMPF_CUSTOM;
    else            
        dwCmpMask &= ~(ASM_CMPF_MAJOR_VERSION | ASM_CMPF_MINOR_VERSION | ASM_CMPF_REVISION_NUMBER | ASM_CMPF_BUILD_NUMBER);

    // Retrieve the max entry.
    if (FAILED(hr = pTransCache->Retrieve(&pTransCacheMax, dwCmpMask)))
        goto exit;            

    // Found a match.
    if (hr == DB_S_FOUND)
    {
        // If version matches or exceeds, return.
        if (pTransCacheMax->GetVersion() 
            >= CAssemblyName::GetVersion(pName))
        {
            hr = S_OK;
            if (FAILED(hr = CCache::NameFromTransCacheEntry(
                pTransCacheMax, &pNameGlobal)))
                goto exit;
        }
        else
        {
            hr = S_FALSE;
        }
    }

exit:

    if (hr == S_OK)
    {
        *ppTransCache = pTransCacheMax;
        *ppNameGlobal = pNameGlobal;
    }
    else
    {
        SAFERELEASE(pTransCacheMax);
        SAFERELEASE(pNameGlobal);
    }

    SAFERELEASE(pTransCache);
    SAFERELEASE(pCache);

    return hr;
}


//------------------- Cache Utility APIs -------------------------------------


// ---------------------------------------------------------------------------
// CCache::TransCacheEntryFromName
// create transport entry from name
//---------------------------------------------------------------------------
HRESULT CCache::TransCacheEntryFromName(IAssemblyName *pName, 
    DWORD dwFlags, CTransCache **ppTransCache)
{    
    HRESULT hr;
    DWORD cb, dwCacheId = 0;
    TRANSCACHEINFO *pTCInfo = 0;
    CTransCache *pTransCache = NULL;
            
    // Get the correct cache index.
    if(FAILED(hr = ResolveCacheIndex(pName, dwFlags, &dwCacheId)))
        goto exit;

    // Construct new CTransCache object.
    if(FAILED(hr = CreateTransCacheEntry(dwCacheId, &pTransCache)))
        goto exit;

    // Cast base info ptr to TRANSCACHEINFO ptr
    pTCInfo = (TRANSCACHEINFO*) pTransCache->_pInfo;
        
    // Downcased text name from target
    if (FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_NAME,
            (LPBYTE*) &pTCInfo->pwzName, &(cb = 0)))
    
        // Version
        || FAILED(hr = pName->GetVersion(&pTCInfo->dwVerHigh, &pTCInfo->dwVerLow))

        // Culture
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CULTURE,
            (LPBYTE*) &pTCInfo->pwzCulture, &cb))
                || (pTCInfo->pwzCulture && !_wcslwr(pTCInfo->pwzCulture))

        // PublicKeyToken
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_PUBLIC_KEY_TOKEN, 
            &pTCInfo->blobPKT.pBlobData, &pTCInfo->blobPKT.cbSize))

        // Custom
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CUSTOM, 
            &pTCInfo->blobCustom.pBlobData, &pTCInfo->blobCustom.cbSize))

        // Signature Blob
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_SIGNATURE_BLOB,
            &pTCInfo->blobSignature.pBlobData, &pTCInfo->blobSignature.cbSize))

        // MVID
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_MVID,
            &pTCInfo->blobMVID.pBlobData, &pTCInfo->blobMVID.cbSize))

        // Codebase url if any from target
        || FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CODEBASE_URL, 
            (LPBYTE*) &pTCInfo->pwzCodebaseURL, &(cb = 0)))

        || FAILED(hr = pName->GetProperty(ASM_NAME_CODEBASE_LASTMOD,
            &pTCInfo->ftLastModified, &(cb = sizeof(FILETIME)))))

    {
        goto exit;
    }


    if(pTCInfo->pwzName && (lstrlen(pTCInfo->pwzName) >= MAX_PATH) )
        hr = FUSION_E_INVALID_NAME;  // name is too long; this is an error.

exit:
    if (SUCCEEDED(hr))
    {
        *ppTransCache = pTransCache;
    }
    else
    {
        SAFERELEASE(pTransCache);
    }
    return hr;
}


// ---------------------------------------------------------------------------
// CCache::NameFromTransCacheEntry
// convert target assembly name from name res entry
//---------------------------------------------------------------------------
HRESULT CCache::NameFromTransCacheEntry(
    CTransCache         *pTransCache,   
    IAssemblyName      **ppName
)
{
    HRESULT hr;
    WORD wVerMajor, wVerMinor, wRevNo, wBldNo;
    TRANSCACHEINFO *pTCInfo = NULL;

    LPBYTE pbPublicKeyToken, pbCustom, pbSignature, pbMVID, pbProcessor;
    DWORD  cbPublicKeyToken, cbCustom, cbSignature, cbMVID, cbProcessor;

    // IAssemblyName target to be returned.
    IAssemblyName *pNameFinal = NULL;
    
    pTCInfo = (TRANSCACHEINFO*) pTransCache->_pInfo;

    // Mask target major, minor versions and rev#, build#
    wVerMajor = HIWORD(pTCInfo->dwVerHigh);
    wVerMinor = LOWORD(pTCInfo->dwVerHigh);
    wBldNo    = HIWORD(pTCInfo->dwVerLow);
    wRevNo    = LOWORD(pTCInfo->dwVerLow);

    // Currently this function is only called during enuming
    // the global cache so we expect an PublicKeyToken to be present.
    // BUT THIS IS NO LONGER TRUE - THE TRANSPORT CACHE CAN BE
    // INDEPENDENTLY ENUMERATED BUT AM LEAVING IN ASSERT AS COMMENT.
    // ASSERT(pTCInfo->blobPKT.cbSize);
    
    pbPublicKeyToken = pTCInfo->blobPKT.pBlobData;
    cbPublicKeyToken = pTCInfo->blobPKT.cbSize;

    pbCustom = pTCInfo->blobCustom.pBlobData;
    cbCustom = pTCInfo->blobCustom.cbSize;

    pbSignature = pTCInfo->blobSignature.pBlobData;
    cbSignature = pTCInfo->blobSignature.cbSize;

    pbMVID = pTCInfo->blobMVID.pBlobData;
    cbMVID = pTCInfo->blobMVID.cbSize;

    pbProcessor = pTCInfo->blobCPUID.pBlobData;
    cbProcessor = pTCInfo->blobCPUID.cbSize;

    // Create final name on text name and set properties.
    if (FAILED(hr = CreateAssemblyNameObject(&pNameFinal, pTCInfo->pwzName, NULL, 0)))
        goto exit;

    if(FAILED(hr = pNameFinal->SetProperty(cbPublicKeyToken ? 
        ASM_NAME_PUBLIC_KEY_TOKEN : ASM_NAME_NULL_PUBLIC_KEY_TOKEN,
        pbPublicKeyToken, cbPublicKeyToken)))
        goto exit;

    if(FAILED(hr = pNameFinal->SetProperty(ASM_NAME_MAJOR_VERSION, 
             &wVerMajor, sizeof(WORD))))
        goto exit;

    if(FAILED(hr = pNameFinal->SetProperty(ASM_NAME_MINOR_VERSION, 
             &wVerMinor, sizeof(WORD))))
        goto exit;

        // Build no.
    if(FAILED(hr = pNameFinal->SetProperty(ASM_NAME_BUILD_NUMBER, 
             &wBldNo, sizeof(WORD))))
        goto exit;

        // Revision no.
    if(FAILED(hr = pNameFinal->SetProperty(ASM_NAME_REVISION_NUMBER,
             &wRevNo, sizeof(WORD))))
        goto exit;

        // Culture
    if(pTCInfo->pwzCulture)
    {
        if(FAILED(hr = pNameFinal->SetProperty(ASM_NAME_CULTURE,
            pTCInfo->pwzCulture, (lstrlen(pTCInfo->pwzCulture) +1) * sizeof(TCHAR))))
            goto exit;
    }
        // Processor

    if(pbProcessor)
    {
        if(FAILED(hr = pNameFinal->SetProperty(ASM_NAME_PROCESSOR_ID_ARRAY,
            pbProcessor, cbProcessor)))
            goto exit;
    }

        // Custom
    if(pbCustom)
    {
        if(FAILED(hr = pNameFinal->SetProperty(cbCustom ? 
            ASM_NAME_CUSTOM : ASM_NAME_NULL_CUSTOM, pbCustom, cbCustom)))
            goto exit;
    }

    if(pbSignature)
    {
        // Signature blob
        if(FAILED(hr = pNameFinal->SetProperty(ASM_NAME_SIGNATURE_BLOB, pbSignature, cbSignature)))
            goto exit;
    }

    if(pbMVID)
    {
        // MVID
        if(FAILED(hr = pNameFinal->SetProperty(ASM_NAME_MVID, pbMVID, cbMVID)))
            goto exit;
    }

    if(pTCInfo->pwzCodebaseURL)
    {
        // Codebase url
        if(FAILED(hr = pNameFinal->SetProperty(ASM_NAME_CODEBASE_URL,
             pTCInfo->pwzCodebaseURL, pTCInfo->pwzCodebaseURL ? 
                (lstrlen(pTCInfo->pwzCodebaseURL) +1) * sizeof(TCHAR) : 0)))
            goto exit;
    }

    // Codebase url last modified filetime
    if(FAILED(hr = pNameFinal->SetProperty(ASM_NAME_CODEBASE_LASTMOD,
             &pTCInfo->ftLastModified, sizeof(FILETIME))))
        goto exit;

    // We're done and can hand out the target name.
    hr = S_OK;       

exit:
    if (SUCCEEDED(hr))
    {
        *ppName = pNameFinal;
    }
    else
    {
        SAFERELEASE(pNameFinal);
    }
    return hr;
}


// ---------------------------------------------------------------------------
// CCache::ResolveCacheIndex
//---------------------------------------------------------------------------
HRESULT CCache::ResolveCacheIndex(IAssemblyName *pName, 
    DWORD dwFlags, LPDWORD pdwCacheId)
{
    HRESULT hr = S_OK;
    DWORD   dwCmpMask = 0;
    BOOL    fIsPartial = FALSE;
    
    // Resolve index from flag and name.    
    if(dwFlags & ASM_CACHE_DOWNLOAD)
    {
        *pdwCacheId = TRANSPORT_CACHE_SIMPLENAME_IDX;
    }
    else if (dwFlags & ASM_CACHE_GAC)
    {
        fIsPartial = CAssemblyName::IsPartial(pName, &dwCmpMask);


        // Name can be strongly named, or indeterminate ref or custom.
        if (! (IsStronglyNamed(pName) || (fIsPartial && !(dwCmpMask & ASM_CMPF_PUBLIC_KEY_TOKEN))) )
        {
            hr = FUSION_E_PRIVATE_ASM_DISALLOWED;
            goto exit;
        }
        *pdwCacheId = TRANSPORT_CACHE_GLOBAL_IDX;
    }
    else if (dwFlags & ASM_CACHE_ZAP)
    {
        fIsPartial = CAssemblyName::IsPartial(pName, &dwCmpMask);


        // Name  has to be custom, but will not be available in Enum
        /*
        if (!IsCustom(pName)
        {
            hr = FUSION_E_ASSEMBLY_IS_NOT_ZAP;
            goto exit;
        }
        */

        *pdwCacheId = TRANSPORT_CACHE_ZAP_IDX;
    }
    // Raw index passed in which is mirrored back.
    else
    {
        *pdwCacheId = dwFlags;
        hr = E_INVALIDARG;
    }        

exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CCache::CreateTransCacheEntry
//---------------------------------------------------------------------------
HRESULT CCache::CreateTransCacheEntry(DWORD dwCacheId, CTransCache **ppTransCache)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = CTransCache::Create(ppTransCache, dwCacheId, this)))
        goto exit;

exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\asmenum.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "debmacro.h"
#include "asmenum.h"
#include "naming.h"
#include <shlwapi.h>

#include <util.h> // STRDUP 
#include <fusionp.h> // STRDUP 

extern DWORD g_dwRegenEnabled;

FusionTag(TagEnum, "Fusion", "Enum");


// ---------------------------------------------------------------------------
// CreateAssemblyEnum
// ---------------------------------------------------------------------------
STDAPI CreateAssemblyEnum(IAssemblyEnum** ppEnum, IUnknown *pUnkAppCtx,
    IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved)    
{
    HRESULT                          hr = S_OK;
    IApplicationContext             *pAppCtx = NULL;

    if (pUnkAppCtx) {
        hr = pUnkAppCtx->QueryInterface(IID_IApplicationContext, (void **)&pAppCtx);
        if (FAILED(hr)) {
            goto exit;
        }
    }

    CAssemblyEnum *pEnum = NEW(CAssemblyEnum);
    if (!pEnum)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (FAILED(hr = pEnum->Init(pAppCtx, pName, dwFlags)))
    {
        SAFERELEASE(pEnum);
        goto exit;
    }

    *ppEnum = (IAssemblyEnum*) pEnum;

exit:
    SAFERELEASE(pAppCtx);

    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyEnum ctor
// ---------------------------------------------------------------------------
CAssemblyEnum::CAssemblyEnum()
{
    _dwSig = 'MUNE';
    _cRef = 0;
    _pCache      = NULL;
    _pTransCache = NULL;
    _pEnumR      = NULL;
}


// ---------------------------------------------------------------------------
// CAssemblyEnum dtor
// ---------------------------------------------------------------------------
CAssemblyEnum::~CAssemblyEnum()
{
    SAFERELEASE(_pTransCache);
    SAFERELEASE(_pCache);
    SAFEDELETE (_pEnumR);
}


// ---------------------------------------------------------------------------
// CAssemblyEnum::Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyEnum::Init(IApplicationContext *pAppCtx, IAssemblyName *pName, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    DWORD dwCmpMask = 0, dwQueryMask = 0, cb = 0;
    BOOL fIsPartial = FALSE;
    LPWSTR      pszTextName=NULL;
    DWORD       cbTextName=0;

    // If no name is passed in, create a default (blank) copy.
    if (!pName)
    { 
        if (FAILED(hr = CreateAssemblyNameObject(&pName, NULL, NULL, NULL)))
            goto exit;            
    }
    else
        pName->AddRef();

    if (FAILED(hr = CCache::Create(&_pCache, pAppCtx)))
        goto exit;

        
    // Create a transcache entry from the name.
    if (FAILED(hr = _pCache->TransCacheEntryFromName(pName, dwFlags, &_pTransCache)))
        goto exit;

    // Get the name comparison mask.
    fIsPartial = CAssemblyName::IsPartial(pName, &dwCmpMask);    

    // Convert to query mask.
    dwQueryMask = _pTransCache->MapNameMaskToCacheMask(dwCmpMask);

        // Allocate an enumerator.
    _pEnumR = NEW(CEnumCache(FALSE, NULL));
    if (!_pEnumR)
    {
            hr = E_OUTOFMEMORY;
            goto exit;
    }
        
        // Initialize the enumerator on the transcache entry.
    if (FAILED(hr = _pEnumR->Init(_pTransCache,  dwQueryMask)))
        goto exit;
         
        
exit:
    if (hr == DB_S_NOTFOUND) {
        hr = S_FALSE;
        SAFEDELETE(_pEnumR);
    }

    _cRef = 1;
    SAFEDELETE(pszTextName);
    SAFERELEASE(pName);
    return hr;
}


// ---------------------------------------------------------------------------
// CAssemblyEnum::GetNextAssembly
// ---------------------------------------------------------------------------
STDMETHODIMP 
CAssemblyEnum::GetNextAssembly(LPVOID pvReserved,
    IAssemblyName** ppName, DWORD dwFlags)
{
    HRESULT              hr      = S_OK;
    CTransCache         *pTC     = NULL;
    IAssemblyName       *pName   = NULL;
    IApplicationContext *pAppCtx = NULL;

    if (!_pEnumR) {
        return S_FALSE;
    }
    
    // If enumerating transport cache.
    if (_pTransCache)
    {
        // Create a transcache entry for output.
        if (FAILED(hr = _pCache->CreateTransCacheEntry(_pTransCache->_dwTableID, &pTC)))
            goto exit;

        // Enumerate next entry.
        if (FAILED(hr = _pEnumR->GetNextRecord(pTC)))
            goto exit;
        
        // No more items.
        if (hr == S_FALSE)
            goto exit;

        // Construct IAssemblyName from enumed transcache entry.
        if (FAILED(hr = CCache::NameFromTransCacheEntry(pTC, &pName)))
            goto exit;

    }
    // Otherwise some error in constructing this CAssemblyEnum.
    else
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    
exit:

    // Enumeration step successful.
    if (SUCCEEDED(hr) && (hr != S_FALSE))
    {        
        // Always hand just name for transcache.
        *ppName = pName;        
    }
    // Otherwise rror encountered.
    else
    {            
        SAFERELEASE(pName);
        SAFERELEASE(pAppCtx);
    }
    
    // Always release intermediates.
    SAFERELEASE(pTC);

    return hr;
}


// ---------------------------------------------------------------------------
// CAssemblyEnum::Reset
// ---------------------------------------------------------------------------
STDMETHODIMP 
CAssemblyEnum::Reset(void)
{
    return E_NOTIMPL;
}

// ---------------------------------------------------------------------------
// CAssemblyEnum::Clone
// ---------------------------------------------------------------------------
STDMETHODIMP 
CAssemblyEnum::Clone(IAssemblyEnum** ppEnum)
{
    return E_NOTIMPL;
}

// IUnknown Boilerplate

// ---------------------------------------------------------------------------
// CAssemblyEnum::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyEnum::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyEnum)
       )
    {
        *ppvObj = static_cast<IAssemblyEnum*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// ---------------------------------------------------------------------------
// CAssemblyEnum::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyEnum::AddRef()
{
    return InterlockedIncrement (&_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyEnum::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyEnum::Release()
{
    ULONG lRet = InterlockedDecrement (&_cRef);
    if (!lRet)
        delete this;
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\asmstrm.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "asmstrm.h"
#include "debmacro.h"
#include "asmimprt.h"
#include "disk.h"
#include "naming.h"
#include "policy.h"
#include "helpers.h"
#include <winver.h>
#include "fusionheap.h"
#include "lock.h"

extern CRITICAL_SECTION g_csInitClb;
BOOL    g_bInitedWindowsDir = FALSE;
WCHAR   g_wszRealWindowsDirectory[MAX_PATH];

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))
#endif

// Cache the provider so we can avoid repetive calls to CryptAcquireContext
// and CryptReleaseContext. Calling these crypto APIs repetively (~10K times)
// will result in failure and "out of memory" messages on Win9x systems.
// The real problem is CryptAcquireContext/CryptReleaseContext load and
// unload the CSP DLLs, and repetive loading/unloading of rsabase.dll and
// rsaenh.dll expose this problem. We will work-around this by caching the
// context, but cannot clean it up at DLL_PROCESS_DETACH time since this
// will result in a FreeLibrary (which you can't do at that time).

HCRYPTPROV g_hProv = 0;

CAssemblyStream::CAssemblyStream (CAssemblyCacheItem* pParent)
{
    // We keep a refcount on the containing assembly cache item to
    // ensure that any error results in a rollback after all file
    // handles have been closed.
    _dwSig = 'SMSA';
    _cRef = 1;
    _hf = INVALID_HANDLE_VALUE;
    *_szPath = TEXT('\0');
    _dwFormat = 0;
    _pParent = pParent;
    _pParent->AddRef();
    _hHash = NULL;

}

HRESULT CAssemblyStream::Init (LPOLESTR pszPath, DWORD dwFormat)
{
    HRESULT                            hr = S_OK;
    DWORD                              cwPath;
    BOOL                               bRet;
    CCriticalSection                   cs(&g_csInitClb);

    ASSERT(pszPath);

    _dwFormat = dwFormat;
    cwPath = lstrlen(pszPath) + 1;

    ASSERT(cwPath < MAX_PATH);
    memcpy(_szPath, pszPath, sizeof(TCHAR) * cwPath);

    _hf = CreateFile(pszPath, GENERIC_WRITE, 0 /* no sharing */,
                     NULL, CREATE_NEW, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (_hf == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ReleaseParent(hr);
        goto Exit;
    }

    if (!g_hProv) {

        hr = cs.Lock();
        if (FAILED(hr)) {
            goto Exit;
        }

        bRet=TRUE;
        if(!g_hProv)
        {
            bRet = CryptAcquireContextA(&g_hProv, NULL, NULL, PROV_RSA_FULL,
                                    CRYPT_VERIFYCONTEXT);
        }

        cs.Unlock();

        if (!bRet) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ReleaseParent(hr);
            goto Exit;
        }
    }

    bRet = CryptCreateHash(g_hProv, CALG_SHA1, 0, 0, &_hHash);
    if (!bRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ReleaseParent(hr);
        goto Exit;
    }

Exit:
    return hr;
}


STDMETHODIMP CAssemblyStream::Write(THIS_ VOID const HUGEP *pv, ULONG cb,
            ULONG FAR *pcbWritten)
{
    BOOL fRet = WriteFile (_hf, pv, cb, pcbWritten, NULL);
    if (fRet)
    {
        CryptHashData(_hHash, (PBYTE) pv, *pcbWritten, 0);
        return S_OK;
    }
    else
    {   // Report the error.
        HRESULT hr = FusionpHresultFromLastError();
        ReleaseParent (hr);
        return hr;
    }
}


STDMETHODIMP CAssemblyStream::Commit(THIS_ DWORD dwCommitFlags)
{
    BOOL fRet;
    HRESULT hr;
    IAssemblyName *pName = NULL;
    IAssemblyName *pNameCopy = NULL;
    IAssemblyManifestImport *pImport = NULL;


    if(FAILED(hr = AddSizeToItem()))
        goto exit;

    fRet = CloseHandle (_hf);
    _hf = INVALID_HANDLE_VALUE;
    hr = fRet? S_OK : FusionpHresultFromLastError();

    if (FAILED(hr))
        goto exit;

    // If this file contains a manifest extract the
    // name and set it on the parent cache item.
    switch (_dwFormat)
    {
        case STREAM_FORMAT_COMPLIB_MANIFEST:
        {
            // If a manifest interface has not already been
            // set on this item, construct one from path.
            if (!(pImport = _pParent->GetManifestInterface()))
            {
                if (FAILED(hr = CreateAssemblyManifestImport(_szPath, &pImport)))
                    goto exit;

                if(FAILED(hr = _pParent->SetManifestInterface( pImport )))
                    goto exit;
            }

            // Get the read-only name def.
            if (FAILED(hr = pImport->GetAssemblyNameDef(&pName)))
                goto exit;

            // Make a writeable copy of the name def.
            if (FAILED(hr = pName->Clone(&pNameCopy)))
                goto exit;

            // Cache this on the parent cache item.
            if (FAILED(hr = _pParent->SetNameDef(pNameCopy)))
                goto exit;

        }
        break;

        case STREAM_FORMAT_COMPLIB_MODULE:
        {
            if( FAILED(hr = CheckHash()) )
                goto exit;
        }
        break;


    } // end switch

exit:

    SAFERELEASE(pImport);
    SAFERELEASE(pName);
    SAFERELEASE(pNameCopy);

    CryptDestroyHash(_hHash);
    _hHash = 0;

    ReleaseParent (hr);
    return hr;
}

void CAssemblyStream::ReleaseParent (HRESULT hr)
{
    if (_hf != INVALID_HANDLE_VALUE)
    {
        CloseHandle (_hf);
        _hf = INVALID_HANDLE_VALUE;
    }
    _pParent->StreamDone (hr);
    _pParent->Release();
    _pParent = NULL;
}

CAssemblyStream::~CAssemblyStream ( )
{
    if (_pParent)
        ReleaseParent (STG_E_ABNORMALAPIEXIT);
    ASSERT (_hf == INVALID_HANDLE_VALUE);
}

HRESULT CAssemblyStream::CheckHash( )
{
    HRESULT hr = S_OK;
    CModuleHashNode  *pModuleHashNode;
    pModuleHashNode = NEW(CModuleHashNode);
    IAssemblyManifestImport *pManifestImport = NULL;
    BOOL    bAssemblyComplete = TRUE;

    if (!pModuleHashNode)
    {
        return E_OUTOFMEMORY;

    }

    BYTE    pbHash[MAX_HASH_LEN];
    DWORD   cbHash=MAX_HASH_LEN;


    if (CryptGetHashParam(_hHash, HP_HASHVAL, pbHash, &cbHash, 0))
    {
        pModuleHashNode->Init(_szPath, CALG_SHA1, cbHash, pbHash );
    }
    else
    {
        pModuleHashNode->Init(_szPath, 0, 0, 0);
    }

    hr = _pParent->AddToStreamHashList(pModuleHashNode);

    SAFERELEASE(pManifestImport);
    return hr;
}

HRESULT CAssemblyStream::AddSizeToItem( )
{

    HRESULT hr=S_OK;
    DWORD dwFileSizeLow = 0, dwFileSizeHigh = 0;

    hr = GetFileSizeRoundedToCluster(_hf, &dwFileSizeLow, &dwFileSizeHigh);
    if(SUCCEEDED(hr))
    {
        _pParent->AddStreamSize(dwFileSizeLow, dwFileSizeHigh);
    }

    return hr ;
}

//
// IStream methods not implemented...
//

STDMETHODIMP CAssemblyStream::Read(THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead)
{
    return E_NOTIMPL;
}


STDMETHODIMP CAssemblyStream::Seek(THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin,
            ULARGE_INTEGER FAR *plibNewPosition)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyStream::SetSize (THIS_ ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyStream::CopyTo(THIS_ LPSTREAM pStm, ULARGE_INTEGER cb,
            ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten)
{
    return E_NOTIMPL;
}


STDMETHODIMP CAssemblyStream::Revert(THIS)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyStream::LockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyStream::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyStream::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAssemblyStream::Clone(THIS_ LPSTREAM FAR *ppStm)
{
    return E_NOTIMPL;
}

//
// IUnknown boilerplate...
//

STDMETHODIMP CAssemblyStream::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IStream)
       )
    {
        *ppvObj = static_cast<IStream*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CAssemblyStream::AddRef(void)
{
    return InterlockedIncrement((LONG *)&_cRef);
}

STDMETHODIMP_(ULONG) CAssemblyStream::Release(void)
{
    ULONG                    ulRef = InterlockedDecrement((LONG *)&_cRef);

    if (!ulRef) {
        delete this;
    }

    return ulRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\enum.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "asmstrm.h"
#include "util.h"

#include "enum.h"
#include "transprt.h"
#include "cacheutils.h"
#include "lock.h"

extern LPCWSTR g_szFindAllMask;
extern LPCWSTR g_szDotDLL;
extern LPCWSTR g_szDotEXE;
extern LPCWSTR g_szZapDotMan;


// global crit-sec for init dbs (reuse, defined at dllmain.cpp)
extern CRITICAL_SECTION g_csInitClb;



void RemoveDirectoryIfEmpty(LPWSTR pszCachePath, LPWSTR pszParentDir)
{
    WCHAR pszDirPath[MAX_PATH+1];

    if( pszCachePath[0] && pszParentDir[0])
    {
        wnsprintf(pszDirPath, MAX_PATH, L"%s\\%s", pszCachePath, pszParentDir);
        RemoveDirectory(pszDirPath);
    }
}


// --------------------- CEnumCache implementation --------------------------



// ---------------------------------------------------------------------------
// CEnumRecord  ctor
// ---------------------------------------------------------------------------
CEnumCache::CEnumCache(BOOL bShowAll, LPWSTR pszCustomPath)
{
    _dwSig = 'RNCE';
    _dwColumns = 0;
    _pQry = 0;
    _bShowAll=bShowAll;
    _fAll = FALSE;
    _fAllDone = FALSE;
    _hParentDone = FALSE;
    _bNeedMutex = FALSE;
    _hParentDir = INVALID_HANDLE_VALUE;
    _hAsmDir = INVALID_HANDLE_VALUE;
    _wzCachePath[0] = '\0';
    _wzParentDir[0] = '\0';
    _wzAsmDir[0] = '\0';
    if(pszCustomPath)
    {
        wnsprintfW(_wzCustomPath, MAX_PATH, L"%ws", pszCustomPath);
    }
    else
    {
        _wzCustomPath[0] = '\0';
    }
}

// ---------------------------------------------------------------------------
// CEnumRecord  dtor
// ---------------------------------------------------------------------------
CEnumCache::~CEnumCache()
{
    _dwColumns = 0;

    if(_hParentDir != INVALID_HANDLE_VALUE)
    {
        FindClose(_hParentDir);
        _hParentDir = INVALID_HANDLE_VALUE;
    }

    if(_hAsmDir != INVALID_HANDLE_VALUE)
    {
        FindClose(_hAsmDir);
        _hAsmDir = INVALID_HANDLE_VALUE;
    }

    SAFERELEASE(_pQry);
}

// ---------------------------------------------------------------------------
// CEnumRecord::Init
// ---------------------------------------------------------------------------
HRESULT
CEnumCache::Init(CTransCache* pQry, DWORD dwCmpMask)
{
    HRESULT hr = S_OK;

    ASSERT(pQry);

    _bNeedMutex = ((pQry->GetCacheType() & ASM_CACHE_DOWNLOAD) && (!_wzCustomPath[0]));

    if(_bNeedMutex)
    {
        if(FAILED(hr = CreateCacheMutex()))
            goto exit;
    }

    hr = Initialize(pQry, dwCmpMask);

exit :
    return hr;
}

HRESULT
CEnumCache::Initialize(CTransCache* pQry, DWORD dwCmpMask)
{
    HRESULT hr = S_OK;
    TRANSCACHEINFO* pInfo = NULL;
    WCHAR wzFullSearchPath[MAX_PATH+1];
    _dwCmpMask = dwCmpMask;
    DWORD           cchRequired=0;
    WIN32_FIND_DATA FindFileData;
    LPWSTR pwzCustomPath = lstrlenW(_wzCustomPath) ?  _wzCustomPath : NULL;
    CMutex  cCacheMutex(_bNeedMutex ? g_hCacheMutex : INVALID_HANDLE_VALUE);

    _pQry = pQry;
    _pQry->AddRef();

    _dwCmpMask = dwCmpMask;

    // custom attribute is set by-default; un-set it if custom blob is not passed-in.
    if( (_dwCmpMask & ASM_CMPF_CUSTOM) && (!(_pQry->_pInfo->blobCustom.pBlobData) 
                         && pQry->GetCacheType() & ASM_CACHE_ZAP))
    {
        _dwCmpMask &= (~ASM_CMPF_CUSTOM);
    }

    _dwColumns = _pQry->MapCacheMaskToQueryCols(_dwCmpMask);

    if( !_dwColumns )
    {
        // _dwColumns == 0 means doing whole table scan
        _fAll = TRUE;
    }

    cchRequired = MAX_PATH;
    if(FAILED(hr = CreateAssemblyDirPath( pwzCustomPath, 0, _pQry->GetCacheType(),
                                           0, _wzCachePath, &cchRequired)))
        goto exit;


    if(FAILED(hr = cCacheMutex.Lock()))
        goto exit;

    if(GetFileAttributes(_wzCachePath) == -1)
    {
        hr = DB_S_NOTFOUND;
        _fAllDone = TRUE;
        goto exit;
    }

    if(FAILED(hr = GetAssemblyParentDir( (CTransCache*) _pQry, _wzParentDir)))
        goto exit;

    cchRequired = lstrlenW(_wzCachePath) + lstrlenW(_wzParentDir) + lstrlenW(g_szFindAllMask) + 1; // extra chars for "\" etc

    if (cchRequired >= MAX_PATH)
    {
        // BUGBUG: need to work around this on NT.
        hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
        goto exit;
    }

    StrCpy(wzFullSearchPath, _wzCachePath);

    if(_fAll)
    {
        StrCat(wzFullSearchPath, g_szFindAllMask);
        
        _hParentDir = FindFirstFile(wzFullSearchPath, &FindFileData);

        if(_hParentDir == INVALID_HANDLE_VALUE)
        {
            hr = FusionpHresultFromLastError();
            goto exit;
        }

        StrCat(_wzParentDir, FindFileData.cFileName );
    }
    else
    {
        if (!lstrlenW(_wzParentDir)) {
            hr = DB_S_NOTFOUND;
            _fAllDone = TRUE;
            goto exit;
        }
            
        hr = PathAddBackslashWrap(wzFullSearchPath, MAX_PATH);
        if (FAILED(hr)) {
            goto exit;
        }

        StrCat(wzFullSearchPath, _wzParentDir);

        if(GetFileAttributes(wzFullSearchPath) == -1)
        {
            hr = DB_S_NOTFOUND;
            _fAllDone = TRUE;
            goto exit;
        }

        _hParentDone = TRUE;
    }

    hr = S_OK;

exit:

    if(FAILED(hr))
        _fAllDone = TRUE;

    return hr;
}

// ---------------------------------------------------------------------------
// CEnumRecord::GetNextRecord
// ---------------------------------------------------------------------------
HRESULT
CEnumCache::GetNextRecord(CTransCache* pOutRecord)
{
    HRESULT hr = S_FALSE;
    DWORD dwCmpResult = 0;
    BOOL fIsMatch = FALSE;

    HANDLE          hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindFileData;
    DWORD           cchRequired=0;
    CMutex  cCacheMutex(_bNeedMutex ? g_hCacheMutex : INVALID_HANDLE_VALUE);
    
    if( !pOutRecord )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if(_fAllDone)
    {
        hr = S_FALSE;
        goto exit;
    }

    if(FAILED(cCacheMutex.Lock()))
        goto exit;

    if(_hParentDir != INVALID_HANDLE_VALUE)
    {
        ASSERT(lstrlenW(_wzParentDir));
        StrCpy(FindFileData.cFileName, _wzParentDir);

        do
        {
            // skip directories    
            if (!FusionCompareStringI(FindFileData.cFileName, L"."))
                continue;
            if (!FusionCompareStringI(FindFileData.cFileName, L".."))
                continue;

            StrCpy(_wzParentDir, FindFileData.cFileName );

            hr = GetNextAssemblyDir(pOutRecord);
            if(FAILED(hr))
                goto exit;
            if(hr == S_OK)
                goto exit;

            RemoveDirectoryIfEmpty( _wzCachePath, _wzParentDir);

        }while(FindNextFile(_hParentDir, &FindFileData)); // while 

        _fAllDone = TRUE;
        if( GetLastError() != ERROR_NO_MORE_FILES)
        {
            hr = FusionpHresultFromLastError();
            goto exit;
        }

    }
    else
    {
        hr = GetNextAssemblyDir(pOutRecord);
    }

exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CEnumCache::GetNextAssemblyDir
// ---------------------------------------------------------------------------
HRESULT
CEnumCache::GetNextAssemblyDir(CTransCache* pOutRecord)
{
    HRESULT hr = S_FALSE;
    DWORD dwCmpResult = 0;
    BOOL fIsMatch = FALSE;
    BOOL fFound = FALSE;
    HANDLE          hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindFileData;
    WCHAR           wzFullSearchPath[MAX_PATH+1];
    int           dwLen=0;
    DWORD dwAttr=0;
    WCHAR wzFullPath[MAX_PATH+1];
    DWORD dwCacheType=0;

    if( !pOutRecord )
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if(_fAllDone)
    {
        hr = S_FALSE;
        goto exit;
    }

    ASSERT(lstrlenW(_wzParentDir));

    if(_hAsmDir == INVALID_HANDLE_VALUE)
    {
        if( (lstrlenW(_wzCachePath) + lstrlenW(_wzParentDir) + lstrlenW(g_szFindAllMask) + 4) >= MAX_PATH)
        {
            hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
            goto exit;
        }

        StrCpy(wzFullSearchPath, _wzCachePath);
        hr = PathAddBackslashWrap(wzFullSearchPath, MAX_PATH);
        if (FAILED(hr)) {
            goto exit;
        }

        StrCat(wzFullSearchPath, _wzParentDir);

        dwAttr = GetFileAttributes(wzFullSearchPath);
        if((dwAttr == -1) || !(dwAttr & FILE_ATTRIBUTE_DIRECTORY ))
        {
            hr = S_FALSE;
            goto exit;
        }

        StrCat(wzFullSearchPath, g_szFindAllMask);
        
        _hAsmDir = FindFirstFile(wzFullSearchPath, &FindFileData);

        if(_hAsmDir == INVALID_HANDLE_VALUE)
        {
            hr = FusionpHresultFromLastError();
            goto exit;
        }

        fFound = TRUE;
    }
    else
    {   
        // BUGBUG: should we comment this out; since we have fFound ??
        if(FindNextFile(_hAsmDir, &FindFileData))
            fFound = TRUE;
    }

    do
    {
        if(!fFound)
            break;

        if (!FusionCompareStringI(FindFileData.cFileName, L"."))
                continue;

        if (!FusionCompareStringI(FindFileData.cFileName, L".."))
                continue;

        if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            continue;

        hr = ParseDirName ( pOutRecord, _wzParentDir, FindFileData.cFileName );
        if(hr != S_OK)
        {
            pOutRecord->CleanInfo(pOutRecord->_pInfo, TRUE);
            continue;
        }

        if( (lstrlenW(_wzCachePath) + lstrlenW(_wzParentDir) + lstrlenW(FindFileData.cFileName) + 4) >= MAX_PATH)
        {
            hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
            goto exit;
        }

        StrCpy(wzFullPath, _wzCachePath);
        hr = PathAddBackslashWrap(wzFullPath, MAX_PATH);
        if (FAILED(hr)) {
            goto exit;
        }

        StrCat(wzFullPath, _wzParentDir);
        hr = PathAddBackslashWrap(wzFullPath, MAX_PATH);
        if (FAILED(hr)) {
            goto exit;
        }
        StrCat(wzFullPath, FindFileData.cFileName);

        dwCacheType = _pQry->GetCacheType();
        hr = GetFusionInfo( pOutRecord, wzFullPath);
        if((hr != S_OK) && (dwCacheType != ASM_CACHE_GAC) && !_bShowAll)
        {
            pOutRecord->CleanInfo(pOutRecord->_pInfo, TRUE);
            continue;
        }

        hr = PathAddBackslashWrap(wzFullPath, MAX_PATH);
        if (FAILED(hr)) {
            goto exit;
        }

        if(dwCacheType & ASM_CACHE_DOWNLOAD)
        {
            if(!pOutRecord->_pInfo->pwzName)
            {
                if(_bShowAll)
                    goto Done;
                else
                    continue;
            }

            StrCatBuff(wzFullPath, pOutRecord->_pInfo->pwzName, MAX_PATH);
        }
        else
        {
            StrCatBuff(wzFullPath, _wzParentDir, MAX_PATH);
        }

        dwLen = lstrlenW(wzFullPath);

        StrCatBuff(wzFullPath, g_szDotDLL, MAX_PATH);
        if(((dwCacheType & ASM_CACHE_DOWNLOAD) || (dwCacheType & ASM_CACHE_ZAP) ) &&
                    (GetFileAttributes(wzFullPath) == -1) )
        {
            // there is no AsmName.dll look for AsmName.exe

            if( (dwLen + lstrlenW(g_szDotEXE)) >= MAX_PATH)
            {
                hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
                goto exit;
            }

            StrCpy(wzFullPath+dwLen, g_szDotEXE);
        }

        if(!_bShowAll)
        {
            fIsMatch = _pQry->IsMatch(pOutRecord, _dwCmpMask, &dwCmpResult);                
            if(!fIsMatch)
            {
                pOutRecord->CleanInfo(pOutRecord->_pInfo, TRUE);
                continue;
            }
        }

Done :
        SAFEDELETEARRAY(pOutRecord->_pInfo->pwzPath); // BUGBUG: do we need this.
        pOutRecord->_pInfo->pwzPath = WSTRDupDynamic(wzFullPath);

        hr = S_OK;
        goto exit;

    }while(FindNextFile(_hAsmDir, &FindFileData)); // while 

    if( GetLastError() != ERROR_NO_MORE_FILES)
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    hr = S_FALSE;
    FindClose(_hAsmDir);
    _hAsmDir = INVALID_HANDLE_VALUE;

    if(_hParentDir == INVALID_HANDLE_VALUE)
        _fAllDone = TRUE;

exit :
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\asmitem.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionp.h"
#include "asm.h"
#include "asmitem.h"
#include "asmstrm.h"
#include "naming.h"
#include "debmacro.h"
#include "asmimprt.h"
#include "helpers.h"
#include "asmcache.h"
#include "appctx.h"
#include "util.h"
#include "scavenger.h"
#include "cacheUtils.h"
#include "scavenger.h"
#include "history.h"
#include "policy.h"
#include "lock.h"

extern CRITICAL_SECTION g_csInitClb;
extern BOOL g_bRunningOnNT;

// ---------------------------------------------------------------------------
// CAssemblyCacheItem ctor
// ---------------------------------------------------------------------------
CAssemblyCacheItem::CAssemblyCacheItem()
{
    _dwSig           = 'TICA';
    _cRef            = 1;
    _pName           = NULL;
    _hrError         = S_OK;
    _cStream         = 0;
    _dwAsmSizeInKB   = 0;
    _szDir[0]        = 0;
    _cwDir           = 0;
    _szManifest[0]   = 0;
    _szDestManifest[0] =0;
    _pszAssemblyName = NULL;
    _pManifestImport = NULL;
    _pStreamHashList = NULL;
    _pszUrl          = NULL;
    _pTransCache     = NULL;
    _pCache          = NULL;
    _dwCacheFlags    = 0;
    _pbCustom        = NULL;
    _cbCustom        = 0;
    _hFile           = INVALID_HANDLE_VALUE;
    memset(&_ftLastMod, 0, sizeof(FILETIME));
    _bNeedMutex      = FALSE;
    _bCommitDone     = FALSE;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem dtor
// ---------------------------------------------------------------------------
CAssemblyCacheItem::~CAssemblyCacheItem()
{
    ASSERT (!_cStream);

    if(_pStreamHashList)
        _pStreamHashList->DestroyList();

    SAFERELEASE(_pManifestImport);
    SAFERELEASE(_pName);
    SAFERELEASE(_pTransCache);
    SAFERELEASE(_pCache);
    SAFEDELETEARRAY(_pszUrl);
    SAFEDELETEARRAY(_pbCustom); 
    SAFEDELETEARRAY(_pszAssemblyName);


    if(_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(_hFile);

    // Fix #113095 - Cleanup temp dirs if installation is incomplete / fails
    if( ((_hrError != S_OK) || (_bCommitDone == FALSE)) && _szDir[0])
    {
        HRESULT hr = RemoveDirectoryAndChildren (_szDir);
    }
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::Create
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyCacheItem::Create(IApplicationContext *pAppCtx,
    IAssemblyName *pName, LPTSTR pszUrl, FILETIME *pftLastMod,
    DWORD dwCacheFlags,    IAssemblyManifestImport *pManImport, 
    LPCWSTR pszAssemblyName, IAssemblyCacheItem **ppAsmItem)
{
    HRESULT               hr       = S_OK;
    CAssemblyCacheItem  *pAsmItem = NULL;

    // bugbug - enforce url + lastmodified passed in.

    if (!ppAsmItem) 
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *ppAsmItem = NULL;

    if(((dwCacheFlags & ASM_CACHE_GAC) || (dwCacheFlags & ASM_CACHE_ZAP)) && !IsGACWritable())
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto exit;
    }

    pAsmItem = NEW(CAssemblyCacheItem);
    if (!pAsmItem) 
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (FAILED(hr = pAsmItem->Init(pAppCtx, pName, pszUrl, pftLastMod, 
        dwCacheFlags, pManImport)))
        goto exit;
 
    if(pszAssemblyName)
    {
        pAsmItem->_pszAssemblyName = WSTRDupDynamic(pszAssemblyName);
        if (!(pAsmItem->_pszAssemblyName)) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

    }

    *ppAsmItem = pAsmItem;
    (*ppAsmItem)->AddRef();

exit:
    SAFERELEASE(pAsmItem);

    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::Init
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheItem::Init(IApplicationContext *pAppCtx,
    IAssemblyName *pName, LPTSTR pszUrl,
    FILETIME *pftLastMod, DWORD dwCacheFlags,
    IAssemblyManifestImport *pManifestImport)
{
    HRESULT hr = S_OK;
    LPWSTR pszManifestPath=NULL, pszTmp;
    DWORD  cbManifestPath;
    BOOL fManifestCreated = FALSE;    

    // Save off cache flags.
    _dwCacheFlags = dwCacheFlags;

    // Create the cache
    if (FAILED(hr = CCache::Create(&_pCache, pAppCtx)))
        goto exit;

    _bNeedMutex = ((_dwCacheFlags & ASM_CACHE_DOWNLOAD) && (_pCache->GetCustomPath() == NULL));

    if(_bNeedMutex)
    {
        if(FAILED(_hrError = CreateCacheMutex()))
            goto exit;
    }

    // If an IAssemblyName passed in, then this will be used
    // to lookup and modify the corresponding cache entry.
    if (pName)
    {
        // Set the assembly name definition.
        SetNameDef(pName);

        // Retrieve associated cache entry from trans cache.
        hr = _pCache->RetrieveTransCacheEntry(_pName, _dwCacheFlags, &_pTransCache);
        if ((hr != DB_S_FOUND) && (hr != S_OK)){
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto exit;
        }

        // Get full path to manifest.
        pszManifestPath = _pTransCache->_pInfo->pwzPath;

        if((_hFile == INVALID_HANDLE_VALUE) &&
                FAILED(hr = GetManifestFileLock(pszManifestPath, &_hFile)))
        {
            goto exit;
        }

        // Instantiate manifest interface from cache path if none provided.
        if (!pManifestImport)
        {
            if (FAILED(hr = CreateAssemblyManifestImport(pszManifestPath, &pManifestImport)))
                goto exit;
            fManifestCreated = TRUE;
        }

        // Cache the manifest.
        SetManifestInterface(pManifestImport);
        
        // Copy over full path to manifest file
        cbManifestPath  = lstrlen(pszManifestPath) + 1;
        memcpy(_szManifest, pszManifestPath, cbManifestPath * sizeof(TCHAR));

        // Extract cache dir assuming one up from file.
        // BUGBUG - this is bogus, and was done in the original
        // code. You need to match against actual name in manifest.
        memcpy(_szDir, pszManifestPath, cbManifestPath * sizeof(TCHAR));
        pszTmp = PathFindFileName(_szDir);
        *(pszTmp-1) = L'\0';
        _cwDir = pszTmp - _szDir;

        // NOTE - since we have a transport cache entry there is no
        // need to set the url and last modified.
    } 
    else
    {
        // If no IAssemblyName provided, then this cache item will be used
        // to create a new transport cache item.

        // **Note - url and last modified are required if the assembly
        // being comitted is simple. If however it is strong or custom,
        // url and last modified are not required. We can check for 
        // strongly named at this point, but if custom the data will 
        // be set just prior to commit so we cannot enforce this at init.
        

        ASSERT(!_pszUrl);

        if(pszUrl)
            _pszUrl = TSTRDupDynamic(pszUrl);

        if(pftLastMod)
            memcpy(&_ftLastMod, pftLastMod, sizeof(FILETIME));

        // Set the manifest import interface if present.
        if (pManifestImport)
            SetManifestInterface(pManifestImport);
    }


exit:
    if (fManifestCreated)
        SAFERELEASE(pManifestImport);

    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::SetNameDef
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheItem::SetNameDef(IAssemblyName *pName)
{   
    if(_pName == pName)
        return S_OK;

    if(_pName)
        _pName->Release();

    _pName = pName;
    pName->AddRef();
    return S_OK;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::GetNameDef
// ---------------------------------------------------------------------------
IAssemblyName *CAssemblyCacheItem::GetNameDef()
{   

    if(_pName)
        _pName->AddRef();

    return _pName;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::SetManifestInterface
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheItem::SetManifestInterface(IAssemblyManifestImport *pImport)
{    
    ASSERT(!_pManifestImport);

    _pManifestImport = pImport;
    _pManifestImport->AddRef();

    return S_OK;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::GetFileHandle
// ---------------------------------------------------------------------------
HANDLE CAssemblyCacheItem::GetFileHandle()
{
    HANDLE hFile = _hFile;
    _hFile = INVALID_HANDLE_VALUE;
    return hFile;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::IsManifestFileLocked
// ---------------------------------------------------------------------------
BOOL CAssemblyCacheItem::IsManifestFileLocked()
{
    if(_hFile == INVALID_HANDLE_VALUE)
        return FALSE;
    else
        return TRUE;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::GetManifestInterface
// ---------------------------------------------------------------------------
IAssemblyManifestImport* CAssemblyCacheItem::GetManifestInterface()
{
    if (_pManifestImport)
        _pManifestImport->AddRef();
    return _pManifestImport;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::GetManifestPath
// ---------------------------------------------------------------------------
LPTSTR CAssemblyCacheItem::GetManifestPath()
{
    return _szDestManifest;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::StreamDone
// ---------------------------------------------------------------------------
void CAssemblyCacheItem::StreamDone (HRESULT hr)
{    
    ASSERT (_cStream);
    if (hr != S_OK)
        _hrError = hr;
    InterlockedDecrement (&_cStream);
}


// ---------------------------------------------------------------------------
// CAssemblyCacheItem::CreateCacheDir
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheItem::CreateCacheDir( 
    /* [in]  */  LPCOLESTR pszCustomPath,
    /* [in] */ LPCOLESTR pszName,
    /* [out] */ LPOLESTR pszAsmDir )
{
    HRESULT hr;

    _cwDir = MAX_PATH;
    hr = GetAssemblyStagingPath (pszCustomPath, _dwCacheFlags, 0, _szDir, &_cwDir);
    if (hr != S_OK)
    {
        _hrError = hr;
        return _hrError;
    }

    // Compose with stream name, checking for path overflow.
    DWORD cwName = lstrlen(pszName) + 1;
    if (_cwDir + cwName > MAX_PATH) // includes backslash
    {
        _hrError = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
        return _hrError;
    }

    if (pszAsmDir )
        StrCpy (pszAsmDir, _szDir);

    return S_OK;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::CreateStream
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyCacheItem::CreateStream( 
        /* [in] */ DWORD dwFlags,                         // For general API flags
        /* [in] */ LPCWSTR pszName,                       // Name of the stream to be passed in
        /* [in] */ DWORD dwFormat,                        // format of the file to be streamed in.
        /* [in] */ DWORD dwFormatFlags,                   // format-specific flags
        /* [out] */ IStream **ppStream,
        /* [in, optional] */ ULARGE_INTEGER *puliMaxSize) // Max size of the Stream.
{
    TCHAR szPath[MAX_PATH];
    
    CAssemblyStream* pstm = NULL;
    *ppStream = NULL;

    // Do not allow path hackery.
    // need to validate this will result in a relative path within asmcache dir.
    // For now don't allow "\" in path; collapse the path before doing this.
    if (StrChr(pszName, DIR_SEPARATOR_CHAR))
    {
        _hrError = E_INVALIDARG;
        goto exit;
    }

    // Empty directory indicates - create a cache directory.
    if ( !_szDir[0] )
    {
        if (FAILED(_hrError = CreateCacheDir((LPOLESTR) _pCache->GetCustomPath(), (LPOLESTR) pszName, NULL)))
            goto exit;
    }
    // Dir exists - ensure final file path from name
    // does not exceed MAX_PATH chars.
    else
    {        
        DWORD cwName; 
        cwName = lstrlen(pszName) + 1;
        if (_cwDir + cwName > MAX_PATH) // includes backslash
        {
            _hrError = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
            goto exit;
        }
    }

    // Construct the stream object.
    pstm = NEW(CAssemblyStream(this));
    if (!pstm)
    {
        _hrError = E_OUTOFMEMORY;
        goto exit;
    }

    // BUGBUG - this guards stream count,
    // BUT THIS OBJECT IS NOT THREAD SAFE. 
    InterlockedIncrement (&_cStream);

    // Append trailing slash to path.
    StrCpy (szPath, _szDir);
    _hrError = PathAddBackslashWrap(szPath, MAX_PATH);
    if (FAILED(_hrError)) {
        goto exit;
    }

    // Generate cache file name
    switch (dwFormat)
    {
        case STREAM_FORMAT_COMPLIB_MANIFEST:
        {
            if((_dwCacheFlags & ASM_CACHE_DOWNLOAD) && (_pszUrl) && (!IsCabFile(_pszUrl)))
            {
                // for download cache get the manifest name from URL;
                // this will get around the name mangling done by IE cache.
                LPWSTR pszTemp = NULL;

                pszTemp = StrRChr(_pszUrl, NULL, URL_DIR_SEPERATOR_CHAR);
                if(pszTemp && (lstrlenW(pszTemp) > 1))
                {
                    if(lstrlenW(szPath) + lstrlenW(pszTemp)  >= MAX_PATH)
                    {
                        _hrError = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
                        goto exit;
                    }

                    DWORD dwLen = lstrlenW(szPath);
                    DWORD dwSize = MAX_PATH - dwLen;

                    lstrcpyW(szPath+dwLen, pszTemp + 1);
                    break;
                }
            }

            // Use passed in module name since we can't do
            // integrity checking to determine real name.
            StrCat (szPath, pszName);
            break;
        }

        case STREAM_FORMAT_COMPLIB_MODULE:
        {
            // Create a random filename since we will
            // do integrity checking later from which
            // we will determine the correct name.
            TCHAR*  pszFileName;
            DWORD dwErr;
            pszFileName = szPath + lstrlen(szPath);

            #define RANDOM_NAME_SIZE 8

            if (lstrlen(szPath) + RANDOM_NAME_SIZE + 1 >= MAX_PATH) {
                _hrError = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                goto exit;
            }

            // Loop until we get a unique file name.
            int i;
            
            for (i = 0; i < MAX_RANDOM_ATTEMPTS; i++)
            {
                // BUGBUG: Check for buffer size.
                // GetRandomDirName is being used here
                // to generate a random filename. 
                GetRandomName (pszFileName, RANDOM_NAME_SIZE);
                if (GetFileAttributes(szPath) != -1)
                    continue;

                dwErr = GetLastError();                
                if (dwErr == ERROR_FILE_NOT_FOUND)
                {
                    _hrError = S_OK;
                    break;
                }
                _hrError = HRESULT_FROM_WIN32(dwErr);
                goto exit;
            }

            if (i >= MAX_RANDOM_ATTEMPTS)  {
                _hrError = E_UNEXPECTED;
                goto exit;
            }

            break;
        }
    } // end switch

    // this creates Asm hierarchy (if required)
    if (FAILED(_hrError = CreateFilePathHierarchy(szPath)))
        goto exit;

    // Initialize stream object.
    if (FAILED(_hrError = pstm->Init ((LPOLESTR) szPath, dwFormat)))
        goto exit;

    // Record the manifest file path.
    switch(dwFormat)
    {
        case STREAM_FORMAT_COMPLIB_MANIFEST:
            StrCpy(_szManifest, szPath);
    }
    
    *ppStream = (IStream*) pstm;

exit:

    if (!SUCCEEDED(_hrError))
        SAFERELEASE(pstm);

    return _hrError;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::CompareInputToDef
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheItem::CompareInputToDef()
{
    HRESULT hr = S_OK;

    IAssemblyName *pName = NULL;

    if (FAILED(hr = CreateAssemblyNameObject(&pName, _pszAssemblyName, CANOF_PARSE_DISPLAY_NAME, 0)))
        goto exit;

    hr = _pName->IsEqual(pName, ASM_CMPF_DEFAULT);

exit:

   SAFERELEASE(pName);
   return hr;

}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::VerifyDuplicate
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheItem::VerifyDuplicate(DWORD dwVerifyFlags, CTransCache *pTC)
{
    HRESULT hr = S_OK;
    IAssemblyName *pName = NULL;
    IAssemblyManifestImport           *pManifestImport=NULL;

    // we found a duplicate now do VerifySignature && def-def matching 
    if (CCache::IsStronglyNamed(_pName) && (_pCache->GetCustomPath() == NULL))
    {
        BOOL fWasVerified;
        if (!VerifySignature(_szDestManifest, &(fWasVerified = FALSE), dwVerifyFlags))
        {
            hr = FUSION_E_SIGNATURE_CHECK_FAILED;
            goto exit;
        }
    }

    if(FAILED(hr = GetFusionInfo(pTC, _szDestManifest)))
        goto exit;

    // BUGBUG: Technically, we should be doing a case-sensitive comparison
    // here because this is an URL, but to cut down code churn, leave the
    // comparison the same as before.

    if(!pTC->_pInfo->pwzCodebaseURL || FusionCompareStringI(pTC->_pInfo->pwzCodebaseURL, _pszUrl))
    {
        hr = E_FAIL;
        goto exit;
    }

    if(_pCache->GetCustomPath() == NULL)
    {
        // ref-def matching in non-XSP case only
        if (FAILED(hr = CreateAssemblyManifestImport(_szDestManifest, &pManifestImport)))
            goto exit;

        // Get the read-only name def.
        if (FAILED(hr = pManifestImport->GetAssemblyNameDef(&pName)))
            goto exit;

        ASSERT(pName);

        hr = _pName->IsEqual(pName, ASM_CMPF_DEFAULT);
    }

exit:

   SAFERELEASE(pManifestImport);
   SAFERELEASE(pName);
   return hr;

}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::MoveAssemblyToFinalLocation
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheItem::MoveAssemblyToFinalLocation( DWORD dwFlags, DWORD dwVerifyFlags )
{
    HRESULT hr=S_OK;
    WCHAR wzCacheLocation[MAX_PATH+1];
    DWORD dwSize=0;
    WCHAR wzFullPath[MAX_PATH+1];
    DWORD cbPath=MAX_PATH;
    DWORD dwAttrib=0, Error=0;
    WCHAR wzManifestFileName[MAX_PATH+1];
    WCHAR szAsmTextName[MAX_PATH+1], szSubDirName[MAX_PATH+1];
    CTransCache *pTransCache=NULL;
    CMutex  cCacheMutex(_bNeedMutex ? g_hCacheMutex : INVALID_HANDLE_VALUE);
    BOOL bEntryFound=FALSE;
    BOOL bReplaceBits=FALSE;
    BOOL bNeedNewDir = FALSE;
    int  iNewer=0;

#define MAX_DIR_LEN  (5)

    dwSize = MAX_PATH;
    if( FAILED(hr = CreateAssemblyDirPath( _pCache->GetCustomPath(), 0, _dwCacheFlags,
                                           0, wzCacheLocation, &dwSize)))
        goto exit;

    StrCpy(wzFullPath, wzCacheLocation);
    hr = PathAddBackslashWrap(wzFullPath, MAX_PATH);
    if (FAILED(hr)) {
        goto exit;
    }

    if(FAILED(hr = GetCacheDirsFromName(_pName, _dwCacheFlags, szAsmTextName, szSubDirName )))
        goto exit;

    StrCpy(wzManifestFileName, PathFindFileName(_szManifest));

    if( (lstrlenW(wzFullPath) + lstrlenW(szAsmTextName) + lstrlenW(szSubDirName) + 
                lstrlenW(wzManifestFileName) + MAX_DIR_LEN) >= MAX_PATH )
    {
        hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
        goto exit;
    }

    StrCat(wzFullPath, szAsmTextName);
    hr = PathAddBackslashWrap(wzFullPath, MAX_PATH);
    if (FAILED(hr)) {
        goto exit;
    }

    StrCat(wzFullPath, szSubDirName);

    wnsprintf(_szDestManifest, MAX_PATH, L"%s\\%s", wzFullPath, wzManifestFileName);

    if(_pTransCache)
    {
        // This seems to be incremental download. nothing to move.
        hr = S_OK;
        goto exit;
    }

    if((_dwCacheFlags & ASM_CACHE_GAC) || (_dwCacheFlags & ASM_CACHE_ZAP))
    {
        if(FusionCompareStringNI(wzManifestFileName, szAsmTextName, lstrlenW(szAsmTextName)))
        {
            // manifest file name should be "asseblyname.dll" (or .exe ??)
            hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
            goto exit;
        }
    }

    if(FAILED(hr = cCacheMutex.Lock()))
        goto exit;

    // Create a transcache entry from name.
    if (FAILED(hr = _pCache->TransCacheEntryFromName(_pName, _dwCacheFlags, &pTransCache)))
        goto exit;

    // See if this assembly already exists.

#define CHECK_IF_NEED_NEW_DIR  \
        do { \
            if ((_pCache->GetCustomPath() != NULL) && (_dwCacheFlags & ASM_CACHE_DOWNLOAD)) \
                bNeedNewDir = TRUE; \
            else \
                goto exit;   \
        }while(0)

    hr = pTransCache->Retrieve();
    if (hr == S_OK) {
        hr = ValidateAssembly(_szDestManifest, _pName);
        if (hr == S_OK) {
            bEntryFound = TRUE;
        }
        else {
            hr = CScavenger::DeleteAssembly(pTransCache->GetCacheType(), _pCache->GetCustomPath(),
                                    pTransCache->_pInfo->pwzPath, TRUE);

            if (hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) ||
                hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) )
            {
                // Will try to copy assembly to new directory only at ASP.Net case.
                CHECK_IF_NEED_NEW_DIR;
            }   
        }
    }

    if(bEntryFound)
    {
        if(_dwCacheFlags & ASM_CACHE_DOWNLOAD)
        {
            hr = VerifyDuplicate(dwVerifyFlags, pTransCache);
            if(hr != S_OK)
                bReplaceBits = TRUE;
        }
        else if(_dwCacheFlags & ASM_CACHE_GAC)
        {
            // this function returns true if either the bits are newer or current bits are  corrupt.
            bReplaceBits = IsNewerFileVersion(_szManifest, _szDestManifest, &iNewer);
        }
        else if(_dwCacheFlags & ASM_CACHE_ZAP)
        {
            bReplaceBits = TRUE;
        }
    }

    if(bEntryFound)
    {
        if( bReplaceBits 
            || (!iNewer && (dwFlags & IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH)) // same file-version but still refresh
            || (dwFlags & IASSEMBLYCACHEITEM_COMMIT_FLAG_FORCE_REFRESH))  // don't care about file-versions! just overwrite
        {
            // if exists delete it.
            hr = CScavenger::DeleteAssembly(pTransCache->GetCacheType(), _pCache->GetCustomPath(),
                                    pTransCache->_pInfo->pwzPath, TRUE);

            if (hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) ||
                hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) )
            {
                // Will try to copy assembly to new directory only at ASP.Net case.
                CHECK_IF_NEED_NEW_DIR;
            }
        }
        else
        {
            // Create a transcache entry from name.
            // if (FAILED(hr = _pCache->TransCacheEntryFromName(_pName, _dwCacheFlags, &pTransCache)))
            if (FAILED(hr = _pCache->CreateTransCacheEntry(CTransCache::GetCacheIndex(_dwCacheFlags), &pTransCache)))
                goto exit;

            if(FAILED(hr = GetFusionInfo(pTransCache, _szDestManifest)))
                goto exit;


            pTransCache->_pInfo->pwzPath = WSTRDupDynamic(_szDestManifest);

            _pTransCache = pTransCache;
            pTransCache->AddRef();

            if(_dwCacheFlags & ASM_CACHE_DOWNLOAD)
            {
                if(FAILED(hr = GetManifestFileLock(_szDestManifest, &_hFile)))
                    goto exit;

                hr = DB_E_DUPLICATE;
            }
            else
                hr = S_FALSE;

            goto exit;
        }
    }

#define EXTRA_PATH_LEN sizeof("_65535")

    if (bNeedNewDir) 
    {
        DWORD dwPathLen = lstrlen(wzFullPath);
        LPWSTR pwzTmp = wzFullPath + lstrlen(wzFullPath); // end of wzFullPath
        WORD i;

        if ((dwPathLen + EXTRA_PATH_LEN ) > MAX_PATH) {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            goto exit;
        }

        for (i=0; i < 65535; i++)
        {
            wnsprintf(pwzTmp, EXTRA_PATH_LEN, L"_%d", i);
            if (GetFileAttributes(wzFullPath) == INVALID_FILE_ATTRIBUTES)
                break;
        }

        // fail after so many tries, let's fail.
        if (i >= 65535) {
            hr = HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION);
            goto exit;
        }
    }
        
    if(FAILED(hr = CreateFilePathHierarchy(wzFullPath)))
    {
        goto exit;
    }

    if(!MoveFile(_szDir, wzFullPath))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    StrCpy(_szManifest, wzFullPath);
    hr = PathAddBackslashWrap(_szManifest, MAX_PATH);
    if (FAILED(hr)) {
        goto exit;
    }
    StrCat(_szManifest, wzManifestFileName);

    StrCpy(_szDir, wzFullPath);

    if (bNeedNewDir) {
        // We change where the assembly will go. 
        // Let's update _szDestManifest
        wnsprintf(_szDestManifest, MAX_PATH, L"%s\\%s", wzFullPath, wzManifestFileName);
    }

    if(!g_bRunningOnNT)
    {
        DWORD dwFileSizeLow;

        if(FAILED(hr = StoreFusionInfo(_pName, _szDir, &dwFileSizeLow)))
        {
            goto exit;
        }
        else
        {
            AddStreamSize(dwFileSizeLow, 0); // add size of auxilary file to asm.
        }
    }

    hr = S_OK;

    if(_dwCacheFlags & ASM_CACHE_DOWNLOAD)
        hr = GetManifestFileLock(_szDestManifest, &_hFile);

    if(_pCache->GetCustomPath()) // delete older version of this assembly 
        FlushOldAssembly(_pCache->GetCustomPath(), wzFullPath, wzManifestFileName, FALSE);

exit:

    SAFERELEASE(pTransCache);
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::AbortItem
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyCacheItem::AbortItem()
{
        return S_OK;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::Commit
// ---------------------------------------------------------------------------
STDMETHODIMP CAssemblyCacheItem::Commit(
    /* [in] */ DWORD dwFlags,
    /* [out, optional] */ ULONG *pulDisposition)
{
    BOOL bDownLoadComplete = TRUE;
    CMutex  cCacheMutex(_bNeedMutex ? g_hCacheMutex : INVALID_HANDLE_VALUE);
    DWORD dwVerifyFlags = SN_INFLAG_INSTALL;

    if ((_dwCacheFlags & ASM_CACHE_GAC) || (_dwCacheFlags & ASM_CACHE_ZAP)) {
        dwVerifyFlags |= SN_INFLAG_ADMIN_ACCESS;
    }
    else {
        ASSERT(_dwCacheFlags & ASM_CACHE_DOWNLOAD);
        dwVerifyFlags |= SN_INFLAG_USER_ACCESS;
    }
    
    // Check to make sure there are no errors.
    if (_cStream)
        _hrError = E_UNEXPECTED;
    if (!_pName)
        _hrError = COR_E_MISSINGMANIFESTRESOURCE;
    if (FAILED(_hrError))
        goto exit;


    if(_bNeedMutex && _pTransCache)
    { // take mutex if we are modifing existing bits(incremental download).
        if(FAILED(_hrError = cCacheMutex.Lock()))
            goto exit;
    }

    // Commit the assembly to the index.    
    // BUGBUG: need to close window from AssemblyLookup where another
    // thread could commit assembly with the same name.
    if (FAILED(_hrError = CModuleHashNode::DoIntegrityCheck
        (_pStreamHashList, _pManifestImport, &bDownLoadComplete )))
        goto exit;

    if(_bNeedMutex && _pTransCache)
    {
        if(FAILED(_hrError = cCacheMutex.Unlock()))
            goto exit;
    }

    // check if all modules are in for GAC.
    if((_dwCacheFlags & ASM_CACHE_GAC) && (!bDownLoadComplete))
    {
        _hrError = FUSION_E_ASM_MODULE_MISSING;
        goto exit;
    }

    // for GAC check if DisplayName passed-in matches with manifest-def
    if( _pszAssemblyName && (_dwCacheFlags & ASM_CACHE_GAC))
    {
        _hrError = CompareInputToDef();

        if(_hrError != S_OK)
        {
            _hrError = FUSION_E_INVALID_NAME;
            goto exit;
        }
    }

    // Verify signature if strongly named assembly
    if (CCache::IsStronglyNamed(_pName) && !_pbCustom && _dwCacheFlags != ASM_CACHE_ZAP )
    {
        BOOL fWasVerified;
        if (!VerifySignature(_szManifest, &(fWasVerified = FALSE), dwVerifyFlags))
        {
            _hrError = FUSION_E_SIGNATURE_CHECK_FAILED;
            goto exit;
        }

    }

    // we are done with using ManifestImport. 
    // also releasing this helps un-lock assembly, needed for move.
    SAFERELEASE(_pManifestImport);
    DWORD dwFileSizeLow;

    if(!_pTransCache) // this asm is being added first time and not incremental download
    {
        // ** Create a transport cache entry **
        // For trans cache insertion we require codebase and last mod
    
        // Codebase
        _pName->SetProperty(ASM_NAME_CODEBASE_URL, (LPWSTR) _pszUrl, 
            _pszUrl ? (lstrlen(_pszUrl) + 1) * sizeof(WCHAR) : 0);

        // Codebase last modified time.
        _pName->SetProperty(ASM_NAME_CODEBASE_LASTMOD, &_ftLastMod, 
            sizeof(FILETIME));

        // Custom data. Set only if present, since we do not want to 
        // clear _fCustom accidentally.
        if (_pbCustom && _cbCustom)
            _pName->SetProperty(ASM_NAME_CUSTOM, _pbCustom, _cbCustom);

        if(g_bRunningOnNT)
        {
            if(FAILED(_hrError = StoreFusionInfo(_pName, _szDir, &dwFileSizeLow)))
            {
                goto exit;
            }
            else
            {
                AddStreamSize(dwFileSizeLow, 0); // add size of auxilary file to asm.
            }

        }
    }

    if( (_hrError = MoveAssemblyToFinalLocation(dwFlags, dwVerifyFlags )) != S_OK)
        goto exit;

    if((_hrError == S_OK) && (_dwCacheFlags & ASM_CACHE_DOWNLOAD) && (_pCache->GetCustomPath() == NULL) )
    {
        DoScavengingIfRequired( _cbCustom ? TRUE : FALSE);

        if(FAILED(_hrError = cCacheMutex.Lock()))
            goto exit;

        SetDownLoadUsage( TRUE, _dwAsmSizeInKB );

        if(FAILED(_hrError = cCacheMutex.Unlock()))
        {
            goto exit;
        }

    }

    if (_hrError == S_OK && (_dwCacheFlags & ASM_CACHE_GAC)) {
        UpdatePublisherPolicyTimeStampFile(_pName);
    }

    CleanupTempDir(_dwCacheFlags, _pCache->GetCustomPath());

exit:
    _bCommitDone = TRUE;        // Set final commit flag
    return _hrError;
}


//
// IUnknown boilerplate...
//

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::QI
// ---------------------------------------------------------------------------
STDMETHODIMP
CAssemblyCacheItem::QueryInterface(REFIID riid, void** ppvObj)
{
    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IAssemblyCacheItem)
       )
    {
        *ppvObj = static_cast<IAssemblyCacheItem*> (this);
        AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}

// Serialize access to _cRef even though this object is rental model
// w.r.t. to the client, but there may be multiple child objects which
// which can call concurrently.

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::AddRef
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCacheItem::AddRef()
{
    return InterlockedIncrement (&_cRef);
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::Release
// ---------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAssemblyCacheItem::Release()
{
    ULONG lRet = InterlockedDecrement (&_cRef);
    if (!lRet)
        delete this;
    return lRet;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::LockStreamHashList
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheItem::AddToStreamHashList(CModuleHashNode *pModuleHashNode)
{
    HRESULT                                 hr = S_OK;
    CCriticalSection                        cs(&g_csInitClb);
    
    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }
    pModuleHashNode->AddToList(&_pStreamHashList);
    
    cs.Unlock();

Exit:
    return hr;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::AddStreamSize
// ---------------------------------------------------------------------------
void CAssemblyCacheItem::AddStreamSize(ULONG dwFileSizeLow, ULONG dwFileSizeHigh)
{    
    static ULONG dwKBMask = (1023); // 1024-1
    ULONG   dwFileSizeInKB = dwFileSizeLow >> 10 ; // strip of 10 LSB bits to convert from bytes to KB.

    if(dwKBMask & dwFileSizeLow)
        dwFileSizeInKB++; // Round up to the next KB.

    if(dwFileSizeHigh)
    {
        // ASSERT ( dwFileSizeHigh < 1024 ) // OverFlow : Do something ??
        // BUGBUG check this arithmetic later !!  22 = 32(for DWORD) - 10(for KB)
        dwFileSizeInKB += (dwFileSizeHigh * (1 << 22) );
    }

    // BUGBUG : This is not supported in Win95, need to use some other locking !!
    // InterlockedExchangeAdd ( &_dwAsmSizeInKB, dwFileSizeInKB );
    _dwAsmSizeInKB += dwFileSizeInKB;
}

// ---------------------------------------------------------------------------
// CAssemblyCacheItem::SetCustomData
// ---------------------------------------------------------------------------
HRESULT CAssemblyCacheItem::SetCustomData(LPBYTE pbCustom, DWORD cbCustom) 
{    
    _pbCustom = MemDupDynamic(pbCustom, cbCustom);

    if (_pbCustom)
        _cbCustom = cbCustom;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\cacheutils.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "fusionP.h"
#include "cacheUtils.h"
#include "cache.h"
#include "shlobj.h"
#include "parse.h"
#include "util.h"
#include "disk.h"
#include "naming.h" // for MAX_VERSION_DISPLAY_SIZE
#include "lock.h"


extern CRITICAL_SECTION g_csInitClb;
#define REG_VAL_FUSION_CACHE_LOCATION    TEXT("CacheLocation")
#define FUSION_LOCAL_GAC_FILE            L"fusion.localgac"
DWORD g_cchWindowsDir;
WCHAR g_GACDir[MAX_PATH+1];
WCHAR g_ZapDir[MAX_PATH+1];
WCHAR g_DownloadDir[MAX_PATH+1];

LPCWSTR g_szFindAllMask = L"\\*";
LPCWSTR g_szDotDLL = L".dll";
LPCWSTR g_szDotEXE = L".exe";
LPCWSTR g_szDotCAB = L".cab";
LPCWSTR g_FusionInfoFile = L"__AssemblyInfo__.ini";

const WCHAR g_wzInvalidAsmNameChars[] = { L':', L'/', L'\\' };
#define INVALID_ASM_NAME_CHAR_LEN       ARRAYSIZE(g_wzInvalidAsmNameChars)

extern BOOL g_bRunningOnNT;
extern BOOL g_bRunningOnNT5OrHigher;

#define ASSEMBLY_INFO_STRING L"AssemblyInfo"
#define SIGNATURE_BLOB_KEY_STRING      L"Signature"
#define MVID_KEY_STRING                L"MVID"
#define CUSTOM_BLOB_STRING   L"CustomString"
#define URL_STRING           L"URL"
#define DISPLAY_NAME_STRING  L"DisplayName"
#define DEFAULT_INFO_STRING  L"__Default__"

BOOL g_bCheckedAccess = FALSE;
HRESULT FindAndSetObfuscatedDirectory();
HRESULT CreateObfuscatedDirectory();

BOOL IsCabFile(LPWSTR pszFileName)
{
    DWORD dwLen = lstrlenW(g_szDotCAB);

    ASSERT(pszFileName);

    DWORD dwFileLen = lstrlenW(pszFileName);

    if(dwFileLen < dwLen)
        return FALSE;

    if(FusionCompareStringI(pszFileName+dwFileLen-dwLen, g_szDotCAB))
        return FALSE;
    else return TRUE; // yes file name has .cab extension.

}

HRESULT GetCacheLoc(DWORD dwCacheFlags, LPWSTR *pszCacheLoc)
{
    HRESULT hr = S_OK;

    if((dwCacheFlags & ASM_CACHE_DOWNLOAD) && (g_bRunningOnNT))
    {
        if(!g_UserFusionCacheDir[0])
        {
            if(FAILED(hr = SetPerUserDownloadDir()))
                goto exit;
        }
        *pszCacheLoc = g_UserFusionCacheDir;
    }
    else
    {
        *pszCacheLoc = g_szWindowsDir;
    }

exit :
    return hr;
}

HRESULT SetGACDir()
{
    if( (lstrlen(g_szWindowsDir) + lstrlen(FUSION_CACHE_DIR_GAC_SZ) ) > MAX_PATH )
        return HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);

    StrCpy(g_GACDir, g_szWindowsDir);
    PathRemoveBackslash(g_GACDir);
    StrCat(g_GACDir, FUSION_CACHE_DIR_GAC_SZ);

    return S_OK;
}

HRESULT GetGACDir(LPWSTR *pszGACDir)
{
    HRESULT hr = S_OK;
    
    if(!g_GACDir[0])
        hr = SetGACDir();

    *pszGACDir = g_GACDir;
    return hr;
}

HRESULT SetZapDir()
{
    HRESULT hr = S_OK;
    WCHAR   szCorVer[MAX_PATH+1];
    DWORD   cchCorVer=MAX_PATH;

    if(FAILED(hr = GetCORVersion(szCorVer, &cchCorVer)))
        goto exit;

    if( (lstrlen(g_szWindowsDir) + cchCorVer + lstrlen(FUSION_CACHE_DIR_ZAP_SZ) ) > MAX_PATH )
        return HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);

    StrCpy(g_ZapDir, g_szWindowsDir);
    StrCat(g_ZapDir, FUSION_CACHE_DIR_ZAP_SZ);
    StrCat(g_ZapDir, szCorVer);

exit :

    return hr;
}

HRESULT GetZapDir(LPWSTR *pszZapDir)
{
    HRESULT hr = S_OK;
    
    if(!g_ZapDir[0])
        hr = SetZapDir();

    *pszZapDir = g_ZapDir;
    return hr;
}

HRESULT SetDownLoadDir()
{
    HRESULT hr = S_OK;
    LPWSTR pszCacheLoc = NULL;
    CCriticalSection cs(&g_csInitClb);

    if (g_DownloadDir[0] == L'\0') {
        hr = cs.Lock();
        if (FAILED(hr)) {
            return hr;
        }
    
        if (g_DownloadDir[0] == L'\0') {
            if(FAILED(hr = GetCacheLoc(ASM_CACHE_DOWNLOAD, &pszCacheLoc))) {
                cs.Unlock();
                goto exit;
            }
        
            if( (lstrlen(pszCacheLoc) + lstrlen(FUSION_CACHE_DIR_DOWNLOADED_SZ)) > MAX_PATH )
            {
                cs.Unlock();
                hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
                goto exit;
            }
        
            StrCpy(g_DownloadDir, pszCacheLoc);
            PathRemoveBackslash(g_DownloadDir);
            StrCat(g_DownloadDir, FUSION_CACHE_DIR_DOWNLOADED_SZ);
        
            hr = PathAddBackslashWrap(g_DownloadDir, MAX_PATH);
            if (FAILED(hr)) {
                cs.Unlock();
                goto exit;
            }
            
            hr = FindAndSetObfuscatedDirectory();
            if (FAILED(hr)) {
                cs.Unlock();
                goto exit;
            }
        }

        cs.Unlock();
    }

exit :

    return hr;
}

#define CACHE_LOCATION_FILE                  L"\\fusioncache.dat"
#define INI_SECTION_FUSION                   L"Fusion"
#define INI_KEY_NAME                         L"CacheLocation"

HRESULT FindAndSetObfuscatedDirectory()
{
    HRESULT                          hr = S_OK;
    WCHAR                            pwzCacheLocFile[MAX_PATH];
    WCHAR                            pwzUserDir[MAX_PATH];
    WCHAR                            pwzBuf[MAX_PATH];
    DWORD                            cbSize;
    BOOL                             bFound;

    hr = CreateCacheMutex();
    if (FAILED(hr)) {
        return hr;
    }

    CMutex                           cCacheMutex(g_hCacheMutex);

    // Build location to cache location file
    
    hr = FusionGetUserFolderPath(pwzUserDir);
    if (FAILED(hr)) {
        goto Exit;
    }

    PathRemoveBackslash(pwzUserDir);

    if (wnsprintfW(pwzCacheLocFile, MAX_PATH, L"%ws%ws", pwzUserDir, CACHE_LOCATION_FILE) < 0) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Extract cache location from file
    
    
    hr = cCacheMutex.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    bFound = TRUE;
    
    cbSize = GetPrivateProfileString(INI_SECTION_FUSION, INI_KEY_NAME, DEFAULT_INFO_STRING,
                                     pwzBuf, MAX_PATH, pwzCacheLocFile);
    if (cbSize == MAX_PATH - 1 || !FusionCompareString(DEFAULT_INFO_STRING, pwzBuf)) {
        // Couldn't find / read the cache location. 

        bFound = FALSE;
    }
    else {
        // Found the cache location. Make sure it's valid.

        hr = PathAddBackslashWrap(pwzUserDir, MAX_PATH);
        if (FAILED(hr)) {
            cCacheMutex.Unlock();
            goto Exit;
        }

        if (FusionCompareStringN(g_DownloadDir, pwzBuf, lstrlenW(g_DownloadDir))) {
            bFound = FALSE;
        }
        else {
            lstrcpyW(g_DownloadDir, pwzBuf);
        }
    }

    if (!bFound) {
        // Create directory, since we can't find it (or it's invalid)
    
        hr = CreateObfuscatedDirectory();
        if (FAILED(hr)) {
            cCacheMutex.Unlock();
            goto Exit;
        }
    
        ASSERT(lstrlenW(g_DownloadDir));
    
        if (!WritePrivateProfileString(INI_SECTION_FUSION, INI_KEY_NAME, g_DownloadDir,
                                       pwzCacheLocFile)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            cCacheMutex.Unlock();
            goto Exit;
        }
    }

    cCacheMutex.Unlock();

Exit:
    return hr;
}

#define DOWNLOAD_CACHE_OBFUSCATION_LENGTH             15

HRESULT CreateObfuscatedDirectory()
{
    HRESULT                                 hr = S_OK;
    HCRYPTPROV                              hProv;
    LPWSTR                                  pwzRandom = NULL;
    BYTE                                    bBuffer[DOWNLOAD_CACHE_OBFUSCATION_LENGTH];

    if (!CryptAcquireContextA(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    if (!CryptGenRandom(hProv, DOWNLOAD_CACHE_OBFUSCATION_LENGTH, bBuffer)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = Base32Encode(bBuffer, DOWNLOAD_CACHE_OBFUSCATION_LENGTH, &pwzRandom);
    if (FAILED(hr)) {
        goto Exit;
    }
    
    // Obfuscation directory name is of the 8.3 format:

    if (lstrlenW(g_DownloadDir) + lstrlenW(L"12345678.123\\12345678.123") + 1 >= MAX_PATH) {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto Exit;
    }

    StrNCat(g_DownloadDir, pwzRandom, 9);
    StrCat(g_DownloadDir, L".");
    StrNCat(g_DownloadDir, pwzRandom + 8, 4);
    
    StrCat(g_DownloadDir, L"\\");

    StrNCat(g_DownloadDir, pwzRandom + 11, 9);
    StrCat(g_DownloadDir, L".");
    StrNCat(g_DownloadDir, pwzRandom + 19, 4);

Exit:
    SAFEDELETEARRAY(pwzRandom);
    CryptReleaseContext(hProv, 0);
    
    return hr;
}

HRESULT GetDownloadDir(LPWSTR *pszDownLoadDir)
{
    HRESULT hr = S_OK;

    if((hr = SetDownLoadDir()) != S_OK)
        return hr;

    *pszDownLoadDir = g_DownloadDir;
    return hr;
}

BOOL IsGACWritable()
{
    CheckAccessPermissions();
    return (g_CurrUserPermissions == READ_WRITE) ? TRUE : FALSE;
}


HRESULT SetPerUserDownloadDir()
{
    HRESULT hr = S_OK;
    TCHAR pszUserDir[MAX_PATH+1];
    CCriticalSection cs(&g_csInitClb);

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    hr = FusionGetUserFolderPath(pszUserDir);
    if (FAILED(hr)) {
        cs.Unlock();
        goto Exit;
    }

    StrCpy(g_UserFusionCacheDir, pszUserDir);
    cs.Unlock();

Exit:
    return hr;
}

#define TEMP_RANDOM_DIR_LENGTH (16)
HRESULT GetCacheLocationFromReg()
{
    HRESULT     hr = S_OK;
    DWORD       dwSize=0;
    DWORD       dwType=0;
    DWORD       lResult=0;
    HKEY        hkey=0;
    DWORD       dwBufSize;
    WCHAR       szBuf[MAX_PATH+1];

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_FUSION_SETTINGS, 0, KEY_READ, &hkey);
    if(lResult == ERROR_SUCCESS) 
    {
        dwBufSize = MAX_PATH * sizeof(TCHAR);
        lResult = RegQueryValueEx(hkey, REG_VAL_FUSION_CACHE_LOCATION, NULL,
                                  &dwType, (LPBYTE)szBuf, &dwBufSize);

        if ((lResult != ERROR_SUCCESS) || (dwType != REG_SZ) || (!dwBufSize) )
        {
            hr = E_FAIL;
            goto exit;
        }
        else
        {
            if(!PathCanonicalize(g_szWindowsDir, szBuf))
            {
                hr = E_FAIL;
                goto exit;
            }
            else
            {
                g_cchWindowsDir = lstrlen(g_szWindowsDir);

                if(g_cchWindowsDir && (g_szWindowsDir[g_cchWindowsDir - 1] == DIR_SEPARATOR_CHAR))
                    g_szWindowsDir[g_cchWindowsDir - 1] = L'\0'; // remove trailing "\"
            }
        }
    }


    // cache location cannot be = MAX_PATH; that won't leave any space for fusion dirs.
    if ((g_cchWindowsDir + TEMP_RANDOM_DIR_LENGTH)>= (MAX_PATH/2) )
    {
        hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
        goto exit;
    }


    g_cchWindowsDir = lstrlen(g_szWindowsDir);

    if(GetFileAttributes(g_szWindowsDir) != -1)
        goto exit;

    if(SUCCEEDED(hr = CreateFilePathHierarchy(g_szWindowsDir)))
    {
        if(!CreateDirectory(g_szWindowsDir, NULL))
            hr = FusionpHresultFromLastError();
    }

exit:

    if (hkey) {
        RegCloseKey(hkey);
    }

    return hr;
}

HRESULT SetCurrentUserPermissions()
{
    HRESULT     hr = E_FAIL;
    DWORD       dwFileAttrib = 0;
    DWORD       cchSize = MAX_PATH;
    HANDLE      hUserToken = NULL;
    WCHAR       wzLocalGACPath[MAX_PATH];
    LPWSTR      pwzFileName;
    DWORD       dwAttr;
    CCriticalSection cs(&g_csInitClb);

    hr = GetCacheLocationFromReg();

    if(FAILED(hr))
    {
        hr = cs.Lock();
        if (FAILED(hr)) {
            goto Exit;
        }

        g_cchWindowsDir = ::GetRealWindowsDirectory(g_szWindowsDir, NUMBER_OF(g_szWindowsDir));

        cs.Unlock();
    }

    // Override registry setting if there is an "fusion.localgac" file
    // under the path where fusion.dll is found

    lstrcpyW(wzLocalGACPath, g_FusionDllPath);

    pwzFileName = PathFindFileName(wzLocalGACPath);
    ASSERT(pwzFileName);
    *pwzFileName = '\0';

    wnsprintfW(wzLocalGACPath, MAX_PATH, L"%s%s", wzLocalGACPath, FUSION_LOCAL_GAC_FILE);
    dwAttr = GetFileAttributes(wzLocalGACPath);
    if (dwAttr != -1 && !(dwAttr & FILE_ATTRIBUTE_DIRECTORY)) {
        *pwzFileName = '\0';
        lstrcpyW(g_szWindowsDir, wzLocalGACPath);
        g_cchWindowsDir = lstrlenW(g_szWindowsDir);
    }

    // Woah, the windows dir is longer than MAX_PATH??
    ASSERT((g_cchWindowsDir + TEMP_RANDOM_DIR_LENGTH) < NUMBER_OF(g_szWindowsDir));

    if (g_cchWindowsDir == 0)
    {
        hr = FusionpHresultFromLastError();
        goto Exit;
    }

    // SetGACDir();
    // SetZapDir();

    // GetNamedSecurityInfo works only for NTFS....
    // Trying to createDir to see if we have permissions.... 
    // This is crude. temp hack, need to find a better way...
    /*
    dwFileAttrib = GetFileAttributes( g_szWindowsDir );

    if (dwFileAttrib == -1)
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto Exit;
         // dwFileAttrib & FILE_ATTRIBUTE_READONLY)

    }
    */

Exit:
    return hr;
}

HRESULT CheckAccessPermissions()
{
    HRESULT                              hr = S_OK;
    CCriticalSection                     cs(&g_csInitClb);
    WCHAR                                pszTempDir[MAX_PATH+1];
    DWORD                                dwLen;

    if (g_bCheckedAccess)  {
        goto Exit;
    }

    hr = cs.Lock();
    if (FAILED(hr)) {
        goto Exit;
    }

    if (g_bCheckedAccess) {
        cs.Unlock();
        goto Exit;
    }

    StrCpy(pszTempDir, g_szWindowsDir);
    hr = PathAddBackslashWrap(pszTempDir, MAX_PATH);
    if (FAILED(hr)) {
        cs.Unlock();
        goto Exit;
    }
    dwLen = lstrlenW(pszTempDir);

    if (dwLen + TEMP_RANDOM_DIR_LENGTH + 1 >= MAX_PATH) {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        cs.Unlock();
        goto Exit;
    }

    int i;
    for (i = 0; i < MAX_RANDOM_ATTEMPTS; i++) {
        GetRandomName(pszTempDir + dwLen, TEMP_RANDOM_DIR_LENGTH); // create random dir of 15 chars.
        
        if (CreateDirectory(pszTempDir, NULL)) {
            g_CurrUserPermissions = READ_WRITE;
            g_GAC_AccessMode = READ_WRITE;
    
            if(!RemoveDirectory(pszTempDir))
            {
                // ASSERT(0); // oops we left a random  dir in winDir
            }

            break;
        }
        else {
            if (GetLastError() == ERROR_ALREADY_EXISTS) {
                continue;
            }

            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    }
    
    if (i >= MAX_RANDOM_ATTEMPTS) {
        hr = E_UNEXPECTED;
        cs.Unlock();
        goto Exit;
    }

    g_bCheckedAccess = TRUE;
    cs.Unlock();
    
Exit:
    return hr;
}
/*
HRESULT GetCacheLocFromType(DWORD dwCacheType, LPWSTR *ppszCacheLoc)
{
    HRESULT hr;

    switch(dwCacheType)
    {
    case ASM_CACHE_DOWNLOAD:
        hr = GetDownloadDir(ppszCacheLoc);
        break;

    case ASM_CACHE_ZAP:
        hr = GetZapDir(ppszCacheLoc);
        break;

    case ASM_CACHE_GAC:
        hr = GetGACDir(ppszCacheLoc);
        break;

    default :
        hr = E_FAIL;
        break;
    };

    return hr;
}

HRESULT GetTempDBPath(LPTSTR pszFileName, LPTSTR pszFullPathBuf, DWORD cchBufSize)
{
    HRESULT hr = S_OK;
    LPWSTR pszCacheLoc = NULL;
    LPWSTR pszDirName  =  FUSION_CACHE_DIR_DOWNLOADED_SZ;

    if(FAILED(hr = GetDownloadDir(&pszCacheLoc)))
        goto exit;

    StrCpy(pszFullPathBuf, pszCacheLoc);
    PathAddBackslash(pszFullPathBuf);
    StrCat(pszFullPathBuf, pszDirName);
    PathAddBackslash(pszFullPathBuf);
    StrCat(pszFullPathBuf, pszFileName);

exit:
    return hr;

}

*/

HRESULT GetAssemblyStagingPath(LPCTSTR pszCustomPath, DWORD dwCacheFlags,
                               BOOL bUser, LPTSTR pszPath, DWORD *pcchSize)
{
    HRESULT hr = S_OK;
    LPTSTR pszCacheLoc = NULL;

    ASSERT(pcchSize);

    if (pszCustomPath != NULL)
    {
        // Use custom path as the base
        StrCpy(pszPath, pszCustomPath);
    }
    else
    {
        if(FAILED(hr = GetCacheLoc(dwCacheFlags, &pszCacheLoc)))
            goto exit;

        // Else use the default
        StrCpy(pszPath, pszCacheLoc);
    }

    // check for buffer overflow
    if( ((DWORD)(lstrlenW(pszPath) + lstrlenW(FUSION_CACHE_STAGING_DIR_SZ) + 10))
           > (*pcchSize))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto exit;
    }

    PathRemoveBackslash(pszPath);
    StrCat(pszPath, FUSION_CACHE_STAGING_DIR_SZ);
    hr = PathAddBackslashWrap(pszPath, *pcchSize);
    if (FAILED(hr)) {
        goto exit;
    }

    hr = CreateDirectoryForAssembly(8, pszPath, pcchSize);

exit :
    return hr;
}

HRESULT GetPendingDeletePath(LPCTSTR pszCustomPath, DWORD dwCacheFlags,
                               LPTSTR pszPath, DWORD *pcchSize)
{
    HRESULT hr = S_OK;
    LPTSTR pszCacheLoc = NULL;

    if (pszCustomPath != NULL)
    {
        // Use custom path as the base
        StrCpy(pszPath, pszCustomPath);
    }
    else
    {
        if(FAILED(hr = GetCacheLoc(dwCacheFlags, &pszCacheLoc)))
            goto exit;

        // Else use the default
        StrCpy(pszPath, pszCacheLoc);
    }

    StrCat(pszPath, FUSION_CACHE_PENDING_DEL_DIR_SZ);

exit:
    return hr;
}

HRESULT CreateAssemblyDirPath( LPCTSTR pszCustomPath, DWORD dwInstaller, DWORD dwCacheFlags,
                               BOOL bUser, LPTSTR pszPath, DWORD *pcchSize)
{
    HRESULT hr = S_OK;
    LPWSTR pszCacheLoc = NULL;

    // ASSERT Buf size....
    // ASSERT dwInstaller and g_CurrUserPermissions == READ_ONLY ??

    if (dwCacheFlags & ASM_CACHE_GAC)
    {
        hr = GetGACDir(&pszCacheLoc);
        if(hr != S_OK)
            goto exit;
        StrCpy(pszPath, pszCacheLoc);
    }
    else if(dwCacheFlags & ASM_CACHE_ZAP)
    {
        hr = GetZapDir(&pszCacheLoc);
        if(hr != S_OK)
            goto exit;
        StrCpy(pszPath, pszCacheLoc);
    }
    else if (dwCacheFlags & ASM_CACHE_DOWNLOAD)
    {
        if (pszCustomPath != NULL)
        {
            // Use custom path as the base
            StrCpy(pszPath, pszCustomPath);
            StrCat(pszPath, FUSION_CACHE_DIR_DOWNLOADED_SZ);
        }
        else
        {
            // Else use the default
            hr = GetDownloadDir(&pszCacheLoc);
            if(hr != S_OK)
                goto exit;
            StrCpy(pszPath, pszCacheLoc);
        }
    }
    else
    {
        // Assert;
    }

exit :

    return hr;
}

HRESULT GetCachePath(ASM_CACHE_FLAGS dwCacheFlags, LPWSTR pwzCachePath, PDWORD pcchPath)
{
    HRESULT hr = S_OK;
    LPWSTR  pszTemp = NULL;
    DWORD dwLen=0;

    if( !pcchPath || !dwCacheFlags || (dwCacheFlags & (dwCacheFlags-1)))
        return E_INVALIDARG;

    if(dwCacheFlags & ASM_CACHE_ZAP)
    {
        hr = GetZapDir(&pszTemp);
    }
    else if(dwCacheFlags & ASM_CACHE_GAC)
    {
        hr = GetGACDir(&pszTemp);
    }
    else if(dwCacheFlags & ASM_CACHE_DOWNLOAD)
    {
        hr = GetDownloadDir(&pszTemp);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if(FAILED(hr))
        goto exit;

    dwLen = lstrlen(pszTemp);

    if(pwzCachePath && (*pcchPath > dwLen))
    {
        StrCpy(pwzCachePath, pszTemp);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    *pcchPath = dwLen+1;

exit :

    return hr;
}

HRESULT VerifySignatureHelper(CTransCache *pTC, DWORD dwVerifyFlags)
{
    HRESULT hr = S_OK;
    BOOL fWasVerified;

    if (!VerifySignature( pTC->_pInfo->pwzPath, 
            &(fWasVerified = FALSE), dwVerifyFlags))
    {
        hr = FUSION_E_SIGNATURE_CHECK_FAILED;
        goto exit;
    }

exit :

    return hr;
}

LPWSTR GetManifestFileNameFromURL(LPWSTR pszURL)
{
    LPWSTR pszTemp = NULL;

    pszTemp = StrRChr(pszURL, NULL, URL_DIR_SEPERATOR_CHAR);
    if(pszTemp && (lstrlenW(pszTemp) > 1))
    {
        // +1 is to avoid "/" char
        return (pszTemp + 1);
    }

    return NULL;
}

HRESULT GetDLParentDir(LPWSTR pszURL, LPWSTR pszParentDir)
{
    if(!pszURL)
        return S_FALSE;

    DWORD dwHash = GetStringHash(pszURL);
    // Convert to unicode.
    CParseUtils::BinToUnicodeHex( (PBYTE) &dwHash, sizeof(DWORD), pszParentDir);
    pszParentDir[DWORD_STRING_LEN] = L'\0';

    return S_OK;
}

VOID GetDLAsmDir(LPFILETIME pftLastMod, LPWSTR pszSubDirName)
{
    DWORD dwLen = DWORD_STRING_LEN;

    ASSERT(pftLastMod && pszSubDirName);
    CParseUtils::BinToUnicodeHex((LPBYTE)&(pftLastMod->dwLowDateTime), sizeof(DWORD), pszSubDirName);
    pszSubDirName[dwLen] = ATTR_SEPARATOR_CHAR;
    CParseUtils::BinToUnicodeHex((LPBYTE)&(pftLastMod->dwHighDateTime), sizeof(DWORD), pszSubDirName+dwLen+1);
    pszSubDirName[2*dwLen+1] = L'\0';

}

HRESULT ParseDLAsmDir(LPWSTR pszAsmDir, LPFILETIME pftLastMod)
{
    ASSERT(pftLastMod);

    DWORD dwLen = DWORD_STRING_LEN;

    if((lstrlenW(pszAsmDir) != (dwLen*2 + 1)) || (pszAsmDir[dwLen] != ATTR_SEPARATOR_CHAR))
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

    CParseUtils::UnicodeHexToBin(pszAsmDir, dwLen, (LPBYTE) &(pftLastMod->dwLowDateTime));
    CParseUtils::UnicodeHexToBin(pszAsmDir + dwLen + 1, dwLen, (LPBYTE) &(pftLastMod->dwHighDateTime));

    return S_OK;
}


HRESULT GetAssemblyParentDir( CTransCache *pTransCache, LPWSTR pszParentDir)
{
    HRESULT hr=S_OK;
    DWORD dwCache;

    ASSERT(pTransCache);
    dwCache = pTransCache->GetCacheType();

    if((dwCache & ASM_CACHE_GAC) || (dwCache & ASM_CACHE_ZAP) )
    {
        if(pTransCache->_pInfo->pwzName)
            StrCpy(pszParentDir, pTransCache->_pInfo->pwzName);
        else
            hr = S_FALSE;
    }
    else if(dwCache & ASM_CACHE_DOWNLOAD)
    {
        hr = GetDLParentDir(pTransCache->_pInfo->pwzCodebaseURL, pszParentDir);
    }
    else ASSERT(0);

    return hr;
}

HRESULT ParseAsmDir(LPWSTR pszAsmDir, CTransCache *pTC)
{
    HRESULT hr=S_OK;
    TRANSCACHEINFO *pTCInfo = pTC->_pInfo;
    DWORD dwCache = 0;
    WCHAR wzDirName[MAX_PATH+1];
    LPWSTR pwzTemp=NULL, pwzStringLeft=NULL,pwzCulture=NULL ;
    DWORD dwLen =0;
    WORD    wVerA, wVerB, wVerC, wVerD;
    PBYTE lpByte=NULL;

    ASSERT(pTC);

    pTCInfo = pTC->_pInfo;

    StrCpy(wzDirName, pszAsmDir);
    pwzStringLeft = wzDirName;

    pwzTemp = StrChrW(pwzStringLeft, ATTR_SEPARATOR_CHAR);
    if(!pwzTemp)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    *pwzTemp = '\0';
    hr = VersionFromString(pwzStringLeft, &wVerA, &wVerB, &wVerC, &wVerD);
    if(FAILED(hr))
        goto exit;

    pTCInfo->dwVerHigh  = MAKELONG(wVerB, wVerA);
    pTCInfo->dwVerLow = MAKELONG(wVerD, wVerC);

    pwzStringLeft = ++pwzTemp;
    pwzTemp = StrChrW(pwzStringLeft, ATTR_SEPARATOR_CHAR);
    if(!pwzTemp)
    {
        hr = E_UNEXPECTED;
        goto exit;
    }
    *pwzTemp = '\0';
    dwLen = lstrlenW(pwzStringLeft)+1;
    pwzCulture = NEW(WCHAR[dwLen]);
    if(!pwzCulture)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    StrCpy(pwzCulture, pwzStringLeft);
 
    pwzStringLeft = ++pwzTemp;
    pwzTemp = StrChrW(pwzStringLeft, ATTR_SEPARATOR_CHAR);
    if(pwzTemp)
    {
        *pwzTemp = '\0';
        // we don't parse beyond this point.
    }
    dwLen = lstrlenW(pwzStringLeft)/2;
    if(dwLen)
    {
        lpByte = NEW(BYTE[dwLen]);

        if(!lpByte)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        CParseUtils::UnicodeHexToBin(pwzStringLeft, lstrlenW(pwzStringLeft), lpByte );
    }
    pTCInfo->blobPKT.pBlobData = lpByte; lpByte = NULL;
    pTCInfo->blobPKT.cbSize = dwLen ;
    pTCInfo->pwzCulture  = pwzCulture; pwzCulture = NULL;

exit:

    SAFEDELETEARRAY(lpByte);
    SAFEDELETEARRAY(pwzCulture);

    return hr;
}

HRESULT ParseDirName( CTransCache *pTransCache, LPWSTR pszParentDir, LPWSTR pszAsmDir)
{
    HRESULT hr=S_OK;
    DWORD dwCache = 0;

    ASSERT(pTransCache && pszParentDir && pszAsmDir);

    dwCache = pTransCache->GetCacheType();

    ASSERT(lstrlenW(pszAsmDir) < MAX_PATH);

    if((dwCache & ASM_CACHE_GAC) || (dwCache & ASM_CACHE_ZAP))
    {
        pTransCache->_pInfo->pwzName = WSTRDupDynamic(pszParentDir);
        hr = ParseAsmDir(pszAsmDir, pTransCache);
    }
    else if(dwCache & ASM_CACHE_DOWNLOAD)
    {
        hr = ParseDLAsmDir(pszAsmDir, &(pTransCache->_pInfo->ftLastModified));
    }
    else ASSERT(0);

    return hr;
}

HRESULT GetDLDirsFromName(IAssemblyName *pName, LPWSTR pszParentDir, LPWSTR pszSubDirName)
{
    HRESULT hr = S_OK;
    LPWSTR  pwzCodebaseURL=NULL;
    FILETIME ftLastMod;
    DWORD   cb=0;

    ASSERT(pName && pszParentDir && pszSubDirName);

    if(FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CODEBASE_URL,
        (LPBYTE*) &pwzCodebaseURL, &(cb = 0))))
        goto exit;

    hr = GetDLParentDir(pwzCodebaseURL, pszParentDir);

    if(FAILED(hr = pName->GetProperty(ASM_NAME_CODEBASE_LASTMOD,
        &ftLastMod, &(cb = sizeof(FILETIME)))))
        goto exit;

    GetDLAsmDir(&ftLastMod, pszSubDirName);

exit :
    SAFEDELETE(pwzCodebaseURL);
    return hr;
}

HRESULT ValidateAsmInstallFolderChars(LPWSTR pszFolderName)
{
    HRESULT hr = S_OK;
    int     iCnt;

    if(!pszFolderName) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    for(iCnt = 0; iCnt < INVALID_ASM_NAME_CHAR_LEN; iCnt++) {
        if(StrChrW(pszFolderName, g_wzInvalidAsmNameChars[iCnt])) {
            hr = FUSION_E_INVALID_NAME;
            break;
        }
    }

Exit:

    return hr;
}

HRESULT GetAsmDir(LPWSTR pszSubDirName, DWORD dwCache, DWORD dwVerHigh, DWORD dwVerLow, 
                  LPWSTR pszCulture, PBYTE pPKT, DWORD cbPKT, PBYTE pCustom, DWORD cbCustom)
{
    HRESULT hr = S_OK;
    DWORD dwLen;

    ASSERT(pszSubDirName && pszCulture); //  && pPKT);
    if( (MAX_VERSION_DISPLAY_SIZE + lstrlen(pszCulture) + 
                    (cbPKT * 2) + (cbCustom*2) + 4) > MAX_PATH )
    {
        hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
        goto exit;
    }

    wnsprintfW(pszSubDirName, MAX_PATH, L"%d.%d.%d.%d",
           HIWORD(dwVerHigh), LOWORD(dwVerHigh),
           HIWORD(dwVerLow), LOWORD(dwVerLow));

    dwLen = lstrlen(pszSubDirName);
    wnsprintfW(pszSubDirName+dwLen, MAX_PATH, L"_%s_", pszCulture);

    dwLen = lstrlen(pszSubDirName);

    // Convert to unicode.
    CParseUtils::BinToUnicodeHex(pPKT, cbPKT, pszSubDirName+dwLen);
    dwLen += cbPKT * 2;

    if(dwCache & ASM_CACHE_ZAP)
    {
        ASSERT(pCustom);
        StrCpy(pszSubDirName+dwLen, L"_");
        dwLen++;

        DWORD dwHash = GetBlobHash(pCustom, cbCustom);
        // Convert to unicode.
        CParseUtils::BinToUnicodeHex( (PBYTE) &dwHash, sizeof(DWORD), pszSubDirName+dwLen);
        dwLen += DWORD_STRING_LEN;
    }
    pszSubDirName[dwLen] = L'\0'; 

    hr = ValidateAsmInstallFolderChars(pszSubDirName);
    if(FAILED(hr)) {
        goto exit;
    }

exit :
    return hr;
}

HRESULT GetCacheDirsFromName(IAssemblyName *pName,
    DWORD dwFlags, LPWSTR pszParentDirName, LPWSTR pszSubDirName)
{
    HRESULT hr = S_OK;
    DWORD   dwVerHigh=0;
    DWORD   dwVerLow=0;
    LPWSTR  pszTextName=NULL;
    DWORD   cb=0;
    PBYTE   pPKT=NULL;
    PBYTE   pCustom=NULL;
    DWORD   cbCustom=0;
    DWORD   cbPKT=0;
    LPWSTR  wzCulture=NULL;
    LPWSTR  szProp=NULL;
    DWORD ccProp=0;
    DWORD dwLen=0;

    ASSERT(pName && dwFlags && pszParentDirName && pszSubDirName);

    if( (dwFlags & ASM_CACHE_GAC) || (dwFlags & ASM_CACHE_ZAP) )
    {
        if (FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_NAME,
                (LPBYTE*) &pszTextName, &(cb = 0))))
            goto exit;

        if(cb > MAX_PATH)
        {
            hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
            goto exit;
        }

        StrCpy(pszParentDirName, pszTextName);

        // Version
        if(FAILED(hr = pName->GetVersion(&dwVerHigh, &dwVerLow)))
            goto exit;

        // Culture
        if(FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CULTURE, (LPBYTE*) &wzCulture, &cb)))
            goto exit;

        // PublicKeyToken
        if(FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_PUBLIC_KEY_TOKEN, &pPKT, &cbPKT)))
            goto exit;

        if (dwFlags & ASM_CACHE_ZAP)
        {
            if(FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CUSTOM, 
                            &pCustom, &(cbCustom = 0))))
                goto exit;
        }

        hr = GetAsmDir(pszSubDirName, dwFlags, dwVerHigh, dwVerLow, 
                        wzCulture, pPKT, cbPKT, 
                        pCustom, cbCustom);


    }
    else if (dwFlags & ASM_CACHE_DOWNLOAD)
    {
        GetDLDirsFromName(pName, pszParentDirName, pszSubDirName);
    }

exit:

    SAFEDELETE(szProp);
    SAFEDELETE(wzCulture);
    SAFEDELETE(pPKT);
    SAFEDELETE(pCustom);
    SAFEDELETE(pszTextName);

    return hr;
}


HRESULT GetCacheDirsFromTransCache(CTransCache *pTransCache, 
    DWORD dwFlags, LPWSTR pszParentDirName, LPWSTR pszSubDirName)
{
    HRESULT hr = S_OK;
    TRANSCACHEINFO *pTCInfo = NULL;
    DWORD dwCache = pTransCache->GetCacheType();

    pTCInfo = (TRANSCACHEINFO*) pTransCache->_pInfo;
    if((dwCache & ASM_CACHE_GAC) || (dwCache & ASM_CACHE_ZAP) )
    {
        if(lstrlenW(pTCInfo->pwzName) >= MAX_PATH)
        {
            hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
            goto exit;
        }

        StrCpy(pszParentDirName, pTCInfo->pwzName);

        hr = GetAsmDir(pszSubDirName, dwCache, pTCInfo->dwVerHigh, pTCInfo->dwVerLow, 
                        pTCInfo->pwzCulture, pTCInfo->blobPKT.pBlobData, pTCInfo->blobPKT.cbSize, 
                        pTCInfo->blobCustom.pBlobData, pTCInfo->blobCustom.cbSize);
    }
    else if(dwCache & ASM_CACHE_DOWNLOAD)
    {
        hr = GetDLParentDir(pTCInfo->pwzCodebaseURL, pszParentDirName);
        GetDLAsmDir(&(pTCInfo->ftLastModified), pszSubDirName);
    }

exit:

    return hr;
}

HRESULT RetrieveFromFileStore( CTransCache *pTransCache )
{
    HRESULT hr=S_OK;
    TRANSCACHEINFO *pTCInfo = NULL;
    DWORD dwCache = 0;
    WCHAR wzParentDirName[MAX_PATH+1];
    WCHAR wzSubDirName[MAX_PATH+1];
    LPWSTR pwzTemp=NULL, pwzStringLeft=NULL,pwzCulture=NULL ;
    DWORD dwLen =0;
    WCHAR wzCacheLocation[MAX_PATH+1];
    ASSERT(pTransCache);
    DWORD dwCacheType = pTransCache->GetCacheType();

    pTCInfo = (TRANSCACHEINFO*) pTransCache->_pInfo;
    dwCache = pTransCache->GetCacheType();

    dwLen = MAX_PATH;
    if(FAILED(hr = CreateAssemblyDirPath( pTransCache->GetCustomPath(), 0, pTransCache->GetCacheType(),
                                           0, wzCacheLocation, &dwLen)))
        goto exit;

    hr = GetCacheDirsFromTransCache(pTransCache, 0, wzParentDirName, wzSubDirName);
    if(FAILED(hr))
        goto exit;

    if( (lstrlenW(wzCacheLocation) + lstrlenW(wzParentDirName) + lstrlenW(wzSubDirName) +
            lstrlenW(g_szDotDLL) + max(lstrlenW(wzParentDirName), lstrlen(pTCInfo->pwzName)) + 4) >= MAX_PATH)
    {
        hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
        goto exit;
    }

    hr = PathAddBackslashWrap(wzCacheLocation, MAX_PATH);
    if (FAILED(hr)) {
        goto exit;
    }
    StrCat(wzCacheLocation, wzParentDirName);
    hr = PathAddBackslashWrap(wzCacheLocation, MAX_PATH);
    if (FAILED(hr)) {
        goto exit;
    }
    StrCat(wzCacheLocation, wzSubDirName);

    if(GetFileAttributes(wzCacheLocation) == -1)
    {
        hr = DB_S_NOTFOUND;
        goto exit;
    }
    else
    {
        hr = DB_S_FOUND;
    }

    hr = PathAddBackslashWrap(wzCacheLocation, MAX_PATH);
    if (FAILED(hr)) {
        goto exit;
    }

    {
        StrCat(wzCacheLocation, pTCInfo->pwzName);
        dwLen  = lstrlenW(wzCacheLocation);
        StrCat(wzCacheLocation, g_szDotDLL);
        if(GetFileAttributes(wzCacheLocation) == -1)
        {
            // there is no AsmName.dll look for AsmName.exe
            StrCpy(wzCacheLocation+dwLen, g_szDotEXE);
        }
    }

    // BUGBUG: check if the manifest exists.
    SAFEDELETEARRAY(pTCInfo->pwzPath);
    pTCInfo->pwzPath = WSTRDupDynamic(wzCacheLocation);

    if(!pTCInfo->pwzPath)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

exit :

    return hr;
}

DWORD GetStringHash(LPCWSTR wzKey)
{
    DWORD   dwHash = 0;
    DWORD   dwLen,i;

    ASSERT(wzKey);

    dwLen = lstrlenW(wzKey);
    for (i = 0; i < dwLen; i++) {
        dwHash = (dwHash * 65599) + (DWORD)towlower(wzKey[i]);
    }

    return dwHash;
}

DWORD GetBlobHash(PBYTE pbKey, DWORD dwLen)
{
    DWORD   i, dwHash = 0;

    ASSERT(pbKey);

    for (i = 0; i < dwLen; i++) {
        dwHash = (dwHash * 65599) + pbKey[i];
    }

    return dwHash;
}

HRESULT StoreFusionInfo(IAssemblyName *pName, LPWSTR pszDir, DWORD *pdwFileSizeLow)
{
    HRESULT hr = S_OK;
    WCHAR  pszFilePath[MAX_PATH+1];
    PBYTE  pSignature=NULL;
    PBYTE  pMVID=NULL;
    PBYTE  pCustom=NULL;
    LPWSTR pszCustomString=NULL;
    LPWSTR pszURL=NULL;
    LPWSTR pszDisplayName=NULL;
    DWORD  cbSize=0;
    BOOL fRet = FALSE;
    DWORD  dwSize;
    LPWSTR pszBuf=NULL;

    if(( lstrlenW(pszDir) + lstrlenW(g_FusionInfoFile) + 1) >= MAX_PATH)
    {
        hr = HRESULT_FROM_WIN32(FUSION_E_INVALID_NAME);
        goto exit;
    }

    StrCpy(pszFilePath, pszDir);
    hr = PathAddBackslashWrap(pszFilePath, MAX_PATH);
    if (FAILED(hr)) {
        goto exit;
    }
    StrCat(pszFilePath, g_FusionInfoFile);

    pszBuf = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!pszBuf)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    cbSize = 0;
    if(FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_SIGNATURE_BLOB, 
            &pSignature, &cbSize)))
        goto exit;

    if(cbSize && (cbSize == SIGNATURE_BLOB_LENGTH_HASH))
    {
        CParseUtils::BinToUnicodeHex(pSignature, cbSize, pszBuf);

        pszBuf[SIGNATURE_BLOB_LENGTH_HASH*2] = L'\0';

        fRet = WritePrivateProfileStringW(ASSEMBLY_INFO_STRING, SIGNATURE_BLOB_KEY_STRING, pszBuf, pszFilePath);
        if (!fRet)
        {
            hr = FusionpHresultFromLastError();
            goto exit;
        }
    }

    cbSize = 0;
    if(FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_MVID,
            &pMVID, &cbSize)))
        goto exit;

    if(cbSize && (cbSize == MVID_LENGTH))
    {
        CParseUtils::BinToUnicodeHex(pMVID, cbSize, pszBuf);

        pszBuf[MVID_LENGTH*2] = L'\0';

        fRet = WritePrivateProfileStringW(ASSEMBLY_INFO_STRING, MVID_KEY_STRING, pszBuf, pszFilePath);
        if (!fRet)
        {
            hr = FusionpHresultFromLastError();
            goto exit;
        }
    }

    cbSize = 0;
    if(FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CUSTOM, 
            &pCustom, &cbSize)))
        goto exit;

    if(cbSize)
    {
        pszCustomString = (LPWSTR) pCustom;
        fRet = WritePrivateProfileStringW(ASSEMBLY_INFO_STRING, CUSTOM_BLOB_STRING, pszCustomString, pszFilePath);
        if (!fRet)
        {
            hr = FusionpHresultFromLastError();
            goto exit;
        }
    }
    else
    {
        // if there is no Custom Blob try storing URL.
        cbSize = 0;
        if(FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CODEBASE_URL, (LPBYTE*) &pszURL, &cbSize)))
            goto exit;

        if(cbSize)
        {
            fRet = WritePrivateProfileStringW(ASSEMBLY_INFO_STRING, URL_STRING, pszURL, pszFilePath);
            if (!fRet)
            {
                hr = FusionpHresultFromLastError();
                goto exit;
            }
        }

        dwSize = 0;
        hr = pName->GetDisplayName(NULL, &dwSize, 0);
        if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            ASSERT(0);
            hr = E_UNEXPECTED;
            goto exit;
        }

        pszDisplayName = NEW(WCHAR[dwSize]);
        if (!pszDisplayName) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        hr = pName->GetDisplayName(pszDisplayName, &dwSize, 0);
        if (FAILED(hr)) {
            goto exit;
        }

        cbSize = dwSize * sizeof(WCHAR);
        if(cbSize)
        {
            fRet = WritePrivateProfileStringW(ASSEMBLY_INFO_STRING, DISPLAY_NAME_STRING, pszDisplayName, pszFilePath);
            if (!fRet)
            {
                hr = FusionpHresultFromLastError();
                goto exit;
            }
        }
    }

    {
        DWORD dwSizeHigh=0;
        *pdwFileSizeLow = 512; // hard-code info file size.

        hr = GetFileSizeRoundedToCluster(INVALID_HANDLE_VALUE, pdwFileSizeLow, &dwSizeHigh);
    }

exit:

    SAFEDELETEARRAY(pszBuf);
    SAFEDELETEARRAY(pszDisplayName);
    SAFEDELETEARRAY(pSignature);
    SAFEDELETEARRAY(pMVID);
    SAFEDELETEARRAY(pCustom);
    SAFEDELETEARRAY(pszURL);

    return hr;
}

HRESULT GetFusionInfo(CTransCache *pTC, LPWSTR pszAsmDir)
{
    HRESULT hr = S_OK;
    WCHAR   wzFilePath[MAX_PATH+1];
    DWORD  cbSize=0;
    PBYTE pSignature=NULL;
    PBYTE pMVID=NULL;
    DWORD dwAttrib;
    DWORD cb;
    IAssemblyName *pName=NULL;
    LPWSTR pszBuf=NULL;
    BOOL bSignatureFailed=FALSE;
    BOOL bCustomFailed=FALSE;
    BOOL bURLFailed=FALSE;
    BOOL bDispNameFailed=FALSE;

#define MAX_BUF (4096 * 2)

    ASSERT(pszAsmDir || (pTC && pTC->_pInfo->pwzPath));

    pszBuf = NEW(WCHAR[MAX_URL_LENGTH+1]);
    if (!pszBuf)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if(pTC && pTC->_pInfo->pwzPath)
    {  
        // if there is path is transprtCache obj use it. else use second param pszAsmDir
        wnsprintf(wzFilePath, MAX_PATH, L"%s", pTC->_pInfo->pwzPath);
    }
    else
    {
        wnsprintf(wzFilePath, MAX_PATH, L"%s", pszAsmDir);
    }

    if((dwAttrib = GetFileAttributes(wzFilePath)) == -1)
    {
        hr = E_FAIL;
        goto exit;
    }

    if(!(dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        // looks manifestFilePath is passed in. knock-off the filename.
        LPWSTR pszTemp = PathFindFileName(wzFilePath);
        if(pszTemp > wzFilePath)
        {
            *(pszTemp-1) = L'\0';
        }
    }
    // else we have assembly dir;

    wnsprintf(wzFilePath, MAX_PATH, L"%s\\%s", wzFilePath, g_FusionInfoFile);

    TRANSCACHEINFO *pTCInfo = (TRANSCACHEINFO*) pTC->_pInfo;

    // Get the SIGNATURE blob
    cbSize = GetPrivateProfileString(ASSEMBLY_INFO_STRING, SIGNATURE_BLOB_KEY_STRING, DEFAULT_INFO_STRING, 
                                        pszBuf, MAX_URL_LENGTH, wzFilePath);

    if((cbSize == SIGNATURE_BLOB_LENGTH_HASH*2)  && StrCmp(pszBuf, DEFAULT_INFO_STRING))
    {
        pSignature = NEW(BYTE[SIGNATURE_BLOB_LENGTH_HASH]);
        if (!pSignature)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        CParseUtils::UnicodeHexToBin(pszBuf, SIGNATURE_BLOB_LENGTH_HASH*2, (LPBYTE) pSignature);

        SAFEDELETEARRAY(pTCInfo->blobSignature.pBlobData);
        pTCInfo->blobSignature.pBlobData = pSignature;
        pTCInfo->blobSignature.cbSize = SIGNATURE_BLOB_LENGTH_HASH;
        pSignature = NULL;
    }

    // Get the MVID blob
    cbSize = GetPrivateProfileString(ASSEMBLY_INFO_STRING, MVID_KEY_STRING, DEFAULT_INFO_STRING,
                                     pszBuf, MAX_URL_LENGTH, wzFilePath);
    if (cbSize == MVID_LENGTH * 2 && StrCmp(pszBuf, DEFAULT_INFO_STRING)) {
        pMVID = NEW(BYTE[MVID_LENGTH]);
        if (!pMVID) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        CParseUtils::UnicodeHexToBin(pszBuf, MVID_LENGTH * 2, (LPBYTE) pMVID);
        SAFEDELETEARRAY(pTCInfo->blobMVID.pBlobData);
        pTCInfo->blobMVID.pBlobData = pMVID;
        pTCInfo->blobMVID.cbSize = MVID_LENGTH;
        pMVID = NULL;
    }
    else {
        bSignatureFailed = TRUE;
    }

    if(pTC->GetCacheType() & ASM_CACHE_ZAP)
    {
        cbSize = GetPrivateProfileString(ASSEMBLY_INFO_STRING, CUSTOM_BLOB_STRING, DEFAULT_INFO_STRING, 
                                        pszBuf, MAX_URL_LENGTH, wzFilePath);

        if(cbSize && FusionCompareString(pszBuf, DEFAULT_INFO_STRING))
        {
            SAFEDELETEARRAY(pTCInfo->blobCustom.pBlobData);
            pTCInfo->blobCustom.pBlobData = (PBYTE) WSTRDupDynamic(pszBuf);
            if (!pTCInfo->blobCustom.pBlobData)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
            pTCInfo->blobCustom.cbSize = (cbSize + 1) * sizeof(WCHAR) ;
        }
        else
            bCustomFailed = TRUE;

    }
    else
    {
        cbSize = GetPrivateProfileString(ASSEMBLY_INFO_STRING, URL_STRING, DEFAULT_INFO_STRING, 
                                        pszBuf, MAX_URL_LENGTH, wzFilePath);

        if(cbSize && FusionCompareString(pszBuf, DEFAULT_INFO_STRING))
        {
            SAFEDELETEARRAY(pTCInfo->pwzCodebaseURL);
            pTCInfo->pwzCodebaseURL = WSTRDupDynamic(pszBuf);

            if (!pTCInfo->pwzCodebaseURL)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }
        }
        else
            bURLFailed = TRUE;

        if(pTC->GetCacheType() & ASM_CACHE_DOWNLOAD)
        {
            cbSize = GetPrivateProfileString(ASSEMBLY_INFO_STRING, DISPLAY_NAME_STRING, DEFAULT_INFO_STRING, 
                                        pszBuf, MAX_URL_LENGTH, wzFilePath);

            if(cbSize && FusionCompareString(pszBuf, DEFAULT_INFO_STRING))
            {
                if (FAILED(hr = CreateAssemblyNameObject(&pName, pszBuf, CANOF_PARSE_DISPLAY_NAME, 0)))
                    goto exit;

                SAFEDELETEARRAY(pTCInfo->pwzName);

                if (FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_NAME,
                        (LPBYTE*) &pTCInfo->pwzName, &(cb = 0))))
                    goto exit;

                // Version
                if(FAILED(hr = pName->GetVersion(&pTCInfo->dwVerHigh, &pTCInfo->dwVerLow)))
                    goto exit;

                SAFEDELETEARRAY(pTCInfo->pwzCulture);

                // Culture
                if(FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_CULTURE,
                    (LPBYTE*) &pTCInfo->pwzCulture, &cb))
                        || (pTCInfo->pwzCulture && !_wcslwr(pTCInfo->pwzCulture)))
                    goto exit;

                SAFEDELETEARRAY(pTCInfo->blobPKT.pBlobData);

                // PublicKeyToken
                if(FAILED(hr = NameObjGetWrapper(pName, ASM_NAME_PUBLIC_KEY_TOKEN, 
                    &pTCInfo->blobPKT.pBlobData, &pTCInfo->blobPKT.cbSize)))
                    goto exit;
            }
            else
                bDispNameFailed = TRUE;
        }
    }

exit:

    SAFEDELETEARRAY(pszBuf);
    SAFEDELETEARRAY(pSignature);
    SAFEDELETEARRAY(pMVID);
    SAFERELEASE(pName);

    if(SUCCEEDED(hr))
    {
        if(bSignatureFailed || bCustomFailed)
            hr = E_FAIL;
        else if(bDispNameFailed || bURLFailed)
            hr = S_FALSE;
    }

    return hr;
}

DWORD GetFileSizeInKB(DWORD dwFileSizeLow, DWORD dwFileSizeHigh);

HRESULT GetAssemblyKBSize(LPWSTR pszManifestPath, DWORD *pdwSizeinKB, 
                          LPFILETIME pftLastAccess, LPFILETIME pftCreation)
{
    HRESULT hr = S_OK;
    LPWSTR pszTemp=NULL;
    TCHAR szSearchPath[MAX_PATH+1];
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindFileData;
    DWORD dwLen = 0;
    DWORD dwAsmSize=0;
    HANDLE hf = INVALID_HANDLE_VALUE;
    DWORD dwShareMode = FILE_SHARE_READ;
    LPWSTR pszManifestFileName=NULL;

    dwLen = lstrlen(pszManifestPath);
    ASSERT(dwLen <= MAX_PATH);

    if(g_bRunningOnNT)
        dwShareMode |= FILE_SHARE_DELETE;

    if(pftLastAccess)
        memset(pftLastAccess, 0, sizeof(FILETIME));

    pszManifestFileName = PathFindFileName(pszManifestPath);

    if(!pszManifestFileName || (pszManifestFileName <= pszManifestPath) )
    {
        hr = E_FAIL;
        goto exit;
    }

    wnsprintf(szSearchPath, MAX_PATH, L"%s", pszManifestPath);

    pszTemp = PathFindFileName(szSearchPath);

    if(!pszTemp || (pszTemp <= szSearchPath) )
    {
        hr = E_FAIL;
        goto exit;
    }

    *(pszTemp-1) = '\0'; // knock-off filename from szSearchPath
    wnsprintf(szSearchPath, MAX_PATH, L"%s\\*", szSearchPath);

    hFind = FindFirstFile(szSearchPath, &FindFileData);

    if(hFind == INVALID_HANDLE_VALUE)
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    do
    {
        // skip directories    
        if (!FusionCompareStringI(FindFileData.cFileName, L".."))
            continue;

        // count the size of dir ??
        if (!FusionCompareStringI(FindFileData.cFileName, L"."))
            continue;

        if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // this is assembly Dir; what are dirs doing here ??
            continue;
        }

        hr = GetFileSizeRoundedToCluster(INVALID_HANDLE_VALUE, &(FindFileData.nFileSizeLow), 
                                                               &(FindFileData.nFileSizeHigh));
        if(FAILED(hr))
            goto exit;

        dwAsmSize += GetFileSizeInKB(FindFileData.nFileSizeLow, FindFileData.nFileSizeHigh);
        if(pftLastAccess && pftCreation && !FusionCompareStringI(pszManifestFileName, FindFileData.cFileName))
        {
            memcpy(pftLastAccess, &(FindFileData.ftLastAccessTime), sizeof(FILETIME));
            memcpy(pftCreation,   &(FindFileData.ftCreationTime),   sizeof(FILETIME));
        }

    }while(FindNextFile(hFind, &FindFileData));

    if( GetLastError() != ERROR_NO_MORE_FILES)
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    if(pdwSizeinKB)
    {
        *pdwSizeinKB = dwAsmSize;
    }

exit:

    if(hFind != INVALID_HANDLE_VALUE)
        FindClose(hFind);

    return hr;
}

//--------------------------------------------------------------------------
// CreateHandleName
//--------------------------------------------------------------------------
HRESULT CreateHandleName(LPWSTR pszBase, LPWSTR pszSpecific, LPWSTR pszMutexName)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       cchName;
    LPWSTR      pszT;
    LPWSTR      pszPrefix = L"Global\\";
    WCHAR       szName[MAX_PATH+1];

    // Invalid Args
    ASSERT(pszBase && pszSpecific && pszMutexName);

    // Compute Length
    // 16 == file_size_max_digits_
    cchName = lstrlen(pszBase) + lstrlen(pszSpecific) + lstrlen(pszPrefix);

    if(cchName >= MAX_PATH)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Format the name
    wnsprintf(szName, (cchName+1), L"%s%s", pszBase, pszSpecific);

    // Remove backslashes from this string
    for (pszT=(szName); *pszT != '\0'; pszT++)
    {
        // Replace Back Slashes
        if (*pszT == '\\')
        {
            // With _
            *pszT = '_';
        }
    }

    if(!_wcslwr(szName))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    pszMutexName[0] = '\0';

    if(g_bRunningOnNT5OrHigher)
    {
        StrCpy(pszMutexName, pszPrefix);
    }

    StrCat(pszMutexName, szName);

exit:
    // Done
    return hr;
}

HANDLE g_hCacheMutex;

HRESULT CreateMutexForCache()
{
    HRESULT hr=S_OK;
    CCriticalSection    cs(&g_csInitClb);
    LPWSTR pszFusion = L"__Fusion_Cache_Mutex_";
    TCHAR szMutexName[MAX_PATH+1];
    WCHAR pszCache[MAX_PATH];
    HANDLE hMutex;

    hr = cs.Lock();
    if (FAILED(hr))
        goto exit;

    if(g_hCacheMutex)
        goto exit;

    if (FAILED(hr = FusionGetUserFolderPath(pszCache)))
    {
        // This guys does not have download cache;  so we don't need mutex.
        hr = S_OK;
        g_hCacheMutex = INVALID_HANDLE_VALUE;
        goto exit;
    }

    if(FAILED(hr = CreateHandleName(pszFusion, pszCache, szMutexName)))
        goto exit;

    // Create the Mutex
    hMutex = CreateMutex(NULL, FALSE, szMutexName);
    if(!hMutex)
    {
        hr = FusionpHresultFromLastError();
    }
    else
    {
        hr = S_OK;
        g_hCacheMutex = hMutex;
    }

exit :
    return hr;
}

HRESULT CreateCacheMutex()
{
    HRESULT hr=S_OK;

    if(g_hCacheMutex)
        goto exit;

    hr = CreateMutexForCache();

exit :
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\installapis.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


#include "fusionP.h"
#include "installApis.h"
#include "helpers.h"
#include "asmimprt.h"
#include "scavenger.h"
#include "asmitem.h"
#include "asmcache.h"
#include "asm.h"

LPCTSTR c_szFailedMsg = TEXT(" AddAssemblyToCache  FAILED with Error code (%x)  ") ;
LPCTSTR c_szSucceededMsg = TEXT(" AddAssemblyToCache  SUCCEEDED");
LPCTSTR c_szCaption = TEXT("AddAssemblyToCache");



LPTSTR SkipBlankSpaces(LPTSTR lpszStr)
{
    if (!lpszStr) return NULL;

    while( (*lpszStr == ' ' ) || (*lpszStr == '\t'))
    {
        lpszStr++;
    }

    return lpszStr;
}


/*--------------------- Cache install Apis ---------------------------------*/

/*
// ---------------------------------------------------------------------------
// InstallAssembly
// ---------------------------------------------------------------------------
STDAPI InstallAssembly(
    DWORD                  dwInstaller,
    DWORD                  dwInstallFlags,
    LPCOLESTR              szPath, 
    LPCOLESTR              pszURL, 
    FILETIME              *pftLastModTime, 
    IApplicationContext   *pAppCtx,
    IAssembly            **ppAsmOut)
{
    HRESULT hr;
    
    CAssemblyCacheItem      *pAsmItem    = NULL;
    IAssemblyManifestImport *pManImport  = NULL;
    IAssemblyName           *pNameDef    = NULL;
    IAssemblyName           *pName       = NULL;
    CTransCache             *pTransCache = NULL;
    CCache                  *pCache      = NULL;


    // Get the manifest import and name def interfaces. 
    if (FAILED(hr = CreateAssemblyManifestImport((LPTSTR)szPath, &pManImport))
        || (FAILED(hr = pManImport->GetAssemblyNameDef(&pNameDef))))
        goto exit;

    // If the assembly is simply named require an app context.
    if (!CCache::IsStronglyNamed(pNameDef) && !pAppCtx)
    {
        hr = FUSION_E_PRIVATE_ASM_DISALLOWED;
        goto exit;
    }


    // Create the assembly cache item.
    if (FAILED(hr = CAssemblyCacheItem::Create(pAppCtx, NULL, (LPTSTR) pszURL, 
        pftLastModTime, dwInstallFlags, 0, pManImport, NULL,
        (IAssemblyCacheItem**) &pAsmItem)))
        goto exit;    
                    
    // Copy to cache.
    if (FAILED(hr = CopyAssemblyFile (pAsmItem, szPath, 
        STREAM_FORMAT_MANIFEST)))
        goto exit;
                

    //  Do a force install. This will delete the existing entry(if any)
    if (FAILED(hr = pAsmItem->Commit(0, NULL)))
    {
        goto exit;        
    }

    // Return resulting IAssembly.
    if (ppAsmOut)
    {
        // Retrieve the trans cache entry.
        pTransCache = pAsmItem->GetTransCacheEntry();     

        // Generate and hand out the associated IAssembly.
        if (FAILED(hr = CreateAssemblyFromTransCacheEntry(pTransCache, NULL, ppAsmOut)))
            goto exit;
    }

exit:

    SAFERELEASE(pAsmItem);
    SAFERELEASE(pTransCache);
    SAFERELEASE(pCache);
    SAFERELEASE(pNameDef);
    SAFERELEASE(pName);
    SAFERELEASE(pManImport);
    
    return hr;
}

// ---------------------------------------------------------------------------
// InstallModule
// ---------------------------------------------------------------------------
STDAPI InstallModule(    
    DWORD                  dwInstaller,
    DWORD                  dwInstallFlags,
    LPCOLESTR              szPath, 
    IAssemblyName*         pName, 
    IApplicationContext    *pAppCtx, 
    LPCOLESTR              pszURL, 
    FILETIME               *pftLastModTime)
{    
    HRESULT hr;

    CAssemblyCacheItem      *pAsmItem      = NULL;

    // If global, ensure name is strong
    if (dwInstallFlags == ASM_CACHE_GAC
        && !CCache::IsStronglyNamed(pName))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create an assembly cache item from an existing entry.
    if (FAILED(hr = CAssemblyCacheItem::Create(pAppCtx, pName, (LPTSTR) pszURL, 
        pftLastModTime, dwInstallFlags, 0, NULL, NULL,
        (IAssemblyCacheItem **) &pAsmItem)))
        goto exit;

    // Copy the file to the assembly cache.
    if (FAILED(hr = CopyAssemblyFile (pAsmItem, szPath, 
        STREAM_FORMAT_MODULE)))
        goto exit;

    // Commit.
    if (FAILED(hr = pAsmItem->Commit(0, NULL)))
    {
        if (hr != DB_E_DUPLICATE)
            goto exit;        
        hr = S_FALSE;
    }

exit:

    SAFERELEASE(pAsmItem);
    return hr;
}
*/

// ---------------------------------------------------------------------------
// InstallCustomAssembly
// ---------------------------------------------------------------------------
STDAPI InstallCustomAssembly(
    LPCOLESTR              szPath, 
    LPBYTE                 pbCustom,
    DWORD                  cbCustom,
    IAssembly            **ppAsmOut)
{
    HRESULT hr;
    DWORD dwCacheFlags=ASM_CACHE_ZAP;
    FILETIME ftLastMod = {0, 0};
    CAssemblyCacheItem      *pAsmItem    = NULL;
    DWORD                  dwInstaller=0;
    CTransCache             *pTransCache = NULL;
    IAssemblyName           *pName=NULL;
    CCache                  *pCache = NULL;

    // Require path and custom data.
    if (!(szPath && pbCustom && cbCustom))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (GetFileAttributes(szPath) == -1) {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    ::GetFileLastModified(szPath, &ftLastMod);


        // Create the assembly cache item.
        if (FAILED(hr = CAssemblyCacheItem::Create(NULL, NULL, (LPWSTR) szPath,
            &ftLastMod, dwCacheFlags, NULL, NULL,
            (IAssemblyCacheItem**) &pAsmItem)))
            goto exit;    
                    
        // Copy to cache. If fail and global, retry
        // on download cache.
        hr = CopyAssemblyFile (pAsmItem, szPath, STREAM_FORMAT_MANIFEST);
        if (FAILED(hr))
        {
            SAFERELEASE(pAsmItem);
            goto exit;
        }
                
        // Add custom data.
        pAsmItem->SetCustomData(pbCustom, cbCustom);

        // Commit.
        hr = pAsmItem->Commit(0, NULL);

        // Duplicate means its available
        // but we return S_FALSE to indicate.
        if (hr == DB_E_DUPLICATE)
        {
            hr = S_FALSE;
            goto exit;
        }
        // Otherwise unknown error
        else if (FAILED(hr))
            goto exit;

    // Return resulting IAssembly.
    if (ppAsmOut)
    {
        /*
        DWORD dwLen = MAX_URL_LENGTH;
        WCHAR szFullCodebase[MAX_URL_LENGTH + 1];

        hr = UrlCanonicalizeUnescape(pAsmItem->GetManifestPath(), szFullCodebase, &dwLen, 0);
        if (FAILED(hr)) {
            goto exit;
        }

        // Generate and hand out the associated IAssembly.
        hr = CreateAssemblyFromManifestFile(pAsmItem->GetManifestPath(), szFullCodebase, &ftLastMod, ppAsmOut);
        if (FAILED(hr)) {
            goto exit;
        }
        */

        if(!(pName = pAsmItem->GetNameDef()))
            goto exit;

        // Create the cache
        if (FAILED(hr = CCache::Create(&pCache, NULL)))
            goto exit;

        // Create a transcache entry from name.
        if (FAILED(hr = pCache->TransCacheEntryFromName(pName, dwCacheFlags, &pTransCache)))
            goto exit;

        if((hr = pTransCache->Retrieve()) != S_OK)
        {
            hr = E_FAIL;
            goto exit;
        }

        if (FAILED(hr = CreateAssemblyFromTransCacheEntry(pTransCache, NULL, ppAsmOut)))
            goto exit;

    }

exit:

    SAFERELEASE(pCache);
    SAFERELEASE(pName);
    SAFERELEASE(pTransCache);
    SAFERELEASE(pAsmItem);
    return hr;
}

// ---------------------------------------------------------------------------
// InstallCustomModule
// ---------------------------------------------------------------------------
STDAPI InstallCustomModule(IAssemblyName* pName, LPCOLESTR szPath)
{    
    HRESULT hr;
    DWORD   dwCacheFlags=ASM_CACHE_ZAP;
    DWORD   dwInstaller=0;

    CAssemblyCacheItem      *pAsmItem      = NULL;
    
    // Require path and custom assembly name.
    if (!(szPath && CCache::IsCustom(pName)))
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
        // Create an assembly cache item from an existing entry.
        if (FAILED(hr = CAssemblyCacheItem::Create(NULL, pName, NULL, NULL,
            dwCacheFlags, NULL, NULL, (IAssemblyCacheItem **) &pAsmItem)))
            goto exit;

        // Copy the file to the assembly cache. If fail and global, 
        // retry on download cache.
        hr = CopyAssemblyFile (pAsmItem, szPath, STREAM_FORMAT_MODULE);
        if (FAILED(hr))
        {
            SAFERELEASE(pAsmItem);
            goto exit;
        }

        // Commit.
        hr = pAsmItem->Commit(0, NULL);

        // If successful, we're done.
        if (hr == S_OK)
            goto exit;

        // Duplicate means its available
        // but we return S_FALSE to indicate.
        else if (hr == DB_E_DUPLICATE)
        {
            hr = S_FALSE;
            goto exit;
        }

        // Otherwise unknown error
        else 
            goto exit;

exit:

    SAFERELEASE(pAsmItem);

    return hr;
}

    

/*
HRESULT ParseCmdLineArgs( LPTSTR lpszCmdLine,  DWORD *pdwFlags, BOOL *pbPrintResult, 
                          BOOL *pbDoExitProcess, LPTSTR szPath, LPTSTR szCodebase)
#ifdef KERNEL_MODE
{
    return E_FAIL;
}
#else
{

    HRESULT hr = S_OK;
    LPTSTR pszPath = NULL;
    LPTSTR pszName = NULL;
    LPTSTR pszFlags = NULL;
    DWORD_PTR dwLen;


    LPTSTR lpszStr=lpszCmdLine;
    LPTSTR lpszTemp;

    if (!lpszStr) 
        return hr; // ????

    while ( *lpszStr) 
    {
        if ( (*lpszStr == '-') || ( *lpszStr == '/' ) )
        {
            lpszStr++;

            switch((TCHAR) ((LPTSTR) *lpszStr))
            {

            case 'e':   // exit the process upon completion
                *pbDoExitProcess =1 ;
                break;

            case 'm':  // Manifest Path
                lpszStr++;
                lpszStr = SkipBlankSpaces(lpszStr);

                if (*lpszStr == TEXT('"')) {
                    lpszStr++;
                    lpszTemp = lpszStr;
    
                    while (*lpszTemp) {
                        if (*lpszTemp == TEXT('"')) {
                            break;
                        }
    
                        lpszTemp++;
                    }
    
                    if (!*lpszTemp) {
                        // no end " found
                        return E_INVALIDARG;
                    }
    
                    // dwLen = # chars to copy including NULL char
                    dwLen = lpszTemp - lpszStr + 1; 
                    StrCpyN(szPath, lpszStr, (DWORD)dwLen);
    
                    lpszStr += dwLen;
                }
                else {
                    lpszTemp = StrChr(lpszStr, ' ');
                    if (!lpszTemp ) 
                    {
                        StrCpy(szPath, lpszStr);
                        lpszStr += lstrlen(lpszStr);
                    }
                    else
                    {
                        StrCpyN(szPath, lpszStr, (int)(lpszTemp-lpszStr)+1);
                        lpszStr = SkipBlankSpaces(lpszTemp);
                    }
                }
                break;

            case 'c': // Codebase
                lpszStr++;
                lpszStr = SkipBlankSpaces(lpszStr);
                lpszTemp = StrChr(lpszStr, ' ');
                if (!lpszTemp ) 
                {
                    StrCpy(szCodebase, lpszStr);
                    lpszStr += lstrlen(lpszStr);
                }
                else
                {
                    StrCpyN(szCodebase, lpszStr, (int)(lpszTemp-lpszStr)+1);
                    lpszStr = SkipBlankSpaces(lpszTemp);
                }

                break;
                
                
            case 'p':   // Print the result (SUCCESS or FAILURE)
                    *pbPrintResult =1 ;
                break;

            default:

                // Print Error
                break;
            }
        }
        else
        {
            lpszStr++;
            // Print Error
        }
    }

return hr;

}
#endif // KERNEL_MODE


STDAPI AddAssemblyToCacheW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow)
{
    
    HRESULT hr = S_OK;
    IAssembly *pAsmOut = NULL;
    TCHAR szPath[MAX_PATH+1];
    BOOL bPrintResult = 0;
    BOOL bDoExitProcess = 0;
    IAssemblyCache *pCache=NULL;
    TCHAR szCodebase[MAX_URL_LENGTH + 1];
    DWORD dwFlags = 0;

    szPath[0] = TEXT('\0');
    szCodebase[0] = TEXT('\0');


    OutputDebugStringA("AddAssemblyToCacheW() processing command: \"");
    OutputDebugStringW(lpszCmdLine);
    OutputDebugStringA("\n");

    hr = ParseCmdLineArgs(lpszCmdLine, &dwFlags, &bPrintResult, &bDoExitProcess,
                          szPath, szCodebase);

    if (FAILED(hr))
    {
        OutputDebugStringA("AddAssemblyToCacheW: ParseCmdLingArgs() failed\n");
        goto exit;
    }

    if(FAILED(hr = CreateAssemblyCache( &pCache, 0)))
        goto exit;

    ASSERT(pCache);

    ASSERT(lstrlenW(szPath));
    hr = pCache->InstallAssembly(0, szPath, NULL);

exit:
    SAFERELEASE(pAsmOut);

    SAFERELEASE(pCache);

    if (bDoExitProcess)
    {
        ExitProcess(hr);
    }

    return hr;
}

STDAPI AddAssemblyToCache(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;
    WCHAR szStr[MAX_PATH*3];

    if ( MultiByteToWideChar(CP_ACP, 0, lpszCmdLine, -1, szStr, MAX_PATH*3) )
    {
        return AddAssemblyToCacheW( hwnd, hinst, szStr , nCmdShow);
    }
    else
    {
        hr = FusionpHresultFromLastError();
    }

    return hr;

}

// This is for naming consistency ( both A & W should exist or none ).
STDAPI AddAssemblyToCacheA(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    return AddAssemblyToCache(hwnd, hinst, lpszCmdLine, nCmdShow);
}

HRESULT ParseRemoveAssemblyCmdLineArgs( LPTSTR lpszCmdLine,  BOOL *pbPrintResult, 
                          BOOL *pbDoExitProcess, LPTSTR szAsmName)
#ifdef KERNEL_MODE
{
    return E_FAIL;
}
#else
{

    HRESULT hr = S_OK;
    LPTSTR pszPath = NULL;
    LPTSTR pszName = NULL;
    LPTSTR pszFlags = NULL;
    DWORD   dwLen = 0;

    LPTSTR lpszStr=lpszCmdLine;
    LPTSTR lpszTemp=NULL;

    if (!lpszStr) 
        return hr; // ????

    while ( *lpszStr) 
    {
        if ( (*lpszStr == '-') || ( *lpszStr == '/' ) )
        {
            lpszStr++;

            switch((TCHAR) ((LPTSTR) *lpszStr))
            {

            case 'e':   // exit the process upon completion
                *pbDoExitProcess =1 ;
                break;

            case 'n':  // Assembly Name
                lpszStr++;
                lpszStr = SkipBlankSpaces(lpszStr);

                if (*lpszStr == TEXT('"')) {
                    lpszStr++;
                    lpszTemp = lpszStr;
    
                    while (*lpszTemp) 
                    {
                        if (*lpszTemp == TEXT('"')) 
                        {
                            if (*(lpszTemp+1) == TEXT('"'))
                               lpszTemp++; // skip "" 
                            else
                                break; // we reached single "
                        }
    
                        lpszTemp++;
                    }
    
                    if (!*lpszTemp) 
                    {
                        // no end " found
                        return E_INVALIDARG;
                    }
    
                    // dwLen = # chars to copy including NULL char
                    dwLen = (DWORD)(lpszTemp - lpszStr + 1); 
                    StrCpyN(szAsmName, lpszStr, dwLen);
    
                    lpszStr += dwLen;
                }
                else {
                    lpszTemp = StrChr(lpszStr, ' ');
                    if (!lpszTemp ) 
                    {
                        StrCpy(szAsmName, lpszStr);
                        lpszStr += lstrlen(lpszStr);
                    }
                    else
                    {
                        StrCpyN(szAsmName, lpszStr, (int)(lpszTemp-lpszStr)+1);
                        lpszStr = SkipBlankSpaces(lpszTemp);
                    }
                }

                break;
                
            case 'p':   // Print the result (SUCCESS or FAILURE)
                    *pbPrintResult =1 ;
                break;

            default:

                // Print Error
                break;
            }
        }
        else
        {
            lpszStr++;
            // Print Error
        }
    }

return hr;
}
#endif

STDAPI RemoveAssemblyFromCacheW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow)
#ifdef KERNEL_MODE
{
    return E_FAIL;
}
#else
{
    HRESULT hr = S_OK;
    BOOL bPrintResult = 0;
    BOOL bDoExitProcess = 0;
    TCHAR szAsmName[MAX_PATH+1]=L"";

    OutputDebugStringA("RemoveAssemblyFromCacheW() processing command: \"");
    OutputDebugStringW(lpszCmdLine);
    OutputDebugStringA("\n");

    hr = ParseRemoveAssemblyCmdLineArgs(lpszCmdLine, &bPrintResult, &bDoExitProcess, szAsmName);

    if (FAILED(hr))
    {
        OutputDebugStringA("RemoveAssemblyFromCacheW: ParseCmdLingArgs() failed\n");
        goto exit;
    }

    hr = DeleteAssemblyFromTransportCache( szAsmName, NULL);

exit :

    return hr;
}
#endif

STDAPI RemoveAssemblyFromCache(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
#ifdef KERNEL_MODE
{
    return E_FAIL;
}
#else
{
    HRESULT hr = S_OK;
    WCHAR szStr[MAX_PATH*3];

    if ( MultiByteToWideChar(CP_ACP, 0, lpszCmdLine, -1, szStr, MAX_PATH*3) )
    {
        hr =  RemoveAssemblyFromCacheW( hwnd, hinst, szStr , nCmdShow);
    }
    else
    {
        hr = FusionpHresultFromLastError();
    }

    return hr;
}
#endif

STDAPI RemoveAssemblyFromCacheA(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    return RemoveAssemblyFromCache(hwnd, hinst, lpszCmdLine, nCmdShow);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\refcount.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "windows.h"
#include "initguid.h"
#include "fusionp.h"
#include "refcount.h"
#include "helpers.h"
#include "asmimprt.h"
#include "naming.h"
#include "parse.h"
#include "fusionheap.h"
#include "msi.h"
#include "adlmgr.h"
#include "util.h"
#include "list.h"

extern BOOL g_bRunningOnNT5OrHigher;

typedef HRESULT (*pfnMsiProvideAssemblyW)(LPCWSTR wzAssemblyName, LPCWSTR szAppContext,
                                          DWORD dwInstallMode, DWORD dwUnused,
                                          LPWSTR lpPathBuf, DWORD *pcchPathBuf);
typedef INSTALLUILEVEL (*pfnMsiSetInternalUI)(INSTALLUILEVEL dwUILevel, HWND *phWnd);
typedef UINT (*pfnMsiInstallProductW)(LPCWSTR wzPackagePath, LPCWSTR wzCmdLine);

extern pfnMsiProvideAssemblyW g_pfnMsiProvideAssemblyW;

HRESULT ConvertIdToFilePath(DWORD dwScheme, LPWSTR pszId, DWORD cchId);

class CVerifyRefNode
{
public:

    CVerifyRefNode();
    ~CVerifyRefNode();

    HRESULT Init(DWORD dwScheme, LPWSTR pszID);

    FUSION_INSTALL_REFERENCE _RefData;
};

CVerifyRefNode::CVerifyRefNode()
{
    DWORD dwSize = sizeof(FUSION_INSTALL_REFERENCE);

    memset(&_RefData, 0, dwSize);
    _RefData.cbSize = dwSize;
}

CVerifyRefNode::~CVerifyRefNode()
{
    SAFEDELETEARRAY(_RefData.szIdentifier);
}

HRESULT CVerifyRefNode::Init(DWORD dwScheme, LPWSTR pszID)
{
    HRESULT hr = S_OK;

    ASSERT(dwScheme && pszID);

    if(dwScheme == FRC_UNINSTALL_SUBKEY_SCHEME)
    {
        _RefData.guidScheme = FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID;
    }
    else if(dwScheme == FRC_FILEPATH_SCHEME)
    {
        _RefData.guidScheme = FUSION_REFCOUNT_FILEPATH_GUID;
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    _RefData.szIdentifier = WSTRDupDynamic(pszID);
    if (!_RefData.szIdentifier) {
        hr = E_OUTOFMEMORY;
    }

exit:

    return hr;
}

HRESULT GACAssemblyReference(LPCWSTR pszManifestFilePath, IAssemblyName *pAsmName, LPCFUSION_INSTALL_REFERENCE pRefData, BOOL bAdd)
{
    HRESULT                            hr=S_OK;
    DWORD                              dwSize;

    LPWSTR                             pszDisplayName = NULL;
    IAssemblyManifestImport           *pManifestImport=NULL;
    IAssemblyName                     *pName = NULL;
    CInstallRef                       *pInstallRef=NULL;

    if(!pRefData || (!pszManifestFilePath && !pAsmName))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if(!pAsmName)
    {
        if (FAILED(hr = CreateAssemblyManifestImport(pszManifestFilePath, &pManifestImport)))
            goto exit;

        // Get the name def.
        if (FAILED(hr = pManifestImport->GetAssemblyNameDef(&pName)))
            goto exit;
    }
    else
    {
        pAsmName->AddRef();
        pName = pAsmName;
    }

    dwSize = 0;
    hr = pName->GetDisplayName(NULL, &dwSize, 0);
    if (hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        ASSERT(0);
        hr = E_UNEXPECTED;
        goto exit;
    }

    pszDisplayName = NEW(WCHAR[dwSize]);
    if (!pszDisplayName) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = pName->GetDisplayName(pszDisplayName, &dwSize, 0);
    if (FAILED(hr)) {
        goto exit;
    }

    pInstallRef = NEW(CInstallRef(pRefData, pszDisplayName));

    if(!pInstallRef)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if(FAILED(hr = pInstallRef->Initialize()))
        goto exit;

    if(bAdd)
    {
        hr = pInstallRef->AddReference();
    }
    else
    {
        hr = pInstallRef->DeleteReference();
    }

exit :

    SAFEDELETEARRAY(pszDisplayName);
    SAFEDELETE(pInstallRef);
    SAFERELEASE(pManifestImport);
    SAFERELEASE(pName);

    return hr;
}

HRESULT ValidateUninstallKey(LPCWSTR pszIdentifier)
{
    HRESULT hr = S_OK;
    WCHAR szRegKey[MAX_PATH*2 +1];
    HKEY hkey=0;
    DWORD       lResult=0;

    wnsprintf(szRegKey, MAX_PATH*2, L"%s%s", UNINSTALL_REG_SUBKEY, pszIdentifier);

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegKey, 0, KEY_ALL_ACCESS, &hkey);

    if(lResult != ERROR_SUCCESS) 
    {
        hr = HRESULT_FROM_WIN32(lResult);
    } 

    if(hkey)
        RegCloseKey(hkey);

    return hr;
}


HRESULT ValidateFilePath(LPCWSTR pszIdentifier)
{
    HRESULT hr = S_OK;
    WCHAR wzNewId[MAX_PATH];
    WCHAR wzFilePath[MAX_PATH];
    // DWORD dwSize;

    wnsprintf(wzFilePath, MAX_PATH, L"%s", pszIdentifier);

    hr = ConvertIdToFilePath(FRC_FILEPATH_SCHEME, wzFilePath, MAX_PATH);

    if(FAILED(hr = GenerateKeyFileIdentifier(wzFilePath, wzNewId, MAX_PATH)))
    {
        hr = S_OK; // we should keep this ref as we could not get info about it.
        goto exit;
    }

    if(FusionCompareString(pszIdentifier, wzNewId, FALSE))
        goto exit; // volumes are diff.

    if(GetFileAttributes(wzFilePath) == -1)
    {
        hr = S_FALSE; // volume is valid ! but the file is deleted ?
    }

exit :

    return hr;
}

HRESULT VerifyActiveRefsToAssembly(IAssemblyName *pName)
{
    HRESULT hr = S_OK;
    BOOL bHasActiveRefs = FALSE;
    CInstallRefEnum *pInstallRefEnum;
    WCHAR szValue[MAX_PATH+1];
    DWORD cchValue;
    WCHAR szData[MAX_PATH+1];
    DWORD cchData;
    DWORD dwScheme = 0;
    List<CVerifyRefNode *>   *pRefList=NEW(List<CVerifyRefNode *>);
    CVerifyRefNode  *pNode;
    DWORD dwAsmCount=0;

    LISTNODE    pDeleteList=NULL;
    DWORD iDeleteCount=0,i=0;
    CVerifyRefNode  *pTargetNode;

    ASSERT(pName);

    pInstallRefEnum = NEW(CInstallRefEnum(pName, TRUE));

    if(!pInstallRefEnum)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    while(hr == S_OK)
    {
        cchValue = MAX_PATH;
        cchData  = MAX_PATH;

        hr = pInstallRefEnum->GetNextRef(0, szValue, &cchValue, szData, &cchData, &dwScheme, NULL);

        if(hr != S_OK)
            break;

        if(dwScheme >= FRC_OPAQUE_STRING_SCHEME)
            continue;

        if(dwScheme == FRC_UNINSTALL_SUBKEY_SCHEME)
        {
            if((hr = ValidateUninstallKey( szValue))== S_OK)
                continue;
        }
        else if(dwScheme == FRC_FILEPATH_SCHEME)
        {
            if((hr = ValidateFilePath( szValue)) == S_OK)
                continue;

            if(hr == S_OK)
                continue;

            // convert the reg entry to file path
            hr = ConvertIdToFilePath(FRC_FILEPATH_SCHEME, szValue, MAX_PATH);

        }

        pNode = NEW(CVerifyRefNode);
        if(!pNode)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        if(FAILED(pNode->Init(dwScheme, szValue)))
            goto exit;

        pRefList->AddHead(pNode);
        dwAsmCount++;
        bHasActiveRefs = TRUE;
        hr = S_OK;
    } // while

    pInstallRefEnum->CleanUpRegKeys();
    SAFEDELETE(pInstallRefEnum);

    if(!dwAsmCount)
        goto exit;

    // delete bad ones

    pDeleteList  = pRefList->GetHeadPosition();
    iDeleteCount = pRefList->GetCount();

    for(i=0; i<dwAsmCount; i++)
    {

        pTargetNode = pRefList->GetNext(pDeleteList); // Element from list;

        hr = GACAssemblyReference(NULL, pName, &(pTargetNode->_RefData), FALSE);
    }

    hr = S_OK;

exit :

    if(pRefList)
    {
        pDeleteList  = pRefList->GetHeadPosition();
        iDeleteCount = pRefList->GetCount();

        for(i=0; i<iDeleteCount; i++)
        {
            pTargetNode = pRefList->GetNext(pDeleteList); // Element from list;
            SAFEDELETE(pTargetNode);
        }
        pRefList->RemoveAll();
        SAFEDELETE(pRefList); // this should call RemoveAll
    }

    SAFEDELETE(pInstallRefEnum);

    // *pbHasActiveRefs = bHasActiveRefs;

    return hr;
}

HRESULT ActiveRefsToAssembly( IAssemblyName *pName, PBOOL pbHasActiveRefs)
{
    HRESULT hr = S_OK;
    BOOL bHasActiveRefs = FALSE;
    CInstallRefEnum *pInstallRefEnum;
    WCHAR szValue[MAX_PATH+1];
    DWORD cchValue;
    WCHAR szData[MAX_PATH+1];
    DWORD cchData;
    DWORD dwScheme = 0;

    ASSERT(pName &&  pbHasActiveRefs);

    hr = VerifyActiveRefsToAssembly(pName);

    pInstallRefEnum = NEW(CInstallRefEnum(pName, TRUE));

    if(!pInstallRefEnum)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = S_OK;

    while(hr == S_OK)
    {
        cchValue = MAX_PATH;
        cchData  = MAX_PATH;

        hr = pInstallRefEnum->GetNextRef(0, szValue, &cchValue, szData, &cchData, &dwScheme, NULL);
        if (FAILED(hr)) {
            goto exit;
        }

        if(hr == S_FALSE)
            break;

        bHasActiveRefs = TRUE;
    }

    pInstallRefEnum->CleanUpRegKeys();

    hr = S_OK;

    *pbHasActiveRefs = bHasActiveRefs;

exit :

    SAFEDELETE(pInstallRefEnum);

    return hr;
}


HRESULT GetRegLocation(LPWSTR &pszRegKeyString, LPCWSTR pszDisplayName, LPCWSTR pszGUIDString)
{
    HRESULT hr = S_OK;
    DWORD   dwLen=0;
    DWORD   dwTempLen=0;

    dwLen = lstrlen(REG_KEY_FUSION_SETTINGS) +
           + lstrlen(INSTALL_REFERENCES_STRING) + 5; // extra chars for '\\'.
 
    if(pszDisplayName)
    {
        dwLen += lstrlen(pszDisplayName);
    }

    if(pszGUIDString)
    {
        dwLen += lstrlen(pszGUIDString);
    }

    pszRegKeyString = NEW(WCHAR[dwLen + 1]);

    if(!pszRegKeyString)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    wnsprintf(pszRegKeyString, dwLen, L"%s\\%s", REG_KEY_FUSION_SETTINGS, INSTALL_REFERENCES_STRING);

    // if available add DisplayName
    dwTempLen = lstrlen(pszRegKeyString);
    if(pszDisplayName)
    {
        wnsprintf(pszRegKeyString + dwTempLen, dwLen - dwTempLen, L"\\%s", pszDisplayName);
    }

    // if available add GUID scheme
    dwTempLen = lstrlen(pszRegKeyString);
    if(pszGUIDString)
    {
        wnsprintf(pszRegKeyString + dwTempLen, dwLen - dwTempLen, L"\\%s", pszGUIDString);
    }

exit:

    return hr;
}

BOOL GetScheme(GUID guid, DWORD &dwScheme)
{
    BOOL fRet = TRUE;

    if(guid == FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID)
        dwScheme = FRC_UNINSTALL_SUBKEY_SCHEME;
    else if(guid == FUSION_REFCOUNT_FILEPATH_GUID)
        dwScheme = FRC_FILEPATH_SCHEME;
    else if(guid == FUSION_REFCOUNT_OPAQUE_STRING_GUID)
        dwScheme = FRC_OPAQUE_STRING_SCHEME;
    else if (guid == FUSION_REFCOUNT_OSINSTALL_GUID)
        dwScheme = FRC_OSINSTALL_SCHEME;
    else
    {
        dwScheme = 0;
        fRet = FALSE;
    }

    return fRet;
}

CInstallRef::CInstallRef(LPCFUSION_INSTALL_REFERENCE pRefData, LPWSTR pszDisplayName)
{
    _pRefData = pRefData;
    _szDisplayName = pszDisplayName;
    _szGUID[0] = L'\0';
    ASSERT( _pRefData && _szDisplayName );
}

HRESULT DoesPathExist(LPWSTR pszKeyFilePath)
{
    HRESULT hr = S_OK;
    WCHAR szPath[MAX_PATH+1];
    LPWSTR pszTemp;

    wnsprintf(szPath, MAX_PATH, L"%s", pszKeyFilePath);
    pszTemp = PathFindFileName(szPath);
    if(pszTemp <= szPath) 
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    *(pszTemp -1) = L'\0';

        if(GetFileAttributes(szPath) == -1)
        {
                hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
        }

exit:

    return hr;
}

CInstallRef::~CInstallRef()
{

}

HRESULT CInstallRef::Initialize( )
{
    HRESULT hr = S_OK;

    // 
    // has to be one of the defined GUIDs
    //
    if ((_pRefData == NULL) || (_pRefData->cbSize < sizeof(FUSION_INSTALL_REFERENCE))
            || (_pRefData->dwFlags) || (_pRefData->szIdentifier == NULL)) 
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // has to be one of the defined GUIDs
    if(!GetScheme( _pRefData->guidScheme, _dwScheme))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // strings have MAX_PATH limit.
    if( (lstrlen(_pRefData->szIdentifier) >= MAX_PATH) || (lstrlen(_pRefData->szNonCannonicalData) >= MAX_PATH))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // stringize GUID;
    FusionFormatGUID(_pRefData->guidScheme, _szGUID, FUSION_GUID_LENGTH);


exit :

    return hr;
}

HRESULT CInstallRef::AddReference()
{
    HRESULT     hr = S_OK;
    DWORD       dwSize=0;
    DWORD       dwType=0;
    DWORD       lResult=0;
    DWORD       dwDisposition=0;
    HKEY        hkey=0;
    LPWSTR      pszRegKeyString=NULL;
    WCHAR       szGenId[MAX_PATH+1];

    if(StrChr(_pRefData->szIdentifier, L';'))
    {
        // ";" is not allowed in file path.
        hr = E_INVALIDARG;
        goto exit;
    }

    /*
    if( _dwScheme == FRC_FILEPATH_SCHEME)
        if(FAILED(hr = DoesPathExist((LPWSTR)_pRefData->szIdentifier)))
            goto exit;
    */

    if(FAILED(hr = GetRegLocation(pszRegKeyString, _szDisplayName, _szGUID)))
        goto exit;


    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszRegKeyString, 0, 
                                  NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, &dwDisposition );

    if(lResult != ERROR_SUCCESS) 
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    if(_pRefData->szNonCannonicalData)
    {
        dwSize = (lstrlen(_pRefData->szNonCannonicalData) + 1) * sizeof(WCHAR);
    }
    else
    {
        dwSize = 0;
    }

    if(FAILED(hr = GenerateIdentifier(_pRefData->szIdentifier, _dwScheme, szGenId, MAX_PATH)))
        goto exit;

    lResult = RegSetValueEx(hkey, szGenId, NULL, REG_SZ, (LPBYTE)_pRefData->szNonCannonicalData, dwSize);
    if (lResult != ERROR_SUCCESS) 
    {
        hr = FusionpHresultFromLastError();

        if( hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
        {
            hr = S_OK; // maybe this should be S_FALSE;
        }
    }

exit :

    SAFEDELETEARRAY(pszRegKeyString);

    if (hkey)
        RegCloseKey(hkey);

    return hr;
}

HRESULT CInstallRef::DeleteReference()
{
    HRESULT     hr = S_OK;
    DWORD       lResult=0;
    DWORD       dwDisposition=0;
    HKEY        hkey=0;
    LPWSTR      pszRegKeyString = NULL;
    WCHAR       szGenId[MAX_PATH+1];
    
    // disallow uninstall of os assemblies
    if (_pRefData->guidScheme == FUSION_REFCOUNT_OSINSTALL_GUID)
    {
        hr = FUSION_E_UNINSTALL_DISALLOWED;
        goto exit;
    }
    
    if(FAILED(hr = GetRegLocation(pszRegKeyString, _szDisplayName, _szGUID)))
        goto exit;

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegKeyString, 0, KEY_ALL_ACCESS, &hkey);

    if(lResult != ERROR_SUCCESS) 
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto exit;
    }

    if(FAILED(hr = GenerateIdentifier(_pRefData->szIdentifier, _dwScheme, szGenId, MAX_PATH)))
        goto exit;

    lResult = RegDeleteValue(hkey, szGenId);

    if (lResult != ERROR_SUCCESS) 
    {
        hr = HRESULT_FROM_WIN32(lResult);
    }

exit :

    SAFEDELETEARRAY(pszRegKeyString);

    if (hkey)
        RegCloseKey(hkey);

    return hr;
}

HRESULT GenerateIdentifier(LPCWSTR pszInputId, DWORD dwScheme, LPWSTR pszGenId, DWORD cchGenId)
{
    HRESULT hr = S_OK;

    if(dwScheme == FRC_FILEPATH_SCHEME)
    {
        hr = GenerateKeyFileIdentifier(pszInputId, pszGenId, cchGenId);
    }
    else
    {
        StrNCpy(pszGenId, pszInputId, cchGenId);
    }

    return hr;
}

HRESULT GenerateKeyFileIdentifier(LPCWSTR pszKeyFilePath, LPWSTR pszVolInfo, DWORD cchVolInfo)
{
    HRESULT hr = S_OK;

    WCHAR szPath[MAX_PATH+1];
    // WCHAR szWorkingBuff[MAX_PATH+1];
    WCHAR szDriveRoot[MAX_PATH+1];
    UINT  uiDriveType;
    DWORD dwDriveSerialNumber;
    DWORD dwLen;
    LPWSTR pszTemp=NULL;
#define UNC_STRING L"\\\\?\\UNC"


    if(!FusionCompareStringNI(pszKeyFilePath, UNC_STRING, lstrlenW(UNC_STRING)))
    {
        wnsprintf(szPath, MAX_PATH, L"\\%s", pszKeyFilePath + lstrlenW(UNC_STRING));
    }
    else
    {
        // wnsprintf(szPath, MAX_PATH, L"%s", pszKeyFilePath);

        if(WszGetFullPathName(pszKeyFilePath, MAX_PATH-1, szPath, &pszTemp) > MAX_PATH)
        {
            hr = E_INVALIDARG;
            goto exit;
        }
    }

    if(g_bRunningOnNT5OrHigher)
    {
        if(!FusionGetVolumePathNameW( szPath, szDriveRoot, MAX_PATH))
        {
            hr = FusionpHresultFromLastError();
            goto exit;
        }

        if(lstrlenW(szDriveRoot) > lstrlenW(szPath))
        {
            hr = E_FAIL;
            goto exit;
        }
        pszTemp = szPath + lstrlenW(szDriveRoot);
    }
    else
    {
        // Get drive name from the "working" path
        pszTemp = PathSkipRoot(szPath);

        if(pszTemp <= szPath) 
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        dwLen = DWORD (pszTemp - szPath + 1); //check for buffer size.
        StrNCpy(szDriveRoot, szPath, dwLen);
        *(pszTemp -1) = '\0';
    }


    // Type and volume number, first
    uiDriveType = GetDriveType(szDriveRoot);

    if(!GetVolumeInformation(
        szDriveRoot,
        NULL,
        0,
        &dwDriveSerialNumber,
        NULL,
        NULL,
        NULL,
        0))
    {
        hr = FusionpHresultFromLastError();
        goto exit;
    }

    // Remote drives get their actual share names.
    if( ( uiDriveType == DRIVE_REMOTE ) && (!PathIsUNC(szDriveRoot)))
    {
        UNIVERSAL_NAME_INFO *puni;
        WCHAR szRemoteNameTemp[MAX_PATH+10];
        DWORD cbSize = MAX_PATH * sizeof(WCHAR);
        DWORD dwRet=0;

        puni = (UNIVERSAL_NAME_INFO *)szRemoteNameTemp;

        if( (dwRet = FusionGetRemoteUniversalName( szDriveRoot, puni, &cbSize)) != NO_ERROR)
        {
            hr = HRESULT_FROM_WIN32(dwRet);
            goto exit;
        }

        StrCpy(szDriveRoot, puni->lpUniversalName);
    }

    wnsprintf(pszVolInfo, MAX_PATH, L"%ls;%x;%ls", szDriveRoot, dwDriveSerialNumber, pszTemp);

exit:

    return hr;
}

HRESULT ConvertIdToFilePath(DWORD dwScheme, LPWSTR pszId, DWORD cchId)
{
    HRESULT hr = S_OK;
    WCHAR szPath[MAX_PATH+1];
    LPWSTR pszTemp=NULL;

    if(dwScheme != FRC_FILEPATH_SCHEME)
        goto exit;

    ASSERT(dwScheme);

    if(dwScheme != FRC_FILEPATH_SCHEME)
        goto exit;

    pszTemp = StrChr(pszId, KEY_FILE_SCHEME_CHAR);

    if(!pszTemp)
        goto exit;

    StrNCpy(szPath, pszId, (DWORD) (pszTemp - pszId + 1));

    pszTemp = StrChr(pszTemp+1, KEY_FILE_SCHEME_CHAR);

    if(!pszTemp)
        goto exit;

    wnsprintf(szPath, MAX_PATH, L"%s%s", szPath, pszTemp+1);

    wnsprintf(pszId, cchId, L"%s", szPath);

exit :

    return hr;
}


// *************************************************************************************************
// CInstallRefEnum
// *************************************************************************************************
CInstallRefEnum::CInstallRefEnum(IAssemblyName *pName, BOOL bDoNotConvertId)
{

    _hr = S_OK;
    _hkey = 0;
    _dwIndex = 0;
    _curScheme = 0;
    _dwRefsInThisScheme = 0;
    _dwTotalValidRefs = 0;
    _bDone = FALSE;
    _bDoNotConvertId = bDoNotConvertId;
    memset(_arDeleteSubKeys, 0, sizeof(_arDeleteSubKeys));
    memset(&_curGUID, 0, sizeof(GUID));

    ASSERT(pName);

    DWORD dwSize = 0;
    _hr = pName->GetDisplayName(NULL, &dwSize, 0);
    if (_hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        ASSERT(0);
        _hr = E_UNEXPECTED;
        goto exit;
    }

    _pszDisplayName = NEW(WCHAR[dwSize]);
    if (!_pszDisplayName) {
        _hr = E_OUTOFMEMORY;
        goto exit;
    }

    _hr = pName->GetDisplayName(_pszDisplayName, &dwSize, 0);

exit :

    return;
}

CInstallRefEnum::~CInstallRefEnum()
{
    SAFEDELETEARRAY(_pszDisplayName);
    if(_hkey)
        RegCloseKey(_hkey);
}

HRESULT CInstallRefEnum::ValidateRegKey(HKEY &hkey)
{
    HRESULT     hr = S_OK;
    DWORD       lResult=0;
    DWORD       dwNoOfSubKeys = 0;
    DWORD       dwNoOfValues  = 0;

    lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL, &dwNoOfSubKeys, NULL, NULL, 
                                &dwNoOfValues, NULL, NULL, NULL, NULL);

    if (lResult != ERROR_SUCCESS) 
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto exit;
    }
    else
    {
        if(!dwNoOfValues)
            _arDeleteSubKeys[_curScheme] = TRUE;
    }

exit :

    return hr;
}

HRESULT CInstallRefEnum::GetNextScheme ()
{
    HRESULT     hr = S_OK;
    DWORD       i = 0;
    DWORD       lResult=0;
    HKEY        hkey=0;

    LPWSTR  pszRegKeyString=NULL;
    WCHAR   szGUIDString[FUSION_GUID_LENGTH+1];

    for(i = _curScheme + 1; i < FRC_MAX_SCHEME; i++)
    {

        switch(i)
        {
            case FRC_UNINSTALL_SUBKEY_SCHEME:
                _curGUID = FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID;
                break;

            case FRC_FILEPATH_SCHEME:
                _curGUID = FUSION_REFCOUNT_FILEPATH_GUID;
                break;

            case FRC_OPAQUE_STRING_SCHEME:
                _curGUID = FUSION_REFCOUNT_OPAQUE_STRING_GUID;
                break;

            case FRC_OSINSTALL_SCHEME:
                _curGUID = FUSION_REFCOUNT_OSINSTALL_GUID;
                break;

            default :
                continue;
        }

        FusionFormatGUID(_curGUID, szGUIDString, FUSION_GUID_LENGTH);

        SAFEDELETEARRAY(pszRegKeyString);

        if(FAILED(hr = GetRegLocation(pszRegKeyString, _pszDisplayName, szGUIDString)))
            goto exit;

        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegKeyString, 0, KEY_ALL_ACCESS, &hkey);

        if (lResult != ERROR_SUCCESS) 
        {
            if((lResult == ERROR_FILE_NOT_FOUND) || (lResult == ERROR_PATH_NOT_FOUND))
            {
                _arDeleteSubKeys[i] = TRUE;
                continue;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lResult);
                goto exit;
            }
        }

        _hkey = hkey;
        hkey = 0;
        _dwRefsInThisScheme = 0;
        _dwIndex = 0;
        break;
    }

    _curScheme = i;

    if(_curScheme >= FRC_MAX_SCHEME)
    {
        hr = S_FALSE;
        goto exit;
    }

exit :

    SAFEDELETEARRAY(pszRegKeyString);
    
    if(hkey)
        RegCloseKey(hkey);

    return hr;
}

HRESULT CInstallRefEnum::GetNextIdentifier (LPWSTR pszIdentifier, DWORD *pcchId, LPBYTE pData, PDWORD pcbData)
{
    HRESULT     hr = S_OK;
    DWORD       i = 0;
    DWORD       lResult=0;
    HKEY        hkey=0;
    DWORD       dwType=0;

    lResult = RegEnumValue(_hkey, _dwIndex++, pszIdentifier, pcchId, NULL, &dwType, pData, pcbData);

    if (lResult != ERROR_SUCCESS)
    {
        if(lResult == ERROR_NO_MORE_ITEMS)
        {
            hr = ValidateRegKey(_hkey);

            if(FAILED(hr))
                goto exit;

            RegCloseKey(_hkey);
            _hkey = 0;
            hr = S_FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lResult);
            goto exit;
        }
    }

exit :

    if((hr == S_OK) && !_bDoNotConvertId)
    {
        ConvertIdToFilePath(_curScheme, pszIdentifier, *pcchId);
    }

    return hr;
}


HRESULT CInstallRefEnum::GetNextRef (DWORD dwFlags, LPWSTR pszIdentifier, PDWORD pcchId,
                                     LPWSTR pszData, PDWORD pcchData, PDWORD pdwScheme, LPVOID pvReserved)
{
    HRESULT hr = S_OK;

    if(_bDone)
        return S_FALSE;

    if( !pszIdentifier || !pcchId || !(*pcchId) || !pszData || !pcchData || !(*pcchData))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    while(1)
    {
        if(!_hkey)
        {
            if(_curScheme >= FRC_MAX_SCHEME)
            {
                hr = S_FALSE;
                goto exit;
            }

            if((hr = GetNextScheme()) != S_OK)
                goto exit;
        }

        *pcchData *= sizeof(WCHAR);

        hr = GetNextIdentifier(pszIdentifier, pcchId, (LPBYTE) pszData, pcchData); 
            
        // found an entry or got an error, get out; else no entires found, so continue to look.
        if((FAILED(hr)) || (hr == S_OK))
            goto exit;
    }

exit :

    if(!_bDone && hr == S_FALSE)
    {
        _bDone = TRUE; // we are done enumerating refs in registry. no checking next time.
        if(SUCCEEDED(hr = CheckMSIInstallAvailable(NULL, NULL)))
        {
            UINT lResult;

            ASSERT(g_pfnMsiProvideAssemblyW);

            lResult = g_pfnMsiProvideAssemblyW(_pszDisplayName, 0, /*INSTALLMODE_NODETECTION_ANY*/ (-4), 0, 0, 0);

            if( (lResult != ERROR_UNKNOWN_COMPONENT) &&
                (lResult != ERROR_INDEX_ABSENT) && (lResult != ERROR_FILE_NOT_FOUND))
            {
                // MSI has reference to this assembly.
                _curScheme = FRC_MSI_SCHEME;
                _curGUID = FUSION_REFCOUNT_MSI_GUID;

                StrCpy(pszIdentifier, MSI_ID);
                StrCpy(pszData, MSI_DESCRIPTION);
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE; // MSI does not have ref.
            }
        }
        else {
            hr = S_FALSE;
        }
    }

    if(pdwScheme && (hr == S_OK))
    {
        *pdwScheme = _curScheme;
    }

    _hr = hr;
    return hr;
}

HRESULT CInstallRefEnum::GetNextReference (DWORD dwFlags, LPWSTR pszIdentifier, PDWORD pcchId,
                                           LPWSTR pszData, PDWORD pcchData, GUID *pGuid, LPVOID pvReserved)
{
    HRESULT hr = S_OK;

    hr = GetNextRef(dwFlags, pszIdentifier, pcchId,
                        pszData, pcchData, NULL, pvReserved);

    if(pGuid && (hr == S_OK))
    {
        *pGuid = _curGUID;
    }

    return hr;
}

BOOL CInstallRefEnum::GetGUID(DWORD dwScheme, GUID &guid)
{
    BOOL fRet = TRUE;

    switch(dwScheme)
    {
    case FRC_UNINSTALL_SUBKEY_SCHEME:
        guid = FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID;
        break;

    case FRC_FILEPATH_SCHEME:
        guid = FUSION_REFCOUNT_FILEPATH_GUID;
        break;

    case FRC_OPAQUE_STRING_SCHEME:
        guid = FUSION_REFCOUNT_OPAQUE_STRING_GUID;
        break;

    case FRC_OSINSTALL_SCHEME:
        guid = FUSION_REFCOUNT_OSINSTALL_GUID;
        break;
            
    default :
        fRet = FALSE;
    }

    return fRet;
}



HRESULT CInstallRefEnum::CleanUpRegKeys()
{
    HRESULT     hr = S_OK;
    DWORD       i = 0;
    DWORD       lResult=0;
    HKEY        hkey=0;
    BOOL        bAllSubKeysDeleted=TRUE;
    LPWSTR  pszRegKeyString=NULL;
    WCHAR   szGUIDString[FUSION_GUID_LENGTH+1];

    if(FAILED(hr = GetRegLocation(pszRegKeyString, _pszDisplayName, NULL)))
        goto exit;

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegKeyString, 0, KEY_ALL_ACCESS, &hkey);

    if (lResult != ERROR_SUCCESS) 
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto exit;
    }

    for(i = FRC_UNINSTALL_SUBKEY_SCHEME; i < FRC_MAX_SCHEME; i++)
    {
        /**/
        if(_arDeleteSubKeys[i] == FALSE)
        {
            bAllSubKeysDeleted = FALSE;
            continue;
        }
        /**/

        if(!GetGUID(i, _curGUID))
        {
            hr = E_FAIL;
            goto exit;
        }

        FusionFormatGUID(_curGUID, szGUIDString, FUSION_GUID_LENGTH);

        lResult = RegDeleteKey(hkey, szGUIDString);

        if (lResult != ERROR_SUCCESS) 
        {
            hr = HRESULT_FROM_WIN32(lResult);
            // goto exit; // couldn't delete this one; try next ??
        }

    } // for(i= ....

    //* do we need this just try to delete...
    if(!bAllSubKeysDeleted)
    {
        goto exit;
    }
    /**/

    SAFEDELETEARRAY(pszRegKeyString);

    if(hkey)
        RegCloseKey(hkey);

    // delete DispName sub-key 
    if(FAILED(hr = GetRegLocation(pszRegKeyString, NULL, NULL)))
        goto exit;

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegKeyString, 0, KEY_ALL_ACCESS, &hkey);

    if (lResult != ERROR_SUCCESS) 
    {
        if( (lResult == ERROR_PATH_NOT_FOUND) ||
            (lResult == ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lResult);
            goto exit;
        }
    }

    lResult = RegDeleteKey(hkey, _pszDisplayName);

    if (lResult != ERROR_SUCCESS) 
    {
        if( (lResult == ERROR_PATH_NOT_FOUND) ||
            (lResult == ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lResult);
            goto exit;
        }
    }

exit :

    SAFEDELETEARRAY(pszRegKeyString);

    if(hkey)
        RegCloseKey(hkey);

    return hr;
}

extern BOOL g_bRunningOnNT;
// OS install reference can be only used at special occasion.
HRESULT ValidateOSInstallReference(LPCFUSION_INSTALL_REFERENCE pRefData)
{
    HKEY  hKeySetup = NULL;
    DWORD bSetupInProgress = 0;
    HRESULT hr = S_OK;
    DWORD type = REG_DWORD;
    DWORD dwSize = sizeof(bSetupInProgress);
    LONG  lResult = 0;
   
    if (pRefData)
    {
        if (pRefData->guidScheme == FUSION_REFCOUNT_OSINSTALL_GUID)
        {
            if (!g_bRunningOnNT)
            {
                hr = E_INVALIDARG;
                goto Exit;
            }

            lResult = WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\Setup", 0, KEY_ENUMERATE_SUB_KEYS|KEY_READ, &hKeySetup);
            if (lResult != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(lResult);
                goto Exit;
            }

            lResult = WszRegQueryValueEx(hKeySetup, L"SystemSetupInProgress", NULL, &type, (LPBYTE) &bSetupInProgress, &dwSize);
            if (lResult != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(lResult);
                goto Exit;
            }
            
            if (!bSetupInProgress)
            {
                hr = E_INVALIDARG;
                goto Exit;
            }
        }
    }

Exit:
    if (hKeySetup)
        RegCloseKey(hKeySetup);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:  Danpo Zhang

!ENDIF

MAJORCOMP=fusion
MINORCOMP=asmcache

TARGETNAME=urtasmc

TARGETTYPE=LIBRARY
TARGETPATHLIB=$(FUSION_LIB_DEST)

!IFDEF USE_PERFTAGS
C_DEFINES = $(C_DEFINES) -DPERFTAGS 
!ENDIF

SOURCES= \
    asmcache.cpp \
    asmint.cpp   \
    asmitem.cpp  \
    asmstrm.cpp  \
    asmenum.cpp  \
    transprt.cpp \
    cache.cpp    \
    scavenger.cpp \
    enum.cpp      \
    installApis.cpp  \
    refcount.cpp \
    refcountenum.cpp \
    cacheUtils.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\fusion\asmcache\refcountenum.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==


#include "refCountEnum.h"


// ---------------------------------------------------------------------------
// CreateInstallReferenceEnum
// ---------------------------------------------------------------------------
STDAPI CreateInstallReferenceEnum(IInstallReferenceEnum **ppRefEnum, 
                                  IAssemblyName *pName, 
                                  DWORD dwFlags, LPVOID pvReserved)
{
    HRESULT hr = S_OK;

    CInstallReferenceEnum *pEnum = NEW(CInstallReferenceEnum);
    if (!pEnum)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (FAILED(hr = pEnum->Init( pName, dwFlags)))
    {
        SAFERELEASE(pEnum);
        goto exit;
    }

    *ppRefEnum = (IInstallReferenceEnum*) pEnum;

exit:

    return hr;
}


// ---------------------------------------------------------------------------
// CreateInstallReferenceItem
// ---------------------------------------------------------------------------
STDAPI CreateInstallReferenceItem(IInstallReferenceItem **ppRefItem,
                                  LPFUSION_INSTALL_REFERENCE pRefData,
                                  DWORD dwFlags, LPVOID pvReserved)
{
    HRESULT hr = S_OK;

    CInstallReferenceItem *pRefItem = NEW(CInstallReferenceItem(pRefData));
    if (!pRefItem)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    *ppRefItem = (IInstallReferenceItem*) pRefItem;

exit:

    return hr;
}

// ---------------------------------------------------------------------------
// CInstallReferenceEnum ctor
// ---------------------------------------------------------------------------
CInstallReferenceEnum::CInstallReferenceEnum()
{
    _cRef = 0;
    _pInstallRefEnum    = NULL;
}


// ---------------------------------------------------------------------------
// CInstallReferenceEnum dtor
// ---------------------------------------------------------------------------
CInstallReferenceEnum::~CInstallReferenceEnum()
{
    SAFEDELETE (_pInstallRefEnum);
}


// ---------------------------------------------------------------------------
// CInstallReferenceEnum::Init
// ---------------------------------------------------------------------------
H