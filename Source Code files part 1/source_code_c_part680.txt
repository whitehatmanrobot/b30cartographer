o->hwndCb );
        SetWindowText( pInfo->hwndCb, pArgs->pszCheckLabel );
        Button_SetCheck( pInfo->hwndCb, *pArgs->pfCheck );
    }

    Edit_LimitText( pInfo->hwndEb, pArgs->dwMaxItemLen );

    // Set caller-defined dialog title and labels.
    //
    SetWindowText( pInfo->hwndDlg, pArgs->pszTitle );
    SetWindowText( pInfo->hwndStItem, pArgs->pszItemLabel );
    SetWindowText( pInfo->hwndStList, pArgs->pszListLabel );

    // Fill the listbox.
    //
    for (pNode = DtlGetFirstNode( pArgs->pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz = (TCHAR* )DtlGetData( pNode );
        ASSERT( psz );

        ListBox_AddItem( pInfo->hwndLb, psz, (VOID* ) DtlGetNodeId( pNode ) );
    }

    c = ListBox_GetCount( pInfo->hwndLb );
    if (c > 0)
    {
        // Select item selected by caller.
        //
        ListBox_SetCurSelNotify( pInfo->hwndLb, pArgs->iSelInitial );
        LeEnableUpAndDownButtons( pInfo );

        if (c == 1 && pInfo->fNoDeleteLast)
        {
            EnableWindow( pInfo->hwndPbDelete, FALSE );
        }
    }
    else
    {
        // Empty list.
        //
        if (!pInfo->fSorted)
        {
            EnableWindow( pInfo->hwndPbUp, FALSE );
            EnableWindow( pInfo->hwndPbDown, FALSE );
        }
        EnableWindow( pInfo->hwndPbDelete, FALSE );
    }

    // Set default edit box contents, if any.
    //
    if (pArgs->pszDefaultItem)
    {
        SetWindowText( pInfo->hwndEb, pArgs->pszDefaultItem );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }
    else
    {
        EnableWindow( pInfo->hwndPbAdd, FALSE );
        EnableWindow( pInfo->hwndPbReplace, FALSE );
    }

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.  Dlgedit.exe doesn't currently
    // support this at resource edit time.  When that's fixed set
    // DS_CONTEXTHELP there and remove this call.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
LeItemTextFromListSelection(
    IN LEINFO* pInfo )

    // Copies the currently selected item in the list to the edit box.
    // 'PInfo' is the dialog context.
    //
{
    TCHAR* psz;
    INT iSel;

    iSel = ListBox_GetCurSel( pInfo->hwndLb );
    if (iSel >= 0)
    {
        psz = ListBox_GetPsz( pInfo->hwndLb, iSel );
        if (psz)
        {
            SetWindowText( pInfo->hwndEb, psz );
            Free( psz );
            return;
        }
    }

    SetWindowText( pInfo->hwndEb, TEXT("") );
}


VOID
LeReplace(
    IN LEINFO* pInfo )

    // Replace button click handler.  'PInfo' is the dialog context.
    //
{
    TCHAR* psz;
    INT i;
    LONG_PTR lId;

    psz = GetText( pInfo->hwndEb );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    if (pInfo->pArgs->dwfFlags & LEDFLAG_Unique)
    {
        if (ListBox_IndexFromString( pInfo->hwndLb, psz ) >= 0)
        {
            MSGARGS msgargs;

            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.apszArgs[ 0 ] = psz;
            MsgDlg( pInfo->hwndDlg, SID_NotUnique, &msgargs );
            Edit_SetSel( pInfo->hwndEb, 0, -1 );
            SetFocus( pInfo->hwndEb );
            Free( psz );
            return;
        }
    }

    i = ListBox_GetCurSel( pInfo->hwndLb );
    lId = ListBox_GetItemData( pInfo->hwndLb, i );
    ListBox_DeleteString( pInfo->hwndLb, i );

    if (pInfo->fSorted)
    {
        i = ListBox_AddItem( pInfo->hwndLb, psz, (VOID* )lId );
    }
    else
    {
        ListBox_InsertString( pInfo->hwndLb, i, psz );
        ListBox_SetItemData( pInfo->hwndLb, i, lId );
    }

    Free( psz );
    ListBox_SetCurSel( pInfo->hwndLb, i );
    SetFocus( pInfo->hwndEb );
    SetWindowText( pInfo->hwndEb, TEXT("") );
}


BOOL
LeSaveSettings(
    IN LEINFO* pInfo )

    // Saves dialog settings in the stub API caller's list.  'PInfo' is the
    // dialog context.
    //
    // Returns true if successful, false if does not validate.
    //
{
    DWORD dwErr;
    DTLNODE* pNode;
    DTLLIST* pList;
    DTLLIST* pListNew;
    TCHAR* psz;
    LONG_PTR lId;
    INT c;
    INT i;

    // Make new list from list box contents.
    //
    do
    {
        pListNew = DtlCreateList( 0L );
        if (!pListNew)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        dwErr = 0;
        c = ListBox_GetCount( pInfo->hwndLb );

        for (i = 0; i < c; ++i)
        {
            psz = ListBox_GetPsz( pInfo->hwndLb, i );
            if (!psz)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            lId = ListBox_GetItemData( pInfo->hwndLb, i );
            ASSERT( lId>=0 );

            pNode = DtlCreateNode( psz, lId );
            if (!pNode)
            {
                Free( psz );
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            DtlAddNodeLast( pListNew, pNode );
        }
    }
    while (FALSE);

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_DisplayData, dwErr, NULL );
        DtlDestroyList( pListNew, DestroyPszNode );
        return FALSE;
    }

    // Free all data in the old list.
    //
    while (pNode = DtlGetFirstNode( pInfo->pArgs->pList ))
    {
        Free( (TCHAR* )DtlGetData( pNode ) );
        DtlDeleteNode( pInfo->pArgs->pList, pNode );
    }

    // Free the node-IDs in the list of deletions.
    //
    if (pInfo->pListDeletes)
    {
        while (pNode = DtlGetFirstNode( pInfo->pListDeletes ))
        {
            pInfo->pArgs->pDestroyId( (DTLNODE* )DtlGetNodeId( pNode ) );
            DtlDeleteNode( pInfo->pListDeletes, pNode );
        }
    }

    // Move the new list onto caller's list.
    //
    while (pNode = DtlGetFirstNode( pListNew ))
    {
        DtlRemoveNode( pListNew, pNode );
        DtlAddNodeLast( pInfo->pArgs->pList, pNode );
    }
    DtlDestroyList( pListNew, DestroyPszNode );

    // Tell caller what the checkbox setting is.
    //
    if (pInfo->pArgs->pfCheck)
    {
        *pInfo->pArgs->pfCheck = Button_GetCheck( pInfo->hwndCb );
    }

    return TRUE;
}


VOID
LeTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    LEINFO* pInfo = (LEINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "LeTerm" );

    if (pInfo)
    {
        if (pInfo->hbmUp)
        {
            DeleteObject( pInfo->hbmUp );
        }

        if (pInfo->hbmDown)
        {
            DeleteObject( pInfo->hbmDown );
        }

        DtlDestroyList( pInfo->pListDeletes, NULL );
        Free( pInfo );
    }
}


VOID
LeUp(
    IN LEINFO* pInfo )

    // Up button click handler.  'PInfo' is the dialog context.
    //
{
    TCHAR* psz;
    INT i;
    LONG_PTR lId;

    ASSERT( !pInfo->fSorted );

    i = ListBox_GetCurSel( pInfo->hwndLb );
    psz = ListBox_GetPsz( pInfo->hwndLb, i );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    ListBox_InsertString( pInfo->hwndLb, i - 1, psz );
    Free( psz );
    lId = ListBox_GetItemData( pInfo->hwndLb, i + 1 );
    ListBox_DeleteString( pInfo->hwndLb, i + 1 );
    ListBox_SetItemData( pInfo->hwndLb, i - 1, lId );
    ListBox_SetCurSel( pInfo->hwndLb, i - 1 );

    if (i == 1)
    {
        Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbDown );
        SetFocus( pInfo->hwndPbDown );
    }

    LeEnableUpAndDownButtons( pInfo );
}


//-----------------------------------------------------------------------------
// String Editor dialog entry point
//-----------------------------------------------------------------------------

BOOL
StringEditorDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszIn,
    IN DWORD dwSidTitle,
    IN DWORD dwSidLabel,
    IN DWORD cbMax,
    IN DWORD dwHelpId,
    IN OUT TCHAR** ppszOut )

    // Pops-up the String Editor dialog.  'PszIn' is the initial setting of
    // the edit box or NULL for blank.  'DwSidTitle' and 'dwSidLabel' are the
    // string resource IDs of the dialog title and edit box label.  'CbMax' is
    // the maximum length of the to allow or 0 for no limit.  'DwHelpId' is
    // the HID_* constant to associate with the label and edit field or -1 if
    // none.
    //
    // Returns true if user pressed OK and succeeded, false if he pressed
    // Cancel or encountered an error.  If true, '*ppszNumber' is a heap block
    // with the edited result.  It is caller's responsibility to Free the
    // returned block.
    //
{
    INT_PTR nStatus;
    ZEARGS args;

    TRACE( "StringEditorDlg" );

    args.pszIn = pszIn;
    args.dwSidTitle = dwSidTitle;
    args.dwSidLabel = dwSidLabel;
    args.cbMax = cbMax;
    args.dwHelpId = dwHelpId;
    args.ppszOut = ppszOut;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_ZE_StringEditor ),
            hwndOwner,
            ZeDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


//----------------------------------------------------------------------------
// String Editor dialog routines
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
ZeDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Edit Phone Number dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "ZeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return ZeInit( hwnd, (ZEARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ZEINFO* pInfo;

            pInfo = (ZEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            if (pInfo && pInfo->pArgs->dwHelpId != (DWORD )-1)
            {
                DWORD adwZeHelp[ (2 + 1) * 2 ];

                ZeroMemory( adwZeHelp, sizeof(adwZeHelp) );
                adwZeHelp[ 0 ] = CID_ZE_ST_String;
                adwZeHelp[ 2 ] = CID_ZE_EB_String;
                adwZeHelp[ 1 ] = adwZeHelp[ 3 ] = pInfo->pArgs->dwHelpId;

                ContextHelp( adwZeHelp, hwnd, unMsg, wparam, lparam );
                break;
            }
        }

        case WM_COMMAND:
        {
            ZEINFO* pInfo = (ZEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return ZeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            ZeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
ZeCommand(
    IN ZEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "ZeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            TRACE( "OK pressed" );
            *pInfo->pArgs->ppszOut = GetText( pInfo->hwndEb );
            EndDialog( pInfo->hwndDlg, (*pInfo->pArgs->ppszOut != NULL) );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
ZeInit(
    IN HWND hwndDlg,
    IN ZEARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments as passed to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    TCHAR* psz;
    ZEINFO* pInfo;

    TRACE( "ZeInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndEb = GetDlgItem( hwndDlg, CID_ZE_EB_String );
    ASSERT( pInfo->hwndEb );

    if (pArgs->cbMax > 0)
    {
        Edit_LimitText( pInfo->hwndEb, pArgs->cbMax );
    }

    psz = PszFromId( g_hinstDll, pArgs->dwSidTitle );
    if (psz)
    {
        SetWindowText( hwndDlg, psz );
        Free( psz );
    }

    psz = PszFromId( g_hinstDll, pArgs->dwSidLabel );
    if (psz)
    {
        HWND hwndSt = GetDlgItem( hwndDlg, CID_ZE_ST_String );
        ASSERT( hwndSt );
        SetWindowText( hwndSt, psz );
        Free( psz );
    }

    if (pArgs->pszIn)
    {
        SetWindowText( pInfo->hwndEb, pArgs->pszIn );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.  Dlgedit.exe doesn't currently
    // support this at resource edit time.  When that's fixed set
    // DS_CONTEXTHELP there and remove this call.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
ZeTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    ZEINFO* pInfo = (ZEINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "ZeTerm" );

    if (pInfo)
    {
        Free( pInfo );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\entryps.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// entryps.c
// Remote Access Common Dialog APIs
// Phonebook Entry property sheet
//
// 06/20/95 Steve Cobb
//


#include "rasdlgp.h"
#include "entryps.h"
#include "uiinfo.h"
#include "inetcfgp.h"
#include "netcon.h"
#include "rassrvrc.h"
#include "shlobjp.h"
#include "shellapi.h"
#include "iphlpapi.h"
#include "prsht.h"
#include "pbkp.h"

// Page definitions.
//
#define PE_GePage 0
#define PE_OePage 1
#define PE_LoPage 2
#define PE_NePage 3
#define PE_SaPage 4

#define PE_PageCount 5


// (Router) Callback context block.
//
#define CRINFO struct tagCRINFO
CRINFO
{
    /* Caller's argument to the stub API.
    */
    EINFO* pArgs;

    /* Dialog and control handles.
    */
    HWND hwndDlg;
    HWND hwndRbNo;
    HWND hwndRbYes;
    HWND hwndLvNumbers;
    HWND hwndPbEdit;
    HWND hwndPbDelete;
};

static TCHAR g_pszFirewallRegKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\HomeNetworking\\PersonalFirewall");
static TCHAR g_pszDisableFirewallWarningValue[] = TEXT("ShowDisableFirewallWarning");

//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static const DWORD g_adwGeHelp[] =
{
    CID_GE_GB_ConnectUsing,      HID_GE_LV_Device, //HID_GE_GB_ConnectUsing,
    CID_GE_LV_Device,            HID_GE_LV_Device,
    CID_GE_LV_Devices,           HID_GE_LV_Devices,
    CID_GE_PB_MoveUp,            HID_GE_PB_MoveUp,
    CID_GE_PB_MoveDown,          HID_GE_PB_MoveDown,
    CID_GE_CB_SharedPhoneNumber, HID_GE_CB_SharedPhoneNumber,
    CID_GE_PB_Configure,         HID_GE_PB_Configure,
    CID_GE_ST_AreaCodes,         HID_GE_CLB_AreaCodes,
    CID_GE_CLB_AreaCodes,        HID_GE_CLB_AreaCodes,
    CID_GE_ST_PhoneNumber,       HID_GE_EB_PhoneNumber,
    CID_GE_EB_PhoneNumber,       HID_GE_EB_PhoneNumber,
    CID_GE_ST_CountryCodes,      HID_GE_LB_CountryCodes,
    CID_GE_LB_CountryCodes,      HID_GE_LB_CountryCodes,
    CID_GE_CB_UseDialingRules,   HID_GE_CB_UseDialingRules,
    CID_GE_PB_Alternates,        HID_GE_PB_Alternates,
    CID_GE_CB_ShowIcon,          HID_GE_CB_ShowIcon,
    CID_GE_ST_HostName,          HID_GE_EB_HostName,
    CID_GE_EB_HostName,          HID_GE_EB_HostName,
    CID_GE_ST_ServiceName,       HID_GE_EB_ServiceName, //Add for whistler bug 343249
    CID_GE_EB_ServiceName,       HID_GE_EB_ServiceName,
    CID_GE_GB_FirstConnect,      -1, //HID_GE_GB_FirstConnect,
    CID_GE_ST_Explain,           HID_GE_GB_FirstConnect,
    CID_GE_CB_DialAnotherFirst,  HID_GE_CB_DialAnotherFirst,
    CID_GE_LB_DialAnotherFirst,  HID_GE_LB_DialAnotherFirst,
    CID_GE_ST_Devices,           HID_GE_LB_Devices,
    CID_GE_LB_Devices,           HID_GE_LB_Devices,
    CID_GE_PB_DialingRules,      HID_GE_PB_DialingRules,
    CID_GE_GB_PhoneNumber,       -1,
    0, 0
};

static const DWORD g_adwOeHelp[] =
{
    CID_OE_GB_Progress,        -1,      //commented for bug 15738//HID_OE_GB_Progress,
    CID_OE_CB_DisplayProgress, HID_OE_CB_DisplayProgress,
    CID_OE_CB_PreviewUserPw,   HID_OE_CB_PreviewUserPw,
    CID_OE_CB_PreviewDomain,   HID_OE_CB_PreviewDomain,
    CID_OE_CB_PreviewNumber,   HID_OE_CB_PreviewNumber,
    CID_OE_GB_Redial,          -1,      //commented for bug 15738//HID_OE_GB_Redial,
    CID_OE_ST_RedialAttempts,  HID_OE_EB_RedialAttempts,
    CID_OE_EB_RedialAttempts,  HID_OE_EB_RedialAttempts,
    CID_OE_ST_RedialTimes,     HID_OE_LB_RedialTimes,
    CID_OE_LB_RedialTimes,     HID_OE_LB_RedialTimes,
    CID_OE_ST_IdleTimes,       HID_OE_LB_IdleTimes,
    CID_OE_LB_IdleTimes,       HID_OE_LB_IdleTimes,
    CID_OE_CB_RedialOnDrop,    HID_OE_CB_RedialOnDrop,
    CID_OE_GB_MultipleDevices, -1,      //commented for bug 15738//HID_OE_GB_MultipleDevices,
    CID_OE_LB_MultipleDevices, HID_OE_LB_MultipleDevices,
    CID_OE_PB_Configure,       HID_OE_PB_Configure,
    CID_OE_PB_X25,             HID_OE_PB_X25,
    CID_OE_PB_Tunnel,          HID_OE_PB_Tunnel,
    CID_OE_RB_DemandDial,      HID_OE_RB_DemandDial,
    CID_OE_RB_Persistent,      HID_OE_RB_Persistent,
    0, 0
};

static const DWORD g_adwOeRouterHelp[] =
{
    CID_OE_GB_Progress,        -1,      //commented for bug 15738//HID_OE_GB_Progress,
    CID_OE_CB_DisplayProgress, HID_OE_CB_DisplayProgress,
    CID_OE_CB_PreviewUserPw,   HID_OE_CB_PreviewUserPw,
    CID_OE_CB_PreviewDomain,   HID_OE_CB_PreviewDomain,
    CID_OE_CB_PreviewNumber,   HID_OE_CB_PreviewNumber,
    CID_OE_GB_Redial,          -1,      //commented for bug 15738//HID_OE_GB_Redial,
    CID_OE_ST_RedialAttempts,  HID_OE_EB_RedialAttempts,
    CID_OE_EB_RedialAttempts,  HID_OE_EB_RedialAttempts,
    CID_OE_ST_RedialTimes,     HID_OE_LB_RedialTimes,
    CID_OE_LB_RedialTimes,     HID_OE_LB_RedialTimes,
    CID_OE_ST_IdleTimes,       HID_OE_LB_IdleTimesRouter,
    CID_OE_LB_IdleTimes,       HID_OE_LB_IdleTimesRouter,
    CID_OE_CB_RedialOnDrop,    HID_OE_CB_RedialOnDrop,
    CID_OE_GB_MultipleDevices, -1,      //commented for bug 15738//HID_OE_GB_MultipleDevices,
    CID_OE_LB_MultipleDevices, HID_OE_LB_MultipleDevices,
    CID_OE_PB_Configure,       HID_OE_PB_Configure,
    CID_OE_PB_X25,             HID_OE_PB_X25,
    CID_OE_PB_Tunnel,          HID_OE_PB_Tunnel,
    CID_OE_RB_DemandDial,      HID_OE_RB_DemandDial,
    CID_OE_RB_Persistent,      HID_OE_RB_Persistent,
    CID_OE_PB_Callback,        HID_OE_PB_Callback,
    0, 0
};

//Get rid of the const qualifire for whistler bug#276452
static DWORD g_adwLoHelp[] =
{
    CID_LO_GB_SecurityOptions,  -1,     //commented for bug 15738//HID_LO_GB_SecurityOptions,
    CID_LO_RB_TypicalSecurity,  HID_LO_RB_TypicalSecurity,
    CID_LO_ST_Auths,            HID_LO_LB_Auths,
    CID_LO_LB_Auths,            HID_LO_LB_Auths,
    CID_LO_CB_UseWindowsPw,     HID_LO_CB_UseWindowsPw,
    CID_LO_CB_Encryption,       HID_LO_CB_Encryption,
    CID_LO_RB_AdvancedSecurity, HID_LO_RB_AdvancedSecurity,
    CID_LO_ST_AdvancedText,     HID_LO_PB_Advanced,
    CID_LO_PB_Advanced,         HID_LO_PB_Advanced,
    CID_LO_GB_Scripting,        -1,     //commented for bug 15738//HID_LO_GB_Scripting,
    CID_LO_CB_RunScript,        HID_LO_CB_RunScript,
    CID_LO_CB_Terminal,         HID_LO_CB_Terminal,
    CID_LO_LB_Scripts,          HID_LO_LB_Scripts,
    CID_LO_PB_Edit,             HID_LO_PB_Edit,
    CID_LO_PB_Browse,           HID_LO_PB_Browse,
    CID_LO_ST_IPSecText,        HID_LO_PB_IPSec,
    CID_LO_PB_IPSec,            HID_LO_PB_IPSec,//On Server, this help ID will be HID_LO_PB_IPSecServer
    0, 0
};

static const DWORD g_adwNeHelp[] =
{
    CID_NE_ST_ServerType,           HID_NE_LB_ServerType,
    CID_NE_LB_ServerType,           HID_NE_LB_ServerType,
    CID_NE_PB_Settings,             HID_NE_PB_Settings,
    CID_NE_ST_Components,           HID_NE_LV_Components,
    CID_NE_LV_Components,           HID_NE_LV_Components,
    CID_NE_PB_Add,                  HID_NE_PB_Add,
    CID_NE_PB_Remove,               HID_NE_PB_Remove,
    CID_NE_PB_Properties,           HID_NE_PB_Properties,
    CID_NE_GB_Description,          -1,     //commented for bug 15738//HID_NE_LB_ComponentDesc,
    CID_NE_LB_ComponentDesc,        HID_NE_LB_ComponentDesc,
    0, 0
};

static const DWORD g_adwPpHelp[] =
{
    CID_NE_EnableLcp,               HID_NE_EnableLcp,
    CID_NE_EnableCompression,       HID_NE_EnableCompression,
    CID_NE_NegotiateMultilinkAlways,HID_NE_NegotiateMultilinkAlways,
    0, 0
};

static DWORD g_adwCrHelp[] =
{
    CID_CR_RB_No,      HID_CR_RB_No,
    CID_CR_RB_Yes,     HID_CR_RB_Yes,
    CID_CR_PB_Edit,    HID_CR_PB_Edit,
    CID_CR_PB_Delete,  HID_CR_PB_Delete,
    CID_CR_LV_Numbers, HID_CR_LV_Numbers,
    0, 0
};

static DWORD g_adwSaHelp[] =
{
    CID_SA_PB_Shared,       HID_SA_PB_Shared,
    CID_SA_GB_Shared,       -1,
    CID_SA_PB_DemandDial,   HID_SA_PB_DemandDial,
    CID_SA_ST_DemandDial,   HID_SA_PB_DemandDial,
    CID_SA_PB_Settings,     HID_SA_PB_Settings,
    CID_SA_GB_PrivateLan,   -1,
    CID_SA_ST_PrivateLan,   HID_SA_LB_PrivateLan,
    CID_SA_LB_PrivateLan,   HID_SA_LB_PrivateLan,
    0, 0
};

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOL
RouterCallbackDlg(
    IN     HWND   hwndOwner,
    IN OUT EINFO* pEinfo );

INT_PTR CALLBACK
CrDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CrCommand(
    IN CRINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

BOOL
CrInit(
    IN HWND   hwndDlg,
    IN EINFO* pArgs );

VOID
CrSave(
    IN CRINFO* pInfo );

VOID
CrTerm(
    IN HWND hwndDlg );

VOID
CrUpdateLvAndPbState(
    IN CRINFO* pInfo );

VOID
GeAlternates(
    IN PEINFO* pInfo );

VOID
GeDialingRules(
    IN PEINFO* pInfo );

INT_PTR CALLBACK
GeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

INT_PTR CALLBACK
GeDlgProcMultiple(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

INT_PTR CALLBACK
GeDlgProcSingle(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
GeClearLbDialAnotherFirst(
    IN HWND hwndLbDialAnotherFirst );

BOOL
GeCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
GeConfigure(
    IN PEINFO* pInfo );

VOID
GeDialAnotherFirstSelChange(
    IN PEINFO* pInfo );

BOOL
GeFillLbDialAnotherFirst(
    IN PEINFO* pInfo,
    IN BOOL fAbortIfPrereqNotFound );

VOID
GeGetPhoneFields(
    IN PEINFO* pInfo,
    OUT DTLNODE* pDstLinkNode );

BOOL
GeInit(
    IN HWND hwndPage,
    IN OUT EINFO* pArgs );

LVXDRAWINFO*
GeLvDevicesCallbackMultiple(
    IN HWND hwndLv,
    IN DWORD dwItem );

LVXDRAWINFO*
GeLvDevicesCallbackSingle(
    IN HWND hwndLv,
    IN DWORD dwItem );

VOID
GeMoveDevice(
    IN PEINFO* pInfo,
    IN BOOL fUp );

DWORD
GeSaveLvDeviceChecks(
    IN PEINFO* pInfo );

VOID
GeUpdateDialAnotherFirstState(
    IN PEINFO* pInfo );

VOID
GeSetPhoneFields(
    IN PEINFO* pInfo,
    IN DTLNODE* pSrcLinkNode,
    IN BOOL fDisableAll );

VOID
GeUpdatePhoneNumberFields(
    IN PEINFO* pInfo,
    IN BOOL fSharedToggle );

VOID
GeUpdatePhoneNumberTitle(
    IN PEINFO* pInfo,
    IN TCHAR* pszDevice );

VOID
GeUpdateUpDownButtons(
    IN PEINFO* pInfo );

BOOL
LoCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
LoDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
LoEnableSecuritySettings(
    IN PEINFO* pInfo,
    IN BOOL fTypical,
    IN BOOL fAdvanced );

VOID
LoFillLbAuths(
    IN PEINFO* pInfo );

BOOL
LoInit(
    IN HWND hwndPage );

VOID
LoLbAuthsSelChange(
    IN PEINFO* pInfo );

VOID
LoRefreshSecuritySettings(
    IN PEINFO* pInfo );

VOID
LoSaveTypicalAuthSettings(
    IN PEINFO* pInfo );

INT_PTR CALLBACK
NeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
NeInit(
    IN HWND hwndPage );

void
NeServerTypeSelChange (
    IN PEINFO* pInfo);

void
NeAddComponent (
    IN PEINFO*  pInfo);

void
NeEnsureNetshellLoaded (
    IN PEINFO* pInfo);

void
NeRemoveComponent (
    IN PEINFO* pInfo);

void
NeLvClick (
    IN PEINFO* pInfo,
    IN BOOL fDoubleClick);

void
NeLvItemChanged (
    IN PEINFO* pInfo);

void
NeSaveBindingChanges (
    IN PEINFO* pInfo);

void
NeLvDeleteItem (
    IN PEINFO* pInfo,
    IN NM_LISTVIEW* pnmlv);

BOOL
OeCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
OeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
OeEnableMultipleDeviceGroup(
    IN PEINFO* pInfo,
    IN BOOL fEnable );

BOOL
OeInit(
    IN HWND hwndPage );

VOID
OeTunnel(
    IN PEINFO* pInfo );

VOID
OeUpdateUserPwState(
    IN PEINFO* pInfo );

VOID
OeX25(
    IN PEINFO* pInfo );

BOOL
PeApply(
    IN HWND hwndPage );

PEINFO*
PeContext(
    IN HWND hwndPage );

DWORD
PeCountEnabledLinks(
    IN PEINFO* pInfo );

VOID
PeExit(
    IN PEINFO* pInfo,
    IN DWORD dwError );

VOID
PeExitInit(
    IN HWND hwndDlg,
    IN EINFO* pEinfo,
    IN DWORD dwError );

PEINFO*
PeInit(
    IN HWND hwndFirstPage,
    IN EINFO* pArgs );

VOID
PeTerm(
    IN HWND hwndPage );

INT_PTR CALLBACK
PpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

INT_PTR CALLBACK
RdDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SaCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
SaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

INT_PTR CALLBACK
SaUnavailDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SaInit(
    IN HWND   hwndDlg );

INT_PTR CALLBACK
SaDisableFirewallWarningDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL SaIsAdapterDHCPEnabled(
    IN IHNetConnection* pConnection);

// wrapper to load homenet page:  used in PePropertySheet(...)
HRESULT HrLoadHNetGetFirewallSettingsPage (PROPSHEETPAGEW * ppsp, EINFO* pInfo)
{
    PROPSHEETPAGEW psp;
    HRESULT hr;
    HNET_CONN_PROPERTIES *pProps;
    IHNetConnection *pHNetConn = NULL;
    IHNetCfgMgr *pHNetCfgMgr = NULL;

//  _asm int 3

    ZeroMemory (&psp, sizeof(PROPSHEETPAGEW));
    psp.dwSize = sizeof(PROPSHEETPAGEW);
    *ppsp = psp;

    // Make sure COM is initialized on this thread.
    //
    hr = CoInitializeEx(
            NULL, 
            COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE
            );

    if (SUCCEEDED(hr))
    {
        pInfo->fComInitialized = TRUE;
    }
    else if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr)) {
        // pass the Guid to the export from hnetcfg ("HNetGetFirewallSettingsPage").
        HINSTANCE hinstDll = LoadLibrary (TEXT("hnetcfg.dll"));
        if (hinstDll == NULL)
            hr = HRESULT_FROM_WIN32 (GetLastError());
        else {
            HRESULT (*pfnGetPage) (PROPSHEETPAGEW *, GUID *);
            pfnGetPage = (HRESULT (*)(PROPSHEETPAGEW *, GUID *))GetProcAddress (hinstDll, "HNetGetFirewallSettingsPage");
            if (!pfnGetPage)
                hr = HRESULT_FROM_WIN32 (GetLastError());
            else
                hr = pfnGetPage (&psp, pInfo->pEntry->pGuid);

            FreeLibrary (hinstDll);
        }
        if (hr == S_OK)
            *ppsp = psp;
    }
    return pInfo->hShowHNetPagesResult = hr;
}

//----------------------------------------------------------------------------
// Phonebook Entry property sheet entrypoint
//----------------------------------------------------------------------------

VOID
PePropertySheet(
    IN OUT EINFO* pEinfo )

    // Runs the Phonebook entry property sheet.  'PEinfo' is the API caller's
    // arguments.
    //
{
    PROPSHEETPAGE apage[ PE_PageCount ];
    PROPSHEETPAGE* ppage;
    INT nPages;
    INT nPageIndex;

    TRACE( "PePropertySheet" );

    nPages = PE_PageCount;
    ZeroMemory( apage, sizeof(apage) );

    // General page.
    //
    ppage = &apage[ PE_GePage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    if (pEinfo->pEntry->dwType == RASET_Vpn)
    {
        ppage->pszTemplate = MAKEINTRESOURCE( PID_GE_GeneralVpn );
        ppage->pfnDlgProc = GeDlgProc;
    }
    else if (pEinfo->pEntry->dwType == RASET_Broadband)
    {
        ppage->pszTemplate = MAKEINTRESOURCE( PID_GE_GeneralBroadband );
        ppage->pfnDlgProc = GeDlgProc;
    }
    else if (pEinfo->pEntry->dwType == RASET_Phone)
    {
        if (pEinfo->fMultipleDevices)
        {
            if (pEinfo->fRouter)
            {
                ppage->pszTemplate =
                    MAKEINTRESOURCE( PID_GE_RouterGeneralMultiple );
            }
            else
            {
                ppage->pszTemplate =
                    MAKEINTRESOURCE( PID_GE_GeneralMultiple );
            }

            ppage->pfnDlgProc = GeDlgProcMultiple;
        }
        else
        {
            if (pEinfo->fRouter)
            {
                ppage->pszTemplate =
                    MAKEINTRESOURCE( PID_GE_RouterGeneralSingle );
            }
            else
            {
                ppage->pszTemplate =
                    MAKEINTRESOURCE( PID_GE_GeneralSingle );
            }

            ppage->pfnDlgProc = GeDlgProcSingle;
        }
    }
    else
    {
        ASSERT( pEinfo->pEntry->dwType == RASET_Direct );
        ppage->pszTemplate = MAKEINTRESOURCE( PID_GE_GeneralDirect );
        ppage->pfnDlgProc = GeDlgProc;
    }

    ppage->lParam = (LPARAM )pEinfo;

    // Options page.
    //
    ppage = &apage[ PE_OePage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate =
        (pEinfo->fRouter)
            ? MAKEINTRESOURCE( PID_OE_OptionsRouter )
            : ((pEinfo->pEntry->dwType == RASET_Phone)
                  ? MAKEINTRESOURCE( PID_OE_Options )
                  : MAKEINTRESOURCE( PID_OE_OptionsVD ));
    ppage->pfnDlgProc = OeDlgProc;

    // Security page.
    //
    ppage = &apage[ PE_LoPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;

    //
    //Add new Security Page for bug 193987 PSK
    //

    if ( pEinfo->pEntry->dwType == RASET_Vpn )
    {
        ppage->pszTemplate = MAKEINTRESOURCE( PID_LO_SecurityVpn );
    }
    else
    {
        ppage->pszTemplate = MAKEINTRESOURCE( PID_LO_Security );
    }
    ppage->pfnDlgProc = LoDlgProc;

    // Network page.
    //
    ppage = &apage[ PE_NePage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_NE_Network );
    ppage->pfnDlgProc = NeDlgProc;

    // Advanced page.
    // (AboladeG) The page is shown if the user is admin and
    // there is at least one LAN connection, or if this phonebook entry
    // is already shared.
    //
    nPageIndex = PE_SaPage;

    if((!pEinfo->fIsUserAdminOrPowerUser) || (pEinfo->fRouter))
    {
        --nPages;
    }
    else
    {
        HRESULT hr;
        BOOL fShowAdvancedUi = TRUE;
        INetConnectionUiUtilities* pncuu = NULL;

        // Check if ZAW is denying access to the Shared Access UI
        //
        hr = HrCreateNetConnectionUtilities(&pncuu);
        if (SUCCEEDED(hr))
        {
            if(FALSE == INetConnectionUiUtilities_UserHasPermission(pncuu, NCPERM_ShowSharedAccessUi) && 
                    FALSE == INetConnectionUiUtilities_UserHasPermission(pncuu, NCPERM_PersonalFirewallConfig))
            fShowAdvancedUi = FALSE;
                
            INetConnectionUiUtilities_Release(pncuu);
        }

        if (!fShowAdvancedUi)
        {
            --nPages;
        }
        else
        {
            // Finally, check whether TCP/IP is installed or not.
            //
            if (!FIsTcpipInstalled())
            {
                --nPages;
            }
            else
            {
                ppage = &apage[ nPageIndex++ ];
                ppage->dwSize = sizeof(PROPSHEETPAGE);
                ppage->hInstance = g_hinstDll;
                {
                    PROPSHEETPAGEW psp;
                    hr = HrLoadHNetGetFirewallSettingsPage (&psp, pEinfo);
                    if (hr == S_OK)
                       *ppage = psp;
                }
                if (hr != S_OK)
                {
                    ppage->pszTemplate = MAKEINTRESOURCE( PID_SA_HomenetUnavailable );
                    ppage->pfnDlgProc = SaUnavailDlgProc;
                }
            }
        }
    }

    if (pEinfo->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
    {
        INT i;
        BOOL fStatus;
        RASEDSHELLOWNEDR2* pShellOwnedInfo;

        pShellOwnedInfo = (RASEDSHELLOWNEDR2*)pEinfo->pApiArgs->reserved2;

        // The property sheet is to be invoked by the shell, using the shell
        // convention of adding pages via callback.
        //
        for (i = 0; i < nPages; ++i)
        {
            HPROPSHEETPAGE h;

            h = CreatePropertySheetPage( &apage[ i ] );
            if (!h)
            {
                TRACE( "CreatePage failed" );
                break;
            }

            fStatus = pShellOwnedInfo->pfnAddPage( h, pShellOwnedInfo->lparam );

            if (!fStatus)
            {
                TRACE( "AddPage failed" );
                DestroyPropertySheetPage( h );
                break;
            }
        }

        if (i < nPages)
        {
            ErrorDlg( pEinfo->pApiArgs->hwndOwner,
                SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        }
    }
    else
    {
        PROPSHEETHEADER header;
        PWSTR pszBuf = NULL;
        PWSTR pszHeader;
        DWORD cb;
        HICON hIcon         = NULL;
        DWORD dwDisplayIcon = 0;
        int i;
        HPROPSHEETPAGE hPages[PE_PageCount];

        //For whistler bug 382720 349866        gangz
        //to fusionalize well for both rasdlg pages in NCW and
        //property pages launched by pressing "Property" button
        //besides following the normal fusion steps: we have to
        // (1) add _WIN32_WINNT=0x501 in the file sources
        // (2) use the phpage member in PROPSHEETHEADER structure, that is
        //    use CreatePropertySheetPage() to create page handles

        for (i = 0; i < nPages; ++i)
        {
            hPages[i] = CreatePropertySheetPage( &apage[ i ] );
            if ( !hPages[i] )
            {
                TRACE( "CreatePage failed" );
                break;
            }
        }
        
        if (i < nPages)
        {
            ErrorDlg( pEinfo->pApiArgs->hwndOwner,
                SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        }
        else
       {
        // Create the correct properties header 
        pszHeader = PszFromId(g_hinstDll, SID_PropertiesHeader);
        if (pszHeader)
        {
            cb = lstrlenW(pEinfo->pEntry->pszEntryName) +
                 1 +  
                 lstrlenW(pszHeader) + 
                 1; 

            pszBuf = Malloc(cb * sizeof(TCHAR));
            if (!pszBuf)
            {
                TRACE("Properties header allocation failed");
            }
            else
            {
                lstrcpyW(pszBuf, pEinfo->pEntry->pszEntryName);
                lstrcatW(pszBuf, L" ");
                lstrcatW(pszBuf, pszHeader);
            }

            Free(pszHeader);
        }

        //For whistler bug 372078 364876   gangz
        //
        hIcon = GetCurrentIconEntryType(pEinfo->pEntry->dwType,
                                        TRUE); //TRUE means small Icon
        
        if (hIcon)
        {
            dwDisplayIcon = PSH_USEHICON;
        }

        // The property sheet is to be invoked directly.
        //
        ZeroMemory( &header, sizeof(header) );

        header.dwSize       = sizeof(PROPSHEETHEADER);
//        header.dwFlags      = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_USECALLBACK | dwDisplayIcon;
        header.dwFlags      = PSH_NOAPPLYNOW | PSH_USECALLBACK | dwDisplayIcon;
        header.hwndParent   = pEinfo->pApiArgs->hwndOwner;
        header.hInstance    = g_hinstDll;
        header.pszCaption   = (pszBuf)?(pszBuf):(pEinfo->pEntry->pszEntryName);
        header.nPages       = nPages;
//        header.ppsp         = apage;
        header.phpage       = hPages;
        header.hIcon        = hIcon;
        header.pfnCallback  = UnHelpCallbackFunc;

        if (PropertySheet( &header ) == -1)
        {
            TRACE( "PropertySheet failed" );
            ErrorDlg( pEinfo->pApiArgs->hwndOwner,
                SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        }

        Free0(pszBuf);

        //For whistler bug 372078
        //GetCurrentIconEntryType() loads Icon from netshell where the icon is loaded
        //by LoadImage() without LR_SHARED, so I have to destroy it when we are done
        //with it
        //
        if (hIcon)
        {
            DestroyIcon( hIcon );
        }
       }    
    }
}

//----------------------------------------------------------------------------
// Phonebook Entry property sheet
// Listed alphabetically
//----------------------------------------------------------------------------

BOOL
PeApply(
    IN HWND hwndPage )

    // Saves the contents of the property sheet.  'HwndPage is the handle of a
    // property page.  Pops up any errors that occur.
    //
    // Returns true is page can be dismissed, false otherwise.
    //
{
    DWORD dwErr;
    PEINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "PeApply" );

    pInfo = PeContext( hwndPage );
    ASSERT( pInfo );
    if (pInfo == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    pEntry = pInfo->pArgs->pEntry;
    ASSERT( pEntry );

    // Save General page fields.
    //
    ASSERT( pInfo->hwndGe );
    {
        DTLNODE* pNode;

        // Retrieve the lone common control.
        //
        pEntry->fShowMonitorIconInTaskBar =
            Button_GetCheck( pInfo->hwndCbShowIcon );

        if (pEntry->dwType == RASET_Phone)
        {
            DWORD dwCount;

            dwCount = GeSaveLvDeviceChecks( pInfo );

            // Don't allow the user to deselect all of the
            // devices
            if ( (pInfo->pArgs->fMultipleDevices) && (dwCount == 0) )
            {
                MsgDlg( hwndPage, SID_SelectDevice, NULL );
                PropSheet_SetCurSel ( pInfo->hwndDlg, pInfo->hwndGe, 0 );
                SetFocus ( pInfo->hwndLvDevices );
                return FALSE;
            }

            // Save the "shared phone number" setting.  As usual, single
            // device mode implies shared mode, allowing things to fall
            // through correctly.
            //
            if (pInfo->pArgs->fMultipleDevices)
            {
                pEntry->fSharedPhoneNumbers =
                    Button_GetCheck( pInfo->hwndCbSharedPhoneNumbers );
            }
            else
            {
                pEntry->fSharedPhoneNumbers = TRUE;
            }

            // Set the phone number set for the first phone number of the
            // current link (shared or selected) to the contents of the phone
            // number controls.
            //
            GeGetPhoneFields( pInfo, pInfo->pCurLinkNode );

            // Swap lists, saving updates to caller's global list of area
            // codes.  Caller's original list will be destroyed by PeTerm.
            //
            if (pInfo->pListAreaCodes)
            {
                DtlSwapLists(
                    pInfo->pArgs->pUser->pdtllistAreaCodes,
                    pInfo->pListAreaCodes );
                pInfo->pArgs->pUser->fDirty = TRUE;
            }
        }
        else if (pEntry->dwType == RASET_Vpn)
        {
            // For whistler 522872
            DTLNODE* pNodeTmp = NULL;
            PBLINK* pLink = NULL;
            PBPHONE* pPhone = NULL;

            // Save host name, i.e. the VPN phone number.
            //
            pNodeTmp = DtlGetFirstNode( pEntry->pdtllistLinks );
            ASSERT( pNodeTmp );
            pLink = (PBLINK* )DtlGetData( pNodeTmp );
            pNodeTmp = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

            if(NULL == pNodeTmp)
            {
                return FALSE;
            }
            
            pPhone = (PBPHONE* )DtlGetData( pNodeTmp );
            Free0( pPhone->pszPhoneNumber );
            pPhone->pszPhoneNumber = GetText( pInfo->hwndEbHostName );
            FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNodeTmp );

            // Any prequisite entry selection change has been saved already.
            // Just need to toss it if disabled.
            //
            if (!Button_GetCheck( pInfo->hwndCbDialAnotherFirst ))
            {
                Free0( pEntry->pszPrerequisiteEntry );
                pEntry->pszPrerequisiteEntry = NULL;
                Free0( pEntry->pszPrerequisitePbk );
                pEntry->pszPrerequisitePbk = NULL;
            }
        }
        else if (pEntry->dwType == RASET_Broadband)
        {
            DTLNODE* pNodeTmp = NULL;
            PBLINK* pLink = NULL;
            PBPHONE* pPhone = NULL;

            // Save service name, i.e. the broadband phone number.
            //
            pNodeTmp = DtlGetFirstNode( pEntry->pdtllistLinks );
            ASSERT( pNodeTmp );
            pLink = (PBLINK* )DtlGetData( pNodeTmp );
            pNodeTmp = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

            if(NULL == pNodeTmp)
            {
                return FALSE;
            }
            
            pPhone = (PBPHONE* )DtlGetData( pNodeTmp );
            Free0( pPhone->pszPhoneNumber );
            pPhone->pszPhoneNumber = GetText( pInfo->hwndEbBroadbandService );
            FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNodeTmp );
        }
        else if (pEntry->dwType == RASET_Direct)
        {
            DTLNODE* pNodeTmp = NULL;
            PBLINK* pLink = NULL;

            // The currently enabled device is the one
            // that should be used for the connection.  Only
            // one device will be enabled (DnUpdateSelectedDevice).
            for (pNodeTmp = DtlGetFirstNode( pEntry->pdtllistLinks );
                 pNodeTmp;
                 pNodeTmp = DtlGetNextNode( pNodeTmp ))
            {
                pLink = (PBLINK* )DtlGetData( pNodeTmp );
                ASSERT(pLink);

                if ( pLink->fEnabled )
                    break;
            }

            // If we found a link successfully, deal with it
            // now.
            if ( pLink && pLink->fEnabled ) {
                if (pLink->pbport.pbdevicetype == PBDT_ComPort)
                    MdmInstallNullModem (pLink->pbport.pszPort);
            }
        }
    }

    // Save Options page fields.
    //
    if (pInfo->hwndOe)
    {
        UINT unValue;
        BOOL f;
        INT iSel;

        pEntry->fShowDialingProgress =
            Button_GetCheck( pInfo->hwndCbDisplayProgress );

        // Note: The'fPreviewUserPw', 'fPreviewDomain' fields are updated as
        //       they are changed.

        pEntry->fPreviewPhoneNumber =
            Button_GetCheck( pInfo->hwndCbPreviewNumber );

        unValue = GetDlgItemInt(
            pInfo->hwndOe, CID_OE_EB_RedialAttempts, &f, FALSE );
        if (f && unValue <= RAS_MaxRedialCount)
        {
            pEntry->dwRedialAttempts = unValue;
        }

        iSel = ComboBox_GetCurSel( pInfo->hwndLbRedialTimes );
        pEntry->dwRedialSeconds =
            (DWORD )ComboBox_GetItemData( pInfo->hwndLbRedialTimes, iSel );

        iSel = ComboBox_GetCurSel( pInfo->hwndLbIdleTimes );
        pEntry->lIdleDisconnectSeconds =
            (LONG )ComboBox_GetItemData( pInfo->hwndLbIdleTimes, iSel );

        if (pInfo->pArgs->fRouter)
        {
            pEntry->fRedialOnLinkFailure =
                Button_GetCheck( pInfo->hwndRbPersistent );
        }
        else
        {
            pEntry->fRedialOnLinkFailure =
                Button_GetCheck( pInfo->hwndCbRedialOnDrop );
        }

        // Note: dwDialMode is saved as changed.
        // Note: X.25 settings are saved at OK on that dialog.
    }

    // Save Security page fields.
    //
    if (pInfo->hwndLo)
    {
        if (Button_GetCheck( pInfo->hwndRbTypicalSecurity ))
        {
            LoSaveTypicalAuthSettings( pInfo );

            if (pEntry->dwTypicalAuth == TA_CardOrCert)
            {
                /*
                // Toss any existing advanced EAP configuration remnants when
                // typical smartcard, per bug 262702 and VBaliga email.
                //
                Free0( pEntry->pCustomAuthData );
                pEntry->pCustomAuthData = NULL;
                pEntry->cbCustomAuthData = 0;

                */
                (void) DwSetCustomAuthData(
                            pEntry,
                            0,
                            NULL);

                TRACE( "RasSetEapUserData" );
                ASSERT( g_pRasSetEapUserData );
                g_pRasSetEapUserData(
                    INVALID_HANDLE_VALUE,
                    pInfo->pArgs->pFile->pszPath,
                    pEntry->pszEntryName,
                    NULL,
                    0 );
                TRACE( "RasSetEapUserData done" );
            }
        }

        if (pEntry->dwType == RASET_Phone)
        {
            Free0( pEntry->pszScriptAfter );
            SuGetInfo( &pInfo->suinfo,
                &pEntry->fScriptAfter,
                &pEntry->fScriptAfterTerminal,
                &pEntry->pszScriptAfter );
        }
    }

    // Save Network page fields.
    // We won't have anything to do if we never initialized pNetCfg.
    //
    if (pInfo->pNetCfg)
    {
        HRESULT             hr;

        // Update the phone book entry with the enabled state of the components.
        // Do this by enumerating the components from the list view item data
        // and consulting the check state for each.
        //
        NeSaveBindingChanges(pInfo);

        hr = INetCfg_Apply (pInfo->pNetCfg);
        if (((NETCFG_S_REBOOT == hr) || (pInfo->fRebootAlreadyRequested)) &&
              pInfo->pNetConUtilities)
        {
            DWORD dwFlags = QUFR_REBOOT;
            if (!pInfo->fRebootAlreadyRequested)
                dwFlags |= QUFR_PROMPT;

            //$TODO NULL caption?
            INetConnectionUiUtilities_QueryUserForReboot (
                    pInfo->pNetConUtilities, pInfo->hwndDlg, NULL, dwFlags);
        }
    }


#if 0 //!!!
    if ((fLocalPad || iPadSelection != 0)
        && (!pEntry->pszX25Address || IsAllWhite( pEntry->pszX25Address )))
    {
        // Address field is blank with X.25 dial-up or local PAD chosen.
        //
        MsgDlg( pInfo->hwndDlg, SID_NoX25Address, NULL );
        PropSheet_SetCurSel( pInfo->hwndDlg, NULL, PE_XsPage );
        SetFocus( pInfo->hwndEbX25Address );
        Edit_SetSel( pInfo->hwndEbX25Address, 0, -1 );
        return FALSE;
    }
#endif

    // Make sure proprietary ISDN options are disabled if more than one link
    // is enabled.  The proprietary ISDN option is only meaningful when
    // calling a down-level server that needs Digiboard channel aggragation
    // instead of PPP multi-link.
    //
    {
        DTLNODE* pNode;
        DWORD cIsdnLinks;

        cIsdnLinks = 0;
        for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            if (pLink->fEnabled && pLink->pbport.pbdevicetype == PBDT_Isdn)
            {
                ++cIsdnLinks;
            }
        }

        if (cIsdnLinks > 1)
        {
            for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {
                PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
                ASSERT(pLink);

                if (pLink->fEnabled && pLink->fProprietaryIsdn)
                {
                    pLink->fProprietaryIsdn = FALSE;
                }
            }
        }
    }

    // Inform user that edits to the connected entry won't take affect until
    // the entry is hung up and re-dialed, per PierreS's insistence.
    //
    if (HrasconnFromEntry( pInfo->pArgs->pFile->pszPath, pEntry->pszEntryName ))
    {
        MsgDlg( pInfo->hwndDlg, SID_EditConnected, NULL );
    }

    // It's a valid new/changed entry.  Commit the changes to the phonebook
    // and preferences.  This occurs immediately in "ShellOwned" mode where
    // the RasEntryDlg API has already returned, but is otherwise deferred
    // until the API is ready to return.
    //
    if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
    {
        EuCommit( pInfo->pArgs );
    }
    else
    {
        pInfo->pArgs->fCommit = TRUE;
    }
    return TRUE;
}


PEINFO*
PeContext(
    IN HWND hwndPage )

    // Retrieve the property sheet context from a property page handle.
    //
{
    return (PEINFO* )GetProp( GetParent( hwndPage ), g_contextId );
}


DWORD
PeCountEnabledLinks(
    IN PEINFO* pInfo )

    // Returns the number of enabled links in the entry.
    //
{
    DWORD c;
    DTLNODE* pNode;

    c = 0;

    for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        PBLINK* pLink = (PBLINK* )DtlGetData( pNode );

        if (pLink->fEnabled)
        {
            ++c;
        }
    }

    TRACE1( "PeCountEnabledLinks=%d", c );
    return c;
}


VOID
PeExit(
    IN PEINFO* pInfo,
    IN DWORD dwError )

    // Forces an exit from the dialog, reporting 'dwError' to the caller.
    // 'PInfo' is the dialog context.
    //
    // Note: This cannot be called during initialization of the first page.
    //       See PeExitInit.
    //
{
    TRACE( "PeExit" );

    // In "ShellOwned" mode where the RasEntryDlg API has already returned,
    // output arguments are not recorded.
    //
    if (!(pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned))
    {
        pInfo->pArgs->pApiArgs->dwError = dwError;
    }

    PropSheet_PressButton( pInfo->hwndDlg, PSBTN_CANCEL );
}


VOID
PeExitInit(
    IN HWND hwndDlg,
    IN EINFO* pEinfo,
    IN DWORD dwError )

    // Utility to report errors within PeInit and other first page
    // initialization.  'HwndDlg' is the dialog window.  'PEinfo' is the
    // common context block, i.e. the PropertySheet argument.  'DwError' is
    // the error that occurred.
    //
{
    // In "ShellOwned" mode where the RasEntryDlg API has already returned,
    // output arguments are not recorded.
    //
    if (!(pEinfo->pApiArgs->dwFlags & RASEDFLAG_ShellOwned))
    {
        pEinfo->pApiArgs->dwError = dwError;
    }

    SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( hwndDlg, SOD_Free, NULL );
    PostMessage( hwndDlg, WM_COMMAND,
        MAKEWPARAM( IDCANCEL , BN_CLICKED ),
        (LPARAM )GetDlgItem( hwndDlg, IDCANCEL ) );
}


PEINFO*
PeInit(
    IN HWND hwndFirstPage,
    IN EINFO* pArgs )

    // Property sheet level initialization.  'HwndPage' is the handle of the
    // first page.  'PArgs' is the common entry input argument block.
    //
    // Returns address of the context block if successful, NULL otherwise.  If
    // NULL is returned, an appropriate message has been displayed, and the
    // property sheet has been cancelled.
    //
{
    DWORD dwErr;
    DWORD dwOp;
    PEINFO* pInfo;
    HWND hwndDlg;

    TRACE( "PeInit" );

    hwndDlg = GetParent( hwndFirstPage );

    // Allocate the context information block.  Initialize it enough so that
    // it can be destroyed properly, and associate the context with the
    // window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            TRACE( "Context NOT allocated" );
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            PeExitInit( hwndDlg, pArgs, ERROR_NOT_ENOUGH_MEMORY );
            return NULL;
        }

        ZeroMemory( pInfo, sizeof(PEINFO) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;
        pInfo->hwndFirstPage = hwndFirstPage;

        if (!SetProp( hwndDlg, g_contextId, pInfo ))
        {
            TRACE(" Context NOT set" );
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
            Free( pInfo );
            PeExitInit( hwndDlg, pArgs, ERROR_UNKNOWN );
            return NULL;
        }

        TRACE( "Context set" );
    }

    // Position the dialog per API caller's instructions.
    //
    //For whislter bug 238459, we center the Property dialog box on its
    //parent window rather than shift it as before.         gangz
    //
    PositionDlg( hwndDlg,
        0, 
        pArgs->pApiArgs->xDlg, pArgs->pApiArgs->yDlg );

    // Mess with the title bar gadgets.
    //
    //TweakTitleBar( hwndDlg );

    // Indicate no device has yet been selected.
    //
    pInfo->iDeviceSelected = -1;

    // Indicate the "no security settings for SLIP" popup is appropriate for
    // the entry and has not been viewed yet during this visit.
    //
    if (pArgs->pEntry->dwBaseProtocol == BP_Slip)
    {
        pInfo->fShowSlipPopup = TRUE;
    }

    // Initialize COM which may be needed by netshell calls.
    //
    {
        HRESULT hr;

        hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
        if (hr == RPC_E_CHANGED_MODE)
        {
            hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
        }

        if (hr == S_OK || hr == S_FALSE)
        {
            pInfo->fComInitialized = TRUE;
        }
    }

#if 0
    // Set even fixed tab widths.
    //
    SetEvenTabWidths( hwndDlg, PE_PageCount );
#endif

    return pInfo;
}


VOID
PeTerm(
    IN HWND hwndPage )

    // Property sheet level termination.  Releases the context block.
    // 'HwndPage' is the handle of a property page.
    //
{
    PEINFO* pInfo;

    TRACE( "PeTerm" );

    pInfo = PeContext( hwndPage );
    if (pInfo)
    {
        if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
        {
            EuFree(pInfo->pArgs);
            pInfo->pArgs = NULL;
        }

        if (pInfo->hwndLbDialAnotherFirst)
        {
            GeClearLbDialAnotherFirst( pInfo->hwndLbDialAnotherFirst );
        }

        if (pInfo->pListAreaCodes)
        {
            DtlDestroyList( pInfo->pListAreaCodes, DestroyPszNode );
        }

#if 0
        if (pInfo->pListEapcfgs)
        {
            DtlDestroyList( pInfo->pListEapcfgs, DestroyEapcfgNode );
        }
#endif

        if (pInfo->fCuInfoInitialized)
        {
            CuFree( &pInfo->cuinfo );
        }

        if (pInfo->fSuInfoInitialized)
        {
            SuFree( &pInfo->suinfo );
        }

        // Cleanup networking page context.
        //
        {
            // Release our UI info callback object after revoking its info.
            //
            if (pInfo->punkUiInfoCallback)
            {
                RevokePeinfoFromUiInfoCallbackObject (pInfo->punkUiInfoCallback);
                ReleaseObj (pInfo->punkUiInfoCallback);
            }

            //!!! Major hack: Get the list view on the networking page
            // to dump its items before the pInfo and pInfo->pNetCfg go away.
            // We have to do this here when we dismiss the property sheet
            // from the General tab.  When this happens, the general page
            // is destroyed first (causing us to wind up here in PeTerm)
            // before the networking page is destroyed.  When the networking
            // page is destroyed, its listview will also get destroyed
            // causing all of its items to be deleted.  If those LVN_ITEMDELETED
            // notifications show up after pInfo and pInfo->pNetCfg are long
            // gone, badness ensues.  We need to solve this by decoupling
            // PeTerm from a WM_DESTROY message and hooking it up to some
            // later notification (like a page callback).
            //
            ListView_DeleteAllItems (pInfo->hwndLvComponents);

            if (pInfo->pNetConUtilities)
            {
                INetConnectionUiUtilities_Release(pInfo->pNetConUtilities);
            }

            if (pInfo->pNetCfg)
            {
                HrUninitializeAndReleaseINetCfg (pInfo->fInitCom,
                    pInfo->pNetCfg, pInfo->fNetCfgLock);
            }

            SetupDiDestroyClassImageList (&pInfo->cild);
        }

        if (pInfo->fComInitialized)
        {
            CoUninitialize();
        }

        Free( pInfo );
        TRACE("Context freed");
    }

    RemoveProp( GetParent( hwndPage ), g_contextId );
}


//----------------------------------------------------------------------------
// General property page (non-VPN)
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
GeDlgProcSingle(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the General page of the Entry Property sheet
    // when in single device mode.  Parameters and return value are as
    // described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "GeDlgProcS(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, GeLvDevicesCallbackSingle ))
    {
        return TRUE;
    }

    return GeDlgProc( hwnd, unMsg, wparam, lparam );
}


INT_PTR CALLBACK
GeDlgProcMultiple(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the General page of the Entry Property sheet
    // when in multiple device mode.  Parameters and return value are as
    // described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "GeDlgProcS(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, GeLvDevicesCallbackMultiple ))
    {
        return TRUE;
    }

    return GeDlgProc( hwnd, unMsg, wparam, lparam );
}


INT_PTR CALLBACK
GeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the General page of the Entry Property sheet.
    // Called directly for VPNs or called by one of the two non-VPN stubs so
    // 'pInfo' lookup is not required for every messages.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                GeInit( hwnd, (EINFO* )(((PROPSHEETPAGE* )lparam)->lParam) );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwGeHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_APPLY:
                {
                    BOOL fValid;

                    TRACE( "GeAPPLY" );
                    fValid = PeApply( hwnd );

                    SetWindowLong(
                        hwnd, DWLP_MSGRESULT,
                        (fValid)
                            ? PSNRET_NOERROR
                            : PSNRET_INVALID_NOCHANGEPAGE );
                    return TRUE;
                }

                case PSN_RESET:
                {
                    TRACE( "GeRESET" );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    break;
                }

                case LVXN_SETCHECK:
                {
                    PEINFO* pInfo;

                    // An item was just checked or unchecked.
                    //
                    pInfo = PeContext( hwnd );
                    ASSERT( pInfo );
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    GeUpdatePhoneNumberFields( pInfo, FALSE );

                    // For whistler bug 29419       gangz
                    // We should grey out the "All device call the same number"
                    // if not all the modems are selected
                    //
                    do
                    {
                        int i, iCount = 0, iChecked = 0;
                        BOOL fEnable = TRUE;
                        
                        iCount = ListView_GetItemCount( 
                                    pInfo->hwndLvDevices
                                                       );
                        if ( iCount <= 0 )
                        {
                            break;
                        }

                        for ( i = 0; i < iCount; i ++ )
                        {
                            if ( ListView_GetCheck(
                                    pInfo->hwndLvDevices,
                                    i)
                                )
                            {
                                iChecked ++;
                            }
                            
                            if ( 2 <=iChecked )
                            {
                                break;
                            }
                        }

                        if ( iChecked < 2 )
                        {
                            fEnable = FALSE;
                        }

                        if ( pInfo->hwndCbSharedPhoneNumbers )
                        {
                            EnableWindow( pInfo->hwndCbSharedPhoneNumbers,
                                          fEnable);
                        }

                    }while(FALSE);
                    
                    break;
                }

                case LVN_ITEMCHANGED:
                {
                    NM_LISTVIEW* p;

                    p = (NM_LISTVIEW* )lparam;
                    if ((p->uNewState & LVIS_SELECTED)
                        && !(p->uOldState & LVIS_SELECTED))
                    {
                        PEINFO* pInfo;

                        // This item was just selected.
                        //
                        pInfo = PeContext( hwnd );
                        ASSERT( pInfo );
                        if (pInfo == NULL)
                        {
                            break;
                        }
                        GeUpdatePhoneNumberFields( pInfo, FALSE );
                        GeUpdateUpDownButtons( pInfo );
                    }
                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return GeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            PeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


VOID
GeAlternates(
    IN PEINFO* pInfo )

    // Called when the "Alternates" button is pressed to popup the alternate
    // phone number dialog.
    //
{
    // Pick up any control window changes into the underlying link so the
    // dialog will reflect them.
    //
    GeGetPhoneFields( pInfo, pInfo->pCurLinkNode );

    if (pInfo->pArgs->fRouter)
    {
        PBLINK* pLink;
        DTLLIST* pListPsz;
        DTLNODE* pNode;

        // TAPI modifiers are not offered in the demand dial connection case,
        // where user enters only a simple string phone number.  The old
        // NT4-style Alternates dialog that allows simple string edits only is
        // used here.  First, must convert the NT5-style list of PBPHONE nodes
        // to a list of PSZ nodes that the old dialog expects.
        //
        pListPsz = DtlCreateList( 0L );
        if (!pListPsz)
        {
            return;
        }

        pLink = (PBLINK* )DtlGetData( pInfo->pCurLinkNode );
        for (pNode = DtlGetFirstNode( pLink->pdtllistPhones );
             pNode;
             pNode = DtlGetNextNode( pNode ) )
        {
            PBPHONE* pPhone;
            DTLNODE* pNodePsz;

            pPhone = (PBPHONE* )DtlGetData( pNode );
            ASSERT( pPhone );
            if (pPhone->pszPhoneNumber && *(pPhone->pszPhoneNumber))
            {
                pNodePsz = CreatePszNode( pPhone->pszPhoneNumber );
                if (pNodePsz)
                {
                    DtlAddNodeLast( pListPsz, pNodePsz );
                }
            }
        }

        // Call the old-sytle Alternates dialog which is shared with the
        // demand dial wizard.
        //
        if (PhoneNumberDlg(
                pInfo->hwndGe, TRUE, pListPsz, &pLink->fPromoteAlternates ))
        {
            // User pressed OK.  Convert back to a PBPHONE node list.
            //
            while (pNode = DtlGetFirstNode( pLink->pdtllistPhones ))
            {
                DtlRemoveNode( pLink->pdtllistPhones, pNode );
                DestroyPhoneNode( pNode );
            }

            for (pNode = DtlGetFirstNode( pListPsz );
                 pNode;
                 pNode = DtlGetNextNode( pNode ) )
            {
                TCHAR* psz;
                DTLNODE* pPhoneNode;
                PBPHONE* pPhone;

                psz = (TCHAR* )DtlGetData( pNode );
                if (!psz)
                {
                    continue;
                }

                pPhoneNode = CreatePhoneNode();
                if (!pPhoneNode)
                {
                    continue;
                }

                pPhone = (PBPHONE* )DtlGetData( pPhoneNode );
                if (!pPhone)
                {
                    continue;
                }

                pPhone->pszPhoneNumber = psz;
                DtlPutData( pNode, NULL );
                DtlAddNodeLast( pLink->pdtllistPhones, pPhoneNode );
            }

            // Refresh the displayed phone number information, since user's
            // edits in the dialog may have changed them.
            //
            GeSetPhoneFields( pInfo, pInfo->pCurLinkNode, FALSE );
        }

        DtlDestroyList( pListPsz, DestroyPszNode );
    }
    else
    {
        // Popup the Alternate Phone Number dialog on the link.
        //
        if (AlternatePhoneNumbersDlg(
                pInfo->hwndDlg, pInfo->pCurLinkNode, pInfo->pListAreaCodes ))
        {
            // User pressed OK.  Refresh the displayed phone number
            // information, since user's edits in the dialog may have changed
            // them.
            //
            GeSetPhoneFields( pInfo, pInfo->pCurLinkNode, FALSE );
        }
    }
}

VOID
GeDialingRules(
    IN PEINFO* pInfo )

    // Called when the "Rules" button is pressed to popup the tapi
    // dialing rules dialog.
    //
{
    TCHAR pszAreaCode[RAS_MaxPhoneNumber];
    TCHAR pszPhoneNumber[RAS_MaxPhoneNumber];
    DWORD dwErr, dwCountryCode, dwLineId;
    COUNTRY* pCountry = NULL;
    INT iSel;

    TRACE( "GeDialingRules" );

    // Get the current phone number
    //
    GetWindowText ( pInfo->hwndEbPhoneNumber,
                    pszPhoneNumber,
                    sizeof(pszPhoneNumber) / sizeof(TCHAR) );

    // Get the current area code
    //
    GetWindowText ( pInfo->hwndClbAreaCodes,
                    pszAreaCode,
                    sizeof(pszAreaCode) / sizeof(TCHAR) );

    // Get the current country code
    //
    iSel = ComboBox_GetCurSel ( pInfo->hwndLbCountryCodes );
    if (iSel >= 0)
    {
        pCountry = (COUNTRY*) ComboBox_GetItemDataPtr (
                                pInfo->hwndLbCountryCodes, iSel );
    }
    dwCountryCode = (pCountry) ? pCountry->dwCode : 0;

    // Popup TAPI dialing rules dialog.
    //
    dwErr = TapiLocationDlg(
        g_hinstDll,
        &(pInfo->cuinfo.hlineapp),
        pInfo->hwndDlg,
        dwCountryCode,
        pszAreaCode,
        pszPhoneNumber,
        0 );

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_LoadTapiInfo, dwErr, NULL );
    }
}


VOID
GeClearLbDialAnotherFirst(
    IN HWND hwndLbDialAnotherFirst )

    // Clear prerequisite entry list box.  'hwndLbDialAnotherFirst' is the
    // window handle of the listbox control.  context.
    //
{
    PREREQITEM* pItem;

    while (pItem = ComboBox_GetItemDataPtr( hwndLbDialAnotherFirst, 0 ))
    {
        ComboBox_DeleteString( hwndLbDialAnotherFirst, 0 );
        Free0( pItem->pszEntry );
        Free0( pItem->pszPbk );
        Free( pItem );
    }
}


BOOL
GeCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "GeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_GE_PB_MoveUp:
        {
            GeMoveDevice( pInfo, TRUE );
            return TRUE;
        }

        case CID_GE_PB_MoveDown:
        {
            GeMoveDevice( pInfo, FALSE );
            return TRUE;
        }

        case CID_GE_PB_Configure:
        {
            GeConfigure( pInfo );
            return TRUE;
        }

        case CID_GE_PB_Alternates:
        {
            GeAlternates( pInfo );
            return TRUE;
        }

        case CID_GE_PB_DialingRules:
        {
            GeDialingRules( pInfo );
            return TRUE;
        }

        case CID_GE_CB_SharedPhoneNumber:
        {
            GeUpdatePhoneNumberFields( pInfo, TRUE );
            return TRUE;
        }

        case CID_GE_CB_UseDialingRules:
        {
            if (CuDialingRulesCbHandler( &pInfo->cuinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_GE_LB_CountryCodes:
        {
            if (CuCountryCodeLbHandler( &pInfo->cuinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_GE_CB_DialAnotherFirst:
        {
            GeUpdateDialAnotherFirstState( pInfo );
            return TRUE;
        }

        case CID_GE_LB_DialAnotherFirst:
        {
            if (wNotification == CBN_SELCHANGE)
            {
                GeDialAnotherFirstSelChange( pInfo );
                return TRUE;
            }
            break;
        }

        case CID_GE_LB_Devices:
        {
            if (wNotification == CBN_SELCHANGE)
            {
                DTLLIST* pList;
                DTLNODE* pNode, *pNode2;
                PBLINK * pLink;

                pList = pInfo->pArgs->pEntry->pdtllistLinks;

                // Get node from current selection
                pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
                    pInfo->hwndLbDevices,
                    ComboBox_GetCurSel( pInfo->hwndLbDevices ) );

                if(NULL == pNode)
                {
                    break;
                }

                // Remove selected item from list of links
                // and disable all other links
                DtlRemoveNode ( pList, pNode );

                for (pNode2 = DtlGetFirstNode (pList);
                     pNode2;
                     pNode2 = DtlGetNextNode (pNode2))
                {
                    pLink = (PBLINK* )DtlGetData( pNode2 );
                    pLink->fEnabled = FALSE;
                }

                // Enable selected device and Re-add
                // in list of links at front
                pLink = (PBLINK* )DtlGetData( pNode );
                pLink->fEnabled = TRUE;
                DtlAddNodeFirst( pList, pNode );
            }
            break;
        }
    }

    return FALSE;
}


VOID
GeConfigure(
    IN PEINFO* pInfo )

    // Called when the "Configure" button is pressed to popup the appropriate
    // device configuration dialog.
    //
{
    DTLNODE* pNode;
    PBLINK* pLink;
    PBENTRY* pEntry;
    BOOL fMultilinking = FALSE;

    pEntry = pInfo->pArgs->pEntry;

    // pmay: 245860
    //
    // Need to allow config of null modem speed.
    //
    if ( pEntry->dwType == RASET_Direct )
    {
        INT iSel;

        iSel = ComboBox_GetCurSel( pInfo->hwndLbDevices );
        pNode = (DTLNODE*)
            ComboBox_GetItemDataPtr ( pInfo->hwndLbDevices, iSel );
    }
    else
    {
        pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLvDevices );
        fMultilinking =
            (ListView_GetCheckedCount( pInfo->hwndLvDevices ) > 1
             && pEntry->dwDialMode == RASEDM_DialAll);

    }

    if (!pNode)
    {
        return;
    }
    pLink = (PBLINK* )DtlGetData( pNode );

    DeviceConfigureDlg(
        pInfo->hwndDlg,
        pLink,
        pEntry,
        !fMultilinking,
        pInfo->pArgs->fRouter);
}


VOID
GeDialAnotherFirstSelChange(
    IN PEINFO* pInfo )

    // Called when the prerequisite entry selection changes.  'PInfo' is the
    // property sheet context.
    //
{
    PBENTRY* pEntry;
    PREREQITEM* pItem;
    INT iSel;

    iSel = ComboBox_GetCurSel( pInfo->hwndLbDialAnotherFirst );
    if (iSel < 0)
    {
        return;
    }

    pEntry = pInfo->pArgs->pEntry;

    Free0( pEntry->pszPrerequisiteEntry );
    Free0( pEntry->pszPrerequisitePbk );

    pItem = (PREREQITEM* )
        ComboBox_GetItemDataPtr( pInfo->hwndLbDialAnotherFirst, iSel );

    if(NULL != pItem)
    {
        pEntry->pszPrerequisiteEntry = StrDup( pItem->pszEntry );
        pEntry->pszPrerequisitePbk = StrDup( pItem->pszPbk );
    }

    
    pEntry->fDirty = TRUE;
}


BOOL
GeFillLbDialAnotherFirst(
    IN PEINFO* pInfo,
    IN BOOL fAbortIfPrereqNotFound )

    // Fill prerequisite entry list box with all non-VPN entries in the
    // phonebook, and select the prerequiste one.  'PInfo' is the property
    // sheet context.  'FAbortIfPrereqNotFound' means the list should not be
    // filled unless the entry's prerequisite entry is found and selected.
    //
    // Returns TRUE if a selection was made, FALSE otherwise.
    //
{
    DWORD i;
    INT iThis;
    INT iSel;
    TCHAR* pszEntry;
    TCHAR* pszPrerequisiteEntry = NULL;
    RASENTRYNAME* pRens;
    RASENTRYNAME* pRen;
    DWORD dwRens;

    GeClearLbDialAnotherFirst( pInfo->hwndLbDialAnotherFirst );

    iSel = -1;
    pszEntry = pInfo->pArgs->pEntry->pszEntryName;

    //
    // Make a dup of this prerequisite entry here. Otherwise
    // this leads to accessing freed memory when _SetCurSelNotify
    // frees pszPrerequisiteEntry - [raos].
    //
    if(NULL != pInfo->pArgs->pEntry->pszPrerequisiteEntry)
    {
        pszPrerequisiteEntry = StrDup(
                        pInfo->pArgs->pEntry->pszPrerequisiteEntry);
    }
    
    if (GetRasEntrynameTable( &pRens, &dwRens ) != 0)
    {
        return FALSE;
    }

    for (i = 0, pRen = pRens; i < dwRens; ++i, ++pRen )
    {
        PREREQITEM* pItem;

        if (lstrcmp( pRen->szEntryName, pszEntry ) == 0)
        {
            continue;
        }

        pItem = Malloc( sizeof(PREREQITEM) );
        if (!pItem)
        {
            continue;
        }

        pItem->pszEntry = StrDup( pRen->szEntryName );
        pItem->pszPbk = StrDup( pRen->szPhonebookPath );

        if (!pItem->pszEntry || !pItem->pszPbk)
        {
            Free0( pItem->pszEntry );
            Free( pItem );
            continue;
        }

        iThis = ComboBox_AddItem(
            pInfo->hwndLbDialAnotherFirst, pItem->pszEntry,  pItem );

        if (pszPrerequisiteEntry && *(pszPrerequisiteEntry)
            && lstrcmp( pItem->pszEntry, pszPrerequisiteEntry ) == 0)
        {
            iSel = iThis;
            ComboBox_SetCurSelNotify( pInfo->hwndLbDialAnotherFirst, iSel );
        }
    }

    Free( pRens );

    if (iSel < 0)
    {
        if (fAbortIfPrereqNotFound)
        {
            GeClearLbDialAnotherFirst( pInfo->hwndLbDialAnotherFirst );
        }
        else
        {
            iSel = 0;
            ComboBox_SetCurSelNotify( pInfo->hwndLbDialAnotherFirst, iSel );
        }
    }

    Free0(pszPrerequisiteEntry);

    return (iSel >= 0);
}


VOID
GeFillLbDevices(
    IN PEINFO* pInfo )

    // Populate the already initialized ListBox of devices, selecting the
    // currently selected item or if none, the first item.  'PInfo' is the
    // property sheet context.
    //
{
    DTLNODE* pNode;
    DTLNODE* pSelNode;
    DTLLIST* pListLinks;
    INT iItem;
    INT iSelItem;

    TRACE( "GeFillLbDevices" );

    pSelNode = NULL;
    iSelItem = -1;

    // (Re-)populate the list.
    //
    pListLinks = pInfo->pArgs->pEntry->pdtllistLinks;
    for (pNode = DtlGetFirstNode( pListLinks ), iItem = 0;
         pNode;
         pNode = DtlGetNextNode( pNode ), ++iItem)
    {
        PBLINK* pLink;
        DWORD dwImage;
        TCHAR* pszText;

        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT( pLink );

        pszText = DisplayPszFromPpbport( &pLink->pbport, &dwImage );
        if (pszText)
        {
            iItem = ComboBox_AddString( pInfo->hwndLbDevices, pszText );
            ComboBox_SetItemData ( pInfo->hwndLbDevices, iItem, pNode );
            Free (pszText);
        }
    }

    ComboBox_SetCurSelNotify( pInfo->hwndLbDevices, 0 );
}

VOID
GeFillLvDevices(
    IN PEINFO* pInfo )

    // Populate the already initialized ListView of devices, selecting the
    // currently selected item or if none, the first item.  'PInfo' is the
    // property sheet context.
    //
{
    DTLNODE* pNode;
    DTLNODE* pSelNode;
    DTLLIST* pListLinks;
    INT iItem;
    INT iSelItem;
    BOOL bFirstTime = TRUE;
    INT cItems;

    TRACE( "GeFillLvDevices" );

    pSelNode = NULL;
    iSelItem = -1;

    if (ListView_GetItemCount( pInfo->hwndLvDevices ) > 0)
    {
        // ListView has been filled.  Lookup the selected link node, if any,
        // then save the check state to the links, and delete all items from
        // the list.
        //
        if (pInfo->iDeviceSelected >= 0)
        {
            pSelNode =
                (DTLNODE* )ListView_GetParamPtr(
                    pInfo->hwndLvDevices, pInfo->iDeviceSelected );
        }

        GeSaveLvDeviceChecks( pInfo );
        ListView_DeleteAllItems( pInfo->hwndLvDevices );

        bFirstTime = FALSE;
    }

    // (Re-)populate the list.
    //
    pListLinks = pInfo->pArgs->pEntry->pdtllistLinks;
    for (pNode = DtlGetFirstNode( pListLinks ), iItem = 0;
         pNode;
         pNode = DtlGetNextNode( pNode ), ++iItem)
    {
        PBLINK* pLink;
        DWORD dwImage;
        TCHAR* pszText;

        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT( pLink );

        pszText = DisplayPszFromPpbport( &pLink->pbport, &dwImage );
        if (pszText)
        {
            LV_ITEM item;

            ZeroMemory( &item, sizeof(item) );
            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            item.iItem = iItem;
            item.lParam = (LPARAM )pNode;
            item.pszText = pszText;
            item.cchTextMax = wcslen(pszText) + 1;
            item.iImage = dwImage;

            iItem = ListView_InsertItem( pInfo->hwndLvDevices, &item );
            Free( pszText );

            if (pNode == pSelNode)
            {
                iSelItem = iItem;
                pInfo->iDeviceSelected = iItem;
            }

            /*
            if (pInfo->pArgs->fMultipleDevices)
            {
                ListView_SetCheck(
                    pInfo->hwndLvDevices, iItem, pLink->fEnabled );
            }
            */
        }
    }

    if(pInfo->pArgs->fMultipleDevices)
    {
        INT i = -1;
        while ((i = ListView_GetNextItem(
            pInfo->hwndLvDevices, i, LVNI_ALL )) >= 0)
        {
            DTLNODE* pNodeTmp = NULL;
            PBLINK* pLink = NULL;

            pNodeTmp = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLvDevices, i );
            ASSERT( pNodeTmp );

            if(NULL == pNodeTmp)
            {
                continue;
            }
            
            pLink = (PBLINK* )DtlGetData( pNodeTmp );
            ASSERT( pLink );
            ListView_SetCheck(
                pInfo->hwndLvDevices, i, pLink->fEnabled);
        }
    }

    if (bFirstTime == TRUE)
    {
        // Add a single column exactly wide enough to fully display
        // the widest member of the list.
        //
        LV_COLUMN col;

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT;
        col.fmt = LVCFMT_LEFT;
        ListView_InsertColumn( pInfo->hwndLvDevices, 0, &col );
        ListView_SetColumnWidth( pInfo->hwndLvDevices, 0, LVSCW_AUTOSIZE_USEHEADER );
    }

    // EuInit creates a bogus device if there are none guaranteeing that the
    // device list is never empty.
    //
    ASSERT( iItem > 0 );

    // Select the previously selected item, or the first item if none.  This
    // will trigger an update of the phone number related controls.  The
    // "previous selection" index is updated to the new index of the same
    // item.
    //
    if (iSelItem >= 0)
    {
        pInfo->iDeviceSelected = iSelItem;
    }
    else
    {
        iSelItem = 0;
    }

    ListView_SetItemState(
        pInfo->hwndLvDevices, iSelItem, LVIS_SELECTED, LVIS_SELECTED );
}


VOID
GeInitLvDevices(
    IN PEINFO* pInfo )

    // Initialize the ListView of devices.
    //
{
    BOOL fChecksInstalled;

    // Install "listview of checkboxes" handling.
    //
    if (pInfo->pArgs->fMultipleDevices)
    {
        fChecksInstalled =
            ListView_InstallChecks( pInfo->hwndLvDevices, g_hinstDll );
        if (!fChecksInstalled)
            return;
    }

    // Set the modem, adapter, and other device images.
    //
    ListView_SetDeviceImageList( pInfo->hwndLvDevices, g_hinstDll );

    // Add a single column exactly wide enough to fully display the widest
    // member of the list.
    //
    ListView_InsertSingleAutoWidthColumn( pInfo->hwndLvDevices );
}


VOID
GeGetPhoneFields(
    IN PEINFO* pInfo,
    OUT DTLNODE* pDstLinkNode )

    // Load the phone number group box field settings into the phone number
    // information of PBLINK node 'pDstLinkNode'.  'PInfo' is the property
    // sheet context.
    //
{
    PBLINK* pLink;
    PBPHONE* pPhone;
    DTLNODE* pPhoneNode;

    TRACE( "GeGetPhoneFields" );

    pLink = (PBLINK* )DtlGetData( pDstLinkNode );
    ASSERT( pLink );

    pPhoneNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );
    if (pPhoneNode)
    {
        CuGetInfo( &pInfo->cuinfo, pPhoneNode );
        FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pPhoneNode );
    }
}


BOOL
GeInit(
    IN HWND hwndPage,
    IN OUT EINFO* pArgs )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.  'PArgs' is the arguments from the PropertySheet caller.
    //
    // Return false if focus was set, true otherwise.
    //
{
    DWORD dwErr;
    PEINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "GeInit" );

    // We're first page, so initialize the property sheet.
    //
    pInfo = PeInit( hwndPage, pArgs );
    if (!pInfo)
    {
        return TRUE;
    }

    pEntry = pInfo->pArgs->pEntry;

    // Initialize page-specific context information.
    //
    pInfo->hwndGe = hwndPage;

    // Initialize the "show icon in the taskbar" button, the lone piece of consistency among
    // the various forms.
    //
    //for bug 154607 whistler, Enable/Disable Show Icon on taskbar 
    //check box according to Policy
    //
    //
    {    
        BOOL fShowStatistics = TRUE;

        NeEnsureNetshellLoaded (pInfo);
        if ( NULL != pInfo->pNetConUtilities)
        {
            fShowStatistics =
            INetConnectionUiUtilities_UserHasPermission(
                        pInfo->pNetConUtilities, NCPERM_Statistics);
        }

        pInfo->hwndCbShowIcon =
               GetDlgItem( hwndPage, CID_GE_CB_ShowIcon );
        ASSERT( pInfo->hwndCbShowIcon );

        if ( pInfo->pArgs->fRouter )
        {
           Button_SetCheck( pInfo->hwndCbShowIcon, FALSE );
           ShowWindow( pInfo->hwndCbShowIcon, SW_HIDE );
         }
         else
        {
           Button_SetCheck(
           pInfo->hwndCbShowIcon, pEntry->fShowMonitorIconInTaskBar );

           if ( !fShowStatistics )
           {
              EnableWindow( pInfo->hwndCbShowIcon, FALSE );
           }
         }
    }
    

    if (pEntry->dwType == RASET_Vpn)
    {
        pInfo->hwndEbHostName =
            GetDlgItem( hwndPage, CID_GE_EB_HostName );
        ASSERT( pInfo->hwndEbHostName );

        pInfo->hwndCbDialAnotherFirst =
            GetDlgItem( hwndPage, CID_GE_CB_DialAnotherFirst );
        ASSERT( pInfo->hwndCbDialAnotherFirst );

        pInfo->hwndLbDialAnotherFirst =
            GetDlgItem( hwndPage, CID_GE_LB_DialAnotherFirst );
        ASSERT( pInfo->hwndLbDialAnotherFirst );

        // Initialize host name, i.e. the "phone number".
        //
        {
            DTLNODE* pNode;
            PBLINK* pLink;
            PBPHONE* pPhone;

            Edit_LimitText( pInfo->hwndEbHostName, RAS_MaxPhoneNumber );

            pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
            ASSERT( pNode );
            pLink = (PBLINK* )DtlGetData( pNode );
            pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

            if(NULL == pNode)
            {
                return TRUE;
            }
            
            pPhone = (PBPHONE* )DtlGetData( pNode );
            SetWindowText( pInfo->hwndEbHostName, pPhone->pszPhoneNumber );
            DestroyPhoneNode( pNode );
        }

        // Initialize the "dial connected first" controls.
        //
        if (pInfo->pArgs->fRouter)
        {
            Button_SetCheck( pInfo->hwndCbDialAnotherFirst, FALSE );
            EnableWindow( pInfo->hwndCbDialAnotherFirst, FALSE );
            ShowWindow( pInfo->hwndCbDialAnotherFirst, SW_HIDE );
            EnableWindow( pInfo->hwndLbDialAnotherFirst, FALSE );
            ShowWindow(pInfo->hwndLbDialAnotherFirst, SW_HIDE );

            ShowWindow(
                GetDlgItem( hwndPage, CID_GE_GB_FirstConnect ),
                SW_HIDE );

            ShowWindow(
                GetDlgItem( hwndPage, CID_GE_ST_Explain ),
                SW_HIDE );
        }
        else
        {
            BOOL fEnableLb;

            fEnableLb = FALSE;
            if (pEntry->pszPrerequisiteEntry
                 && *(pEntry->pszPrerequisiteEntry))
            {
                if (GeFillLbDialAnotherFirst( pInfo, TRUE ))
                {
                    fEnableLb = TRUE;
                }
                else
                {
                    // Don't enable the listbox if the prerequisite entry
                    // defined no longer exists.  See bug 220420.
                    //
                    Free0( pEntry->pszPrerequisiteEntry );
                    pEntry->pszPrerequisiteEntry = NULL;
                    Free0( pEntry->pszPrerequisitePbk );
                    pEntry->pszPrerequisitePbk = NULL;
                }
            }

            Button_SetCheck( pInfo->hwndCbDialAnotherFirst, fEnableLb );
            EnableWindow( pInfo->hwndLbDialAnotherFirst, fEnableLb );

            if (pArgs->fDisableFirstConnect)
            {
                EnableWindow( pInfo->hwndCbDialAnotherFirst, FALSE );
                EnableWindow( pInfo->hwndLbDialAnotherFirst, FALSE );
            }
        }

        return TRUE;
    }
    else if (pEntry->dwType == RASET_Broadband)
    {
        pInfo->hwndEbBroadbandService =
            GetDlgItem( hwndPage, CID_GE_EB_ServiceName );
        ASSERT( pInfo->hwndEbBroadbandService );

        // Initialize host name, i.e. the "phone number".
        //
        {
            DTLNODE* pNode;
            PBLINK* pLink;
            PBPHONE* pPhone;

            Edit_LimitText( pInfo->hwndEbBroadbandService, RAS_MaxPhoneNumber );

            pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
            ASSERT( pNode );
            pLink = (PBLINK* )DtlGetData( pNode );
            pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

            if(NULL == pNode)
            {
                return TRUE;
            }
            
            pPhone = (PBPHONE* )DtlGetData( pNode );
            SetWindowText( pInfo->hwndEbBroadbandService, pPhone->pszPhoneNumber );
            DestroyPhoneNode( pNode );
        }

        return TRUE;
    }    
    else if (pEntry->dwType == RASET_Phone)
    {
        if (pArgs->fMultipleDevices)
        {
            pInfo->hwndLvDevices =
                GetDlgItem( hwndPage, CID_GE_LV_Devices );
            ASSERT( pInfo->hwndLvDevices );

            pInfo->hwndPbUp =
                GetDlgItem( hwndPage, CID_GE_PB_MoveUp );
            ASSERT( pInfo->hwndPbUp );

            pInfo->hwndPbDown =
                GetDlgItem( hwndPage, CID_GE_PB_MoveDown );
            ASSERT( pInfo->hwndPbDown );

            pInfo->hwndCbSharedPhoneNumbers =
                GetDlgItem( hwndPage, CID_GE_CB_SharedPhoneNumber );
            ASSERT( pInfo->hwndCbSharedPhoneNumbers );
        }
        else
        {
            // The listview has a different control-ID in single mode so that
            // a different help context can be provided.
            //
            pInfo->hwndLvDevices =
                GetDlgItem( hwndPage, CID_GE_LV_Device );
            ASSERT( pInfo->hwndLvDevices );
        }

        pInfo->hwndPbConfigureDevice =
            GetDlgItem( hwndPage, CID_GE_PB_Configure );
        ASSERT( pInfo->hwndPbConfigureDevice );
        if ( pEntry->fGlobalDeviceSettings )
        {
            // Whislter bug 281306.  If the entry is set up to use
            // control panel settings, then hide the option that
            // allows users to configure the devices per-phonebook.
            //
            ShowWindow( pInfo->hwndPbConfigureDevice, SW_HIDE );
        }

        pInfo->hwndStPhoneNumber =
            GetDlgItem( hwndPage, CID_GE_ST_PhoneNumber );
        ASSERT( pInfo->hwndStPhoneNumber );

        pInfo->hwndEbPhoneNumber =
            GetDlgItem( hwndPage, CID_GE_EB_PhoneNumber );
        ASSERT( pInfo->hwndEbPhoneNumber );

        pInfo->hwndPbAlternates =
            GetDlgItem( hwndPage, CID_GE_PB_Alternates );
        ASSERT( pInfo->hwndPbAlternates );

        if (!pInfo->pArgs->fRouter)
        {
            pInfo->hwndGbPhoneNumber =
                GetDlgItem( hwndPage, CID_GE_GB_PhoneNumber );
            ASSERT( pInfo->hwndGbPhoneNumber );

            pInfo->hwndStAreaCodes =
                GetDlgItem( hwndPage, CID_GE_ST_AreaCodes );
            ASSERT( pInfo->hwndStAreaCodes );

            pInfo->hwndClbAreaCodes =
                GetDlgItem( hwndPage, CID_GE_CLB_AreaCodes );
            ASSERT( pInfo->hwndClbAreaCodes );

            pInfo->hwndStCountryCodes =
                GetDlgItem( hwndPage, CID_GE_ST_CountryCodes );
            ASSERT( pInfo->hwndStCountryCodes );

            pInfo->hwndLbCountryCodes =
                GetDlgItem( hwndPage, CID_GE_LB_CountryCodes );
            ASSERT( pInfo->hwndLbCountryCodes );

            pInfo->hwndCbUseDialingRules =
                GetDlgItem( hwndPage, CID_GE_CB_UseDialingRules );
            ASSERT( pInfo->hwndCbUseDialingRules );

            pInfo->hwndPbDialingRules =
                GetDlgItem( hwndPage, CID_GE_PB_DialingRules );
            ASSERT( pInfo->hwndPbDialingRules );
        }

        if (pArgs->fMultipleDevices)
        {
            // Set the shared phone number checkbox.
            //
            Button_SetCheck(
                pInfo->hwndCbSharedPhoneNumbers, pEntry->fSharedPhoneNumbers );

            // Load the icons into the move up and move down buttons.  From
            // what I can tell tell in MSDN, you don't have to close or
            // destroy the icon handle.
            //
            pInfo->hiconUpArr = LoadImage(
                g_hinstDll, MAKEINTRESOURCE( IID_UpArr ), IMAGE_ICON, 0, 0, 0 );
            pInfo->hiconDnArr = LoadImage(
                g_hinstDll, MAKEINTRESOURCE( IID_DnArr ), IMAGE_ICON, 0, 0, 0 );
            pInfo->hiconUpArrDis = LoadImage(
                g_hinstDll, MAKEINTRESOURCE( IID_UpArrDis ), IMAGE_ICON, 0, 0, 0 );
            pInfo->hiconDnArrDis = LoadImage(
                g_hinstDll, MAKEINTRESOURCE( IID_DnArrDis ), IMAGE_ICON, 0, 0, 0 );
        }

        pInfo->pListAreaCodes = DtlDuplicateList(
            pInfo->pArgs->pUser->pdtllistAreaCodes,
            DuplicatePszNode, DestroyPszNode );

        CuInit( &pInfo->cuinfo,
            pInfo->hwndStAreaCodes, pInfo->hwndClbAreaCodes,
            pInfo->hwndStPhoneNumber, pInfo->hwndEbPhoneNumber,
            pInfo->hwndStCountryCodes, pInfo->hwndLbCountryCodes,
            pInfo->hwndCbUseDialingRules, pInfo->hwndPbDialingRules,
            pInfo->hwndPbAlternates,
            NULL, NULL,
            pInfo->pListAreaCodes );

        pInfo->fCuInfoInitialized = TRUE;

        // Configure and populate the device list, selecting the first item.
        //
        GeInitLvDevices( pInfo );
        GeFillLvDevices( pInfo );

        // Set initial focus.
        //
        if (pArgs->fMultipleDevices)
        {
            SetFocus( pInfo->hwndLvDevices );
        }
        else
        {
            ASSERT( IsWindowEnabled( pInfo->hwndEbPhoneNumber ) );
            SetFocus( pInfo->hwndEbPhoneNumber );
            Edit_SetSel( pInfo->hwndEbPhoneNumber, 0, -1 );
        }

        return FALSE;
    }
    else
    {
        ASSERT( pEntry->dwType == RASET_Direct );

        // The listview has a different control-ID in single mode so that
        // a different help context can be provided.
        //
        pInfo->hwndLbDevices =
            GetDlgItem( hwndPage, CID_GE_LB_Devices );
        ASSERT( pInfo->hwndLbDevices );

        // Configure and populate the device list, selecting the first item.
        //
        GeFillLbDevices( pInfo );
    }

    return TRUE;
}


LVXDRAWINFO*
GeLvDevicesCallbackMultiple(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the draw information.
    //
{
    // Use "full row select" and other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info = { 1, 0, 0, { 0 } };

    return &info;
}


LVXDRAWINFO*
GeLvDevicesCallbackSingle(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the draw information.
    //
{
    // Set up to emulate a static text control but with icon on left.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info = { 1, 0, LVXDI_DxFill, { LVXDIA_Static } };

    return &info;
}


VOID
GeMoveDevice(
    IN PEINFO* pInfo,
    IN BOOL fUp )

    // Refill the ListView of devices with the selected item moved up or down
    // one position.  'FUp' is set to move up, otherwise moves down.  'PInfo'
    // is the property sheeet context.
    //
{
    DTLNODE* pNode;
    DTLNODE* pPrevNode;
    DTLNODE* pNextNode;
    DTLLIST* pList;

    if (pInfo->iDeviceSelected < 0)
    {
        return;
    }

    pNode =
        (DTLNODE* )ListView_GetParamPtr(
            pInfo->hwndLvDevices, pInfo->iDeviceSelected );
    ASSERT( pNode );

    if(NULL == pNode)
    {
        return;
    }

    pList = pInfo->pArgs->pEntry->pdtllistLinks;

    if (fUp)
    {
        pPrevNode = DtlGetPrevNode( pNode );
        if (!pPrevNode)
        {
            return;
        }

        DtlRemoveNode( pList, pNode );
        DtlAddNodeBefore( pList, pPrevNode, pNode );
    }
    else
    {
        pNextNode = DtlGetNextNode( pNode );
        if (!pNextNode)
        {
            return;
        }

        DtlRemoveNode( pList, pNode );
        DtlAddNodeAfter( pList, pNextNode, pNode );
    }

    GeFillLvDevices( pInfo );
}


DWORD
GeSaveLvDeviceChecks(
    IN PEINFO* pInfo )

    // Mark links enabled/disabled based on it's check box in the ListView of
    // devices.  Returns the count of enabled devices.
    //
{
    DWORD dwCount = 0;

    if (pInfo->pArgs->fMultipleDevices)
    {
        INT i;

        i = -1;
        while ((i = ListView_GetNextItem(
            pInfo->hwndLvDevices, i, LVNI_ALL )) >= 0)
        {
            DTLNODE* pNode;
            PBLINK* pLink;

            pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLvDevices, i );
            ASSERT( pNode );
            if(NULL == pNode)
            {
                return 0;
            }
            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT( pLink );
            pLink->fEnabled = ListView_GetCheck( pInfo->hwndLvDevices, i );
            dwCount += (pLink->fEnabled) ? 1 : 0;
        }
    }

    return dwCount;
}


VOID
GeSetPhoneFields(
    IN PEINFO* pInfo,
    IN DTLNODE* pSrcLinkNode,
    IN BOOL fDisableAll )

    // Set the phone number group box fields from the phone information in
    // PBLINK node 'pSrcLinkNode'.  'PInfo' is the property sheet context.
    //
{
    PBLINK* pLink;
    DTLNODE* pPhoneNode;

    TRACE( "GeSetPhoneFields" );

    pLink = (PBLINK* )DtlGetData( pSrcLinkNode );
    ASSERT( pLink );

    pPhoneNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );
    if (pPhoneNode)
    {
        CuSetInfo( &pInfo->cuinfo, pPhoneNode, fDisableAll );
        DestroyPhoneNode( pPhoneNode );
    }
}


VOID
GeUpdateDialAnotherFirstState(
    IN PEINFO* pInfo )

    // Update the prequisite entry controls.  'PInfo' is the property sheet
    // context.
    //
{
    if (Button_GetCheck( pInfo->hwndCbDialAnotherFirst ))
    {
        GeFillLbDialAnotherFirst( pInfo, FALSE );
        EnableWindow( pInfo->hwndLbDialAnotherFirst, TRUE );
    }
    else
    {
        GeClearLbDialAnotherFirst( pInfo->hwndLbDialAnotherFirst );
        EnableWindow( pInfo->hwndLbDialAnotherFirst, FALSE );
    }
}


VOID
GeUpdatePhoneNumberFields(
    IN PEINFO* pInfo,
    IN BOOL fSharedToggle )

    // Called when anything affecting the Phone Number group of controls
    // occurs.  'PInfo' is the property sheet context.  'FSharedToggle' is set
    // when the update is due to the toggling of the shared phone number
    // checkbox.
    //
{
    INT i;
    BOOL fShared;
    DTLNODE* pNode;
    PBLINK* pLink;

    TRACE( "GeUpdatePhoneNumberFields" );

    if (pInfo->pArgs->fMultipleDevices)
    {
        fShared = Button_GetCheck( pInfo->hwndCbSharedPhoneNumbers );
    }
    else
    {
        fShared = TRUE;
        ASSERT( !fSharedToggle );
    }

    if (pInfo->iDeviceSelected >= 0)
    {
        // A device was previously selected.
        //
        pNode = (DTLNODE* )ListView_GetParamPtr(
            pInfo->hwndLvDevices, pInfo->iDeviceSelected );
        ASSERT( pNode );

        if(NULL == pNode)
        {
            return;
        }

        if (fShared)
        {
            if (fSharedToggle)
            {
                // Shared-mode just toggled on.  Update the selected node from
                // the controls, then copy it's phone settings to the shared
                // node.
                //
                GeGetPhoneFields( pInfo, pNode );
                CopyLinkPhoneNumberInfo( pInfo->pArgs->pSharedNode, pNode );
            }
            else
            {
                // Update the shared node from the controls.
                //
                GeGetPhoneFields( pInfo, pInfo->pArgs->pSharedNode );
            }
        }
        else
        {
            if (fSharedToggle)
            {
                // Shared-mode just toggled off.  Update the shared node from
                // the controls, then copy it's phone settings to the selected
                // node.
                //
                GeGetPhoneFields( pInfo, pInfo->pArgs->pSharedNode );
                CopyLinkPhoneNumberInfo( pNode, pInfo->pArgs->pSharedNode );
            }
            else
            {
                // Update the previously selected node from the controls.
                //
                GeGetPhoneFields( pInfo, pNode );
            }
        }
    }

    // Load the phone number fields and title with the phone number for the
    // selected link.  Save the selected device index in the context block so
    // we'll know where to swap out the phone number when the selection
    // changes.
    //
    i = ListView_GetNextItem( pInfo->hwndLvDevices, -1, LVIS_SELECTED );
    pInfo->iDeviceSelected = i;
    if (i < 0)
    {
        // No device is currently selected.  This occurs because a new
        // selection generates first an "unselect" event, then a separate
        // "select" event.
        //
        return;
    }

    // Set the phone number fields including group box title, all
    // enabling/disabling, and "blanked" handling of area code and country
    // code.  The entire phone number group is disabled when in separate
    // number mode with the selected device unchecked.
    //
    if (fShared)
    {
        pInfo->pCurLinkNode = pInfo->pArgs->pSharedNode;
        GeUpdatePhoneNumberTitle( pInfo, NULL );
        GeSetPhoneFields( pInfo, pInfo->pArgs->pSharedNode, FALSE );
    }
    else
    {
        pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLvDevices, i );
        ASSERT( pNode );

        if(NULL == pNode)
        {
            return;
        }
        
        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT( pLink );

        if(NULL == pLink)
        {
            return;
        }

        pInfo->pCurLinkNode = pNode;
        GeUpdatePhoneNumberTitle( pInfo, pLink->pbport.pszDevice );
        GeSetPhoneFields( pInfo, pNode,
            !(ListView_GetCheck( pInfo->hwndLvDevices, i )) );
    }

    // When the enabled device count falls below 2 the "Multiple Devices"
    // group box and contained controls on the Options page are disabled.  If
    // 2 or above it is enabled.
    //
    if (pInfo->hwndOe && pInfo->pArgs->fMultipleDevices)
    {
        DWORD cChecked;

        cChecked = ListView_GetCheckedCount( pInfo->hwndLvDevices );
        OeEnableMultipleDeviceGroup( pInfo, (cChecked > 1) );
    }
}


VOID
GeUpdatePhoneNumberTitle(
    IN PEINFO* pInfo,
    IN TCHAR* pszDevice )

    // Update the Phone Number group box title based on the "share" mode.
    // 'PInfo' is the property sheet context.  'PszDevice' is the device name
    // string to display in non-shared mode or NULL in shared mode.
    //
{
    if (!pInfo->hwndGbPhoneNumber)
    {
        return;
    }

    if (pszDevice)
    {
        TCHAR* psz;
        TCHAR* pszFormat;

        // Set the individual title, e.g. "Phone number for K-Tel 28.8
        // Fax/Plus".
        //
        pszFormat = PszFromId( g_hinstDll, SID_LinkPhoneNumber );
        if (pszFormat)
        {
            psz = Malloc(
                (lstrlen( pszFormat ) + lstrlen( pszDevice ))
                 * sizeof(TCHAR) );
            if (psz)
            {
                wsprintf( psz, pszFormat, pszDevice );
                SetWindowText( pInfo->hwndGbPhoneNumber, psz );
                Free( psz );
            }

            Free( pszFormat );
        }
    }
    else
    {
        TCHAR* psz;

        // Set the shared title, e.g. "Phone number".
        //
        psz = PszFromId( g_hinstDll, SID_SharedPhoneNumber );
        if (psz)
        {
            SetWindowText( pInfo->hwndGbPhoneNumber, psz );
            Free( psz );
        }
    }
}


VOID
GeUpdateUpDownButtons(
    IN PEINFO* pInfo )

    // Update the enable/disable and corresponding icon for the
    // move-up/move-down buttons.  Moves focus and default button as
    // necessary.  'PInfo' is the property sheet context.
    //
{
    INT iSel;
    INT cItems;
    BOOL fSel;

    if (!pInfo->pArgs->fMultipleDevices)
    {
        return;
    }

    iSel = ListView_GetNextItem( pInfo->hwndLvDevices, -1, LVNI_SELECTED );
    fSel = (iSel >= 0);
    cItems = ListView_GetItemCount( pInfo->hwndLvDevices );

    // "Up" button, enabled if there is an item above.
    //
    if (iSel > 0)
    {
        EnableWindow( pInfo->hwndPbUp, TRUE );
        SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconUpArr );
    }
    else
    {
        EnableWindow( pInfo->hwndPbUp, FALSE );
        SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconUpArrDis );
    }

    // "Down" button, enabled if there is an item below.
    //
    if (fSel && (iSel < cItems - 1))
    {
        EnableWindow( pInfo->hwndPbDown, TRUE );
        SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconDnArr );
    }
    else
    {
        EnableWindow( pInfo->hwndPbDown, FALSE );
        SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconDnArrDis );
    }

    // if the focus button is disabled, move focus to the ListView and make OK
    // the default button.
    //
    if (!IsWindowEnabled( GetFocus() ))
    {
        SetFocus( pInfo->hwndLvDevices );
        Button_MakeDefault( pInfo->hwndDlg,
            GetDlgItem( pInfo->hwndDlg, IDOK ) );
    }
}


//----------------------------------------------------------------------------
// Options property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
OeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Options page of the Entry property sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
#if 0
    TRACE4( "OeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return OeInit( hwnd );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            if (pInfo->pArgs->fRouter)
            {
                ContextHelp( g_adwOeRouterHelp, hwnd, unMsg, wparam, lparam );
            }
            else
            {
                ContextHelp( g_adwOeHelp, hwnd, unMsg, wparam, lparam );
            }
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return OeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }

        case WM_NOTIFY:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    // Because of inter-page dependencies on the 'fAutoLogon'
                    // flag the User/password and subordinate checkbox states
                    // must be reinitialized at each activation.
                    //
                    OeUpdateUserPwState( pInfo );
                    break;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
OeCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "OeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_OE_CB_PreviewUserPw:
        {
            pInfo->pArgs->pEntry->fPreviewUserPw =
                Button_GetCheck( pInfo->hwndCbPreviewUserPw );
            OeUpdateUserPwState( pInfo );
            return TRUE;
        }

        case CID_OE_CB_PreviewDomain:
        {
            pInfo->pArgs->pEntry->fPreviewDomain =
                Button_GetCheck( pInfo->hwndCbPreviewDomain );
            return TRUE;
        }

        case CID_OE_PB_Configure:
        {
            MultiLinkDialingDlg( pInfo->hwndDlg, pInfo->pArgs->pEntry );
            return TRUE;
        }

        case CID_OE_PB_X25:
        {
            OeX25( pInfo );
            return TRUE;
        }

        case CID_OE_PB_Tunnel:
        {
            OeTunnel( pInfo );
            return TRUE;
        }

        case CID_OE_LB_MultipleDevices:
        {
            pInfo->pArgs->pEntry->dwDialMode =
                (DWORD)ComboBox_GetItemData( pInfo->hwndLbMultipleDevices,
                    ComboBox_GetCurSel( pInfo->hwndLbMultipleDevices ) );

            EnableWindow( pInfo->hwndPbConfigureDialing,
                !!(pInfo->pArgs->pEntry->dwDialMode == RASEDM_DialAsNeeded) );
                
            return TRUE;
        }

        case CID_OE_RB_Persistent:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    ComboBox_SetCurSel( pInfo->hwndLbIdleTimes, 0 );
                    EnableWindow( pInfo->hwndLbIdleTimes, FALSE );
                    return TRUE;
                }
            }
            break;
        }

        case CID_OE_RB_DemandDial:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    EnableWindow( pInfo->hwndLbIdleTimes, TRUE );
                    return TRUE;
                }
            }
            break;
        }

        case CID_OE_PB_Callback:
        {
            RouterCallbackDlg ( pInfo->hwndOe, pInfo->pArgs );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
OeEnableMultipleDeviceGroup(
    IN PEINFO* pInfo,
    IN BOOL fEnable )

    // Enable/disable the Multiple Devices groupbox and all controls it
    // contains based on 'fEnable'.  'PInfo' is the property sheet context.
    //
{
    EnableWindow( pInfo->hwndGbMultipleDevices, fEnable );
    EnableWindow( pInfo->hwndLbMultipleDevices, fEnable );
    EnableWindow( pInfo->hwndPbConfigureDialing,
        (fEnable
         && !!(pInfo->pArgs->pEntry->dwDialMode == RASEDM_DialAsNeeded)) );
}


BOOL
OeInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    PEINFO*  pInfo;
    PBENTRY* pEntry;
    LBTABLEITEM* pItem;
    HWND hwndLb;
    INT i;
    INT iSel;
    HWND hwndUdRedialAttempts;

    static LBTABLEITEM aRedialTimes[] =
    {
        SID_Time1s,  1,
        SID_Time3s,  3,
        SID_Time5s,  5,
        SID_Time10s, 10,
        SID_Time30s, 30,
        SID_Time1m,  60,
        SID_Time2m,  120,
        SID_Time5m,  300,
        SID_Time10m, RAS_RedialPause10m,
        0, 0
    };

    static LBTABLEITEM aIdleTimes[] =
    {
        SID_TimeNever, 0,
        SID_Time1m,    60,
        SID_Time5m,    300,
        SID_Time10m,   600,
        SID_Time20m,   1200,    //Add for whistler bug 307969
        SID_Time30m,   1800,
        SID_Time1h,    3600,
        SID_Time2h,    7200,
        SID_Time4h,    14400,
        SID_Time8h,    28800,
        SID_Time24h,   86400,
        0, 0
    };

    static LBTABLEITEM aMultipleDeviceOptions[] =
    {
        SID_DialOnlyFirst, 0,
        SID_DialAll,       RASEDM_DialAll,
        SID_DialNeeded,    RASEDM_DialAsNeeded,
        0, 0
    };

    TRACE( "OeInit" );

    pInfo = PeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }

    pEntry = pInfo->pArgs->pEntry;

    // Initialize page-specific context information.
    //
    pInfo->hwndOe = hwndPage;

    // Initialize 'Dialing options' group box.
    //
    if (!pInfo->pArgs->fRouter)
    {
        pInfo->hwndCbDisplayProgress =
            GetDlgItem( hwndPage, CID_OE_CB_DisplayProgress );
        ASSERT( pInfo->hwndCbDisplayProgress );
        Button_SetCheck(
            pInfo->hwndCbDisplayProgress, pEntry->fShowDialingProgress );

        pInfo->hwndCbPreviewUserPw =
            GetDlgItem( hwndPage, CID_OE_CB_PreviewUserPw );
        ASSERT( pInfo->hwndCbPreviewUserPw );
        pInfo->fPreviewUserPw = pEntry->fPreviewUserPw;
        Button_SetCheck( pInfo->hwndCbPreviewUserPw, pInfo->fPreviewUserPw );

        pInfo->hwndCbPreviewDomain =
            GetDlgItem( hwndPage, CID_OE_CB_PreviewDomain );
        ASSERT( pInfo->hwndCbPreviewDomain );
        pInfo->fPreviewDomain = pEntry->fPreviewDomain;
        Button_SetCheck( pInfo->hwndCbPreviewDomain, pInfo->fPreviewDomain );

        if (pEntry->dwType == RASET_Phone)
        {
            pInfo->hwndCbPreviewNumber =
                GetDlgItem( hwndPage, CID_OE_CB_PreviewNumber );
            ASSERT( pInfo->hwndCbPreviewNumber );
            Button_SetCheck(
                pInfo->hwndCbPreviewNumber, pEntry->fPreviewPhoneNumber );
        }
    }

    // Initialize 'Redialing options' group box.  In the 'fRouter' case this
    // includes both the 'Dialing policy' and 'Connection type' group boxes.
    //
    {
        pInfo->hwndEbRedialAttempts =
            GetDlgItem( hwndPage, CID_OE_EB_RedialAttempts );
        ASSERT( pInfo->hwndEbRedialAttempts );

        // Redial attempts.  Note that the RAS API and phonebook allow redials
        // up to RAS_MaxRedialCount (999999999).  However, it was decided this
        // many redials didn't make sense.  Thus we have limited the UI to a max
        // of MAX_UI_REDIAL_ATTEMPTS (99) redials even though through the API
        // or an upgraded phonebook entry may have more.
        //
        hwndUdRedialAttempts = CreateUpDownControl(
            WS_CHILD + WS_VISIBLE + WS_BORDER + UDS_SETBUDDYINT
                + UDS_ALIGNRIGHT + UDS_NOTHOUSANDS + UDS_ARROWKEYS,
            0, 0, 0, 0, hwndPage, 100, g_hinstDll, pInfo->hwndEbRedialAttempts,
            MAX_UI_REDIAL_ATTEMPTS, 0, 0 );
        ASSERT( hwndUdRedialAttempts );
        
        Edit_LimitText( pInfo->hwndEbRedialAttempts, MAX_UI_REDIAL_CHARS );
        
        SetDlgItemInt( hwndPage, CID_OE_EB_RedialAttempts,
            pEntry->dwRedialAttempts, FALSE );

        // Redial times.
        //
        pInfo->hwndLbRedialTimes =
            GetDlgItem( hwndPage, CID_OE_LB_RedialTimes );
        ASSERT( pInfo->hwndLbRedialTimes );

        {
            iSel = -1;
            for (pItem = aRedialTimes, i = 0;
                 pItem->sidItem;
                 ++pItem, ++i )
            {
                ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbRedialTimes,
                    pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData ));

                if (iSel < 0
                    && pEntry->dwRedialSeconds <= pItem->dwData)
                {
                    iSel = i;
                    ComboBox_SetCurSel( pInfo->hwndLbRedialTimes, iSel );
                }
            }

            if (iSel < 0)
            {
                ComboBox_SetCurSel( pInfo->hwndLbRedialTimes, i - 1 );
            }
        }

        // Idle times.
        //
        pInfo->hwndLbIdleTimes =
            GetDlgItem( hwndPage, CID_OE_LB_IdleTimes );
        ASSERT( pInfo->hwndLbIdleTimes );

        {
            if (pEntry->lIdleDisconnectSeconds < 0)
            {
                pEntry->lIdleDisconnectSeconds = 0;
            }

            iSel = -1;
            for (pItem = aIdleTimes, i = 0;
                 pItem->sidItem;
                 ++pItem, ++i )
            {
                ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbIdleTimes,
                    pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

                if (iSel < 0
                    && pEntry->lIdleDisconnectSeconds <= (LONG )pItem->dwData)
                {
                    iSel = i;
                    ComboBox_SetCurSel( pInfo->hwndLbIdleTimes, iSel );
                }
            }

            if (iSel < 0)
            {
                ComboBox_SetCurSel( pInfo->hwndLbIdleTimes, i - 1 );
            }
        }

        if (pInfo->pArgs->fRouter)
        {
            HWND hwndRb;

            //for whistler bug 294271, initialize the window handlers for
            //multiple device group         gangz
            //
            pInfo->hwndGbMultipleDevices =
                GetDlgItem( hwndPage, CID_OE_GB_MultipleDevices );
            ASSERT( pInfo->hwndGbMultipleDevices );

            pInfo->hwndLbMultipleDevices =
                GetDlgItem( hwndPage, CID_OE_LB_MultipleDevices );
            ASSERT( pInfo->hwndLbMultipleDevices );

            pInfo->hwndPbConfigureDialing =
                GetDlgItem( hwndPage, CID_OE_PB_Configure );
            ASSERT( pInfo->hwndPbConfigureDialing );
        
            // Connection type radio buttons.
            //
            pInfo->hwndRbDemandDial =
                GetDlgItem( hwndPage, CID_OE_RB_DemandDial );
            ASSERT( pInfo->hwndRbDemandDial );

            pInfo->hwndRbPersistent =
                GetDlgItem( hwndPage, CID_OE_RB_Persistent );
            ASSERT( pInfo->hwndRbPersistent );

            hwndRb =
                (pEntry->fRedialOnLinkFailure)
                    ? pInfo->hwndRbPersistent
                    : pInfo->hwndRbDemandDial;

            SendMessage( hwndRb, BM_CLICK, 0, 0 );
        }
        else
        {
            // Redial on link failure
            //
            pInfo->hwndCbRedialOnDrop =
                GetDlgItem( hwndPage, CID_OE_CB_RedialOnDrop );
            ASSERT( pInfo->hwndCbRedialOnDrop );

            Button_SetCheck(
                pInfo->hwndCbRedialOnDrop, pEntry->fRedialOnLinkFailure );
        }
    }

    // Initialize 'Multiple devices' group box.
    //
    if (pEntry->dwType == RASET_Phone)
    {
        pInfo->hwndGbMultipleDevices =
            GetDlgItem( hwndPage, CID_OE_GB_MultipleDevices );
        ASSERT( pInfo->hwndGbMultipleDevices );

        pInfo->hwndLbMultipleDevices =
            GetDlgItem( hwndPage, CID_OE_LB_MultipleDevices );
        ASSERT( pInfo->hwndLbMultipleDevices );

        pInfo->hwndPbConfigureDialing =
            GetDlgItem( hwndPage, CID_OE_PB_Configure );
        ASSERT( pInfo->hwndPbConfigureDialing );

        {
            iSel = -1;
            for (pItem = aMultipleDeviceOptions, i = 0;
                 pItem->sidItem;
                 ++pItem, ++i )
            {
                ComboBox_AddItemFromId(
                    g_hinstDll, pInfo->hwndLbMultipleDevices,
                    pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

                if (pEntry->dwDialMode == pItem->dwData)
                {
                    iSel = i;
                    ComboBox_SetCurSel( pInfo->hwndLbMultipleDevices, iSel );
                }
            }

            if (iSel < 0)
            {
                ComboBox_SetCurSel( pInfo->hwndLbMultipleDevices, 0 );
            }
        }

        if (pInfo->pArgs->fMultipleDevices)
        {
            DWORD cChecked;

            // When the enabled device count falls below 2 the "Multiple
            // Devices" group box and contained controls are disabled.  If 2
            // or above it is enabled.
            //
            if (pInfo->hwndLvDevices)
            {
                cChecked = ListView_GetCheckedCount( pInfo->hwndLvDevices );
                OeEnableMultipleDeviceGroup( pInfo, (cChecked > 1) );
            }
        }
        else
        {
            ShowWindow( pInfo->hwndGbMultipleDevices, SW_HIDE );
            ShowWindow( pInfo->hwndLbMultipleDevices, SW_HIDE );
            ShowWindow( pInfo->hwndPbConfigureDialing, SW_HIDE );
        }
    }
    else if (pInfo->pArgs->fRouter && pEntry->dwType == RASET_Vpn)
    {
        // Make sure that a VPN demand dial interface can't be configured for
        // multilink.
        //
        ComboBox_SetCurSel( pInfo->hwndLbMultipleDevices, 0 );
        ShowWindow( pInfo->hwndGbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndLbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndPbConfigureDialing, SW_HIDE );
    }
    else if (pEntry->dwType == RASET_Broadband)
    {
        // Make sure that broadband connections can't be multilinked since
        // it is not possible to select multiple ports.
        //
        ComboBox_SetCurSel( pInfo->hwndLbMultipleDevices, 0 );
        ShowWindow( pInfo->hwndGbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndLbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndPbConfigureDialing, SW_HIDE );
    }
    else if ( pEntry->dwType == RASET_Direct )
    {   
      //for whistler bug 294271, initialize the window handlers for
      //multiple device group         gangz
      //
        ShowWindow( pInfo->hwndGbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndLbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndPbConfigureDialing, SW_HIDE );
    }

    // Bug 261692: Don't show X.25 button unless "phone" type entry.
    //
    if (pInfo->pArgs->fRouter && pEntry->dwType != RASET_Phone)
    {
        pInfo->hwndPbX25 = GetDlgItem( hwndPage, CID_OE_PB_X25 );
        ASSERT( pInfo->hwndPbX25 );

        ShowWindow( pInfo->hwndPbX25, SW_HIDE );
        EnableWindow( pInfo->hwndPbX25, FALSE );
    }

    return TRUE;
}


VOID
OeTunnel(
    IN PEINFO* pInfo )

    // Called when the "Virtual (tunnel) connection" button is pressed to
    // chain the VPN add entry wizard.
    //
{
    //!!!
}


VOID
OeUpdateUserPwState(
    IN PEINFO* pInfo )

    // Called to update the enabled/disabled save/restore state of the
    // User/password and Domain checkboxes.
    //
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    EnableCbWithRestore(
        pInfo->hwndCbPreviewUserPw,
        !pEntry->fAutoLogon,
        FALSE,
        &pInfo->fPreviewUserPw );

    EnableCbWithRestore(
        pInfo->hwndCbPreviewDomain,
        !pEntry->fAutoLogon,
        FALSE,
        &pInfo->fPreviewDomain );
}


VOID
OeX25(
    IN PEINFO* pInfo )

    // Called when the X.25 button is pressed to popup the X.25 settings
    // dialog.
    //
{
    DTLNODE* pNode;
    PBLINK* pLink;
    BOOL fLocalPad;
    INT iSel;

    // Figure out if the selected device is a local PAD device.
    //
    fLocalPad = FALSE;
    iSel = ListView_GetNextItem( pInfo->hwndLvDevices, -1, LVNI_SELECTED );
    if (iSel >= 0)
    {
        pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLvDevices, iSel );
        ASSERT( pNode );

        if(NULL == pNode)
        {
            return;
        }
        
        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT( pLink );

        if (pLink->pbport.pbdevicetype == PBDT_Pad)
        {
            fLocalPad = TRUE;
        }
    }

    // Popup the X.25 dialog which saves directly to the common context
    // 'pEntry' if user makes changes.
    //
    X25LogonSettingsDlg( pInfo->hwndDlg, fLocalPad, pInfo->pArgs->pEntry );
}


//----------------------------------------------------------------------------
// Security property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
LoDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Security page of the Entry property sheet
    // "Lo" is for Logon, the original name of this page.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "LoDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return LoInit( hwnd );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwLoHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return LoCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }

        case WM_NOTIFY:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    // Because of inter-page dependencies on the framing type,
                    // the typical and advanced sections must be reinitialized
                    // at each activation.
                    //
                    BOOL fEnabled;

                    //This is for pre-shared key bug
                    //
                    fEnabled = ( VS_PptpOnly != pInfo->pArgs->pEntry->dwVpnStrategy );
        
                    EnableWindow( pInfo->hwndPbIPSec, fEnabled );

                    pInfo->fAuthRbInitialized = FALSE;
                    LoRefreshSecuritySettings( pInfo );
                    break;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
LoCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "LoCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_LO_LB_Auths:
        {
            switch (wNotification)
            {
                case CBN_SELCHANGE:
                {
                    LoLbAuthsSelChange( pInfo );
                    return TRUE;
                }
            }
            break;
        }

        case CID_LO_CB_UseWindowsPw:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    // Necessary to save 'fAutoLogon' setting immediately as
                    // there is an inter-page dependency with the Option page
                    // 'fPreviewUserPw' and subordinate controls.
                    //
                    LoSaveTypicalAuthSettings( pInfo );
                    return TRUE;
                }
            }
            break;
        }

        case CID_LO_RB_TypicalSecurity:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    if (!pInfo->fAuthRbInitialized)
                    {
                        pInfo->fAuthRbInitialized = TRUE;
                    }

                    pInfo->pArgs->pEntry->dwAuthRestrictions
                        &= ~(AR_F_AuthCustom);
                    LoEnableSecuritySettings( pInfo, TRUE, FALSE );
                    return TRUE;
                }
            }
            break;
        }

        case CID_LO_RB_AdvancedSecurity:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    if (!pInfo->fAuthRbInitialized)
                    {
                        pInfo->fAuthRbInitialized = TRUE;
                    }
                    else
                    {
                        // Save the "typical" settings as they will be used as
                        // defaults should user decide to invoke the advanced
                        // security dialog.
                        //
                        LoSaveTypicalAuthSettings( pInfo );
                    }
                    pInfo->pArgs->pEntry->dwAuthRestrictions
                        |= AR_F_AuthCustom;
                    LoEnableSecuritySettings( pInfo, FALSE, TRUE );
                    return TRUE;
                }
            }
            break;
        }

        case CID_LO_PB_Advanced:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    // At this point, the 'pEntry' authentication settings
                    // match the current "typical" settings, which the
                    // advanced dialog uses as defaults.
                    //
                    AdvancedSecurityDlg( pInfo->hwndDlg, pInfo->pArgs );
                    return TRUE;
                }
            }
            break;
        }

        case CID_LO_PB_IPSec:
        {
            switch (wNotification)
            {
            case BN_CLICKED:
                {
                    IPSecPolicyDlg( pInfo->hwndDlg, pInfo->pArgs );
                    return TRUE;
                }
            }

            break;
        }

        case CID_LO_CB_RunScript:
        {
            if (SuScriptsCbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_LO_PB_Edit:
        {
            if (SuEditPbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_LO_PB_Browse:
        {
            if (SuBrowsePbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}


VOID
LoEnableSecuritySettings(
    IN PEINFO* pInfo,
    IN BOOL fTypical,
    IN BOOL fAdvanced )

    // Enables/disables the typical or advanced security settings based on
    // caller's 'fTypical' and 'fAdvanced' flags.  If neither flag is set all
    // controls including the frames and radio buttons are disabled.  Both
    // flags may not be set.  'PInfo' is the property sheet context.
    //
{
    BOOL fEither;

    ASSERT( !(fTypical && fAdvanced) );

    fEither = (fTypical || fAdvanced);

    EnableWindow( pInfo->hwndGbSecurityOptions, fEither );

    EnableWindow( pInfo->hwndRbTypicalSecurity, fEither );
    EnableWindow( pInfo->hwndStAuths, fTypical );
    EnableLbWithRestore( pInfo->hwndLbAuths, fTypical, &pInfo->iLbAuths );

    // Note: "Use Windows password" and "require encryption" checkbox updates
    //       are triggered by the EnableLbWithRestore above.

    EnableWindow( pInfo->hwndRbAdvancedSecurity, fEither );
    EnableWindow( pInfo->hwndStAdvancedText, fAdvanced );
    EnableWindow( pInfo->hwndPbAdvanced, fAdvanced );
}


VOID
LoFillLbAuths(
    IN PEINFO* pInfo )

    // Fill the authentication list box and set the selection based on the
    // setting in the phonebook entry.  'PInfo' is the property sheet context.
    // This routine should be called only once.
    //
{
    INT i;
    LBTABLEITEM* pItem;
    LBTABLEITEM* pItems;
    PBENTRY* pEntry;

    LBTABLEITEM aItemsPhone[] =
    {
        SID_AuthUnsecured, TA_Unsecure,
        SID_AuthSecured, TA_Secure,
        SID_AuthCardOrCert, TA_CardOrCert,
        0, 0
    };

    LBTABLEITEM aItemsVpn[] =
    {
        SID_AuthSecured, TA_Secure,
        SID_AuthCardOrCert, TA_CardOrCert,
        0, 0
    };

    LBTABLEITEM aItemsPhoneRouter[] =
    {
        SID_AuthUnsecured, TA_Unsecure,
        SID_AuthSecured, TA_Secure,
        0, 0
    };

    LBTABLEITEM aItemsVpnRouter[] =
    {
        SID_AuthSecured, TA_Secure,
        0, 0
    };

    pEntry = pInfo->pArgs->pEntry;

    if (pEntry->dwType == RASET_Vpn)
    {
        pItems = (pInfo->pArgs->fRouter) ? aItemsVpnRouter : aItemsVpn;
    }
    else
    {
        pItems = (pInfo->pArgs->fRouter) ? aItemsPhoneRouter : aItemsPhone;
    }

    for (pItem = pItems; pItem->sidItem; ++pItem)
    {
        i = ComboBox_AddItemFromId(
            g_hinstDll, pInfo->hwndLbAuths,
            pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

        if (pEntry->dwTypicalAuth == pItem->dwData)
        {
            ComboBox_SetCurSelNotify( pInfo->hwndLbAuths, i );
        }
    }

    if (ComboBox_GetCurSel( pInfo->hwndLbAuths ) < 0)
    {
        ComboBox_SetCurSelNotify( pInfo->hwndLbAuths, 0 );
    }
}


BOOL
LoInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    PEINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "LoInit" );

    pInfo = PeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }

    pEntry = pInfo->pArgs->pEntry;

    // Initialize page-specific context information.
    //
    pInfo->hwndLo = hwndPage;
    pInfo->hwndGbSecurityOptions =
        GetDlgItem( hwndPage, CID_LO_GB_SecurityOptions );
    ASSERT( pInfo->hwndGbSecurityOptions );
    pInfo->hwndRbTypicalSecurity =
        GetDlgItem( hwndPage, CID_LO_RB_TypicalSecurity );
    ASSERT( pInfo->hwndRbTypicalSecurity );
    pInfo->hwndStAuths = GetDlgItem( hwndPage, CID_LO_ST_Auths );
    ASSERT( pInfo->hwndStAuths );
    pInfo->hwndLbAuths = GetDlgItem( hwndPage, CID_LO_LB_Auths );
    ASSERT( pInfo->hwndLbAuths );
    pInfo->hwndCbUseWindowsPw = GetDlgItem( hwndPage, CID_LO_CB_UseWindowsPw );
    ASSERT( pInfo->hwndCbUseWindowsPw );
    pInfo->hwndCbEncryption = GetDlgItem( hwndPage, CID_LO_CB_Encryption );
    ASSERT( pInfo->hwndCbEncryption );
    pInfo->hwndRbAdvancedSecurity =
        GetDlgItem( hwndPage, CID_LO_RB_AdvancedSecurity );
    ASSERT( pInfo->hwndRbAdvancedSecurity );
    pInfo->hwndStAdvancedText = GetDlgItem( hwndPage, CID_LO_ST_AdvancedText );
    ASSERT( pInfo->hwndStAdvancedText );
    pInfo->hwndPbAdvanced = GetDlgItem( hwndPage, CID_LO_PB_Advanced );
    ASSERT( pInfo->hwndPbAdvanced );

    //
    //for VPN's security page show IPSec Policy 
    // for whistler bug 193987
    //
    if ( pInfo->pArgs->pEntry->dwType == RASET_Vpn )
    {
        BOOL  fEnabled;

        pInfo->hwndPbIPSec = GetDlgItem( hwndPage, CID_LO_PB_IPSec );
        ASSERT( pInfo->hwndPbIPSec );

        //  gangz
        //If it is for a remote Win2k server's Demand Dialer
        //dont show the IPSec Policy stuff, because W2k didnt
        //implement this.
        //
        if ( pInfo->pArgs->fW2kRouter )
        {
            ShowWindow( pInfo->hwndPbIPSec, FALSE );
        }
        else
        {
            fEnabled = ( VS_PptpOnly != pInfo->pArgs->pEntry->dwVpnStrategy );
            EnableWindow( pInfo->hwndPbIPSec, fEnabled );
        }

        //for the IPSec Policy dialog, fPSKCached = TRUE means the user already
        //go to the IPSec Policy dialog and saved a PSK     gangz
        //
        pInfo->pArgs->fPSKCached = FALSE; 

        //gangz:  for bug# 276452
        //On a Server OS, the help message for this IPSec pushbutton 
        //should be different from that for a Non-server OS, 
        //so change its help ID when neeeded.
        //
        if ( IsServerOS() )
        {
            DWORD * p = (DWORD *)g_adwLoHelp;

            while( p )
            {
                if ( (p[0] == 0) && ( p[1] == 0 ) )
                {
                    break;
                 }
               
                if ( (p[0] == CID_LO_PB_IPSec) &&
                     (p[1] == HID_LO_PB_IPSec) )
                {
                    p[1] = HID_LO_PB_IPSecServer;
                    break;
                }

                p+=2;
            }
        }
        
    }
    else
    {
        pInfo->hwndGbScripting = GetDlgItem( hwndPage, CID_LO_GB_Scripting );
        ASSERT( pInfo->hwndGbScripting );
        pInfo->hwndCbRunScript = GetDlgItem( hwndPage, CID_LO_CB_RunScript );
        ASSERT( pInfo->hwndCbRunScript );
        pInfo->hwndCbTerminal = GetDlgItem( hwndPage, CID_LO_CB_Terminal );
        ASSERT( pInfo->hwndCbTerminal );
        pInfo->hwndLbScripts = GetDlgItem( hwndPage, CID_LO_LB_Scripts );
        ASSERT( pInfo->hwndLbScripts );
        pInfo->hwndPbEdit = GetDlgItem( hwndPage, CID_LO_PB_Edit );
        ASSERT( pInfo->hwndPbEdit );
        pInfo->hwndPbBrowse = GetDlgItem( hwndPage, CID_LO_PB_Browse );
        ASSERT( pInfo->hwndPbBrowse );
    }

    // Initialize the page controls.  Note that the page activation event
    // immediately after this initialization triggers the final security
    // setting enabling/disabling and does any "restore caching".  While this
    // initialization sets the check values and list selection to bootstrap
    // the "restore caching", these settings may be adjusted by the activation
    // refresh.
    //
    if (pInfo->pArgs->fRouter)
    {
        // The "Use Windows credentials" option is removed in the demand-dial
        // case.
        //
        pInfo->fUseWindowsPw = FALSE;
        Button_SetCheck( pInfo->hwndCbUseWindowsPw, FALSE );
        EnableWindow ( pInfo->hwndCbUseWindowsPw, FALSE );
        ShowWindow (pInfo->hwndCbUseWindowsPw, SW_HIDE );
    }
    else
    {
        pInfo->fUseWindowsPw = pEntry->fAutoLogon;
        Button_SetCheck( pInfo->hwndCbUseWindowsPw, pInfo->fUseWindowsPw  );
    }

    pInfo->fEncryption =
        (pEntry->dwDataEncryption != DE_None
         && pEntry->dwDataEncryption != DE_IfPossible);
    Button_SetCheck( pInfo->hwndCbEncryption, pInfo->fEncryption );

    // Fill authentiction list and set selection, which triggers all
    // appropriate enabling/disabling.
    //
    LoFillLbAuths( pInfo );

    if ((pInfo->pArgs->pEntry->dwType != RASET_Vpn)
         && (pInfo->pArgs->pEntry->dwType != RASET_Direct) 
         && (pInfo->pArgs->pEntry->dwType != RASET_Broadband))
         //&& !pInfo->pArgs->fRouter)
    {
        // Set up the after-dial scripting controls.
        //
        SuInit( &pInfo->suinfo,
            pInfo->hwndCbRunScript,
            pInfo->hwndCbTerminal,
            pInfo->hwndLbScripts,
            pInfo->hwndPbEdit,
            pInfo->hwndPbBrowse,
            pInfo->pArgs->fRouter ? SU_F_DisableTerminal : 0);
        pInfo->fSuInfoInitialized = TRUE;

        SuSetInfo( &pInfo->suinfo,
            pEntry->fScriptAfter,
            pEntry->fScriptAfterTerminal,
            pEntry->pszScriptAfter );
    }
    else
    {
        // Disable/hide the after-dial scripting controls.
        // for VPN there is no need to do this Disable/hide operation
        //
        if (pInfo->pArgs->pEntry->dwType != RASET_Vpn)
        {
            EnableWindow( pInfo->hwndGbScripting, FALSE );
            ShowWindow( pInfo->hwndGbScripting, SW_HIDE );
            EnableWindow( pInfo->hwndCbRunScript, FALSE );
            ShowWindow( pInfo->hwndCbRunScript, SW_HIDE );
            EnableWindow( pInfo->hwndCbTerminal, FALSE );
            ShowWindow( pInfo->hwndCbTerminal, SW_HIDE );
            EnableWindow( pInfo->hwndLbScripts, FALSE );
            ShowWindow( pInfo->hwndLbScripts, SW_HIDE );
            EnableWindow( pInfo->hwndPbEdit, FALSE );
            ShowWindow( pInfo->hwndPbEdit, SW_HIDE );
            EnableWindow( pInfo->hwndPbBrowse, FALSE );
            ShowWindow( pInfo->hwndPbBrowse, SW_HIDE );
        }
    }

    if (pInfo->pArgs->fRouter)
    {
        EnableWindow( pInfo->hwndCbTerminal, FALSE );
        ShowWindow( pInfo->hwndCbTerminal, SW_HIDE );
    }

    return TRUE;
}


VOID
LoLbAuthsSelChange(
    IN PEINFO* pInfo )

    // Called when the selection in the authentication drop list is changed.
    //
{
    INT iSel;
    DWORD dwTaCode;

    // Retrieve the bitmask of authentication protocols associated with the
    // selected authentication level.
    //
    iSel = ComboBox_GetCurSel( pInfo->hwndLbAuths );
    if (iSel < 0)
    {
        dwTaCode = 0;
    }
    else
    {
        dwTaCode = (DWORD )ComboBox_GetItemData( pInfo->hwndLbAuths, iSel );
    }

    if (!pInfo->pArgs->fRouter)
    {
        // Update the "Use Windows NT credentials" checkbox.  Per the spec, it
        // is enabled only for "require secure password", though the real
        // requirement is that MSCHAP (provides NT-style credentials) gets
        // negotiated.
        //
        EnableCbWithRestore(
            pInfo->hwndCbUseWindowsPw,
            (dwTaCode == TA_Secure),
            FALSE,
            &pInfo->fUseWindowsPw );
    }

    // Update the "Require data encryption" checkbox.  Per the spec, it is
    // enabled unless "allow unsecured password" is selected, though the real
    // requirement is that all authentication protocols in the set provide
    // MPPE encryption keys.
    //
    EnableCbWithRestore(
        pInfo->hwndCbEncryption,
        (dwTaCode != 0 && dwTaCode != TA_Unsecure),
        FALSE,
        &pInfo->fEncryption );
}


VOID
LoRefreshSecuritySettings(
    IN PEINFO* pInfo )

    // Sets the contents and state of all typical and advanced security
    // setting fields.
    //
{
    if (pInfo->pArgs->pEntry->dwBaseProtocol & BP_Slip)
    {
        // For SLIP framing, all the typical and advanced controls are
        // disabled and the radio buttons show no selection.
        //
        Button_SetCheck( pInfo->hwndRbTypicalSecurity, FALSE );
        Button_SetCheck( pInfo->hwndRbAdvancedSecurity, FALSE );
        LoEnableSecuritySettings( pInfo, FALSE, FALSE );

        if (pInfo->fShowSlipPopup)
        {
            // Time to show the one-shot informational about SLIP not doing
            // any in-protocol authentication or encryption.
            //
            MsgDlg( pInfo->hwndDlg, SID_NoAuthForSlip, NULL );
            pInfo->fShowSlipPopup = FALSE;
        }
    }
    else
    {
        HWND hwndRb;

        // For PPP framing, select the appropriate security setting radio
        // button which triggers additional enabling/disabling of the framed
        // controls.
        //
        if (pInfo->pArgs->pEntry->dwAuthRestrictions & AR_F_AuthCustom)
        {
            hwndRb = pInfo->hwndRbAdvancedSecurity;
        }
        else
        {
            hwndRb = pInfo->hwndRbTypicalSecurity;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }
}


VOID
LoSaveTypicalAuthSettings(
    IN PEINFO* pInfo )

    // Save the values in the "typical" authentication controls to the
    // phonebook entry.  'PInfo' is the property sheet context.
    //
{
    PBENTRY* pEntry;
    INT iSel;

    pEntry = pInfo->pArgs->pEntry;
    iSel = ComboBox_GetCurSel( pInfo->hwndLbAuths );
    if (iSel >= 0)
    {
        pEntry->dwTypicalAuth =
            (DWORD) ComboBox_GetItemData( pInfo->hwndLbAuths, iSel );

        pEntry->dwAuthRestrictions =
            AuthRestrictionsFromTypicalAuth( pEntry->dwTypicalAuth );

        // Set the default custom authentication key value for smart
        // cards.  RasDial API should assume this default anyway, but we
        // need it before then in DialerDlgEap.
        //
        if (pEntry->dwTypicalAuth == TA_CardOrCert)
        {
            pEntry->dwCustomAuthKey = EAPCFG_DefaultKey;
        }
        else
        {
            pEntry->dwCustomAuthKey = (DWORD )-1;
        }
    }

    if (IsWindowEnabled( pInfo->hwndCbUseWindowsPw ))
    {
        pEntry->fAutoLogon =
            Button_GetCheck( pInfo->hwndCbUseWindowsPw );
    }
    else
    {
        pEntry->fAutoLogon = FALSE;
    }

    if (IsWindowEnabled( pInfo->hwndCbEncryption ))
    {
        pEntry->dwDataEncryption =
            (Button_GetCheck( pInfo->hwndCbEncryption ))
                ? DE_Require : DE_IfPossible;
    }
    else
    {
        pEntry->dwDataEncryption = DE_IfPossible;
    }

    if (pEntry->dwDataEncryption == DE_Require
        && !(pEntry->dwType == RASET_Vpn
             && pEntry->dwVpnStrategy == VS_L2tpOnly))
    {
        // Encryption is required and MPPE will be the encryption method
        // so eliminate authentication protocols that don't support it.
        //
        pEntry->dwAuthRestrictions &= ~(AR_F_AuthNoMPPE);
    }
}


//----------------------------------------------------------------------------
// Networking property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

LVXDRAWINFO*
NeLvComponentsCallback(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the draw information.
    //
{
    // Use "full row select" and other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info = { 1, 0, LVXDI_DxFill, { 0 } };

    return &info;
}

INT_PTR CALLBACK
NeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Network page of the Entry property sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    // Filter the customized list view messages
    if (ListView_OwnerHandler(hwnd, unMsg, wparam, lparam, NeLvComponentsCallback))
        return TRUE;

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return NeInit( hwnd );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwNeHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext (hwnd);
            ASSERT (pInfo);

            switch (LOWORD(wparam))
            {
                case CID_NE_LB_ServerType:
                    if (CBN_SELCHANGE == HIWORD(wparam))
                    {
                        NeServerTypeSelChange (pInfo);
                    }
                    break;

                case CID_NE_PB_Settings:
                    DialogBoxParam (g_hinstDll,
                        MAKEINTRESOURCE(DID_NE_PppSettings),
                        hwnd, PpDlgProc, (LPARAM)pInfo);
                    break;

                case CID_NE_PB_Add:
                    NeAddComponent (pInfo);
                    break;

                case CID_NE_PB_Properties:
                    NeShowComponentProperties (pInfo);
                    break;

                case CID_NE_PB_Remove:
                    NeRemoveComponent (pInfo);
                    break;
            }
            break;
        }

        case WM_NOTIFY:
        {
            PEINFO* pInfo = PeContext(hwnd);

            //!!! Hack related to PeTerm in WM_DESTROY.  We still get
            // WM_NOTIFYs after PeTerm is called.  So we commented out the
            // following assert and moved it into each message handler below.
            //ASSERT (pInfo);

            switch (((NMHDR*)lparam)->code)
            {
// !!! See if base lvx.c code can handle inversion of check state on double
// click.
#if 0
                case NM_CLICK:
                    ASSERT (pInfo);
                    if (CID_NE_LV_Components == ((NMHDR*)lparam)->idFrom)
                    {
                        NeLvClick (pInfo, FALSE);
                    }
                    break;
#endif

                case NM_DBLCLK:
                    ASSERT (pInfo);
                    if (CID_NE_LV_Components == ((NMHDR*)lparam)->idFrom)
                    {
                        NeLvClick (pInfo, TRUE);
                    }
                    break;

                case LVN_ITEMCHANGED:
                    ASSERT (pInfo);
                    NeLvItemChanged (pInfo);
                    break;

                case LVN_DELETEITEM:
                    ASSERT (pInfo);
                    NeLvDeleteItem (pInfo, (NM_LISTVIEW*)lparam);
                    break;

                case PSN_SETACTIVE:
                    ASSERT (pInfo);

                    // If we couldn't get INetCfg, we can't show this page.
                    //
                    if (!pInfo->pNetCfg)
                    {
                        MsgDlg( pInfo->hwndDlg, ERR_CANT_SHOW_NETTAB_INETCFG, NULL );
                        SetWindowLong( hwnd, DWLP_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;
            }
            break;
        }
    }
    return FALSE;
}


void
NeEnsureNetshellLoaded (
    IN PEINFO* pInfo)
{
    // Load the netshell utilities interface.  The interface is freed in PeTerm.
    //
    if (!pInfo->pNetConUtilities)
    {
        // Initialize the NetConnectionsUiUtilities
        //
        HRESULT hr = HrCreateNetConnectionUtilities(&pInfo->pNetConUtilities);
    }
}

BOOL
NeInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    PEINFO*  pInfo;
    PBENTRY* pEntry;

    pInfo = PeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }

    // Initialize page-specific context information.
    //
    pInfo->hwndLbServerType =
        GetDlgItem( hwndPage, CID_NE_LB_ServerType );
    ASSERT( pInfo->hwndLbServerType );

    pInfo->hwndPbSettings =
        GetDlgItem( hwndPage, CID_NE_PB_Settings );
    ASSERT( pInfo->hwndPbSettings );

    pInfo->hwndLvComponents =
        GetDlgItem( hwndPage, CID_NE_LV_Components );
    ASSERT( pInfo->hwndLvComponents );

    pInfo->hwndPbAdd =
        GetDlgItem( hwndPage, CID_NE_PB_Add );
    ASSERT( pInfo->hwndPbAdd );

    pInfo->hwndPbRemove =
        GetDlgItem( hwndPage, CID_NE_PB_Remove );
    ASSERT( pInfo->hwndPbRemove );

    pInfo->hwndPbProperties =
        GetDlgItem( hwndPage, CID_NE_PB_Properties );
    ASSERT( pInfo->hwndPbProperties );

    pInfo->hwndDescription =
        GetDlgItem( hwndPage, CID_NE_LB_ComponentDesc );
    ASSERT( pInfo->hwndDescription );

    // Initialize page.
    //
    pEntry = pInfo->pArgs->pEntry;

    // Initialize the server type combo box with the strings and the selection.
    //
    if (pEntry->dwType == RASET_Vpn)
    {
        INT i;
        LBTABLEITEM* pItem;

        // Whistler bug 312921 CM/RAS should default to PPTP instead of L2TP
        //
        LBTABLEITEM aItems[] =
        {
            SID_ST_VpnAuto, VS_PptpFirst,
            SID_ST_VpnPptp, VS_PptpOnly,
            SID_ST_VpnL2tp, VS_L2tpOnly,
            0, 0
        };

        for (pItem = aItems; pItem->sidItem != 0; ++pItem)
        {
            i = ComboBox_AddItemFromId(
                g_hinstDll, pInfo->hwndLbServerType,
                pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

            if (pItem->dwData == pEntry->dwVpnStrategy)
            {
                ComboBox_SetCurSel( pInfo->hwndLbServerType, i );
            }
        }

        // If nothing was selected, then the strategy must have been one of the
        // VS_xxxxFirst values.  Set the current selection to automatic.
        if ( ComboBox_GetCurSel ( pInfo->hwndLbServerType ) < 0 )
            ComboBox_SetCurSel( pInfo->hwndLbServerType, 0 );

        // Change the label to be VPN-specific per bug 307526.
        //
        {
            TCHAR* psz;

            psz = PszFromId( g_hinstDll, SID_NE_VpnServerLabel );
            if (psz)
            {
                SetWindowText(
                    GetDlgItem( hwndPage, CID_NE_ST_ServerType ), psz );
                Free( psz );
            }
        }
    }
    else if (pEntry->dwType == RASET_Broadband)
    {
        INT i;
        LBTABLEITEM* pItem;
        LBTABLEITEM aItems[] =
        {
            SID_ST_BbPppoe, BP_Ppp,
            0, 0
        };

        for (pItem = aItems; pItem->sidItem != 0; ++pItem)
        {
            i = ComboBox_AddItemFromId(
                g_hinstDll, pInfo->hwndLbServerType,
                pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));
        }
        ComboBox_SetCurSel( pInfo->hwndLbServerType, 0 );

        // Change the label to be broadband-specific
        //
        {
            TCHAR* psz;

            psz = PszFromId( g_hinstDll, SID_NE_BbServerLabel );
            if (psz)
            {
                SetWindowText(
                    GetDlgItem( hwndPage, CID_NE_ST_ServerType ), psz );
                Free( psz );
            }
        }
    }
    else
    {
        ComboBox_AddItemFromId (g_hinstDll, pInfo->hwndLbServerType,
            SID_ST_Ppp, (VOID*)BP_Ppp );
        if (!pInfo->pArgs->fRouter)
        {
            ComboBox_AddItemFromId (g_hinstDll, pInfo->hwndLbServerType,
                SID_ST_Slip, (VOID*)BP_Slip );
        }

        if (pEntry->dwBaseProtocol == BP_Ppp)
        {
            ComboBox_SetCurSel(pInfo->hwndLbServerType, 0 );
        }
        else
        {
            ComboBox_SetCurSel( pInfo->hwndLbServerType, 1 );
            EnableWindow( pInfo->hwndPbSettings, FALSE );
        }
    }

    // Set the image list for the state of the check boxes.
    //
    ListView_InstallChecks( pInfo->hwndLvComponents, g_hinstDll );
    ListView_InsertSingleAutoWidthColumn( pInfo->hwndLvComponents );

    // Set the image list for the component bitmaps.  Unfortunately we have to
    // duplicate it (as opposed to share) because the image list for the state
    // icons is not shared.  (If we set the shared style, all image lists would
    // have to be deleted manually.
    //
    {
        ZeroMemory (&pInfo->cild, sizeof(pInfo->cild));
        pInfo->cild.cbSize = sizeof(pInfo->cild);
        if (SetupDiGetClassImageList (&pInfo->cild))
        {
            HIMAGELIST himlSmall = ImageList_Duplicate (pInfo->cild.ImageList);
            ListView_SetImageList (pInfo->hwndLvComponents, himlSmall, LVSIL_SMALL);
        }
    }

    // Get the interface used to change network configuration and lock it.
    // The description of who has the lock (us) comes from the title of our
    // parent dialog.  This is done so that when other applications try to obtain
    // the lock (and fail) they get an indication of who has it locked.  They
    // can then direct the user to close our window to release the lock.
    //
    {
        BOOL fEnableAdd = TRUE;
        HRESULT hr;
        TCHAR pszParentCaption [MAX_PATH] = {0};
        GetWindowText (GetParent(hwndPage), pszParentCaption, MAX_PATH);
        pInfo->fInitCom = TRUE;
        hr = HrCreateAndInitializeINetCfg (&pInfo->fInitCom, &pInfo->pNetCfg,
                        TRUE, 0, pszParentCaption, NULL);
        if (S_OK == hr)
        {
            // Refresh the list view.
            //
            hr = HrNeRefreshListView (pInfo);

            // Reset the state of the buttons as if something changed.
            //
            NeLvItemChanged (pInfo);

            pInfo->fNetCfgLock = TRUE;
        }
        else
        {
            DWORD   dwMsg = SID_NE_ReadOnly;

            //For whistler bug 311566
            //
            if (NETCFG_E_NO_WRITE_LOCK == hr)
            {
                pInfo->fReadOnly = TRUE;
            }                

            if (NETCFG_E_NEED_REBOOT == hr)
            {
                dwMsg = SID_NE_Reboot;
            }
            else if (E_ACCESSDENIED == hr)
            {
                pInfo->fNonAdmin = TRUE;
                dwMsg = SID_NE_AccessDenied;
            }

            // Uh.. ok let's try that again in read-only mode
            hr = HrCreateAndInitializeINetCfg (&pInfo->fInitCom,
                                               &pInfo->pNetCfg,FALSE, 0,
                                               pszParentCaption, NULL);

            if (S_OK == hr)
            {
                // Refresh the list view.
                //
                hr = HrNeRefreshListView (pInfo);

                // Reset the state of the buttons as if something changed.
                //
                NeLvItemChanged (pInfo);

                MsgDlg( pInfo->hwndDlg, dwMsg, NULL );
            }
        }

        // Get the interface so we can check our access rights to the UI
        //
        NeEnsureNetshellLoaded (pInfo);
        if (NULL != pInfo->pNetConUtilities)
        {
            fEnableAdd = INetConnectionUiUtilities_UserHasPermission(
                                            pInfo->pNetConUtilities,
                                            NCPERM_AddRemoveComponents);
        }

        // Disable some buttons if user does not have privilege
        //
        if (pInfo->fReadOnly || (NULL == pInfo->pNetConUtilities))
        {
            EnableWindow(pInfo->hwndPbAdd, FALSE);
            EnableWindow(pInfo->hwndPbRemove, FALSE);
            EnableWindow(pInfo->hwndPbProperties, FALSE);
        }
        // Disable some buttons if running in non-admin mode
        else if (pInfo->fNonAdmin)
        {
            EnableWindow(pInfo->hwndPbAdd, FALSE);
            EnableWindow(pInfo->hwndPbRemove, FALSE);
        }
        else
        {
            EnableWindow(pInfo->hwndPbAdd, fEnableAdd);
            // Other buttons enabled via NeLvItemChanged
        }

        // pmay: 348623
        //
        // Hide some buttons if we're remote admining
        //
        if (pInfo->pArgs->fRemote)
        {
            ShowWindow(pInfo->hwndPbAdd, SW_HIDE);
            ShowWindow(pInfo->hwndPbRemove, SW_HIDE);
        }
    }
    return TRUE;
}

void
NeServerTypeSelChange (
    IN PEINFO* pInfo)
{
    PBENTRY* pEntry;
    int iSel;
    DWORD dwValue;

    pEntry = pInfo->pArgs->pEntry;
    iSel = ComboBox_GetCurSel (pInfo->hwndLbServerType);
    ASSERT (CB_ERR != iSel);

    dwValue = (DWORD) ComboBox_GetItemData (pInfo->hwndLbServerType, iSel);

    // Regular connections choose between slip and ppp
    //
    if (pEntry->dwType != RASET_Vpn)
    {
        pEntry->dwBaseProtocol = dwValue;

        // When SLIP is selected, turn off all protocols but IP and indicate
        // the SLIP security page informational popup should appear.
        //
        if (BP_Slip == dwValue)
        {
            // No need to exclude the protocols. We lose this config state if
            // we remove this and its of no use anyway. PPP won't be done
            // if slip is selected -- [raos].
            //
            // pEntry->dwfExcludedProtocols = ~NP_Ip;

            pInfo->fShowSlipPopup = TRUE;
        }

        HrNeRefreshListView (pInfo);
    }

    // Vpn connections select a strategy.  When automatic is selected,
    // we need to make sure the authentication and encryption is
    // compatible
    //
    else
    {
        pEntry->dwVpnStrategy = dwValue;

        // Whistler bug 312921 CM/RAS should default to PPTP instead of L2TP
        //
        if (dwValue == VS_PptpFirst)
        {
            pEntry->dwDataEncryption = DE_Require;

            if( !(pEntry->dwAuthRestrictions & AR_F_AuthEAP ) )
            {
                pEntry->dwAuthRestrictions = AR_F_TypicalSecure;
            }
            
            pEntry->dwTypicalAuth = TA_Secure;
        }
    }

    EnableWindow (pInfo->hwndPbSettings, !!(BP_Ppp == pEntry->dwBaseProtocol));
}

BOOL
NeRequestReboot (
    IN PEINFO* pInfo)
{
    NeEnsureNetshellLoaded (pInfo);

    if (pInfo->pNetConUtilities)
    {
        HRESULT     hr;

        // A reboot is required. Ask the user if it is ok to reboot now
        //
        //$TODO NULL caption?
        hr = INetConnectionUiUtilities_QueryUserForReboot(
                        pInfo->pNetConUtilities, pInfo->hwndDlg,
                        NULL, QUFR_PROMPT);
        if (S_OK == hr)
        {
            // User requested a reboot, note this for processing in OnApply
            // which is triggered by the message posted below
            //
            pInfo->fRebootAlreadyRequested = TRUE;

            // Press the cancel button (changes have already been applied)
            // so the appropriate cleanup occurs.
            //
            PostMessage(pInfo->hwndDlg, PSM_PRESSBUTTON,
                        (WPARAM)PSBTN_OK, 0);
        }
        else if (S_FALSE == hr)
        {
            // User denied to request to reboot
            //
            return FALSE;
        }
    }

    return TRUE;
}

void
NeSaveBindingChanges(IN PEINFO* pInfo)
{
    // Won't have changes to keep unless we have a writable INetCfg
    if (pInfo->pNetCfg)
    {
        int                 iItem;
        INetCfgComponent*   pComponent;
        BOOL                fEnabled;
        HRESULT             hr;

        // Update the phone book entry with the enabled state of the components.
        // Do this by enumerating the components from the list view item data
        // and consulting the check state for each.
        //
        iItem = -1;
        while (-1 != (iItem = ListView_GetNextItem (pInfo->hwndLvComponents,
                                iItem, LVNI_ALL)))
        {
            pComponent = PComponentFromItemIndex (pInfo->hwndLvComponents, iItem);
            ASSERT (pComponent);

            fEnabled = ListView_GetCheck (pInfo->hwndLvComponents, iItem);
            if(pComponent)
            {
                NeEnableComponent (pInfo, pComponent, fEnabled);
            }
        }
    }
}

void
NeAddComponent (
    IN PEINFO* pInfo)
{
    NeEnsureNetshellLoaded (pInfo);

    // If we have our pointer to the interface used to bring up the add
    // component dialog (obtained above only once), call it.
    //
    if (pInfo->pNetConUtilities)
    {
        HRESULT hr;

        // We want to filter out protocols that RAS does not care about
        // We do this by sending in a CI_FILTER_INFO structure indicating
        // we want non-RAS protocols filtered out
        //
        CI_FILTER_INFO cfi = {0};
        cfi.eFilter = FC_RASCLI;

        ASSERT (pInfo->pNetCfg);
        hr = INetConnectionUiUtilities_DisplayAddComponentDialog(
                        pInfo->pNetConUtilities, pInfo->hwndDlg,
                        pInfo->pNetCfg, &cfi);

        // If the user didn't cancel, refresh the list view.
        //
        if (S_FALSE != hr)
        {
            if (SUCCEEDED(hr))
            {
                // Change the Cancel Button to CLOSE (because we committed changes)
                //
                PropSheet_CancelToClose(pInfo->hwndDlg);
            }

            // commit binding changes made (Raid #297216)
            NeSaveBindingChanges(pInfo);

            HrNeRefreshListView (pInfo);

            // Reset the state of the buttons as if something changed.
            //
            NeLvItemChanged (pInfo);

            // If reboot is needed request approval for this from the user
            //
            if (NETCFG_S_REBOOT == hr)
            {
                NeRequestReboot (pInfo);
            }
        }
    }
}

void
NeRemoveComponent (
    IN PEINFO* pInfo)
{
    NeEnsureNetshellLoaded (pInfo);

    // If we have our pointer to the function used to bring up the remove
    // component dialog (obtained above only once), call it.
    //
    if (pInfo->pNetConUtilities)
    {
        HRESULT hr;
        INetCfgComponent* pComponent;
        pComponent = PComponentFromCurSel (pInfo->hwndLvComponents, NULL);
        ASSERT (pComponent);

        ASSERT (pInfo->pNetCfg);
        hr = INetConnectionUiUtilities_QueryUserAndRemoveComponent(
                        pInfo->pNetConUtilities, pInfo->hwndDlg,
                        pInfo->pNetCfg, pComponent);

        // If the user didn't cancel, refresh the list view.
        //
        if (S_FALSE != hr)
        {
            if (SUCCEEDED(hr))
            {
                // Change the Cancel Button to CLOSE (because we committed changes)
                //
                PropSheet_CancelToClose(pInfo->hwndDlg);
            }

            NeSaveBindingChanges(pInfo);

            HrNeRefreshListView(pInfo);

            // Reset the state of the buttons as if something changed.
            //
            NeLvItemChanged (pInfo);

            // If reboot is needed request approval for this from the user
            //
            if (NETCFG_S_REBOOT == hr)
            {
                NeRequestReboot (pInfo);
            }
        }
    }
}

void
NeLvClick (
    IN PEINFO* pInfo,
    IN BOOL fDoubleClick)
{
    //Add the IsWindowEnabled for whistler bug #204976
    //Not to pop up the property dialog box if it is a router
    //and the selected List View item is IPX
    //
    if (fDoubleClick && IsWindowEnabled(pInfo->hwndPbProperties))
    {
        INetCfgComponent*   pComponent;
        int iItem;

        pComponent = PComponentFromCurSel (pInfo->hwndLvComponents, &iItem);
        if (pComponent)
        {
            HRESULT hr;
            if ( ListView_GetCheck (pInfo->hwndLvComponents, iItem))
            {
                // Check if the component has property UI
                //

                // Create the UI info callback object if we haven't done so yet.
                // If this fails, we can still show properties.  TCP/IP just might
                // not know which UI-variant to show.
                //
                if (!pInfo->punkUiInfoCallback)
                {
                    HrCreateUiInfoCallbackObject (pInfo, &pInfo->punkUiInfoCallback);
                }

                // Check if the component has property UI
                hr = INetCfgComponent_RaisePropertyUi ( pComponent,
                                                        pInfo->hwndDlg,
                                                        NCRP_QUERY_PROPERTY_UI,
                                                        pInfo->punkUiInfoCallback);

                if (S_OK == hr)
                {
                    NeEnsureNetshellLoaded (pInfo);
                    if ((NULL != pInfo->pNetConUtilities) &&
                        INetConnectionUiUtilities_UserHasPermission(
                                                pInfo->pNetConUtilities,
                                                NCPERM_RasChangeProperties))
                    {
                        NeShowComponentProperties (pInfo);
                    }
                }
            }
        }
    }
}

void
NeLvItemChanged (
    IN PEINFO* pInfo)
{
    LPWSTR              pszwDescription    = NULL;
    BOOL                fEnableRemove      = FALSE;
    BOOL                fEnableProperties  = FALSE;
    INetCfgComponent*   pComponent;
    int iItem;

    // Get the current selection if it exists.
    //
    pComponent = PComponentFromCurSel (pInfo->hwndLvComponents, &iItem);
    if (pComponent)
    {
        NeEnsureNetshellLoaded (pInfo);

        // Determine if removal is allowed
        //
        if (NULL != pInfo->pNetConUtilities)
        {
            DWORD   dwFlags = 0;
            HRESULT hr;
            fEnableRemove = INetConnectionUiUtilities_UserHasPermission(
                                            pInfo->pNetConUtilities,
                                            NCPERM_AddRemoveComponents);
                                            
            //Now disable the user ability to uninstall TCP stack
            //for whistler bug 322846   gangz
            //
            hr = INetCfgComponent_GetCharacteristics(pComponent, &dwFlags );
            if( SUCCEEDED(hr) && (NCF_NOT_USER_REMOVABLE & dwFlags) )
            {
                fEnableRemove = FALSE;
            }
        }

        // See if the properties UI should be allowed.  Only allow it for
        // enabled items that have UI to display.
        //
        {
            HRESULT hr = S_OK;
            if (ListView_GetCheck (pInfo->hwndLvComponents, iItem))
            {
                // Check if the component has property UI
                //
                INetCfgComponent* pComponentTmp = PComponentFromCurSel (pInfo->hwndLvComponents, NULL);
                ASSERT (pComponentTmp);

                // Create the UI info callback object if we haven't done so yet.
                // If this fails, we can still show properties.  TCP/IP just might
                // not know which UI-variant to show.
                //
                if (!pInfo->punkUiInfoCallback)
                {
                    HrCreateUiInfoCallbackObject (pInfo, &pInfo->punkUiInfoCallback);
                }

                if(pComponentTmp)
                {

                    // Check if the component has property UI
                    hr = INetCfgComponent_RaisePropertyUi ( pComponentTmp,
                                                        pInfo->hwndDlg,
                                                        NCRP_QUERY_PROPERTY_UI,
                                                        pInfo->punkUiInfoCallback);

                    if ((S_OK == hr) && (NULL != pInfo->pNetConUtilities))
                    {
                        fEnableProperties = INetConnectionUiUtilities_UserHasPermission(
                                                    pInfo->pNetConUtilities,
                                                    NCPERM_RasChangeProperties);
                    }
                }
            }
        }

        // Bug #221837 (danielwe): Set member vars based on whether they
        // are checked in the UI
        //
        {
            PBENTRY *           pEntry;
            BOOL                fIsChecked;
            LPWSTR              pszwId = NULL;

            pEntry = pInfo->pArgs->pEntry;

            fIsChecked = ListView_GetCheck(pInfo->hwndLvComponents, iItem);

            if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
            {
                // For whistler 522872
                //
                if( CSTR_EQUAL == CompareStringW(
                        LOCALE_INVARIANT,
                        NORM_IGNORECASE,
                        NETCFG_CLIENT_CID_MS_MSClient,
                        -1,
                        pszwId,
                        -1
                        )
                    )
                {
                    pEntry->fBindMsNetClient = fIsChecked;
                }
                else if( CSTR_EQUAL == CompareStringW(
                            LOCALE_INVARIANT,
                            NORM_IGNORECASE,
                            NETCFG_SERVICE_CID_MS_SERVER,
                            -1,
                            pszwId,
                            -1
                            )
                        )
                {
                    pEntry->fShareMsFilePrint = fIsChecked;
                }
                // pmay 406630
                // 
                // Disable the properties of all components but tcpip if we
                // are running in non-admin mode
                //
                
                else if ( CSTR_EQUAL == CompareStringW(
                            LOCALE_INVARIANT,
                            NORM_IGNORECASE,
                            NETCFG_TRANS_CID_MS_TCPIP,
                            -1,
                            pszwId,
                            -1)
                            )
                {
                    if (pInfo->fNonAdmin)
                    {
                        fEnableProperties = FALSE;
                    }
                }
                
                CoTaskMemFree(pszwId);
            }
        }

        // Bug #348623 (pmay): 
        //
        // Ipx is hardcoded to disable properties when remote admining
        // a router.
        //
        if (pInfo->pArgs->fRouter ) //commented for bug #204976 //&& pInfo->pArgs->fRemote)
        {
            LPWSTR              pszwId = NULL;

            if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
            {
                if ( CSTR_EQUAL== CompareStringW(
                        LOCALE_INVARIANT,
                        NORM_IGNORECASE,
                        NETCFG_TRANS_CID_MS_NWIPX,
                        -1,
                        pszwId,
                        -1)
                    )
                {
                    fEnableProperties = FALSE;
                }

                CoTaskMemFree(pszwId);
            }
        }

        // Get the description text.  Failure is okay here.  It just means
        // we'll display nothing.
        //
        INetCfgComponent_GetHelpText (pComponent, &pszwDescription);
    }

    // Update the UI with its new state.
    //
    if (!pInfo->fReadOnly)
    {
        EnableWindow (pInfo->hwndPbRemove,      fEnableRemove);
        EnableWindow (pInfo->hwndPbProperties,  fEnableProperties);
    }

    if(NULL != pszwDescription)
    {
        SetWindowText (pInfo->hwndDescription,  pszwDescription);
        CoTaskMemFree (pszwDescription);
    }
}

void
NeLvDeleteItem (
    IN PEINFO* pInfo,
    IN NM_LISTVIEW* pnmlv)
{
    // Release our component object stored as the lParam of the list view
    // item.
    //
    INetCfgComponent* pComponent;
    pComponent = PComponentFromItemIndex (pInfo->hwndLvComponents,
                        pnmlv->iItem);
    ReleaseObj (pComponent);
}


//----------------------------------------------------------------------------
// Networking property page PPP Settings dialog
//----------------------------------------------------------------------------

INT_PTR CALLBACK
PpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    PEINFO*  pInfo;
    PBENTRY* pEntry;

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            pInfo = (PEINFO*)lparam;
            ASSERT (pInfo);

            pEntry = pInfo->pArgs->pEntry;

            CheckDlgButton (hwnd, CID_NE_EnableLcp,
                (pEntry->fLcpExtensions)
                    ? BST_CHECKED : BST_UNCHECKED);

            CheckDlgButton (hwnd, CID_NE_EnableCompression,
                (pEntry->fSwCompression)
                    ? BST_CHECKED : BST_UNCHECKED);

            //Cut Negotiate multi-link for whistler bug 385842
            //
            CheckDlgButton (hwnd, CID_NE_NegotiateMultilinkAlways,
                (pEntry->fNegotiateMultilinkAlways)
                    ? BST_CHECKED : BST_UNCHECKED);

            SetWindowLongPtr (hwnd, DWLP_USER, (ULONG_PTR )lparam);

            // Center dialog on the owner window.
            //
            CenterWindow(hwnd, GetParent(hwnd));

            // Add context help button to title bar.
            //
            AddContextHelpButton(hwnd);

            return TRUE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwPpHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            if ((IDOK == LOWORD(wparam)) &&
                (BN_CLICKED == HIWORD(wparam)))
            {
                pInfo = (PEINFO*)GetWindowLongPtr (hwnd, DWLP_USER);
                ASSERT (pInfo);

                pEntry = pInfo->pArgs->pEntry;

                pEntry->fLcpExtensions = (BST_CHECKED ==
                            IsDlgButtonChecked (hwnd, CID_NE_EnableLcp));

                pEntry->fSwCompression = (BST_CHECKED ==
                            IsDlgButtonChecked (hwnd, CID_NE_EnableCompression));

               //Cut Negotiate multi-link for whistler bug 385842
               //
               pEntry->fNegotiateMultilinkAlways = (BST_CHECKED ==
                            IsDlgButtonChecked (hwnd, CID_NE_NegotiateMultilinkAlways));
                
		/*
                pEntry->fNegotiateMultilinkAlways = FALSE;
		*/
                EndDialog (hwnd, TRUE);
                return TRUE;
            }

            else if ((IDCANCEL == LOWORD(wparam)) &&
                     (BN_CLICKED == HIWORD(wparam)))
            {
                EndDialog (hwnd, FALSE);
                return TRUE;
            }
            break;
        }
    }
    return FALSE;
}


INT_PTR CALLBACK
SaUnavailDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Shared Access Unavailable page of the Entry property
    // sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
#if 0
    TRACE4( "SaUnavailDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            LPWSTR pszError;
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            pszError = PszFromId(g_hinstDll, pInfo->pArgs->hShowHNetPagesResult == HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED) ? SID_SA_NoWMIError : SID_SA_StoreError);
            if(NULL != pszError)
            {
                SetDlgItemText(hwnd, CID_SA_ST_ErrorText, pszError);
                Free(pszError);
            }
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
//            ContextHelp( g_adwSaHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

    }

    return FALSE;
}
//----------------------------------------------------------------------------
// Routing property page (PLACEHOLDER only)
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
RdDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Routing page of the Entry property sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    return FALSE;
}


/*----------------------------------------------------------------------------
** (Router) Callback dialog
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/


BOOL
RouterCallbackDlg(
    IN     HWND   hwndOwner,
    IN OUT EINFO* pEinfo )

    /* Pops-up the (Router) Callback dialog.  Initial settings are read from
    ** the working entry (no/yes choice) and router user preferences (number
    ** list) in common entry context 'pEinfo' and the result of user's edits
    ** written there on "OK" exit.  'HwndOwner' is the window owning the
    ** dialog.
    **
    ** Returns true if user pressed OK and succeeded, false if he pressed
    ** Cancel or encountered an error.
    */
{
    INT_PTR nStatus;

    TRACE("RouterCallbackDlg");

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CR_CallbackRouter ),
            hwndOwner,
            CrDlgProc,
            (LPARAM )pEinfo );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
CrDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the (Router) Callback dialog.  Parameters and
    ** return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("CrDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, CbutilLvNumbersCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return CrInit( hwnd, (EINFO* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwCrHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case NM_DBLCLK:
                {
                    CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                    ASSERT(pInfo);
                    SendMessage( pInfo->hwndPbEdit, BM_CLICK, 0, 0 );
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                    ASSERT(pInfo);
                    CrUpdateLvAndPbState( pInfo );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return CrCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            CrTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
CrCommand(
    IN CRINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("CrCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_CR_RB_No:
        case CID_CR_RB_Yes:
        {
            if (wNotification == BN_CLICKED)
            {
                CrUpdateLvAndPbState( pInfo );

                if (wId == CID_CR_RB_Yes
                    && ListView_GetSelectedCount( pInfo->hwndLvNumbers ) == 0)
                {
                    /* Nothing's selected, so select the first item, if any.
                    */
                    ListView_SetItemState( pInfo->hwndLvNumbers, 0,
                        LVIS_SELECTED, LVIS_SELECTED );
                }
            }
            break;
        }

        case CID_CR_PB_Edit:
        {
            if (wNotification == BN_CLICKED)
                CbutilEdit( pInfo->hwndDlg, pInfo->hwndLvNumbers );
            break;
        }

        case CID_CR_PB_Delete:
        {
            if (wNotification == BN_CLICKED)
                CbutilDelete( pInfo->hwndDlg, pInfo->hwndLvNumbers );
            break;
        }

        case IDOK:
        {
            TRACE("OK pressed");
            CrSave( pInfo );
            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE("Cancel pressed");
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CrInit(
    IN HWND   hwndDlg,
    IN EINFO* pArgs )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the phonebook
    ** dialog window.  'pArgs' is caller's argument to the stub API.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    CRINFO* pInfo;

    TRACE("CrInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE("Context set");
    }

    /* Initialize page-specific context information.
    */
    pInfo->hwndRbNo = GetDlgItem( hwndDlg, CID_CR_RB_No );
    ASSERT(pInfo->hwndRbNo);
    pInfo->hwndRbYes = GetDlgItem( hwndDlg, CID_CR_RB_Yes );
    ASSERT(pInfo->hwndRbYes);
    pInfo->hwndLvNumbers = GetDlgItem( hwndDlg, CID_CR_LV_Numbers );
    ASSERT(pInfo->hwndLvNumbers);
    pInfo->hwndPbEdit = GetDlgItem( hwndDlg, CID_CR_PB_Edit );
    ASSERT(pInfo->hwndPbEdit);
    pInfo->hwndPbDelete = GetDlgItem( hwndDlg, CID_CR_PB_Delete );
    ASSERT(pInfo->hwndPbDelete);

    /* Initialize the listview.
    */
    CbutilFillLvNumbers(
        pInfo->hwndDlg, pInfo->hwndLvNumbers,
        pArgs->pUser->pdtllistCallback, pArgs->fRouter );

    /* Set the radio button selection, which triggers appropriate
    ** enabling/disabling.
    */
    {
        HWND  hwndRb;

        if (pArgs->pEntry->dwCallbackMode == CBM_No)
            hwndRb = pInfo->hwndRbNo;
        else
        {
            ASSERT(pArgs->pEntry->dwCallbackMode==CBM_Yes);
            hwndRb = pInfo->hwndRbYes;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    /* Center dialog on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
CrSave(
    IN CRINFO* pInfo )

    /* Saves dialog settings in the entry.  'PInfo' is the dialog context.
    */
{
    PBENTRY* pEntry;

    TRACE("CrSave");

    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    if (IsDlgButtonChecked( pInfo->hwndDlg, CID_CR_RB_No ))
        pEntry->dwCallbackMode = CBM_No;
    else
        pEntry->dwCallbackMode = CBM_Yes;

    pEntry->dwfOverridePref |= RASOR_CallbackMode;
    pEntry->fDirty = TRUE;
    pInfo->pArgs->pUser->fDirty = TRUE;

    CbutilSaveLv(
        pInfo->hwndLvNumbers, pInfo->pArgs->pUser->pdtllistCallback );
}


VOID
CrTerm(
    IN HWND hwndDlg )

    /* Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    */
{
    CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE("CrTerm");

    // pmay: 213060
    //
    // Cleanup the numbers
    //
    if ( pInfo->hwndLvNumbers )
    {
        CbutilLvNumbersCleanup( pInfo->hwndLvNumbers );
    }

    if (pInfo)
    {
        Free( pInfo );
    }
}


VOID
CrUpdateLvAndPbState(
    IN CRINFO* pInfo )

    /* Enables/disables the list view and associated buttons.  ListView is
    ** gray unless auto-callback is selected.  Buttons gray unless
    ** auto-callback selected and there is an item selected.
    */
{
    BOOL fEnableList;
    BOOL fEnableButton;

    fEnableList = Button_GetCheck( pInfo->hwndRbYes );
    if (fEnableList)
    {
        fEnableButton =
            ListView_GetSelectedCount( pInfo->hwndLvNumbers );
    }
    else
        fEnableButton = FALSE;

    EnableWindow( pInfo->hwndLvNumbers, fEnableList );
    EnableWindow( pInfo->hwndPbEdit, fEnableButton );
    EnableWindow( pInfo->hwndPbDelete, fEnableButton );
}

INT_PTR CALLBACK
SaDisableFirewallWarningDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    switch(unMsg)
    {
        case WM_COMMAND:
        {
            switch(LOWORD(wparam))
            {
            case IDYES:
            case IDNO:
                if(BST_CHECKED == IsDlgButtonChecked(hwnd, CID_SA_PB_DisableFirewallWarning))
                {
                    HKEY hFirewallKey;
                    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, g_pszFirewallRegKey, 0, NULL, 0, KEY_SET_VALUE, NULL, &hFirewallKey, NULL))
                    {
                        DWORD dwValue = TRUE;
                        RegSetValueEx(hFirewallKey, g_pszDisableFirewallWarningValue, 0, REG_DWORD, (CONST BYTE*)&dwValue, sizeof(dwValue));
                        RegCloseKey(hFirewallKey);
                    }
                }

                // fallthru
            case IDCANCEL:
                EndDialog(hwnd, LOWORD(wparam));
                break;

            }
            break;
        }
    }

    return FALSE;
}


BOOL SaIsAdapterDHCPEnabled(IHNetConnection* pConnection)
{
    HRESULT hr;
    BOOL fDHCP = FALSE;
    GUID* pAdapterGuid;
    hr = IHNetConnection_GetGuid(pConnection, &pAdapterGuid);
    if(SUCCEEDED(hr))
    {
        LPOLESTR pAdapterName;
        hr = StringFromCLSID(pAdapterGuid, &pAdapterName);
        if(SUCCEEDED(hr))
        {
            SIZE_T Length = wcslen(pAdapterName);
            LPSTR pszAnsiAdapterName = Malloc(Length + 1);
            if(NULL != pszAnsiAdapterName)
            {
                if(0 != WideCharToMultiByte(CP_ACP, 0, pAdapterName, (int)(Length + 1), pszAnsiAdapterName, (int)(Length + 1), NULL, NULL))
                {
                    HMODULE hIpHelper;
                    hIpHelper = LoadLibrary(L"iphlpapi");
                    if(NULL != hIpHelper)
                    {
                        DWORD (WINAPI *pGetAdaptersInfo)(PIP_ADAPTER_INFO, PULONG);
                        
                        pGetAdaptersInfo = (DWORD (WINAPI*)(PIP_ADAPTER_INFO, PULONG)) GetProcAddress(hIpHelper, "GetAdaptersInfo");
                        if(NULL != pGetAdaptersInfo)
                        {
                            ULONG ulSize = 0;
                            if(ERROR_BUFFER_OVERFLOW == pGetAdaptersInfo(NULL, &ulSize))
                            {
                                PIP_ADAPTER_INFO pInfo = Malloc(ulSize);
                                if(NULL != pInfo)
                                {
                                    if(ERROR_SUCCESS == pGetAdaptersInfo(pInfo, &ulSize))
                                    {
                                        PIP_ADAPTER_INFO pAdapterInfo = pInfo;
                                        do
                                        {
                                            if(0 == lstrcmpA(pszAnsiAdapterName, pAdapterInfo->AdapterName))
                                            {
                                                fDHCP = !!pAdapterInfo->DhcpEnabled;
                                                break;
                                            }
                                            
                                        } while(NULL != (pAdapterInfo = pAdapterInfo->Next));
                                    }
                                    Free(pInfo);
                                }
                            }
                        }
                        FreeLibrary(hIpHelper);
                    }
                }
                Free(pszAnsiAdapterName);
            }
            CoTaskMemFree(pAdapterName);
        }
        CoTaskMemFree(pAdapterGuid);
    }

    return fDHCP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\entry.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// entry.c
// Remote Access Common Dialog APIs
// {Ras,Router}PhonebookEntryDlg APIs and general entry utilities
//
// 06/20/95 Steve Cobb
//
// Eu, Cu, and Su utilities sets:
//
// This file contains 3 sets of high-level phone book entry UI utilities
// shared by the phonebook entry property sheet and the add entry wizard.  The
// highest level set of "Eu" utilities is based on the EINFO block and is
// specific to the entry property sheet and add entry wizards.  The other two
// utilities may be used by other dialogs without an EINFO context.  The "Cu"
// utility set based on the CUINFO block encapsulates all complex phone number
// logic.  The "Su" utility set, based on the SUINFO block, encapsulates
// scripting logic.


#include "rasdlgp.h"
#include <serial.h>   // for SERIAL_TXT
#include <mprapi.h>   // for MprAdmin API declarations
#include <lmaccess.h> // for NetUserAdd declarations
#include <lmerr.h>    // for NERR_* declarations.  pmay bug 232983
#include <rasapip.h>
#include <mprerror.h>
//#include <tapi.h>



// Target machine for RouterEntryDlg{A,W} in "\\server" form.  See
// "limitation" comment in RouterEntryDlgW.
//
static WCHAR g_wszServer[ MAX_COMPUTERNAME_LENGTH + 3] = L"";

//-----------------------------------------------------------------------------
// Local structures
//-----------------------------------------------------------------------------
typedef struct _FREE_COM_PORTS_DATA {
    DTLLIST* pListPortsInUse;       // Ports currently in use
    DTLLIST* pListFreePorts;        // Ports currently free
    DWORD dwCount;                  // Count of com ports
} FREE_COM_PORTS_DATA;

typedef struct _COM_PORT_INFO {
    PWCHAR pszFriendlyName;
    PWCHAR pszPort;
} COM_PORT_INFO;

//-----------------------------------------------------------------------------
// Local prototypes
//-----------------------------------------------------------------------------

// 
// Prototype of the RouterEntryDlg func
//
typedef
BOOL 
(APIENTRY * ROUTER_ENTRY_DLG_FUNC) (
    IN     LPWSTR         lpszServer,
    IN     LPWSTR         lpszPhonebook,
    IN     LPWSTR         lpszEntry,
    IN OUT LPRASENTRYDLGW lpInfo );

VOID
AppendDisabledPorts(
    IN EINFO* pInfo,
    IN DWORD dwType );

BOOL
BuildFreeComPortList(
    IN PWCHAR pszPort,
    IN HANDLE hData);

//-----------------------------------------------------------------------------
// External entry points
//-----------------------------------------------------------------------------

DWORD
GetRasDialOutProtocols()

    // This is called by WinLogon to determine if RAS is installed.
    //
    // !!! RaoS is working on cleaning this up, i.e. making it a "real" RAS
    //     API or removing the need for it.
    //
{
#if 1
    return g_pGetInstalledProtocolsEx( NULL, FALSE, TRUE, FALSE );
#else
    return NP_Ip;
#endif
}

BOOL APIENTRY
RasEntryDlgA(
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry,
    IN OUT LPRASENTRYDLGA lpInfo )

    // Win32 ANSI entrypoint that displays the modal Phonebook Entry property
    // sheet.  'LpszPhonebook' is the full path to the phonebook file or NULL
    // to use the default phonebook.  'LpszEntry' is the entry to edit or the
    // default name of the new entry.  'LpInfo' is caller's additional
    // input/output parameters.
    //
    // Returns true if user presses OK and succeeds, false on error or Cancel.
    //
{
    WCHAR* pszPhonebookW;
    WCHAR* pszEntryW;
    RASENTRYDLGW infoW;
    BOOL fStatus;

    TRACE( "RasEntryDlgA" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASENTRYDLGA))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    // Thunk "A" arguments to "W" arguments.
    //
    if (lpszPhonebook)
    {
        pszPhonebookW = StrDupTFromA( lpszPhonebook );
        if (!pszPhonebookW)
        {
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
        pszPhonebookW = NULL;

    if (lpszEntry)
    {
        pszEntryW = StrDupTFromA( lpszEntry );
        if (!pszEntryW)
        {
            Free0( pszPhonebookW );
            {
                lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
                return FALSE;
            }
        }
    }
    else
        pszEntryW = NULL;

    ZeroMemory( &infoW, sizeof(infoW) );
    infoW.dwSize = sizeof(infoW);
    infoW.hwndOwner = lpInfo->hwndOwner;
    infoW.dwFlags = lpInfo->dwFlags;
    infoW.xDlg = lpInfo->xDlg;
    infoW.yDlg = lpInfo->yDlg;
    infoW.reserved = lpInfo->reserved;
    infoW.reserved2 = lpInfo->reserved2;

    // Thunk to the equivalent "W" API.
    //
    fStatus = RasEntryDlgW( pszPhonebookW, pszEntryW, &infoW );

    Free0( pszPhonebookW );
    Free0( pszEntryW );

    // Thunk "W" results to "A" results.
    //
    StrCpyAFromW(lpInfo->szEntry, infoW.szEntry, sizeof(lpInfo->szEntry));
    lpInfo->dwError = infoW.dwError;

    return fStatus;
}


BOOL APIENTRY
RasEntryDlgW(
    IN LPWSTR lpszPhonebook,
    IN LPWSTR lpszEntry,
    IN OUT LPRASENTRYDLGW lpInfo )

    // Win32 Unicode entrypoint that displays the modal Phonebook Entry
    // property sheet.  'LpszPhonebook' is the full path to the phonebook file
    // or NULL to use the default phonebook.  'LpszEntry' is the entry to edit
    // or the default name of the new entry.  'LpInfo' is caller's additional
    // input/output parameters.
    //
    // Returns true if user presses OK and succeeds, false on error or Cancel.
    //
{
    DWORD dwErr;
    EINFO* pEinfo;
    BOOL fStatus;
    HWND hwndOwner;
    DWORD dwOp;
    BOOL fRouter;
    BOOL fShellOwned;

    TRACE( "RasEntryDlgW" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASENTRYDLGW))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    // The "ShellOwned" mode is required for Connections.  In this mode, the
    // API returns before the sheet is dismissed, does not fill in outputs,
    // and the wizard and property sheets are responsible for calling EuCommit
    // (if necessary) and then EuFree.  Otherwise, EuCommit/EuFree are called
    // below.
    //
    fShellOwned = lpInfo->dwFlags & RASEDFLAG_ShellOwned;

    if (fShellOwned)
    {
        RASEDSHELLOWNEDR2* pShellOwnedInfo;

        pShellOwnedInfo = (RASEDSHELLOWNEDR2*)lpInfo->reserved2;
        if (!pShellOwnedInfo ||
            IsBadWritePtr (&pShellOwnedInfo->pvWizardCtx,
                           sizeof(pShellOwnedInfo->pvWizardCtx)))
        {
            lpInfo->dwError = ERROR_INVALID_PARAMETER;
            return FALSE;
        }
    }

    // Eliminate some invalid flag combinations up front.
    //
    if (lpInfo->dwFlags & RASEDFLAG_CloneEntry)
    {
        lpInfo->dwFlags &= ~(RASEDFLAG_AnyNewEntry | RASEDFLAG_NoRename);
    }

    // fRouter = RasRpcDllLoaded();
    if(lpInfo->reserved)
    {
        fRouter = IsRasRemoteConnection(((INTERNALARGS *)lpInfo->reserved)->hConnection);
    }
    else
    {
        fRouter = FALSE;
    }

    if (!fRouter)
    {
        // DwCustomEntryDlg returns ERROR_SUCCESS if it handled
        // the CustomEntryDlg. returns E_NOINTERFACE otherwise
        // which implies that there is no custom dlg interface
        // supported for this entry and the default Entrydlg
        // should be displayed
        //
        dwErr = DwCustomEntryDlg(
                        lpszPhonebook,
                        lpszEntry,
                        lpInfo,
                        &fStatus);

        if(ERROR_SUCCESS == dwErr)
        {
            return fStatus;
        }

        // Load RAS DLL entrypoints which starts RASMAN, if necessary.  The
        // entrypoints are already loaded in the router case.  The limitations
        // this creates are discussed in RasEntryDlgW.
        //
        dwErr = LoadRas( g_hinstDll, lpInfo->hwndOwner );
        if (dwErr != 0)
        {
            if (!fShellOwned)
            {
                ErrorDlg( lpInfo->hwndOwner, SID_OP_LoadRas, dwErr, NULL );
            }
            lpInfo->dwError = dwErr;
            return FALSE;
        }

        {
            // Commented it out For whistler bug 445424      gangz
            // We move the Tapi first area Dialog to dialing rules check
            // box
            /*
            HLINEAPP hlineapp;

            // Popup TAPI's "first location" dialog if they are uninitialized.
            // An error here is treated as a "cancel" per bug 288385.  This
            // ridiculous exercise is necessary due to TAPI's inability to (a)
            // provide a default location or (b) create a location
            // programatically.
            //
            hlineapp = (HLINEAPP )0;
            if (TapiNoLocationDlg(
                    g_hinstDll, &hlineapp, lpInfo->hwndOwner ) == 0)
            {
                TapiShutdown( hlineapp );
            }
            else
            {
                lpInfo->dwError = 0;
                return FALSE;
            }
            */
#if 0
            RAS_DEVICE_INFO *pDeviceInfo = NULL;
            DWORD dwVersion = RAS_VERSION, 
                   dwEntries = 0, 
                   dwcb = 0,  i;

            dwErr = RasGetDeviceConfigInfo(NULL, &dwVersion,
                                        &dwEntries, &dwcb,
                                        NULL);

            if(dwErr == ERROR_BUFFER_TOO_SMALL)
            {
                pDeviceInfo = LocalAlloc(LPTR,
                                      dwcb);
                if(NULL == pDeviceInfo)
                {
                    lpInfo->dwError = GetLastError();
                    return FALSE;
                }
                dwErr = RasGetDeviceConfigInfo(NULL,
                                            &dwVersion,
                                            &dwEntries,
                                            &dwcb,
                                            (PBYTE) pDeviceInfo);

                //
                // Check to see if there is a modem device
                //
                for(i = 0; i < dwEntries; i++)
                {
                    if(RAS_DEVICE_TYPE(pDeviceInfo[i].eDeviceType)
                        == RDT_Modem)
                    {
                        break;
                    }
                }
                
                LocalFree(pDeviceInfo);

                if(i < dwEntries)
                {
                    // Popup TAPI's "first location" dialog if they are uninitialized.
                    // An error here is treated as a "cancel" per bug 288385.  This
                    // ridiculous exercise is necessary due to TAPI's inability to (a)
                    // provide a default location or (b) create a location
                    // programatically.
                    //
                    hlineapp = (HLINEAPP )0;
                    if (TapiNoLocationDlg(
                            g_hinstDll, &hlineapp, lpInfo->hwndOwner ) == 0)
                    {
                        TapiShutdown( hlineapp );
                    }
                    else
                    {
                        lpInfo->dwError = 0;
                        return FALSE;
                    }
                }
            }
#endif        
        }
    }

    // Initialize the entry common context block.
    //
    dwErr = EuInit( lpszPhonebook, lpszEntry, lpInfo, fRouter, &pEinfo, &dwOp );
    if (dwErr == 0)
    {
        BOOL fShowWizard = FALSE;

        if (lpInfo->dwFlags & RASEDFLAG_AnyNewEntry)
        {
            fShowWizard = (pEinfo->pUser->fNewEntryWizard || fShellOwned);
        }
        else if (lpInfo->dwFlags & RASEDFLAG_CloneEntry)
        {
            // Need the wizard to gather the cloned entry's name.
            fShowWizard = TRUE;
        }

        if (fShowWizard)
        {
            if (pEinfo->fRouter)
            {
#if 1
                AiWizard( pEinfo );
#else
                pEinfo->fChainPropertySheet = TRUE;
#endif
            }
            else
            {
                AeWizard( pEinfo );
            }

            if (pEinfo->fChainPropertySheet && lpInfo->dwError == 0)
            {
                PePropertySheet( pEinfo );
            }
        }
        else
        {
            PePropertySheet( pEinfo );
        }
    }
    else
    {
        ErrorDlg( lpInfo->hwndOwner, dwOp, dwErr, NULL );
        lpInfo->dwError = dwErr;
    }

    // Clean up here, but only in non-Shell-owned mode.
    //
    if (fShellOwned)
    {
        fStatus = TRUE;
    }
    else 
    {
        if( NULL != pEinfo)
        {
            fStatus = (pEinfo->fCommit && EuCommit( pEinfo ));
            EuFree( pEinfo );
        }
        else
        {
            fStatus = FALSE;
         }
    }

    return fStatus;
}

//
// Raises the NT4 ui.
//
BOOL  
RouterEntryDlgNt4W(
    IN LPWSTR lpszServer,
    IN LPWSTR lpszPhonebook,
    IN LPWSTR lpszEntry,
    IN OUT LPRASENTRYDLGW lpInfo )
{
    HMODULE hLib = NULL;
    ROUTER_ENTRY_DLG_FUNC pFunc = NULL;
    BOOL bOk = FALSE;

    do
    {
        // Load the library
        hLib = LoadLibraryA("rasdlg4.dll");
        if (hLib == NULL)
        {
            lpInfo->dwError = GetLastError();
            break;
        }

        // Get the func pointer
        pFunc = (ROUTER_ENTRY_DLG_FUNC) 
            GetProcAddress(hLib, "RouterEntryDlgW");
        if (pFunc == NULL)
        {
            lpInfo->dwError = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Call the function
        //
        bOk = pFunc(lpszServer, lpszPhonebook, lpszEntry, lpInfo);

    } while (FALSE);        
    
    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return bOk;
}

BOOL APIENTRY
RouterEntryDlgA(
    IN LPSTR lpszServer,
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry,
    IN OUT LPRASENTRYDLGA lpInfo )

    // Router-specific version of RasEntryDlgA.  'LpszServer' is the name of
    // the target server in "\\server" form or NULL for the local machine.
    // Other arguments are as for RasEntryDlgA.  See "limitation" comment in
    // RouterEntryDlgW.
    //
{
    BOOL fSuccess;
    DWORD dwErr;
    HANDLE hConnection = NULL;
    BOOL fAllocatedIArgs = FALSE;
    WCHAR wszServer[ MAX_COMPUTERNAME_LENGTH + 3];
    VOID * pSRouteList = NULL;

    TRACE( "RouterEntryDlgA" );

    // Load RAS entrypoints or set up RPC to them, if remote server.
    //
    if (lpszServer)
    {
        StrCpyWFromAUsingAnsiEncoding(
            wszServer, 
            lpszServer, 
            MAX_COMPUTERNAME_LENGTH+3);
    }
    else
    {
        wszServer[ 0 ] = L'\0';
    }

    // Load RAS entrypoints or set up RPC to them, if remote server.
    //
    dwErr = InitializeConnection(wszServer, &hConnection);
    if(dwErr)
    {
        lpInfo->dwError = dwErr;
        return FALSE;
    }

    // Use the reserved parameter to pass the handle to the api - allocate
    // this parameter if not already present - very sleazy - (RaoS)
    //
    if (NULL == (INTERNALARGS *)lpInfo->reserved)
    {
        INTERNALARGS *pIArgs = Malloc(sizeof(INTERNALARGS));

        if(NULL == pIArgs)
        {
            lpInfo->dwError = GetLastError();
            return FALSE;
        }

        ZeroMemory(pIArgs, sizeof(INTERNALARGS));

        pIArgs->fInvalid = TRUE;
        lpInfo->reserved = (ULONG_PTR )pIArgs;
        fAllocatedIArgs = TRUE;
    }

    ((INTERNALARGS *)lpInfo->reserved)->hConnection = hConnection;

    // Load MPR entrypoints.
    //
    dwErr = LoadMpradminDll();
    if (dwErr)
    {
        dwErr = UnloadRasRpcDll();
        lpInfo->dwError = dwErr;
        return FALSE;
    }

    // Call the normal dial-out UI.
    //
    fSuccess = RasEntryDlgA( lpszPhonebook, lpszEntry, lpInfo );

    // Unload DLLs.
    //
    UnloadMpradminDll();
    UninitializeConnection(hConnection);
    ((INTERNALARGS *)lpInfo->reserved)->hConnection = NULL;

    pSRouteList = ((INTERNALARGS *)lpInfo->reserved)->pvSRouteInfo;

    if(fAllocatedIArgs)
    {
        Free((PVOID)lpInfo->reserved);
        (PVOID)lpInfo->reserved = NULL;
    }
    lpInfo->reserved = (ULONG_PTR)pSRouteList;
    return fSuccess;
}


BOOL APIENTRY
RouterEntryDlgW(
    IN LPWSTR lpszServer,
    IN LPWSTR lpszPhonebook,
    IN LPWSTR lpszEntry,
    IN OUT LPRASENTRYDLGW lpInfo )

    // Router-specific version of RasEntryDlgA.  'LpszServer' is the name of
    // the target server in "\\server" form or NULL for the local machine.
    // Other arguments are as for RasEntryDlgW.
    //
    // LIMITATION: As implemented with the 'g_wszServer' global and global RPC
    //     entrypoints, the following single process limitations apply to this
    //     (currently undocumented) API.  First, it cannot be called
    //     simultaneously for two different servers.  Second, it cannot be
    //     called simultaneously with RasEntryDlg.
{
    BOOL fSuccess;
    DWORD dwErr, dwVersion;
    HANDLE hConnection = NULL;
    BOOL fAllocatedIArgs = FALSE;
    WCHAR wszServer[ MAX_COMPUTERNAME_LENGTH + 3];
    VOID * pSRouteList = NULL;


    TRACE( "RouterEntryDlgW" );
    TRACEW1( "  s=%s", (lpszServer) ? lpszServer : TEXT("") );
    TRACEW1( "  p=%s", (lpszPhonebook) ? lpszPhonebook : TEXT("") );
    TRACEW1( "  e=%s", (lpszEntry) ? lpszEntry : TEXT("") );

    if (lpszServer)
    {
        lstrcpynW( wszServer, lpszServer, sizeof(wszServer) / sizeof(WCHAR) );
    }
    else
    {
        wszServer[0] = L'\0';
    }

    // Load RAS entrypoints or set up RPC to them, if remote server.
    //
    dwErr = InitializeConnection(lpszServer, &hConnection);
    if(dwErr)
    {
        lpInfo->dwError = dwErr;
        return FALSE;
    }

    // If this is a downlevel machine, use the downlevel
    // UI
    //
    if (IsRasRemoteConnection(hConnection))
    {
        dwVersion = RemoteGetServerVersion(hConnection);
        if (dwVersion == VERSION_40)
        {
            UninitializeConnection(hConnection);                                            
            
            // for 523414   gangz
            // We remove remotely managing downlevel NT4 machine
            //
            dwErr = ERROR_NOT_SUPPORTED;

            /*
            dwErr = RouterEntryDlgNt4W(
                        lpszServer,
                        lpszPhonebook,
                        lpszEntry,
                        lpInfo );
            */
                        
            return dwErr;
        }
    }

    //
    // Use the reserved parameter to pass the handle to the
    // api - allocate this parameter if not already present
    //  - very sleazy -
    //
    if(NULL == (INTERNALARGS *) lpInfo->reserved)
    {
        INTERNALARGS *pIArgs = Malloc(sizeof(INTERNALARGS));

        if(NULL == pIArgs)
        {
            lpInfo->dwError = GetLastError();
            return FALSE;
        }

        ZeroMemory(pIArgs, sizeof(INTERNALARGS));
        pIArgs->fInvalid = TRUE;
        lpInfo->reserved = (ULONG_PTR ) pIArgs;
        fAllocatedIArgs = TRUE;
    }

    ((INTERNALARGS *)lpInfo->reserved)->hConnection = hConnection;


    // Load MPR entrypoints.
    //
    dwErr = LoadMpradminDll();
    if (dwErr)
    {
        dwErr = UnloadRasRpcDll();
        lpInfo->dwError = dwErr;
        return FALSE;
    }

    // Call the normal dial-out UI.
    //
    fSuccess = RasEntryDlgW( lpszPhonebook, lpszEntry, lpInfo );

    // Unload DLLs.
    //
    UnloadMpradminDll();
    UninitializeConnection(hConnection);
    ((INTERNALARGS *)lpInfo->reserved)->hConnection = NULL;
    pSRouteList = ((INTERNALARGS *)lpInfo->reserved)->pvSRouteInfo;
    if(fAllocatedIArgs)
    {
        Free((PVOID) lpInfo->reserved);
        (PVOID)lpInfo->reserved = 0;
    }
    lpInfo->reserved = (ULONG_PTR) pSRouteList;
    return fSuccess;
}


//----------------------------------------------------------------------------
// Phonebook Entry common routines (Eu utilities)
// Listed alphabetically
//----------------------------------------------------------------------------

VOID
AppendDisabledPorts(
    IN EINFO* pInfo,
    IN DWORD dwType )

    // Utility to append links containing all remaining configured ports of
    // RASET_* type 'dwType' to the list of links with the new links marked
    // "unenabled".  If 'dwType' is -1 all configured ports are appended.
    //
{
    DTLNODE* pNodeP;
    DTLNODE* pNodeL;

    for (pNodeP = DtlGetFirstNode( pInfo->pListPorts );
         pNodeP;
         pNodeP = DtlGetNextNode( pNodeP ))
    {
        PBPORT* pPort;
        BOOL fSkipPort;
        DTLNODE* pNode;

        pPort = (PBPORT* )DtlGetData( pNodeP );
        fSkipPort = FALSE;

        if (dwType != RASET_P_AllTypes)
        {
            // pmay: 233287
            //
            // The port should not be included if:
            //   1. The mode is non-tunnel and the port is vpn type
            //   2. The mode is normal and the port type mismatches
            //
            if (dwType == RASET_P_NonVpnTypes)
            {
                if (pPort->dwType == RASET_Vpn)
                {
                    continue;
                }
            }
            else
            {
                if (pPort->dwType != dwType)
                {
                    continue;
                }
            }
        }

        for (pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
             pNodeL;
             pNodeL = DtlGetNextNode( pNodeL ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNodeL );

            ASSERT( pPort->pszPort );
            ASSERT( pLink->pbport.pszPort );

            if (lstrcmp( pLink->pbport.pszPort, pPort->pszPort ) == 0
                && lstrcmp( pLink->pbport.pszDevice, pPort->pszDevice ) == 0)
            {
                // The port already appears in a link in the list.
                //
                fSkipPort = TRUE;
                break;
            }
        }

        if (fSkipPort)
        {
            continue;
        }

        pNode = CreateLinkNode();
        if (pNode)
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );

            if (CopyToPbport( &pLink->pbport, pPort ) != 0)
            {
                DestroyLinkNode( pNode );
            }
            else
            {
                if ((pPort->pbdevicetype == PBDT_Modem) ||
                    (pPort->dwFlags & PBP_F_NullModem)
                   )
                {
                    SetDefaultModemSettings( pLink );
                }

                pLink->fEnabled = FALSE;
                DtlAddNodeLast( pInfo->pEntry->pdtllistLinks, pNode );
            }
        }
    }

    // Set "multiple devices" flag if there is more than one device of this
    // type for convenient reference elsewhere.
    //
    pInfo->fMultipleDevices =
        (DtlGetNodes( pInfo->pEntry->pdtllistLinks ) > 1);
}

BOOL
BuildFreeComPortList(
    IN PWCHAR pszPort,
    IN HANDLE hData)

    // Com port enumeration function that generates a list of
    // free com ports.  Returns TRUE to stop enumeration (see
    // MdmEnumComPorts)
{
    FREE_COM_PORTS_DATA* pfcpData = (FREE_COM_PORTS_DATA*)hData;
    DTLLIST* pListUsed = pfcpData->pListPortsInUse;
    DTLLIST* pListFree = pfcpData->pListFreePorts;
    DTLNODE* pNodeP, *pNodeL, *pNode;

    // If the given port is in the used list, then return
    // so that it is not added to the list of free ports and
    // so that enumeration continues.
    for (pNodeL = DtlGetFirstNode( pListUsed );
         pNodeL;
         pNodeL = DtlGetNextNode( pNodeL ))
    {
        PBLINK* pLink = (PBLINK* )DtlGetData( pNodeL );
        ASSERT( pLink->pbport.pszPort );

        // The port already appears in a link in the list.
        if (lstrcmp( pLink->pbport.pszPort, pszPort ) == 0)
            return FALSE;
    }

    // The port is not in use.  Add it to the free list.
    pNode = DtlCreateSizedNode( sizeof(COM_PORT_INFO), 0L );
    if (pNode)
    {
        COM_PORT_INFO* pComInfo;
        TCHAR* pszFriendlyName;

        pszFriendlyName = PszFromId(g_hinstDll, SID_FriendlyComPort);
        pComInfo = (COM_PORT_INFO* )DtlGetData( pNode );
        pComInfo->pszFriendlyName = pszFriendlyName;
        pComInfo->pszPort = StrDup(pszPort);
        DtlAddNodeLast( pListFree, pNode );
        pfcpData->dwCount += 1;
    }

    return FALSE;
}

DWORD
EuMergeAvailableComPorts(
    IN  EINFO* pInfo,
    OUT DTLNODE** ppNodeP,
    IN OUT LPDWORD lpdwCount)

    // Adds all the available com ports in the system
    // as modem devices.
{
    FREE_COM_PORTS_DATA fcpData;
    DTLLIST* pListFreeComPorts = NULL;
    DTLNODE* pNodeL;

    // Initialize the list of com ports
    pListFreeComPorts = DtlCreateList(0L);

    if(NULL == pListFreeComPorts)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    fcpData.pListPortsInUse = pInfo->pListPorts;
    fcpData.pListFreePorts = pListFreeComPorts;
    fcpData.dwCount = 0;

    // Enumerate the com ports
    MdmEnumComPorts (
        BuildFreeComPortList,
        (HANDLE)(&fcpData));

    // Go throught the list of free com ports and create
    // a bogus device for each one.
    for (pNodeL = DtlGetFirstNode( pListFreeComPorts );
         pNodeL;
         pNodeL = DtlGetNextNode( pNodeL ))
    {
        COM_PORT_INFO* pComInfo;
        DTLNODE* pNode;

        // Get the info about the com port
        pComInfo = (COM_PORT_INFO* )DtlGetData( pNodeL );

        // Create a new device for it
        pNode = CreateLinkNode();
        if (pNode)
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            pLink->pbport.pszPort = pComInfo->pszPort;
            pLink->pbport.pszDevice = pComInfo->pszFriendlyName;
            pLink->pbport.pszMedia = StrDup( TEXT(SERIAL_TXT) );
            pLink->pbport.pbdevicetype = PBDT_ComPort;
            pLink->pbport.dwType = RASET_Direct;
            pLink->fEnabled = TRUE;

            // If the first node hasn't been identified yet,
            // assign it to this one.
            //
            // ppNode is assumed to have been added to the 
            // list pInfo->pEntry->pdtllistLinks (#348920)
            //
            if (! (*ppNodeP))
            {
                *ppNodeP = pNode;
            }
            else
            {
                DtlAddNodeLast( pInfo->pEntry->pdtllistLinks, pNode );
            }                
        }
    }

    // Free up the resources held by the list of
    // free com ports
    DtlDestroyList(pListFreeComPorts, NULL);

    // Update the count
    *lpdwCount += fcpData.dwCount;

    return NO_ERROR;
}

DWORD
EuChangeEntryType(
    IN EINFO* pInfo,
    IN DWORD dwType )

    // Changes the work entry node to the default settings for the RASET_*
    // entry type 'dwType', or if -1 to phone defaults with a full list of
    // available links.  'PInfo' is the common entry information block.  As
    // this routine is intended for use only on new entries, information
    // stored in the entries existing list of links, if any, is discarded.
    //
    // Returns 0 if successful or an error code.
    //
{
    DTLNODE* pNode;
    DTLNODE* pNodeP;
    DTLNODE* pNodeL;
    PBLINK* pLink;
    DWORD cDevices, cPorts;

    // Change the default settings of the phonebook entry, i.e. those not
    // specific to the way the UI manipulates the PBLINK list.
    //
    // pmay: 233287. Special types can be considered phone entries.
    //
    if ((dwType == RASET_P_AllTypes) || (dwType == RASET_P_NonVpnTypes))
    {
        ChangeEntryType( pInfo->pEntry, RASET_Phone );
    }
    else
    {
        ChangeEntryType( pInfo->pEntry, dwType );
    }

    // Update the list of PBLINKs to include only links of the appropriate
    // type.  First, delete the old links, if any, and add one default link.
    // This resets the links to the what they are just after CreateEntryNode.
    //
    while (pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks ))
    {
        DtlRemoveNode( pInfo->pEntry->pdtllistLinks, pNodeL );
        DestroyLinkNode( pNodeL );
    }

    pNodeL = CreateLinkNode();
    if (!pNodeL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DtlAddNodeLast( pInfo->pEntry->pdtllistLinks, pNodeL );
    pLink = (PBLINK* )DtlGetData( pNodeL );
    ASSERT( pLink );

    // Count the configured links of the indicated type, noting the first node
    // of the correct type.
    //
    cDevices = 0;
    pNodeP = NULL;
    for (pNode = DtlGetFirstNode( pInfo->pListPorts );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        PBPORT* pPort;

        pPort = (PBPORT* )DtlGetData( pNode );
        if ((dwType == RASET_P_AllTypes)                                     ||
            ((dwType == RASET_P_NonVpnTypes) && (pPort->dwType != RASET_Vpn))||
            (pPort->dwType == dwType)
           )
        {
            ++cDevices;

            if (!pNodeP)
            {
                pNodeP = pNode;
            }
        }
    }

    // If this is a direct connect device, merge in the
    // com ports since they will be available to have
    // null modems installed over them
    if (pInfo->pEntry->dwType == RASET_Direct)
    {
        // pmay: 249346
        //
        // Only merge the com ports if the user is an admin since
        // admin privilege is required to install a null modem.
        //
        if (pInfo->fIsUserAdminOrPowerUser)
        {
            EuMergeAvailableComPorts(pInfo, &pNodeP, &cDevices);
        }            
    }

    if (pNodeP)
    {
        pInfo->fNoPortsConfigured = FALSE;
    }
    else
    {
        TRACE( "No ports configured" );
        pInfo->fNoPortsConfigured = TRUE;
        pNodeP = CreatePortNode();
    }

    if (pNodeP)
    {
        PBPORT* pPort;

        pPort = (PBPORT* )DtlGetData( pNodeP );

        if (cDevices <= 0)
        {
            if (pInfo->pEntry->dwType == RASET_Phone)
            {
                // Make up a bogus COM port with unknown Unimodem
                // attached.  Hereafter, this will behave like an entry
                // whose modem has been de-installed.
                //
                pPort->pszPort = PszFromId( g_hinstDll, SID_DefaultPort );
                pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
                pPort->pbdevicetype = PBDT_Modem;

                // pmay: 233287
                // We need to track bogus devices so that the dd interface
                // wizard can prevent interfaces with these from being
                // created.
                pPort->dwFlags |= PBP_F_BogusDevice;
            }
            else if (pInfo->pEntry->dwType == RASET_Vpn)
            {
                pPort->pszPort = PszFromId( g_hinstDll, SID_DefaultVpnPort );
                pPort->pszMedia = StrDup( TEXT("rastapi") );
                pPort->pbdevicetype = PBDT_Vpn;
            }
            else if (pInfo->pEntry->dwType == RASET_Broadband)
            {
                pPort->pszPort = PszFromId( g_hinstDll, SID_DefaultBbPort );
                pPort->pszMedia = StrDup( TEXT("rastapi") );
                pPort->pbdevicetype = PBDT_PPPoE;
                pPort->dwFlags |= PBP_F_BogusDevice;
            }
            else
            {
                ASSERT( pInfo->pEntry->dwType == RASET_Direct );

                // Make up a bogus COM port with unknown Unimodem
                // attached.  Hereafter, this will behave like an entry
                // whose modem has been de-installed.
                //
                pPort->pszPort = PszFromId( g_hinstDll, SID_DefaultPort );
                pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
                pPort->pbdevicetype = PBDT_Null;

                // pmay: 233287
                // We need to track bogus devices so that the dd interface
                // wizard can prevent interfaces with these from being
                // created.
                pPort->dwFlags |= PBP_F_BogusDevice;
            }

            pPort->fConfigured = FALSE;
        }

        // If a bogus port was created, copy it into the
        // new node
        CopyToPbport( &pLink->pbport, pPort );
        if ((pLink->pbport.pbdevicetype == PBDT_Modem) ||
            (pLink->pbport.dwFlags & PBP_F_NullModem)
           )
        {
            SetDefaultModemSettings( pLink );
        }
    }

    if (pInfo->fNoPortsConfigured)
    {
        if(NULL != pNodeP)
        {
            DestroyPortNode( pNodeP );
        }
    }

    if (!pNodeP || !pLink->pbport.pszPort || !pLink->pbport.pszMedia)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Append all non-configured ports of the entries type to the list of
    // links.  This is for the convenience of the UI.  The non-configured
    // ports are removed after editing prior to saving.
    //
    AppendDisabledPorts( pInfo, dwType );

    return NO_ERROR;
}

BOOL 
EuRouterInterfaceIsNew(
     IN EINFO * pInfo )
{
    if ((pInfo->pApiArgs->dwFlags & RASEDFLAG_AnyNewEntry)
        && pInfo->fRouter
        && pInfo->pUser->fNewEntryWizard
        && !pInfo->fChainPropertySheet)
    {
        return TRUE;
    }

    return FALSE;
} //EuRouterInterfaceIsNew()

BOOL
EuCommit(
    IN EINFO* pInfo )

    // Commits the new or changed entry node to the phonebook file and list.
    // Also adds the area code to the per-user list, if indicated.  'PInfo' is
    // the common entry information block.
    //
    // Returns true if successful, false otherwise.
    //
{
    DWORD dwErr;
    BOOL fEditMode;
    BOOL fChangedNameInEditMode;

    // If shared phone number, copy the phone number information from the
    // shared link to each enabled link.
    //
    if (pInfo->pEntry->fSharedPhoneNumbers)
    {
        DTLNODE* pNode;

        ASSERT( pInfo->pEntry->dwType == RASET_Phone );

        for (pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            if (pLink->fEnabled)
            {
                CopyLinkPhoneNumberInfo( pNode, pInfo->pSharedNode );
            }
        }
    }

    // Delete all disabled link nodes.
    //
    if (pInfo->fMultipleDevices)
    {
        DTLNODE* pNode;

        pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
        while (pNode)
        {
            PBLINK*  pLink = (PBLINK* )DtlGetData( pNode );
            DTLNODE* pNextNode = DtlGetNextNode( pNode );

            if (!pLink->fEnabled)
            {
                DtlRemoveNode( pInfo->pEntry->pdtllistLinks, pNode );
                DestroyLinkNode( pNode );
            }

            pNode = pNextNode;
        }
    }

    // pmay: 277801
    //
    // Update the preferred device if the one selected is different
    // from the device this page was initialized with.
    //
    if ((pInfo->fMultipleDevices) &&
        (DtlGetNodes(pInfo->pEntry->pdtllistLinks) == 1))
    {
        DTLNODE* pNodeL = NULL;
        PBLINK* pLink = NULL;
        BOOL bUpdatePref = FALSE;

        pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );

        //For whistler bug 428308
        //
        if(pNodeL)
        {
            pLink = (PBLINK*) DtlGetData( pNodeL );
        
            TRACE( "Mult devs, only one selected -- check preferred dev." );

            if ((pInfo->pszCurDevice == NULL) || (pInfo->pszCurPort == NULL))
            {
                TRACE( "No preferred device.  Resetting preferred to current." );
                bUpdatePref = TRUE;
            }
            else if (
                (lstrcmpi(pInfo->pszCurDevice, pLink->pbport.pszDevice)) ||
                (lstrcmpi(pInfo->pszCurPort, pLink->pbport.pszPort)) || 
                ( pInfo->pEntry->dwPreferredBps != pLink->dwBps ) ||
                ( pInfo->pEntry->fPreferredHwFlow  != pLink->fHwFlow  ) ||  //.Net 639551
                ( pInfo->pEntry->fPreferredEc != pLink->fEc )   ||
                ( pInfo->pEntry->fPreferredEcc != pLink->fEcc ) ||
                ( pInfo->pEntry->fPreferredSpeaker != pLink->fSpeaker ) ||
                ( pInfo->pEntry->dwPreferredModemProtocol !=    //whistler 402522
                    pLink->dwModemProtocol) )
            {
                TRACE( "New device selected as preferred device" );
                bUpdatePref = TRUE;
            }
            if (bUpdatePref)
            {
                // Assign new values to the preferred parameters
                //
                Free0(pInfo->pEntry->pszPreferredDevice);
                Free0(pInfo->pEntry->pszPreferredPort);

                pInfo->pEntry->pszPreferredDevice = 
                    StrDup(pLink->pbport.pszDevice);
                pInfo->pEntry->pszPreferredPort = 
                    StrDup(pLink->pbport.pszPort);


                // For .Net bug 639551      gangz
                //
                pInfo->pEntry->dwPreferredBps   = pLink->dwBps;
                pInfo->pEntry->fPreferredHwFlow = pLink->fHwFlow;
                pInfo->pEntry->fPreferredEc     = pLink->fEc;
                pInfo->pEntry->fPreferredEcc    = pLink->fEcc;
                pInfo->pEntry->fPreferredSpeaker = pLink->fSpeaker;
                
                // For whistler bug 402522
                //
                pInfo->pEntry->dwPreferredModemProtocol =
                    pLink->dwModemProtocol;
            }
        }
    }
    
    // Save preferences if they've changed.
    //
    if (pInfo->pUser->fDirty)
    {
        INTERNALARGS *pIArgs = (INTERNALARGS *)pInfo->pApiArgs->reserved;

        if (g_pSetUserPreferences(
                (pIArgs) ? pIArgs->hConnection : NULL,
                pInfo->pUser,
                (pInfo->fRouter) ? UPM_Router : UPM_Normal ) != 0)
        {
            return FALSE;
        }
    }

    // Save the changed phonebook entry.
    //
    pInfo->pEntry->fDirty = TRUE;

    // The final name of the entry is output to caller via API structure.
    //
    lstrcpyn( 
        pInfo->pApiArgs->szEntry, 
        pInfo->pEntry->pszEntryName,
        RAS_MaxEntryName + 1);

    // Delete the old node if in edit mode, then add the new node.
    //
    EuGetEditFlags( pInfo, &fEditMode, &fChangedNameInEditMode );
    
    //For whislter bug  424430      gangz
    //Try to Save the changed Entry Node first, if failed we should
    //restor the pInfo->pFile->pdtllistEntries
    //
    {
        DTLNODE * pTmpOldNode = NULL, * pTmpNewNode = NULL;
            
        if (fEditMode)
        {
            pTmpOldNode = pInfo->pOldNode;

            // Just remove the node from the link list, but wont destroy it 
            // until necessary
            DtlRemoveNode( pInfo->pFile->pdtllistEntries, pInfo->pOldNode );
        }

        //For whistler bug 424430
        //
        pTmpNewNode = pInfo->pNode;
        DtlAddNodeLast( pInfo->pFile->pdtllistEntries, pInfo->pNode );
        pInfo->pNode = NULL;

        // Write the change to the phone book file.
        //
        dwErr = WritePhonebookFile( pInfo->pFile,
                    (fChangedNameInEditMode) ? pInfo->szOldEntryName : NULL );

        if (dwErr != 0)
        {
            ErrorDlg( pInfo->pApiArgs->hwndOwner, SID_OP_WritePhonebook, dwErr, NULL );
            // shaunco - fix RAID 171651 by assigning dwErr to callers 
            // structure.
            pInfo->pApiArgs->dwError = dwErr;

            //For whistler bug 424430
            //
            if( NULL != pTmpNewNode )
            {
                DtlRemoveNode( pInfo->pFile->pdtllistEntries, pTmpNewNode );
                DestroyEntryNode( pTmpNewNode);
            }
            
            if(fEditMode)
            {
                DtlAddNodeLast( pInfo->pFile->pdtllistEntries, pTmpOldNode);
            }
            
            return FALSE;
        }
        else
        {
            if(NULL != pTmpOldNode)
            {
                // For bug 426235           gangz
                // should destroy the PBENTRY structure inside the 
                // pInfo->pOldNode, because it is already taken out from the 
                // linklist at above so it wont be freed in the EuFree()
                //
                DestroyEntryNode(pTmpOldNode);
            }

         }
    }

    // Notify through rasman that the entry has changed
    //
    if(pInfo->pApiArgs->dwFlags & (RASEDFLAG_AnyNewEntry | RASEDFLAG_CloneEntry))
    {
        dwErr = DwSendRasNotification(
                        ENTRY_ADDED,
                        pInfo->pEntry,
                        pInfo->pFile->pszPath,
                        NULL);
    }
    else
    {
        dwErr = DwSendRasNotification(
                        ENTRY_MODIFIED,
                        pInfo->pEntry,
                        pInfo->pFile->pszPath,
                        NULL);

    }

    // Ignore the error returned from DwSendRasNotification - we don't want
    // to fail the operation in this case. The worst case scenario is that
    // the connections folder won't refresh automatically.
    //
    dwErr = ERROR_SUCCESS;

    // If EuCommit is being called as a result of completing the "new demand 
    // dial interface" wizard, then we need to create the new demand dial 
    // interface now.
    //
    if ( EuRouterInterfaceIsNew( pInfo ) )
    {
        //Create Router MPR interface and save user credentials
        //like UserName, Domain and Password
        //IPSec credentials are save in EuCredentialsCommitRouterIPSec
        //

        dwErr = EuRouterInterfaceCreate( pInfo );

        // If we weren't successful at commiting the interface's
        // credentials, then delete the new phonebook entry.
        //
        if ( dwErr != NO_ERROR )
        {
            WritePhonebookFile( pInfo->pFile, pInfo->pApiArgs->szEntry );
            pInfo->pApiArgs->dwError = dwErr;
            return FALSE;
        }

    }

    // Now save any per-connection credentials
    //
    dwErr = EuCredentialsCommit( pInfo );

   // If we weren't successful at commiting the interface's
  // credentials, then delete the new phonebook entry.
   //
   if ( dwErr != NO_ERROR )
    {
        ErrorDlg( pInfo->pApiArgs->hwndOwner, 
                  SID_OP_CredCommit, 
                  dwErr,
                  NULL );

        pInfo->pApiArgs->dwError = dwErr;

       return FALSE;
    }

    // Save the default Internet connection settings as appropriate.  Igonre
    // the error returned as failure to set the connection as default need
    // not prevent the connection/interface creation.
    //
    dwErr = EuInternetSettingsCommitDefault( pInfo );
    dwErr = NO_ERROR;

    // If the user edited/created a router-phonebook entry, store the bitmask
    // of selected network-protocols in 'reserved2'.
    //
    if (pInfo->fRouter)
    {
        pInfo->pApiArgs->reserved2 =
            ((NP_Ip | NP_Ipx) & ~pInfo->pEntry->dwfExcludedProtocols);
    }

    // Commit the user's changes to home networking settings.
    // Ignore the return value.
    //
    dwErr = EuHomenetCommitSettings(pInfo);
    dwErr = NO_ERROR;

    pInfo->pApiArgs->dwError = 0;
    return TRUE;
}

DWORD
EuCredentialsCommit(
    IN EINFO * pInfo )
{

    // If the user is creating a new router-phonebook entry, and the user is
    // using the router wizard to create it, and the user did not edit
    // properties directly, save the dial-out credentials, and optionally, the
    // dial-in credentials.
    //
    DWORD dwErr = NO_ERROR;

    //Save the IPSec Credentials Info
    //
    if ( pInfo->fRouter )
    {
        // Save the router ipsec settings
        //
        dwErr = EuCredentialsCommitRouterIPSec( pInfo );

        // If this is a new router connection, save the 
        // credentials.  Currently, we only persist the 
        // standard credentials when it's a new router 
        // interface because there is no UI in the properties
        // of a router interface that sets the standard
        // credentials.
        //
        if ( (NO_ERROR == dwErr) && EuRouterInterfaceIsNew ( pInfo ) )
        {
            dwErr = EuCredentialsCommitRouterStandard( pInfo );
        }
    }
    else
    {
        dwErr = EuCredentialsCommitRasIPSec( pInfo );

        if (dwErr == NO_ERROR)
        {
            dwErr = EuCredentialsCommitRasGlobal( pInfo );
        }
    }
    
    return dwErr;   
} //end of EuCredentialsCommit()

DWORD
EuCredentialsCommitRouterStandard( 
    IN EINFO* pInfo )
{
    DWORD dwErr = NO_ERROR;
    HANDLE hServer = NULL;
    WCHAR* pwszInterface = NULL;
    HANDLE hInterface = NULL;

    TRACE( "EuCredentialsCommitRouterStandard" );
    // Generate the interface name based on the 
    // phonebook entry name
    dwErr = g_pMprAdminServerConnect(pInfo->pszRouter, &hServer);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    do{
        //Get the interface handle
        //
        pwszInterface = StrDupWFromT( pInfo->pEntry->pszEntryName );
        if (!pwszInterface)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        dwErr = g_pMprAdminInterfaceGetHandle(
                    hServer,
                    pwszInterface,
                    &hInterface,
                    FALSE);

        if (dwErr)
        {
            TRACE1( 
                "EuCredComRouterStandard: MprAdminInterfaceGetHandle error %d",
                 dwErr);
            break;
        }

        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded previously
        //
        DecodePassword( pInfo->pszRouterPassword );
        dwErr = g_pMprAdminInterfaceSetCredentials(
                    pInfo->pszRouter,
                    pwszInterface,
                    pInfo->pszRouterUserName,
                    pInfo->pszRouterDomain,
                    pInfo->pszRouterPassword );
        EncodePassword( pInfo->pszRouterPassword );

        if(dwErr)
        {
            TRACE1(
             "EuCredComRouterStndrd: MprAdminInterfaceSetCredentials error %d",
             dwErr);
            break;
        }
    }
    while(FALSE);

    if (pwszInterface)
    {
        Free0(pwszInterface);
    }

    if (hServer)
    {
        g_pMprAdminServerDisconnect( hServer );
    }

    return dwErr;
} //EuCredentialsCommitRouterStandard()

//
//Save IPSec keys
//
DWORD
EuCredentialsCommitRouterIPSec(
    IN EINFO* pInfo )
{
    DWORD dwErr = NO_ERROR;
    HANDLE hServer = NULL;
    HANDLE hInterface = NULL;
    WCHAR* pwszInterface = NULL;
    WCHAR pszComputer[512];
    BOOL bComputer, bUserAdded = FALSE;
    MPR_INTERFACE_0 mi0;
    MPR_CREDENTIALSEX_1 mc1;

    TRACE( "EuCredComRouterIPSec" );

    //
    //Save PSK only when User changed it in the Property UI
    //
    if ( !pInfo->fPSKCached )
    {
        return NO_ERROR;
    }
    
    // Connect to the router service.
    //
    dwErr = g_pMprAdminServerConnect(pInfo->pszRouter, &hServer);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        // Initialize the interface-information structure.
        //
        ZeroMemory( &mi0, sizeof(mi0) );

        mi0.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
        mi0.fEnabled = TRUE;
        pwszInterface = StrDupWFromT( pInfo->pEntry->pszEntryName );
        if (!pwszInterface)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        lstrcpynW( 
            mi0.wszInterfaceName, 
            pwszInterface, 
            MAX_INTERFACE_NAME_LEN+1 );

        //
        //Get the interface handle
        //
         dwErr = g_pMprAdminInterfaceGetHandle(
                    hServer,
                    pwszInterface,
                    &hInterface,
                    FALSE);

        if (dwErr)
        {
            TRACE1( "EuCredComRouterIPSec: MprAdminInterfaceGetHandle error %d", dwErr);
            break;
        }

        // Set the dial-out credentials for the interface.  Stop after this if
        // an error occurs, or if we don't need to add a user-account.
        //

        //Save the IPSec Policy keys(PSK for Whislter)
        //
            ASSERT( g_pMprAdminInterfaceSetCredentialsEx );
            ZeroMemory( &mc1, sizeof(mc1) );
            mc1.dwSize = sizeof( pInfo->szPSK );
            mc1.lpbCredentialsInfo = (LPBYTE)(pInfo->szPSK);

            // Whistler bug 254385 encode password when not being used
            // Assumed password was encoded previously
            //
            DecodePassword( pInfo->szPSK );
            dwErr = g_pMprAdminInterfaceSetCredentialsEx(
                        hServer,
                        hInterface,
                        1,
                        (LPBYTE)&mc1);
            EncodePassword( pInfo->szPSK );
            if(dwErr)
            {
                TRACE1(
                    "EuCredComRouterIPSec: MprAdminInterfaceSetCredentialsEx error %d",
                    dwErr);
                break;
            }

    }
    while (FALSE);

    // Cleanup
    {
        // Close all handles, free all strings.
        if (pwszInterface)
        {
            Free0( pwszInterface );
        }

        if (hServer)
        {
            g_pMprAdminServerDisconnect( hServer );
        }
    }

    return dwErr;
}//end of EuCredentialsCommitRouterIPSec()

DWORD
EuCredentialsCommitRasIPSec(
    IN EINFO* pInfo )
{
     //Save IPSec Keys through RAS functions
     //
     DWORD dwErr = NO_ERROR;
     RASCREDENTIALS rc;

    TRACE( "EuCredentialsCommitRasIPSec" );
    if ( pInfo->fPSKCached )
    {
        ZeroMemory( &rc, sizeof(rc) );
        rc.dwSize = sizeof(rc);
        rc.dwMask = RASCM_PreSharedKey; //RASCM_Password; //RASCM_UserName;

        // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
        //
        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded previously
        //
        DecodePassword( pInfo->szPSK );
        lstrcpyn(
            rc.szPassword,
            pInfo->szPSK,
            sizeof(rc.szPassword) / sizeof(TCHAR) );
        EncodePassword( pInfo->szPSK );

        ASSERT( g_pRasSetCredentials );
        TRACE( "RasSetCredentials(p,TRUE)" );
        dwErr = g_pRasSetCredentials(
                    pInfo->pFile->pszPath,
                    pInfo->pEntry->pszEntryName,
                    &rc,
                    FALSE );

        RtlSecureZeroMemory( rc.szPassword, sizeof(rc.szPassword) );

        TRACE1( "EuCredentialsCommitRasIPSec: RasSetCredentials=%d", dwErr );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->pApiArgs->hwndOwner, SID_OP_CachePw, dwErr, NULL );
        }
    }

    return dwErr;
} //end of EuCredentialsCommitRasIPSec()

// Commits the global ras credentials
//
DWORD
EuCredentialsCommitRasGlobal(
    IN EINFO* pInfo )
{
    DWORD dwErr = NO_ERROR;
    RASCREDENTIALS rc;

    TRACE( "EuCredentialsCommitRasGlobal" );
    if ( pInfo->pszDefUserName )
    {
         ZeroMemory( &rc, sizeof(rc) );
         rc.dwSize = sizeof(rc);
         rc.dwMask = RASCM_UserName | RASCM_Password; 

        //Add this for whistler bug 328673
        //
         if ( pInfo->fGlobalCred )
         {
            rc.dwMask |= RASCM_DefaultCreds;
         }

         // Whistler bug 254385 encode password when not being used
         //
         DecodePassword( pInfo->pszDefPassword );
         lstrcpyn( 
            rc.szPassword, 
            pInfo->pszDefPassword,
            sizeof(rc.szPassword) / sizeof(TCHAR));
         EncodePassword( pInfo->pszDefPassword );

         lstrcpyn( 
            rc.szUserName, 
            pInfo->pszDefUserName,
            sizeof(rc.szUserName) / sizeof(TCHAR));
            
         ASSERT( g_pRasSetCredentials );
         TRACE( "RasSetCredentials(p,TRUE)" );
         dwErr = g_pRasSetCredentials(
                    pInfo->pFile->pszPath,
                    pInfo->pEntry->pszEntryName, 
                    &rc, 
                    FALSE );

         // Whistler bug 254385 encode password when not being used
         //
         RtlSecureZeroMemory( rc.szPassword, sizeof(rc.szPassword) );

         TRACE1( "EuCredsCommitRasGlobal: RasSetCredentials=%d", dwErr );
         if (dwErr != 0)
         {
              ErrorDlg( 
                pInfo->pApiArgs->hwndOwner, 
                SID_OP_CachePw, 
                dwErr, 
                NULL );
         }
    }

    return dwErr;
}

DWORD
EuInternetSettingsCommitDefault( 
    IN EINFO* pInfo )
{
    RASAUTODIALENTRY adEntry;
    DWORD dwErr = NO_ERROR;

    ZeroMemory(&adEntry, sizeof(adEntry));
    adEntry.dwSize = sizeof(adEntry);

    if ( pInfo->fDefInternet )
    {
        lstrcpyn(
            adEntry.szEntry, 
            pInfo->pApiArgs->szEntry, 
            RAS_MaxEntryName + 1);

        dwErr = RasSetAutodialAddress(
                    NULL,
                    0,
                    &adEntry,
                    sizeof(adEntry),
                    1);
    }

    return dwErr;
}

DWORD
EuHomenetCommitSettings(
    IN EINFO* pInfo)
{
    DWORD dwErr = NO_ERROR;

    return dwErr;
}

DWORD
EuRouterInterfaceCreate(
    IN EINFO* pInfo )

    // Commits the credentials and user-account for a router interface.
    //
{
    DWORD dwErr;
    DWORD dwPos, dwSize;
    HANDLE hServer = NULL, hUserServer = NULL, hUser = NULL;
    HANDLE hInterface = NULL;
    WCHAR* pwszInterface = NULL;
    WCHAR pszComputer[512];
    BOOL bComputer, bUserAdded = FALSE;
    RAS_USER_0 ru0;
    USER_INFO_1 ui1;
    MPR_INTERFACE_0 mi0;
    //MPR_CREDENTIALSEX_1 mc1;

    TRACE( "EuRouterInterfaceCreate" );

    // Connect to the router service.
    //
    dwErr = g_pMprAdminServerConnect(pInfo->pszRouter, &hServer);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        // Initialize the interface-information structure.
        //
        ZeroMemory( &mi0, sizeof(mi0) );

        mi0.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
        mi0.fEnabled = TRUE;
        pwszInterface = StrDupWFromT( pInfo->pEntry->pszEntryName );
        if (!pwszInterface)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        lstrcpynW( 
            mi0.wszInterfaceName, 
            pwszInterface, 
            MAX_INTERFACE_NAME_LEN+1 );

        // Create the interface.
        //
        dwErr = g_pMprAdminInterfaceCreate(
                    hServer,
                    0,
                    (BYTE*)&mi0,
                    &hInterface );
        if ( dwErr )
        {
            TRACE1( "EuRouterInterfaceCreate: MprAdminInterfaceCreate error %d", dwErr);
            break;
        }

         dwErr = g_pMprAdminInterfaceGetHandle(
                    hServer,
                    pwszInterface,
                    &hInterface,
                    FALSE);

        if (dwErr)
        {
            TRACE1( "EuRouterInterfaceCreate: MprAdminInterfaceGetHandle error %d", dwErr);
            break;
        }

        // Add a user if we were instructed to.
        if (pInfo->fAddUser)
        {
            // Initialize user-information structure.
            //
            ZeroMemory( &ui1, sizeof(ui1) );

            ui1.usri1_name = pwszInterface;

            // Whistler bug 254385 encode password when not being used
            // Assumed password was encoded previously
            //
            DecodePassword( pInfo->pszRouterDialInPassword );
            ui1.usri1_password =
                StrDupWFromT( pInfo->pszRouterDialInPassword );
            EncodePassword( pInfo->pszRouterDialInPassword );

            ui1.usri1_priv = USER_PRIV_USER;
            ui1.usri1_comment =
                PszFromId( g_hinstDll, SID_RouterDialInAccount );
            ui1.usri1_flags = UF_SCRIPT         |
                              UF_NORMAL_ACCOUNT |
                              UF_DONT_EXPIRE_PASSWD;

            // Format the server name so that it is
            // in the form '\\<server>' as this is
            // required by the NetUser api's.
            bComputer = FALSE;
            if (pInfo->pszRouter)
            {
                if (*(pInfo->pszRouter) != L'\\')
                {
                    dwSize = sizeof(pszComputer) - (2 * sizeof(WCHAR));

                    // Whistler bug 224074 use only lstrcpyn's to prevent
                    // maliciousness
                    //
                    lstrcpynW(
                        pszComputer,
                        L"\\\\",
                        sizeof(pszComputer) / sizeof(TCHAR) );
                    if (*(pInfo->pszRouter) != 0)
                    {
                        lstrcatW(pszComputer, pInfo->pszRouter);
                    }
                    else
                    {
                        GetComputerName(pszComputer + 2, &dwSize);
                    }
                    bComputer = TRUE;
                }
            }

            // Add the user-account.
            //
            dwErr = NetUserAdd(
                        (bComputer) ? pszComputer : pInfo->pszRouter,
                        1,
                        (BYTE*)&ui1,
                        &dwPos );

            ZeroMemory(
                ui1.usri1_password,
                lstrlen( ui1.usri1_password ) * sizeof(TCHAR) );
            Free0(ui1.usri1_password);
            Free0(ui1.usri1_comment);

            // pmay: bug 232983.  If the user already exists, give the
            // admin the option of continuing with the config or
            // canceling this operation.
            if (dwErr == NERR_UserExists)
            {
                MSGARGS args;
                INT iRet;

                // Initialize the arguments that specify the
                // type of popup we want.
                ZeroMemory(&args, sizeof(args));
                args.dwFlags = MB_YESNO | MB_ICONINFORMATION;
                args.apszArgs[0] = ui1.usri1_name;

                // Popup the confirmation
                iRet = MsgDlg(
                        GetActiveWindow(),
                        SID_RouterUserExists,
                        &args );
                if (iRet == IDNO)
                {
                    break;
                }
            }

            // If some other error occurred besides the user already
            // existing, bail out.
            else if (dwErr)
            {
                TRACE1( "EuRouterInterfaceCreate: NetUserAdd error %d", dwErr );
                break;
            }

            // Otherwise, record the fact that a user was added
            // so that we can clean up as appropriate.
            else
            {
                bUserAdded = TRUE;
            }

            // Initialize the RAS user-settings structure.
            //
            ZeroMemory( &ru0, sizeof(ru0) );
            ru0.bfPrivilege = RASPRIV_NoCallback | RASPRIV_DialinPrivilege;

            // Nt4 routers enable local users by setting user parms
            //
            if ( pInfo->fNt4Router )
            {
                dwErr = g_pRasAdminUserSetInfo(
                            pInfo->pszRouter,
                            pwszInterface,
                            0,
                            (BYTE*)&ru0 );
                if(dwErr)
                {
                    TRACE1( "EuRouterInterfaceCreate: MprAdminUserSetInfo %d", dwErr );
                    break;
                }
            }

            // Nt5 routers enable users for dialin by setting
            // information with sdo's.
            else
            {
                dwErr = g_pMprAdminUserServerConnect(
                                (bComputer) ? pszComputer : pInfo->pszRouter,
                                TRUE,
                                &hUserServer);
                if (dwErr != NO_ERROR)
                {
                    TRACE1( "EuRouterInterfaceCreate: UserSvrConnect error %d", dwErr );
                    break;
                }

                dwErr = g_pMprAdminUserOpen(
                            hUserServer,
                            pwszInterface,
                            &hUser);
                if (dwErr != NO_ERROR)
                {
                    TRACE1( "EuRouterInterfaceCreate: UserOpen error %d", dwErr );
                    break;
                }

                dwErr = g_pMprAdminUserWrite(
                            hUser,
                            0,
                            (LPBYTE)&ru0);

                if (dwErr != NO_ERROR)
                {
                    TRACE1( "EuRouterInterfaceCreate: UserWrite error %d", dwErr );
                    break;
                }
            }
        }
    }
    while (FALSE);

    // Cleanup
    {
        // If some operation failed, restore the router to the
        // state it was previously in.
        if ( dwErr != NO_ERROR )
        {
            // Cleanup the interface we created...
            if ( hInterface )
            {
                MprAdminInterfaceDelete(hServer, hInterface);
            }
            if ( bUserAdded )
            {
                NetUserDel (
                    (bComputer) ? pszComputer : pInfo->pszRouter,
                    pwszInterface );
            }
        }

        // Close all handles, free all strings.
        if ( hUser )
            g_pMprAdminUserClose( hUser );
        if ( hUserServer )
            g_pMprAdminUserServerDisconnect( hUserServer );
        if (pwszInterface)
            Free0( pwszInterface );
        if (hServer)
            g_pMprAdminServerDisconnect( hServer );
    }

    return dwErr;
}


VOID
EuFree(
    IN EINFO* pInfo )

    // Releases 'pInfo' and associated resources.
    //
{
    TCHAR* psz;
    INTERNALARGS* piargs;

    piargs = (INTERNALARGS* )pInfo->pApiArgs->reserved;

    // Don't clean up the phonebook and user preferences if they arrived via
    // the secret hack.
    //
    if (!piargs)
    {
        if (pInfo->pFile)
        {
            ClosePhonebookFile( pInfo->pFile );
        }

        if (pInfo->pUser)
        {
            DestroyUserPreferences( pInfo->pUser );
        }
    }

    if (pInfo->pListPorts)
    {
        DtlDestroyList( pInfo->pListPorts, DestroyPortNode );
    }
    Free0(pInfo->pszCurDevice);
    Free0(pInfo->pszCurPort);

    if (pInfo->pNode)
    {
        DestroyEntryNode( pInfo->pNode );
    }

    // Free router-information
    //
    Free0( pInfo->pszRouter );
    Free0( pInfo->pszRouterUserName );
    Free0( pInfo->pszRouterDomain );

    if (pInfo->pSharedNode)
    {
        DestroyLinkNode( pInfo->pSharedNode );
    }

    psz = pInfo->pszRouterPassword;
    if (psz)
    {
        ZeroMemory( psz, lstrlen( psz ) * sizeof(TCHAR) );
        Free( psz );
    }

    psz = pInfo->pszRouterDialInPassword;
    if (psz)
    {
        ZeroMemory( psz, lstrlen( psz ) * sizeof(TCHAR) );
        Free( psz );
    }

    // Free credentials stuff
    //
    Free0(pInfo->pszDefUserName);

    // Whistler bug 254385 encode password when not being used
    //
    psz = pInfo->pszDefPassword;
    if (psz)
    {
        ZeroMemory( psz, lstrlen( psz ) * sizeof(TCHAR) );
        Free( psz );
    }

    if (pInfo->fComInitialized)
    {
        CoUninitialize();
    }

    Free( pInfo );
}


VOID
EuGetEditFlags(
    IN EINFO* pEinfo,
    OUT BOOL* pfEditMode,
    OUT BOOL* pfChangedNameInEditMode )

    // Sets '*pfEditMode' true if in edit mode, false otherwise.  Set
    // '*pfChangedNameInEditMode' true if the entry name was changed while in
    // edit mode, false otherwise.  'PEinfo' is the common entry context.
    //
{
    if ((pEinfo->pApiArgs->dwFlags & RASEDFLAG_AnyNewEntry)
        || (pEinfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry))
    {
        *pfEditMode = *pfChangedNameInEditMode = FALSE;
    }
    else
    {
        *pfEditMode = TRUE;
        *pfChangedNameInEditMode =
            (lstrcmpi( pEinfo->szOldEntryName,
                pEinfo->pEntry->pszEntryName ) != 0);
    }
}


DWORD
EuInit(
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry,
    IN RASENTRYDLG* pArgs,
    IN BOOL fRouter,
    OUT EINFO** ppInfo,
    OUT DWORD* pdwOp )

    // Allocates '*ppInfo' data for use by the property sheet or wizard.
    // 'PszPhonebook', 'pszEntry', and 'pArgs', are the arguments passed by
    // user to the API.  'FRouter' is set if running in "router mode", clear
    // for the normal "dial-out" mode.  '*pdwOp' is set to the operation code
    // associated with any error.
    //
    // Returns 0 if successful, or an error code.  If non-null '*ppInfo' is
    // returned caller must eventually call EuFree to release the returned
    // block.
    //
{
    DWORD dwErr;
    EINFO* pInfo;
    INTERNALARGS* piargs;

    *ppInfo = NULL;
    *pdwOp = 0;

    pInfo = Malloc( sizeof(EINFO) );
    if (!pInfo)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppInfo = pInfo;

    ZeroMemory( pInfo, sizeof(*pInfo ) );
    pInfo->pszPhonebook = pszPhonebook;
    pInfo->pszEntry = pszEntry;
    pInfo->pApiArgs = pArgs;
    pInfo->fRouter = fRouter;

    piargs = (INTERNALARGS *)pArgs->reserved;

    if (pInfo->fRouter)
    {
        LPTSTR pszRouter;
        DWORD dwVersion;

        ASSERT(piargs);

        pszRouter = RemoteGetServerName(piargs->hConnection);

        // pmay: 348623
        //
        // Note that RemoteGetServerName is guarenteed to return
        // NULL for local box, non-NULL for remote
        //
        pInfo->fRemote = !!pszRouter;

        if(NULL == pszRouter)
        {
            pszRouter = TEXT("");
        }

        pInfo->pszRouter = StrDupTFromW(pszRouter);

        // Find out if we're focused on an nt4 router
        // pInfo->fNt4Router = FALSE;
        // IsNt40Machine( pszRouter, &(pInfo->fNt4Router) );

        dwVersion = ((RAS_RPC *)(piargs->hConnection))->dwVersion;

        pInfo->fNt4Router = !!(VERSION_40 == dwVersion );
        //Find out if the remote server is a win2k machine
        //
        pInfo->fW2kRouter = !!(VERSION_50 == dwVersion );
    }

    // Load the user preferences, or figure out that caller has already loaded
    // them.
    //
    if (piargs && !piargs->fInvalid)
    {
        // We've received user preferences and the "no user" status via the
        // secret hack.
        //
        pInfo->pUser = piargs->pUser;
        pInfo->fNoUser = piargs->fNoUser;
        pInfo->pFile = piargs->pFile;
        pInfo->fDisableFirstConnect = piargs->fDisableFirstConnect;
    }
    else
    {
        DWORD dwReadPbkFlags = 0;

        // Read user preferences from registry.
        //
        dwErr = g_pGetUserPreferences(
            (piargs) ? piargs->hConnection : NULL,
            &pInfo->user,
            (pInfo->fRouter) ? UPM_Router : UPM_Normal );
        if (dwErr != 0)
        {
            *pdwOp = SID_OP_LoadPrefs;
            return dwErr;
        }

        pInfo->pUser = &pInfo->user;

        if(pInfo->fRouter)
        {
            pInfo->file.hConnection = piargs->hConnection;
            dwReadPbkFlags |= RPBF_Router;
        }

        if(pInfo->fNoUser)
        {
            dwReadPbkFlags |= RPBF_NoUser;
        }
        else
        {
            if (IsConsumerPlatform())
            {
                dwReadPbkFlags |= RPBF_AllUserPbk;
            }
        }

        // Load and parse the phonebook file.
        //
        dwErr = ReadPhonebookFile(
            pInfo->pszPhonebook, &pInfo->user, NULL,
            dwReadPbkFlags,
            &pInfo->file );
        if (dwErr != 0)
        {
            *pdwOp = SID_OP_LoadPhonebook;
            return dwErr;
        }

        pInfo->pFile = &pInfo->file;
    }

    // Determine if strong encryption is supported.  Export laws prevent it in
    // some versions of the system.
    //
    {
        ULONG ulCaps;
        RAS_NDISWAN_DRIVER_INFO info;

        ZeroMemory( &info, sizeof(info) );
        ASSERT( g_pRasGetNdiswanDriverCaps );
        dwErr = g_pRasGetNdiswanDriverCaps(
            (piargs) ? piargs->hConnection : NULL, &info );
        if (dwErr == 0)
        {
            pInfo->fStrongEncryption =
                !!(info.DriverCaps & RAS_NDISWAN_128BIT_ENABLED);
        }
        else
        {
            pInfo->fStrongEncryption = FALSE;
        }
    }

    // Load the list of ports.
    //
    dwErr = LoadPortsList2(
        (piargs) ? piargs->hConnection : NULL,
        &pInfo->pListPorts,
        pInfo->fRouter );
    if (dwErr != 0)
    {
        TRACE1( "LoadPortsList=%d", dwErr );
        *pdwOp = SID_OP_RetrievingData;
        return dwErr;
    }

    // Set up work entry node.
    //
    if (pInfo->pApiArgs->dwFlags & RASEDFLAG_AnyNewEntry)
    {
        DTLNODE* pNodeL;
        DTLNODE* pNodeP;
        PBLINK* pLink;
        PBPORT* pPort;

        // New entry mode, so 'pNode' set to default settings.
        //
        pInfo->pNode = CreateEntryNode( TRUE );
        if (!pInfo->pNode)
        {
            TRACE( "CreateEntryNode failed" );
            *pdwOp = SID_OP_RetrievingData;
            return dwErr;
        }

        // Store entry within work node stored in context for convenience
        // elsewhere.
        //
        pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );
        ASSERT( pInfo->pEntry );

        if (pInfo->fRouter)
        {
            // Set router specific defaults.
            //
            pInfo->pEntry->dwIpNameSource = ASRC_None;
            pInfo->pEntry->dwRedialAttempts = 0;

            // Since this is a new entry, setup a proposed entry name.
            // This covers the case when the wizard is not used to
            // create the entry and the property sheet has no way to enter
            // the name.
            ASSERT( !pInfo->pEntry->pszEntryName );
            GetDefaultEntryName( pInfo->pFile,
                                 RASET_Phone,
                                 pInfo->fRouter,
                                 &pInfo->pEntry->pszEntryName );

            // Disable MS client and File and Print services by default
            //
            EnableOrDisableNetComponent( pInfo->pEntry, TEXT("ms_msclient"),
                FALSE);
            EnableOrDisableNetComponent( pInfo->pEntry, TEXT("ms_server"),
                FALSE);
        }

        // Use caller's default name, if any.
        //
        if (pInfo->pszEntry)
        {
            pInfo->pEntry->pszEntryName = StrDup( pInfo->pszEntry );
        }

        // Set the default entry type to "phone", i.e. modems, ISDN, X.26 etc.
        // This may be changed to "VPN" or  "direct"  by the new entry  wizard
        // after the initial wizard page.
        //
        EuChangeEntryType( pInfo, RASET_Phone );
    }
    else
    {
        DTLNODE* pNode;

        // Edit or clone entry mode, so 'pNode' set to entry's current
        // settings.
        //
        pInfo->pOldNode = EntryNodeFromName(
            pInfo->pFile->pdtllistEntries, pInfo->pszEntry );

        if (    !pInfo->pOldNode
            &&  !pInfo->fRouter)
        {

            if(NULL == pInfo->pszPhonebook)
            {
                //
                // Close the phonebook file we opened above.
                // we will try to find the entry name in the
                // per user phonebook file.
                //
                ClosePhonebookFile(&pInfo->file);

                pInfo->pFile = NULL;

                //
                // Attempt to find the file in users profile
                //
                dwErr = GetPbkAndEntryName(
                                    NULL,
                                    pInfo->pszEntry,
                                    0,
                                    &pInfo->file,
                                    &pInfo->pOldNode);

                if(ERROR_SUCCESS != dwErr)
                {
                    *pdwOp = SID_OP_RetrievingData;
                    return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
                }

                pInfo->pFile = &pInfo->file;
            }
            else
            {
                *pdwOp = SID_OP_RetrievingData;
                return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            }
        }

        if(NULL != pInfo->pOldNode)
        {
            PBENTRY *pEntry = (PBENTRY *) DtlGetData(pInfo->pOldNode);
            
            // Before cloning or editing make sure that for dial up
            // connections, share File And Print is disabled.
            //
            if(     ((RASET_Phone == pEntry->dwType)
                ||  (RASET_Broadband == pEntry->dwType))
                &&  (!pEntry->fShareMsFilePrint))
            {
                EnableOrDisableNetComponent( pEntry, TEXT("ms_server"),
                    FALSE);
            }
        }

        if(NULL != pInfo->pOldNode)
        {
            if (pInfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry)
            {
                pInfo->pNode = CloneEntryNode( pInfo->pOldNode );
            }
            else
            {
                pInfo->pNode = DuplicateEntryNode( pInfo->pOldNode );
            }
        }

        if (!pInfo->pNode)
        {
            TRACE( "DuplicateEntryNode failed" );
            *pdwOp = SID_OP_RetrievingData;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        // Store entry within work node stored in context for convenience
        // elsewhere.
        //
        pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );

        // Save original entry name for comparison later.
        //
        lstrcpyn( 
            pInfo->szOldEntryName, 
            pInfo->pEntry->pszEntryName,
            RAS_MaxEntryName + 1);

        // For router, want unconfigured ports to show up as "unavailable" so
        // they stand out to user who has been directed to change them.
        //
        if (pInfo->fRouter)
        {
            DTLNODE* pNodeL;
            PBLINK* pLink;

            pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
            pLink = (PBLINK* )DtlGetData( pNodeL );

            if (!pLink->pbport.fConfigured)
            {
                Free0( pLink->pbport.pszDevice );
                pLink->pbport.pszDevice = NULL;
            }
        }

        // pmay: 277801
        //
        // Remember the "current" device if this entry was last saved
        // as single link.  
        //
        if (DtlGetNodes(pInfo->pEntry->pdtllistLinks) == 1)
        {
            DTLNODE* pNodeL;
            PBLINK* pLink;
            
            pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
            pLink = (PBLINK* )DtlGetData( pNodeL );

            if (pLink->pbport.pszDevice && pLink->pbport.pszPort)
            {
                pInfo->pszCurDevice = 
                    StrDup(pLink->pbport.pszDevice);
                pInfo->pszCurPort = 
                    StrDup(pLink->pbport.pszPort);
            }                
        }

        // Append all non-configured ports of the entries type to the list of
        // links.  This is for the convenience of the UI.  The non-configured
        // ports are removed after editing prior to saving.
        //
        AppendDisabledPorts( pInfo, pInfo->pEntry->dwType );
    }

    // Set up the phone number storage for shared phone number mode.
    // Initialize it to a copy of the information from the first link which at
    // startup will always be enabled.  Note the Dial case with non-0
    // dwSubEntry is an exception, but in that case the pSharedNode anyway.
    //
    {
        DTLNODE* pNode;

        pInfo->pSharedNode = CreateLinkNode();
        if (!pInfo->pSharedNode)
        {
            *pdwOp = SID_OP_RetrievingData;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        ASSERT( pInfo->pSharedNode );
        pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
        ASSERT( pNode );
        CopyLinkPhoneNumberInfo( pInfo->pSharedNode, pNode );
    }

    if (pInfo->fRouter)
    {
        pInfo->pEntry->dwfExcludedProtocols |= NP_Nbf;
    }

    // AboladeG - capture the security level of the current user.
    //
    pInfo->fIsUserAdminOrPowerUser = FIsUserAdminOrPowerUser();

    return 0;
}


BOOL
EuValidateName(
    IN HWND hwndOwner,
    IN EINFO* pEinfo )

    // Validates the working entry name and pops up a message if invalid.
    // 'HwndOwner' is the window to own the error popup.  'PEinfo' is the
    // common dialog context containing the name to validate.
    //
    // Returns true if the name is valid, false if not.
    //
{
    PBENTRY* pEntry;
    BOOL fEditMode;
    BOOL fChangedNameInEditMode;

    pEntry = pEinfo->pEntry;

    // Validate the sheet data.
    //
    if (!ValidateEntryName( pEinfo->pEntry->pszEntryName ))
    {
        // Invalid entry name.
        //
        MsgDlg( hwndOwner, SID_BadEntry, NULL );
        return FALSE;
    }

    EuGetEditFlags( pEinfo, &fEditMode, &fChangedNameInEditMode );

    if ((fChangedNameInEditMode || !fEditMode)
        && EntryNodeFromName(
               pEinfo->pFile->pdtllistEntries, pEntry->pszEntryName ))
    {
        // Duplicate entry name.
        //
        MSGARGS msgargs;
        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pEntry->pszEntryName;
        MsgDlg( hwndOwner, SID_DuplicateEntry, &msgargs );
        return FALSE;
    }

    return TRUE;
}


//----------------------------------------------------------------------------
// Area-code and Country-code utility routiness (Cu utilities)
// Listed alphabetically
//----------------------------------------------------------------------------

VOID
CuClearCountryCodeLb(
    IN CUINFO* pCuInfo )

    // Clear the country code dropdown.  'PCuInfo' is the complex phone number
    // context.
    //
{
    TRACE( "CuClearCountryCodeLb" );

    ComboBox_ResetContent( pCuInfo->hwndLbCountryCodes );

    if (pCuInfo->pCountries)
    {
        FreeCountryInfo( pCuInfo->pCountries, pCuInfo->cCountries );
        pCuInfo->pCountries = NULL;
    }

    pCuInfo->cCountries = 0;
    pCuInfo->fComplete = FALSE;
}


BOOL
CuCountryCodeLbHandler(
    IN CUINFO* pCuInfo,
    IN WORD wNotification )

    // Handles WM_COMMAND notification to the Country Code dropdown.
    // 'PCuInfo' is the complex phone number context.  'WNotification' is the
    // wParam of the WM_COMMAND.
    //
    // Returns true if processed message, false otherwise.
    //
{
    switch (wNotification)
    {
        case CBN_DROPDOWN:
        {
            CuUpdateCountryCodeLb( pCuInfo, TRUE );
            return TRUE;
        }

        case CBN_SELCHANGE:
        {
            CuCountryCodeLbSelChange( pCuInfo );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
CuCountryCodeLbSelChange(
    IN CUINFO* pCuInfo )

    // Called when the country list selection has changed.  'PCuInfo' is the
    // complex phone number context.
    //
{
    LONG lSign;
    LONG i;

    TRACE( "CuCountryCodeLbSelChange" );

    // When a partial list (default after setting a new phone number set) is
    // loaded there are dummy entries placed before and after the single
    // country code with contexts of -1 and 1.  This allows transparent
    // behavior when user presses left/right arrows to change selection, in
    // which case the full list of countries is loaded behind the scenes, and
    // the selection adjusted to the country before/after the country in the
    // original partial display.
    //
    lSign =
        (LONG )ComboBox_GetItemData( pCuInfo->hwndLbCountryCodes,
                   ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes ) );

    if (lSign == -1 || lSign == 1)
    {
        CuUpdateCountryCodeLb( pCuInfo, TRUE );

        i = (LONG )ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes );
        if (ComboBox_SetCurSel( pCuInfo->hwndLbCountryCodes, i + lSign ) < 0)
        {
            ComboBox_SetCurSel( pCuInfo->hwndLbCountryCodes, i );
        }
    }
    else
    {
        ASSERT( pCuInfo->fComplete );
    }
}


BOOL
CuDialingRulesCbHandler(
    IN CUINFO* pCuInfo,
    IN WORD wNotification )

    // Handle the WM_COMMAND notification to the "use dialing rules" checkbox
    // control.  Updates the the Area Code and Country Code controls to
    // reflect the current state of dialing rules.  'PCuInfo' is the complex
    // phone number context.  'WNotification' is the wparam of the WM_COMMAND
    // notification (though it currently assumes it's a button click).
    //
    // Returns true if processed message, false otherwise.
{
    BOOL fRules;
    BOOL fEnable;

    TRACE( "CuDialingRulesCbChange" );

    
    fRules = Button_GetCheck( pCuInfo->hwndCbUseDialingRules );
    
    // For whistler bug 445424      gangz
    //
    if ( fRules )
    {
        DWORD dwErr = NO_ERROR;
        HLINEAPP hlineapp = (HLINEAPP )0;
        
        dwErr = TapiNoLocationDlg( 
                            g_hinstDll, 
                            &hlineapp, 
                            pCuInfo->hwndCbUseDialingRules
                                );
        if (dwErr != 0)
        {
            // Error here is treated as a "cancel" per bug 288385.
            //
            Button_SetCheck( pCuInfo->hwndCbUseDialingRules, FALSE);
            fRules = FALSE;
            Button_SetCheck( pCuInfo->hwndCbUseDialingRules, FALSE);
        }
    }

    if (fRules)
    {
        CuUpdateCountryCodeLb( pCuInfo, FALSE );
        CuUpdateAreaCodeClb( pCuInfo );
    }
    else
    {
        COUNTRY* pCountry;
        INT iSel;

        iSel = ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes );
        if (iSel >= 0)
        {
            pCountry = (COUNTRY* )ComboBox_GetItemDataPtr(
                pCuInfo->hwndLbCountryCodes, iSel );
            ASSERT( pCountry );

            if(NULL != pCountry)
            {
                pCuInfo->dwCountryId = pCountry->dwId;
                pCuInfo->dwCountryCode = pCountry->dwCode;
            }
        }

        Free0( pCuInfo->pszAreaCode );
        pCuInfo->pszAreaCode = GetText( pCuInfo->hwndClbAreaCodes );

        ComboBox_ResetContent( pCuInfo->hwndClbAreaCodes );
        CuClearCountryCodeLb( pCuInfo );
    }

    EnableWindow( pCuInfo->hwndStAreaCodes, fRules );
    EnableWindow( pCuInfo->hwndClbAreaCodes, fRules );
    EnableWindow( pCuInfo->hwndStCountryCodes, fRules );
    EnableWindow( pCuInfo->hwndLbCountryCodes, fRules );
    EnableWindow( pCuInfo->hwndPbDialingRules, fRules );

    return TRUE;
}


VOID
CuFree(
    IN CUINFO* pCuInfo )

    // Free resources attached to the 'pCuInfo' context.
    //
{
    TRACE( "CuFree" );

    if (pCuInfo->pCountries)
    {
        FreeCountryInfo( pCuInfo->pCountries, pCuInfo->cCountries );
        pCuInfo->pCountries = NULL;
    }

    pCuInfo->cCountries = 0;
    pCuInfo->fComplete = FALSE;

    Free0( pCuInfo->pszAreaCode );
    pCuInfo->pszAreaCode = NULL;
}


VOID
CuGetInfo(
    IN CUINFO* pCuInfo,
    OUT DTLNODE* pPhoneNode )

    // Load the phone number set information from the controls into PBPHONE
    // node 'pPhone'.  'PCuInfo' is the complex phone number context.
    //
{
    PBPHONE* pPhone;

    pPhone = (PBPHONE* )DtlGetData( pPhoneNode );
    ASSERT( pPhone );

    Free0( pPhone->pszPhoneNumber );
    pPhone->pszPhoneNumber = GetText( pCuInfo->hwndEbPhoneNumber );

    if (pCuInfo->hwndEbComment)
    {
        Free0( pPhone->pszComment );
        pPhone->pszComment = GetText( pCuInfo->hwndEbComment );
    }

    pPhone->fUseDialingRules =
        Button_GetCheck( pCuInfo->hwndCbUseDialingRules );

    Free0( pPhone->pszAreaCode );

    if (pPhone->fUseDialingRules)
    {
        COUNTRY* pCountry;
        INT iSel;

        // Get the area and country code selections from the lists.
        //
        pPhone->pszAreaCode = GetText( pCuInfo->hwndClbAreaCodes );

        iSel = ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes );
        if (iSel >= 0)
        {
            pCountry = (COUNTRY* )ComboBox_GetItemDataPtr(
                pCuInfo->hwndLbCountryCodes, iSel );
            ASSERT( pCountry );

            if(NULL != pCountry)
            {
                pPhone->dwCountryID = pCountry->dwId;
                pPhone->dwCountryCode = pCountry->dwCode;
            }
        }
    }
    else
    {
        // Get the "blanked" values instead.
        //
        pPhone->pszAreaCode = StrDup( pCuInfo->pszAreaCode );
        pPhone->dwCountryID = pCuInfo->dwCountryId;
        pPhone->dwCountryCode = pCuInfo->dwCountryCode;
    }

    if (pPhone->pszAreaCode)
    {
        TCHAR* pIn;
        TCHAR* pOut;

        // Sanitize the area code.  See bug 298570.
        //
        for (pIn = pOut = pPhone->pszAreaCode; *pIn; ++pIn)
        {
            if (*pIn != TEXT(' ') && *pIn != TEXT('(') && *pIn != TEXT(')'))
            {
                *pOut++ = *pIn;
            }
        }
        *pOut = TEXT('\0');
    }

    // Add the area code entered to the global list for this user.
    //
    CuSaveToAreaCodeList( pCuInfo, pPhone->pszAreaCode );
}


VOID
CuInit(
    OUT CUINFO* pCuInfo,
    IN HWND hwndStAreaCodes,
    IN HWND hwndClbAreaCodes,
    IN HWND hwndStPhoneNumber,
    IN HWND hwndEbPhoneNumber,
    IN HWND hwndStCountryCodes,
    IN HWND hwndLbCountryCodes,
    IN HWND hwndCbUseDialingRules,
    IN HWND hwndPbDialingRules,
    IN HWND hwndPbAlternates,
    IN HWND hwndStComment,
    IN HWND hwndEbComment,
    IN DTLLIST* pListAreaCodes )

    // Initialize the context '*pCuInfo' in preparation for using other CuXxx
    // calls.  The 'hwndStPhoneNumber', 'hwndStComment', 'hwndEbComment',
    // 'hwndPbAlternates', and 'pListAreaCodes' arguments may be NULL.  Others
    // are required.
    //
{
    ZeroMemory( pCuInfo, sizeof(*pCuInfo) );

    pCuInfo->hwndStAreaCodes = hwndStAreaCodes;
    pCuInfo->hwndClbAreaCodes = hwndClbAreaCodes;
    pCuInfo->hwndStPhoneNumber = hwndStPhoneNumber;
    pCuInfo->hwndEbPhoneNumber = hwndEbPhoneNumber;
    pCuInfo->hwndStCountryCodes = hwndStCountryCodes;
    pCuInfo->hwndLbCountryCodes = hwndLbCountryCodes;
    pCuInfo->hwndCbUseDialingRules = hwndCbUseDialingRules;
    pCuInfo->hwndPbDialingRules = hwndPbDialingRules;
    pCuInfo->hwndPbAlternates = hwndPbAlternates;
    pCuInfo->hwndStComment = hwndStComment;
    pCuInfo->hwndEbComment = hwndEbComment;
    pCuInfo->pListAreaCodes = pListAreaCodes;

    // Disaster defaults only.  Not used in normal operation.
    //
    pCuInfo->dwCountryId = 1;
    pCuInfo->dwCountryCode = 1;

    Edit_LimitText( pCuInfo->hwndEbPhoneNumber, RAS_MaxPhoneNumber );

    if (pCuInfo->hwndEbComment)
    {
        Edit_LimitText( pCuInfo->hwndEbComment, RAS_MaxDescription );
    }
}


VOID
CuSaveToAreaCodeList(
    IN CUINFO* pCuInfo,
    IN TCHAR* pszAreaCode )

    // Adds 'pszAreaCode' to the top of the list of area codes eliminating any
    // duplicate farther down in the list.
    //
{
    DTLNODE* pNodeNew;
    DTLNODE* pNode;

    TRACE( "CuSaveToAreaCodeList" );

    if (!pszAreaCode || IsAllWhite( pszAreaCode ) || !pCuInfo->pListAreaCodes)
    {
        return;
    }

    // Create a new node for the current area code and add it to the list
    // head.
    //
    pNodeNew = CreatePszNode( pszAreaCode );
    if (!pNodeNew)
    {
        return;
    }

    DtlAddNodeFirst( pCuInfo->pListAreaCodes, pNodeNew );

    // Delete any other occurrence of the same area code later in the
    // list.
    //
    pNode = DtlGetNextNode( pNodeNew );

    while (pNode)
    {
        TCHAR* psz;
        DTLNODE* pNodeNext;

        pNodeNext = DtlGetNextNode( pNode );

        psz = (TCHAR* )DtlGetData( pNode );
        if (lstrcmp( psz, pszAreaCode ) == 0)
        {
            DtlRemoveNode( pCuInfo->pListAreaCodes, pNode );
            DestroyPszNode( pNode );
        }

        pNode = pNodeNext;
    }
}


VOID
CuSetInfo(
    IN CUINFO* pCuInfo,
    IN DTLNODE* pPhoneNode,
    IN BOOL fDisableAll )

    // Set the controls for context 'pCuInfo' to the PBPHONE node 'pPhoneNode'
    // values.  'FDisableAll' indicates the controls are disabled, meaning a
    // group disable, not a no dialing rules disable.
    //
{
    PBPHONE* pPhone;
    BOOL fEnableAny;
    BOOL fEnableComplex;

    TRACE( "CuSetInfo" );

    pPhone = (PBPHONE* )DtlGetData( pPhoneNode );
    ASSERT( pPhone );

    // Update "blanked" values.
    //
    Free0( pCuInfo->pszAreaCode );
    pCuInfo->pszAreaCode = StrDup( pPhone->pszAreaCode );
    pCuInfo->dwCountryId = pPhone->dwCountryID;
    pCuInfo->dwCountryCode = pPhone->dwCountryCode;

    SetWindowText(
        pCuInfo->hwndEbPhoneNumber, UnNull( pPhone->pszPhoneNumber ) );
    Button_SetCheck(
        pCuInfo->hwndCbUseDialingRules, pPhone->fUseDialingRules );

    if (pPhone->fUseDialingRules)
    {
        CuUpdateCountryCodeLb( pCuInfo, FALSE );
        CuUpdateAreaCodeClb( pCuInfo );
    }
    else
    {
        ComboBox_ResetContent( pCuInfo->hwndClbAreaCodes );
        CuClearCountryCodeLb( pCuInfo );
    }

    // Enable/disable controls.
    //
    fEnableAny = !fDisableAll;
    fEnableComplex = (pPhone->fUseDialingRules && fEnableAny);

    EnableWindow( pCuInfo->hwndStAreaCodes, fEnableComplex );
    EnableWindow( pCuInfo->hwndClbAreaCodes, fEnableComplex );
    EnableWindow( pCuInfo->hwndEbPhoneNumber, fEnableAny );
    EnableWindow( pCuInfo->hwndStCountryCodes, fEnableComplex );
    EnableWindow( pCuInfo->hwndLbCountryCodes, fEnableComplex );
    EnableWindow( pCuInfo->hwndPbDialingRules, fEnableComplex );

    if (pCuInfo->hwndStPhoneNumber)
    {
        EnableWindow( pCuInfo->hwndStPhoneNumber, fEnableAny );
    }

    if (pCuInfo->hwndPbAlternates)
    {
        EnableWindow( pCuInfo->hwndPbAlternates, fEnableAny );
    }

    if (pCuInfo->hwndEbComment)
    {
        SetWindowText( pCuInfo->hwndEbComment, UnNull( pPhone->pszComment ) );
        EnableWindow( pCuInfo->hwndStComment, fEnableAny );
        EnableWindow( pCuInfo->hwndEbComment, fEnableAny );
    }
}


VOID
CuUpdateAreaCodeClb(
    IN CUINFO* pCuInfo )

    // Fill the area code combo-box-list, if necessary, and set the selection
    // to the one in the context.  'PCuInfo' is the complex phone number
    // context.
    //
{
    DTLNODE* pNode;
    INT iSel;

    TRACE( "CuUpdateAreaCodeClb" );

    if (!pCuInfo->pListAreaCodes)
    {
        return;
    }

    ComboBox_ResetContent( pCuInfo->hwndClbAreaCodes );
    ComboBox_LimitText( pCuInfo->hwndClbAreaCodes, RAS_MaxAreaCode );

    // Add caller's list of area codes.
    //
    for (pNode = DtlGetFirstNode( pCuInfo->pListAreaCodes );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* pszAreaCode = (TCHAR* )DtlGetData( pNode );

        ComboBox_AddString( pCuInfo->hwndClbAreaCodes, pszAreaCode );
    }

    // Select the last area code set via CuSetInfo, inserting at the top if
    // it's not already in the list.
    //
    if (pCuInfo->pszAreaCode && *(pCuInfo->pszAreaCode))
    {
        iSel = ComboBox_FindStringExact(
            pCuInfo->hwndClbAreaCodes, -1, pCuInfo->pszAreaCode );
        if (iSel < 0)
        {
            ComboBox_InsertString(
                pCuInfo->hwndClbAreaCodes, 0, pCuInfo->pszAreaCode );
            iSel = 0;
        }

        ComboBox_SetCurSel( pCuInfo->hwndClbAreaCodes, iSel );
    }

    ComboBox_AutoSizeDroppedWidth( pCuInfo->hwndClbAreaCodes );
}


VOID
CuUpdateCountryCodeLb(
    IN CUINFO* pCuInfo,
    IN BOOL fComplete )

    // Fill the country code dropdown and set the selection.  'FComplete'
    // indicates the entire list should be loaded, otherwise only the selected
    // item is loaded.  'PCuInfo' is the complex phone number context.
    //
{
    DWORD dwErr;
    BOOL fSelectionOk;
    COUNTRY* pCountries;
    COUNTRY* pCountry;
    DWORD cCountries;
    DWORD i;
    INT iSel;

    TRACE1( "CuUpdateCountryCodeLb(f=%d)", fComplete );

    // See if the current selection is the one to select.  If so, and it's not
    // a partial list when a complete list was requested, there's no need
    // to do anything further.
    //
    iSel = ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes );
    if (iSel >= 0)
    {
        pCountry = (COUNTRY* )ComboBox_GetItemDataPtr(
            pCuInfo->hwndLbCountryCodes, iSel );

        if (pCountry
            && pCountry != (VOID* )-1
            && pCountry != (VOID* )1
            && (pCountry->dwId == pCuInfo->dwCountryId)
            && (!fComplete || pCuInfo->fComplete))
        {
            return;
        }
    }

    // ...otherwise, clear the list in preparation for reload.
    //
    CuClearCountryCodeLb( pCuInfo );
    pCountries = NULL;
    cCountries = 0;

    dwErr = GetCountryInfo( &pCountries, &cCountries,
                (fComplete) ? 0 : pCuInfo->dwCountryId );
    if (dwErr == 0)
    {
        if (!fComplete)
        {
            // Add dummy item first in partial list so left arrow selection
            // change can be handled correctly.  See CBN_SELCHANGE handling.
            //
            ComboBox_AddItem(
                pCuInfo->hwndLbCountryCodes, TEXT("AAAAA"), (VOID* )-1 );
        }

        for (i = 0, pCountry = pCountries;
             i < cCountries;
             ++i, ++pCountry)
        {
            INT iItem;
            TCHAR szBuf[ 512 ];

            wsprintf( szBuf, TEXT("%s (%d)"),
                pCountry->pszName, pCountry->dwCode );
            iItem = ComboBox_AddItem(
                pCuInfo->hwndLbCountryCodes, szBuf, pCountry );

            // If it's the one in the entry, select it.
            //
            if (pCountry->dwId == pCuInfo->dwCountryId)
            {
                ComboBox_SetCurSel( pCuInfo->hwndLbCountryCodes, iItem );
            }
        }

        if (!fComplete)
        {
            // Add dummy item last in partial list so right arrow selection
            // change can be handled correctly.  See CBN_SELCHANGE handling.
            //
            ComboBox_AddItem(
                pCuInfo->hwndLbCountryCodes, TEXT("ZZZZZ"), (VOID* )1 );
        }

        ComboBox_AutoSizeDroppedWidth( pCuInfo->hwndLbCountryCodes );

        if (dwErr == 0 && cCountries == 0)
        {
            dwErr = ERROR_TAPI_CONFIGURATION;
        }
    }

    if (dwErr != 0)
    {
        ErrorDlg( GetParent( pCuInfo->hwndLbCountryCodes ),
            SID_OP_LoadTapiInfo, dwErr, NULL );
        return;
    }

    if (ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes ) < 0)
    {
        // The entry's country code was not added to the list, so as an
        // alternate select the first country in the list, loading the whole
        // list if necessary...should be extremely rare, a diddled phonebook
        // or TAPI country list strangeness.
        //
        if (ComboBox_GetCount( pCuInfo->hwndLbCountryCodes ) > 0)
        {
            ComboBox_SetCurSel( pCuInfo->hwndLbCountryCodes, 0 );
        }
        else
        {
            FreeCountryInfo( pCountries, cCountries );
            CuUpdateCountryCodeLb( pCuInfo, TRUE );
            return;
        }
    }

    // Will be freed by CuFree.
    //
    pCuInfo->pCountries = pCountries;
    pCuInfo->cCountries = cCountries;
    pCuInfo->fComplete = fComplete;
}


//----------------------------------------------------------------------------
// Scripting utility routines (Su utilities)
// Listed alphabetically
//----------------------------------------------------------------------------

BOOL
SuBrowsePbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification )

    // Handle the WM_COMMAND notification to the "browse" button control.
    // 'PSuInfo' is the script utility context.  'WNotification' is the wparam
    // of the WM_COMMAND notification.
    //
    // 'PSuInfo' is the script utility context.
    //
{
    OPENFILENAME ofn;
    TCHAR* pszFilterDesc;
    TCHAR* pszFilter;
    TCHAR* pszDefExt;
    TCHAR* pszTitle;
    TCHAR szBuf[ MAX_PATH + 1 ];
    TCHAR szDir[ MAX_PATH + 1 ];
    TCHAR szFilter[ 64 ];

    if (wNotification != BN_CLICKED)
    {
        return FALSE;
    }

    // Fill in FileOpen dialog parameter buffer.
    //
    pszFilterDesc = PszFromId( g_hinstDll, SID_ScpFilterDesc );
    pszFilter = PszFromId( g_hinstDll, SID_ScpFilter );
    if (pszFilterDesc && pszFilter)
    {
        DWORD dwLen = 0, dwSize = sizeof(szFilter) / sizeof(TCHAR);
        
        ZeroMemory( szFilter, sizeof(szFilter) );
        lstrcpyn( szFilter, pszFilterDesc, dwSize);
        dwLen = lstrlen( szFilter ) + 1;
        lstrcpyn( szFilter + dwLen, pszFilter, dwSize - dwLen );
    }
    Free0( pszFilterDesc );
    Free0( pszFilter );

    pszTitle = PszFromId( g_hinstDll, SID_ScpTitle );
    pszDefExt = PszFromId( g_hinstDll, SID_ScpDefExt );
    szBuf[ 0 ] = TEXT('\0');
    szDir[ 0 ] = TEXT('\0');

    // Saying "Alternate" rather than "System" here gives us the old NT
    // phonebook location rather than the new NT5 location, which for
    // scripts, is what we want.
    //
    GetPhonebookDirectory( PBM_Alternate, szDir );

    ZeroMemory( &ofn, sizeof(ofn) );
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = GetParent( pSuInfo->hwndLbScripts );
    ofn.hInstance = g_hinstDll;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szBuf;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = szDir;
    ofn.lpstrTitle = pszTitle;
    ofn.lpstrDefExt = pszDefExt;
    ofn.Flags = OFN_HIDEREADONLY;

    if (GetOpenFileName (&ofn))
    {
        SetWindowText( pSuInfo->hwndLbScripts, ofn.lpstrFile );
    }

    Free0( pszTitle );
    Free0( pszDefExt );

    return TRUE;
}


BOOL
SuEditPbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification )

    // Handle the WM_COMMAND notification to the "edit" button control.
    // 'PSuInfo' is the script utility context.  'WNotification' is the wparam
    // of the WM_COMMAND notification.
    //
    // 'PSuInfo' is the script utility context.
    //
{
    TCHAR* psz;

    if (wNotification != BN_CLICKED)
    {
        return FALSE;
    }

    psz = GetText( pSuInfo->hwndLbScripts );
    if (psz)
    {
        HWND hwndDlg = GetParent( pSuInfo->hwndPbEdit );

        if (FFileExists( psz ))
        {
            SuEditScpScript( hwndDlg, psz );
        }
        else
        {
            SuEditSwitchInf( hwndDlg );
        }

        Free( psz );
    }

    return TRUE;
}


VOID
SuEditScpScript(
    IN HWND   hwndOwner,
    IN TCHAR* pszScript )

    // Starts notepad.exe on the 'pszScript' script path.  'HwndOwner' is the
    // window to center any error popup on.
    //
{
    TCHAR szCmd[ (MAX_PATH * 2) + 50 + 1 ];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL f;

    wsprintf( szCmd, TEXT("notepad.exe %s"), pszScript );

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);

    TRACEW1( "SuEditScp-cmd=%s", szCmd );

    f = CreateProcess(
            NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi );
    if (f)
    {
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
    }
    else
    {
        ErrorDlg( hwndOwner, SID_OP_LoadSwitchEditor, GetLastError(), NULL );
    }
}


VOID
SuEditSwitchInf(
    IN HWND hwndOwner )

    // Starts notepad.exe on the system script file, switch.inf.  'HwndOwner'
    // is the window to center any error popup on.
    //
{
    TCHAR szCmd[ (MAX_PATH * 2) + 50 + 1 ];
    TCHAR szSysDir[ MAX_PATH + 1 ];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL f;

    szSysDir[ 0 ] = TEXT('\0');
    g_pGetSystemDirectory( NULL, szSysDir, MAX_PATH );

    wsprintf( szCmd, TEXT("notepad.exe %s\\ras\\switch.inf"), szSysDir );

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);

    TRACEW1( "SuEditInf-cmd=%s", szCmd );

    f = CreateProcess(
            NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi );

    if (f)
    {
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
    }
    else
    {
        ErrorDlg( hwndOwner, SID_OP_LoadSwitchEditor, GetLastError(), NULL );
    }
}


VOID
SuFillDoubleScriptsList(
    IN SUINFO* pSuInfo )

    // Fill scripts list in context 'pSuInfo' with switch.inf entries and .SCP
    // file entries.  The old list, if any, is freed.  Select the script
    // selection in the context or "(none)" if none.  If the name is non-NULL
    // but not found in the list it is appended.  Caller must eventually call
    // DtlDestroyList on the returned list.
    //
{
    DWORD dwErr;
    DTLNODE* pNode;
    INT nIndex;
    DTLLIST* pList;
    DTLLIST* pListScp;

    TRACE( "SuFillDoubleScriptsList" );

    ComboBox_ResetContent( pSuInfo->hwndLbScripts );
    ComboBox_AddItemFromId(
        g_hinstDll, pSuInfo->hwndLbScripts, SID_NoneSelected, NULL );
    ComboBox_SetCurSel( pSuInfo->hwndLbScripts, 0 );

    pList = NULL;
    dwErr = LoadScriptsList( pSuInfo->hConnection, &pList );
    if (dwErr != 0)
    {
        ErrorDlg( GetParent( pSuInfo->hwndLbScripts ),
            SID_OP_LoadScriptInfo, dwErr, NULL );
        return;
    }

    pListScp = NULL;
    dwErr = SuLoadScpScriptsList( &pListScp );
    if (dwErr == 0)
    {
        while (pNode = DtlGetFirstNode( pListScp ))
        {
            DtlRemoveNode( pListScp, pNode );
            DtlAddNodeLast( pList, pNode );
        }

        DtlDestroyList( pListScp, NULL );
    }

    DtlDestroyList( pSuInfo->pList, DestroyPszNode );
    pSuInfo->pList = pList;

    for (pNode = DtlGetFirstNode( pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz;

        psz = (TCHAR* )DtlGetData( pNode );
        nIndex = ComboBox_AddString( pSuInfo->hwndLbScripts, psz );

        if (pSuInfo->pszSelection
            && lstrcmp( psz, pSuInfo->pszSelection ) == 0)
        {
            ComboBox_SetCurSel( pSuInfo->hwndLbScripts, nIndex );
        }
    }

    if (pSuInfo->pszSelection
        && ComboBox_GetCurSel( pSuInfo->hwndLbScripts ) <= 0
        && lstrcmp( pSuInfo->pszSelection,
               PszLoadString( g_hinstDll, SID_NoneSelected ) ) != 0)
    {
        nIndex = ComboBox_AddString(
            pSuInfo->hwndLbScripts, pSuInfo->pszSelection );
        if (nIndex >= 0)
        {
            ComboBox_SetCurSel( pSuInfo->hwndLbScripts, nIndex );
        }
    }

    ComboBox_AutoSizeDroppedWidth( pSuInfo->hwndLbScripts );
}


#if 0
VOID
SuFillScriptsList(
    IN EINFO* pEinfo,
    IN HWND hwndLbScripts,
    IN TCHAR* pszSelection )

    // Fill scripts list in working entry of common entry context 'pEinfo'.
    // The old list, if any, is freed.  Select the script from user's entry.
    // 'HwndLbScripts' is the script dropdown.  'PszSelection' is the selected
    // name from the phonebook or NULL for "(none)".  If the name is non-NULL
    // but not found in the list it is appended.
    //
{
    DWORD dwErr;
    DTLNODE* pNode;
    INT nIndex;
    DTLLIST* pList;

    TRACE( "SuFillScriptsList" );

    ComboBox_ResetContent( hwndLbScripts );
    ComboBox_AddItemFromId(
        g_hinstDll, hwndLbScripts, SID_NoneSelected, NULL );
    ComboBox_SetCurSel( hwndLbScripts, 0 );

    pList = NULL;
    dwErr = LoadScriptsList( &pList );
    if (dwErr != 0)
    {
        ErrorDlg( GetParent( hwndLbScripts ),
            SID_OP_LoadScriptInfo, dwErr, NULL );
        return;
    }

    DtlDestroyList( pEinfo->pListScripts, DestroyPszNode );
    pEinfo->pListScripts = pList;

    for (pNode = DtlGetFirstNode( pEinfo->pListScripts );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz;

        psz = (TCHAR* )DtlGetData( pNode );
        nIndex = ComboBox_AddString( hwndLbScripts, psz );

        if (pszSelection && lstrcmp( psz, pszSelection ) == 0)
        {
            ComboBox_SetCurSel( hwndLbScripts, nIndex );
        }
    }

    if (pszSelection && ComboBox_GetCurSel( hwndLbScripts ) <= 0)
    {
        nIndex = ComboBox_AddString( hwndLbScripts, pszSelection );
        if (nIndex >= 0)
        {
            ComboBox_SetCurSel( hwndLbScripts, nIndex );
        }
    }

    ComboBox_AutoSizeDroppedWidth( hwndLbScripts );
}
#endif


VOID
SuFree(
    IN SUINFO* pSuInfo )

    // Free resources attached to the 'pSuInfo' context.
    //
{
    if (pSuInfo->pList)
    {
        DtlDestroyList( pSuInfo->pList, DestroyPszNode );
        pSuInfo->pList = NULL;
    }

    Free0( pSuInfo->pszSelection );
}


VOID
SuGetInfo(
    IN SUINFO* pSuInfo,
    OUT BOOL* pfScript,
    OUT BOOL* pfTerminal,
    OUT TCHAR** ppszScript )

    // Load the scripting information from the controls into caller's output
    // arguments.  'PSuInfo' is the complex phone number context.
    //
{
    // Whistler 308135 Dialup Scripting: Pre-Dial scripts can be selected but
    // are not executed
    //
    if (pSuInfo->hwndCbTerminal && !(pSuInfo->dwFlags & SU_F_DisableTerminal))
    {
        if (pfTerminal)
        {
            *pfTerminal = Button_GetCheck( pSuInfo->hwndCbTerminal );
        }
    }
    else
    {
        if (pfTerminal)
        {
            *pfTerminal = FALSE;
        }
    }

    if (pSuInfo->dwFlags & SU_F_DisableScripting)
    {
        if (pfScript)
        {
            *pfScript = FALSE;
        }

        if (ppszScript)
        {
            *ppszScript = NULL;
        }
    }
    else
    {
        if (pfScript)
        {
            *pfScript = Button_GetCheck( pSuInfo->hwndCbRunScript );
        }

        if (ppszScript)
        {
            *ppszScript = GetText( pSuInfo->hwndLbScripts );
        }
    }

    // Silently fix up "no script selected" error.
    //
    if (pfScript && *pfScript)
    {
        TCHAR* pszNone;

        pszNone = PszFromId( g_hinstDll, SID_NoneSelected );

        if (!ppszScript || !*ppszScript
            || !pszNone || lstrcmp( pszNone, *ppszScript ) == 0)
        {
            *pfScript = FALSE;
        }

        Free0( pszNone );
    }
}


VOID
SuInit(
    IN SUINFO* pSuInfo,
    IN HWND hwndCbRunScript,
    IN HWND hwndCbTerminal,
    IN HWND hwndLbScripts,
    IN HWND hwndPbEdit,
    IN HWND hwndPbBrowse,
    IN DWORD dwFlags)

    // Initialize the scripting context 'pSuInfo'.  The window handles are the
    // controls to be managed.  'PSuInfo' is the script utility context.
    //
{
    if( NULL == pSuInfo)
    {
        return;
    }
    
    pSuInfo->hwndCbRunScript = hwndCbRunScript;
    pSuInfo->hwndCbTerminal = hwndCbTerminal;
    pSuInfo->hwndLbScripts = hwndLbScripts;
    pSuInfo->hwndPbEdit = hwndPbEdit;
    pSuInfo->hwndPbBrowse = hwndPbBrowse;
    pSuInfo->dwFlags = dwFlags;

    if (pSuInfo->dwFlags & SU_F_DisableTerminal)
    {
        // For whistler 467262
        //
        if(pSuInfo->hwndCbTerminal)
        {
            Button_SetCheck(pSuInfo->hwndCbTerminal, FALSE);
            EnableWindow(pSuInfo->hwndCbTerminal, FALSE);
       }
    }
    if (pSuInfo->dwFlags & SU_F_DisableScripting)
    {
        if(pSuInfo->hwndCbRunScript)
        {
            Button_SetCheck(pSuInfo->hwndCbRunScript, FALSE);
            EnableWindow(pSuInfo->hwndCbRunScript, FALSE);
        }

        if(pSuInfo->hwndLbScripts)
        {
            EnableWindow(pSuInfo->hwndLbScripts, FALSE);
        }

        if(pSuInfo->hwndPbEdit)
        {
            EnableWindow(pSuInfo->hwndPbEdit, FALSE);
        }

        if(pSuInfo->hwndPbBrowse)
        {
            EnableWindow(pSuInfo->hwndPbBrowse, FALSE);
        }
    }

    pSuInfo->pList = NULL;
    pSuInfo->pszSelection = NULL;
}


DWORD
SuLoadScpScriptsList(
    OUT DTLLIST** ppList )

    // Loads '*ppList' with a list of Psz nodes containing the pathnames of
    // the .SCP files in the RAS directory.  It is caller's responsibility to
    // call DtlDestroyList on the returned list.
    //
    // Returns 0 if successful or an error code.
    //
{
    UINT cch;
    TCHAR szPath[ MAX_PATH ];
    TCHAR* pszFile;
    WIN32_FIND_DATA data;
    HANDLE h;
    DTLLIST* pList;

    cch = g_pGetSystemDirectory( NULL, szPath, MAX_PATH );
    if (cch == 0)
    {
        return GetLastError();
    }

    pList = DtlCreateList( 0L );
    if (!pList)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    lstrcat( szPath, TEXT("\\ras\\*.scp") );

    h = FindFirstFile( szPath, &data );
    if (h != INVALID_HANDLE_VALUE)
    {
        // Find the address of the file name part of the path since the 'data'
        // provides only the filename and not the rest of the path.
        //
        pszFile = szPath + lstrlen( szPath ) - 5;

        do
        {
            DTLNODE* pNode;

            // Ignore any directories that happen to match.
            //
            if (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                continue;
            }

            // Create a Psz node with the path to the found file and append it
            // to the end of the list.
            //
            // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
            //
            lstrcpyn(
                pszFile,
                data.cFileName,
                MAX_PATH - lstrlen( szPath ) - 5 );
            pNode = CreatePszNode( szPath );
            if (!pNode)
            {
                continue;
            }

            DtlAddNodeLast( pList, pNode );
        }
        while (FindNextFile( h, &data ));

        FindClose( h );
    }

    *ppList = pList;
    return 0;
}


BOOL
SuScriptsCbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification )

    // Handle the WM_COMMAND notification to the "run scripts" checkbox
    // control.  'PSuInfo' is the script utility context.  'WNotification' is
    // the wparam of the WM_COMMAND notification.
    //
{
    if (wNotification != BN_CLICKED)
    {
        return FALSE;
    }

    SuUpdateScriptControls( pSuInfo );

    return TRUE;
}


VOID
SuSetInfo(
    IN SUINFO* pSuInfo,
    IN BOOL fScript,
    IN BOOL fTerminal,
    IN TCHAR* pszScript )

    // Set the controls for context 'pSuInfo' to the argument values.
    //
{
    Free0( pSuInfo->pszSelection );
    pSuInfo->pszSelection = StrDup( pszScript );

    if (pSuInfo->hwndCbTerminal && !(pSuInfo->dwFlags & SU_F_DisableTerminal))
    {
        Button_SetCheck( pSuInfo->hwndCbTerminal, fTerminal );
    }      
    if (!(pSuInfo->dwFlags & SU_F_DisableScripting))
    {
        Button_SetCheck( pSuInfo->hwndCbRunScript, fScript );
    }

    SuFillDoubleScriptsList( pSuInfo );

    SuUpdateScriptControls( pSuInfo );
}


VOID
SuUpdateScriptControls(
    IN SUINFO* pSuInfo )

    // Update the enable/disable state of the script controls based on the
    // "run script" check box setting.  'PSuInfo' is the script utility
    // context.
    //
{
    BOOL fCheck;

    fCheck = Button_GetCheck( pSuInfo->hwndCbRunScript );

    if (fCheck)
    {
        if (!pSuInfo->pList)
        {
            // Fill the script list with both SWITCH.INF and .SCP scripts.
            //
            SuFillDoubleScriptsList( pSuInfo );
        }
    }
    else
    {
        // Clear the list contents in addition to disabling, per spec.  The
        // current selection is saved off so if user re-checks the box his
        // last selection will show.
        //
        Free0( pSuInfo->pszSelection );
        pSuInfo->pszSelection = GetText( pSuInfo->hwndLbScripts );

        ComboBox_ResetContent( pSuInfo->hwndLbScripts );
        DtlDestroyList( pSuInfo->pList, DestroyPszNode );
        pSuInfo->pList = NULL;
    }

    EnableWindow( pSuInfo->hwndLbScripts, fCheck );
    EnableWindow( pSuInfo->hwndPbEdit, fCheck );
    EnableWindow( pSuInfo->hwndPbBrowse, fCheck );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\entryw.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// entryw.c
// Remote Access Common Dialog APIs
// Add Entry wizard
//
// 06/20/95 Steve Cobb
// 11/10/97 Shaun Cox, NT5/Connections rework


#include "rasdlgp.h"
#include "inetcfgp.h"
#include "netcon.h"
#include "rasuip.h"
#include "rassrvp.h"
#include <winscard.h>
#include "hnportmapping.h"
#include <wchar.h>

static int MAX_ENTERCONNECTIONNAME = 200;
DWORD
OpenPhonebookFile(
    BOOL    fForAllUsers,
    PBFILE* pFile )
{
    TCHAR pszPhonebookPath [MAX_PATH];

    pszPhonebookPath[0] = TEXT('\0');

    // Get the correct phonebook file path depending on whether it is
    // for all users or the current one.
    //
    if (fForAllUsers)
    {
        if(!GetPublicPhonebookPath( pszPhonebookPath ))
        {
            return ERROR_CANNOT_OPEN_PHONEBOOK;
        }
    }
    else
    {
        if(!GetPersonalPhonebookPath( NULL, pszPhonebookPath ))
        {
            return ERROR_CANNOT_OPEN_PHONEBOOK;
        }
    }

    return ReadPhonebookFile( pszPhonebookPath, NULL, NULL, 0, pFile );
}

VOID
ReOpenPhonebookFile(
    BOOL    fForAllUsers,
    PBFILE* pFile )
{
    // Close the previous phonebook file.
    //
    if (pFile)
    {
        ClosePhonebookFile( pFile );
    }

    // Open the one corresponding to the selection.
    //
    OpenPhonebookFile( fForAllUsers, pFile );
}


//----------------------------------------------------------------------------
// Local datatypes (alphabetically)
//----------------------------------------------------------------------------

// Add Entry wizard context block.  All property pages refer to the single
// context block associated with the sheet.
//
typedef struct
_AEINFO
{
    // Common input arguments.
    //
    EINFO* pArgs;

    // Wizard and page handles.
    //
    HWND hwndDlg;
    HWND hwndLa;
    HWND hwndMa;
    HWND hwndCn;    //Add for bug 328673
    HWND hwndPa;
    HWND hwndBs;    
    HWND hwndDa;
    HWND hwndPn;
    HWND hwndUs;
    HWND hwndDt;
    HWND hwndEn;
    HWND hwndGh;
    HWND hwndDn;
    HWND hwndSw;
    HWND hwndSp;
    HWND hwndSc;

    // Legacy application page.
    //
    HFONT hfontBold;

    // Modem/Adapter page.
    //
    HWND hwndLv;

    // Connection Name page.
    //
    HWND hwndCnName;
    HWND hwndCnStHMsg;
    HWND hwndCnStHMsg2;
    HWND hwndCnEbConnectionName;    //Add for bug 328673
    BOOL fCnWizNext;              //if Back button is pressed

    // Phone number page.
    //
    HWND hwndEbNumber;

    // Smart Card page
    //
    HWND hwndScRbYes;
    HWND hwndScRbNo;

    // Destination page.
    //
    HWND hwndEbHostName;

    // Broadband service page
    //
    HWND hwndEbBroadbandService;

    // Public network page.
    //
    HWND hwndLbDialFirst;

    // Entry Name page.
    //
    HWND hwndEbEntryName;

    // Shared Access private-lan page
    //
    HWND hwndSpLbPrivateLan;

    // User/default connection windows
    //
    HWND hwndUsRbForAll;
    HWND hwndUsRbForMe;

    HWND hwndDtCbFirewall;          //add for whistler bug 328673
    HWND hwndDtCbDefault;
    HWND hwndDtCbUseCredentials;
    HWND hwndDtEbUserName;
    HWND hwndDtEbPassword;
    HWND hwndDtEbPassword2;
    HWND hwndDtStUserName;
    HWND hwndDtStPassword;
    HWND hwndDtStPassword2;

    // Set true when there is only one meaningful choice of device.
    //
    BOOL fSkipMa;

    // Set true if the selected device is a modem or null modem.
    //
    BOOL fModem;

    // Set to true if there are no connections to show on the public
    // network page and therefore no reason to show the page.
    //
    BOOL fHidePublicNetworkPage;

    // Set true if administrator/power user wants the entry available to all
    // users.
    //
    BOOL fCreateForAllUsers;
    BOOL fFirewall;     //for whistler bug 328673 

    // The NB_* mask of protocols configured for RAS.
    //
    DWORD dwfConfiguredProtocols;

    // Set true if IP is configured for RAS.
    //
    BOOL fIpConfigured;

    // Area-code and country-code helper context block, and a flag indicating
    // if the block has been initialized.
    //
    CUINFO cuinfo;
    BOOL fCuInfoInitialized;

    // List of area codes passed CuInit plus all strings retrieved with
    // CuGetInfo.  The list is an editing duplicate of the one from the
    // PBUSER.
    //
    DTLLIST* pListAreaCodes;

    // Scripting utility context block, and a flag indicating if the block has
    // been initialized.
    //
    SUINFO suinfo;
    BOOL fSuInfoInitialized;

    // Set to true if we want to show the host pages in the dcc wizard, false
    // otherwise.  If true, rassrvui will administer most of the wizard.
    BOOL fDccHost;

    // The context used to identify the modifications being made through the
    // dcc host wizard
    PVOID pvDccHostContext;

    // Flags that track whether a smart card reader is installed and whether
    // the user has opted to use it.
    BOOL fSmartCardInstalled;
    BOOL fUseSmartCard;

    // Modem device dialog
    BOOL fMaAlreadyInitialized;

    //For Isdn devices on Ma page, for whislter bug 354542
    //
    BOOL fMultilinkAllIsdn;

    // For whistler bug 453704          gangz
    //
    BOOL fEnBack;
}
AEINFO;


//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

AEINFO*
AeContext(
    IN HWND hwndPage );

void
AeSetContext(
    IN HWND   hwndPage,
    IN LPARAM lparam);

void
AeFinish(
    IN AEINFO* pInfo );

DWORD
AeInit(
    IN HWND         hwndOwner,
    IN EINFO*       pEinfo,
    OUT AEINFO**    ppInfo );

VOID
AeTerm(
    IN AEINFO* pInfo );

BOOL
ApCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
BsDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
BsInit(
    IN HWND hwndPage );

BOOL
BsKillActive(
    IN AEINFO* pInfo );

BOOL
BsSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
CnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CnInit(
    IN HWND hwndPage );

BOOL
CnKillActive(
    IN AEINFO* pInfo );

BOOL
CnSetActive(
    IN AEINFO* pInfo );

BOOL
CnCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
DaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DaInit(
    IN HWND hwndPage );

BOOL
DaKillActive(
    IN AEINFO* pInfo );

BOOL
DaSetActive(
    IN AEINFO* pInfo );

BOOL
DnCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
DnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DtCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );
    
BOOL
DnInit(
    IN HWND hwndPage );

BOOL
DnKillActive(
    IN AEINFO* pInfo );

BOOL
DnSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
DtDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DtInit(
    IN HWND hwndPage );

BOOL
DtKillActive(
    IN AEINFO* pInfo );

BOOL
DtSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
EnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
EnInit(
    IN HWND hwndPage );

BOOL
EnKillActive(
    IN AEINFO* pInfo );

BOOL
EnSetActive(
    IN AEINFO* pInfo );

BOOL
GhCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
GhDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
GhInit(
    IN HWND hwndPage );

BOOL
GhKillActive(
    IN AEINFO* pInfo );

BOOL
GhSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
LaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
LaInit(
    IN HWND hwndPage );

BOOL
LaKillActive(
    IN AEINFO* pInfo );

BOOL
LaSetActive(
    IN AEINFO* pInfo );


INT_PTR CALLBACK
MaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
MaInit(
    IN HWND hwndPage );

LVXDRAWINFO*
MaLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

BOOL
MaSetActive(
    IN AEINFO* pInfo );

BOOL
MaKillActive(
    IN AEINFO* pInfo );

BOOL
PaCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
PaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
PaInit(
    IN HWND hwndPage );

BOOL
PaKillActive(
    IN AEINFO* pInfo );

BOOL
PaSetActive(
    IN AEINFO* pInfo );

VOID
PnClearLbDialFirst(
    IN HWND hwndLbDialFirst );

INT_PTR CALLBACK
PnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
PnInit(
    IN HWND hwndPage );

BOOL
PnKillActive(
    IN AEINFO* pInfo );

BOOL
PnSetActive(
    IN AEINFO* pInfo );

VOID
PnDialAnotherFirstSelChange(
    IN AEINFO* pInfo );

VOID
PnUpdateLbDialAnotherFirst(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
ScDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ScInit(
    IN HWND hwndPage );

BOOL
ScKillActive(
    IN AEINFO* pInfo );

BOOL
ScSetActive(
    IN AEINFO* pInfo );

BOOL
ScSmartCardReaderInstalled(
    IN AEINFO* pInfo);

INT_PTR CALLBACK
SpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SpInit(
    IN HWND hwndPage );

BOOL
SpKillActive(
    IN AEINFO* pInfo );

BOOL
SpSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
StDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
StInit(
    IN HWND hwndPage,
    IN OUT AEINFO* pInfo );

BOOL
StKillActive(
    IN AEINFO* pInfo );

BOOL
StSetActive(
    IN AEINFO* pInfo );

BOOL
SwCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
SwDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SwInit(
    IN HWND hwndPage );

BOOL
SwKillActive(
    IN AEINFO* pInfo );

BOOL
SwSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
UsDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
UsInit(
    IN HWND hwndPage );

BOOL
UsKillActive(
    IN AEINFO* pInfo );

BOOL
UsSetActive(
    IN AEINFO* pInfo );

// NOTICE-2002/05/20 - DavePr -- found this anonymous comment while cleaning up (DLGPROC)
// This is as good of a hack as I could think of to incorporate the direct
// connect host ui wizard pages without actually exposing the resources and
// functions that implement them (which are in the project, rassrvui)
#define DCC_HOST_PROCID ((DLGPROC)0x1)

struct PAGE_INFO
{
    DLGPROC     pfnDlgProc;
    INT         nPageId;
    INT         nSidTitle;
    INT         nSidSubtitle;
    DWORD       dwConnectionFlags;
};

static const struct PAGE_INFO c_aWizInfo [] =
{
    { 
        StDlgProc, 
        PID_ST_Start,           
        0,            
        0,               
        RASEDFLAG_AnyNewEntry | RASEDFLAG_CloneEntry
    },
    
    { 
        LaDlgProc, 
        PID_LA_NameAndType,     
        SID_LA_Title, 
        SID_LA_Subtitle, 
        RASEDFLAG_NewEntry 
    },
    
    { 
        MaDlgProc, 
        PID_MA_ModemAdapter,    
        SID_MA_Title, 
        SID_MA_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewPhoneEntry  
    },

//put Guest/Host page before Connection Name page for bug 328673
//
    { 
        GhDlgProc, 
        PID_GH_GuestHost,       
        SID_GH_Title, 
        SID_GH_Subtitle, 
        RASEDFLAG_NewDirectEntry 
    },


//Add a new wizard page to get Connection Name, this is not available for rasphone.exe
//for whistler bug 328673       gangz
//
    {
        CnDlgProc,
        PID_CN_ConnectionName,
        SID_CN_Title,
        SID_CN_SubtitleInternet,
        RASEDFLAG_AnyNewEntry | RASEDFLAG_ShellOwned
    },
    
    { 
        PaDlgProc, 
        PID_PA_PhoneNumber,     
        SID_PA_Title, 
        SID_PA_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewPhoneEntry  
    },
    
    { 
        PnDlgProc, 
        PID_PN_PublicNetwork,   
        SID_PN_Title, 
        SID_PN_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewTunnelEntry 
    },
    
    { 
        DaDlgProc, 
        PID_DA_VpnDestination,  
        SID_DA_Title, 
        SID_DA_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewTunnelEntry 
    },
    
    { 
        BsDlgProc, 
        PID_BS_BroadbandService,
        SID_BS_Title, 
        SID_BS_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewBroadbandEntry 
    },
    
    { 
        ScDlgProc, 
        PID_SC_SmartCard,       
        SID_SC_Title, 
        SID_SC_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewPhoneEntry | RASEDFLAG_NewTunnelEntry  
    },
    
    { 
        DnDlgProc, 
        PID_DN_DccDevice,       
        SID_DN_Title, 
        SID_DN_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewDirectEntry 
    },
    
    { 
        DCC_HOST_PROCID,          
        0,       
        0, 
        0, 
        RASEDFLAG_NewDirectEntry 
    },
    
    { 
        UsDlgProc, 
        PID_US_Users,           
        SID_US_Title, 
        SID_US_Subtitle, 
        RASEDFLAG_AnyNewEntry | RASEDFLAG_ShellOwned 
    },
    
    { 
        DtDlgProc, 
        PID_DT_DefaultInternet, 
        SID_DT_Title, 
        SID_DT_Subtitle, 
        RASEDFLAG_AnyNewEntry | RASEDFLAG_ShellOwned 
    },
    
    { 
        SwDlgProc, 
        PID_SW_SharedAccess,    
        SID_SW_Title, 
        SID_SW_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewPhoneEntry | RASEDFLAG_NewTunnelEntry | RASEDFLAG_NewBroadbandEntry
    },
    
    { 
        SpDlgProc, 
        PID_SP_SharedLan,       
        SID_SP_Title, 
        SID_SP_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewPhoneEntry | RASEDFLAG_NewTunnelEntry | RASEDFLAG_NewBroadbandEntry 
    },
    
    { 
        EnDlgProc, 
        PID_EN_EntryName,       
        SID_EN_Title, 
        SID_EN_Subtitle, 
        RASEDFLAG_AnyNewEntry | RASEDFLAG_CloneEntry 
    },
};
#define c_cWizPages    (sizeof (c_aWizInfo) / sizeof(c_aWizInfo[0]))

//----------------------------------------------------------------------------
// Private exports - New client connection wizard
//----------------------------------------------------------------------------

DWORD
APIENTRY
NccCreateNewEntry(
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwPbkFile,
    OUT LPWSTR  pszwEntryName,
    OUT DWORD*  pdwFlags)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fIcRunning = FALSE;

    if (!pvData || !pszwPbkFile || !pszwEntryName || !pdwFlags)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        AEINFO* pInfo = (AEINFO*)pvData;

        // If the direct connect wizard went down the host path, then we
        // need to instruct the shell to create the "Incoming Connections"
        // connection.
        if (pInfo->fDccHost)
        {
            RassrvCommitSettings (pInfo->pvDccHostContext, RASWIZ_TYPE_DIRECT);
            *pdwFlags = NCC_FLAG_CREATE_INCOMING;
            return NO_ERROR;
        }

        // Otherwise, create the phone book entry
        ASSERT (pInfo->pArgs->file.pszPath);
        ASSERT (pInfo->pArgs->pEntry->pszEntryName);

        lstrcpynW( pszwPbkFile,   pInfo->pArgs->file.pszPath,         MAX_PATH );
        lstrcpynW( pszwEntryName, pInfo->pArgs->pEntry->pszEntryName, MAX_PATH );
        *pdwFlags = (pInfo->fCreateForAllUsers) ? NCC_FLAG_ALL_USERS : 0;

        //Add this for the Account and password page, only available for consumer
        //platform. for whistler bug 328673         gangz
        //
        if(pInfo->fFirewall)
        {
            *pdwFlags |= NCC_FLAG_FIREWALL;
        }

        AeFinish( pInfo );

        EuCommit( pInfo->pArgs );

        //Setup port mapping for this new connection
        //According to the VPN enable/disable and
        // IC exist/non-exist condition and 
        // if it is a Firewall available platform
        //
        //Detect if Incoming Connection exists 
        //If it is a DccHost connection, SetPortMapping
        //is already done in RassrvCommitSettings()
        //
        if ( pInfo->fFirewall &&    //For bug 342810
             (NO_ERROR == RasSrvIsServiceRunning( &fIcRunning )) && 
             fIcRunning
             )
        {
            HnPMConfigureSingleConnectionGUIDIfVpnEnabled( pInfo->pArgs->pEntry->pGuid, FALSE, NULL );
        }

        dwErr = pInfo->pArgs->pApiArgs->dwError;
    }
    return dwErr;
}

DWORD
APIENTRY
NccGetSuggestedEntryName(
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwSuggestedName)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (!pvData || !pszwSuggestedName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        AEINFO* pInfo = (AEINFO*)pvData;
        PBENTRY* pEntry = pInfo->pArgs->pEntry;
        LPTSTR pszName;

        // If this is a dcc host connection, ask the ras server
        // module for the name.
        if (pInfo->fDccHost)
        {
            WCHAR pszBuf[MAX_PATH];
            DWORD dwSize = MAX_PATH;

            if ((dwErr = RassrvGetDefaultConnectionName(pszBuf, &dwSize)) != NO_ERROR)
                return dwErr;
            
            lstrcpynW(pszwSuggestedName, pszBuf, MAX_PATH);
            return NO_ERROR;
        }


        // If pFile is NULL, it probably means that the wizard page
        // to determine where the phonebook should be stored was never
        // visited.
        //
        if (!pInfo->pArgs->pFile)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            dwErr = GetDefaultEntryName(
                NULL,
                pEntry->dwType,
                FALSE, &pszName );
            if (ERROR_SUCCESS == dwErr)
            {
                // Whistler bug 224074 use only lstrcpyn's to prevent
                // maliciousness
                //
                lstrcpynW( pszwSuggestedName, pszName, MAX_PATH );

                Free( pszName );
            }
        }
    }
    
    return dwErr;
}

DWORD
APIENTRY
NccQueryMaxPageCount()
{
    // Return the number of pages in the array   We subtract
    // 1 from this since DCC_HOST_PROCID takes a space in the array.
    return c_cWizPages - 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   NccSetEntryName
//
//  Purpose:
//
//  Arguments:
//      pvData   []
//      pszwName []
//
//  Returns:    ERROR_SUCCESS, ERROR_INVALID_PARAMETER,
//              ERROR_NOT_ENOUGH_MEMORY or ERROR_DUP_NAME.
//
//  Author:     shaunco   21 Jan 1998
//
//  Notes:
//
DWORD
APIENTRY
NccSetEntryName(
    IN  LPVOID  pvData,
    IN  LPCWSTR pszwName)
{
    DWORD dwErr = ERROR_SUCCESS;
    AEINFO* pInfo = (AEINFO*)pvData;

    if (!pvData || !pszwName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else if (pInfo->fDccHost)
    {
        // dwErr = ERROR_CAN_NOT_COMPLETE;
        dwErr = ERROR_SUCCESS;
    }
    else if (ERROR_SUCCESS == (dwErr = LoadRasapi32Dll()))
    {
        // Validate the entry name against the current phonebook.
        // If we can't open the phonebook, its okay.  It just means
        // it hasn't been created yet.  The name is valid in this case.
        //
        dwErr = g_pRasValidateEntryName (pInfo->pArgs->pFile->pszPath,
                    pszwName);
        if (ERROR_ALREADY_EXISTS == dwErr)
        {
            dwErr = ERROR_DUP_NAME;
        }
        else if ((ERROR_SUCCESS == dwErr) ||
                 (ERROR_CANNOT_OPEN_PHONEBOOK == dwErr))
        {
            PBENTRY* pEntry = pInfo->pArgs->pEntry;

            dwErr = ERROR_SUCCESS;

            Free( pEntry->pszEntryName );
            pEntry->pszEntryName = StrDup( pszwName );
            if (!pEntry->pszEntryName)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Function:   NccIsEntryRenamable
//
//  Purpose:    Returns whether the user should be allowed
//              to rename the given connection.
//
//  Arguments:
//      pvData   []
//      pfRenamable     // Set to TRUE if renamable
//
//  Returns:    ERROR_SUCCESS, ERROR_INVALID_PARAMETER,
//              ERROR_NOT_ENOUGH_MEMORY or ERROR_DUP_NAME.
//
//  Author:     pmay    2/4/98
//
//  Notes:
//
DWORD
APIENTRY
NccIsEntryRenamable(
    IN  LPVOID  pvData,
    OUT BOOL*   pfRenamable)
{
    AEINFO* pInfo = (AEINFO*)pvData;

    if (!pInfo || !pfRenamable)
        return ERROR_INVALID_PARAMETER;

    // Only dcc host connections are non-renamable
    *pfRenamable =  !pInfo->fDccHost;

    return NO_ERROR;
}


DWORD
APIENTRY
RasWizCreateNewEntry(
    IN  DWORD    dwRasWizType,
    IN  LPVOID   pvData,
    OUT LPWSTR   pszwPbkFile,
    OUT LPWSTR   pszwEntryName,
    OUT DWORD*   pdwFlags)
{
    switch (dwRasWizType)
    {
        case RASWIZ_TYPE_DIALUP:
        case RASWIZ_TYPE_DIRECT:
        case RASWIZ_TYPE_BROADBAND:
            return NccCreateNewEntry(pvData, pszwPbkFile, pszwEntryName, pdwFlags);
            break;

        case RASWIZ_TYPE_INCOMING:
            return RassrvCommitSettings((HWND)pvData, RASWIZ_TYPE_INCOMING);
            break;
    }

    return ERROR_INVALID_PARAMETER;
}

// Add for whistler bug 328673
// This is function is called by folder team just before the 
// RasWizCreateNewEntry(), because it is only meaningful to call it
// after the rasdlg wizard pages are done

DWORD
APIENTRY
RasWizGetNCCFlags(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT DWORD * pdwFlags)
{
    DWORD dwErr = NO_ERROR;
    
    if (!pvData || !pdwFlags)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        AEINFO* pInfo = (AEINFO*)pvData;

        *pdwFlags = 0;
        switch (dwRasWizType)
        {
            case RASWIZ_TYPE_DIRECT:
            case RASWIZ_TYPE_DIALUP:
            case RASWIZ_TYPE_BROADBAND:
                if (pInfo->fDccHost)
                {
                    *pdwFlags |= NCC_FLAG_CREATE_INCOMING;
                    dwErr =  NO_ERROR;
                }
                else
                {
                    if ( pInfo->fCreateForAllUsers )
                    {
                        //the connecntion is created for all users
                        //for Us page
                        //
                        *pdwFlags |= NCC_FLAG_ALL_USERS;    
                    }

                    if(pInfo->fFirewall)
                    {
                         *pdwFlags |= NCC_FLAG_FIREWALL;
                    }

                    if ( IsConsumerPlatform())
                    {
                        if (pInfo->pArgs->fGlobalCred)
                        {
                            //The password is saved for every users
                            //for Dt page
                            //
                            *pdwFlags |= NCC_FLAG_GLOBALCREDS;
                        }
                    }

                    if ( pInfo->pArgs->fDefInternet )
                    {
                        *pdwFlags |= NCC_FLAG_DEFAULT_INTERNET;
                    }

                    if ( pInfo->pArgs->fGlobalCred )
                    {
                        *pdwFlags |= NCC_FLAG_GLOBALCREDS;
                    }
                    
                    dwErr = NO_ERROR;
                }
                break;

            case RASWIZ_TYPE_INCOMING:
                *pdwFlags |= NCC_FLAG_CREATE_INCOMING;
                dwErr =  NO_ERROR;
                break;
                
            default:
                dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    return dwErr;
}

//This is function is called by folder team just before the 
//RasWizCreateNewEntry()
//
DWORD
APIENTRY
RasWizGetUserInputConnectionName (
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwInputName)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (!pvData || !pszwInputName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        AEINFO* pInfo = (AEINFO*)pvData;
        WCHAR * pszwTemp = NULL;
        
        if ( pInfo->pArgs->pEntry->pszEntryName )
        {
            pszwTemp = StrDupWFromT( pInfo->pArgs->pEntry->pszEntryName );
            if (!pszwTemp)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                // Truncate to maximum name length (including terminating NULL) 
                // that rest of MAX_PATH can be appened by netcfg
                //
                lstrcpynW(pszwInputName, pszwTemp, MAX_ENTERCONNECTIONNAME);
                Free0(pszwTemp);
            }
         }
         else
         {
            dwErr = ERROR_NO_DATA;
          }
    }

    return dwErr;
}


DWORD
APIENTRY
RasWizGetSuggestedEntryName (
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwSuggestedName)
{
    DWORD dwSize = MAX_PATH;

    switch (dwRasWizType)
    {
        case RASWIZ_TYPE_DIALUP:
        case RASWIZ_TYPE_DIRECT:
        case RASWIZ_TYPE_BROADBAND:
            return NccGetSuggestedEntryName(pvData, pszwSuggestedName);
            break;

        case RASWIZ_TYPE_INCOMING:
            return RassrvGetDefaultConnectionName(pszwSuggestedName, &dwSize);
            break;
    }

    return ERROR_INVALID_PARAMETER;
}


DWORD
APIENTRY
RasWizQueryMaxPageCount (
    IN  DWORD    dwRasWizType)
{
    switch (dwRasWizType)
    {
        case RASWIZ_TYPE_DIALUP:
        case RASWIZ_TYPE_BROADBAND:
            return NccQueryMaxPageCount();
            break;

        case RASWIZ_TYPE_DIRECT:
            {
                DWORD dwDirect;

                // Find out whether the dcc wizard option should be disabled
                // based on whether we allow it.
                if (! AllowDccWizard(NULL))
                    return 0;

                // Find out how many pages the server library needs for dcc.
                // If 0 pages are returned from RassrvQueryMaxPageCount, it means
                // that we shouldn't display the direct connect wizard (which is
                // true for member nts or dc nts.)  By returning 0, we tell the
                // shell that the given type isn't available.
                if ((dwDirect = RassrvQueryMaxPageCount (RASWIZ_TYPE_DIRECT)) == 0)
                    return 0;

                return dwDirect + NccQueryMaxPageCount();
            }
            break;

        case RASWIZ_TYPE_INCOMING:
            return RassrvQueryMaxPageCount(RASWIZ_TYPE_INCOMING);
            break;
    }

    return ERROR_INVALID_PARAMETER;
}


DWORD
APIENTRY
RasWizSetEntryName (
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    IN  LPCWSTR pszwName)
{
    switch (dwRasWizType)
    {
        case RASWIZ_TYPE_DIALUP:
        case RASWIZ_TYPE_DIRECT:
        case RASWIZ_TYPE_BROADBAND:
            return NccSetEntryName(pvData, pszwName);
            break;

        case RASWIZ_TYPE_INCOMING:
            // We'll accept it even though we don't do anything with it.
            return NOERROR;
            break;
    }

    return ERROR_INVALID_PARAMETER;
}

DWORD
APIENTRY
RasWizIsEntryRenamable (
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT BOOL*   pfRenamable)
{
    if (!pfRenamable)
        return ERROR_INVALID_PARAMETER;

    switch (dwRasWizType)
    {
        case RASWIZ_TYPE_DIALUP:
        case RASWIZ_TYPE_DIRECT:
        case RASWIZ_TYPE_BROADBAND:
            return NccIsEntryRenamable(pvData, pfRenamable);
            break;

        case RASWIZ_TYPE_INCOMING:
            *pfRenamable = FALSE;
            return NO_ERROR;
            break;
    }

    return ERROR_INVALID_PARAMETER;
}


// 232097: (shaunco) Fix a memory leak in the shell-owned case.
// For start pages which don't get created, WM_DESTROY won't be called which
// is where we used to free the memory.  Free the memory via a propsheet
// callback function associated only with the start page in shell-owned mode.
//
UINT
CALLBACK
DestroyStartPageCallback (
    HWND            hwnd,
    UINT            unMsg,
    LPPROPSHEETPAGE ppsp)
{
    if (PSPCB_RELEASE == unMsg)
    {
        AEINFO* pInfo;
        EINFO*  pArgs;

        pInfo = (AEINFO*)ppsp->lParam;
        ASSERT( pInfo );

        ASSERT( pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned );

        pArgs = pInfo->pArgs;

        AeTerm( pInfo );    // pInfo invalid after this call

        EuFree( pArgs );
    }

    // for PSPCB_CREATE == unMsg, returning non-zero means create the page.
    // Ignored for PSPCB_RELEASE.
    //
    return 1;
}


//----------------------------------------------------------------------------
// Add Entry wizard entry point
//----------------------------------------------------------------------------
BOOL
AeIsWorkPlace(DWORD dwFlags)
{
    TRACE("AeIsWorkPlace");

    if( RASEDFLAG_InternetEntry  & dwFlags ||
        RASEDFLAG_NewDirectEntry & dwFlags)
   {
        return FALSE;
    }
   else
   {
        return TRUE;
    }
}


//Add this for whistler 364818  gangz
//
AeTitle(RASENTRYDLG * pArgs,
        struct PAGE_INFO  c_aPageInfo)
{
    INT nTitle = 0;
    
    TRACE("AeTitle");

    if( !pArgs )
    {
        nTitle = c_aPageInfo.nSidTitle;
    }
    else if ( c_aPageInfo.nPageId == PID_DT_DefaultInternet )
    {
        if ( pArgs->dwFlags & RASEDFLAG_InternetEntry )    
        {
            nTitle = SID_DT_Title;
        }
        else if( pArgs->dwFlags & RASEDFLAG_NewDirectEntry )
        {
            nTitle = SID_DT_TitleWork;
        }
        else
        {
            nTitle = SID_DT_TitleWork;
        }
    }
    else
    {
        nTitle = c_aPageInfo.nSidTitle;
     }

   return nTitle;
}


INT
AeSubTitle(RASENTRYDLG * pArgs,
           struct PAGE_INFO  c_aPageInfo)
{
    INT nSubTitle = 0;
    
    TRACE("AeSubTitle");

    if( !pArgs )
    {
        nSubTitle = c_aPageInfo.nSidSubtitle;
    }
    else if ( c_aPageInfo.nPageId == PID_CN_ConnectionName )
    {
    //Return different subtitle for Conneciton Name page
    //
        if( RASEDFLAG_InternetEntry & pArgs->dwFlags )
        {
            nSubTitle =  SID_CN_SubtitleInternet;
        }
        else if( RASEDFLAG_NewDirectEntry & pArgs->dwFlags )
        {
            nSubTitle = SID_CN_SubtitleDccGuest;
        }
        else
        {
            nSubTitle =  SID_CN_SubtitleWork;
        }
    }
    //Add this for whistler 364818
    //
    else if ( c_aPageInfo.nPageId == PID_DT_DefaultInternet )
    {
        if ( RASEDFLAG_InternetEntry & pArgs->dwFlags )    
        {
            nSubTitle = SID_DT_Subtitle;
        }
        else if ( RASEDFLAG_NewDirectEntry & pArgs->dwFlags )
        {
            nSubTitle = SID_DT_SubtitleWork;
        }
        else
        {
            nSubTitle = SID_DT_SubtitleWork;
        }
    }
    //Add this for whistler bug 382701
    //
    else if ( c_aPageInfo.nPageId == PID_PA_PhoneNumber )
    {
        if ( RASEDFLAG_InternetEntry & pArgs->dwFlags )    
        {
            nSubTitle = SID_PA_Subtitle;
        }
        else 
        {
            nSubTitle = SID_PA_SubtitleWork;
        }
        
    }
    else
    {
        nSubTitle = c_aPageInfo.nSidSubtitle;
     }

   return nSubTitle;
}

VOID
AeWizard(
    IN OUT EINFO* pEinfo )

    // Runs the Phonebook entry property sheet.  'PEinfo' is an input block
    // with only caller's API arguments filled in.
    //
{
    AEINFO*             pAeinfo;
    RASEDSHELLOWNEDR2*  pShellOwnedInfo = NULL;
    BOOL                fShellOwned;
    BOOL                fShowSharedAccessUi = TRUE;
    HPROPSHEETPAGE      ahpage [ c_cWizPages ];
    HPROPSHEETPAGE*     phpage = ahpage;
    INT                 i;
    HRESULT             hr;
    INetConnectionUiUtilities * pncuu = NULL;
   

    TRACE("AeWizard");

    if (0 != AeInit( pEinfo->pApiArgs->hwndOwner, pEinfo, &pAeinfo ))
    {
        return;
    }

    fShellOwned = (pEinfo->pApiArgs->dwFlags & RASEDFLAG_ShellOwned);

    if (fShellOwned)
    {
        pShellOwnedInfo = (RASEDSHELLOWNEDR2*)pEinfo->pApiArgs->reserved2;
        pShellOwnedInfo->pvWizardCtx = pAeinfo;
    }

    if (pEinfo->pApiArgs->dwFlags & RASEDFLAG_NewTunnelEntry)
    {
        EuChangeEntryType (pEinfo, RASET_Vpn);
    }
    else if (pEinfo->pApiArgs->dwFlags & RASEDFLAG_NewDirectEntry)
    {
        EuChangeEntryType (pEinfo, RASET_Direct);
    }
    else if (pEinfo->pApiArgs->dwFlags & RASEDFLAG_NewBroadbandEntry)
    {
        EuChangeEntryType (pEinfo, RASET_Broadband);
    }
    else if (!(pEinfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry))
    {
        ASSERT (RASET_Phone == pEinfo->pEntry->dwType);
    }

    // Check if ZAW is denying access to the Shared Access UI
    //
    hr = HrCreateNetConnectionUtilities(&pncuu);
    if (SUCCEEDED(hr))
    {
        fShowSharedAccessUi = INetConnectionUiUtilities_UserHasPermission(
                                        pncuu, NCPERM_ShowSharedAccessUi);
        INetConnectionUiUtilities_Release(pncuu);
    }
    
    for (i = 0; i < c_cWizPages; i++)
    {
        if (pEinfo->pApiArgs->dwFlags & c_aWizInfo[i].dwConnectionFlags)
        {
            // If the page specifies that it is for shell-owned scenarios
            // only and this is not a shell-owned scenario, then don't add 
            // the page to the property sheet.  (124654)
            //
            if ((c_aWizInfo[i].dwConnectionFlags & RASEDFLAG_ShellOwned) && 
                !(pEinfo->pApiArgs->dwFlags & RASEDFLAG_ShellOwned))
            {
                continue;
            }
        
            // HACK: Add the host-side direct connect pages if needed.
            if (c_aWizInfo[i].pfnDlgProc == DCC_HOST_PROCID)
            {
                if (fShellOwned)
                {
                    RassrvAddDccWizPages(
                        pShellOwnedInfo->pfnAddPage, pShellOwnedInfo->lparam,
                        &(pAeinfo->pvDccHostContext) );
                }
            }
            else if ((c_aWizInfo[i].nPageId == PID_SW_SharedAccess) && !fShowSharedAccessUi)
            {
                // Do not add the Shared Access Ui if disallowed by ZAW
                //
                continue;
            }
            else
            {
                // Otherwise, add pages as normal.
                PROPSHEETPAGE page;
                ZeroMemory (&page, sizeof(page));

                page.dwSize       = sizeof(PROPSHEETPAGE);
                page.hInstance    = g_hinstDll;
                page.pszTemplate  = MAKEINTRESOURCE( c_aWizInfo[i].nPageId );
                page.pfnDlgProc   = c_aWizInfo[i].pfnDlgProc;
                page.lParam       = (LPARAM )pAeinfo;

                if (c_aWizInfo[i].nSidTitle)
                {
                    page.dwFlags |= PSP_USEHEADERTITLE;
                    page.pszHeaderTitle = PszLoadString( g_hinstDll,
                            AeTitle(pEinfo->pApiArgs, c_aWizInfo[i]) );  //For whstler bug 364818
                }

                if(c_aWizInfo[i].nSidSubtitle)
                {
                   page.dwFlags |= PSP_USEHEADERSUBTITLE;
                   page.pszHeaderSubTitle = PszLoadString( g_hinstDll,
                            AeSubTitle(pEinfo->pApiArgs, c_aWizInfo[i]) );
                }

                if (fShellOwned &&
                    (PID_ST_Start == c_aWizInfo[i].nPageId))
                {
                    page.dwFlags |= PSP_USECALLBACK;
                    page.pfnCallback = DestroyStartPageCallback;
                }

                *phpage = CreatePropertySheetPage( &page );

                if (fShellOwned)
                {
                    ASSERT (*phpage);
                    pShellOwnedInfo->pfnAddPage (*phpage, pShellOwnedInfo->lparam);
                }

                phpage++;
            }
        }
    }

    if (!fShellOwned)
    {
        PROPSHEETHEADER header;
        ZeroMemory( &header, sizeof(header) );
        header.dwSize           = sizeof(PROPSHEETHEADER);
        header.dwFlags          = PSH_WIZARD | PSH_WIZARD97
                                | PSH_WATERMARK | PSH_HEADER
                                | PSH_STRETCHWATERMARK;
        header.hwndParent       = pEinfo->pApiArgs->hwndOwner;
        header.hInstance        = g_hinstDll;
        header.nPages           = (ULONG)(phpage - ahpage);
        header.phpage           = ahpage;
        header.pszbmHeader      = MAKEINTRESOURCE( BID_WizardHeader );

        if (-1 == PropertySheet( &header ))
        {
            TRACE("PropertySheet failed");
            ErrorDlg( pEinfo->pApiArgs->hwndOwner, SID_OP_LoadDlg,
                ERROR_UNKNOWN, NULL );
        }

        AeTerm (pAeinfo);
    }
}


//----------------------------------------------------------------------------
// Add Entry wizard
// Listed alphabetically
//----------------------------------------------------------------------------


AEINFO*
AeContext(
    IN HWND hwndPage )

    // Retrieve the property sheet context from a wizard page handle.
    //
{
    return (AEINFO* )GetWindowLongPtr( hwndPage, DWLP_USER );
}

void
AeSetContext(
    IN HWND   hwndPage,
    IN LPARAM lparam)
{
    AEINFO* pInfo = (AEINFO* )(((PROPSHEETPAGE* )lparam)->lParam);
    SetWindowLongPtr( hwndPage, DWLP_USER, (ULONG_PTR )pInfo );
}

void
AeFinish(
    IN AEINFO* pInfo )

    // Saves the contents of the wizard.  'HwndPage is the handle of a
    // property page.  Pops up any errors that occur.  'FPropertySheet'
    // indicates the user chose to edit the property sheet directly.
    //
{
    PBENTRY* pEntry;

    TRACE("AeFinish");

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    // Retrieve information from the phone number set of controls.
    //
    if (RASET_Phone == pEntry->dwType)
    {
        PBLINK* pLink;
        DTLNODE* pPhoneNode;

        pLink = (PBLINK* )DtlGetData( pInfo->pArgs->pSharedNode );
        ASSERT( pLink );

        pPhoneNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );
        if (pPhoneNode)
        {
            CuGetInfo( &pInfo->cuinfo, pPhoneNode );
            FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pPhoneNode );
        }

        /*

        // Bug #221837: (danielwe) Default to disable file and print sharing
        // for dialup connections.
        //
        pEntry->fShareMsFilePrint = FALSE;

        // Disable File and Print services by default
        //
        EnableOrDisableNetComponent( pEntry, TEXT("ms_server"),
            FALSE);

        */            
        
    }

    // Retrieve the hostname information if this is a Vpn wizard.
    //
    else if (RASET_Vpn == pEntry->dwType)
    {
    // !!! Share code with stuff in PeApply.
        DTLNODE* pNode;
        PBLINK* pLink;
        PBPHONE* pPhone;

        // Save host name, i.e. the VPN phone number.
        //
        pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
        ASSERT( pNode );
        pLink = (PBLINK* )DtlGetData( pNode );
        pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

        if(NULL == pNode)
        {
            return;
        }
        
        pPhone = (PBPHONE* )DtlGetData( pNode );
        Free0( pPhone->pszPhoneNumber );
        pPhone->pszPhoneNumber = GetText( pInfo->hwndEbHostName );
        FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNode );

        // Whistler bug 312921
        //
        // Default the "automatic" setting in the ui to mean 
        // "try pptp first".  This is because in the Whistler timeframe
        // we found that l2tp/ipsec was not being widely deployed so
        // people were more commonly getting unneccessary timeout delays
        // while the client would attempt l2tp to no avail.
        //
        pEntry->dwVpnStrategy = VS_PptpFirst;
        
    }

    // Retrieve the service name information if this is a broadband wizard.
    //
    else if (RASET_Broadband == pEntry->dwType)
    {
        // !!! Share code with stuff in PeApply.
        DTLNODE* pNode;
        PBLINK* pLink;
        PBPHONE* pPhone;

        // Save service name, i.e. the broadband phone number.
        //
        pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
        ASSERT( pNode );
        pLink = (PBLINK* )DtlGetData( pNode );
        pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

        if(NULL == pNode)
        {
            return;
        }
        
        pPhone = (PBPHONE* )DtlGetData( pNode );
        Free0( pPhone->pszPhoneNumber );
        pPhone->pszPhoneNumber = GetText( pInfo->hwndEbBroadbandService );
        FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNode );

        // 222177, pppoe connections should default to unsecure
        //
        pEntry->dwTypicalAuth = TA_Unsecure;
        pEntry->dwAuthRestrictions = 
            AuthRestrictionsFromTypicalAuth(TA_Unsecure);
    }

    else if ( RASET_Direct == pEntry->dwType )
    {
        PBLINK* pLink = NULL;
        DTLNODE* pNode = NULL;

        // The currently enabled device is the one
        // that should be used for the connection.  Only
        // one device will be enabled (DnUpdateSelectedDevice).
        for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            if ( pLink->fEnabled )
                break;
        }

        // If we found a link successfully, deal with it
        // now.
        if ( pLink && pLink->fEnabled )
        {
            if (pLink->pbport.pbdevicetype == PBDT_ComPort)
            {
                // Install the null modem
                MdmInstallNullModem (pLink->pbport.pszPort);

                // Delete the bogus device name.  This will cause
                // the device to automatically be mapped to the
                // null modem we just installed when the phonebook
                // is next read.
                Free0 ( pLink->pbport.pszDevice );
                pLink->pbport.pszDevice = NULL;
            }
        }

        // DCC guest should by default enable LM Hash in MSCHAPv1
        // Whistler bug 216458
        //
        pEntry->dwAuthRestrictions |= AR_F_AuthW95MSCHAP | AR_F_AuthCustom;
        
    }

    // If the user opted to use his/her smart card for this
    // connection, set up the entry accordingly now.
    if ( ( pInfo->fSmartCardInstalled ) &&
         ( pInfo->fUseSmartCard ) )
    {
        pEntry->dwAuthRestrictions = AR_F_TypicalCardOrCert;
        pEntry->dwTypicalAuth = TA_CardOrCert;
        pEntry->dwCustomAuthKey = EAPCFG_DefaultKey;
        pEntry->dwDataEncryption = DE_Require;
    }

    // Default Software compression ON.
    // For whistler bug 410725          gangz
    // We turn off Sofware compression for PPPoE, RFC 2516
    //
    // Per bug 483599 turn off compression for VPN by default
    //
    if (RASET_Broadband == pEntry->dwType ||
        RASET_Vpn == pEntry->dwType )
    {
        pEntry->fSwCompression = FALSE;

        // For BillG's bug 511663, Enable redial on link failure for VPN and 
        // PPPoE connections by default
        //
        pEntry->fRedialOnLinkFailure = TRUE;
    }
    else
    {
        pEntry->fSwCompression = TRUE;
    }

    // Set the appropriate defaults if this is an "Internet" 
    // connection
    //
    if ((pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_InternetEntry) ||
         (RASET_Broadband == pEntry->dwType)) // all broadband are to Internet
    {
        // IP only
        //
        pEntry->dwfExcludedProtocols |= (NP_Nbf | NP_Ipx);

        // Disable file and print sharing
        //
        pEntry->fShareMsFilePrint = FALSE;
        pEntry->fBindMsNetClient = FALSE;
        EnableOrDisableNetComponent( pEntry, TEXT("ms_server"), FALSE);
        EnableOrDisableNetComponent( pEntry, TEXT("ms_msclient"), FALSE);
        pEntry->dwIpNbtFlags = 0;

        // Add default idle timeout for whistler bug 307969     gangz
        //
        if ( RASET_Phone == pEntry->dwType )
        {
            pEntry->lIdleDisconnectSeconds = 1200;
         }
        else
        {
            pEntry->lIdleDisconnectSeconds = 0;
         }

        // Enable PAP -- most common to ISPs
        //
        pEntry->dwTypicalAuth = TA_Unsecure;
        pEntry->dwAuthRestrictions = 
            AuthRestrictionsFromTypicalAuth(pEntry->dwTypicalAuth);

        // Do not include a domain -- not logging into secure domain
        //
        pEntry->fPreviewDomain = FALSE;

        // Record that this is a connection to the Internet
        //
        pEntry->dwUseFlags |= PBK_ENTRY_USE_F_Internet;
        
    }        


    // It's a valid new entry and caller has not chosen to edit properties
    // directly, so mark the entry for commitment.
    //
    if (!pInfo->pArgs->fChainPropertySheet)
        pInfo->pArgs->fCommit = TRUE;
}


DWORD
AeInit(
    IN  HWND        hwndParent,
    IN  EINFO*      pArgs,
    OUT AEINFO**    ppInfo )

    // Wizard level initialization.  'HwndPage' is the handle of the first
    // page.  'pInfo' is the common entry input argument block.
    //
    // Returns address of the context block if successful, NULL otherwise.  If
    // NULL is returned, an appropriate message has been displayed, and the
    // wizard has been cancelled.
    //
{
    AEINFO* pInfo;

    TRACE("AeInit");

    *ppInfo = NULL;

    pInfo = Malloc( sizeof(AEINFO) );
    if (!pInfo)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppInfo = pInfo;

    ZeroMemory( pInfo, sizeof(*pInfo) );
    pInfo->pArgs = pArgs;

    if ( pArgs->fRouter )
    {
        INTERNALARGS *pIArgs = (INTERNALARGS *) pArgs->pApiArgs->reserved;

        // Check for installed protocols over router and RasServer if router
        // bit is set.
        //
        pInfo->dwfConfiguredProtocols =
            g_pGetInstalledProtocolsEx((pIArgs) ? pIArgs->hConnection : NULL,
                                       TRUE, FALSE, TRUE);
    }
    else
    {
        INTERNALARGS *pIArgs = (INTERNALARGS *) pArgs->pApiArgs->reserved;

        // Check over which protocols is dial up client enabled.
        //
        pInfo->dwfConfiguredProtocols = g_pGetInstalledProtocolsEx(
                                                (pIArgs) ?
                                                pIArgs->hConnection :
                                                NULL, FALSE, TRUE, FALSE);
    }

    pInfo->fIpConfigured = (pInfo->dwfConfiguredProtocols & NP_Ip);

    //initialization for RasWizGetNCCFlags()
    //
    pInfo->fCreateForAllUsers = TRUE;   //for this for Dt Page
    pInfo->fFirewall = FALSE;
    pInfo->pArgs->fGlobalCred  = FALSE;
    pInfo->pArgs->fDefInternet = FALSE;

    // For whistler 506917      gangz
    // Actually, pArgs(EINFO) is already initialized in EuInit(), just in case 
    // of some future change
    //
    pInfo->pArgs->pszDefUserName = NULL;
    pInfo->pArgs->pszDefPassword = NULL ;

    return ERROR_SUCCESS;
}


VOID
AeTerm(
    IN AEINFO* pInfo )
{
    TRACE("AeTerm");

    if (pInfo)
    {
        if (pInfo->hwndLbDialFirst)
        {
            PnClearLbDialFirst( pInfo->hwndLbDialFirst );
        }

        if (pInfo->hfontBold)
        {
            DeleteObject (pInfo->hfontBold);
        }

        if (pInfo->pListAreaCodes)
        {
            DtlDestroyList( pInfo->pListAreaCodes, DestroyPszNode );
        }

        if (pInfo->fCuInfoInitialized)
        {
            CuFree( &pInfo->cuinfo );
        }

        Free (pInfo);
    }
}


//This broadband serice page is shared by AiWizard(ifw.c) and AeWizard(in entryw.c)
//
//----------------------------------------------------------------------------
// Broadband service dialog procedure
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
BsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the broadband service page of the wizard.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return BsInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("BsSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = BsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("BsKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = BsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
BsInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("BsInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndBs = hwndPage;
    pInfo->hwndEbBroadbandService = 
        GetDlgItem( hwndPage, CID_BS_EB_ServiceName );
    ASSERT(pInfo->hwndEbBroadbandService);

    Edit_LimitText( pInfo->hwndEbBroadbandService, RAS_MaxPhoneNumber );

    return TRUE;
}


BOOL
BsKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    return FALSE;
}


BOOL
BsSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    ASSERT(pInfo);

    //For bug 364818, we decide to remove Broadband's service name
    //From the NCW      gang
    //
    return FALSE;    

    /*
    pEntry = pInfo->pArgs->pEntry;

    if (RASET_Broadband != pEntry->dwType)
    {
        fDisplayPage = FALSE;
    }
    else
    {
        LPARAM dwWizButtons = PSWIZB_NEXT;
        DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

        // Show the back button if we're shell owned or we have the 
        // LA page before us.
        //
        if ((dwFlags & RASEDFLAG_ShellOwned) ||
            !(dwFlags & RASEDFLAG_NewTunnelEntry))
        {
            dwWizButtons |= PSWIZB_BACK;
        }

        PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
        fDisplayPage = TRUE;
    }

    return fDisplayPage;
    */
}


//Add ConnectionName Dialog proc for whistler bug 328673
//
//----------------------------------------------------------------------------
// Connection Name property page, this is only for shellowned, the filtering
// is already done in AeWizard()
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------
INT_PTR CALLBACK
CnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Connection Name page of the wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return CnInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("CnSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = CnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("CnKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = CnKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    AEINFO* pInfo;

                    TRACE("CnNEXT");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);

                    pInfo->fCnWizNext = TRUE;
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    return TRUE;
                }

            }
            break;
        }

    }

    return FALSE;
}


BOOL
CnInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    
    TRACE("CnInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }

    // A DCC host conneciton will be forward to the incoming connection path
    //
    if ( pInfo->fDccHost )
    {
        return TRUE;
     }

    //This page wont be available for rasphone.exe
    //the filtering is done in AeWizard
    //

    pInfo->hwndCn = hwndPage;
    pInfo->hwndCnEbConnectionName = GetDlgItem( hwndPage, CID_CN_EB_ConnectionName );
    ASSERT(pInfo->hwndCnEbConnectionName);
    pInfo->hwndCnStHMsg = GetDlgItem( hwndPage, CID_CN_ST_HMsg );
    ASSERT(pInfo->hwndCnStHMsg);
    pInfo->hwndCnStHMsg2 = GetDlgItem( hwndPage, CID_CN_ST_HMsg2 );
    ASSERT(pInfo->hwndCnStHMsg2);
    pInfo->hwndCnName = GetDlgItem( hwndPage, CID_CN_Name );
    ASSERT(pInfo->hwndCnName);

    //the length does NOT include the terminating NULL character
    //in order to match the RasWizGetUserInputConnectionName()
    //we need to minus one from the lenght limit
    //

    //
    //For whistler bug 270255, for the sake of creating short cut which will be placed
    //under "Documents and Setttings\...", we dynamically limit the maximum connection
    //name
    //
    {
        long lPathLen = 0;
        WCHAR szPath[MAX_PATH];

        if (SHGetSpecialFolderPath(hwndPage, 
                               szPath, 
                               CSIDL_DESKTOPDIRECTORY, 
                               FALSE))
        {
            lPathLen = wcslen(szPath);
        }

        if (SHGetSpecialFolderPath(hwndPage, 
                               szPath, 
                               CSIDL_COMMON_DESKTOPDIRECTORY, 
                               FALSE))
        {
            lPathLen = max(lPathLen, (long)wcslen(szPath));
        }

        // We need to take the following lengths into acount:
        // "\\\\?\\"            - 4
        // "(path)"             - dwPathLen (Desktop path)
        // "\\"                 - 1
        // "(connection name)"  - rest from MAX_PATH
        // "(number)"           - 5 (duplicate counter, should not exceed 5 digits)
        // ".lnk"               - 4
        // "\0"                 - 1
        
        ASSERT( 9 < (MAX_PATH - lPathLen - 15));
        if( 9 >= (MAX_PATH - lPathLen - 15) )
        {
            MAX_ENTERCONNECTIONNAME = 9; //We sacrifice the shortcut for the NCW task
         }
        else
        {
            MAX_ENTERCONNECTIONNAME = min(MAX_ENTERCONNECTIONNAME,
                                          MAX_PATH - lPathLen - 15);
        }
    }

    Edit_LimitText( pInfo->hwndCnEbConnectionName, MAX_ENTERCONNECTIONNAME-1);//RAS_MaxEntryName );

    // Set the static text box
    //
   {
    DWORD dwFlags;
    TCHAR *pszMsg = NULL, *pszSubTitle = NULL, *pszMsg2 = NULL, *pszName=NULL;
    HWND   hwndHMsg = NULL, hwndPageTmp = NULL, hwndHMsg2 = NULL, hwndName = NULL;

    hwndHMsg  = pInfo->hwndCnStHMsg;
    hwndHMsg2 = pInfo->hwndCnStHMsg2;
    hwndPageTmp  = pInfo->hwndCn;
    hwndName  = pInfo->hwndCnName;

    if(!hwndHMsg || !hwndPageTmp || !hwndHMsg2 ||!hwndName)
    {
        return FALSE;
    }

    //Set the  message on this page, the subtitle is set in AeWizard
    //by help function AeSubTitle()
    //
    {
        dwFlags = pInfo->pArgs->pApiArgs->dwFlags;
        
        if (dwFlags & RASEDFLAG_NewDirectEntry) 
        {
            pszMsg = PszFromId( g_hinstDll, SID_CN_HMsgDccGuest );
            pszName = PszFromId( g_hinstDll, SID_CN_NameDccGuest );
        }
        else if( dwFlags & RASEDFLAG_InternetEntry)
        {
            pszMsg = PszFromId( g_hinstDll, SID_CN_HMsgInternet );
            pszName = PszFromId( g_hinstDll, SID_CN_NameInternet );
        }
        else
        {
            pszMsg = PszFromId( g_hinstDll, SID_CN_HMsgWork );
            pszMsg2 = PszFromId( g_hinstDll, SID_CN_HMsgWork2 );
            pszName = PszFromId( g_hinstDll, SID_CN_NameWork );
        }
     }

     if(pszMsg)
     {
        if(hwndHMsg)
        {
          SetWindowText(hwndHMsg, pszMsg);
        }
        
        Free(pszMsg);
     }

     if (pszMsg2)
     {
        if(hwndHMsg2)
        {
          SetWindowText(hwndHMsg2, pszMsg2);
        }
        
        Free(pszMsg2);
     }

    if (pszName)
    {
        if(hwndName)
        {
          SetWindowText(hwndName, pszName);
        }

        Free(pszName);
    }
  }

    return TRUE;
}

//For whistler bug 346886
//

BOOL CnValidName(TCHAR * pszSrc)
{
    WCHAR pszwInvalidChars[] = L"\\/:*?\"<>|\t";
    WCHAR * pszwSrc=NULL;
    BOOL fValid = TRUE;

    if(!pszSrc)
    {
        return FALSE;
     }

    pszwSrc = StrDupWFromT(pszSrc);
    ASSERT(pszwSrc);
    if(!pszwSrc)
    {
        return TRUE;
    }

    fValid= ( !wcspbrk( pszwSrc, pszwInvalidChars ) )?TRUE:FALSE;

     return fValid;
}

BOOL
CnKillActive(
    IN AEINFO* pInfo)

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    TCHAR* psz = NULL;

    TRACE("CnKillActive");
    
    // A DCC host conneciton will be forward to the incoming connection path
    //
    if ( pInfo->fDccHost )
    {
        return FALSE;
    }
     
    Free0( pInfo->pArgs->pEntry->pszEntryName );
    pInfo->pArgs->pEntry->pszEntryName = NULL;

    //this GetText will always return an allocated buffer if memory
    //is availabe, if user input nothing, it will return a string has
    //only a NULL termination, TEXT('\0');
    //
    psz = GetText( pInfo->hwndCnEbConnectionName );
    if (psz)
    {
        // Update the entry name from the editbox.
        // We wont enfore a name to be entered, we also wont check if the
        // the name entered here is a duplicate, because it is just part 
        // of the final name
        //

        // Validate the entry name. It cannot begin with a "."
        //
        
        if( pInfo->fCnWizNext )
        {
            pInfo->fCnWizNext = FALSE;

            if ( 0 < lstrlen( psz ) && 
                 ( (psz[ 0 ] == TEXT('.') ) ||
                   !CnValidName(psz) )
                 )
            {
                Free0(psz);
                MsgDlg( pInfo->hwndDlg, SID_BadEntryWithDot, NULL );
                SetFocus( pInfo->hwndCnEbConnectionName );
                Edit_SetSel( pInfo->hwndCnEbConnectionName, 0, -1 );
                return TRUE;
            }
         }

        if( TEXT('\0') != psz[0] )
        {
            pInfo->pArgs->pEntry->pszEntryName = psz;
        }
        else
        {
            Free0(psz);
        }
    }

    return FALSE;
}

BOOL
CnSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    TRACE("CnSetActive");

    // A DCC host conneciton will be forward to the incoming connection path
    //
    if ( pInfo->fDccHost )
    {
    /*
        //when forwarded to incoming connection path, there is no Connection page
        //beside, the incoming conneciton's name is not changable,
        //so we remove the possible entered connection by previous given path
        //like the DCC guest path
        //
        Free0( pInfo->pArgs->pEntry->pszEntryName );
        pInfo->pArgs->pEntry->pszEntryName = NULL;
    */
        return FALSE;
     }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );

    return TRUE;
}


//----------------------------------------------------------------------------
// Destination property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
DaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Destination page of the wizard.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return DaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("DaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = DaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = DaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
DaInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("DaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndDa = hwndPage;
    pInfo->hwndEbHostName = GetDlgItem( hwndPage, CID_DA_EB_HostName );
    ASSERT(pInfo->hwndEbHostName);

    Edit_LimitText( pInfo->hwndEbHostName, RAS_MaxPhoneNumber );

    return TRUE;
}


BOOL
DaKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    return FALSE;
}


BOOL
DaSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if (RASET_Vpn != pEntry->dwType)
    {
        fDisplayPage = FALSE;
    }
    else
    {
        LPARAM dwWizButtons = PSWIZB_NEXT;
        DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

        // Show the back button if we're shell owned or, we have the
        // La page or the Pn page before us.
        //
        if ((dwFlags & RASEDFLAG_ShellOwned) ||
            !(dwFlags & RASEDFLAG_NewTunnelEntry) ||
            !pInfo->fHidePublicNetworkPage)
        {
            dwWizButtons |= PSWIZB_BACK;
        }

        PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
        fDisplayPage = TRUE;
    }

    return fDisplayPage;
}

//----------------------------------------------------------------------------
// Default inTernet wizard page
// This is a personal-sku only page.
//----------------------------------------------------------------------------

INT_PTR CALLBACK
DtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Default inTernet page of the wizard.  
    // Parameters and return value are as described for standard 
    // windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return DtInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("DtSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = DtSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DtKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = DtKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

DWORD
DtEnableDisableControls(
    IN AEINFO* pInfo,
    IN BOOL fEnable)
{
    EnableWindow(pInfo->hwndDtEbUserName,  fEnable );
    EnableWindow(pInfo->hwndDtEbPassword,  fEnable );
    EnableWindow(pInfo->hwndDtEbPassword2, fEnable );
    EnableWindow(pInfo->hwndDtStUserName,  fEnable );
    EnableWindow(pInfo->hwndDtStPassword,  fEnable );
    EnableWindow(pInfo->hwndDtStPassword2, fEnable );

    return NO_ERROR;
}

BOOL
DtInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    BOOL fWork = FALSE;

    TRACE("DtInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndDt           = hwndPage;
    pInfo->hwndDtCbFirewall = GetDlgItem( hwndPage, CID_DT_CB_Firewall );
    pInfo->hwndDtCbDefault  = GetDlgItem( hwndPage, CID_DT_CB_Default );
    pInfo->hwndDtEbUserName = GetDlgItem( hwndPage, CID_DT_EB_UserName );
    pInfo->hwndDtEbPassword = GetDlgItem( hwndPage, CID_DT_EB_Password );
    pInfo->hwndDtEbPassword2= GetDlgItem( hwndPage, CID_DT_EB_Password2 );
    pInfo->hwndDtStUserName = GetDlgItem( hwndPage, CID_DT_ST_UserName  );
    pInfo->hwndDtStPassword = GetDlgItem( hwndPage, CID_DT_ST_Password  );
    pInfo->hwndDtStPassword2= GetDlgItem( hwndPage, CID_DT_ST_Password2 );
    pInfo->hwndDtCbUseCredentials = 
        GetDlgItem( hwndPage, CID_DT_CB_UseSharedCredentials );

    Edit_LimitText( pInfo->hwndDtEbUserName,  UNLEN );
    Edit_LimitText( pInfo->hwndDtEbPassword,  PWLEN );
    Edit_LimitText( pInfo->hwndDtEbPassword2, PWLEN );

    {
        DWORD dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

        if ( dwFlags & RASEDFLAG_NewDirectEntry ||
             dwFlags & RASEDFLAG_InternetEntry )
        {
            fWork = FALSE;
        }
        else
        {
            fWork = TRUE;
        }
    }        

    //Turn on the Domain bits for workplace path
    //Per the request of Jenellec and approved by Davidei and pmay,
    //we revert this change
    /*
    if(fWork)
    {
        pInfo->pArgs->pEntry->fPreviewDomain = 1;
    }
    */
    
    //Change the HeadMessage for workplace path
    //For whistler bug 364818       gangz
    //
    if( fWork ||
        (RASEDFLAG_NewDirectEntry & pInfo->pArgs->pApiArgs->dwFlags)
      )
    {
        HWND hwndHeadMsg = GetDlgItem( hwndPage, CID_DT_HeadMessage );

        TCHAR *  pszMsg = PszFromId( g_hinstDll, SID_DT_HMsgWork );

        if(pszMsg)
        {
            if(hwndHeadMsg)
            {
                SetWindowText( hwndHeadMsg, pszMsg);
            }
            Free(pszMsg);
        }
    }

    // Intialize the three check buttons, turn them off for the
    // workplace path        gangz
    //

    Button_SetCheck( pInfo->hwndDtCbDefault, !fWork );
    Button_SetCheck( pInfo->hwndDtCbUseCredentials, !fWork );

    //Show the Firewall check box according to 3 conditions
    //(1) Admin or Power Users
    //(2) only for Personal, Professional 
    //(3) Group Policy enable it(GPA is not configues is viewed as enable)

    if (pInfo->pArgs->fIsUserAdminOrPowerUser &&
        IsFirewallAvailablePlatform() &&
        IsGPAEnableFirewall())
    {  
        EnableWindow( pInfo->hwndDtCbFirewall, TRUE );
        Button_SetCheck( pInfo->hwndDtCbFirewall, !fWork );
     }
    else
    {
        EnableWindow( pInfo->hwndDtCbFirewall, FALSE );
        ShowWindow( pInfo->hwndDtCbFirewall, SW_HIDE);
        pInfo->fFirewall = FALSE;
    }

    //Normal user doesnt have the privilege to set a connectoid
    //as a default internet connection
    //
    if ( !pInfo->pArgs->fIsUserAdminOrPowerUser)
    {
        Button_SetCheck( pInfo->hwndDtCbDefault, FALSE);
        EnableWindow(pInfo->hwndDtCbDefault, FALSE);
    }
    
    // Reset the title and subtitle if this is the work path
    // this is done in AeWizard() by calling AeTitle() and AeSubtitle()
    //

    // This entry is default to be available for all users
    //
   // pInfo->fCreateForAllUsers = TRUE; //this is done in AeInit()

    return TRUE;
}

BOOL
DtKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    // Remember whether to set this as the default Internet connection
    //
    BOOL fFailed = FALSE;

   //Dont show the Account name page for DCC guest connection
   //for whistler bug 364818        gangz
   //
   if( pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_NewDirectEntry )
   {
        return  FALSE;
   }
   
    pInfo->pArgs->fDefInternet = 
        Button_GetCheck( pInfo->hwndDtCbDefault );

    //Add firewall check and GlobalCred for whistler bug 328673
    //
    pInfo->fFirewall = 
        Button_GetCheck( pInfo->hwndDtCbFirewall );

    pInfo->pArgs->fGlobalCred = 
        Button_GetCheck( pInfo->hwndDtCbUseCredentials );
        
    Free0(pInfo->pArgs->pszDefUserName);
    Free0(pInfo->pArgs->pszDefPassword);

    // For whistler 506917      gangz
    pInfo->pArgs->pszDefUserName = NULL;
    pInfo->pArgs->pszDefPassword = NULL ;
    

    // Get the credentials
    //
    {
        TCHAR pszUserName[UNLEN + 1];
        TCHAR pszPassword[PWLEN + 1];
        TCHAR pszPassword2[PWLEN + 1];
        INT iLen;

        pszUserName[0] = TEXT('\0');
        pszPassword[0] = TEXT('\0');
        pszPassword2[0] = TEXT('\0');

        // Get the credentials
        //
        do {
            GetWindowText( pInfo->hwndDtEbUserName, pszUserName, UNLEN + 1);
            GetWindowText( pInfo->hwndDtEbPassword, pszPassword, PWLEN + 1);
            GetWindowText( pInfo->hwndDtEbPassword2, pszPassword2, PWLEN + 1);

            // Verify there is a user name
            //
            //Add for whistler bug 328673
            //User can leave the credential blank or must fill a complete
            //credential information
            //
        
            if ( 0 == lstrlen(pszUserName) &&
                 0 == lstrlen(pszPassword) &&
                 0 == lstrlen(pszPassword2) )
            {
                fFailed = FALSE;
                break;
            }
        
            if (lstrlen(pszUserName) == 0)
            {
                MsgDlg(pInfo->hwndDt, SID_MissingUserName, NULL);
                fFailed = TRUE;
                break;
            }

            // Verify the passwords match
            //
            if (lstrcmp(pszPassword, pszPassword2) != 0)
            {
                MsgDlg(pInfo->hwndDt, SID_PasswordMismatch, NULL);
                fFailed = TRUE;
                break;
            }

            pInfo->pArgs->pszDefUserName = StrDup(pszUserName);
            if (pInfo->pArgs->pszDefUserName == NULL)
            {
                fFailed = TRUE;
                break;
            }

            pInfo->pArgs->pszDefPassword = StrDup(pszPassword);
            if (pInfo->pArgs->pszDefPassword)
            {
                // Scramble the password
                //
                EncodePassword(pInfo->pArgs->pszDefPassword);
                fFailed = FALSE;
            }
            else if (lstrlen(pszPassword))
            {
                // Copy failed
                fFailed = TRUE;
            }
            else
            {
                fFailed = FALSE;
            }
         }
        while(FALSE);
        
        // Clear passwords from temporary stack memory
        //
        RtlSecureZeroMemory(pszPassword, sizeof(pszPassword));
        RtlSecureZeroMemory(pszPassword2, sizeof(pszPassword2));
    }

    if ( fFailed )
    {
        Free0(pInfo->pArgs->pszDefUserName);
        Free0(pInfo->pArgs->pszDefPassword);
        
        // For whistler 506917      gangz
        pInfo->pArgs->pszDefUserName = NULL;
        pInfo->pArgs->pszDefPassword = NULL ;
    }
    
    return fFailed;
}

BOOL
DtSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    if (pInfo->fDccHost)
    {
        return FALSE;
    }

    // Dont show the Account name page for DCC guest connection
    // or workpath connections
    // for whistler bug 364818  383533      gangz
    //
    if( RASEDFLAG_NewDirectEntry & pInfo->pArgs->pApiArgs->dwFlags ||
        !(RASEDFLAG_InternetEntry & pInfo->pArgs->pApiArgs->dwFlags)
        )
    {
        pInfo->pArgs->fDefInternet = FALSE;
        pInfo->fFirewall = FALSE;
        pInfo->pArgs->fGlobalCred = FALSE;
    
        return  FALSE;
    }

    // If this is a singer-user connection then we hide the option to save the
    // password globally.
    //
    if ( !pInfo->fCreateForAllUsers )
    {
        Button_SetCheck( pInfo->hwndDtCbUseCredentials, FALSE );
        EnableWindow( pInfo->hwndDtCbUseCredentials, FALSE );
        ShowWindow( pInfo->hwndDtCbUseCredentials, SW_HIDE );
    }
    else
    {
       ShowWindow( pInfo->hwndDtCbUseCredentials, SW_SHOW );
       EnableWindow( pInfo->hwndDtCbUseCredentials, TRUE );
       
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}

//----------------------------------------------------------------------------
// Entry Name property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
EnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Entry Name page of the wizard.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return EnInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_RESET:
                {
                    TRACE("EnRESET");
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("EnSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = EnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("EnKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = EnKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZBACK:
                {
                    AEINFO* pInfo;

                    TRACE("EnWIZBACK");
                    pInfo = AeContext( hwnd );
                    
                    // For whislter bug 453704          gangz
                    //
                    pInfo->fEnBack  = TRUE;
                    
                    PropSheet_SetWizButtons(pInfo->hwndDlg, PSWIZB_NEXT | PSWIZB_BACK);
                    return FALSE;
                }

                case PSN_WIZFINISH:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("EnWIZFINISH");

                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);

                    // You'd think pressing Finish would trigger a KILLACTIVE
                    // event, but it doesn't, so we do it ourselves.
                    //
                    fInvalid = EnKillActive( pInfo );
                    if (!fInvalid)
                    {
                        pInfo->pArgs->pUser->fDirty = TRUE;
                        SetUserPreferences(
                            NULL, pInfo->pArgs->pUser,
                            pInfo->pArgs->fNoUser ? UPM_Logon : UPM_Normal );

                        AeFinish( pInfo );
                    }

                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
EnInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    DWORD    dwErr;
    AEINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("EnInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;
        
    // The shell owns the finished page, so if we're shell owned, don't
    // display ours.
    //
    if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
    {
        return TRUE;
    }


    // Initialize page-specific context information.
    //
    pInfo->hwndEn = hwndPage;
    pInfo->hwndEbEntryName = GetDlgItem( hwndPage, CID_EN_EB_EntryName );
    ASSERT(pInfo->hwndEbEntryName);

    // Initialize the entry name field.
    //
    pEntry = pInfo->pArgs->pEntry;
    if (!pEntry->pszEntryName)
    {
        ASSERT( pInfo->pArgs->pFile );

        // No entry name, so think up a default.
        //
        dwErr = GetDefaultEntryName(
            NULL,
            pEntry->dwType,
            pInfo->pArgs->fRouter,
            &pEntry->pszEntryName );
    }

    Edit_LimitText( pInfo->hwndEbEntryName, RAS_MaxEntryName );
    SetWindowText( pInfo->hwndEbEntryName, pEntry->pszEntryName );

    return TRUE;
}


BOOL
EnKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    TCHAR* psz;

    // The shell owns the finished page, so if we're shell owned, don't
    // display ours.
    //
    if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
    {
        return FALSE;
    }

    // For whislter bug 453704          gangz
    //
    if ( TRUE == pInfo->fEnBack )
    {
        return FALSE;
    }
    
    psz = GetText( pInfo->hwndEbEntryName );
    if (psz)
    {
        // Update the entry name from the editbox.
        //
        Free0( pInfo->pArgs->pEntry->pszEntryName );
        pInfo->pArgs->pEntry->pszEntryName = psz;

        // Validate the entry name.
        //
        if (!EuValidateName( pInfo->hwndDlg, pInfo->pArgs ))
        {
            SetFocus( pInfo->hwndEbEntryName );
            Edit_SetSel( pInfo->hwndEbEntryName, 0, -1 );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
EnSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    LPARAM dwWizButtons = PSWIZB_FINISH;
    DWORD  dwFlags      = pInfo->pArgs->pApiArgs->dwFlags;

    // The shell owns the finished page, so if we're shell owned, don't
    // display ours.
    //
    if (dwFlags & RASEDFLAG_ShellOwned)
    {
        return FALSE;
    }

    if (!(dwFlags & RASEDFLAG_CloneEntry))
    {
        dwWizButtons |= PSWIZB_BACK;
    }
    PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );

    // For whislter bug 453704          gangz
    //
    pInfo->fEnBack  = FALSE;
    
    return TRUE;
}


INT_PTR CALLBACK
LaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the start page of the wizard.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return LaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("LaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = LaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("LaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = LaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
LaInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.  'pInfo' is the arguments from the PropertySheet caller.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    DWORD   dwType;
    INT     nIdButton;
    HFONT   hfont;

    TRACE("LaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndLa = hwndPage;

    // Create the bold font and apply it to the buttons.
    //
    hfont = GetWindowFont (hwndPage);
    if (!hfont)
    {
        // If not found then the dialog is using the system font.
        //
        hfont = (HFONT )GetStockObject (SYSTEM_FONT);
    }
    if (hfont)
    {
        LOGFONT lf;

        // Get the font info so we can generate the bold version.
        //
        if (GetObject (hfont, sizeof(lf), &lf))
        {
            lf.lfWeight = FW_BOLD;
            hfont = CreateFontIndirect (&lf);

            if (hfont)
            {
                // Store this so we can destroy it during cleanup.
                //
                pInfo->hfontBold = hfont;

                // Set the fonts of the radio buttons using this bold font.
                //
                SetWindowFont (GetDlgItem (hwndPage, CID_LA_RB_Phone),
                    hfont, FALSE);

                SetWindowFont (GetDlgItem (hwndPage, CID_LA_RB_Tunnel),
                    hfont, FALSE);

                SetWindowFont (GetDlgItem (hwndPage, CID_LA_RB_Direct),
                    hfont, FALSE);

                SetWindowFont (GetDlgItem (hwndPage, CID_LA_RB_Broadband),
                    hfont, FALSE);
            }
        }
    }

    // Set the radio buttons.
    //
    dwType = pInfo->pArgs->pEntry->dwType;

    if (RASET_Phone == dwType)
    {
        nIdButton = CID_LA_RB_Phone;
    }
    else if (RASET_Vpn == dwType)
    {
        nIdButton = CID_LA_RB_Tunnel;
    }
    else if (RASET_Broadband == dwType)
    {
        nIdButton = CID_LA_RB_Broadband;
    }
    else
    {
        nIdButton = CID_LA_RB_Direct;
    }
    CheckDlgButton( hwndPage, nIdButton, BST_CHECKED );

    return TRUE;
}

BOOL
LaKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    if (BST_CHECKED == IsDlgButtonChecked (pInfo->hwndLa, CID_LA_RB_Phone))
    {
        EuChangeEntryType (pInfo->pArgs, RASET_Phone);
    }
    else if (BST_CHECKED == IsDlgButtonChecked (pInfo->hwndLa, CID_LA_RB_Tunnel))
    {
        EuChangeEntryType (pInfo->pArgs, RASET_Vpn);
    }
    else if (BST_CHECKED == IsDlgButtonChecked (pInfo->hwndLa, CID_LA_RB_Broadband))
    {
        EuChangeEntryType (pInfo->pArgs, RASET_Broadband);
    }
    else
    {
        EuChangeEntryType (pInfo->pArgs, RASET_Direct);
    }

    return FALSE;
}

BOOL
LaSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    DWORD dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

    // If we are owned by the shell, then we are not displayed.
    //
    if (dwFlags & RASEDFLAG_ShellOwned)
    {
        return FALSE;
    }

    // If we were told by the caller, which type of entry we should be,
    // then we are not displayed.
    //
    if (dwFlags & (RASEDFLAG_NewPhoneEntry | RASEDFLAG_NewTunnelEntry |
                   RASEDFLAG_NewDirectEntry | RASEDFLAG_NewBroadbandEntry)) //Add _NewBroadbandEntry for bug237175
    {
        return FALSE;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_NEXT );
    return TRUE;
}


//----------------------------------------------------------------------------
// Modem/Adapter property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
MaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Modem/Adapter page of the wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, MaLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return MaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("MaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = MaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case LVXN_SETCHECK:
                {
                    AEINFO* pInfo;

                    TRACE("MaLVXNSETCHECK");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    if (ListView_GetCheckedCount(pInfo->hwndLv) > 0)
                    {
                        PropSheet_SetWizButtons(pInfo->hwndDlg,
                                                PSWIZB_BACK | PSWIZB_NEXT);
                    }
                    else
                    {
                        // Disable Next button if no items are checked
                        PropSheet_SetWizButtons(pInfo->hwndDlg, PSWIZB_BACK);
                    }
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("MaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = MaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
MaInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("MaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndMa = hwndPage;
    pInfo->hwndLv = GetDlgItem( hwndPage, CID_MA_LV_Devices );
    ASSERT(pInfo->hwndLv);

    // Add the modem and adapter images.
    //
    ListView_InstallChecks( pInfo->hwndLv, g_hinstDll );
    ListView_SetDeviceImageList( pInfo->hwndLv, g_hinstDll );

    // Add a single column exactly wide enough to fully display
    // the widest member of the list.
    //
    {
        LV_COLUMN col;

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT;
        col.fmt = LVCFMT_LEFT;
        ListView_InsertColumn( pInfo->hwndLv, 0, &col );
        ListView_SetColumnWidth( pInfo->hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );
    }

    // Don't bother with this page if there's only one device.
    //
    if (DtlGetNodes( pInfo->pArgs->pEntry->pdtllistLinks ) < 2)
    {
        pInfo->fSkipMa = TRUE;
    }

    //For whislter bug 354542
    //
    pInfo->fMultilinkAllIsdn = FALSE;
    return FALSE;
}


LVXDRAWINFO*
MaLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the column information.
    //
{
    // Use "wide selection bar" feature and the other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info =
        { 1, 0, LVXDI_DxFill, { 0, 0 } };

    return &info;
}

BOOL
MaKillActive(
    IN AEINFO* pInfo )

    // Called when the modem/adapter page is loosing activation.
{
    PBENTRY* pEntry;

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if (!pInfo->fSkipMa && (RASET_Phone == pEntry->dwType))
    {

        // Initialization of i to -1 is important here.  It means start
        // the search beginning with that item.
        //
        INT i = -1;

        //For whistler bug 354542
        //
        pInfo->fMultilinkAllIsdn = FALSE;

        while ((i = ListView_GetNextItem(pInfo->hwndLv, i, LVNI_ALL )) >= 0)
        {
            DTLNODE* pNode;

            pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLv, i );

            if (pNode)
            {
                PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
                ASSERT( pLink );

                // If we're multilinking all ISDN, we only need to
                // set enabled based on the check state if the device type
                // is not ISDN.  (If it is ISDN and we're multilinking, we've
                // already taken care of it below.
                //
                if (!pInfo->fMultilinkAllIsdn ||
                    (pLink->pbport.pbdevicetype != PBDT_Isdn))
                {
                    pLink->fEnabled = ListView_GetCheck( pInfo->hwndLv, i );
                }
            }
            //Only the Dummy "All available Isdn" item will return the NULL pLink
            //
            else if (ListView_GetCheck( pInfo->hwndLv, i ))
            {
                // ISDN multi-link selected.  Enable the ISDN multi-link
                // nodes, move them to the head of the list, and disable
                // all the other links.
                //
                DTLNODE* pNextNode;
                DTLNODE* pAfterNode;
                DTLLIST* pList;

                //For whistler bug 354542
                //
                pInfo->fMultilinkAllIsdn = TRUE;

                pList = pInfo->pArgs->pEntry->pdtllistLinks;

                pInfo->fModem = FALSE;

                pAfterNode = NULL;
                for (pNode = DtlGetFirstNode( pList );
                     pNode;
                     pNode = pNextNode)
                {
                    PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
                    ASSERT(pLink);

                    pNextNode = DtlGetNextNode( pNode );

                    if (pLink->pbport.pbdevicetype == PBDT_Isdn
                        && !pLink->fProprietaryIsdn)
                    {
                        pLink->fEnabled = TRUE;

                        DtlRemoveNode( pList, pNode );
                        if (pAfterNode)
                            DtlAddNodeAfter( pList, pAfterNode, pNode );
                        else
                            DtlAddNodeFirst( pList, pNode );
                        pAfterNode = pNode;
                    }
                    else
                    {
                        pLink->fEnabled = FALSE;
                    }
                }
            }
        }
    }

    return FALSE;
}

BOOL
MaSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if (pInfo->fSkipMa || (RASET_Phone != pEntry->dwType))
    {
        fDisplayPage = FALSE;
    }
    else
    {
        TCHAR*   psz;
        DTLNODE* pNode;
        DWORD    cMultilinkableIsdn;
        LV_ITEM  item;
        INT      iItem, iIndex;

        ListView_DeleteAllItems( pInfo->hwndLv );

        // Fill the list of devices and select the first item.
        //
        iItem = 1;
        cMultilinkableIsdn = 0;
        for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink;
            DWORD dwImage;

            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            if ((pLink->pbport.pbdevicetype == PBDT_Isdn) &&
                !pLink->fProprietaryIsdn)
            {
                ++cMultilinkableIsdn;
            }

            psz = DisplayPszFromPpbport( &pLink->pbport, &dwImage );
            if (psz)
            {
                PBLINK* pLinkTmp = NULL;

                pLinkTmp = (PBLINK* )DtlGetData( pNode );

                ZeroMemory( &item, sizeof(item) );
                item.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                item.iItem   = iItem++;
                item.pszText = psz;
                item.iImage  = dwImage;
                item.lParam  = (LPARAM )pNode;

                iIndex = ListView_InsertItem( pInfo->hwndLv, &item );

                if (pInfo->fMaAlreadyInitialized)
                {
                    ListView_SetCheck(pInfo->hwndLv, iIndex, pLinkTmp->fEnabled);
                }
                else
                {
                    ListView_SetCheck(pInfo->hwndLv, iIndex, FALSE);
                }
                Free( psz );
            }
        }

        if (cMultilinkableIsdn > 1)
        {
            psz = PszFromId( g_hinstDll, SID_IsdnAdapter );
            if (psz)
            {
                LONG    lStyle;

                // Turn off sorting so the special ISDN-multilink item appears
                // at the top of the list.
                //
                lStyle = GetWindowLong( pInfo->hwndLv, GWL_STYLE );
                SetWindowLong( pInfo->hwndLv, GWL_STYLE,
                    (lStyle & ~(LVS_SORTASCENDING)) );

                ZeroMemory( &item, sizeof(item) );
                item.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                item.iItem   = 0;
                item.pszText = psz;
                item.iImage  = DI_Adapter;
                item.lParam  = (LPARAM )NULL;

                iIndex = ListView_InsertItem( pInfo->hwndLv, &item );

                //For whislter bug 354542
                //
                ListView_SetCheck(pInfo->hwndLv, iIndex, pInfo->fMultilinkAllIsdn);
                
                Free( psz );
            }
        }

        // Select the first item.
        //
        ListView_SetItemState( pInfo->hwndLv, 0, LVIS_SELECTED, LVIS_SELECTED );
        
        if (!pInfo->fMaAlreadyInitialized)
        {
            ListView_SetCheck( pInfo->hwndLv, 0, TRUE );

            {
                LPARAM dwWizButtons = PSWIZB_NEXT;
                DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

                if ((dwFlags & RASEDFLAG_ShellOwned) ||
                    !(dwFlags & RASEDFLAG_NewPhoneEntry))
                {
                    dwWizButtons |= PSWIZB_BACK;
                }

                PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
            }

            pInfo->fMaAlreadyInitialized = TRUE;
        }
        else
        {
            if (!ListView_GetCheckedCount(pInfo->hwndLv))
            {
                // Disable next button if no items checked
                PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK );
            }
        }

        fDisplayPage = TRUE;
    }

    return fDisplayPage;
}


//----------------------------------------------------------------------------
// Phone Number property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
PaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Phone Number page of the wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return PaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("PaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = PaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("PaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = PaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

    }

    return FALSE;
}


BOOL
PaInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    CUINFO * pCuInfo = NULL;

    TRACE("PaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndPa = hwndPage;
    pInfo->hwndEbNumber = GetDlgItem( hwndPage, CID_PA_EB_Number );
    ASSERT(pInfo->hwndEbNumber);

    // Initialize the complex phone number context and use those utilities to
    // set the phone number controls.
    //
    pInfo->pListAreaCodes = DtlDuplicateList(
        pInfo->pArgs->pUser->pdtllistAreaCodes,
        DuplicatePszNode, DestroyPszNode );

//Modify Phonenumber page for bug 328673       gangz
//Initialize pInfo->CuInfoCuInfo 
//
    pCuInfo=&pInfo->cuinfo;
    ZeroMemory(pCuInfo, sizeof(*pCuInfo) );

    pCuInfo->hwndStAreaCodes = NULL;
    pCuInfo->hwndClbAreaCodes = NULL;
    pCuInfo->hwndStPhoneNumber = NULL;
    pCuInfo->hwndEbPhoneNumber = pInfo->hwndEbNumber;
    pCuInfo->hwndStCountryCodes = NULL;
    pCuInfo->hwndLbCountryCodes = NULL;
    pCuInfo->hwndCbUseDialingRules = NULL;
    pCuInfo->hwndPbDialingRules = NULL;
    pCuInfo->hwndPbAlternates = NULL;
    pCuInfo->hwndStComment = NULL;
    pCuInfo->hwndEbComment = NULL;
    pCuInfo->pListAreaCodes = pInfo->pListAreaCodes;

    // Disaster defaults only.  Not used in normal operation.
    //
    pCuInfo->dwCountryId = 1;
    pCuInfo->dwCountryCode = 1;

    Edit_LimitText( pCuInfo->hwndEbPhoneNumber, RAS_MaxPhoneNumber );

    pInfo->fCuInfoInitialized = TRUE;

    // Load the phone number fields from the shared link.
    //
    {
        PBLINK* pLink;
        DTLNODE* pPhoneNode;

        pLink = (PBLINK* )DtlGetData( pInfo->pArgs->pSharedNode );
        ASSERT( pLink );

        pPhoneNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );
        if (pPhoneNode)
        {
            CuSetInfo( &pInfo->cuinfo, pPhoneNode, FALSE );
            DestroyPhoneNode( pPhoneNode );
        }
    }

    Edit_SetSel( pInfo->hwndEbNumber, 0, -1 );
    SetFocus( pInfo->hwndEbNumber );

    return FALSE;
}


BOOL
PaKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false if it can be dismissed.
    //
{
    return FALSE;
}


BOOL
PaSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if (RASET_Phone != pEntry->dwType)
    {
        fDisplayPage = FALSE;
    }
    else
    {
        LPARAM dwWizButtons = PSWIZB_NEXT;
        DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

        // Show the back button if we're shell owned or, we have the
        // La page or the Ma page before us.  La page will be shown if
        // not RASEDFLAG_NewPhoneEntry.  Ma page will be shown if !fSkipMa.
        //
        if ((dwFlags & RASEDFLAG_ShellOwned) ||
            !(dwFlags & RASEDFLAG_NewPhoneEntry) || !pInfo->fSkipMa)
        {
            dwWizButtons |= PSWIZB_BACK;
        }

        PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
        fDisplayPage = TRUE;
    }

    return fDisplayPage;
}

//----------------------------------------------------------------------------
// Public network property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
PnDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Public Network page of the wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return PnInit( hwnd );

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT (pInfo);

            switch (LOWORD(wparam))
            {
                case CID_PN_LB_DialAnotherFirst:
                {
                    if (HIWORD( wparam ) == CBN_SELCHANGE)
                    {
                        PnDialAnotherFirstSelChange( pInfo );
                        return TRUE;
                    }
                    break;
                }

                // NOTE for the following 2 handlers:
                // For keyboard navigation, we receive 2 BN_CLICKED notifications,
                // one before the button is actually clicked, and one afterwards.
                // Handling both clicks causes problems (unexpected re-entrancy)
                // so make sure each button only handles the latter click. (i.e.
                // the one where it is already checked)
                //
                case CID_PN_RB_DoNotDialFirst:
                {
                    switch (HIWORD( wparam))
                    {
                        case BN_CLICKED:
                        {
                            if (BST_CHECKED == IsDlgButtonChecked (pInfo->hwndPn,
                                                    CID_PN_RB_DoNotDialFirst))
                            {
                                PnUpdateLbDialAnotherFirst( pInfo );
                                return TRUE;
                            }
                        }
                    }
                    break;
                }

                case CID_PN_RB_DialFirst:
                {
                    switch (HIWORD( wparam))
                    {
                        case BN_CLICKED:
                        {
                            if (BST_CHECKED == IsDlgButtonChecked (pInfo->hwndPn,
                                                    CID_PN_RB_DialFirst))
                            {
                                PnUpdateLbDialAnotherFirst( pInfo );
                                return TRUE;
                            }
                        }
                    }
                    break;
                }
            }
            break;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("PnSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = PnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("PnKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = PnKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


VOID
PnClearLbDialFirst(
    IN HWND hwndLbDialFirst )

    // Clear prerequisite entry list box.  'hwndLbDialAnotherFirst' is the
    // window handle of the listbox control.  context.
    //
{
    PREREQITEM* pItem;

    while (pItem = ComboBox_GetItemDataPtr( hwndLbDialFirst, 0 ))
    {
        ComboBox_DeleteString( hwndLbDialFirst, 0 );
        Free0( pItem->pszEntry );
        Free0( pItem->pszPbk );
        Free( pItem );
    }
}


VOID
PnDialAnotherFirstSelChange(
    IN AEINFO* pInfo )
{
    PBENTRY* pEntry;
    PREREQITEM* pItem;
    INT iSel;

    iSel = ComboBox_GetCurSel( pInfo->hwndLbDialFirst );
    if (iSel < 0)
    {
        return;
    }

    pEntry = pInfo->pArgs->pEntry;

    Free0( pEntry->pszPrerequisiteEntry );
    Free0( pEntry->pszPrerequisitePbk );

    pItem = (PREREQITEM* )
        ComboBox_GetItemDataPtr( pInfo->hwndLbDialFirst, iSel );

    if(NULL != pItem)
    {
        pEntry->pszPrerequisiteEntry = StrDup( pItem->pszEntry );
        pEntry->pszPrerequisitePbk = StrDup( pItem->pszPbk );
    }
}

// !!! Make this common with GeFillLbDialAnotherFirst
VOID
PnUpdateLbDialAnotherFirst(
    IN AEINFO* pInfo )

    // Fill prerequisite entry list box with all non-VPN entries in the
    // phonebook, and select the prerequiste one.  'pInfo' is the property
    // sheet context.
    //
{
    BOOL fEnabledLb = FALSE;

    ComboBox_ResetContent( pInfo->hwndLbDialFirst );

    if (BST_CHECKED == IsDlgButtonChecked (pInfo->hwndPn,
                            CID_PN_RB_DialFirst))
    {
        DWORD i;
        INT iThis;
        INT iSel;
        TCHAR* pszEntry;
        TCHAR* pszPrerequisiteEntry;
        RASENTRYNAME* pRens;
        RASENTRYNAME* pRen;
        DWORD dwRens;

        PnClearLbDialFirst( pInfo->hwndLbDialFirst );

        iSel = 0;
        pszEntry = pInfo->pArgs->pEntry->pszEntryName;

        pszPrerequisiteEntry = pInfo->pArgs->pEntry->pszPrerequisiteEntry;

        if (GetRasEntrynameTable( &pRens, &dwRens ) != 0)
        {
            return;
        }

        for (i = 0, pRen = pRens; i < dwRens; ++i, ++pRen )
        {
            PREREQITEM* pItem;

            if (lstrcmp( pRen->szEntryName, pszEntry ) == 0)
            {
                continue;
            }

            pItem = Malloc( sizeof(PREREQITEM) );
            if (!pItem)
            {
                continue;
            }

            pItem->pszEntry = StrDup( pRen->szEntryName );
            pItem->pszPbk = StrDup( pRen->szPhonebookPath );

            if (!pItem->pszEntry || !pItem->pszPbk)
            {
                Free0( pItem->pszEntry );
                Free( pItem );
                continue;
            }

            iThis = ComboBox_AddItem(
                pInfo->hwndLbDialFirst, pItem->pszEntry,  pItem );

            if (pszPrerequisiteEntry && *(pszPrerequisiteEntry)
                && lstrcmp( pItem->pszEntry, pszPrerequisiteEntry ) == 0)
            {
                iSel = iThis;
                ComboBox_SetCurSelNotify( pInfo->hwndLbDialFirst, iSel );
            }
        }

        Free( pRens );

        if (iSel == 0)
        {
            ComboBox_SetCurSelNotify( pInfo->hwndLbDialFirst, iSel );
        }

        fEnabledLb = TRUE;
    }
    else
    {
        // Toss the existing prerequesite entry since its disabled.
        //
        PBENTRY* pEntry = pInfo->pArgs->pEntry;

        Free0( pEntry->pszPrerequisiteEntry );
        pEntry->pszPrerequisiteEntry = NULL;
        Free0( pEntry->pszPrerequisitePbk );
        pEntry->pszPrerequisitePbk = NULL;
    }
    EnableWindow( pInfo->hwndLbDialFirst, fEnabledLb );
}


BOOL
PnInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    PBENTRY *pEntry;

    TRACE("PnInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndPn = hwndPage;

    pInfo->hwndLbDialFirst =
        GetDlgItem( hwndPage, CID_PN_LB_DialAnotherFirst );
    ASSERT( pInfo->hwndLbDialFirst );

    pEntry = pInfo->pArgs->pEntry;

    if(RASET_Vpn == pEntry->dwType)
    {

        // Set the dial another first radio button so that the
        // combo box of entries to dial can be filled in.  If it
        // turns out that there were no entries we don't need to show the page.
        //
        CheckDlgButton( hwndPage, CID_PN_RB_DialFirst, BST_CHECKED );
    }

    PnUpdateLbDialAnotherFirst( pInfo );

    if (0 == ComboBox_GetCount( pInfo->hwndLbDialFirst ))
    {
        pInfo->fHidePublicNetworkPage = TRUE;
    }

    return TRUE;
}


BOOL
PnKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    return FALSE;
}

BOOL
PnSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if (pInfo->fHidePublicNetworkPage || (RASET_Vpn != pEntry->dwType))
    {
        fDisplayPage = FALSE;
    }
    else
    {
        LPARAM dwWizButtons = PSWIZB_NEXT;
        DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

        // Show the back button if we're shell owned or, we have the
        // La page before us.  La page will be shown if
        // not RASEDFLAG_NewTunnelEntry.
        //
        if ((dwFlags & RASEDFLAG_ShellOwned) ||
            !(dwFlags & RASEDFLAG_NewTunnelEntry))
        {
            dwWizButtons |= PSWIZB_BACK;
        }

        PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
        fDisplayPage = TRUE;
    }

    return fDisplayPage;
}

//----------------------------------------------------------------------------
// Smart card wizard page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
ScDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Smart Card page of the wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return ScInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("ScSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = ScSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("MaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = ScKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
ScInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("ScInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
     }

    //Smart card page is shown only for workplace path
    //
    if ( !AeIsWorkPlace(pInfo->pArgs->pApiArgs->dwFlags) )
    {
        pInfo->fSmartCardInstalled = FALSE;
        pInfo->fUseSmartCard = FALSE;

        return TRUE;
    }
    // Initialize page-specific context information.
    //
    pInfo->hwndSc = hwndPage;
    pInfo->hwndScRbYes = GetDlgItem ( hwndPage, CID_SC_RB_YesSmartCard );
    pInfo->hwndScRbNo = GetDlgItem ( hwndPage, CID_SC_RB_NoSmartCard );

    // Discover whether a smart card reader is installed.  If so, default
    // to not use it.
    //
    pInfo->fSmartCardInstalled = ScSmartCardReaderInstalled( pInfo );
    pInfo->fUseSmartCard = FALSE;

    return FALSE;
}

BOOL
ScKillActive(
    IN AEINFO* pInfo )

    // Called when the smart card page is loosing activation.  Records
    // whether the use selected to use his/her smart card.
{
    //Smart card page is shown only for workplace path
    //
    if ( !AeIsWorkPlace(pInfo->pArgs->pApiArgs->dwFlags) )
    {
        return FALSE;
    }

    pInfo->fUseSmartCard =
        ( SendMessage(pInfo->hwndScRbYes, BM_GETCHECK, 0, 0) == BST_CHECKED );

    return FALSE;
}

BOOL
ScSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    //Smart card page is shown only for workplace path
    //
    if ( !AeIsWorkPlace(pInfo->pArgs->pApiArgs->dwFlags) )
    {
        return FALSE;
    }

    // Initialize the "use smart card" check
    SendMessage (
        pInfo->hwndScRbYes,
        BM_SETCHECK,
        (pInfo->fUseSmartCard) ? BST_CHECKED : BST_UNCHECKED,
        0);

    // Initialize the "use smart card" check
    SendMessage (
        pInfo->hwndScRbNo,
        BM_SETCHECK,
        (pInfo->fUseSmartCard) ? BST_UNCHECKED : BST_CHECKED,
        0);

    // Only show the page when a smart card reader is installed
    return pInfo->fSmartCardInstalled;
}

BOOL
ScSmartCardReaderInstalled(
    IN AEINFO* pInfo)

    // Returns TRUE iff there is a smart card reader installed.
    // Clone of FSmartCardReaderInstalled in ppp\eaptls\util.c
    //
{
    LONG            lErr;
    DWORD           dwLen   = 0;
    SCARDCONTEXT    hCtx    = 0;
    BOOL            fReturn = FALSE;

    lErr = SCardListReadersA(0, NULL, NULL, &dwLen);

    fReturn = (   (NO_ERROR == lErr)
               && (2 * sizeof(CHAR) < dwLen));

    if (!fReturn)
    {
        goto LDone;
    }

    fReturn = FALSE;

    lErr = SCardEstablishContext(SCARD_SCOPE_USER, 0, 0, &hCtx);

    if (SCARD_S_SUCCESS != lErr)
    {
        goto LDone;
    }

    lErr = SCardListReadersA(hCtx, NULL, NULL, &dwLen);

    fReturn = (   (NO_ERROR == lErr)
               && (2 * sizeof(CHAR) < dwLen));

LDone:

    if (0 != hCtx)
    {
        SCardReleaseContext(hCtx);
    }
    
    return(fReturn);
}


INT_PTR CALLBACK
StDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the start page of the wizard.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            AEINFO* pInfo = (AEINFO* )(((PROPSHEETPAGE* )lparam)->lParam);
            SetWindowLongPtr( hwnd, DWLP_USER, (ULONG_PTR )pInfo );

            // Position the dialog per caller's instructions if we're not
            // owned by the shell.
            //
            if (!(pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned))
            {
                PositionDlg( GetParent( hwnd ),
                    pInfo->pArgs->pApiArgs->dwFlags & RASDDFLAG_PositionDlg,
                    pInfo->pArgs->pApiArgs->xDlg,
                    pInfo->pArgs->pApiArgs->yDlg );
            }

            return StInit( hwnd, pInfo );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("StSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = StSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("StKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = StKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
StInit(
    IN     HWND    hwndPage,
    IN OUT AEINFO* pInfo )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.  'pInfo' is the arguments from the PropertySheet caller.
    //
    // Return false if focus was set, true otherwise.
    //
{
    pInfo->hwndDlg = GetParent( hwndPage );

    // Initialize the common controls library for the controls we use.
    //
    {
        INITCOMMONCONTROLSEX icc;
        icc.dwSize = sizeof(icc);
        icc.dwICC  = ICC_INTERNET_CLASSES;
        InitCommonControlsEx (&icc);
    }

    return TRUE;
}

BOOL
StKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    return FALSE;
}

BOOL
StSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    return FALSE;
}


//----------------------------------------------------------------------------
// Users property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
UsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Users page of the wizard.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return UsInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("UsSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = UsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("UsKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = UsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
UsInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("UsInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Don't execute on personal (DT page in this case)
    //
    if (IsConsumerPlatform())
    {
    //For consumer platform, personal or non-domain professional
    //all connections are all-user
        pInfo->fCreateForAllUsers = TRUE;
        return TRUE;
    }
    
    // Initialize page-specific context information.
    //
    pInfo->hwndUs = hwndPage;
    pInfo->hwndUsRbForAll = GetDlgItem( hwndPage, CID_US_RB_All ); 
    pInfo->hwndUsRbForMe  = GetDlgItem( hwndPage, CID_US_RB_Myself ); 
    
    // If the user is an administrator or power user, we want the default
    // to be to create the phone book entry for all users.  This
    // must correspond to how ReadPhonebookFile opens the default phonebook.
    //
    //For whistler bug 382795
    //We let the VPN connection default to "My use only"
    //
    if ( RASEDFLAG_NewTunnelEntry & pInfo->pArgs->pApiArgs->dwFlags )
    {
        pInfo->fCreateForAllUsers = FALSE;
    }
    else
    {    
        pInfo->fCreateForAllUsers = pInfo->pArgs->fIsUserAdminOrPowerUser;
    }

    return TRUE;
}

BOOL
UsKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    BOOL fCreateForAllUsers;

    // Don't execute on personal (DT page in this case)
    //
    if (IsConsumerPlatform())
    {
        return FALSE;
    }

    fCreateForAllUsers = Button_GetCheck( pInfo->hwndUsRbForAll );

    // We need to (re)open the phonebook file corresponding to the selection.
    // Only do this if the selection has changed, or we don't have the file
    // open yet.  We definitely need to have it open when this page is left
    // because subsequent pages depend on it.
    //
    if ((fCreateForAllUsers != pInfo->fCreateForAllUsers) ||
        !pInfo->pArgs->pFile ||
        (fCreateForAllUsers != IsPublicPhonebook(pInfo->pArgs->pFile->pszPath)))
    {

        pInfo->fCreateForAllUsers = fCreateForAllUsers;

        // Close and re-open the phonebook file since the All Users flag has
        // changed
        ReOpenPhonebookFile(pInfo->fCreateForAllUsers,
                            pInfo->pArgs->pFile);

    }

    return FALSE;
}

BOOL
UsSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    // Don't execute on personal (DT page in this case)
    //
    if (IsConsumerPlatform())
    {
        return FALSE;
    }
    
    if (pInfo->fDccHost)
    {
        return FALSE;
    }

    // We don't give the option to create all-user connections to non-admins.
    //
    if (!pInfo->pArgs->fIsUserAdminOrPowerUser)
    {
        EnableWindow( pInfo->hwndUsRbForAll, FALSE );

        //Change for whistler bug 283902    gangz
        //
        Button_SetCheck( pInfo->hwndUsRbForMe, TRUE);

    }

    // Set the radio buttons.
    //
    /*
    //For whistler bug 382795
    //We let the VPN connection default to "My use only"
    //
    if ( RASEDFLAG_NewTunnelEntry & pInfo->pArgs->pApiArgs->dwFlags )
    {
        Button_SetCheck( pInfo->hwndUsRbForAll, FALSE);
        Button_SetCheck( pInfo->hwndUsRbForMe, TRUE );
    }
    else
    */
    {
        Button_SetCheck( pInfo->hwndUsRbForAll, pInfo->fCreateForAllUsers );
        Button_SetCheck( pInfo->hwndUsRbForMe, !pInfo->fCreateForAllUsers );
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


//----------------------------------------------------------------------------
// Shared-access property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
SwDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Shared-access page of the wizard.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return SwInit( hwnd );

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT(pInfo);

            return SwCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("SwSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = SwSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("SwKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = SwKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
SwCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "SwCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_SW_PB_Shared:
        {
            BOOL fShared =
                Button_GetCheck( GetDlgItem(pInfo->hwndSw, CID_SW_PB_Shared) );
            EnableWindow(
                GetDlgItem( pInfo->hwndSw, CID_SW_ST_DemandDial), fShared );
            EnableWindow(
                GetDlgItem( pInfo->hwndSw, CID_SW_PB_DemandDial), fShared );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
SwInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("SwInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndSw = hwndPage;
    Button_SetCheck(
        GetDlgItem(pInfo->hwndSw, CID_SW_PB_Shared),
        pInfo->pArgs->fShared );
    Button_SetCheck(
        GetDlgItem(pInfo->hwndSw, CID_SW_PB_DemandDial),
        pInfo->pArgs->fDemandDial );
    SwCommand(
        pInfo, BN_CLICKED, CID_SW_PB_Shared,
        GetDlgItem(pInfo->hwndSw, CID_SW_PB_Shared) );

    return TRUE;
}


BOOL
SwKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    if (!pInfo->fCreateForAllUsers)
    {
        pInfo->pArgs->fNewShared = pInfo->pArgs->fShared;
        pInfo->pArgs->fNewDemandDial = pInfo->pArgs->fDemandDial;
    }
    else
    {
        pInfo->pArgs->fNewShared =
            Button_GetCheck( GetDlgItem(pInfo->hwndSw, CID_SW_PB_Shared) );
        pInfo->pArgs->fNewDemandDial =
            Button_GetCheck( GetDlgItem(pInfo->hwndSw, CID_SW_PB_DemandDial) );
        if (pInfo->pArgs->fNewShared)
        {
            UINT    unId;
            MSGARGS msgargs;
            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.dwFlags = MB_YESNO | MB_ICONINFORMATION;
            unId = MsgDlg( pInfo->hwndDlg, SID_EnableSharedAccess, &msgargs );
            if (unId == IDNO)
            {
                pInfo->pArgs->fNewShared = pInfo->pArgs->fShared;
                pInfo->pArgs->fNewDemandDial = pInfo->pArgs->fDemandDial;
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL
SwSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    NT_PRODUCT_TYPE ProductType;
    ASSERT(pInfo);
    // skip the page if
    // (a) this is a workstation installation
    // (b) the user does not have administrative privileges
    // (c) the connection is not for all users
    // (d) TCP/IP is not configured
    // (e) there is already a shared connection
    // (f) there are no lan connections
    //
    RtlGetNtProductType(&ProductType);
    if (ProductType == NtProductWinNt ||
        !pInfo->pArgs->fIsUserAdminOrPowerUser ||
        !pInfo->fCreateForAllUsers ||
        !pInfo->fIpConfigured ||
        // pInfo->pArgs->fAnyShared ||
        !pInfo->pArgs->dwLanCount )
    {
        return FALSE;
    }
    else
    {
        EnableWindow(
            GetDlgItem( pInfo->hwndSw, CID_SW_ST_DemandDial ),
            pInfo->pArgs->fNewShared );
        EnableWindow(
            GetDlgItem( pInfo->hwndSw, CID_SW_PB_DemandDial ),
            pInfo->pArgs->fNewShared );
        return TRUE;
    }
}


//----------------------------------------------------------------------------
// Shared private-lan property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
SpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Shared private-lan page of the wizard.
    // Parameters / and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return SpInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("SpSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = SpSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("SpKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = SpKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
SpInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    DWORD i;
    INT item;
    AEINFO* pInfo;
    NETCON_PROPERTIES* pLanTable;

    TRACE("SpInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndSp = hwndPage;
    pInfo->hwndSpLbPrivateLan = GetDlgItem( hwndPage, CID_SP_LB_PrivateLan );
    ASSERT( pInfo->hwndSpLbPrivateLan );

    // Fill the drop-list with lan connections
    //
  /*  pLanTable = (NETCON_PROPERTIES*)pInfo->pArgs->pLanTable;
    for (i = 0; i < pInfo->pArgs->dwLanCount; i++)
    {
        item =
            ComboBox_AddString(
                pInfo->hwndSpLbPrivateLan, pLanTable[i].pszwName );
        if (item != CB_ERR)
        {
            ComboBox_SetItemData(
                pInfo->hwndSpLbPrivateLan, item, &pLanTable[i].guidId );
        }
    }*/

    ComboBox_SetCurSel( pInfo->hwndSpLbPrivateLan, 0 );

    return TRUE;
}


BOOL
SpKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    if (!pInfo->pArgs->fNewShared || (pInfo->pArgs->dwLanCount <= 1))
    {
        pInfo->pArgs->pPrivateLanConnection = NULL;
    }
    else
    {
        INT item = ComboBox_GetCurSel( pInfo->hwndSpLbPrivateLan );
        if (item != CB_ERR)
        {
            pInfo->pArgs->pPrivateLanConnection =
                (IHNetConnection*)ComboBox_GetItemData(
                    pInfo->hwndSpLbPrivateLan, item );
        }
    }
    return FALSE;
}


BOOL
SpSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    ASSERT(pInfo);
    // skip the page if
    // (a) sharing has not been enabled
    // (b) there is less than or equal to one lan interface.
    //
    if (!pInfo->pArgs->fNewShared || (pInfo->pArgs->dwLanCount <= 1))
    {
        return FALSE;
    }
    return TRUE;
}


BOOL
GhCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3("GhCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_GH_RB_Host:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    pInfo->fDccHost = TRUE;
                    break;
                }
            }
            break;
        }

        case CID_GH_RB_Guest:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    pInfo->fDccHost = FALSE;
                    break;
                }
            }
            break;
        }
    }

    return FALSE;
}


INT_PTR CALLBACK
GhDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Guest Host page of the Direct Connect wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return GhInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("GhSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = GhSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("PaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = GhKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT(pInfo);

            return GhCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}



BOOL
GhInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    HWND hwndHost = GetDlgItem( hwndPage, CID_GH_RB_Host );
    HWND hwndGuest = GetDlgItem( hwndPage, CID_GH_RB_Guest );

    TRACE("GhInit");

    // Initialize page-specific context information.
    //
    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    pInfo->hwndGh = hwndPage;

    // If the user is an admin or power user, then enable the
    // host control and set focus to it
    //
    if (pInfo->pArgs->fIsUserAdminOrPowerUser)
    {
        pInfo->fDccHost = TRUE;
        SetFocus(hwndHost);
    }

    // Otherwise, this page will be skipped
    //
    else
    {
        pInfo->fDccHost = FALSE;
        EnableWindow(hwndHost, FALSE);
        SetFocus(hwndGuest);
    }

    SendMessage (
        hwndHost,
        BM_SETCHECK,
        (pInfo->fDccHost) ? BST_CHECKED : BST_UNCHECKED,
        0);

    SendMessage (
        hwndGuest,
        BM_SETCHECK,
        (!pInfo->fDccHost) ? BST_CHECKED : BST_UNCHECKED,
        0);

    return FALSE;
}


BOOL
GhKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false if it can be dismissed.
    //
{
    // Show the ras-server specific pages according to whether
    // host was selected.  Show the ras client pages accordingly.
    RassrvShowWizPages (pInfo->pvDccHostContext, pInfo->fDccHost);

    return FALSE;
}

BOOL
GhSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    LPARAM dwWizButtons = PSWIZB_NEXT;

    // If we're not an admin, only the guest path
    // is available. 
    //
    if (! pInfo->pArgs->fIsUserAdminOrPowerUser)
    {
        pInfo->fDccHost = FALSE;
    }

    if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
    {
        dwWizButtons |= PSWIZB_BACK;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
    
    return TRUE;
}

DWORD
DnUpdateSelectedDevice(
    IN AEINFO* pInfo,
    IN HWND hwndLv)

    // Called to a handle the fact that a device has changed
    // in the direct connect wizard.
{

    DTLLIST* pList = NULL;
    DTLNODE* pNode = NULL, *pNode2 = NULL;
    PBLINK * pLink = NULL;

    // pmay: 372661
    // 
    // Validate the connection type so that the right logic is
    // applied.
    //
    if (pInfo->pArgs->pEntry->dwType != RASET_Direct)
    {
        return NO_ERROR;
    }

    pList = pInfo->pArgs->pEntry->pdtllistLinks;

    // Get node from current selection
    pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
        hwndLv,
        ComboBox_GetCurSel( hwndLv ) );

    if(NULL == pNode)
    {   
        return NO_ERROR;
    }

    // Remove selected item from list of links
    // and disable all other links
    DtlRemoveNode ( pList, pNode );

    for (pNode2 = DtlGetFirstNode (pList);
         pNode2;
         pNode2 = DtlGetNextNode (pNode2))
    {
        pLink = (PBLINK* )DtlGetData( pNode2 );
        pLink->fEnabled = FALSE;
    }

    // Enable selected device and Re-add
    // in list of links at front
    pLink = (PBLINK* )DtlGetData( pNode );
    pLink->fEnabled = TRUE;
    DtlAddNodeFirst( pList, pNode );

    return NO_ERROR;
}

BOOL
DnCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3("DnCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wNotification)
    {
        case CBN_SELCHANGE:
            if (wId == CID_DN_CB_DeviceSelect)
                DnUpdateSelectedDevice(pInfo, hwndCtrl);
            break;
    }

    return FALSE;
}



INT_PTR CALLBACK
DnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the direct connect device page of the Direct Connect wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return DnInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("GhSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = DnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("PaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = DnKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT(pInfo);

            return DnCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}

BOOL
DnInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    HWND hwndCb = GetDlgItem( hwndPage, CID_DN_CB_DeviceSelect );

    TRACE("DnInit");

    // Initialize page-specific context information.
    //
    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    pInfo->hwndDn = hwndPage;

    // Fill the dropdown list of devices and select the first item.
    //
    {
        TCHAR*   psz;
        DTLNODE* pNode;
        INT      iItem;

        iItem = 1;
        for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = NULL;
            DWORD dwImage;

            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            psz = DisplayPszFromPpbport( &pLink->pbport, &dwImage );
            if (psz)
            {
                PBLINK* pLinkTmp = NULL;

                pLinkTmp = (PBLINK* )DtlGetData( pNode );
                ComboBox_AddItem( hwndCb, psz, pNode );
                Free( psz );
            }
        }
        ComboBox_SetCurSelNotify(hwndCb, 0);
    }


    SetFocus( hwndCb );

    return FALSE;
}

BOOL
DnKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false if it can be dismissed.
    //
{
    return FALSE;
}


BOOL
DnSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    LPARAM dwWizButtons = PSWIZB_NEXT;
    DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

    PBENTRY* pEntry = pInfo->pArgs->pEntry;

    // If the "guest" option of the dcc client wasn't selected,
    // don't allow this page to show.
    if ((pInfo->fDccHost) || (RASET_Direct != pEntry->dwType))
    {
        return FALSE;
    }

    // Show the back button if we're shell owned or, we have the
    // La page before us.
    //
    if ((dwFlags & RASEDFLAG_ShellOwned) ||
        !(dwFlags & RASEDFLAG_NewDirectEntry) || !pInfo->fSkipMa)
    {
        dwWizButtons |= PSWIZB_BACK;
    }


    PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\main.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// main.c
// Remote Access Common Dialog APIs
// Main routines
//
// 06/20/95 Steve Cobb


#include "rasdlgp.h"
#include "treelist.h" // for TL_Init: RasMonitorDlg only
#define INCL_ENCRYPT
#include <rassrvp.h>  // [pmay] private header merges this project with ras server ui

//-----------------------------------------------------------------------------
// Rasdlg globals
//-----------------------------------------------------------------------------

// IMPORTANT: No globals may be defined that do not work properly when the DLL
//            is called by multiple threads within a single process.
//

// Handle of the DLL instance set from the corresponding DllMain parameter.
//
HINSTANCE g_hinstDll = NULL;

// The atom identifying our context property suitable for use by the Windows
// XxxProp APIs.  A Prop is used to associate context information with a
// property sheet.  The atom is registered in DllMain.
//
LPCTSTR g_contextId = NULL;

// The handle of the RAS wizard bitmap.  This is needed only because
// DLGEDIT.EXE is currently unable to produce the RC syntax necessary to
// create a self-contained SS_BITMAP control, so the image must be set at
// run-time.  See also SetWizardBitmap().
//
HBITMAP g_hbmWizard = NULL;

// The name of the on-line help file.  Initialized in DllMain.
//
TCHAR* g_pszHelpFile = NULL;

// The name of the on-line ROUTER help file.  Initialized in DllMain.
//
TCHAR* g_pszRouterHelpFile = NULL;

// Count of RasDial callbacks active and the flag telling the dialer to
// terminate them ASAP, plus the mutex that protects these fields.
//
LONG g_ulCallbacksActive = 0L;   //Change this for whistler bug 341662   gangz
BOOL g_fTerminateAsap = FALSE;

//for XPSP2 511810, .Net 668164
CRITICAL_SECTION g_csCallBacks;

// For whistler 460931
CRITICAL_SECTION  g_csDiagTab;

// ----------------------------------------------------------------------------
// Rasdlg DLL entrypoint
// ----------------------------------------------------------------------------

BOOL
DllMain(
    HANDLE hinstDll,
    DWORD fdwReason,
    LPVOID lpReserved )

    // This routine is called by the system on various events such as the
    // process attachment and detachment.  See Win32 DllEntryPoint
    // documentation.
    //
    // Returns true if successful, false otherwise.
    //
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        // Initialize trace and assert support.
        //
        DEBUGINIT( "RASDLG" );

        // Initialize fusion
        // For whistler bug 349866
        //
         SHFusionInitializeFromModuleID(hinstDll, 128);


        // Stash the DLL instance handle for use in the dialog/window calls
        // later.
        //
        g_hinstDll = hinstDll;

        // Register the context ID atom for use in the Windows XxxProp calls
        // which are used to associate a context with a dialog window handle.
        //
        g_contextId = (LPCTSTR )GlobalAddAtom( TEXT("RASDLG") );
        if (!g_contextId)
            return FALSE;

        //[gangz] For whistler 460931
        __try
        {
            InitializeCriticalSection( & g_csDiagTab );
        }
         __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;    
         }

        //for XPSP2 511810, .Net 668164
        // CriticalSection protecting count of active RasDial callbacks.
        //
        __try
        {
            InitializeCriticalSection( &g_csCallBacks);
        }
         __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;    
         }

        // Initialize the TreeList custom control
        //
        TL_Init( hinstDll );

        // Load the name of our on-line help file.
        //
        g_pszHelpFile = PszFromId( hinstDll, SID_HelpFile );

        // Load the name of our on-line help file.
        //
        g_pszRouterHelpFile = PszFromId( hinstDll, SID_RouterHelpFile );

        // Initialize the Phonebook library.
        //
        if (InitializePbk() != 0)
        {
            return FALSE;
        }

        // [pmay] Allow the ras server ui to initialize
        RassrvHandleProcessAttach(hinstDll, lpReserved);
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        
        //[gangz] for whistler bug 460931
        DeleteCriticalSection( & g_csDiagTab );

        //for .net 511810
        DeleteCriticalSection( & g_csCallBacks);

        // [pmay] Allow the ras server ui to cleanup
        RassrvHandleProcessDetach(hinstDll, lpReserved);

        // Remove the context ID atom we registered at initialization.
        //
        GlobalDeleteAtom( LOWORD( g_contextId ) );

        // Unload the wizard bitmap.
        //
        if (g_hbmWizard)
            DeleteObject( (HGDIOBJ )g_hbmWizard );

        // Free the on-line help file string.
        //
        Free0( g_pszHelpFile );
        Free0( g_pszRouterHelpFile );

        /* Uninitialize the Phonebook library.
        */
        TerminatePbk();

        /* Unload dynamically loaded DLLs, if any.
        */
        UnloadRas();

        //For whistler bug 349866
        //
        SHFusionUninitialize();


        /* Terminate trace and assert support.
        */
        DEBUGTERM();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\ipsecpolicy.c ===
// Copyright (c) 2000, Microsoft Corporation, all rights reserved
//
// IPSecPolicy.c
// Remote Access Common Dialog APIs
// IPSecPolicy dialogs
//
// 10/04/2000 Gang Zhao
//


#include "rasdlgp.h"
#include <rasauth.h>
#include <rrascfg.h>
#include <ras.h>
#include <mprapi.h>
#include <mprerror.h>

//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwCiHelp[] =
{
    CID_CI_CB_PresharedKey,         HID_CI_CB_PresharedKey,
    CID_CI_ST_Key,                  HID_CI_EB_PSK,
    CID_CI_EB_PSK,                  HID_CI_EB_PSK,
    0, 0
};

//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------
typedef struct
_CIARGS
{
    EINFO * pEinfo;

}
CIARGS;

typedef struct
_CIINFO
{
    //Caller's arguments to the dialog
    //
    CIARGS * pArgs;

    //Handles of this dialog and some of its controls
    //for PSK
    HWND hwndDlg;
    HWND hwndCbPresharedKey;
    HWND hwndStKey;
    HWND hwndEbPSK;

    //for User certs
    //
    HWND hwndCbUserCerts;

    //for specific certs
    //
    HWND hwndCbSpecificCerts;
    HWND hwndPbSelect;
    HWND hwndLbCertsList;
    
}
CIINFO;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------
BOOL
CiCommand(
    IN CIINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
CiDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CiInit(
    IN HWND hwndDlg,
    IN CIARGS* pArgs );

VOID
CiTerm(
    IN HWND hwndDlg );

BOOL
CiSave(
    IN CIINFO* pInfo );

//
// Add new features for whistler bug 193987
// Pop Up a Dialog box for IPSec Policy
// currently just Pre-shared key/L2TP, and will have Certificates/L2TP in the future
//

BOOL
IPSecPolicyDlg(
    IN HWND hwndOwner,
    IN OUT EINFO* pArgs )
{
    INT_PTR nStatus;
    CIARGS args;

    TRACE( "IPSecPolicyDlg" );

    args.pEinfo = pArgs;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CI_CustomIPSec ),
            hwndOwner,
            CiDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}//end of IPSecPolicyDlg()


INT_PTR CALLBACK
CiDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Custom IPSecPolicy dialog.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "CiDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return CiInit( hwnd, (CIARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwCiHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            CIINFO* pInfo = (CIINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return CiCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            CiTerm( hwnd );
            break;
        }
    }

    return FALSE;
}//end of CiDlgProc()


BOOL
CiInit(
    IN HWND hwndDlg,
    IN CIARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's arguments as passed to the stub
    // API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr = NO_ERROR;
    CIINFO* pInfo = NULL;

    TRACE( "CiInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndCbPresharedKey = GetDlgItem( hwndDlg, CID_CI_CB_PresharedKey );
    ASSERT(pInfo->hwndCbPresharedKey);
    pInfo->hwndStKey = GetDlgItem( hwndDlg, CID_CI_ST_Key );
    ASSERT(pInfo->hwndStKey);
    pInfo->hwndEbPSK = GetDlgItem( hwndDlg, CID_CI_EB_PSK );
    ASSERT(pInfo->hwndEbPSK);
    pInfo->hwndCbUserCerts = GetDlgItem( hwndDlg, CID_CI_CB_UserCerts );
    ASSERT(pInfo->hwndCbUserCerts);
    pInfo->hwndCbSpecificCerts = GetDlgItem( hwndDlg, CID_CI_CB_SpecificCerts );
    ASSERT(pInfo->hwndCbSpecificCerts);
    pInfo->hwndPbSelect = GetDlgItem( hwndDlg, CID_CI_PB_Select );
    ASSERT(pInfo->hwndPbSelect);
    pInfo->hwndLbCertsList = GetDlgItem( hwndDlg, CID_CI_LB_CertsList );
    ASSERT(pInfo->hwndLbCertsList);

    //Hide the User certs and Specific certs until the whistler server
    ShowWindow( pInfo->hwndCbUserCerts, SW_HIDE );
    ShowWindow( pInfo->hwndCbSpecificCerts, SW_HIDE );
    ShowWindow( pInfo->hwndPbSelect, SW_HIDE );
    ShowWindow( pInfo->hwndLbCertsList, SW_HIDE );

   // Fill the EAP packages listbox and select the previously identified
   // selection.  The Properties button is disabled by default, but may
   // be enabled when the EAP list selection is set.
   //
    {
        BOOL fEnabled;

        fEnabled = !!((pArgs->pEinfo->pEntry->dwIpSecFlags)& AR_F_IpSecPSK) ;

        Button_SetCheck( pInfo->hwndCbPresharedKey, fEnabled );

        EnableWindow( pInfo->hwndStKey, fEnabled );
        EnableWindow( pInfo->hwndEbPSK, fEnabled );

        // For whistler bug 432771      gangz
        // Limit the length of PSK to be 255
        //  
        Edit_LimitText( pInfo->hwndEbPSK, PWLEN-1 );  
    }

    //
    //Fill the Preshared Key in "*"s or just leave it bland if none 
    //is saved previously
    //
    //for Demand Dial, use MprAdmin.... router functions
    //
    if (pArgs->pEinfo->fRouter) 
    {
        if( !(pArgs->pEinfo->fPSKCached) )
        {
           // Initialize the interface-information structure.
           //
           // For whistler 522872
           HANDLE hServer = NULL;
           HANDLE hInterface = NULL;
           WCHAR* pwszInterface = NULL;
           WCHAR pszComputer[512];
           MPR_INTERFACE_0 mi0;
           MPR_CREDENTIALSEX_1 * pMc1 = NULL;

           do {
                dwErr = g_pMprAdminServerConnect(pArgs->pEinfo->pszRouter, &hServer);

                if (dwErr != NO_ERROR)
                {
                    TRACE("CiInit: MprAdminServerConnect failed!");
                    break;
                }

                ZeroMemory( &mi0, sizeof(mi0) );

                mi0.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
                mi0.fEnabled = TRUE;

                pwszInterface = StrDupWFromT( pArgs->pEinfo->pEntry->pszEntryName );
                if (!pwszInterface)
                {
                    TRACE("CiInit:pwszInterface conversion failed!");
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                lstrcpynW( 
                    mi0.wszInterfaceName, 
                    pwszInterface, 
                    MAX_INTERFACE_NAME_LEN+1 );

                // Get the interface handle
                //
                ASSERT( g_pMprAdminInterfaceGetHandle );
                dwErr = g_pMprAdminInterfaceGetHandle(
                            hServer,
                            pwszInterface,
                            &hInterface,
                            FALSE);

                if (dwErr)
                {
                    TRACE1( "CiInit: MprAdminInterfaceGetHandle error %d", dwErr);
                    break;
                }

                //Get the IPSec Policy keys(PSK for Whislter)
                //
                ASSERT( g_pMprAdminInterfaceGetCredentialsEx );
                dwErr = g_pMprAdminInterfaceGetCredentialsEx(
                            hServer,
                            hInterface,
                            1,
                            (LPBYTE *)&pMc1 );
                 if(dwErr)
                {
                    TRACE1(
                     "CiInit: MprAdminInterfaceGetCredentialsEx error %d", dwErr);
                    break;
                }

                if ( !pMc1 )
                {
                    TRACE(
                     "CiInit: MprAdminInterfaceGetCredentialsEx returns invalid credential pointer!");

                    dwErr = ERROR_CAN_NOT_COMPLETE;
                    break;
                }
                else
                {
                    if ( lstrlenA( pMc1->lpbCredentialsInfo ) >0 )
                    {
                        SetWindowText( pInfo->hwndEbPSK,TEXT("****************") );

                        // Whistler bug 254385 encode password when not being used
                        // Whistler bug 275526 NetVBL BVT Break: Routing BVT broken
                        //
                        ZeroMemory(
                            pMc1->lpbCredentialsInfo,
                            lstrlenA(pMc1->lpbCredentialsInfo) + 1 );
                    }
                    else
                    {
                        SetWindowText( pInfo->hwndEbPSK,TEXT("") );
                    }

                    ASSERT( g_pMprAdminBufferFree );
                    g_pMprAdminBufferFree( pMc1 );
                }

               }
               while (FALSE) ;

            // Cleanup
            {
                // If some operation failed, restore the router to the
                // state it was previously in.
                if ( dwErr != NO_ERROR )
                {
                    SetWindowText( pInfo->hwndEbPSK, TEXT("") );
                }

                // Close all handles, free all strings.
                if ( pwszInterface )
                {
                    Free0( pwszInterface );
                }

                if (hServer)
                {
                    g_pMprAdminServerDisconnect( hServer );
                }
            }
        }
        else
        {
            SetWindowText( pInfo->hwndEbPSK,TEXT("****************") );// pArgs->pEinfo->szPSK ); //
        }

    }
    else    //retrieve the credentials with Ras functions
    {
        // Look up cached PSK, from RASMAN or EINFO
        //
        if( !(pArgs->pEinfo->fPSKCached) )
        {
            DWORD dwErrRc;
            RASCREDENTIALS rc;

            ZeroMemory( &rc, sizeof(rc) );
            rc.dwSize = sizeof(rc);
            rc.dwMask = RASCM_PreSharedKey; 
            ASSERT( g_pRasGetCredentials );
            TRACE( "RasGetCredentials" );
            dwErrRc = g_pRasGetCredentials(
                pInfo->pArgs->pEinfo->pFile->pszPath, 
                pInfo->pArgs->pEinfo->pEntry->pszEntryName, 
                &rc );

            TRACE2( "RasGetCredentials=%d,m=%d", dwErrRc, rc.dwMask );

            if (dwErrRc == 0 && (rc.dwMask & RASCM_PreSharedKey) && ( lstrlen(rc.szPassword) > 0 ) )
            {
                SetWindowText( pInfo->hwndEbPSK, TEXT("****************") );
            }
            else
            {
                SetWindowText( pInfo->hwndEbPSK,TEXT("") );
            }

            // Whistler bug 254385 encode password when not being used
            //
            RtlSecureZeroMemory( rc.szPassword, sizeof(rc.szPassword) );
        }
        else
        {
            SetWindowText( pInfo->hwndEbPSK,TEXT("****************") );// pArgs->pEinfo->szPSK ); //
        }

    }
    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    SetFocus( pInfo->hwndEbPSK );

    return TRUE;
} //end of CiInit()


BOOL
CiCommand(
    IN CIINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "CiCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_CI_EB_PSK:
        {
            return TRUE;
        }

        case CID_CI_CB_PresharedKey:
        {
            BOOL fEnabled;
            
            fEnabled = Button_GetCheck( pInfo->hwndCbPresharedKey );
            EnableWindow( pInfo->hwndStKey, fEnabled );
            EnableWindow( pInfo->hwndEbPSK, fEnabled );
        }
        break;

        case IDOK:
        {
            if (CiSave( pInfo ))
            {
                EndDialog( pInfo->hwndDlg, TRUE );
            }
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}//end of CiCommand()

BOOL
CiSave(
    IN CIINFO* pInfo )

    // Saves control contents to caller's PBENTRY argument.  'PInfo' is the
    // dialog context.
    //
    // Returns TRUE if successful or false if invalid combination of
    // selections was detected and reported.
    //
{
        TCHAR szPSK[PWLEN + 1];
        BOOL  fPskChecked = FALSE;

        fPskChecked = Button_GetCheck( pInfo->hwndCbPresharedKey );
        
        if ( fPskChecked )
        {
            GetWindowText( pInfo->hwndEbPSK, szPSK, PWLEN+1 );
        
            if ( lstrlen( szPSK ) == 0  )
            {
                MsgDlgUtil( pInfo->hwndDlg, SID_HavetoEnterPSK, NULL, g_hinstDll, SID_PopupTitle );
                return FALSE;
            }
            else if (!lstrcmp( szPSK, TEXT("****************")) )  //16 "*" means no change
            {
                ; 
            }
            else    //save PSK to EINFO and mark the fPSKCached
            {
                // Whistler bug 224074 use only lstrcpyn's to prevent
                // maliciousness
                //
                // Whistler bug 254385 encode password when not being used
                // Assumed password was not encoded by GetWindowText()
                //
                lstrcpyn(
                    pInfo->pArgs->pEinfo->szPSK,
                    szPSK,
                    sizeof(pInfo->pArgs->pEinfo->szPSK) / sizeof(TCHAR) );
                EncodePassword( pInfo->pArgs->pEinfo->szPSK );
                pInfo->pArgs->pEinfo->fPSKCached = TRUE;
            }
        }
        else
        {
                // Whistler bug 224074 use only lstrcpyn's to prevent
                // maliciousness
                //
                lstrcpyn(
                    pInfo->pArgs->pEinfo->szPSK,
                    TEXT(""),
                    sizeof(pInfo->pArgs->pEinfo->szPSK) / sizeof(TCHAR) );
                pInfo->pArgs->pEinfo->fPSKCached = FALSE;
        }

        // Whistler bug 254385 encode password when not being used
        //
        RtlSecureZeroMemory( szPSK, sizeof(szPSK) );

        //Change the value of dwIpSecFlags only along with a valid operation
        //
        pInfo->pArgs->pEinfo->pEntry->dwIpSecFlags = fPskChecked?AR_F_IpSecPSK : 0;

    return TRUE;
}//end of CiSave()


VOID
CiTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    CIINFO* pInfo;

    TRACE( "CiTerm" );

    pInfo = (CIINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE( "Context freed" );
    }
}//end of CiTerm()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\ifw.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** ifw.c
** Remote Access Common Dialog APIs
** Add Interface wizard
**
** 02/11/97 Abolade Gbadegesin (based on entryw.c, by Steve Cobb).
*/

#include "rasdlgp.h"
#include "entry.h"
#include <winsock.h>        //got in for inet_addr

//
// Definitions for flags tracked by the interface wizard.
// See the dwFlags member of AIINFO.
//
#define AI_F_HasPhysDevs    0x1    // router has phys ports available
#define AI_F_HasTunlDevs    0x2    // router has tunnel ports available
#define AI_F_HasPptpDevs    0x4    // router has Pptp ports available
#define AI_F_HasL2tpDevs    0x8    // router has L2tp ports available
#define AI_F_HasPPPoEDevs   0x10   // router has PPPoE ports available //for whistler bug 345068 349087

/*----------------------------------------------------------------------------
** Local datatypes 
**----------------------------------------------------------------------------
*/

#define EMPTY_IPADDRESS         L"0.0.0.0"


#define SROUTEINFO struct tagSROUTEINFO
SROUTEINFO
{
    TCHAR * pszDestIP;
    TCHAR * pszNetworkMask;
    TCHAR * pszMetric;
};

#define SROUTEINFOLIST struct tagSROUTEINFOLIST
SROUTEINFOLIST
{
    SROUTEINFOLIST * pNext;
    SROUTEINFO       RouteInfo;
};


/* Add Interface wizard context block.  All property pages refer to the single
** context block associated with the sheet.
*/
#define AIINFO struct tagAIINFO
AIINFO
{
    /* Common input arguments.
    */
    EINFO* pArgs;

    /* Wizard and page handles.  'hwndFirstPage' is the handle of the first
    ** property page initialized.  This is the page that allocates and frees
    ** the context block.
    */
    HWND hwndDlg;
    HWND hwndFirstPage;
    HWND hwndRb;    //Add for DOD wizard 345068 349087
    HWND hwndRw;
    HWND hwndIn;
    HWND hwndSr;
    HWND hwndSs;
    HWND hwndRn;
    HWND hwndRp;
    HWND hwndRc;
    HWND hwndRa;
    HWND hwndNs;
    HWND hwndDo;
    HWND hwndDi;
    HWND hwndRf;
    HWND hwndVd;

    /* Interface Name page.
    */
    HWND hwndEbInterfaceName;

    /* Modem/Adapter page.
    */
    HWND hwndLv;

    /* Connection type page
    */
    HWND hwndRbTypePhys;
    HWND hwndRbTypeTunl;
    HWND hwndRbBroadband;   //Add for DOD wizard

    /* Phone number page.
    */
    HWND hwndStNumber;
    HWND hwndEbNumber;  //Share by VpnDestination, PhoneNumber, PPPoE
    HWND hwndPbAlternates;

    /* Login script page.
    */
    HWND hwndCbRunScript;
    HWND hwndLbScripts;
    HWND hwndCbTerminal;
    HWND hwndPbEdit;
    HWND hwndPbBrowse;

    /* IP address page.
    */
    HWND hwndCcIp;

    /* Name server page.
    */
    HWND hwndCcDns;
    HWND hwndCcWins;

    /* Vpn type page
    */
    HWND hwndVtRbAutomatic;
    HWND hwndVtRbPptp;
    HWND hwndVtRbL2tp;

    /* Dial-out credentials page.
    */
    HWND hwndDoEbUserName;
    HWND hwndDoEbDomain;
    HWND hwndDoEbPassword;
    HWND hwndDoEbConfirm;

    /* Dial-in credentials page.
    */
    HWND hwndDiEbUserName;
    HWND hwndDiEbDomain;
    HWND hwndDiEbPassword;
    HWND hwndDiEbConfirm;

    /* Router welcome page
    */
    HWND hwndRwStWelcome;

    /* Router finish page
    */
    HWND hwndRfStFinish;

    /* Static Route Page
    */
    HWND hwndLvStaticRoutes;

    /* Static Route Add Dialog
    */
    HWND hwndDest;
    HWND hwndNetMask;
    HWND hwndMetric;

    /* The phone number stash.  This allows user to change the port to another
    ** link without losing the phone number he typed.  Initialized to empty in
    ** AiInit and saved to entry in AiFinish.
    */
    DTLLIST* pListPhoneNumbers;
    BOOL     fPromoteHuntNumbers;

    /* Checkbox options chosen by user.
    */
    BOOL fIp;
    BOOL fIpx;
    BOOL fClearPwOk;
    BOOL fNotNt;

    /*For connection type page, For whistler bug 349807
    */
    DWORD dwCtDeviceNum;
    
    /* Set true when there is only one meaningful choice of device.
    */
    BOOL fSkipMa;

    /* Set true if the selected device is a modem or null modem.
    */
    BOOL fModem;

    /* The NP_* mask of protocols configured for RAS.
    */
    DWORD dwfConfiguredProtocols;

    /* Set true if IP is configured for RAS.
    */
    BOOL fIpConfigured;

    //IPX is not supported on IA64
    //
    BOOL fIpxConfigured;    

    /* Set to true of Add Interface wizard is skipped.
    */
    BOOL fSkipWizard;

    // After dial scripting helper context block, and a flag indicating if the
    // block has been initialized.
    //
    SUINFO suinfo;
    BOOL fSuInfoInitialized;

    // Handle to a bold font for use with start and finish wizard pages
    HFONT hBoldFont;

    // Flags that track the configuration of the machine that the
    // wizard is currently focused on.  See AI_F_*
    DWORD dwFlags;

    // Set to the vpn type when one is configured.
    DWORD dwVpnStrategy;

    // Index of the selected device on the RN page
    //
    DWORD dwSelectedDeviceIndex;

    // List of all static routes 
    //
    SROUTEINFOLIST * pRouteInfoListHead;
};



/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

int CALLBACK
AiCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam );

VOID
AiCancel(
    IN HWND hwndPage );

AIINFO*
AiContext(
    IN HWND hwndPage );

VOID
AiExit(
    IN AIINFO* pInfo,
    IN DWORD   dwError );

VOID
AiExitInit(
    IN HWND hwndDlg );

BOOL
AiFinish(
    IN HWND hwndPage );

AIINFO*
AiInit(
    IN HWND   hwndFirstPage,
    IN EINFO* pArgs );

VOID
AiTerm(
    IN HWND hwndPage );

INT_PTR CALLBACK
RbDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RbInit(
    IN HWND hwndPage );

BOOL
RbKillActive(
    IN AIINFO* pInfo );

BOOL
RbSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
CtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CtInit(
    IN HWND   hwndPage );

BOOL
CtKillActive(
    IN AIINFO* pInfo );

BOOL
CtSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
DiDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DiInit(
    IN HWND   hwndPage );

BOOL
DiKillActive(
    IN AIINFO* pInfo );

BOOL
DiNext(
    IN AIINFO* pInfo );

BOOL
DiSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
DoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DoCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

BOOL
DoInit(
    IN HWND   hwndPage );

BOOL
DoKillActive(
    IN AIINFO* pInfo );

BOOL
DoNext(
    IN AIINFO* pInfo );
    
BOOL
DoSetActive(
    IN AIINFO* pInfo );

DWORD 
GetPhysicDeviceOtherThanLPT1(
    IN AIINFO * pInfo );


BOOL
InCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
InDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
InInit(
    IN     HWND   hwndPage);

BOOL
InKillActive(
    IN AIINFO* pInfo );

BOOL
InSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
NsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
NsInit(
    IN HWND   hwndPage );

BOOL
NsKillActive(
    IN AIINFO* pInfo );

BOOL
NsSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
RaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RaInit(
    IN HWND hwndPage );

BOOL
RaKillActive(
    IN AIINFO* pInfo );

BOOL
RaSetActive(
    IN AIINFO* pInfo );

BOOL
RcCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
RcDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RcInit(
    IN HWND hwndPage );

BOOL
RcKillActive(
    IN AIINFO* pInfo );

BOOL
RcSetActive(
    IN AIINFO* pInfo );

BOOL
RfCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
RfDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RfInit(
    IN HWND hwndPage );

BOOL
RfKillActive(
    IN AIINFO* pInfo );
    
BOOL
RfSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
RnDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RnInit(
    IN HWND hwndPage );

LVXDRAWINFO*
RnLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

VOID
RnLvItemChanged(
    IN AIINFO* pInfo );

BOOL
RnLvRefresh(
    IN AIINFO* pInfo);
    
BOOL
RnSetActive(
    IN AIINFO* pInfo );

VOID
RpAlternates(
    IN AIINFO* pInfo );

BOOL
RpCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
RpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RpInit(
    IN HWND hwndPage );

BOOL
RpKillActive(
    IN AIINFO* pInfo );

VOID
RpPhoneNumberToStash(
    IN AIINFO* pInfo );

BOOL
RpSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
RwDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RwInit(
    IN     HWND   hwndPage,
    IN OUT EINFO* pArgs );

BOOL
RwKillActive(
    IN AIINFO* pInfo );

BOOL
RwSetActive(
    IN AIINFO* pInfo );

BOOL
SrCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

VOID
SrLvItemChanged(
    IN AIINFO* pInfo );


INT_PTR CALLBACK
SrDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SrInit(
    IN HWND hwndPage );

BOOL
SrKillActive(
    IN AIINFO* pInfo );

BOOL
SrSetActive(
    IN AIINFO* pInfo );



BOOL
SsCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
SsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SsInit(
    IN HWND hwndPage );

BOOL
SsKillActive(
    IN AIINFO* pInfo );

BOOL
SsSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
VdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
VdInit(
    IN HWND   hwndPage );

BOOL
VdKillActive(
    IN AIINFO* pInfo );

BOOL
VdSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
VtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
VtInit(
    IN HWND   hwndPage );

BOOL
VtKillActive(
    IN AIINFO* pInfo );

BOOL
VtSetActive(
    IN AIINFO* pInfo );


/* Demand dial wizard page definitions.
*/
struct DD_WIZ_PAGE_INFO
{
    DLGPROC     pfnDlgProc;
    INT         nPageId;
    INT         nSidTitle;
    INT         nSidSubtitle;
    DWORD       dwFlags;
};


static const struct DD_WIZ_PAGE_INFO c_aDdWizInfo [] =
{
    { RwDlgProc, PID_RW_RouterWelcome,        0,            0,                PSP_HIDEHEADER},
    { InDlgProc, PID_IN_InterfaceName,        SID_IN_Title, SID_IN_Subtitle,  0},
    { CtDlgProc, PID_CT_RouterConnectionType, SID_CT_Title, SID_CT_Subtitle,  0},
    { VtDlgProc, PID_VT_RouterVpnType,        SID_VT_Title, SID_VT_Subtitle,  0},
    { RnDlgProc, PID_RN_RouterModemAdapter,   SID_RN_Title, SID_RN_Subtitle,  0},
    { RbDlgProc, PID_BS_BroadbandService,     SID_BS_Title, SID_BS_Subtitle,  0},
    { RpDlgProc, PID_RP_RouterPhoneNumber,    SID_RP_Title, SID_RP_Subtitle,  0},
    { VdDlgProc, PID_VD_RouterVpnDestination, SID_VD_Title, SID_VD_Subtitle,  0},
    { SsDlgProc, PID_SS_ServerSettings,       SID_SS_Title, SID_SS_Subtitle,  0},
    { SrDlgProc, PID_SR_StaticRoute,          SID_SR_Title, SID_SR_SubTitle,  0},
    { RaDlgProc, PID_RA_RouterIpAddress,      SID_RA_Title, SID_RA_Subtitle,  0},
    { NsDlgProc, PID_NS_RouterNameServers,    SID_NS_Title, SID_NS_Subtitle,  0},
    { RcDlgProc, PID_RC_RouterScripting,      SID_RC_Title, SID_RC_Subtitle,  0},
    { DiDlgProc, PID_DI_RouterDialIn,         SID_DI_Title, SID_DI_Subtitle,  0},
    { DoDlgProc, PID_DO_RouterDialOut,        SID_DO_Title, SID_DO_Subtitle,  0},
    { RfDlgProc, PID_RF_RouterFinish,         0,            0,                PSP_HIDEHEADER},
};

#define c_cDdWizPages    (sizeof (c_aDdWizInfo) / sizeof(c_aDdWizInfo[0]))


/*----------------------------------------------------------------------------
** Add Interface wizard entry point
**----------------------------------------------------------------------------
*/

VOID
AiWizard(
    IN OUT EINFO* pEinfo )

    /* Runs the Phonebook entry property sheet.  'PEinfo' is an input block
    ** with only caller's API arguments filled in.
    */
{
    DWORD           dwErr, i;
    PROPSHEETHEADER header;
    PROPSHEETPAGE   apage[ c_cDdWizPages ];
    PROPSHEETPAGE*  ppage;
    

    TRACE("AiWizard");

    ZeroMemory( &header, sizeof(header) );

    // Prepare the header
    //
    header.dwSize       = sizeof(PROPSHEETHEADER);
    header.hwndParent   = pEinfo->pApiArgs->hwndOwner;
    header.hInstance    = g_hinstDll;
    header.nPages       = c_cDdWizPages;
    header.pszbmHeader  = MAKEINTRESOURCE( BID_WizardHeader );
    header.ppsp         = apage;
    header.pfnCallback  = AiCallbackFunc;
    header.dwFlags      = 
        (
            PSH_WIZARD           | PSH_WIZARD97    |
            PSH_WATERMARK        | PSH_HEADER      | 
            PSH_STRETCHWATERMARK | PSH_USECALLBACK |
            PSH_PROPSHEETPAGE 
        );

    // Prepare the array of pages
    //
    ZeroMemory( apage, sizeof(apage) );
    for (i = 0; i < c_cDdWizPages; i++)
    {
        // Initialize page data
        //
        ppage = &apage[i];
        ppage->dwSize       = sizeof(PROPSHEETPAGE);
        ppage->hInstance    = g_hinstDll;
        ppage->pszTemplate  = MAKEINTRESOURCE(c_aDdWizInfo[i].nPageId);
        ppage->pfnDlgProc   = c_aDdWizInfo[i].pfnDlgProc;
        ppage->lParam       = (LPARAM )pEinfo;
        ppage->dwFlags      = c_aDdWizInfo[i].dwFlags;

        // Initialize title and subtitle information.
        //
        if (c_aDdWizInfo[i].nSidTitle)
        {
            ppage->dwFlags |= PSP_USEHEADERTITLE;
            ppage->pszHeaderTitle = PszLoadString( g_hinstDll,
                    c_aDdWizInfo[i].nSidTitle );
        }

        if (c_aDdWizInfo[i].nSidSubtitle)
        {
            ppage->dwFlags |= PSP_USEHEADERSUBTITLE;
            ppage->pszHeaderSubTitle = PszLoadString( g_hinstDll,
                    c_aDdWizInfo[i].nSidSubtitle );
        }
        
    }

    if (PropertySheet( &header ) == -1)
    {
        TRACE("PropertySheet failed");
        ErrorDlg( pEinfo->pApiArgs->hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN,
            NULL );
    }
}


/*----------------------------------------------------------------------------
** Add Interface wizard
** Listed alphabetically
**----------------------------------------------------------------------------
*/

int CALLBACK
AiCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam )

    /* A standard Win32 commctrl PropSheetProc.  See MSDN documentation.
    **
    ** Returns 0 always.
    */
{
    TRACE2("AiCallbackFunc(m=%d,l=%08x)",unMsg,lparam);

    if (unMsg == PSCB_PRECREATE)
    {
        DLGTEMPLATE* pDlg = (DLGTEMPLATE* )lparam;
        pDlg->style &= ~(DS_CONTEXTHELP);
    }

    return 0;
}


VOID
AiCancel(
    IN HWND hwndPage )

    /* Cancel was pressed.  'HwndPage' is the handle of a wizard page.
    */
{
    TRACE("AiCancel");
}


AIINFO*
AiContext(
    IN HWND hwndPage )

    /* Retrieve the property sheet context from a wizard page handle.
    */
{
    return (AIINFO* )GetProp( GetParent( hwndPage ), g_contextId );
}


VOID
AiExit(
    IN AIINFO* pInfo,
    IN DWORD   dwError )

    /* Forces an exit from the dialog, reporting 'dwError' to the caller.
    ** 'PInfo' is the dialog context.
    **
    ** Note: This cannot be called during initialization of the first page.
    **       See AiExitInit.
    */
{
    TRACE("AiExit");

    pInfo->pArgs->pApiArgs->dwError = dwError;
    PropSheet_PressButton( pInfo->hwndDlg, PSBTN_CANCEL );
}


VOID
AiExitInit(
    IN HWND hwndDlg )

    /* Utility to report errors within AiInit and other first page
    ** initialization.  'HwndDlg' is the dialog window.
    */
{
    SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( hwndDlg, SOD_Free, NULL );
    PostMessage( hwndDlg, WM_COMMAND,
        MAKEWPARAM( IDCANCEL , BN_CLICKED ),
        (LPARAM )GetDlgItem( hwndDlg, IDCANCEL ) );
}


BOOL
AiFinish(
    IN HWND hwndPage )

    /* Saves the contents of the wizard.  'HwndPage is the handle of a
    ** property page.  Pops up any errors that occur.  'FPropertySheet'
    ** indicates the user chose to edit the property sheet directly.
    **
    ** Returns true is page can be dismissed, false otherwise.
    */
{
    const TCHAR* pszIp0 = TEXT("0.0.0.0");

    AIINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("AiFinish");

    pInfo = AiContext( hwndPage );
    ASSERT(pInfo);
    if (pInfo == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    // Update the entry type to match the selected port(s), which are assumed
    // to have been moved to the head of the list.  This does not happen
    // automatically because "all types" is used initially.
    //
    {
        DTLNODE* pNode;
        PBLINK* pLink;

        pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
        ASSERT( pNode );
        pLink = (PBLINK* )DtlGetData( pNode );
        ChangeEntryType( pEntry, pLink->pbport.dwType );
    }

    // Replace phone number settings of all enabled links (or the shared link,
    // if applicable) from the stashed phone number list.
    //
    {
        DTLLIST* pList;
        DTLNODE* pNodeL;
        PBLINK* pLink;

        ASSERT( pInfo->pListPhoneNumbers );

        if (pEntry->fSharedPhoneNumbers)
        {
            pLink = (PBLINK* )DtlGetData( pInfo->pArgs->pSharedNode );
            ASSERT( pLink );
            CopyPszListToPhoneList( pLink, pInfo->pListPhoneNumbers );
        }
        else
        {
            for (pNodeL = DtlGetFirstNode( pEntry->pdtllistLinks );
                 pNodeL;
                 pNodeL = DtlGetNextNode( pNodeL ))
            {
                pLink = (PBLINK* )DtlGetData( pNodeL );
                ASSERT( pLink );

                if (pLink->fEnabled)
                {
                    CopyPszListToPhoneList( pLink, pInfo->pListPhoneNumbers );
                }
            }
        }
    }

    /* Update some settings based on user selections.
    */
    if (pInfo->fClearPwOk)
    {
        pEntry->dwTypicalAuth = TA_Unsecure;
    }
    else
    {
        pEntry->dwTypicalAuth = TA_Secure;
    }
    pEntry->dwAuthRestrictions =    
        AuthRestrictionsFromTypicalAuth(pEntry->dwTypicalAuth);
    
    if (    !pInfo->fSkipWizard
        &&  !pInfo->fIp)
        pEntry->dwfExcludedProtocols |= NP_Ip;

    if (    !pInfo->fSkipWizard
        &&  !pInfo->fIpx)
        pEntry->dwfExcludedProtocols |= NP_Ipx;

    if (pEntry->pszIpAddress
        && lstrcmp( pEntry->pszIpAddress, pszIp0 ) != 0)
    {
        pEntry->dwIpAddressSource = ASRC_RequireSpecific;
    }

    if ((pEntry->pszIpDnsAddress
             && lstrcmp( pEntry->pszIpDnsAddress, pszIp0 ) != 0)
        || (pEntry->pszIpWinsAddress
             && lstrcmp( pEntry->pszIpWinsAddress, pszIp0 ) != 0))
    {
        pEntry->dwIpNameSource = ASRC_RequireSpecific;
    }

    if ( pEntry->dwType == RASET_Vpn ) 
    {
        pEntry->dwVpnStrategy = pInfo->dwVpnStrategy;
    }

    // pmay: 234964
    // Default the idle disconnect to five minutes
    //
    pEntry->lIdleDisconnectSeconds = 5 * 60;

    // pmay: 389632
    //
    // Default DD connections to not register their names (CreateEntryNode 
    // defaults this value to primary+inform)
    //
    pEntry->dwIpDnsFlags = 0;

    // Whistler bug: 
    // 
    // By default, DD connections should share file+print, nor be msclient,
    // nor permit NBT over tcp.
    //
    pEntry->fShareMsFilePrint = FALSE;
    pEntry->fBindMsNetClient = FALSE;
    EnableOrDisableNetComponent( pEntry, TEXT("ms_server"), FALSE);
    EnableOrDisableNetComponent( pEntry, TEXT("ms_msclient"), FALSE);
    pEntry->dwIpNbtFlags = 0;

    /* It's a valid new entry and caller has not chosen to edit properties
    ** directly, so mark the entry for commitment.
    */
    if (!pInfo->pArgs->fChainPropertySheet)
        pInfo->pArgs->fCommit = TRUE;

    /*
     ** Assign the Router list pointer to 
     ** Internal Args...
    */
    {
        INTERNALARGS *pIArgs = (INTERNALARGS *) pInfo->pArgs->pApiArgs->reserved;
        pIArgs->pvSRouteInfo = (VOID *) ( pInfo->pRouteInfoListHead );
    }

    return TRUE;
}


AIINFO*
AiInit(
    IN HWND   hwndFirstPage,
    IN EINFO* pArgs )

    /* Wizard level initialization.  'HwndPage' is the handle of the first
    ** page.  'PArgs' is the common entry input argument block.
    **
    ** Returns address of the context block if successful, NULL otherwise.  If
    ** NULL is returned, an appropriate message has been displayed, and the
    ** wizard has been cancelled.
    */
{
    DWORD   dwErr;
    DWORD   dwOp;
    AIINFO* pInfo;
    HWND    hwndDlg;
    BOOL    bNt4;

    TRACE("AiInit");

    hwndDlg = GetParent( hwndFirstPage );

    /* Allocate the context information block.  Initialize it enough so that
    ** it can be destroyed properly, and associate the context with the
    ** window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            TRACE("Context NOT allocated");
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            pArgs->pApiArgs->dwError = ERROR_NOT_ENOUGH_MEMORY;
            AiExitInit( hwndDlg );
            return NULL;
        }

        ZeroMemory( pInfo, sizeof(AIINFO) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;
        pInfo->hwndFirstPage = hwndFirstPage;

        if (!SetProp( hwndDlg, g_contextId, pInfo ))
        {
            TRACE("Context NOT set");
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
            pArgs->pApiArgs->dwError = ERROR_UNKNOWN;
            Free( pInfo );
            AiExitInit( hwndDlg );
            return NULL;
        }

        TRACE("Context set");
    }

    /* Position the dialog per caller's instructions.
    */
    PositionDlg( hwndDlg,
        pArgs->pApiArgs->dwFlags & RASDDFLAG_PositionDlg,
        pArgs->pApiArgs->xDlg, pArgs->pApiArgs->yDlg );

    // Do here instead of LibMain because otherwise it leaks resources into
    // WinLogon according to ShaunCo.
    //
    {
        InitCommonControls();
        IpAddrInit( g_hinstDll, SID_PopupTitle, SID_BadIpAddrRange );
    }

    /* Initialize these meta-flags that are not actually stored.
    */
    pInfo->fNotNt = FALSE;
    pInfo->fSkipMa = FALSE;
    pInfo->fModem = FALSE;
    pInfo->pArgs->fPadSelected = FALSE;

    {
        INTERNALARGS *pIArgs = (INTERNALARGS *) pArgs->pApiArgs->reserved;

        pInfo->dwfConfiguredProtocols =
            g_pGetInstalledProtocolsEx(
                (pIArgs) ? pIArgs->hConnection : NULL,
                TRUE, FALSE, TRUE);


    }
    
    pInfo->fIpConfigured = (pInfo->dwfConfiguredProtocols & NP_Ip);

//for whistler bug 213901 .Net server 605988, remove IPX
//
    pInfo->fIpxConfigured = FALSE;


    // Set up common phone number list storage.
    //
    {
        pInfo->pListPhoneNumbers = DtlCreateList( 0 );
        if (!pInfo->pListPhoneNumbers)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            pArgs->pApiArgs->dwError = ERROR_NOT_ENOUGH_MEMORY;
            AiExitInit( hwndDlg );
            return NULL;
        }
    }

    // Load links for all port types.
    //
    EuChangeEntryType( pArgs, (DWORD )-1 );

    // Convert the PBPHONE phone list for the first link to a TAPI-disabled
    // PSZ stash list of phone numbers.  The stash list is edited rather than
    // the list in the entry so user can change active links without losing
    // the phone number he entered.
    //
    {
        DTLNODE* pNode;
        PBLINK* pLink;

        ASSERT( pInfo->pListPhoneNumbers );

        pNode = DtlGetFirstNode( pArgs->pEntry->pdtllistLinks );
        ASSERT( pNode );
        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT( pLink );

        for (pNode = DtlGetFirstNode( pLink->pdtllistPhones );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBPHONE* pPhone;
            DTLNODE* pNodeP;

            pPhone = (PBPHONE* )DtlGetData( pNode );
            ASSERT( pPhone );

            pNodeP = CreatePszNode( pPhone->pszPhoneNumber );
            if (pNodeP)
            {
                DtlAddNodeLast( pInfo->pListPhoneNumbers, pNodeP );
            }
        }
    }

    // Get the bold font for the start and finish pages
    //
    GetBoldWindowFont(hwndFirstPage, TRUE, &(pInfo->hBoldFont));

    // Initlialize the flags for this wizard based on the 
    // ports loaded in.
    //
    {
        DTLNODE* pNode;
        PBLINK* pLink;

        for (pNode = DtlGetFirstNode( pArgs->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT( pLink );

            if ( pLink->pbport.dwType == RASET_Vpn ) 
            {
                pInfo->dwFlags |= AI_F_HasTunlDevs;
            }

            // pmay: 233287
            // Do not count bogus devices as physical devices.
            //
            else if (! (pLink->pbport.dwFlags & PBP_F_BogusDevice))
            {
                pInfo->dwFlags |= AI_F_HasPhysDevs;
            }

            if ( pLink->pbport.dwFlags & PBP_F_PptpDevice )
            {
                pInfo->dwFlags |= AI_F_HasPptpDevs;
            }
            else if ( pLink->pbport.dwFlags & PBP_F_L2tpDevice )
            {
                pInfo->dwFlags |= AI_F_HasL2tpDevs;
            }

            //For whistler bug 345068 349087
            //
            if ( pLink->pbport.dwFlags & PBP_F_PPPoEDevice )
            {
                pInfo->dwFlags |= AI_F_HasPPPoEDevs;
            }
        }

    }    

    //
    //Set the static route list pointer to null
    //
    pInfo->pRouteInfoListHead = NULL;

    return pInfo;
}


VOID
AiTerm(
    IN HWND hwndPage )

    /* Wizard level termination.  Releases the context block.  'HwndPage' is
    ** the handle of a property page.
    */
{
    AIINFO* pInfo;

    TRACE("AiTerm");

    pInfo = AiContext( hwndPage );
    if (pInfo)
    {
        if (pInfo->hBoldFont)
        {
            DeleteObject(pInfo->hBoldFont);
        }
        if (pInfo->pListPhoneNumbers)
        {
            DtlDestroyList( pInfo->pListPhoneNumbers, DestroyPszNode );
        }

        if (pInfo->fSuInfoInitialized)
        {
            SuFree( &pInfo->suinfo );
        }

        Free( pInfo );
        TRACE("Context freed");
    }

    RemoveProp( GetParent( hwndPage ), g_contextId );
}

/*----------------------------------------------------------------------------
** AI Info Utiltity functions aroudn route info structure.
**----------------------------------------------------------------------------
*/

DWORD AIInfoSRouteGetNode(SROUTEINFOLIST ** pNode )
{
    DWORD dwRetCode = NO_ERROR;

    TRACE("AIInfoSRouteGetNode");

    *pNode = Malloc( sizeof(SROUTEINFOLIST) );
    if ( !*pNode )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    ZeroMemory(*pNode, sizeof(SROUTEINFOLIST) );

done:
    return dwRetCode;
}


DWORD AIInfoSRouteSetDestIP(SROUTEINFOLIST * pNode, LPTSTR lpszDestIP )
{
    DWORD dwRetCode = NO_ERROR;

    TRACE("AIInfoSRouteSetDestIP");

    if ( !lpszDestIP || !pNode )
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if ( pNode->RouteInfo.pszDestIP )
        Free(pNode->RouteInfo.pszDestIP );

    pNode->RouteInfo.pszDestIP = Malloc( ( lstrlen(lpszDestIP) * sizeof(TCHAR) )+ sizeof(TCHAR) );
    if ( !pNode->RouteInfo.pszDestIP )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    lstrcpy ( pNode->RouteInfo.pszDestIP, lpszDestIP );

done:
    return dwRetCode;
}

DWORD AIInfoSRouteSetNetworkMask (SROUTEINFOLIST * pNode, LPTSTR lpszNetMask )
{
    DWORD dwRetCode = NO_ERROR;

    TRACE("AIInfoSRouteSetNetworkMask");

    if ( !lpszNetMask || !pNode )
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if ( pNode->RouteInfo.pszNetworkMask )
        Free(pNode->RouteInfo.pszNetworkMask );

    pNode->RouteInfo.pszNetworkMask = Malloc( ( lstrlen(lpszNetMask) * sizeof(TCHAR) ) + sizeof(TCHAR) );
    if ( !pNode->RouteInfo.pszNetworkMask )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    lstrcpy ( pNode->RouteInfo.pszNetworkMask, lpszNetMask );

done:
    return dwRetCode;
}

DWORD AIInfoSRouteSetMetric (SROUTEINFOLIST * pNode, LPTSTR lpszMetric )
{
    DWORD dwRetCode = NO_ERROR;

    TRACE("AIInfoSRouteSetMetric");

    if ( !lpszMetric || !pNode )
    {
        dwRetCode = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if ( pNode->RouteInfo.pszMetric )
        Free(pNode->RouteInfo.pszMetric );

    pNode->RouteInfo.pszMetric = Malloc( ( lstrlen(lpszMetric) * sizeof(TCHAR)) + sizeof(TCHAR) );
    if ( !pNode->RouteInfo.pszMetric )
    {
        dwRetCode = GetLastError();
        goto done;
    }

    lstrcpy ( pNode->RouteInfo.pszMetric, lpszMetric );

done:
    return dwRetCode;
}


DWORD AIInfoAddNewSRouteNode( SROUTEINFOLIST ** ppList, SROUTEINFOLIST * pNewNode )
{
    DWORD               dwRetCode = NO_ERROR;
    
    //
    //Add Node at the head of the list
    //
    
    if ( NULL == *ppList )
    {
        *ppList = pNewNode;
    }
    else
    {
        pNewNode->pNext = *ppList;
        *ppList = pNewNode;
    }
    return dwRetCode;
}

DWORD AIInfoRemoveSRouteNode ( AIINFO * pInfo, SROUTEINFOLIST * pNode )
{
    DWORD               dwRetCode = NO_ERROR;
    SROUTEINFOLIST *    pCurNode = pInfo->pRouteInfoListHead;
    SROUTEINFOLIST *    pPrevNode = NULL;
    //
    //Iterate the list and remove node.
    //
    while ( pCurNode )
    {
        if ( pCurNode == pNode )
        {
            //
            //This is the node to delete
            //
            if ( pPrevNode == NULL)
            {
                //
                //This is the head node being deleted
                //
                pInfo->pRouteInfoListHead = pCurNode->pNext;
            }
            else
            {
                pPrevNode->pNext = pCurNode->pNext;
            }
        }
        pPrevNode = pCurNode;
        pCurNode = pCurNode->pNext;
    }

    Free( pNode->RouteInfo.pszDestIP );
    Free( pNode->RouteInfo.pszNetworkMask );
    Free( pNode->RouteInfo.pszMetric );
    Free(pNode);
    return dwRetCode;
}

DWORD AIInfoSRouteCreateEntry(AIINFO * pInfo, LPTSTR pszDest, LPTSTR pszNetMask, LPTSTR pszMetric )
{
    DWORD               dwRetCode = NO_ERROR;
    SROUTEINFOLIST *    pNode = NULL;

    dwRetCode = AIInfoSRouteGetNode (&pNode );

    if ( pNode )
    {
        AIInfoSRouteSetDestIP(pNode, pszDest );
        AIInfoSRouteSetNetworkMask (pNode, pszNetMask );
        AIInfoSRouteSetMetric (pNode, pszMetric );
        AIInfoAddNewSRouteNode( & ( pInfo->pRouteInfoListHead ), pNode );
    }

    return dwRetCode;
}


SROUTEINFOLIST * AiInfoSRouteGetFirstNode(AIINFO * pInfo)
{
    return ( pInfo->pRouteInfoListHead);
}

SROUTEINFOLIST * AiInfoSRouteGetNextNode(SROUTEINFOLIST * pNode)
{
    return pNode->pNext;
}



BOOL 
AIInfoSRouteIsRouteinList
    (
     AIINFO * pInfo, 
     LPCTSTR pszDest, 
     LPCTSTR pszMask, 
     LPCTSTR pszMetric 
    )
{
    BOOL fRet = FALSE;
    SROUTEINFOLIST * pNode = pInfo->pRouteInfoListHead;

    while ( pNode )
    {
        if ( !lstrcmp(pNode->RouteInfo.pszDestIP, pszDest ) &&
             !lstrcmp(pNode->RouteInfo.pszNetworkMask, pszMask ) &&
             !lstrcmp(pNode->RouteInfo.pszMetric, pszMetric)
           )
        {
            fRet = TRUE;
            break;
        }
        pNode = pNode->pNext;
    }
    return fRet;
}

DWORD 
inet_addrw(
    LPCWSTR     szAddressW
    ) {

    CHAR szAddressA[16];

    wcstombs(szAddressA, szAddressW, 16);

    return inet_addr(szAddressA);
}


// Add Broadband service name page for router wizard 
// For whistler 345068 349087     gangz
// This broadband serice page is shared by AiWizard(ifw.c) and AeWizard(in entryw.c)
//
/*----------------------------------------------------------------------------
** Broadband service dialog procedure
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RbDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the broadband service page of the wizard.  
    // Parameters and return value are as described for 
    // standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RbInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RbSetActive");
                    pInfo = AiContext( hwnd );
                    
                    ASSERT(pInfo);
                    if ( NULL == pInfo )
                    {
                        break;
                    }
                    
                    fDisplay = RbSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RbKillActive");
                    pInfo = AiContext( hwnd );
                    
                    ASSERT(pInfo);
                    if ( NULL == pInfo )
                    {
                        break;
                    }
                    
                    fInvalid = RbKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
RbInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AIINFO* pInfo;

    TRACE("RbInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }

    // Initialize page-specific context information.
    //
    pInfo->hwndRb = hwndPage;
    pInfo->hwndEbNumber = 
        GetDlgItem( hwndPage, CID_BS_EB_ServiceName );
    ASSERT(pInfo->hwndEbNumber);

    Edit_LimitText( pInfo->hwndEbNumber, RAS_MaxPhoneNumber );
    SetWindowText( pInfo->hwndEbNumber,
                   FirstPszFromList( pInfo->pListPhoneNumbers ) );
    

    return FALSE;
}

//For whistler bug 349807
//The RbXXX, VdXXX, RpXXX three sets of functions share the same pInfo->hwndEbNumber
//to store phone number/Vpn destionation/PPPPoE service name
//
BOOL
RbKillActive(
    IN AIINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{

    // If we're focused on an nt4 box, then this page is 
    // invalid (pptp was the only type)
    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }

    // If we have no PPPoE devices, then this page is invalid
    else if ( ! (pInfo->dwFlags & AI_F_HasPPPoEDevs) )
    {
        return FALSE;
    }

    // If the connection type is not broadband, skip this page since the
    // destination will be gotten from the phone number/VPN page.
    if ( pInfo->pArgs->pEntry->dwType != RASET_Broadband )
    {
        return FALSE;
    }    

    RpPhoneNumberToStash(pInfo);

    return FALSE;
}


BOOL
RbSetActive(
    IN AIINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    TRACE("RbSetActive");
    
    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }
    // If we have no PPPoE devices, then this page is invalid
    //
    if ( ! (pInfo->dwFlags & AI_F_HasPPPoEDevs) )
    {
        return FALSE;
    }
    
    if (RASET_Broadband != pEntry->dwType)
    {
        return FALSE;
    }
    else
    {
        PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
        fDisplayPage = TRUE;
    }

    pInfo->hwndEbNumber = 
        GetDlgItem( pInfo->hwndRb, CID_BS_EB_ServiceName );
    ASSERT(pInfo->hwndEbNumber);

    Edit_LimitText( pInfo->hwndEbNumber, RAS_MaxPhoneNumber );
    SetWindowText( pInfo->hwndEbNumber,
                   FirstPszFromList( pInfo->pListPhoneNumbers ) );

    return fDisplayPage;
}


/*----------------------------------------------------------------------------
** Connection type property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
CtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the vpn type page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return CtInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("CtSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = CtSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("CtKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = CtKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
CtInit(
    IN HWND   hwndPage )
    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO * pInfo;
    DWORD dwPhysicDeviceOtherThanLPT1 = 0;
    
    // Get the context
    pInfo = AiContext( hwndPage );
    ASSERT ( pInfo );
    if (pInfo == NULL)
    {
        return FALSE;
    }
    
    // Initialize the checks
    pInfo->hwndRbTypePhys = GetDlgItem( hwndPage, CID_CT_RB_Physical );
    ASSERT(pInfo->hwndRbTypePhys);
    pInfo->hwndRbTypeTunl = GetDlgItem( hwndPage, CID_CT_RB_Virtual );
    ASSERT(pInfo->hwndRbTypeTunl);
    //for whistler 345068 349087        gangz
    //
    pInfo->hwndRbBroadband  = GetDlgItem( hwndPage, CID_CT_RB_Broadband );       
    ASSERT(pInfo->hwndRbBroadband);

    // pmay: 233287     
    //for whistler 345068 349087    gangz
    // Likewise, if there are only one devices available among
    // phys devices, tunel devices and broadband devices , then force the 
    // user to configure  dd interface with that device.
    // 

    //If no valid device availabe, stop the wizard
    //
    pInfo->dwCtDeviceNum = 0;

    // Get the number of Physic Devices other that LPT1 because DoD interfaces 
    // just do not use LPT1
    //
    if (pInfo->dwFlags &AI_F_HasPhysDevs ) 
    {
        dwPhysicDeviceOtherThanLPT1 = GetPhysicDeviceOtherThanLPT1( pInfo );
        if( 0 < dwPhysicDeviceOtherThanLPT1 )
        {
            pInfo->dwCtDeviceNum++;
        }
     }
     
    if (pInfo->dwFlags & AI_F_HasTunlDevs )
    {
        pInfo->dwCtDeviceNum++;
     }

    if (pInfo->dwFlags & AI_F_HasPPPoEDevs)
    {
        pInfo->dwCtDeviceNum++;
     }
    
    if ( 0 == pInfo->dwCtDeviceNum )
    {
        ErrorDlg( pInfo->hwndDlg, SID_NoDevices, ERROR_UNKNOWN, NULL);
        AiExit ( pInfo, ERROR_DEVICE_NOT_AVAILABLE );
        
        return TRUE;
    }

    if ( 1 == pInfo->dwCtDeviceNum )
    {
        if ( ( pInfo->dwFlags & AI_F_HasPhysDevs ) && 
             ( 0 < dwPhysicDeviceOtherThanLPT1 )
            ) 
        {
            EuChangeEntryType(
                pInfo->pArgs, 
                RASET_P_NonVpnTypes);
        }
        else if (pInfo->dwFlags & AI_F_HasTunlDevs) 
        {
            EuChangeEntryType(
                pInfo->pArgs, 
                RASET_Vpn);
        }
        else if (pInfo->dwFlags & AI_F_HasPPPoEDevs) 
        {
            EuChangeEntryType(
                pInfo->pArgs, 
                RASET_Broadband);
        }
        else
        {
            ErrorDlg( pInfo->hwndDlg, SID_NoDevices, ERROR_UNKNOWN, NULL);
            AiExit ( pInfo, ERROR_DEVICE_NOT_AVAILABLE );

            return TRUE;
        }
    }

    //Set radio buttons
    //
    if( pInfo->hwndRbTypePhys )    
    {
        Button_SetCheck(pInfo->hwndRbTypePhys, FALSE);
    }
    
    if( pInfo->hwndRbTypeTunl )    
    {
        Button_SetCheck(pInfo->hwndRbTypeTunl, FALSE);
    }
    
    if( pInfo->hwndRbBroadband )   
    {
        Button_SetCheck(pInfo->hwndRbBroadband, FALSE);
    }
    
    //Enable/Disable buttons
    //

    if( pInfo->hwndRbTypePhys )
    {
   
        if ( !(pInfo->dwFlags & AI_F_HasPhysDevs) ||
             0 == dwPhysicDeviceOtherThanLPT1 )
        {
            EnableWindow(pInfo->hwndRbTypePhys, FALSE);
        }
        else
        {
            EnableWindow(pInfo->hwndRbTypePhys, TRUE );
        }
    }

    
    if( pInfo->hwndRbTypeTunl )
    {
        if ( !(pInfo->dwFlags & AI_F_HasTunlDevs) )
        {
            EnableWindow(pInfo->hwndRbTypeTunl, FALSE);
        }
        else
        {
            EnableWindow(pInfo->hwndRbTypeTunl, TRUE );
        }
    }

    if( pInfo->hwndRbBroadband )
    {
        if ( !(pInfo->dwFlags & AI_F_HasPPPoEDevs) )
        {
            EnableWindow(pInfo->hwndRbBroadband, FALSE);
        }
        else
        {
            EnableWindow(pInfo->hwndRbBroadband, TRUE );
        }
    }

    if (  pInfo->hwndRbTypePhys  &&
          IsWindowEnabled( pInfo->hwndRbTypePhys ) 
        )
    {
        Button_SetCheck(pInfo->hwndRbTypePhys, TRUE);
    }
    else if( pInfo->hwndRbTypeTunl &&
             IsWindowEnabled( pInfo->hwndRbTypeTunl )
            )
    {
        Button_SetCheck(pInfo->hwndRbTypeTunl, TRUE);
    }
    else
    {
        if( pInfo->hwndRbBroadband )
        {
            Button_SetCheck(pInfo->hwndRbBroadband, TRUE);
        }
    }
    
    return FALSE;
}

BOOL
CtKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    BOOL bPhys, bTunnel;
    
    // Change the entry type based on the type 
    // selected from this page
    //For whistler 345068 349087    gangz
    // 

    bPhys = Button_GetCheck( pInfo->hwndRbTypePhys );
    bTunnel = Button_GetCheck( pInfo->hwndRbTypeTunl );

    if(bPhys)
    {
        EuChangeEntryType(
                          pInfo->pArgs, 
                          RASET_P_NonVpnTypes);
     }
     else if(bTunnel)
     {
        EuChangeEntryType(
                          pInfo->pArgs, 
                          RASET_Vpn);
     }
     else
     {
        EuChangeEntryType(
                          pInfo->pArgs, 
                          RASET_Broadband);
     }
    
    return FALSE;
}


DWORD GetPhysicDeviceOtherThanLPT1(
    IN AIINFO * pInfo )
{
    DTLNODE* pNode = NULL;
    PBLINK* pLink = NULL;
    DWORD dwItem = 0;

    do
    {
        if( NULL == pInfo ||
            NULL == pInfo->pArgs ||
            NULL == pInfo->pArgs->pEntry ||
            NULL == pInfo->pArgs->pEntry->pdtllistLinks
           )
        {
            break;
        }
        
        for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBDEVICETYPE pbType ;
            
            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            // For whistler bug 448251
            // for whistler DCR 524304        gangz
            // Filter out LPT1, because the DoD only happens in a NAT or NAT/VPN 
            // which won't use this LPT1 port
            pbType = pLink->pbport.pbdevicetype;
            if (  PBDT_Modem == pbType ||
                  PBDT_Pad == pbType ||
                  PBDT_Switch == pbType ||
                  PBDT_Isdn == pbType ||
                  PBDT_Atm == pbType ||
                  PBDT_FrameRelay == pbType 

                )
            {
                 dwItem ++;
            }
         }// End of for loop
    }
    while(FALSE);
 
    return dwItem;
}

BOOL
CtSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    // If we're focused on an nt4 box, then this page is 
    // invalid (type of connection is inferred from the 
    // device that gets selected.)
    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }

    // Only allow this page to display if there are at least two of 
    // physical, tunnel and broadband devices configured.  Otherwise,
    // it makes no sense to allow the user to choose which
    // type he/she wants.

    if ( 2 <= pInfo->dwCtDeviceNum )
    {
        PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
        return TRUE;
    }

    return FALSE;
}



/*----------------------------------------------------------------------------
** Dial-In Credentials property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
DiDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Dial-in Credentials page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                DiInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("DiSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = DiSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DiKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = DiKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DoNEXT");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = DiNext( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fInvalid) ? -1 : 0 );
                    return TRUE;
                }

            }
            break;
        }
    }

    return FALSE;
}



BOOL
DiInit(
    IN     HWND   hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("DiInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndDi = hwndPage;
    pInfo->hwndDiEbUserName = GetDlgItem( hwndPage, CID_DI_EB_UserName );
    Edit_LimitText( pInfo->hwndDiEbUserName, UNLEN );
    pInfo->hwndDiEbPassword = GetDlgItem( hwndPage, CID_DI_EB_Password );
    Edit_LimitText( pInfo->hwndDiEbPassword, PWLEN );
    pInfo->hwndDiEbConfirm = GetDlgItem( hwndPage, CID_DI_EB_Confirm );
    Edit_LimitText( pInfo->hwndDiEbConfirm, PWLEN );

    // pmay: 222622: Since we only configure local users, we removed 
    // the domain field from the dial in credentials page.

    return FALSE;
}

BOOL
DiKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    return FALSE;
}

BOOL
DiNext(
    IN AIINFO* pInfo )

    /* Called when PSN_WIZNEXT is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    /* Whistler bug 254385 encode password when not being used
    */
    psz = GetText(pInfo->hwndDiEbPassword);
    EncodePassword(psz);
    if (psz)
    {
        TCHAR* psz2;

        psz2 = GetText(pInfo->hwndDiEbConfirm);

        if(NULL != psz2)
        {
            /* Whistler bug 254385 encode password when not being used
            */
            DecodePassword(psz);
            if (lstrcmp(psz, psz2))
            {
                ZeroMemory(psz, (lstrlen(psz) + 1) * sizeof(TCHAR));
                ZeroMemory(psz2, (lstrlen(psz2) + 1) * sizeof(TCHAR));
                Free(psz);
                Free(psz2);
                MsgDlg(pInfo->hwndDlg, SID_PasswordMismatch, NULL);
                SetFocus(pInfo->hwndDiEbPassword);
                return TRUE;
            }

            EncodePassword(psz);
            ZeroMemory(psz2, (lstrlen(psz2) + 1) * sizeof(TCHAR));
            Free(psz2);
        }
        /* Whistler bug 254385 encode password when not being used
        ** Whistler bug 275526 NetVBL BVT Break: Routing BVT broken
        */
        if (pInfo->pArgs->pszRouterDialInPassword)
        {
            ZeroMemory(
                pInfo->pArgs->pszRouterDialInPassword,
                (lstrlen(pInfo->pArgs->pszRouterDialInPassword) + 1) *
                    sizeof(TCHAR));
        }

        Free0(pInfo->pArgs->pszRouterDialInPassword);
        pInfo->pArgs->pszRouterDialInPassword = psz;
    }

    return FALSE;
}

BOOL
DiSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    /* The dialog is only displayed if the user is adding a dial-in account.
    */
    if (!pInfo->pArgs->fAddUser)
        return FALSE;

    /* Display the interface name in the disabled edit-box
    */
    SetWindowText(
        pInfo->hwndDiEbUserName, pInfo->pArgs->pEntry->pszEntryName );

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}




/*----------------------------------------------------------------------------
** Dial-Out Credentials property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
DoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Dial-Out Credentials page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                DoInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("DoSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = DoSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DoKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = DoKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DoNEXT");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = DoNext( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fInvalid) ? -1 : 0 );
                    return TRUE;
                }
                
            }
            break;
        }
        // For whistler DCR bug 524304      gangz
        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return DoCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
        
    }

    return FALSE;
}

BOOL
DoCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'pInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    //TRACE3("DoCommand(n=%d,i=%d,c=$%x)",
    //    (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);
    TCHAR* psz = NULL;
    
    switch( wId )
    {
        case CID_DO_EB_UserName:
        {
            if( EN_CHANGE == wNotification )
            {
                if( pInfo->hwndDoEbUserName )
                {
                    if( 0 < GetWindowTextLength(pInfo->hwndDoEbUserName) )
                    {
                        PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK );
                    }
                }
            }
            
            break;
        }
    }
    
    return FALSE;
}


BOOL
DoInit(
    IN     HWND   hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("DoInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndDo = hwndPage;
    pInfo->hwndDoEbUserName = GetDlgItem( hwndPage, CID_DO_EB_UserName );
    Edit_LimitText( pInfo->hwndDoEbUserName, UNLEN );
    pInfo->hwndDoEbDomain = GetDlgItem( hwndPage, CID_DO_EB_Domain );
    Edit_LimitText( pInfo->hwndDoEbDomain, DNLEN );
    pInfo->hwndDoEbPassword = GetDlgItem( hwndPage, CID_DO_EB_Password );
    Edit_LimitText( pInfo->hwndDoEbPassword, PWLEN );
    pInfo->hwndDoEbConfirm = GetDlgItem( hwndPage, CID_DO_EB_Confirm );
    Edit_LimitText( pInfo->hwndDoEbConfirm, PWLEN );

    /* Use the target router name as the default "User name",
    */
    if (pInfo->pArgs->pszRouter)
    {
        if (pInfo->pArgs->pszRouter[0] == TEXT('\\') &&
            pInfo->pArgs->pszRouter[1] == TEXT('\\'))
            SetWindowText(pInfo->hwndDoEbUserName, pInfo->pArgs->pszRouter+2);
        else
            SetWindowText(pInfo->hwndDoEbUserName, pInfo->pArgs->pszRouter);
    }

    return FALSE;
}




BOOL
DoKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    // for whistler DCR 524304        gangz
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );

    return FALSE;
}

BOOL
DoNext(
    IN AIINFO* pInfo )

    /* Called when PSN_WIZNEXT is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText(pInfo->hwndDoEbUserName);
    if (psz)
    {
        if (!lstrlen(psz))
        {
            Free(psz);
            MsgDlg(pInfo->hwndDlg, SID_DialOutUserName, NULL);
            SetFocus(pInfo->hwndDoEbUserName);
            return TRUE;
        }

        Free0(pInfo->pArgs->pszRouterUserName);
        pInfo->pArgs->pszRouterUserName = psz;
    }

    psz = GetText(pInfo->hwndDoEbDomain);
    if (psz)
    {
        Free0(pInfo->pArgs->pszRouterDomain);
        pInfo->pArgs->pszRouterDomain = psz;
    }

    /* Whistler bug 254385 encode password when not being used
    */
    psz = GetText(pInfo->hwndDoEbPassword);
    EncodePassword(psz);
    if (psz)
    {
        TCHAR* psz2;

        psz2 = GetText(pInfo->hwndDoEbConfirm);

        if(NULL != psz2)
        {
            /* Whistler bug 254385 encode password when not being used
            */
            DecodePassword(psz);
            if (lstrcmp(psz, psz2))
            {
                ZeroMemory(psz, (lstrlen(psz) + 1) * sizeof(TCHAR));
                ZeroMemory(psz2, (lstrlen(psz2) + 1) * sizeof(TCHAR));
                Free(psz);
                Free(psz2);
                MsgDlg(pInfo->hwndDlg, SID_PasswordMismatch, NULL);
                SetFocus(pInfo->hwndDoEbPassword);
                return TRUE;
            }

            EncodePassword(psz);
            ZeroMemory(psz2, (lstrlen(psz2) + 1) * sizeof(TCHAR));
            Free(psz2);
        }
        /* Whistler bug 254385 encode password when not being used
        ** Whistler bug 275526 NetVBL BVT Break: Routing BVT broken
        */
        if (pInfo->pArgs->pszRouterPassword)
        {
            ZeroMemory(
                pInfo->pArgs->pszRouterPassword,
                (lstrlen(pInfo->pArgs->pszRouterPassword) + 1) * sizeof(TCHAR));
        }

        Free0(pInfo->pArgs->pszRouterPassword);
        pInfo->pArgs->pszRouterPassword = psz;
    }

    return FALSE;
}


BOOL
DoSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
#if 0
    TCHAR* psz;

    /* Fill in the interface name in the explanatory text.
    */
    psz = PszFromId( g_hinstDll, SID_RouterDialOut );
    if (psz)
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pInfo->pArgs->pEntry->pszEntryName;
        msgargs.fStringOutput = TRUE;
        msgargs.pszString = psz;

        MsgDlgUtil( NULL, 0, &msgargs, g_hinstDll, 0 );

        if (msgargs.pszOutput)
        {
            SetDlgItemText( pInfo->hwndDo, CID_DO_ST_Explain,
                msgargs.pszOutput );
            Free( msgargs.pszOutput );
        }

        Free( psz );
    }
#endif    

    // For whistler DCR bug 524304      gangz
    // won't enable Next button until user input a user name
    //
    if( pInfo->hwndDoEbUserName &&
        pInfo->hwndDlg )
    {
        if( 0 < GetWindowTextLength(pInfo->hwndDoEbUserName) )
        {
            PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
        }
        else
        {
            PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK );
        }
    }

    return TRUE;

}



/*----------------------------------------------------------------------------
** Interface Name property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
InDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Interface Name page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                InInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_RESET:
                {
                    TRACE("InRESET");
                    AiCancel( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("InSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = InSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("InKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = InKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    AIINFO* pInfo;

                    TRACE("InWIZFINISH");

                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }

                    /* You'd think pressing Finish would trigger a KILLACTIVE
                    ** event, but it doesn't, so we do it ourselves.
                    */
                    InKillActive( pInfo );

                    /* Set "no wizard" user preference, per user's check.
                    */
                    pInfo->pArgs->pUser->fNewEntryWizard = FALSE;
                    pInfo->pArgs->pUser->fDirty = TRUE;
                    g_pSetUserPreferences(
                        NULL,
                        pInfo->pArgs->pUser,
                        pInfo->pArgs->fNoUser ? UPM_Logon : UPM_Normal );

                    pInfo->pArgs->fPadSelected = FALSE;
                    pInfo->pArgs->fChainPropertySheet = TRUE;
                    AiFinish( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, 0 );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return InCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            AiTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
InCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    //TRACE3("InCommand(n=%d,i=%d,c=$%x)",
    //    (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    return FALSE;
}


BOOL
InInit(
    IN     HWND   hwndPage)

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD    dwErr;
    AIINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("InInit");

    // Get the context of this page
    pInfo = AiContext( hwndPage );
    ASSERT ( pInfo );
    if (pInfo == NULL)
    {
        return FALSE;
    }

    // Set up the interface name stuff
    //
    pInfo->hwndEbInterfaceName =
        GetDlgItem( hwndPage, CID_IN_EB_InterfaceName );
    ASSERT(pInfo->hwndEbInterfaceName);
    
    pEntry = pInfo->pArgs->pEntry;
    if (!pEntry->pszEntryName)
    {
        /* No entry name, so think up a default.
        */
        dwErr = GetDefaultEntryName(
            pInfo->pArgs->pFile,
            pEntry->dwType,
            pInfo->pArgs->fRouter,
            &pEntry->pszEntryName );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_LoadPage, dwErr, NULL );
            AiExit( pInfo, dwErr );
            return TRUE;
        }
    }

    Edit_LimitText( pInfo->hwndEbInterfaceName, RAS_MaxEntryName );
    SetWindowText( pInfo->hwndEbInterfaceName, pEntry->pszEntryName );

    /* Initialize page-specific context information.
    */
    pInfo->hwndIn = hwndPage;

    return TRUE;
}


BOOL
InKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndEbInterfaceName );
    if (psz)
    {
        /* Update the entry name from the editbox.
        */
        Free0( pInfo->pArgs->pEntry->pszEntryName );
        pInfo->pArgs->pEntry->pszEntryName = psz;

        /* Validate the entry name.
        */
        if (!EuValidateName( pInfo->hwndDlg, pInfo->pArgs ))
        {
            SetFocus( pInfo->hwndEbInterfaceName );
            Edit_SetSel( pInfo->hwndEbInterfaceName, 0, -1 );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
InSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    TCHAR* psz;

    // for whistler DCR 524304        gangz
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    
    return TRUE;
}



/*----------------------------------------------------------------------------
** Name Servers property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
NsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Name Servers page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                NsInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("NsSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = NsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("NsKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = NsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}



BOOL
NsInit(
    IN     HWND   hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("NsInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndNs = hwndPage;
    pInfo->hwndCcDns = GetDlgItem( hwndPage, CID_NS_CC_Dns );
    ASSERT(pInfo->hwndCcDns);
    pInfo->hwndCcWins = GetDlgItem( hwndPage, CID_NS_CC_Wins );
    ASSERT(pInfo->hwndCcWins);

    /* Set the IP address fields.
    */
    SetWindowText( pInfo->hwndCcDns, pInfo->pArgs->pEntry->pszIpDnsAddress );
    SetWindowText( pInfo->hwndCcWins, pInfo->pArgs->pEntry->pszIpWinsAddress );

    return FALSE;
}




BOOL
NsKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR*      psz;
    PBENTRY*    pEntry = pInfo->pArgs->pEntry;

    psz = GetText( pInfo->hwndCcDns );
    if (psz)
    {
        Free0( pEntry->pszIpDnsAddress );
        pEntry->pszIpDnsAddress = psz;
    }

    psz = GetText( pInfo->hwndCcWins );
    if (psz)
    {
        Free0( pEntry->pszIpWinsAddress );
        pEntry->pszIpWinsAddress = psz;
    }

    return FALSE;
}


BOOL
NsSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    // In NT5, we always skip this page
    return FALSE;

    if (!pInfo->fNotNt || !pInfo->fIpConfigured)
    {
        return FALSE;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}




/*----------------------------------------------------------------------------
** IP Address property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the IP Address page of the wizard.  Parameters
    ** and return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("RaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RaSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = RaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RaKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = RaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
RaInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("RaInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRa = hwndPage;
    pInfo->hwndCcIp = GetDlgItem( hwndPage, CID_RA_CC_Ip );
    ASSERT(pInfo->hwndCcIp);

    /* Set the IP address field to '0.0.0.0'.
    */
    SetWindowText( pInfo->hwndCcIp, pInfo->pArgs->pEntry->pszIpAddress );

    return FALSE;
}


BOOL
RaKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndCcIp );
    if (psz)
    {
        PBENTRY* pEntry = pInfo->pArgs->pEntry;

        Free0( pEntry->pszIpAddress );
        pEntry->pszIpAddress = psz;
    }

    return FALSE;
}


BOOL
RaSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    // In NT5, we always skip this page
    return FALSE;

    if (!pInfo->fNotNt || !pInfo->fIpConfigured)
    {
        return FALSE;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Logon Script property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RcDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Logon Script page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RcDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RcInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RcSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = RcSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RcKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = RcKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return RcCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
RcCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("RcCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_RC_CB_RunScript:
        {
            if (SuScriptsCbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_RC_PB_Edit:
        {
            if (SuEditPbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_RC_PB_Browse:
        {
            if (SuBrowsePbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}


BOOL
RcInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;
    PBENTRY* pEntry;

    TRACE("RcInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRc = hwndPage;
    pInfo->hwndCbTerminal = GetDlgItem( hwndPage, CID_RC_CB_Terminal );
    ASSERT( pInfo->hwndCbTerminal );
    pInfo->hwndCbRunScript = GetDlgItem( hwndPage, CID_RC_CB_RunScript );
    ASSERT( pInfo->hwndCbRunScript );
    pInfo->hwndLbScripts = GetDlgItem( hwndPage, CID_RC_LB_Scripts );
    ASSERT( pInfo->hwndLbScripts );
    pInfo->hwndPbEdit = GetDlgItem( hwndPage, CID_RC_PB_Edit );
    ASSERT( pInfo->hwndPbEdit );
    pInfo->hwndPbBrowse = GetDlgItem( hwndPage, CID_RC_PB_Browse );
    ASSERT( pInfo->hwndPbBrowse );

    pEntry = pInfo->pArgs->pEntry;

    pInfo->suinfo.hConnection = 
        ((INTERNALARGS *) pInfo->pArgs->pApiArgs->reserved)->hConnection;

    // We don't allow the script window for dd interfaces
    //
    ShowWindow(pInfo->hwndCbTerminal, SW_HIDE);

    // Set up the after-dial scripting controls.
    //
    SuInit( &pInfo->suinfo,
        pInfo->hwndCbRunScript,
        pInfo->hwndCbTerminal,
        pInfo->hwndLbScripts,
        pInfo->hwndPbEdit,
        pInfo->hwndPbBrowse,
        SU_F_DisableTerminal);
    pInfo->fSuInfoInitialized = TRUE;

    SuSetInfo( &pInfo->suinfo,
        pEntry->fScriptAfter,
        pEntry->fScriptAfterTerminal,
        pEntry->pszScriptAfter );

    return FALSE;
}


BOOL
RcKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    Free0( pEntry->pszScriptAfter );
    SuGetInfo( &pInfo->suinfo,
        &pEntry->fScriptAfter,
        &pEntry->fScriptAfterTerminal,
        &pEntry->pszScriptAfter );

    return FALSE;
}


BOOL
RcSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    HWND hwndRb;

    if (!pInfo->fNotNt || !pInfo->fModem)
        return FALSE;

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Finish property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RfDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Finish page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RfDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RfInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RfSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = RfSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RfKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = RfKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    TRACE("RfWIZFINISH");
                    AiFinish( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, 0 );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return RfCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
RfCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("RfCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

#if 0
    switch (wId)
    {
        case CID_RF_PB_Properties:
        {
            pInfo->pArgs->fChainPropertySheet = TRUE;
            PropSheet_PressButton( pInfo->hwndDlg, PSBTN_FINISH );
            return TRUE;
        }
    }
#endif

    return FALSE;
}


BOOL
RfInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;
    PBENTRY* pEntry;
    DWORD dwErr;

    TRACE("RfInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRf = hwndPage;

    // Set up a bold font if we can.
    //
    pInfo->hwndRfStFinish = GetDlgItem( hwndPage, CID_RF_ST_Explain );
    if (pInfo->hBoldFont && pInfo->hwndRfStFinish)
    {
        SendMessage( 
            pInfo->hwndRfStFinish,
            WM_SETFONT,
            (WPARAM)pInfo->hBoldFont,
            MAKELPARAM(TRUE, 0));
    }

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
RfSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_FINISH );
    return TRUE;
}

BOOL
RfKillActive(
    IN AIINFO* pInfo )
{
    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */

    return FALSE;
}


/*----------------------------------------------------------------------------
** Modem/Adapter property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RnDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Modem/Adapter page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RnDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, RnLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RnInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RnSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = RnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    AIINFO* pInfo;

                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    RnLvItemChanged( pInfo );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
RnInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD   dwErr;
    AIINFO* pInfo;

    TRACE("RnInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRn = hwndPage;
    pInfo->hwndLv = GetDlgItem( hwndPage, CID_RN_LV_Devices );
    ASSERT(pInfo->hwndLv);

    /* Add the modem and adapter images.
    */
    ListView_SetDeviceImageList( pInfo->hwndLv, g_hinstDll );

    /* Add a single column exactly wide enough to fully display the
    ** widest member of the list.
    */
    {
        LV_COLUMN col;

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT;
        col.fmt = LVCFMT_LEFT;
        ListView_InsertColumn( pInfo->hwndLv, 0, &col );
        ListView_SetColumnWidth(
            pInfo->hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );
    }
    
    /* Don't bother with this page if there's only one device, not counting
    ** the bogus "uninstalled" standard modem that's added by EuInit so
    ** entries can be edited when there are no ports.
    */
    if (!pInfo->pArgs->fNoPortsConfigured
        && ListView_GetItemCount( pInfo->hwndLv ) == 1)
    {
        pInfo->fSkipMa = TRUE;
    }

    return FALSE;
}

LVXDRAWINFO*
RnLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    /* Enhanced list view callback to report drawing information.  'HwndLv' is
    ** the handle of the list view control.  'DwItem' is the index of the item
    ** being drawn.
    **
    ** Returns the address of the column information.
    */
{
    /* Use "wide selection bar" feature and the other recommended options.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info =
        { 1, 0, LVXDI_DxFill, { 0, 0 } };

    return &info;
}

VOID
RnLvItemChanged(
    IN AIINFO* pInfo )

    /* Called when the combobox selection changes.  'PInfo' is the wizard
    ** context.
    */
{
    INT      iSel;
    DTLNODE* pNode;
    DTLLIST* pList;

    TRACE("RnLvItemChanged");

    pList = pInfo->pArgs->pEntry->pdtllistLinks;
    ASSERT(pList);
    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
    pInfo->dwSelectedDeviceIndex = 
        (DWORD) ListView_GetNextItem( pInfo->hwndLv, -1, LVNI_SELECTED );

    if (pNode)
    {
        PBLINK* pLink;

        /* Single device selected.  Enable it, move it to the head of the list
        ** of links, and disable all the other links.
        */
        pLink = (PBLINK* )DtlGetData( pNode );
        pLink->fEnabled = TRUE;

        pInfo->fModem =
            (pLink->pbport.pbdevicetype == PBDT_Modem
             || pLink->pbport.pbdevicetype == PBDT_Null);

        /* If the device selected is an X25 PAD, we will drop the user into
        ** the phonebook entry-dialog after this wizard, so that the X25
        ** address can be entered there.
        */
        pInfo->pArgs->fPadSelected = (pLink->pbport.pbdevicetype == PBDT_Pad);

        DtlRemoveNode( pList, pNode );
        DtlAddNodeFirst( pList, pNode );

        for (pNode = DtlGetNextNode( pNode );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            //For whstler 522872
            PBLINK* pLinkTmp = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLinkTmp);
            pLinkTmp->fEnabled = FALSE;
        }
    }
    else
    {
        DTLNODE* pNextNode;
        DTLNODE* pAfterNode;

        pInfo->fModem = FALSE;

        /* ISDN multi-link selected.  Enable the ISDN multi-link nodes, move
        ** them to the head of the list, and disable all the other links.
        */
        pAfterNode = NULL;
        for (pNode = DtlGetFirstNode( pList );
             pNode;
             pNode = pNextNode)
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            pNextNode = DtlGetNextNode( pNode );

            if (pLink->pbport.pbdevicetype == PBDT_Isdn
                && !pLink->fProprietaryIsdn)
            {
                pLink->fEnabled = TRUE;

                DtlRemoveNode( pList, pNode );
                if (pAfterNode)
                    DtlAddNodeAfter( pList, pAfterNode, pNode );
                else
                    DtlAddNodeFirst( pList, pNode );
                pAfterNode = pNode;
            }
            else
            {
                pLink->fEnabled = FALSE;
            }
        }
    }
}

BOOL
RnLvRefresh(
    IN AIINFO* pInfo)
{
    DWORD dwErr = NO_ERROR;
    TCHAR*   psz;
    DTLNODE* pNode;
    DWORD    cMultilinkableIsdn;
    INT      iItem;

    ListView_DeleteAllItems( pInfo->hwndLv );

    iItem = 1;
    cMultilinkableIsdn = 0;
    for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        PBLINK* pLink;

        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT(pLink);

        // For whistler bug 448251
        // for whistler DCR 524304        gangz
        // Filter out LPT1, because the DoD only happens in a NAT or NAT/VPN 
        // which won't use this LPT1 port
        if ( PBDT_PPPoE == pLink->pbport.pbdevicetype ||
            PBDT_Parallel == pLink->pbport.pbdevicetype )
        {
            continue;
        }

        if (pLink->pbport.pbdevicetype == PBDT_Isdn
            && !pLink->fProprietaryIsdn)
        {
            ++cMultilinkableIsdn;
        }

        psz = DisplayPszFromDeviceAndPort(
            pLink->pbport.pszDevice, pLink->pbport.pszPort );
        if (psz)
        {
            PBLINK* pLinkTmp = NULL;
            LV_ITEM item;

            pLinkTmp = (PBLINK* )DtlGetData( pNode );

            ZeroMemory( &item, sizeof(item) );
            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            item.iItem = iItem++;
            item.pszText = psz;

            // I noticed that the device bitmaps were
            // inconsistent with connections, so I'm 
            // matching them up here.
            //
            if (pLinkTmp->pbport.dwType == RASET_Direct)
            {
                item.iImage = DI_Direct;
            }
            else if (pLinkTmp->pbport.pbdevicetype == PBDT_Modem)
            {
                item.iImage = DI_Modem;    
            }
            else 
            {
                item.iImage = DI_Adapter;    
            }

            item.lParam = (LPARAM )pNode;

            ListView_InsertItem( pInfo->hwndLv, &item );
            Free( psz );
        }
    }

    if (cMultilinkableIsdn > 1)
    {
        psz = PszFromId( g_hinstDll, SID_IsdnAdapter );
        if (psz)
        {
            LONG    lStyle;
            LV_ITEM item;

            /* Turn off sorting so the special ISDN-multilink item appears
            ** at the top of the list.
            */
            lStyle = GetWindowLong( pInfo->hwndLv, GWL_STYLE );
            SetWindowLong( pInfo->hwndLv, GWL_STYLE,
                (lStyle & ~(LVS_SORTASCENDING)) );

            ZeroMemory( &item, sizeof(item) );
            item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
            item.iItem = 0;
            item.pszText = psz;
            item.iImage = DI_Adapter;
            item.lParam = (LPARAM )NULL;

            ListView_InsertItem( pInfo->hwndLv, &item );
            Free( psz );
        }
    }

    return NO_ERROR;    
}

BOOL
RnSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    INT cDevices;

    // pmay: 233295.
    // This page does not apply to VPN connections
    //
    if (
        ((pInfo->pArgs->pEntry->dwType == RASET_Vpn        
            &&  !pInfo->pArgs->fNt4Router) 
         || (pInfo->fSkipMa) 
         || (pInfo->pArgs->pEntry->dwType == RASET_Broadband)) //For whistler 349807
       )
    {
        return FALSE;
    }

    // If we have no physical devices, then this page is invalid
    // unless we're focused on an nt4 machine in which case the 
    // tunneling adapters are selected from here.
    if ( ! (pInfo->dwFlags & AI_F_HasPhysDevs) )
    {
        if ( ! pInfo->pArgs->fNt4Router )
            return FALSE;
    }

    // Refresh the list view and make the correct selection
    //
    RnLvRefresh(pInfo);

    // for whistler DCR 524304        gangz
    // If there is no device, just skip this page
    //
    if( 0 == ListView_GetItemCount( pInfo->hwndLv ) )
    {
        return FALSE;
    }
    
    ListView_SetItemState( 
        pInfo->hwndLv, 
        pInfo->dwSelectedDeviceIndex,
        LVIS_SELECTED, LVIS_SELECTED );

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    
    return TRUE;
}


/*----------------------------------------------------------------------------
** Phone Number property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Phone Number page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RpDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RpInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RpSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = RpSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RpKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = RpKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return RpCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


VOID
RpAlternates(
    IN AIINFO* pInfo )

    /* Popup the Alternate Phone Numbers dialog.  'PInfo' is the property
    ** sheet context.
    */
{
    RpPhoneNumberToStash( pInfo );

    if (PhoneNumberDlg(
            pInfo->hwndRp,
            pInfo->pArgs->fRouter,
            pInfo->pListPhoneNumbers,
            &pInfo->fPromoteHuntNumbers ))
    {
        TCHAR* pszPhoneNumber;

        pszPhoneNumber = FirstPszFromList( pInfo->pListPhoneNumbers );
        SetWindowText( pInfo->hwndEbNumber, pszPhoneNumber );
    }
}


BOOL
RpCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("RpCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_RP_PB_Alternates:
            RpAlternates( pInfo );
            return TRUE;
    }

    return FALSE;
}


BOOL
RpInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("RpInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRp = hwndPage;
    pInfo->hwndStNumber = GetDlgItem( hwndPage, CID_RP_ST_Number );
    ASSERT(pInfo->hwndStNumber);
    pInfo->hwndEbNumber = GetDlgItem( hwndPage, CID_RP_EB_Number );
    ASSERT(pInfo->hwndEbNumber);
    pInfo->hwndPbAlternates = GetDlgItem( hwndPage, CID_RP_PB_Alternates );
    ASSERT(pInfo->hwndPbAlternates);

    /* Fill the phone number field from the stash created earlier.
    */
    Edit_LimitText( pInfo->hwndEbNumber, RAS_MaxPhoneNumber );
    SetWindowText( pInfo->hwndEbNumber,
        FirstPszFromList( pInfo->pListPhoneNumbers ) );

    return FALSE;
}


BOOL
RpKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    // pmay: 226610.  Call RpPhoneNumberToStash if we were successfully
    // activated.
    
    /* Update the stashed phone number from the editbox.
    */
    if ( (! pInfo->pArgs->fNt4Router)                && 
         ( (pInfo->pArgs->pEntry->dwType == RASET_Vpn) ||
           (pInfo->pArgs->pEntry->dwType == RASET_Broadband) ) //For whistler 349807
       )
    {
        return FALSE;
    }
   
    RpPhoneNumberToStash( pInfo );

    return FALSE;
}


VOID
RpPhoneNumberToStash(
    IN AIINFO* pInfo )

    /* Replace the first phone number in the stashed list with the contents of
    ** the phone number field.  'pInfo' is the property sheet context.
    */
{
    DWORD  dwErr;
    TCHAR* pszPhoneNumber;

    TRACE("RpPhoneNumberToStash");

    pszPhoneNumber = GetText( pInfo->hwndEbNumber );
    if (pszPhoneNumber)
    {
        dwErr = FirstPszToList( pInfo->pListPhoneNumbers, pszPhoneNumber );
        Free( pszPhoneNumber );
    }
    else
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_RetrievingData, dwErr, NULL );
        AiExit( pInfo, dwErr );
    }
}


BOOL
RpSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    INT      iSel;
    DTLNODE* pNode;
    DTLLIST* pList;
    PBLINK*  pLink;
        
    if (! pInfo->pArgs->fNt4Router)             
    {
        // If we're focused on an nt5 machine, then skip this page
        // if the connection type is virtual because the phone number will
        // be gotten from the vpn destination page.
        if (pInfo->pArgs->pEntry->dwType == RASET_Vpn ||
            pInfo->pArgs->pEntry->dwType == RASET_Broadband)    //Add this for whistler 349087
        {
            return FALSE;
        }
        
        // pmay: 233287
        //
        // No phone number is requred if the device is dcc.  Skip 
        // this page if that is the case.
        //
        pList = pInfo->pArgs->pEntry->pdtllistLinks;
        ASSERT(pList);
        pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
        if (pNode)
        {
            // Single device selected.  See if its dcc
            pLink = (PBLINK* )DtlGetData( pNode );
            if (pLink->pbport.dwType == RASET_Direct)
            {
                return FALSE;
            }
        }
    }        

    // Instruct the wizard to use the destination editbox for the 
    // phone number of this connection
    pInfo->hwndEbNumber = GetDlgItem(pInfo->hwndRp, CID_RP_EB_Number);
    
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    
    return TRUE;
}


/*----------------------------------------------------------------------------
** Router welcome property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RwDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Router Welcome page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                RwInit( hwnd, (EINFO* )(((PROPSHEETPAGE* )lparam)->lParam) );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_RESET:
                {
                    TRACE("RwRESET");
                    AiCancel( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RwSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = RwSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("InKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = RwKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    AIINFO* pInfo;

                    TRACE("InWIZFINISH");

                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }

                    /* You'd think pressing Finish would trigger a KILLACTIVE
                    ** event, but it doesn't, so we do it ourselves.
                    */
                    RwKillActive( pInfo );

                    /* Set "no wizard" user preference, per user's check.
                    */
                    pInfo->pArgs->pUser->fNewEntryWizard = FALSE;
                    pInfo->pArgs->pUser->fDirty = TRUE;
                    g_pSetUserPreferences(
                        NULL,
                        pInfo->pArgs->pUser,
                        pInfo->pArgs->fNoUser ? UPM_Logon : UPM_Normal );

                    pInfo->pArgs->fPadSelected = FALSE;
                    pInfo->pArgs->fChainPropertySheet = TRUE;
                    AiFinish( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, 0 );
                    return TRUE;
                }
            }
            break;
        }

        case WM_DESTROY:
        {
            AiTerm( hwnd );
            break;
        }
    }

    return FALSE;
}

BOOL
RwInit(
    IN     HWND   hwndPage,
    IN OUT EINFO* pArgs )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD    dwErr;
    AIINFO*  pInfo;

    TRACE("RwInit");

    /* We're first page, so initialize the wizard.
    */
    pInfo = AiInit( hwndPage, pArgs );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRw = hwndPage;
    pInfo->hwndRwStWelcome = GetDlgItem( hwndPage, CID_RW_ST_Welcome);

    // Set up a bold font if we can.
    //
    if (pInfo->hBoldFont)
    {
        SendMessage( 
            pInfo->hwndRwStWelcome,
            WM_SETFONT,
            (WPARAM)pInfo->hBoldFont,
            MAKELPARAM(TRUE, 0));
    }

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return TRUE;
}


BOOL
RwKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    return FALSE;
}


BOOL
RwSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_NEXT );
    return TRUE;
}



INT_PTR CALLBACK
SrAddDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    
    AIINFO  * pInfo;
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            pInfo = (AIINFO *)lparam;
            //
            //Set the ip addresses to "0.0.0.0"
            //
            pInfo->hwndDest = GetDlgItem(hwnd, CID_SR_Dest_Ip);
            pInfo->hwndNetMask = GetDlgItem(hwnd, CID_SR_NetMask_Ip);
            pInfo->hwndMetric = GetDlgItem(hwnd, CID_SR_Metric);

            //
            //Initialize Controls
            //
            SetWindowText( pInfo->hwndDest , EMPTY_IPADDRESS );
            SetWindowText( pInfo->hwndNetMask , EMPTY_IPADDRESS );
            SetWindowText( pInfo->hwndMetric , L"1" );

            //
            //Set text limit for metric control
            //
            SendMessage(pInfo->hwndMetric, 
                        EM_LIMITTEXT,
                        2,
                        0
                       );

            SetWindowLongPtr( hwnd, DWLP_USER, (ULONG_PTR )pInfo );

        }
        case WM_COMMAND:
        {
            //
            //id is in loword of wparam and 
            //notification is in hiword of wparam
            //
            switch (LOWORD( wparam ))
            {
                case IDOK:
                {
                    TCHAR * pszDest = NULL;
                    TCHAR * pszMask = NULL;
                    TCHAR * pszMetric = NULL;
                    SROUTEINFOLIST * pNode = NULL;
                    ULONG   ulDestIP, ulMask;
                    pInfo = (AIINFO *)GetWindowLongPtr( hwnd, DWLP_USER);
                    pszDest = GetText( pInfo->hwndDest );

                    // For whistler 492089
                    if( NULL == pszDest )
                    {
                        break;
                    }
                    
                    //
                    // Check to see if the ip,mask and metric 
                    // are still empty.
                    //
                    pszMetric = GetText(pInfo->hwndMetric);
                    if( NULL == pszMetric )
                    {
                        Free( pszDest );
                        break;
                    }
                    
                    if ( !lstrcmp ( pszMetric, L"0" ) )
                    {
                        MsgDlg( hwnd, SID_SR_MetricRequired, NULL );
                        Free(pszDest);
                        Free(pszMetric);
                        return TRUE;
                    }

                    pszMask = GetText( pInfo->hwndNetMask );
                    ulDestIP = inet_addrw(pszDest);
                    ulMask = inet_addrw(pszMask);
                    if ( ulDestIP != (ulMask & ulDestIP) )
                    {
                        MsgDlg( hwnd, SID_SR_InvalidMask, NULL );
                        Free(pszDest);
                        Free(pszMask);
                        Free(pszMetric);
                        return TRUE;
                    }
                    //
                    //Check to see if this entry has already been added
                    //
                    if ( AIInfoSRouteIsRouteinList(pInfo, pszDest, pszMask, pszMetric ) )
                    {
                        Free(pszDest);
                        Free(pszMask);
                        Free(pszMetric);
                        MsgDlg(hwnd, SID_SR_DuplicateRoute, NULL);
                        return TRUE;
                    }
                    AIInfoSRouteCreateEntry(pInfo, pszDest, pszMask, pszMetric );
                    Free(pszDest);
                    Free(pszMask);
                    Free(pszMetric);
                    

                }
                // ...fall thru...
                case IDCANCEL:
                {
                    EndDialog( hwnd, TRUE );
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}


DWORD 
SrRefresSRouteList(
    IN AIINFO * pInfo
    )
{
    DWORD               dwRetCode = ERROR_SUCCESS;
    SROUTEINFOLIST *    pNode = AiInfoSRouteGetFirstNode(pInfo);
    LVITEM              lvItem;
    SHORT               nIndex = 0;

    ListView_DeleteAllItems (pInfo->hwndLvStaticRoutes);
    
    while ( pNode )
    {
        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.iItem = nIndex;
        lvItem.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
        lvItem.lParam =  (LPARAM)pNode;
        lvItem.pszText = pNode->RouteInfo.pszDestIP;

        ListView_InsertItem(pInfo->hwndLvStaticRoutes, &lvItem );

        ListView_SetItemText(   pInfo->hwndLvStaticRoutes,
                                nIndex,
                                1,
                                pNode->RouteInfo.pszNetworkMask
                            );

        ListView_SetItemText(   pInfo->hwndLvStaticRoutes,
                                nIndex,
                                2,
                                pNode->RouteInfo.pszMetric
                            );

        pNode = AiInfoSRouteGetNextNode(pNode);
        nIndex++;
    }

	SrLvItemChanged(pInfo);
    
    return dwRetCode;
}

 
void SrRemoveRoute (AIINFO * pInfo)
{
    int nSelIndex = -1;
    SROUTEINFOLIST * pNode = NULL;
    LVITEM lvItem;

    nSelIndex = ListView_GetNextItem( 
                pInfo->hwndLvStaticRoutes,
                -1,
                LVNI_SELECTED
                                    );

    //
    //Check to see if any items are selected
    //
    if ( nSelIndex == -1 )
        return;
    //
    //Now delete the entry from list box and from the list
    //
    ZeroMemory( &lvItem, sizeof(lvItem) );

    lvItem.mask = LVIF_PARAM;

    lvItem.iItem = nSelIndex;

    ListView_GetItem(pInfo->hwndLvStaticRoutes, &lvItem);

    pNode = (SROUTEINFOLIST *)lvItem.lParam;

    AIInfoRemoveSRouteNode ( pInfo, pNode );

    SrRefresSRouteList ( pInfo );
}

/*------------------------------------------------------------------------
** Static Routes property page
**
**------------------------------------------------------------------------
*/
BOOL
SrCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )
{
    INT_PTR nStatus;

    TRACE( "SrCommand" );

    switch (wId)
    {
        case CID_SR_PB_Add:
            //
            //Show the dialog here to add a new 
            //static route
            //   

            nStatus =
                (BOOL )DialogBoxParam(
                    g_hinstDll,
                    MAKEINTRESOURCE( DID_SR_StaticRoute ),
                    pInfo->hwndSr,
                    SrAddDlgProc,
                    (LPARAM )pInfo );
            SrRefresSRouteList(pInfo);
            return TRUE;
        case CID_SR_PB_Remove:
            //
            //Check to see if we have any items selected.  
            //
            SrRemoveRoute ( pInfo );
            

            return TRUE;
    }

    return FALSE;
}


INT_PTR CALLBACK
SrDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return SrInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("SrSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = SrSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("SrKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = SrKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

				case LVN_ITEMCHANGED:
                {
                    AIINFO* pInfo;

                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    SrLvItemChanged( pInfo );
                    return TRUE;
                }

            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return SrCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }
    return FALSE;
}

VOID
SrLvItemChanged(
    IN AIINFO* pInfo )
{
	HWND hwnd;
	int  nSelIndex;

	hwnd = GetDlgItem(pInfo->hwndSr, CID_SR_PB_Remove);
	if(hwnd){

		nSelIndex = ListView_GetNextItem( 
                pInfo->hwndLvStaticRoutes,
                -1,
                LVNI_SELECTED);

		if(nSelIndex == -1){
			//Disable the remove button
			EnableWindow(hwnd, FALSE);
		}
		else {
			//Enable remove button
			EnableWindow(hwnd, TRUE);
		}
	}
}


BOOL
SrInit(
    IN HWND hwndPage )
{
    AIINFO* pInfo;
	HWND hwnd;

    TRACE("SrInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;


	//Disable the Remove button
	hwnd = GetDlgItem(hwndPage, CID_SR_PB_Remove);
	if(hwnd){
		EnableWindow(hwnd, FALSE);
	}


    /* Initialize page-specific context information.
    */
    pInfo->hwndSr = hwndPage;

    pInfo->hwndLvStaticRoutes = GetDlgItem(hwndPage, CID_SR_LV_StaticRoutes );

    ListView_SetExtendedListViewStyle( pInfo->hwndLvStaticRoutes,
            ListView_GetExtendedListViewStyle(pInfo->hwndLvStaticRoutes) 
                    | LVS_EX_FULLROWSELECT 
                                    );
    //
    // Add columns.
    //
    {
        LV_COLUMN   col;
        TCHAR*      pszHeader0 = NULL;
        TCHAR*      pszHeader1 = NULL;
        TCHAR*      pszHeader2 = NULL;
        RECT        rc;
        LONG        lColWidth;

        pszHeader0 = PszFromId( g_hinstDll, SID_SR_Destination );
        pszHeader1 = PszFromId( g_hinstDll, SID_SR_Netmask );        
        pszHeader2 = PszFromId( g_hinstDll, SID_SR_Metric );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_TEXT + LVCF_SUBITEM;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader0) ? pszHeader0 : TEXT("");
        ListView_InsertColumn( pInfo->hwndLvStaticRoutes, 0, &col );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_SUBITEM + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader1) ? pszHeader1 : TEXT("");
        col.iSubItem = 1;
        ListView_InsertColumn( pInfo->hwndLvStaticRoutes, 1, &col );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_SUBITEM + LVCF_TEXT ;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader2) ? pszHeader2 : TEXT("");
        col.iSubItem = 2;
        ListView_InsertColumn( pInfo->hwndLvStaticRoutes, 2, &col );

        //
        //Now Set the column headers
        //
        Free0( pszHeader0 );
        Free0( pszHeader1 );
        Free0( pszHeader2 );

        //
        //Set column width
        //
        GetClientRect(pInfo->hwndLvStaticRoutes, &rc);
        lColWidth = ( rc.right - rc.left ) / 3;
        ListView_SetColumnWidth (   pInfo->hwndLvStaticRoutes,
                                    0,
                                    lColWidth
                                );

        ListView_SetColumnWidth (   pInfo->hwndLvStaticRoutes,
                                    1,
                                    lColWidth
                                );

        ListView_SetColumnWidth (   pInfo->hwndLvStaticRoutes,
                                    2,
                                    lColWidth
                                );

    }

    // for whistler DCR 524304        gangz
    PropSheet_SetWizButtons( pInfo->hwndSr, PSWIZB_BACK | PSWIZB_NEXT );

    return TRUE;
}

BOOL
SrKillActive(
    IN AIINFO* pInfo )
{

    return FALSE;
}

BOOL
SrSetActive(
    IN AIINFO* pInfo )
{
    BOOL fDisplay = FALSE;

    if (pInfo->fIp)
    {
        //
        //Check to see if there are existing routes.
        //If so, add them to the list.
        //

        SrRefresSRouteList(pInfo);
        fDisplay =  TRUE;
    }
    else
    {   
        fDisplay = FALSE;
    }

    // for whistler DCR 524304        gangz
    PropSheet_SetWizButtons( pInfo->hwndSr, PSWIZB_BACK | PSWIZB_NEXT );

    // Won't show this for NAT path
    //
    if(  RASEDFLAG_NAT & pInfo->pArgs->pApiArgs->dwFlags )
    {
        // Add a default static route
        TCHAR pszDest[] = TEXT("0.0.0.0");
        TCHAR pszMask[] = TEXT("0.0.0.0");
        TCHAR pszMetric[] = TEXT("1");
        
        if ( !AIInfoSRouteIsRouteinList(pInfo, pszDest, pszMask, pszMetric ) )
        {
            AIInfoSRouteCreateEntry(pInfo, pszDest, pszMask, pszMetric );
        }
        
        //Return No Display flag
        fDisplay = FALSE;

    }
    
    return fDisplay;

}



/*----------------------------------------------------------------------------
** Server settings property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
SsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the 5 checkboxes page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("SsDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return SsInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("SsSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = SsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("SsKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = SsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return SsCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}



BOOL
SsCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("SsCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_SS_CB_AddUser:
            return TRUE;
    }

    return FALSE;
}


BOOL
SsInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("SsInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndSs = hwndPage;

    if (pInfo->fIpConfigured)
        CheckDlgButton( hwndPage, CID_SS_CB_RouteIp, BST_CHECKED );

//for whistler bug 213901
//Hide the IPX checkbox
//move other check boxes to cover the hole made by hiding

// For .Net server bug 605988 remove IPX for all versions

    return FALSE;
}


BOOL
SsKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    pInfo->fIp =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_RouteIp );

//for whistler bug 213901, .Net 605988, remove IPX
//
    pInfo->fIpx = FALSE;

    pInfo->pArgs->fAddUser =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_AddUser );
    pInfo->pArgs->pEntry->fAuthenticateServer = FALSE;
    pInfo->fClearPwOk =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_PlainPw );
    pInfo->fNotNt =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_NotNt );

    if (pInfo->fIp && !pInfo->fIpConfigured)
    {
        MsgDlg( pInfo->hwndDlg, SID_ConfigureIp, NULL );
        SetFocus( GetDlgItem( pInfo->hwndSs, CID_SS_CB_RouteIp) );
        return TRUE;
    }

    return FALSE;
}


BOOL
SsSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    HWND hwndScript = GetDlgItem( pInfo->hwndSs, CID_SS_CB_NotNt );
    HWND hwndPw = GetDlgItem( pInfo->hwndSs, CID_SS_CB_PlainPw );
    HWND hwndUser = GetDlgItem( pInfo->hwndSs, CID_SS_CB_AddUser );
    //
    // We only allow interactive scripting on modem devices
    //
    // (pmay: 378432.  Same for PAP/SPAP)
    //
    if ( pInfo->pArgs->pEntry->dwType == RASET_Vpn )
    {
        Button_SetCheck( hwndScript, FALSE );
        Button_SetCheck( hwndPw, FALSE );
        EnableWindow( hwndScript, FALSE );
        EnableWindow( hwndPw, FALSE );
    }
    else
    {
        EnableWindow( hwndScript, TRUE );
        EnableWindow( hwndPw, TRUE );
    }

    //For PPPoE dont add a dial-in user account whistler 345068 349087 gangz
    //
    // For whistler bug 522292, Enable the AddUser check box if it is not a 
    // PPPoE connections
    //
    if (hwndUser)
    {
        Button_SetCheck( hwndUser, FALSE );
        if ( RASET_Broadband == pInfo->pArgs->pEntry->dwType )
        {
            EnableWindow( hwndUser, FALSE);
        }
        else
        {
            //For whistler bug 522292
            EnableWindow( hwndUser, TRUE);
        }
    }
    
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


/*----------------------------------------------------------------------------
** Vpn destination property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
VdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the vpn destination page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return VdInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("VdSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = VdSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("VdKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = VdKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
VdInit(
    IN HWND   hwndPage )
    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD    dwErr;
    AIINFO*  pInfo = NULL;
    PBENTRY* pEntry;

    TRACE("InInit");

    // Get the context of this page
    pInfo = AiContext( hwndPage );
    ASSERT ( pInfo );

    // Set up the interface name stuff
    //
    //For prefix bug 226336 to validate the pInfo   gangz
    //
    if(pInfo)
    {
        pInfo->hwndEbNumber =
            GetDlgItem( hwndPage, CID_VD_EB_NameOrAddress );
     //    ASSERT(pInfo->hwndEbInterfaceName);
        ASSERT(pInfo->hwndEbNumber);
     
    
        Edit_LimitText( pInfo->hwndEbNumber, RAS_MaxPhoneNumber );
        SetWindowText( pInfo->hwndEbNumber,
            FirstPszFromList( pInfo->pListPhoneNumbers ) );

        /* Initialize page-specific context information.
        */
        pInfo->hwndVd = hwndPage;
       return TRUE;
   }
   else
   {
       return FALSE;
   }

}

BOOL
VdKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    // pmay: 226610.  Call RpPhoneNumberToStash if we were successfully
    // activated.

    // If we're focused on an nt4 box, then this page is 
    // invalid (pptp was the only type)
    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }

    // If we have no tunnel devices, then this page is invalid
    else if ( ! (pInfo->dwFlags & AI_F_HasTunlDevs) )
    {
        return FALSE;
    }

    // If the connection type is not virtual, skip this page since the
    // destination will be gotten from the phone number/PPPoE page.
    if ( pInfo->pArgs->pEntry->dwType != RASET_Vpn )
    {
        return FALSE;
    }    

    RpPhoneNumberToStash(pInfo);
    
    return FALSE;
}

BOOL
VdSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    // If we're focused on an nt4 box, then this page is 
    // invalid (pptp was the only type)
    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }

    // If we have no tunnel devices, then this page is invalid
    else if ( ! (pInfo->dwFlags & AI_F_HasTunlDevs) )
    {
        return FALSE;
    }

    // If the connection type is not virtual, skip this page since the
    // destination will be gotten from the phone number page.
    if ( pInfo->pArgs->pEntry->dwType != RASET_Vpn )
    {
        return FALSE;
    }            

    // Instruct the wizard to use the destination editbox for the 
    // phone number of this connection
    pInfo->hwndEbNumber = GetDlgItem(pInfo->hwndVd, CID_VD_EB_NameOrAddress);
    
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    
    return TRUE;
}

/*----------------------------------------------------------------------------
** Vpn type property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
VtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the vpn type page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return VtInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("VtSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = VtSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("VtKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = VtKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
VtInit(
    IN HWND   hwndPage )
    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO * pInfo;

    // Get the context
    pInfo = AiContext( hwndPage );
    ASSERT ( pInfo );
    if (pInfo == NULL)
    {
        return FALSE;
    }
    
    // Initialize the checks
    pInfo->hwndVtRbAutomatic = GetDlgItem( hwndPage, CID_VT_RB_Automatic );
    pInfo->hwndVtRbPptp = GetDlgItem( hwndPage, CID_VT_RB_Pptp );
    pInfo->hwndVtRbL2tp = GetDlgItem( hwndPage, CID_VT_RB_L2tp );
    ASSERT( pInfo->hwndVtRbAutomatic );
    ASSERT( pInfo->hwndVtRbPptp );
    ASSERT( pInfo->hwndVtRbL2tp );

    // Default to automatic
    Button_SetCheck( pInfo->hwndVtRbAutomatic, TRUE );     
    
    return FALSE;
}

BOOL
VtKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    if ( Button_GetCheck( pInfo->hwndVtRbAutomatic ) )
    {
        pInfo->dwVpnStrategy = VS_Default;
    }

    else if ( Button_GetCheck( pInfo->hwndVtRbPptp ) )
    {
        pInfo->dwVpnStrategy = VS_PptpOnly;
    }
    
    else if ( Button_GetCheck( pInfo->hwndVtRbL2tp ) )
    {
        pInfo->dwVpnStrategy = VS_L2tpOnly;
    }
    
    return FALSE;
}

BOOL
VtSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    // If we're focused on an nt4 box, then this page is 
    // invalid (pptp was the only type)
    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }

    // If we have no tunnel devices, then this page is invalid
    else if ( ! (pInfo->dwFlags & AI_F_HasTunlDevs) )
    {
        return FALSE;
    }

    // If the connection type is not virtual, skip this page since the
    // destination will be gotten from the phone number page.
    if ( pInfo->pArgs->pEntry->dwType != RASET_Vpn )
    {
        return FALSE;
    }            

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\nwc.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// nwc.c
// Remote Access Common Dialog APIs
// NetWare Compatible warning dialog
//
// 12/06/95 Steve Cobb


#include "rasdlgp.h"


//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// NetWare Compatible warning dialog argument block.
//
typedef struct
_NWARGS
{
    // Caller's  arguments to the stub API.
    //
    BOOL fPosition;
    LONG xDlg;
    LONG yDlg;
    PBFILE* pFile;
    PBENTRY* pEntry;
}
NWARGS;


// NetWare Compatible warning dialog context block.
//
typedef struct
_NWINFO
{
    // Stub API arguments.
    //
    NWARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndCb;
}
NWINFO;


//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

BOOL
NwConnectionDlg(
    IN HWND hwndOwner,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg,
    IN PBFILE* pFile,
    IN PBENTRY* pEntry );

INT_PTR CALLBACK
NwDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
NwCommand(
    IN NWINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
NwInit(
    IN HWND hwndDlg,
    IN NWARGS* pArgs );

VOID
NwTerm(
    IN HWND hwndDlg );

TCHAR*
GetNwProviderName(
    void );

BOOL
IsActiveNwLanConnection(
    void );


//----------------------------------------------------------------------------
// Entry point
//----------------------------------------------------------------------------

BOOL
NwConnectionCheck(
    IN HWND hwndOwner,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg,
    IN PBFILE* pFile,
    IN PBENTRY* pEntry )

    // Warns about active NetWare LAN connections being blown away, if
    // indicated.  'HwndOwner' is the owning window if a dialog is necessary.
    // 'FPosition', 'xDlg', and 'yDlg' are the dialog positioning parameters
    // as specified to the calling API.  'PFile' and 'pEntry' are the open
    // phonebook file and entry to check.
    //
    // Note: This call will write the phonebook file if user checks the "not
    //       in the future" checkbox.
    //
    // Returns true if warning is not necessary or user pressed OK, false if
    // user presses cancel.
    //
{
    TRACE("NwConnectionCheck");

    // Warn about active NetWare LAN connections being blown away, if
    // indicated.
    //
    if (!pEntry->fSkipNwcWarning
        && pEntry->dwBaseProtocol == BP_Ppp
        && (g_pGetInstalledProtocolsEx(NULL, FALSE, TRUE, FALSE) & NP_Ipx)
        && !(pEntry->dwfExcludedProtocols & NP_Ipx)
        && IsActiveNwLanConnection())
    {
        if (!NwConnectionDlg(
                hwndOwner, fPosition, xDlg, yDlg, pFile, pEntry ))
        {
            return FALSE;
        }
    }

    return TRUE;
}


//----------------------------------------------------------------------------
// Netware dialog routines (alphabetically following stub and DlgProc)
//----------------------------------------------------------------------------

BOOL
NwConnectionDlg(
    IN HWND hwndOwner,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg,
    IN PBFILE* pFile,
    IN PBENTRY* pEntry )

    // Pops up a warning about active NWC LAN connections being blown away.
    // 'HwndOwner' is the owning window if a dialog is necessary.
    // 'FPosition', 'xDlg', and 'yDlg' are the dialog positioning parameters
    // as specified to the calling API.  'PFile' and 'pEntry' are the open
    // phonebook file and entry to check.
    //
    // Note: This call will write the phonebook file if user checks the "not
    //       in the future" checkbox.
    //
    // Returns true if user pressed OK, false if user presses cancel.
    //
{
    INT_PTR nStatus;
    NWARGS args;

    TRACE( "NwConnectionDlg" );

    // Initialize dialog argument block.
    //
    args.fPosition = fPosition;
    args.xDlg = xDlg;
    args.yDlg = yDlg;
    args.pFile = pFile;
    args.pEntry = pEntry;

    // Run the dialog.
    //
    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_NW_NwcConnections ),
            hwndOwner,
            NwDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
NwDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Netware warning dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "NwDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return NwInit( hwnd, (NWARGS* )lparam );
        }

        case WM_COMMAND:
        {
            NWINFO* pInfo = (NWINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return NwCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            NwTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
NwCommand(
    IN NWINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "NwCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            TRACE( "OK pressed" );

            if (Button_GetCheck( pInfo->hwndCb ))
            {
                DWORD dwErr;

                // Save user's preference to skip this warning popup in the
                // phonebook.
                //
                pInfo->pArgs->pEntry->fSkipNwcWarning = TRUE;
                pInfo->pArgs->pEntry->fDirty = TRUE;
                dwErr = WritePhonebookFile( pInfo->pArgs->pFile, NULL );
                if (dwErr != 0)
                {
                    ErrorDlg( pInfo->hwndDlg, SID_OP_WritePhonebook,
                        dwErr, NULL );
                }
            }

            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
NwInit(
    IN HWND hwndDlg,
    IN NWARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments as passed to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    TCHAR* psz;
    NWINFO* pInfo;

    TRACE( "NwInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndCb = GetDlgItem( hwndDlg, CID_NW_CB_SkipPopup );
    ASSERT( pInfo->hwndCb );

    // Position the dialog per caller's instructions.
    //
    PositionDlg( hwndDlg, pArgs->fPosition, pArgs->xDlg, pArgs->yDlg );
    SetForegroundWindow( hwndDlg );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
NwTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    NWINFO* pInfo = (NWINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "NwTerm" );

    if (pInfo)
    {
        Free( pInfo );
    }
}


//----------------------------------------------------------------------------
// Utility routines
//----------------------------------------------------------------------------

TCHAR*
GetNwProviderName(
    void )

    // Returns the NWC provider name from the registry or NULL if none.  It's
    // caller's responsibility to Free the returned string.
    //
{
#define REGKEY_Nwc  TEXT("SYSTEM\\CurrentControlSet\\Services\\NWCWorkstation\\networkprovider")
#define REGVAL_Name TEXT("Name")

    HKEY hkey;
    DWORD dwErr;
    DWORD cb = 0;	//Add this for prefix whislter bug 295921
    TCHAR* psz = NULL;
    DWORD dwType = REG_SZ;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Nwc, &hkey );

    if (dwErr == 0)
    {
        dwErr = RegQueryValueEx(
            hkey, REGVAL_Name, NULL, &dwType, NULL, &cb );
        if (dwErr == 0)
        {
            psz = (TCHAR* )Malloc( cb );
            if (psz)
            {
                dwErr = RegQueryValueEx(
                    hkey, REGVAL_Name, NULL, &dwType, (LPBYTE )psz, &cb );
            }
        }

        RegCloseKey( hkey );
    }

    if (!psz || dwErr != 0 || dwType != REG_SZ)
    {
        if (psz)
        {
            Free( psz );
        }
        return NULL;
    }

    return psz;
}


BOOL
IsActiveNwLanConnection(
    void )

    // Returns true if NWC is installed and there are redirected drive or UNC
    // connections using NWC provider, false otherwise.
    //
{
    DWORD dwErr;
    DWORD cEntries;
    DWORD cb;
    TCHAR* pszProvider;
    BYTE ab[ 1024 ];
    HANDLE hEnum = INVALID_HANDLE_VALUE;
    BOOL fStatus = FALSE;

    do
    {
        pszProvider = GetNwProviderName();
        if (!pszProvider)
        {
            break;
        }

        dwErr = WNetOpenEnum(
            RESOURCE_CONNECTED, RESOURCETYPE_ANY, 0, NULL, &hEnum );
        if (dwErr != NO_ERROR)
        {
            break;
        }

        for (;;)
        {
            NETRESOURCE* pnr;

            cEntries = 0xFFFFFFFF;
            cb = sizeof(ab);
            dwErr = WNetEnumResource( hEnum, &cEntries, ab, &cb );
            if (!cEntries || dwErr != NO_ERROR)
            {
                break;
            }

            for (pnr = (NETRESOURCE* )ab; cEntries--; ++pnr)
            {
                if (pnr->lpProvider
                    && lstrcmp( pnr->lpProvider, pszProvider ) == 0)
                {
                    fStatus = TRUE;
                    break;
                }
            }
        }
    }
    while (FALSE);

    if (hEnum != INVALID_HANDLE_VALUE)
    {
        WNetCloseEnum( hEnum );
    }

    if (pszProvider)
    {
        Free( pszProvider );
    }

    return fStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\pbook.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// pbook.c
// Remote Access Common Dialog APIs
// RasPhonebookDlg APIs
//
// 06/20/95 Steve Cobb


#include "rasdlgp.h" // Our private header
#include <commdlg.h> // FileOpen dialog
#include <dlgs.h>    // Common dialog resource constants
#include <rnk.h>     // Shortcut file library

#define WM_RASEVENT      (WM_USER+987)
#define WM_NOUSERTIMEOUT (WM_USER+988)

#define RAS_SC_IS_BAD_PIN(_err) \
    (((_err) == SCARD_W_WRONG_CHV) || ((_err) == SCARD_E_INVALID_CHV))

// In no-user mode this is updated on every mouse or keyboard event by our
// window hook.  The monitor thread notices and resets it's inactivity
// timeout.
//
DWORD g_cInput = 0;


//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwDuHelp[] =
{
    CID_DU_ST_Entries,     HID_DU_LB_Entries,
    CID_DU_LB_Entries,     HID_DU_LB_Entries,
    CID_DU_PB_New,         HID_DU_PB_New,
    CID_DU_PB_More,        HID_DU_PB_More,
    CID_DU_PB_Dial,        HID_DU_PB_Dial,
    CID_DU_PB_Close,       HID_DU_PB_Close,
    0, 0
};


//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// Phonebook dialog argument block.
//
typedef struct
_DUARGS
{
    // Caller's  arguments to the RAS API.  Outputs in 'pApiArgs' are visible
    // to the API which has the address of same.  'PszPhonebook' is updated if
    // user changes the phonebook on the Preferences->PhoneList page, though
    // API is unaware of this.
    //
    LPTSTR pszPhonebook;
    LPTSTR pszEntry;
    RASPBDLG* pApiArgs;

    // RAS API return value.  Set true if a connection is established within
    // the dialog.
    //
    BOOL fApiResult;
}
DUARGS;

typedef struct
_DUCONTEXT
{
    LPTSTR  pszPhonebookPath;
    PBENTRY *pEntry;
}
DUCONTEXT;


// Dial-Up Networking dialog context block.
//
typedef struct
_DUINFO
{
    // Caller's arguments to the RAS API.
    //
    DUARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndPbNew;
    HWND hwndPbProperties;
    HWND hwndLbEntries;
    HWND hwndPbDial;

    // Global user preference settings read from the Registry.
    //
    PBUSER user;

    // Phonebook settings read from the phonebook file.
    //
    PBFILE file;

    // No logged on user information retrieved via callback.
    //
    RASNOUSER* pNoUser;

    // Set if in "no user before logon" mode.  Always the same as the
    // RASPBDFLAG but here for convenience.
    //
    BOOL fNoUser;

    // Window hooks used to detect user input in the thread.  Used only when
    // 'fNoUser' is set.
    //
    HHOOK hhookKeyboard;
    HHOOK hhookMouse;

    // TAPI session handle.
    //
    HLINEAPP hlineapp;

    // Handle of the RAS connection associated with the current entry or NULL
    // if none.
    //
    HRASCONN hrasconn;

    // Connect monitor objects.
    //
    HANDLE hThread;
    HANDLE hEvent;
    BOOL fAbortMonitor;
}
DUINFO;


//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

BOOL
DuCommand(
    IN DUINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
DuCreateShortcut(
    IN DUINFO* pInfo );

LRESULT CALLBACK
DuCreateShortcutCallWndRetProc(
    int code,
    WPARAM wparam,
    LPARAM lparam );

INT_PTR CALLBACK
DuDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
DuDeleteSelectedEntry(
    IN DUINFO* pInfo );

VOID
DuDialSelectedEntry(
    IN DUINFO* pInfo );

VOID
DuEditSelectedEntry(
    IN DUINFO* pInfo );

VOID
DuEditSelectedLocation(
    IN DUINFO* pInfo );

DWORD
DuFillLocationList(
    IN DUINFO* pInfo );

VOID
DuFillPreview(
    IN DUINFO* pInfo );

DWORD
DuGetEntry(
    DUINFO* pInfo,
    DUCONTEXT* pContext );

TCHAR*
DuGetPreview(
    IN DUINFO* pInfo );

DWORD
DuHandleConnectFailure(
    IN DUINFO* pInfo,
    IN RASDIALDLG* pDialInfo);
    
VOID
DuHangUpSelectedEntry(
    IN DUINFO* pInfo );

BOOL
DuInit(
    IN HWND    hwndDlg,
    IN DUARGS* pArgs );

LRESULT CALLBACK
DuInputHook(
    IN int nCode,
    IN WPARAM wparam,
    IN LPARAM lparam );

LRESULT APIENTRY
DuLbEntriesProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
DuLocationChange(
    IN DUINFO* pInfo );

DWORD
DuMonitorThread(
    LPVOID pThreadArg );

VOID
DuNewEntry(
    IN DUINFO* pInfo,
    IN BOOL fClone );

VOID
DuOperatorDial(
    IN DUINFO* pInfo );

LRESULT APIENTRY
DuPbMoreProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
DuPopupMoreMenu(
    IN DUINFO* pInfo );

VOID
DuPreferences(
    IN DUINFO* pInfo,
    IN BOOL fLogon );

VOID
DuSetup(
    IN DUINFO* pInfo );

VOID
DuStatus(
    IN DUINFO* pInfo );

VOID
DuTerm(
    IN HWND hwndDlg );

VOID
DuUpdateConnectStatus(
    IN DUINFO* pInfo );

VOID
DuUpdateLbEntries(
    IN DUINFO* pInfo,
    IN TCHAR* pszEntry );

VOID
DuUpdatePreviewAndLocationState(
    IN DUINFO* pInfo );

VOID
DuUpdateTitle(
    IN DUINFO* pInfo );

VOID
DuWriteShortcutFile(
    IN HWND hwnd,
    IN TCHAR* pszRnkPath,
    IN TCHAR* pszPbkPath,
    IN TCHAR* pszEntry );

DWORD
DwGetEapLogonInfo(
    VOID *pv,
    EAPLOGONINFO **ppEapLogonInfo );

VOID WINAPI
RasPbDlgCallbackThunk(
    ULONG_PTR ulpId,
    DWORD dwEvent,
    LPWSTR pszEntry,
    LPVOID pArgs );


//----------------------------------------------------------------------------
// External entry points
//----------------------------------------------------------------------------

BOOL APIENTRY
RasPhonebookDlgA(
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry,
    IN OUT LPRASPBDLGA lpInfo )

    // Win32 ANSI entrypoint that displays the Dial-Up Networking dialog, i.e.
    // the RAS phonebook.  'LpszPhonebook' is the full path the phonebook or
    // NULL indicating the default phonebook.  'LpszEntry' is the entry to
    // highlight on entry or NULL to highlight the first entry in the list.
    // 'LpInfo' is caller's additional input/output parameters.
    //
    // Returns true if user establishes a connection, false otherwise.
    //
{
    WCHAR* pszPhonebookW;
    WCHAR* pszEntryW;
    RASPBDLGW infoW;
    BOOL fStatus;

    TRACE( "RasPhonebookDlgA" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASPBDLGA))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    // Thunk "A" arguments to "W" arguments.
    //
    if (lpszPhonebook)
    {
        pszPhonebookW = StrDupTFromAUsingAnsiEncoding( lpszPhonebook );
        if (!pszPhonebookW)
        {
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
    {
        pszPhonebookW = NULL;
    }

    if (lpszEntry)
    {
        pszEntryW = StrDupTFromAUsingAnsiEncoding( lpszEntry );
        if (!pszEntryW)
        {
            Free0( pszPhonebookW );
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
    {
        pszEntryW = NULL;
    }

    // Take advantage of the structures currently having the same size and
    // layout.  Only the callback is different.
    //
    ASSERT( sizeof(RASPBDLGA) == sizeof(RASPBDLGW) );
    CopyMemory( &infoW, lpInfo, sizeof(infoW) );

    if (lpInfo->pCallback)
    {
        infoW.dwCallbackId = (ULONG_PTR)lpInfo;
        infoW.pCallback = RasPbDlgCallbackThunk;
    }

    infoW.reserved2 = lpInfo->reserved2;

    // Thunk to the equivalent "W" API.
    //
    fStatus = RasPhonebookDlgW( pszPhonebookW, pszEntryW, &infoW );

    Free0( pszPhonebookW );
    Free0( pszEntryW );

    return fStatus;
}


VOID WINAPI
RasPbDlgCallbackThunk(
    ULONG_PTR ulpId,
    DWORD dwEvent,
    LPWSTR pszEntry,
    LPVOID pArgs )

    // This thunks "W" callbacks to API caller's "A" callback.
    //
{
    CHAR* pszEntryA;
    VOID* pArgsA;
    RASPBDLGA* pInfo;
    RASNOUSERA nuA;

    if (dwEvent == RASPBDEVENT_NoUser || dwEvent == RASPBDEVENT_NoUserEdit)
    {
        RASNOUSERW* pnuW = (RASNOUSERW* )pArgs;
        ASSERT( pnuW );

        ZeroMemory( &nuA, sizeof(nuA) );
        nuA.dwSize = sizeof(nuA);
        nuA.dwFlags = pnuW->dwFlags;
        nuA.dwTimeoutMs = pnuW->dwTimeoutMs;

        StrCpyAFromW(nuA.szUserName, pnuW->szUserName, UNLEN + 1);
        StrCpyAFromW(nuA.szPassword, pnuW->szPassword, UNLEN + 1);
        StrCpyAFromW(nuA.szDomain, pnuW->szDomain, UNLEN + 1);
        
        pArgsA = &nuA;
    }
    else
    {
        pArgsA = NULL;
    }

    pszEntryA = StrDupAFromT( pszEntry );
    pInfo = (RASPBDLGA* )ulpId;
    pInfo->pCallback( pInfo->dwCallbackId, dwEvent, pszEntryA, pArgsA );
    Free0( pszEntryA );

    if (dwEvent == RASPBDEVENT_NoUser || dwEvent == RASPBDEVENT_NoUserEdit)
    {
        RASNOUSERW* pnuW = (RASNOUSERW* )pArgs;

        pnuW->dwFlags = nuA.dwFlags;
        pnuW->dwTimeoutMs = nuA.dwTimeoutMs;

        StrCpyWFromA(pnuW->szUserName, nuA.szUserName, UNLEN + 1);
        StrCpyWFromA(pnuW->szPassword, nuA.szPassword, UNLEN + 1);
        StrCpyWFromA(pnuW->szDomain, nuA.szDomain, UNLEN + 1);
        
        RtlSecureZeroMemory( nuA.szPassword, PWLEN );
    }
}


BOOL APIENTRY
RasPhonebookDlgW(
    IN LPWSTR lpszPhonebook,
    IN LPWSTR lpszEntry,
    IN OUT LPRASPBDLGW lpInfo )

    // Win32 Unicode entrypoint that displays the Dial-Up Networking dialog,
    // i.e. the RAS phonebook.  'LpszPhonebook' is the full path the phonebook
    // or NULL indicating the default phonebook.  'LpszEntry' is the entry to
    // highlight on entry or NULL to highlight the first entry in the list.
    // 'LpInfo' is caller's additional input/output parameters.
    //
    // Returns true if user establishes a connection, false otherwise.
    //
{
    INT_PTR nStatus;
    DUARGS args;

    TRACE( "RasPhonebookDlgW" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASPBDLGW))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    // Initialize OUT parameters.
    //
    lpInfo->dwError = 0;

    // Initialize dialog argument block.
    //
    args.pszPhonebook = lpszPhonebook;
    args.pszEntry = lpszEntry;
    args.pApiArgs = lpInfo;
    args.fApiResult = FALSE;


    // Run the dialog.
    //
    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DU_DialUpNetworking ),
            lpInfo->hwndOwner,
            DuDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( lpInfo->hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        lpInfo->dwError = ERROR_UNKNOWN;
        args.fApiResult = FALSE;
    }

    return args.fApiResult;
}


//----------------------------------------------------------------------------
// Dial-Up Networking dialog
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
DuDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Dial-Up Networking dialog, i.e. the
    // phonebook dialog.  Parameters and return value are as described for
    // standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DuDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DuInit( hwnd, (DUARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDuHelp, hwnd, unMsg, wparam, lparam );
            return TRUE;
        }

        case WM_COMMAND:
        {
            DUINFO* pInfo = (DUINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return DuCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_RASEVENT:
        {
            DUINFO* pInfo = (DUINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            DuUpdateConnectStatus( pInfo );
            break;
        }

        case WM_NOUSERTIMEOUT:
        {
            DUINFO* pInfo;
            ULONG ulCallbacksActive;

            TRACE( "CancelOwnedWindows" );
            CancelOwnedWindows( hwnd );
            TRACE( "CancelOwnedWindows done" );

            ulCallbacksActive = CallbacksActive( 1, NULL );
            if (ulCallbacksActive > 0)
            {
                TRACE1( "NoUser timeout stall, n=%d", ulCallbacksActive );
                PostMessage( hwnd, WM_NOUSERTIMEOUT, wparam, lparam );
                return TRUE;
            }

            pInfo = (DUINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            if (pInfo)
            {
                pInfo->pArgs->pApiArgs->dwError = STATUS_TIMEOUT;
            }

            EndDialog( hwnd, TRUE );
            CallbacksActive( 0, NULL );
            break;
        }

        case WM_DESTROY:
        {
            DuTerm( hwnd );

            /*

            //We have to wait for Deonb to return us the IID_Dun1 icon
            //For whistler bug 372078 381099
            //Icon returned by GetCurrentIconEntryType() has to be destroyed
            {
                HICON hIcon=NULL;

                hIcon = GetProp( hwnd, TEXT("TweakTitleBar_Small_Icon"));
                ASSERT(hIcon);
                if( hIcon )
                {
                    DestroyIcon(hIcon);
                }
                else
                {
                    TRACE("DuDlgProc:Destroy small Icon failed");
                }

                RemoveProp( hwnd, TEXT("TweakTitleBar_Small_Icon") );
                
                hIcon = GetProp( hwnd, TEXT("TweakTitleBar_Big_Icon"));
                ASSERT(hIcon);
                if( hIcon )
                {
                    DestroyIcon(hIcon);
                }
                else
                {
                    TRACE("DuDlgProc:Destroy Big Icon failed");
                }
                
                RemoveProp( hwnd, TEXT("TweakTitleBar_Big_Icon") );

            }
            */
            break;
        }
    }

    return FALSE;
}


BOOL
DuCommand(
    IN DUINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "DuCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_DU_PB_Dial:
        {
            if (pInfo->hrasconn)
            {
                DuHangUpSelectedEntry( pInfo );
            }
            else
            {
                DuDialSelectedEntry( pInfo );
            }
            return TRUE;
        }

        case CID_DU_PB_New:
        {
            DuNewEntry( pInfo, FALSE );
            return TRUE;
        }

        case CID_DU_PB_More:
        {
            DuEditSelectedEntry( pInfo );
            return TRUE;
        }

        case CID_DU_LB_Entries:
        {
            if (wNotification == CBN_SELCHANGE)
            {
                PBENTRY *pEntry;
                DWORD  dwErr = SUCCESS;
                DUCONTEXT *pContext;

                pContext = (DUCONTEXT *)
                           ComboBox_GetItemDataPtr(
                                pInfo->hwndLbEntries,
                                ComboBox_GetCurSel(pInfo->hwndLbEntries));

                ASSERT(NULL != pContext);

                if(NULL == pContext)
                {
                    return TRUE;
                }

                //
                // Update the phonebook information
                //
                dwErr = DuGetEntry(pInfo, pContext);

                if(ERROR_SUCCESS == dwErr)
                {
                    ComboBox_SetItemData(
                            pInfo->hwndLbEntries,
                            ComboBox_GetCurSel(pInfo->hwndLbEntries),
                            pContext);
                }
                else
                {
                    ComboBox_DeleteString(
                            pInfo->hwndLbEntries,
                            ComboBox_GetCurSel(pInfo->hwndLbEntries) );
                }

                DuUpdateConnectStatus( pInfo );
                return TRUE;
            }
            break;
        }

        case IDCANCEL:
        case CID_DU_PB_Close:
        {
            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }
    }

    return FALSE;
}
    
VOID
DuDialSelectedEntry(
    IN DUINFO* pInfo )

    // Called when user presses the "Dial" button.
    //
{
    DWORD dwErr;
    BOOL fConnected;
    BOOL fAutoLogon;
    TCHAR* pszEbNumber;
    TCHAR* pszEbPreview;
    TCHAR* pszOrgPreview;
    TCHAR* pszOverride;
    TCHAR* pszEntryName;
    RASDIALDLG info;
    INTERNALARGS iargs;
    PBENTRY* pEntry;
    DTLNODE *pdtlnode;
    PBFILE file;
    DUCONTEXT *pContext;

    TRACE( "DuDialSelectedEntry" );

    // Look up the selected entry.
    //
    pContext = (DUCONTEXT *) ComboBox_GetItemDataPtr(
                                pInfo->hwndLbEntries,
                                ComboBox_GetCurSel(pInfo->hwndLbEntries));

    if (!pContext)
    {
        MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
        SetFocus( pInfo->hwndPbNew );
        return;
    }

    pEntry = pContext->pEntry;

    if (!pEntry)
    {
        MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
        SetFocus( pInfo->hwndPbNew );
        return;
    }


    pszOverride = NULL;
    pszOrgPreview = NULL;
    pszEbPreview = NULL;
    pszEbNumber = NULL;

    // Set up API argument block.
    //
    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = pInfo->hwndDlg;

    // The secret hack to share information already loaded with the entry API.
    //
    ZeroMemory( &iargs, sizeof(iargs) );
    iargs.pFile = &pInfo->file;
    iargs.pUser = &pInfo->user;
    iargs.pNoUser = pInfo->pNoUser;
    iargs.fNoUser = pInfo->fNoUser;
    iargs.fForceCloseOnDial =
        (pInfo->pArgs->pApiArgs->dwFlags & RASPBDFLAG_ForceCloseOnDial);

    iargs.pvEapInfo = NULL;

    if(0 != pInfo->pArgs->pApiArgs->reserved2)
    {
        DWORD retcode;
        EAPLOGONINFO *pEapInfo = NULL;

        retcode = DwGetEapLogonInfo(
                    (VOID *) pInfo->pArgs->pApiArgs->reserved2,
                    &pEapInfo);

        if(SUCCESS == retcode)
        {
            iargs.pvEapInfo = (VOID *) pEapInfo;
        }
    }

    iargs.fMoveOwnerOffDesktop =
        (iargs.fForceCloseOnDial || pInfo->user.fCloseOnDial);
    info.reserved = (ULONG_PTR ) &iargs;

    // Call the Win32 API to run the connect status dialog.  Make a copy of
    // the entry name and auto-logon flag first, because RasDialDlg may
    // re-read the entry node to pick up RASAPI changes.
    //
    pszEntryName = StrDup( pEntry->pszEntryName );
    fAutoLogon = pEntry->fAutoLogon;

    TRACEW1( "RasDialDlg,o=\"%s\"", (pszOverride) ? pszOverride : TEXT("") );

    //For whistler bug 426268       gangz
    //
    fConnected = RasDialDlg(
        pContext->pszPhonebookPath, 
        /*pEntry->pszEntryName*/
        pszEntryName, 
        pszOverride, 
        &info );
    
    TRACE1( "RasDialDlg=%d", fConnected );

    Free0( pszEbPreview );
    Free0( pszOrgPreview );

    if(NULL != iargs.pvEapInfo)
    {
        Free0(iargs.pvEapInfo);
        iargs.pvEapInfo = NULL;
    }

    if (fConnected)
    {
        pInfo->pArgs->fApiResult = TRUE;

        if (pInfo->pArgs->pApiArgs->pCallback)
        {
            RASPBDLGFUNCW pfunc = pInfo->pArgs->pApiArgs->pCallback;

            if (pInfo->pNoUser && iargs.fNoUserChanged && fAutoLogon)
            {
                // Whistler bug 254385 encode password when not being used
                // Need to Decode password before callback function
                // Assumed password was encoded previously by DuInit()
                //
                DecodePassword( pInfo->pNoUser->szPassword );
                TRACE( "Callback(NoUserEdit)" );
                pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
                    RASPBDEVENT_NoUserEdit, NULL, pInfo->pNoUser );
                TRACE( "Callback(NoUserEdit) done" );
                EncodePassword( pInfo->pNoUser->szPassword );
            }

            TRACE( "Callback(DialEntry)" );
            pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
                RASPBDEVENT_DialEntry, pszEntryName, NULL );
            TRACE( "Callback(DialEntry) done" );
        }

        if (pInfo->user.fCloseOnDial
            || (pInfo->pArgs->pApiArgs->dwFlags & RASPBDFLAG_ForceCloseOnDial))
        {
            EndDialog( pInfo->hwndDlg, TRUE );
        }
    }

    else
    {
        DuHandleConnectFailure(pInfo, &info);
    }

    if (pInfo->pNoUser && !pInfo->hThread)
    {
        TRACE( "Taking shortcut to exit" );
        return;
    }

    // Reload the list even if the Dial was cancelled as user may have changed
    // the current PBENTRY with the Properties button on the dialer which
    // commits changes even if user cancels the dial itself.  See bug 363710.
    //
    DuUpdateLbEntries( pInfo, pszEntryName );
    SetFocus( pInfo->hwndLbEntries );

    Free0( pszEntryName );
}


VOID
DuEditSelectedEntry(
    IN DUINFO* pInfo )

    // Called when user selects "Edit entry" from the menu.  'PInfo' is the
    // dialog context.  'PszEntry' is the name of the entry to edit.
    //
{
    BOOL fOk;
    RASENTRYDLG info;
    INTERNALARGS iargs;
    PBENTRY* pEntry;
    LPTSTR pszEntryName;
    DTLNODE *pdtlnode;
    PBFILE file;
    DWORD dwErr;
    DUCONTEXT *pContext;
    INT iSel;

    TRACE( "DuEditSelectedEntry" );

    // Look up the selected entry.
    //
    iSel = ComboBox_GetCurSel( pInfo->hwndLbEntries );
    if (iSel < 0)
    {
        return;
    }

    pContext = (DUCONTEXT * )ComboBox_GetItemDataPtr(
        pInfo->hwndLbEntries, iSel );

    ASSERT(NULL != pContext);

    if(NULL == pContext)
    {
        return;
    }
    
    ASSERT(NULL != pContext->pszPhonebookPath);

    pEntry = pContext->pEntry;

    if (!pEntry)
    {
        MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
        SetFocus( pInfo->hwndPbNew );
        return;
    }

    // Set up API argument block.
    //
    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = pInfo->hwndDlg;

    {
        RECT rect;

        info.dwFlags = RASEDFLAG_PositionDlg;
        GetWindowRect( pInfo->hwndDlg, &rect );
        info.xDlg = rect.left + DXSHEET;
        info.yDlg = rect.top + DYSHEET;
    }

    // The secret hack to share information already loaded with the entry API.
    //
    ZeroMemory( &iargs, sizeof(iargs) );
    iargs.pFile = &pInfo->file;
    iargs.pUser = &pInfo->user;
    iargs.pNoUser = pInfo->pNoUser;
    iargs.fNoUser = pInfo->fNoUser;
    info.reserved = (ULONG_PTR ) &iargs;

    // Call the Win32 API to run the entry property sheet.
    //
    TRACE( "RasEntryDlg" );
    fOk = RasEntryDlg(
              pContext->pszPhonebookPath, pEntry->pszEntryName, &info );
    TRACE1( "RasEntryDlg=%d", fOk );

    if (pInfo->pNoUser && !pInfo->hThread)
    {
        TRACE( "Taking shortcut to exit" );
        return;
    }

    if (fOk)
    {
        TRACEW1( "OK pressed,e=\"%s\"", info.szEntry );

        if (pInfo->pArgs->pApiArgs->pCallback)
        {
            RASPBDLGFUNCW pfunc = pInfo->pArgs->pApiArgs->pCallback;

            TRACE( "Callback(EditEntry)" );
            pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
                RASPBDEVENT_AddEntry, info.szEntry, NULL );
            TRACE( "Callback(EditEntry) done" );
        }

        DuUpdateLbEntries( pInfo, info.szEntry );
        SetFocus( pInfo->hwndLbEntries );
    }
    else
    {
        TRACE( "Cancel pressed or error" );
    }
}

// 
// Helper function called by DuDialSelectedEntry to handle errors
// returned from RasDialDlgW
//
DWORD
DuHandleConnectFailure(
    IN DUINFO* pInfo,
    IN RASDIALDLG* pDialInfo)
{
    TRACE3( 
        "DuHandleConnectFailure: nu=%x, r2=%x, de=%x",
        (pInfo->pNoUser),
        (pInfo->pArgs->pApiArgs->reserved2),
        (pDialInfo->dwError));
        
    // XP: 384968
    //
    // Handle the bad-PIN error from winlogon
    //
    // Normally, the smart card PIN is gotten by calling EAP-TLS's identity
    // api.  This API raises UI and validates the PIN entered.
    //
    // During winlogon, however, the smart card PIN is passed to us from GINA.
    // In this case it is not validated until we call EAP API's.  (actually, 
    // it's until we call the eap identity api with RAS_EAP_FLAG_LOGON.
    // This flag tells EAP not to raise any UI but instead to use the info 
    // passed from GINA)
    //
    // GINA is not able to validate the PIN itself because it does not call any
    // CAPI's directly.  Oh well.
    //
    // If RasDialDlg returns a bad pin error, then we should gracefully fail 
    // back to winlogon.
    //

    if ((pInfo->pNoUser)                        &&  // called by winlogon
        (pInfo->pArgs->pApiArgs->reserved2)     &&  // for smart card
        (RAS_SC_IS_BAD_PIN(pDialInfo->dwError)))    // but pin is bad
    {
        pInfo->pArgs->pApiArgs->dwError = pDialInfo->dwError;
        EndDialog( pInfo->hwndDlg, TRUE );
    }

    return NO_ERROR;
}

VOID
DuHangUpSelectedEntry(
    IN DUINFO* pInfo )

    // Hang up the selected entry after confirming with user.  'Pinfo' is the
    // dialog context block.
    //
{
    DWORD dwErr;
    PBENTRY* pEntry;
    INT iSel;
    INT nResponse;
    MSGARGS msgargs;
    LPTSTR pszEntryName;
    DTLNODE *pdtlnode;
    DUCONTEXT *pContext;

    TRACE( "DuHangUpSelectedEntry" );

    // Look up the selected entry.
    //
    iSel = ComboBox_GetCurSel( pInfo->hwndLbEntries );
    ASSERT( iSel >= 0 );
    pContext = (DUCONTEXT * )ComboBox_GetItemDataPtr( pInfo->hwndLbEntries, iSel );

    ASSERT(NULL != pContext);
    
    if (!pContext)
    {
        MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
        SetFocus( pInfo->hwndPbNew );
        return;
    }
    
    pEntry = pContext->pEntry;
    ASSERT( pEntry );

    if (!pEntry)
    {
        MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
        SetFocus( pInfo->hwndPbNew );
        return;
    }

    ZeroMemory( &msgargs, sizeof(msgargs) );
    msgargs.apszArgs[ 0 ] = pEntry->pszEntryName;
    msgargs.dwFlags = MB_YESNO | MB_ICONEXCLAMATION;
    nResponse = MsgDlg( pInfo->hwndDlg, SID_ConfirmHangUp, &msgargs );

    if (nResponse == IDYES)
    {
        ASSERT( g_pRasHangUp );
        TRACE( "RasHangUp" );
        dwErr = g_pRasHangUp( pInfo->hrasconn );
        TRACE1( "RasHangUp=%d", dwErr );
        if ( dwErr == ERROR_HANGUP_FAILED )
        {
            MsgDlg( pInfo->hwndDlg, SID_CantHangUpRouter, NULL );
        }
    }
}


BOOL
DuInit(
    IN HWND    hwndDlg,
    IN DUARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the phonebook
    // dialog window.  'pArgs' points at caller's arguments as passed to the
    // API (or thunk).
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DWORD dwThreadId;
    DWORD dwReadPbkFlags = 0;
    DUINFO* pInfo;

    TRACE( "DuInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            pArgs->pApiArgs->dwError = ERROR_NOT_ENOUGH_MEMORY;
            EndDialog( hwndDlg, TRUE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->file.hrasfile = -1;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->pArgs = pArgs;
    pInfo->hwndDlg = hwndDlg;

    // Position the dialog per caller's instructions.
    //
    PositionDlg( hwndDlg,
        pArgs->pApiArgs->dwFlags & RASPBDFLAG_PositionDlg,
        pArgs->pApiArgs->xDlg, pArgs->pApiArgs->yDlg );

    // Load RAS DLL entrypoints which starts RASMAN, if necessary.  There must
    // be no API calls that require RASAPI32 or RASMAN prior to this point.
    //
    dwErr = LoadRas( g_hinstDll, hwndDlg );
    if (dwErr != 0)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadRas, dwErr, NULL );
        pArgs->pApiArgs->dwError = dwErr;
        EndDialog( hwndDlg, TRUE );
        return TRUE;
    }


    if(0 != (pArgs->pApiArgs->dwFlags & RASPBDFLAG_NoUser))
    {
        // Popup TAPI's "first location" dialog if they are uninitialized.
        //
        dwErr = TapiNoLocationDlg( g_hinstDll, &pInfo->hlineapp, hwndDlg );
        if (dwErr != 0)
        {
            // Error here is treated as a "cancel" per bug 288385.
            //
            pArgs->pApiArgs->dwError = 0;
            EndDialog( hwndDlg, TRUE );
            return TRUE;
        }
    }

    pInfo->hwndLbEntries = GetDlgItem( hwndDlg, CID_DU_LB_Entries );
    ASSERT( pInfo->hwndLbEntries );
    pInfo->hwndPbDial = GetDlgItem( hwndDlg, CID_DU_PB_Dial );
    ASSERT( pInfo->hwndPbDial );
    pInfo->hwndPbNew = GetDlgItem( hwndDlg, CID_DU_PB_New );
    ASSERT( pInfo->hwndPbNew );
    pInfo->hwndPbProperties = GetDlgItem( hwndDlg, CID_DU_PB_More );
    ASSERT( pInfo->hwndPbProperties );

    pInfo->fNoUser = (pArgs->pApiArgs->dwFlags & RASPBDFLAG_NoUser );

    // Setting this global flag indicates that WinHelp will not work in the
    // current mode.  See common\uiutil\ui.c.  We assume here that only the
    // WinLogon process makes use of this.
    //
    {
        extern BOOL g_fNoWinHelp;
        g_fNoWinHelp = pInfo->fNoUser;
    }

    // Read user preferences from registry.
    //
    dwErr = g_pGetUserPreferences(
        NULL, &pInfo->user, pInfo->fNoUser ? UPM_Logon : UPM_Normal);
    if (dwErr != 0)
    {
        //
        // The following free causes a crash in DuTerm. This context will be
        // freed in DuTerm - raos.
        //
        // Free( pInfo );
        ErrorDlg( hwndDlg, SID_OP_LoadPrefs, dwErr, NULL );
        EndDialog( hwndDlg, TRUE );
        return TRUE;
    }

    // Load and parse phonebook file.
    //
    if (pInfo->fNoUser)
    {
        dwReadPbkFlags |= RPBF_NoUser;
    }
    dwErr = ReadPhonebookFile(
                pArgs->pszPhonebook,
                &pInfo->user,
                NULL,
                dwReadPbkFlags,
                &pInfo->file );
    if (dwErr != 0)
    {
        // The following free causes a crash in DuTerm. This context will be
        // freed in DuTerm - raos.
        //
        // Free( pInfo );
        ErrorDlg( hwndDlg, SID_OP_LoadPhonebook, dwErr, NULL );
        EndDialog( hwndDlg, TRUE );
        return TRUE;
    }

    if (pArgs->pApiArgs->pCallback && !pArgs->pszPhonebook)
    {
        RASPBDLGFUNCW pfunc = pInfo->pArgs->pApiArgs->pCallback;

        // Tell user the path to the default phonebook file.
        //
        TRACE( "Callback(EditGlobals)" );
        pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
            RASPBDEVENT_EditGlobals, pInfo->file.pszPath, NULL );
        TRACE( "Callback(EditGlobals) done" );
    }

    if (pInfo->fNoUser)
    {
        // Retrieve logon information from caller via callback.
        //
        if (pArgs->pApiArgs->pCallback)
        {
            RASPBDLGFUNCW pfunc = pArgs->pApiArgs->pCallback;

            pInfo->pNoUser = Malloc( sizeof(RASNOUSERW) );
            if (pInfo->pNoUser)
            {
                ZeroMemory( pInfo->pNoUser, sizeof(*pInfo->pNoUser) );
                pInfo->pNoUser->dwSize = sizeof(*pInfo->pNoUser);

                TRACE( "Callback(NoUser)" );
                pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
                    RASPBDEVENT_NoUser, NULL, pInfo->pNoUser );
                TRACE1( "Callback(NoUser) done,to=%d",
                    pInfo->pNoUser->dwTimeoutMs );
                TRACEW1( "U=%s",pInfo->pNoUser->szUserName );
                TRACEW1( "D=%s",pInfo->pNoUser->szDomain );

                // Whistler bug 254385 encode password when not being used
                // Assumed password was not encoded during callback
                //
                EncodePassword( pInfo->pNoUser->szPassword );

                // Install input detection hooks.
                //
                if (pInfo->pNoUser->dwTimeoutMs > 0)
                {
                    pInfo->hhookMouse = SetWindowsHookEx(
                        WH_MOUSE, DuInputHook, g_hinstDll,
                        GetCurrentThreadId() );

                    pInfo->hhookKeyboard = SetWindowsHookEx(
                        WH_KEYBOARD, DuInputHook, g_hinstDll,
                        GetCurrentThreadId() );
                }
            }
        }

        if (!pInfo->user.fAllowLogonPhonebookEdits)
        {
            // Disable new button.  See also similar logic for the Properties
            // button occurs in DuUpdateLbEntries.
            //
            EnableWindow( pInfo->hwndPbNew, FALSE );
        }
    }

    // Load the list of phonebook entries and set selection.
    //
    DuUpdateLbEntries( pInfo, pInfo->pArgs->pszEntry );

    if (!pInfo->pArgs->pszEntry)
    {
        if (ComboBox_GetCount( pInfo->hwndLbEntries ) > 0)
        {
            ComboBox_SetCurSelNotify( pInfo->hwndLbEntries, 0 );
        }
    }

    // Update the title to reflect the phonebook mode.
    //
    DuUpdateTitle( pInfo );

    // Adjust the title bar widgets and create the wizard bitmap.
    //
    TweakTitleBar( hwndDlg );
    AddContextHelpButton( hwndDlg );

    // Start the connect monitor.
    //
    if ((pInfo->hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ))
        && (pInfo->hThread = CreateThread(
                NULL, 0, DuMonitorThread, (LPVOID )pInfo, 0,
                (LPDWORD )&dwThreadId )))
    {
        ASSERT( g_pRasConnectionNotification );
        TRACE( "RasConnectionNotification" );
        dwErr = g_pRasConnectionNotification(
            INVALID_HANDLE_VALUE, pInfo->hEvent,
            RASCN_Connection | RASCN_Disconnection );
        TRACE1( "RasConnectionNotification=%d", dwErr );
    }
    else
        TRACE( "Monitor DOA" );

    if (ComboBox_GetCount( pInfo->hwndLbEntries ) == 0)
    {
        // The phonebook is empty.
        //
        if (pInfo->fNoUser
            && !pInfo->user.fAllowLogonPhonebookEdits
            )
        {
            // Tell the user you can't create an entry or locations during
            // startup.
            //
            MsgDlg( hwndDlg, SID_EmptyLogonPb, NULL );
            EndDialog( hwndDlg, TRUE );
            return TRUE;
        }
        else
        {
            if(pInfo->fNoUser)
            {
                dwErr = TapiNoLocationDlg( g_hinstDll, 
                                           &pInfo->hlineapp, hwndDlg );
                if (dwErr != 0)
                {
                    // Error here is treated as a "cancel" per bug 288385.
                    //
                    pArgs->pApiArgs->dwError = 0;
                    EndDialog( hwndDlg, TRUE );
                    return TRUE;
                }
            }
        
            // Tell the user, then automatically start him into adding a new
            // entry.  Set initial focus to "New" button first, in case user
            // cancels out.
            //
            SetFocus( pInfo->hwndPbNew );
            MsgDlg( hwndDlg, SID_EmptyPhonebook, NULL );
            DuNewEntry( pInfo, FALSE );
        }
    }
    else
    {
        // Set initial focus to the non-empty entry listbox.
        //
        SetFocus( pInfo->hwndLbEntries );
    }

    return FALSE;
}


LRESULT CALLBACK
DuInputHook(
    IN int    nCode,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // Standard Win32 'MouseProc' or 'KeyboardProc' callback.  For our simple
    // processing we can take advantage of them having identical arguments and
    // 'nCode' definitions.
    //
{
    if (nCode == HC_ACTION)
    {
        ++g_cInput;
    }
    return 0;
}

VOID
DuNewEntry(
    IN DUINFO* pInfo,
    IN BOOL fClone )

    // Called when user presses the "New" button or "Clone" menu item.
    // 'PInfo' is the dialog context.  'FClone' is set to clone the selected
    // entry, otherwise an empty entry is created.
    //
{
    BOOL fOk;
    TCHAR* pszEntry;
    RASENTRYDLG info;
    INTERNALARGS iargs;
    PBENTRY* pEntry;

    TRACE1( "DuNewEntry(f=%d)", fClone );

    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = pInfo->hwndDlg;

    if (fClone)
    {
        DUCONTEXT *pContext;

        // Look up the selected entry.
        //
        pContext = (DUCONTEXT* )ComboBox_GetItemDataPtr(
            pInfo->hwndLbEntries, ComboBox_GetCurSel( pInfo->hwndLbEntries ) );

        if (!pContext)
        {
            MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
            SetFocus( pInfo->hwndPbNew );
            return;
        }

        pEntry = pContext->pEntry;

        if (!pEntry)
        {
            MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
            SetFocus( pInfo->hwndPbNew );
            return;
        }

        pszEntry = pEntry->pszEntryName;
        info.dwFlags = RASEDFLAG_CloneEntry;
    }
    else
    {
        pszEntry = NULL;
        info.dwFlags = RASEDFLAG_NewEntry;
    }

    {
        RECT rect;

        GetWindowRect( pInfo->hwndDlg, &rect );
        info.dwFlags += RASEDFLAG_PositionDlg;
        info.xDlg = rect.left + DXSHEET;
        info.yDlg = rect.top + DYSHEET;
    }

    // The secret hack to share information already loaded with the entry API.
    //
    ZeroMemory( &iargs, sizeof(iargs) );
    iargs.pFile = &pInfo->file;
    iargs.pUser = &pInfo->user;
    iargs.pNoUser = pInfo->pNoUser;
    iargs.fNoUser = pInfo->fNoUser;
    info.reserved = (ULONG_PTR ) &iargs;

    // Call the Win32 API to run the add entry wizard.
    //
    TRACE( "RasEntryDlg" );
    fOk = RasEntryDlg( pInfo->pArgs->pszPhonebook, pszEntry, &info );
    TRACE1( "RasEntryDlg=%d", fOk );

    if (pInfo->pNoUser && !pInfo->hThread)
    {
        TRACE( "Taking shortcut to exit" );
        return;
    }

    if (fOk)
    {
        TRACEW1( "OK pressed, e=\"%s\"", info.szEntry );

        if (pInfo->pArgs->pApiArgs->pCallback)
        {
            RASPBDLGFUNCW pfunc = pInfo->pArgs->pApiArgs->pCallback;

            TRACE( "Callback(AddEntry)" );
            pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
                RASPBDEVENT_AddEntry, info.szEntry, NULL );
            TRACE( "Callback(AddEntry) done" );
        }

        DuUpdateLbEntries( pInfo, info.szEntry );
        Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbDial );
        SetFocus( pInfo->hwndLbEntries );
    }
    else
    {
        TRACE( "Cancel pressed or error" );
    }
}

VOID
DuUpdateConnectStatus(
    IN DUINFO* pInfo )

    // Called to update connect status of the selected entry and the text of
    // the Dial/HangUp button.  'PInfo' is the dialog context block.
    //
{
    TCHAR* pszPhonebook;
    TCHAR* pszEntry;
    INT iSel;
    TCHAR* psz;
    DUCONTEXT *pContext;

    TRACE( "DuUpdateConnectStatus" );

    // pszPhonebook = pInfo->file.pszPath;
    iSel = ComboBox_GetCurSel( pInfo->hwndLbEntries );
    if (iSel < 0)
    {
        return;
    }

    pContext = (DUCONTEXT *) ComboBox_GetItemDataPtr(
                                pInfo->hwndLbEntries,
                                iSel);

    ASSERT(NULL != pContext);

    pszEntry = ComboBox_GetPsz( pInfo->hwndLbEntries, iSel );
    pInfo->hrasconn = HrasconnFromEntry(
                                    pContext->pszPhonebookPath,
                                    pszEntry );

    psz = PszFromId( g_hinstDll,
              (pInfo->hrasconn) ? SID_DU_HangUp : SID_DU_Dial );
    if (psz)
    {
        SetWindowText( pInfo->hwndPbDial, psz );
        Free( psz );
    }
}


VOID
DuUpdateLbEntries(
    IN DUINFO* pInfo,
    IN TCHAR* pszEntry )

    // Update the contents of the entry listbox and set the selection to
    // 'pszEntry'.  If there are entries the Properties button is enabled,
    // otherwise it is disabled.  'PInfo' is the dialog context.
    //
{
    DTLNODE* pNode;
    RASENTRYNAME *pRasEntryNames = NULL;
    DWORD cEntries = 0;
    DWORD cb;
    DWORD dwErr;
    DWORD i;
    RASENTRYNAME ren;
    DUCONTEXT *pContext;
    INT iSel;

    TRACE( "DuUpdateLbEntries" );

    iSel = -1;
    ComboBox_ResetContent( pInfo->hwndLbEntries );

    cb = ren.dwSize = sizeof(RASENTRYNAME);

    //
    // Enumerate entries across all phonebooks. Fix for bug 206467
    //
    dwErr = g_pRasEnumEntries(NULL,
                              pInfo->pArgs->pszPhonebook,
                              &ren,
                              &cb,
                              &cEntries);

    if(     (   (ERROR_BUFFER_TOO_SMALL == dwErr)
            ||  (SUCCESS == dwErr))
        &&  (cb >= sizeof(RASENTRYNAME)))
    {
        pRasEntryNames = (RASENTRYNAME *) Malloc(cb);

        if(NULL == pRasEntryNames)
        {
            // Nothing else can be done in this case
            //
            goto done;
        }

        pRasEntryNames->dwSize = sizeof(RASENTRYNAME);

        dwErr = g_pRasEnumEntries(NULL,
                                  pInfo->pArgs->pszPhonebook,
                                  pRasEntryNames,
                                  &cb,
                                  &cEntries);

        if(dwErr)
        {
            goto done;
        }
    }
    else
    {
        goto done;
    }


    for(i = 0; i < cEntries; i++)
    {
        pContext = (DUCONTEXT *) Malloc(sizeof(DUCONTEXT));

        if(NULL == pContext)
        {
            dwErr = GetLastError();
            goto done;
        }

        ZeroMemory(pContext, sizeof(DUCONTEXT));

        pContext->pszPhonebookPath = 
                            StrDup(
                                pRasEntryNames[i].szPhonebookPath
                                );
                                
        ComboBox_AddItem(pInfo->hwndLbEntries,
                         pRasEntryNames[i].szEntryName,
                         pContext);


    }

    if (ComboBox_GetCount( pInfo->hwndLbEntries ) >= 0)
    {
        if (pszEntry)
        {
            // Select entry specified by API caller.
            //
            iSel = ComboBox_FindStringExact(
                pInfo->hwndLbEntries, -1, pszEntry );
        }

        if (iSel < 0)
        {
            // Entry not found so default to first item selected.
            //
            iSel = 0;
        }

        if(ComboBox_GetCount(pInfo->hwndLbEntries) > 0)
        {
            ComboBox_SetCurSelNotify( pInfo->hwndLbEntries, iSel );
        }
    }

done:

    // Enable/disable Properties button based on existence of an entry.  See
    // bug 313037.
    //
    if (ComboBox_GetCurSel( pInfo->hwndLbEntries ) >= 0
        && (!pInfo->fNoUser || pInfo->user.fAllowLogonPhonebookEdits))
    {
        EnableWindow( pInfo->hwndPbProperties, TRUE );
    }
    else
    {
        if (GetFocus() == pInfo->hwndPbProperties)
        {
            SetFocus( pInfo->hwndPbDial );
        }

        EnableWindow( pInfo->hwndPbProperties, FALSE );
    }

    ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbEntries );
    Free0(pRasEntryNames);
}

VOID
DuUpdateTitle(
    IN DUINFO* pInfo )

    // Called to update the dialog title to reflect the current phonebook.
    // 'PInfo' is the dialog context.
    //
{
    TCHAR szBuf[ 256 ];
    TCHAR* psz;

    // For whistler 117934, initialize the buffer
    //
    ZeroMemory( szBuf, 256 * sizeof(TCHAR) );
    psz = PszFromId( g_hinstDll, SID_PopupTitle );
    if (psz)
    {
        lstrcpyn( szBuf, psz, sizeof(szBuf) / sizeof(TCHAR) );
        Free( psz );
    }
    else
    {
        *szBuf = TEXT('0');
    }

    if (pInfo->pArgs->pszPhonebook
        || pInfo->user.dwPhonebookMode != PBM_System)
    {
        INT iSel;

        iSel = ComboBox_GetCurSel(pInfo->hwndLbEntries);
        if (iSel >= 0)
        {
            DUCONTEXT *pContext;

            pContext = (DUCONTEXT *) ComboBox_GetItemDataPtr(
                pInfo->hwndLbEntries, iSel);

            ASSERT( pContext );

            if(NULL != pContext)
            {
                lstrcat( szBuf, TEXT(" - ") );
                lstrcat( szBuf, StripPath( pContext->pszPhonebookPath ) );
            }
        }
    }

    SetWindowText( pInfo->hwndDlg, szBuf );
}


VOID
DuTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    DUINFO* pInfo;

    DWORD i;
    DWORD cEntries;

    TRACE( "DuTerm" );

    pInfo = (DUINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        // Close ReceiveMonitorThread resources.
        //
        if (pInfo->hThread)
        {
            TRACE( "Set abort event" );

            // Tell thread to wake up and quit...
            //
            pInfo->fAbortMonitor = TRUE;
            CloseHandle( pInfo->hThread );

            // Don't SetEvent before closing the thread handle.  On
            // multi-proc systems, the thread will exit so fast (and
            // set hThread to NULL) that CloseHandle will then close
            // an invalid handle.
            //
            SetEvent( pInfo->hEvent );

            // ...and wait for that to happen.  A message API (such as
            // PeekMessage) must be called to prevent the thread-to-thread
            // SendMessage in the thread from blocking.
            //
            {
                MSG msg;

                TRACE( "Termination spin..." );
                for (;;)
                {
                    PeekMessage( &msg, hwndDlg, 0, 0, PM_NOREMOVE );
                    if (!pInfo->hThread)
                    {
                        break;
                    }
                    Sleep( 500L );
                }
                TRACE( "Termination spin ends" );
            }
        }

        if (pInfo->hEvent)
        {
            CloseHandle( pInfo->hEvent );
        }

        if (pInfo->pNoUser)
        {
            // Don't leave caller's password floating around in memory.
            //
            RtlSecureZeroMemory( pInfo->pNoUser->szPassword, PWLEN * sizeof(TCHAR) );
            Free( pInfo->pNoUser );

            // Uninstall input event hooks.
            //
            if (pInfo->hhookMouse)
            {
                UnhookWindowsHookEx( pInfo->hhookMouse );
            }
            if (pInfo->hhookKeyboard)
            {
                UnhookWindowsHookEx( pInfo->hhookKeyboard );
            }
        }
        else if ((pInfo->pArgs->pApiArgs->dwFlags & RASPBDFLAG_UpdateDefaults)
                 && pInfo->hwndLbEntries && pInfo->user.fInitialized)
        {
            INT iSel;
            RECT rect;

            // Caller said to update default settings so save the name of the
            // selected entry and the current window position.
            //
            iSel = ComboBox_GetCurSel( pInfo->hwndLbEntries );
            if (iSel >= 0)
            {
                DUCONTEXT *pContext;
                PBENTRY* pEntry;

                pContext = (DUCONTEXT* )ComboBox_GetItemDataPtr(
                    pInfo->hwndLbEntries, iSel );

                if(     (NULL != pContext)
                    &&  (NULL != (pEntry = pContext->pEntry)))
                {
                    Free0( pInfo->user.pszDefaultEntry );
                    pInfo->user.pszDefaultEntry =
                        StrDup( pEntry->pszEntryName );
                }
            }

            if (!SetOffDesktop( pInfo->hwndDlg, SOD_GetOrgRect, &rect ))
            {
                GetWindowRect( pInfo->hwndDlg, &rect );
            }
            pInfo->user.dwXPhonebook = rect.left;
            pInfo->user.dwYPhonebook = rect.top;

            pInfo->user.fDirty = TRUE;
            g_pSetUserPreferences(
                NULL, &pInfo->user, pInfo->fNoUser ? UPM_Logon : UPM_Normal );
        }

        if(NULL != pInfo->hwndLbEntries)
        {
            DUCONTEXT *pContext;

            cEntries = ComboBox_GetCount(pInfo->hwndLbEntries);

            //
            // Free the context stored in the list box
            //
            for(i = 0; i < cEntries; i++)
            {
                pContext = ComboBox_GetItemDataPtr(
                                pInfo->hwndLbEntries, i);

                if(NULL != pContext)
                {
                    Free0(pContext->pszPhonebookPath);
                }

                Free0(pContext);
            }
        }

        TapiShutdown( pInfo->hlineapp );
        ClosePhonebookFile( &pInfo->file );
        DestroyUserPreferences( &pInfo->user );
        Free( pInfo );
    }
}

DWORD
DuMonitorThread(
    LPVOID pThreadArg )

    // The "main" of the "connect monitor" thread.  This thread simply
    // converts Win32 RasConnectionNotification events int WM_RASEVENT style
    // notfications.
    //
{
    DUINFO* pInfo;
    DWORD dwErr;
    DWORD dwTimeoutMs;
    DWORD dwQuitTick;
    DWORD cInput = 0;

    TRACE( "DuMonitor starting" );

    pInfo = (DUINFO* )pThreadArg;

    if (pInfo->pNoUser && pInfo->pNoUser->dwTimeoutMs != 0)
    {
        TRACE( "DuMonitor quit timer set" );
        dwTimeoutMs = 5000L;
        dwQuitTick = GetTickCount() + pInfo->pNoUser->dwTimeoutMs;
        cInput = g_cInput;
    }
    else
    {
        dwTimeoutMs = INFINITE;
        dwQuitTick = 0;
    }

    // Trigger the event so the other thread has the correct state as of the
    // monitor starting.
    //
    SetEvent( pInfo->hEvent );

    for (;;)
    {
        dwErr = WaitForSingleObject( pInfo->hEvent, dwTimeoutMs );

        if (pInfo->fAbortMonitor)
        {
            break;
        }

        if (dwErr == WAIT_TIMEOUT)
        {
            if (g_cInput > cInput)
            {
                TRACE( "Input restarts timer" );
                cInput = g_cInput;
                dwQuitTick = GetTickCount() + pInfo->pNoUser->dwTimeoutMs;
            }
            else if (GetTickCount() >= dwQuitTick)
            {
                TRACE( "/DuMonitor SendMessage(WM_NOUSERTIMEOUT)" );
                SendMessage( pInfo->hwndDlg, WM_NOUSERTIMEOUT, 0, 0 );
                TRACE( "\\DuMonitor SendMessage(WM_NOUSERTIMEOUT) done" );
                break;
            }
        }
        else
        {
            TRACE( "/DuMonitor SendMessage(WM_RASEVENT)" );
            SendMessage( pInfo->hwndDlg, WM_RASEVENT, 0, 0 );
            TRACE( "\\DuMonitor SendMessage(WM_RASEVENT) done" );
        }
    }

    // This clues the other thread that all interesting work has been done.
    //
    pInfo->hThread = NULL;

    TRACE( "DuMonitor terminating" );
    return 0;
}


DWORD
DuGetEntry(
    DUINFO* pInfo,
    DUCONTEXT* pContext )
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwReadPbkFlags = 0;
    LPTSTR pszEntryName;
    DTLNODE *pdtlnode;
    PBFILE file;

    ASSERT(NULL != pContext);

    pContext->pEntry = NULL;

    pszEntryName = ComboBox_GetPsz(pInfo->hwndLbEntries,
                                   ComboBox_GetCurSel(pInfo->hwndLbEntries));

    if (pInfo->fNoUser)
    {
        dwReadPbkFlags |= RPBF_NoUser;
    }

    if(     (NULL != pInfo->file.pszPath)
        &&  (0 == lstrcmpi(pContext->pszPhonebookPath,
                     pInfo->file.pszPath)))
    {
        //
        // We already have the phonebook file open
        //
        pdtlnode = EntryNodeFromName(
                        pInfo->file.pdtllistEntries,
                        pszEntryName);

        ASSERT(NULL != pdtlnode);
    }
    else
    {
        //
        // phonebook file changed. So close the existing phone
        // book file and open the one in  which the entry
        // belongs
        //
        if(NULL != pInfo->file.pszPath)
        {
            ClosePhonebookFile(&pInfo->file);
        }

        dwErr = GetPbkAndEntryName(pContext->pszPhonebookPath,
                                   pszEntryName,
                                   dwReadPbkFlags,
                                   &file,
                                   &pdtlnode);

        if(dwErr)
        {
            goto done;
        }

        ASSERT(NULL != pdtlnode);

        CopyMemory(&pInfo->file, &file, sizeof(PBFILE));
    }

    if (pdtlnode)
    {
        pContext->pEntry = (PBENTRY *) DtlGetData(pdtlnode);
    }
    else
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
    }

done:
    return dwErr;
}


DWORD
DwGetEapLogonInfo(
    VOID *pv,
    EAPLOGONINFO **ppEapLogonInfo )
{
    EAPLOGONINFO *pEapLogonInfo = NULL;

    DWORD retcode = SUCCESS;

    struct EAPINFO
    {
        DWORD dwSizeofEapInfo;
        PBYTE pbEapInfo;
        DWORD dwSizeofPINInfo;
        PBYTE pbPINInfo;
    };

    struct EAPINFO *pEapInfo = (struct EAPINFO *) pv;

    DWORD dwSize;

    if(NULL == pv)
    {
        retcode = E_INVALIDARG;
        goto done;
    }

    dwSize = sizeof(EAPLOGONINFO)
           + pEapInfo->dwSizeofEapInfo
           + pEapInfo->dwSizeofPINInfo;

    pEapLogonInfo = (EAPLOGONINFO *) Malloc(dwSize);

    if(NULL == pEapLogonInfo)
    {

        retcode = GetLastError();

        TRACE1("Failed to Allocate EapLogonInfo. rc=0x%x",
                 retcode);
        goto done;
    }

    ZeroMemory(pEapLogonInfo, dwSize);

    //
    // Set up the fields in pEapLogonInfo by
    // flattening out the information passed
    // in.
    //
    pEapLogonInfo->dwSize = dwSize;

    pEapLogonInfo->dwLogonInfoSize =
        pEapInfo->dwSizeofEapInfo;

    pEapLogonInfo->dwOffsetLogonInfo =
        FIELD_OFFSET(EAPLOGONINFO, abdata);

    memcpy( pEapLogonInfo->abdata,
            pEapInfo->pbEapInfo,
            pEapInfo->dwSizeofEapInfo);

    pEapLogonInfo->dwPINInfoSize =
        pEapInfo->dwSizeofPINInfo;

    pEapLogonInfo->dwOffsetPINInfo =
        FIELD_OFFSET(EAPLOGONINFO, abdata)
        + pEapInfo->dwSizeofEapInfo;

    memcpy(    (PBYTE)
               ((PBYTE) pEapLogonInfo
             + pEapLogonInfo->dwOffsetPINInfo),

            pEapInfo->pbPINInfo,

            pEapInfo->dwSizeofPINInfo);

done:
    *ppEapLogonInfo = pEapLogonInfo;

    return retcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\mlink.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// mlink.c
// Remote Access Common Dialog APIs
// Multi-link configuration dialogs
//
// 01/23/96 Steve Cobb


#include "rasdlgp.h"


//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwDmHelp[] =
{
    CID_DM_ST_Explain,       HID_DM_ST_Explain,
    CID_DM_ST_Dial,          HID_DM_LB_DialPercent,
    CID_DM_LB_DialPercent,   HID_DM_LB_DialPercent,
    CID_DM_ST_DialOrMore,    HID_DM_LB_DialTime,
    CID_DM_LB_DialTime,      HID_DM_LB_DialTime,
    CID_DM_ST_HangUp,        HID_DM_LB_HangUpPercent,
    CID_DM_LB_HangUpPercent, HID_DM_LB_HangUpPercent,
    CID_DM_ST_HangUpOrLess,  HID_DM_LB_HangUpTime,
    CID_DM_LB_HangUpTime,    HID_DM_LB_HangUpTime,
    0, 0
};


//-----------------------------------------------------------------------------
// Local datatypes
//-----------------------------------------------------------------------------

// Multi-link dialing dialog context block.
//
typedef struct
_DMINFO
{
    // Stub API argument.
    //
    PBENTRY* pEntry;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndLbDialPercents;
    HWND hwndLbDialTimes;
    HWND hwndLbHangUpPercents;
    HWND hwndLbHangUpTimes;
}
DMINFO;


//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

BOOL
DmCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
DmDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DmInit(
    IN HWND hwndDlg,
    IN PBENTRY* pEntry );

VOID
DmSave(
    IN DMINFO* pInfo );

VOID
DmTerm(
    IN HWND hwndDlg );


//----------------------------------------------------------------------------
// Multi-link dialing dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
MultiLinkDialingDlg(
    IN HWND hwndOwner,
    OUT PBENTRY* pEntry )

    // Popup the Multi-link dialing dialog.  'HwndOwner' is the owner of the
    // dialog.  'PEntry' is a phonebook entry to edit.
    //
    // Returns true if user pressed OK and succeeded, false if user pressed
    // Cancel or encountered an error.
{
    INT_PTR nStatus;

    TRACE( "MultiLinkConfigureDlg" );

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DM_DialingMultipleLines ),
            hwndOwner,
            DmDlgProc,
            (LPARAM )pEntry );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
DmDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Multi-Link dialing dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DmDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
            (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DmInit( hwnd, (PBENTRY* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDmHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return DmCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            DmTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
DmCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "DmCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            DMINFO* pInfo;

            pInfo = (DMINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );
            DmSave( pInfo );
            EndDialog( hwnd, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
DmInit(
    IN HWND hwndDlg,
    IN PBENTRY* pEntry )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PEntry' is the caller's stub API argument.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DMINFO* pInfo;

    TRACE( "DmInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pEntry = pEntry;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndLbDialPercents = GetDlgItem( hwndDlg, CID_DM_LB_DialPercent );
    ASSERT( pInfo->hwndLbDialPercents );
    pInfo->hwndLbDialTimes = GetDlgItem( hwndDlg, CID_DM_LB_DialTime );
    ASSERT( pInfo->hwndLbDialTimes );
    pInfo->hwndLbHangUpPercents = GetDlgItem( hwndDlg, CID_DM_LB_HangUpPercent );
    ASSERT( pInfo->hwndLbHangUpPercents );
    pInfo->hwndLbHangUpTimes = GetDlgItem( hwndDlg, CID_DM_LB_HangUpTime );
    ASSERT( pInfo->hwndLbHangUpTimes );

    // Initialize the drop lists contents and selections.
    //
    {
        INT i;
        INT iSel;
        DWORD* pdwPercent;
        LBTABLEITEM* pItem;

        static LBTABLEITEM aTimes[] =
        {
            SID_Time3s,  3,
            SID_Time5s,  5,
            SID_Time10s, 10,
            SID_Time30s, 30,
            SID_Time1m,  60,
            SID_Time2m,  120,
            SID_Time5m,  300,
            SID_Time10m, 600,
            SID_Time30m, 1800,
            SID_Time1h,  3600,
            0, 0
        };

        static DWORD aDialPercents[] =
        {
            1, 5, 10, 25, 50, 75, 90, 95, 100, 0xFFFFFFFF
        };

        static DWORD aHangUpPercents[] =
        {
            0, 5, 10, 25, 50, 75, 90, 95, 99, 0xFFFFFFFF
        };

        // Initialize the Dial Percents list and set the selection.
        //
        iSel = -1;
        for (pdwPercent = aDialPercents, i = 0;
             *pdwPercent != 0xFFFFFFFF;
             ++pdwPercent, ++i)
        {
            TCHAR achPercent[ 12 ];

            wsprintf( achPercent, TEXT("%d%%"), *pdwPercent );
            ComboBox_AddItem( pInfo->hwndLbDialPercents, achPercent,
                (VOID* )UlongToPtr(*pdwPercent));

            if (iSel < 0 && pEntry->dwDialPercent <= *pdwPercent)
            {
                iSel = i;
                ComboBox_SetCurSel( pInfo->hwndLbDialPercents, iSel );
            }
        }

        if (iSel < 0)
        {
            ComboBox_SetCurSel( pInfo->hwndLbDialPercents, i - 1 );
        }

        // Initialize the Hang Up Percents list and set the selection.
        //
        iSel = -1;
        for (pdwPercent = aHangUpPercents, i = 0;
             *pdwPercent != 0xFFFFFFFF;
             ++pdwPercent, ++i)
        {
            TCHAR achPercent[ 12 ];

            wsprintf( achPercent, TEXT("%d%%"), *pdwPercent );
            ComboBox_AddItem( pInfo->hwndLbHangUpPercents, achPercent,
                (VOID* )UlongToPtr(*pdwPercent));

            if (iSel < 0 && pEntry->dwHangUpPercent <= *pdwPercent)
            {
                iSel = i;
                ComboBox_SetCurSel( pInfo->hwndLbHangUpPercents, iSel );
            }
        }

        if (iSel < 0)
        {
            ComboBox_SetCurSel( pInfo->hwndLbHangUpPercents, i - 1 );
        }

        // Initialize the Dial times list.
        //
        iSel = -1;
        for (pItem = aTimes, i = 0;
             pItem->sidItem;
             ++pItem, ++i )
        {
            ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbDialTimes,
                pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

            if (iSel < 0 && pEntry->dwDialSeconds <= pItem->dwData)
            {
                iSel = i;
                ComboBox_SetCurSel( pInfo->hwndLbDialTimes, iSel );
            }
        }

        if (iSel < 0)
        {
            ComboBox_SetCurSel( pInfo->hwndLbDialTimes, i - 1 );
        }

        // Initialize the Hang Up times list.
        //
        iSel = -1;
        for (pItem = aTimes, i = 0;
             pItem->sidItem;
             ++pItem, ++i )
        {
            ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbHangUpTimes,
                pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

            if (iSel < 0 && pEntry->dwHangUpSeconds <= pItem->dwData)
            {
                iSel = i;
                ComboBox_SetCurSel( pInfo->hwndLbHangUpTimes, iSel );
            }
        }

        if (iSel < 0)
        {
            ComboBox_SetCurSel( pInfo->hwndLbDialTimes, i - 1 );
        }
    }

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.  Dlgedit.exe doesn't currently
    // support this at resource edit time.  When that's fixed set
    // DS_CONTEXTHELP there and remove this call.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
DmSave(
    IN DMINFO* pInfo )

    // Save the current dialog state in the stub API entry buffer.  'PInfo' is
    // the dialog context.
    //
{
    INT iSel;

    TRACE( "DmSave" );

    iSel = ComboBox_GetCurSel( pInfo->hwndLbDialPercents );
    ASSERT( iSel >= 0 );
    pInfo->pEntry->dwDialPercent =
        PtrToUlong( ComboBox_GetItemDataPtr( pInfo->hwndLbDialPercents, iSel ) );

    iSel = ComboBox_GetCurSel( pInfo->hwndLbDialTimes );
    ASSERT( iSel >= 0 );
    pInfo->pEntry->dwDialSeconds =
        PtrToUlong( ComboBox_GetItemDataPtr( pInfo->hwndLbDialTimes, iSel ) );

    iSel = ComboBox_GetCurSel( pInfo->hwndLbHangUpPercents );
    ASSERT( iSel >= 0 );
    pInfo->pEntry->dwHangUpPercent =
        PtrToUlong( ComboBox_GetItemDataPtr( pInfo->hwndLbHangUpPercents, iSel ) );

    iSel = ComboBox_GetCurSel( pInfo->hwndLbHangUpTimes );
    ASSERT( iSel >= 0 );
    pInfo->pEntry->dwHangUpSeconds =
        PtrToUlong( ComboBox_GetItemDataPtr( pInfo->hwndLbHangUpTimes, iSel ) );

    pInfo->pEntry->fDirty = TRUE;
}


VOID
DmTerm(
    IN HWND hwndDlg )

    /* Dialog termination.  Releases the context block.  'HwndDlg' is the
    ** handle of a dialog.
    */
{
    DMINFO* pInfo;

    TRACE( "DmTerm" );

    pInfo = (DMINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE( "Context freed" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\pref.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pref.c
** Remote Access Common Dialog APIs
** User Preferences property sheet
**
** 08/22/95 Steve Cobb
*/

#include "rasdlgp.h"
#include "pref.h"

/* Page definitions.
*/
#define UP_AdPage    0
#define UP_CbPage    1
#define UP_DgPage    2
//#define UP_GpPage    2
//#define UP_PlPage    3

// For whistler 460931  gangz
// 
#define UP_PageCount 3  //2


/*----------------------------------------------------------------------------
** Help maps
**----------------------------------------------------------------------------
*/

static DWORD g_adwAdHelp[] =
{
    CID_AD_ST_Enable,              HID_AD_LV_Enable,
    CID_AD_LV_Enable,              HID_AD_LV_Enable,
    CID_AD_CB_AskBeforeAutodial,   HID_AD_CB_AskBeforeAutodial,
    CID_AD_CB_AskBeforeAutodial,   HID_AD_CB_AskBeforeAutodial,
    CID_AD_CB_DisableThisSession,  HID_AD_CB_DisableThisSession,
    0, 0
};

static DWORD g_adwCbHelp[] =
{
    CID_CB_RB_No,      HID_CB_RB_No,
    CID_CB_RB_Maybe,   HID_CB_RB_Maybe,
    CID_CB_RB_Yes,     HID_CB_RB_Yes,
    CID_CB_LV_Numbers, HID_CB_LV_Numbers,
    CID_CB_PB_Edit,    HID_CB_PB_Edit,
    CID_CB_PB_Delete,  HID_CB_PB_Delete,
    0, 0
};

static DWORD g_adwCoHelp[] =
{
    CID_CO_GB_LogonPrivileges,             HID_CO_GB_LogonPrivileges,
    CID_CO_ST_AllowConnectionModification, HID_CO_CB_AllowConnectionModification,
    CID_CO_CB_AllowConnectionModification, HID_CO_CB_AllowConnectionModification,
    0, 0
};

static DWORD g_adwPlHelp[] =
{
    CID_PL_ST_Open,          HID_PL_ST_Open,
    CID_PL_RB_SystemList,    HID_PL_RB_SystemList,
    CID_PL_RB_PersonalList,  HID_PL_RB_PersonalList,
    CID_PL_RB_AlternateList, HID_PL_RB_AlternateList,
    CID_PL_CL_Lists,         HID_PL_CL_Lists,
    CID_PL_PB_Browse,        HID_PL_PB_Browse,
    0, 0
};


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
AdApply(
    IN UPINFO* pInfo );

INT_PTR CALLBACK
AdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
AdFillLvEnable(
    IN UPINFO* pInfo );

BOOL
AdInit(
    IN     HWND    hwndPage,
    IN OUT UPARGS* pArgs );

LVXDRAWINFO*
AdLvEnableCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

VOID
CbApply(
    IN UPINFO* pInfo );

void DgApply(
    IN UPINFO* pInfo );

BOOL
CbCommand(
    IN UPINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
CbDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CbInit(
    IN HWND hwndPage );

VOID
CbUpdateLvAndPbState(
    IN UPINFO* pInfo );

BOOL
CoApply(
    IN UPINFO* pInfo );

INT_PTR CALLBACK
CoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CoInit(
    IN     HWND    hwndPage,
    IN OUT UPARGS* pArgs );

VOID
GpApply(
    IN UPINFO* pInfo );

BOOL
GpCommand(
    IN UPINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
GpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
GpInit(
    IN HWND hwndPage );

VOID
GpUpdateCbStates(
    IN UPINFO* pInfo );

BOOL
PlApply(
    IN UPINFO* pInfo );

VOID
PlBrowse(
    IN UPINFO* pInfo );

BOOL
PlCommand(
    IN UPINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
PlDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
PlInit(
    IN HWND hwndPage );

BOOL
UpApply(
    IN HWND hwndPage );

VOID
UpCancel(
    IN HWND hwndPage );

VOID
UpExit(
    IN UPINFO* pInfo );


UPINFO*
UpInit(
    IN HWND    hwndFirstPage,
    IN UPARGS* pArgs );

VOID
UpTerm(
    IN HWND hwndPage );

// Allows the editing of ras user preferences
DWORD
APIENTRY
RasUserPrefsDlgInternal (
    HWND hwndParent,
    DWORD dwFlags);


// For whistler 460931
BOOL CALLBACK PrefDisableAllChildWindows(
  IN    HWND hwnd,      // handle to child window
  IN    LPARAM lParam )
{
    BOOL fEnable = (BOOL)lParam;

    EnableWindow( hwnd, fEnable);

    return TRUE;
}

/*----------------------------------------------------------------------------
** User Preferences property sheet entry point
**----------------------------------------------------------------------------
*/

BOOL
UserPreferencesDlg(
    IN  HLINEAPP hlineapp,
    IN  HWND     hwndOwner,
    IN  DWORD    dwFlags,
    OUT PBUSER*  pUser,
    OUT PBFILE** ppFile )

    /* Pops up the User Preferences property sheet, reading and storing the
    ** result in the USER registry.  'HwndOwner' is the handle of the owning
    ** window.  'Hlineapp' is an open TAPI session handle or NULL if none.
    ** 'Puser' is caller's buffer to receive the
    ** result.  'PpFile' is address of caller's file block which is filled in,
    ** if user chooses to open a new phonebook file, with the information
    ** about the newly open file.  It is caller's responsibility to
    ** ClosePhonebookFile and Free the returned block.
    **
    ** Returns true if user pressed OK and settings were saved successfully,
    ** or false if user pressed Cancel or an error occurred.  The routine
    ** handles the display of an appropriate error popup.
    */
{
    PROPSHEETHEADER header;
    PROPSHEETPAGE*  apage;
    PROPSHEETPAGE*  ppage;
    TCHAR*          pszTitle;
    UPARGS          args;
    BOOL            bIsAdmin;
    DWORD           dwPageCount, i;
    INT nStartPage, nEndPage, nTotalPage;   // For whistler 460931

    TRACE("UpPropertySheet");

    // If the user doesn't have administrative priveleges, then
    // we don't allow the Connections tab to show.
    ZeroMemory(&args, sizeof(args));
    args.fIsUserAdmin = FIsUserAdminOrPowerUser();
    dwPageCount = UP_PageCount;

    // Initialize the array of pages
    apage = Malloc (dwPageCount * sizeof (PROPSHEETPAGE));
    if (!apage)
        return FALSE;

    /* Initialize OUT parameter and property sheet argument block.
    */
    ZeroMemory( pUser, sizeof(*pUser) );
    args.pUser = pUser;
    args.ppFile = ppFile;
    args.hlineapp = hlineapp;
    args.fResult = FALSE;
    args.dwFlags = dwFlags;

    if (ppFile)
        *ppFile = NULL;

    ZeroMemory( apage, dwPageCount * sizeof (PROPSHEETPAGE) );
    i = 0;

    // Add the autodial page
    ppage = &apage[ i ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_AD_AutoDial );
    ppage->pfnDlgProc = AdDlgProc;
    ppage->lParam = (LPARAM )&args;
    i++;

    ppage = &apage[ i ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_CB_CallbackSettings );
    ppage->pfnDlgProc = CbDlgProc;
    i++;

    // For whistler 460931      gangz
    // Diagnostic page.
    //
    ppage = &apage[ UP_DgPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_DG_Diagnostics);
    ppage->pfnDlgProc = DgDlgProc;

    if ( dwFlags & UP_F_ShowOnlyDiagnostic)
    {
        ppage->lParam = (LPARAM)&args;
    }
    else
    {
        ppage->lParam = (LPARAM) NULL;
    }

    // For whistler 460931
    // Set showing pages
    //
    if( dwFlags & UP_F_ShowOnlyDiagnostic )
    {
        nStartPage = 0; 
        nEndPage = dwPageCount - 1;
        
//        nStartPage = UP_DgPage;
//        nEndPage = UP_DgPage;
    }
    else
    {
        nStartPage = 0; 
        nEndPage = dwPageCount - 1;
    }
    nTotalPage = nEndPage - nStartPage + 1;

    pszTitle = PszFromId(g_hinstDll, SID_UpTitle);

    ZeroMemory( &header, sizeof(header) );

    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_PROPSHEETPAGE + PSH_NOAPPLYNOW;
    header.hwndParent = hwndOwner;
    header.hInstance = g_hinstDll;
    header.pszCaption = (pszTitle) ? pszTitle : TEXT("");
    header.nPages = nTotalPage;
    header.ppsp = &apage[nStartPage];


    if (PropertySheet( &header ) == -1)
    {
        TRACE("PropertySheet failed");
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
    }

    Free0( pszTitle );

    return args.fResult;
}

// Allows the editing of ras user preferences
DWORD
APIENTRY
RasUserPrefDiagOnly (
    HWND hwndParent,
    BOOL * pbCommit)
{
    PBFILE * pPbFile = NULL;
    PBUSER pbuser;
    DWORD dwErr;

    if( NULL == pbCommit )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // Load ras if neccessary
    dwErr = LoadRas( g_hinstDll, hwndParent );
    if (dwErr != 0)
    {
        ErrorDlg( hwndParent, SID_OP_LoadRas, dwErr, NULL );
        return dwErr;
    }

    // Launch the user preferences dialog
    *pbCommit = UserPreferencesDlg( 
                    0,
                    hwndParent,
                    UP_F_ShowOnlyDiagnostic,
                    &pbuser,
                    &pPbFile );

    
    return NO_ERROR;
}


// Allows the editing of ras user preferences
DWORD
APIENTRY
RasUserPrefsDlgInternal (
    HWND hwndParent,
    DWORD dwFlags)
{
    BOOL bCommit = FALSE;
    PBFILE * pPbFile = NULL;
    PBUSER pbuser;
    DWORD dwErr;

    // Load ras if neccessary
    dwErr = LoadRas( g_hinstDll, hwndParent );
    if (dwErr != 0)
    {
        ErrorDlg( hwndParent, SID_OP_LoadRas, dwErr, NULL );
        return dwErr;
    }

    // Launch the user preferences dialog
    bCommit = UserPreferencesDlg( 
                    0,
                    hwndParent,
                    dwFlags,
                    &pbuser,
                    &pPbFile );

    // Commit any neccessary changes
    if (bCommit)
    {

    }

    return NO_ERROR;
}

DWORD
APIENTRY
RasUserPrefsDlgAutodial (
    HWND hwndParent)
{
    return RasUserPrefsDlgInternal(hwndParent, UP_F_AutodialMode);
}

DWORD
APIENTRY
RasUserPrefsDlg (
    HWND hwndParent)
{
    return RasUserPrefsDlgInternal(hwndParent, 0);
}

DWORD
APIENTRY
RasUserEnableManualDial (
    IN HWND  hwndParent,
    IN BOOL  bLogon,
    IN BOOL  bEnable )

    /* Called when the "operator dial" menu item is checked.
    */
{
    return SetUserManualDialEnabling (
                bEnable,
                (bLogon) ? UPM_Logon : UPM_Normal);
}

DWORD
APIENTRY
RasUserGetManualDial (
    IN HWND  hwndParent,    // parent for error dialogs
    IN BOOL  bLogon,        // whether a user is logged in
    IN PBOOL pbEnabled )    // whether to enable or not

    /* Called when the "operator dial" menu item is checked.
    */
{
    return GetUserManualDialEnabling (
                pbEnabled,
                (bLogon) ? UPM_Logon : UPM_Normal );
}

/*----------------------------------------------------------------------------
** User Preferences property sheet
** Listed alphabetically
**----------------------------------------------------------------------------
*/

BOOL
UpApply(
    IN HWND hwndPage )

    /* Saves the contents of the property sheet.  'hwndPage' is the property
    ** sheet page.  Pops up any errors that occur.
    **
    ** Returns false if invalid, true otherwise.
    */
{
    DWORD   dwErr;
    UPINFO* pInfo;

    TRACE("UpApply");

    pInfo = UpContext( hwndPage );
    if (!pInfo)
        return TRUE;

    if ( pInfo->hwndAd )
        AdApply( pInfo );

    if (pInfo->hwndCb)
        CbApply( pInfo );

    if(pInfo->hwndDg )
    {
        DgApply( pInfo );
    }
    
#if 0
    if (pInfo->hwndGp)
        GpApply( pInfo );
#endif

    if (pInfo->hwndCo)
        CoApply ( pInfo );

#if 0
    if (pInfo->hwndPl)
    {
        if (!PlApply( pInfo ))
            return FALSE;
    }
#endif

    pInfo->user.fDirty = TRUE;

    // Save off the user preferences
    //
    dwErr = g_pSetUserPreferences( 
                NULL, 
                &pInfo->user, 
                UPM_Normal );

    if (dwErr != 0)
    {
        if (*pInfo->pArgs->ppFile)
        {
            ClosePhonebookFile( *pInfo->pArgs->ppFile );
            *pInfo->pArgs->ppFile = NULL;
        }

        ErrorDlg( pInfo->hwndDlg, SID_OP_WritePrefs, dwErr, NULL );
        UpExit( pInfo );
        return TRUE;
    }

    // Save off the logon preferences if we loaded them.
    //
    dwErr = g_pSetUserPreferences( 
                NULL, 
                &pInfo->userLogon, 
                UPM_Logon );
    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_WritePrefs, dwErr, NULL );
        UpExit( pInfo );
        return TRUE;
    }

    CopyMemory( pInfo->pArgs->pUser, &pInfo->user, sizeof(PBUSER) );

    pInfo->pArgs->fResult = TRUE;
    return TRUE;
}


VOID
UpCancel(
    IN HWND hwndPage )

    /* Cancel was pressed.  'HwndPage' is the handle of a property page.
    */
{
    TRACE("UpCancel");
}


UPINFO*
UpContext(
    IN HWND hwndPage )

    /* Retrieve the property sheet context from a property page handle.
    */
{
    return (UPINFO* )GetProp( GetParent( hwndPage ), g_contextId );
}


VOID
UpExit(
    IN UPINFO* pInfo )

    /* Forces an exit from the dialog.  'PInfo' is the property sheet context.
    **
    ** Note: This cannot be called during initialization of the first page.
    **       See UpExitInit.
    */
{
    TRACE("UpExit");

    PropSheet_PressButton( pInfo->hwndDlg, PSBTN_CANCEL );
}


VOID
UpExitInit(
    IN HWND hwndDlg )

    /* Utility to report errors within UpInit and other first page
    ** initialization.  'HwndDlg' is the dialog window.
    */
{
    SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( hwndDlg, SOD_Free, NULL );
    PostMessage( hwndDlg, WM_COMMAND,
        MAKEWPARAM( IDCANCEL , BN_CLICKED ),
        (LPARAM )GetDlgItem( hwndDlg, IDCANCEL ) );
}

UPINFO*
UpInit(
    IN HWND    hwndFirstPage,
    IN UPARGS* pArgs )

    /* Property sheet level initialization.  'HwndPage' is the handle of the
    ** first page.  'PArgs' is the API argument block.
    **
    ** Returns address of the context block if successful, NULL otherwise.  If
    ** NULL is returned, an appropriate message has been displayed, and the
    ** property sheet has been cancelled.
    */
{
    UPINFO* pInfo;
    DWORD   dwErr;
    HWND    hwndDlg;

    TRACE("UpInit");

    hwndDlg = GetParent( hwndFirstPage );
    ASSERT(hwndDlg);

    /* Allocate the context information block.
    */
    pInfo = Malloc( sizeof(*pInfo) );
    if (!pInfo)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
        UpExitInit( hwndDlg );
        return NULL;
    }

    /* Initialize the context block.
    */
    ZeroMemory( pInfo, sizeof(*pInfo) );
    pInfo->hwndDlg = hwndDlg;
    pInfo->pArgs = pArgs;
    pInfo->hwndFirstPage = hwndFirstPage;

    /* Read in the user preferences
    */
    dwErr = g_pGetUserPreferences( 
                NULL, 
                &pInfo->user, 
                UPM_Normal);
    if (dwErr != 0)
    {
        Free( pInfo );
        ErrorDlg( hwndDlg, SID_OP_LoadPrefs, dwErr, NULL );
        UpExitInit( hwndDlg );
        return NULL;
    }

    /* If the fNoUser option was not selected, then load in the 
       logon preferences separately, since we allow them to be
       modificed in this UI
    */
    dwErr = g_pGetUserPreferences( 
                NULL, 
                &pInfo->userLogon, 
                UPM_Logon);
    if (dwErr != 0)
    {
        Free( pInfo );
        ErrorDlg( hwndDlg, SID_OP_LoadPrefs, dwErr, NULL );
        UpExitInit( hwndDlg );
        return NULL;
    }

    /* Associate the context with the property sheet window.
    */
    if (!SetProp( hwndDlg, g_contextId, pInfo ))
    {
        Free( pInfo );
        ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        UpExitInit( hwndDlg );
        return NULL;
    }

    /* Use caller's TAPI session handle, if any.
    */
    if (pArgs->hlineapp)
       pInfo->pHlineapp = &pArgs->hlineapp;
    else
       pInfo->pHlineapp = &pInfo->hlineapp;

    TRACE("Context set");

    /* Set even fixed tab widths, per spec.
    */
    // SetEvenTabWidths( hwndDlg, UP_PageCount );

    /* Position property sheet at standard offset from parent.
    {
        RECT rect;

        GetWindowRect( GetParent( hwndDlg ), &rect );
        SetWindowPos( hwndDlg, NULL,
            rect.left + DXSHEET, rect.top + DYSHEET, 0, 0,
            SWP_NOZORDER + SWP_NOSIZE );
        UnclipWindow( hwndDlg );
    }
    */

    CenterWindow ( hwndDlg, GetParent ( hwndDlg ) );

    //
    // pmay: 292069
    //
    // If the autodialer dialog has called into us, set focus to the
    // autodial tab.
    //
    // For whistler 460931
    //
    if (pArgs->dwFlags & UP_F_ShowOnlyDiagnostic)
    {
        PostMessage(
            hwndDlg,
            PSM_SETCURSELID,
            0,
            (LPARAM)(INT)PID_DG_Diagnostics);
    }
    else
    if (pArgs->dwFlags & UP_F_AutodialMode)
    {
        PostMessage(
            hwndDlg,
            PSM_SETCURSELID,
            0,
            (LPARAM)(INT)PID_AD_AutoDial);
    }
    
    return pInfo;
}


VOID
UpTerm(
    IN HWND hwndPage )

    /* Property sheet level termination.  Releases the context block.
    ** 'HwndPage' is the handle of a property page.
    */
{
    UPINFO* pInfo;

    TRACE("UpTerm");

    pInfo = UpContext( hwndPage );

    // Only terminate for once by making sure that we 
    // only terminate if this is the first page.
    if ( (pInfo) && (pInfo->hwndFirstPage == hwndPage) )
    {
        // For whistler 460931
        // Clean up the diagnostic library 
        //
        UnLoadDiagnosticDll( &pInfo->diagInfo);
        // Cleanup the list view

        if ( pInfo->hwndLvNumbers )
        {
            CbutilLvNumbersCleanup( pInfo->hwndLvNumbers );
        }

        if (pInfo->fChecksInstalled)
        {
            ListView_UninstallChecks( pInfo->hwndLvEnable );
        }

        if (pInfo->pHlineapp && *pInfo->pHlineapp != pInfo->pArgs->hlineapp)
        {
            TapiShutdown( *pInfo->pHlineapp );
        }

        Free( pInfo );
        TRACE("Context freed");
    }

    RemoveProp( GetParent( hwndPage ), g_contextId );
}


/*----------------------------------------------------------------------------
** Auto Dial property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
AdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Auto Dial page of the User Preferences
    ** property sheet.  Parameters and return value are as described for
    ** standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("AdDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, AdLvEnableCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return
                AdInit( hwnd, (UPARGS* )(((PROPSHEETPAGE* )lparam)->lParam) );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwAdHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_APPLY:
                {
                    BOOL fValid;
                    UPINFO* pInfo = UpContext ( hwnd );

                    TRACE("AdAPPLY");

                    // We have to apply if we are the first page...
                    if (pInfo->hwndFirstPage == hwnd)
                    {
                        /* Call UpApply only on first page.
                        */
                        fValid = UpApply( hwnd );
                        SetWindowLong(
                            hwnd, DWLP_MSGRESULT,
                            (fValid)
                                ? PSNRET_NOERROR
                                : PSNRET_INVALID_NOCHANGEPAGE );
                        return TRUE;
                    }
                }

                case PSN_RESET:
                {
                    /* Call UpCancel only on first page.
                    */
                    TRACE("AdRESET");
                    UpCancel( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    break;
                }
            }
        }
        break;

        case WM_DESTROY:
        {
            /* UpTerm will handle making sure it only does its 
            ** thing once
            */
            UpTerm( hwnd );
            break;
        }

    }

    return FALSE;
}


VOID
AdApply(
    IN UPINFO* pInfo )

    /* Saves the contents of the property page.  'PInfo' is the property sheet
    ** context.
    */
{
    DWORD   dwErr, dwFlag;
    UINT    unValue;
    LV_ITEM item;
    INT     i, iCount;
    BOOL    f;

    TRACE("AdApply");

    ZeroMemory( &item, sizeof(item) );
    item.mask = LVIF_PARAM + LVIF_STATE;

    iCount = ListView_GetItemCount( pInfo->hwndLvEnable );
    for (i = 0; i < iCount; ++i)
    {
        BOOL fCheck;

        item.iItem = i;
        if (!ListView_GetItem( pInfo->hwndLvEnable, &item ))
            break;

        fCheck = ListView_GetCheck( pInfo->hwndLvEnable, i );
        ASSERT(g_pRasSetAutodialEnable);
        dwErr = g_pRasSetAutodialEnable( (DWORD )item.lParam, fCheck );
        if (dwErr != 0)
            ErrorDlg( pInfo->hwndDlg, SID_OP_SetADialInfo, dwErr, NULL );
    }

    /* Set the autodial prompt information.
     * Flip it because the API wants true to mean "disable".
    */
    dwFlag = (DWORD )!IsDlgButtonChecked(
        pInfo->hwndAd, CID_AD_CB_AskBeforeAutodial );

    TRACE1("RasSetAutodialParam(%d)",dwFlag);
    dwErr = g_pRasSetAutodialParam( RASADP_DisableConnectionQuery,
        &dwFlag, sizeof(dwFlag) );
    TRACE1("RasSetAutodialParam=%d",dwErr);

    // 
    // pmay: 209762
    //
    // Save the "disable current session" checkbox
    //
    dwFlag = (DWORD )
        IsDlgButtonChecked(pInfo->hwndAd, CID_AD_CB_DisableThisSession );

    dwErr = g_pRasSetAutodialParam( 
                RASADP_LoginSessionDisable,
                &dwFlag, 
                sizeof(dwFlag) );
}


BOOL
AdFillLvEnable(
    IN UPINFO* pInfo )

    /* Initialize the listview of checkboxes.  'PInfo' is the property sheet
    ** context.
    **
    ** Note: This routine must only be called once.
    **
    ** Returns true if focus is set, false otherwise.
    */
{
    DWORD     dwErr;
    LOCATION* pLocations;
    DWORD     cLocations;
    DWORD     dwCurLocation;
    BOOL      fFocusSet;

    fFocusSet = FALSE;
    ListView_DeleteAllItems( pInfo->hwndLvEnable );

    /* Install "listview of check boxes" handling.
    */
    pInfo->fChecksInstalled =
        ListView_InstallChecks( pInfo->hwndLvEnable, g_hinstDll );
    if (!pInfo->fChecksInstalled)
        return FALSE;

    /* Insert an item for each location.
    */
    pLocations = NULL;
    cLocations = 0;
    dwCurLocation = 0xFFFFFFFF;
    dwErr = GetLocationInfo( g_hinstDll, pInfo->pHlineapp,
                &pLocations, &cLocations, &dwCurLocation );
    if (dwErr != 0)
        ErrorDlg( pInfo->hwndDlg, SID_OP_LoadTapiInfo, dwErr, NULL );
    else
    {
        LV_ITEM   item;
        LOCATION* pLocation;
        TCHAR*    pszCurLoc;
        DWORD     i;

        pszCurLoc = PszFromId( g_hinstDll, SID_IsCurLoc );

        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_TEXT + LVIF_PARAM;

        for (i = 0, pLocation = pLocations;
             i < cLocations;
            ++i, ++pLocation)
        {
            TCHAR* psz;
            TCHAR* pszText;
            DWORD  cb;

            pszText = NULL;
            psz = StrDup( pLocation->pszName );
            if (psz)
            {
                if (dwCurLocation == pLocation->dwId && pszCurLoc)
                {
                    /* This is the current globally selected location.  Append
                    ** the " (the current location)" text.
                    */
                    cb = lstrlen( psz ) + lstrlen(pszCurLoc) + 1;
                    pszText = Malloc( cb * sizeof(TCHAR) );
                    if (pszText)
                    {
                        // Whistler bug 224074 use only lstrcpyn's to prevent
                        // maliciousness
                        //
                        lstrcpyn(
                            pszText,
                            psz,
                            cb );
                        lstrcat( pszText, pszCurLoc );
                    }
                    Free( psz );
                }
                else
                    pszText = psz;
            }

            if (pszText)
            {
                BOOL fCheck;

                /* Get the initial check value for this location.
                */
                ASSERT(g_pRasGetAutodialEnable);
                dwErr = g_pRasGetAutodialEnable( pLocation->dwId, &fCheck );
                if (dwErr != 0)
                {
                    ErrorDlg( pInfo->hwndDlg, SID_OP_GetADialInfo,
                        dwErr, NULL );
                    fCheck = FALSE;
                }

                item.iItem = i;
                item.lParam = pLocation->dwId;
                item.pszText = pszText;
                ListView_InsertItem( pInfo->hwndLvEnable, &item );
                ListView_SetCheck( pInfo->hwndLvEnable, i, fCheck );

                if (dwCurLocation == pLocation->dwId)
                {
                    /* Initial selection is the current location.
                    */
                    ListView_SetItemState( pInfo->hwndLvEnable, i,
                        LVIS_SELECTED + LVIS_FOCUSED,
                        LVIS_SELECTED + LVIS_FOCUSED );
                    fFocusSet = TRUE;
                }

                Free( pszText );
            }
        }

        Free0( pszCurLoc );
        FreeLocationInfo( pLocations, cLocations );

        /* Add a single column exactly wide enough to fully display the widest
        ** member of the list.
        */
        {
            LV_COLUMN col;

            ZeroMemory( &col, sizeof(col) );
            col.mask = LVCF_FMT;
            col.fmt = LVCFMT_LEFT;
            ListView_InsertColumn( pInfo->hwndLvEnable, 0, &col );
            ListView_SetColumnWidth(
                pInfo->hwndLvEnable, 0, LVSCW_AUTOSIZE_USEHEADER );
        }
    }

    return fFocusSet;
}


BOOL
AdInit(
    IN     HWND    hwndPage,
    IN OUT UPARGS* pArgs )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    UPINFO* pInfo;
    BOOL    fFocusSet;
    HWND    hwndUdAttempts;
    HWND    hwndUdSeconds;
    HWND    hwndUdIdle;
    DWORD   dwErr = NO_ERROR;
    DWORD dwFlag;
    DWORD cb;

    TRACE("AdInit");

    /* We're first page, if the user isn't
     * an admin.
    */
    pInfo = UpInit( hwndPage, pArgs );
    if (!pInfo)
        return TRUE;

    // For whistler bug 460931  gangz
    //
    if ( pArgs->dwFlags & UP_F_ShowOnlyDiagnostic)
    {
        pInfo->fShowOnlyDiagnostic = TRUE;
        EnumChildWindows( hwndPage, 
                          PrefDisableAllChildWindows,
                          (LPARAM)FALSE);
    }
    else
    {
        pInfo->fShowOnlyDiagnostic = FALSE;
    }


    // Make sure that a default location is created if there isn't one.  bug
    // 168631
    //
    dwErr = TapiNoLocationDlg( g_hinstDll, &(pInfo->pArgs->hlineapp), hwndPage );
    if (dwErr != 0)
    {
        // Error here is treated as a "cancel" per bug 288385.
        //
        return TRUE;
    }

    /* Initialize page-specific context information.
    */
    pInfo->hwndAd = hwndPage;
    pInfo->hwndLvEnable = GetDlgItem( hwndPage, CID_AD_LV_Enable );
    ASSERT(pInfo->hwndLvEnable);

    /* Initialize the listview.
    */
    fFocusSet = AdFillLvEnable( pInfo );

    /* Initialize autodial parameters.
    */
    dwFlag = FALSE;
    cb = sizeof(dwFlag);
    TRACE("RasGetAutodialParam(DCQ)");
    dwErr = g_pRasGetAutodialParam(
        RASADP_DisableConnectionQuery, &dwFlag, &cb );
    TRACE1("RasGetAutodialParam=%d",dwErr);

    /* Flip it because the API wants true to mean "disable".
    */
    CheckDlgButton( hwndPage, CID_AD_CB_AskBeforeAutodial, (BOOL )!dwFlag );

    // 
    // pmay: 209762
    //
    // Initialize the "disable current session" checkbox
    //
    dwFlag = FALSE;
    cb = sizeof(dwFlag);
    dwErr = g_pRasGetAutodialParam(
        RASADP_LoginSessionDisable, &dwFlag, &cb );
        
    CheckDlgButton( 
        hwndPage, 
        CID_AD_CB_DisableThisSession, 
        (BOOL )dwFlag );

    return !fFocusSet;
}


LVXDRAWINFO*
AdLvEnableCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    /* Enhanced list view callback to report drawing information.  'HwndLv' is
    ** the handle of the list view control.  'DwItem' is the index of the item
    ** being drawn.
    **
    ** Returns the address of the draw information.
    */
{
    /* The enhanced list view is used only to get the "wide selection bar"
    ** feature so our option list is not very interesting.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info = { 1, 0, 0, { 0 } };

    return &info;
}


/*----------------------------------------------------------------------------
** Callback property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
CbDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Callback page of the User Preferences
    ** property sheet.  Parameters and return value are as described for
    ** standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("CbDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, CbutilLvNumbersCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return CbInit( hwnd );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwCbHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case NM_DBLCLK:
                {
                    UPINFO* pInfo = UpContext( hwnd );
                    ASSERT(pInfo);
                    SendMessage( pInfo->hwndPbEdit, BM_CLICK, 0, 0 );
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    UPINFO* pInfo = UpContext( hwnd );
                    ASSERT(pInfo);
                    CbUpdateLvAndPbState( pInfo );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            UPINFO* pInfo = UpContext( hwnd );
            ASSERT(pInfo);

            return CbCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }
    }

    return FALSE;
}


VOID
CbApply(
    IN UPINFO* pInfo )

    /* Saves the contents of the property page.  'PInfo' is the property sheet
    ** context.
    */
{
    TRACE("CbApply");

    if (IsDlgButtonChecked( pInfo->hwndCb, CID_CB_RB_No ))
        pInfo->user.dwCallbackMode = CBM_No;
    else if (IsDlgButtonChecked( pInfo->hwndCb, CID_CB_RB_Maybe ))
        pInfo->user.dwCallbackMode = CBM_Maybe;
    else
        pInfo->user.dwCallbackMode = CBM_Yes;

    CbutilSaveLv( pInfo->hwndLvNumbers, pInfo->user.pdtllistCallback );
}


BOOL
CbCommand(
    IN UPINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("CbCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_CB_RB_No:
        case CID_CB_RB_Maybe:
        case CID_CB_RB_Yes:
        {
            if (wNotification == BN_CLICKED)
            {
                CbUpdateLvAndPbState( pInfo );

                if (wId == CID_CB_RB_Yes
                    && ListView_GetSelectedCount( pInfo->hwndLvNumbers ) == 0)
                {
                    /* Nothing's selected, so select the first item, if any.
                    */
                    ListView_SetItemState( pInfo->hwndLvNumbers, 0,
                        LVIS_SELECTED, LVIS_SELECTED );
                }
            }
            break;
        }

        case CID_CB_PB_Edit:
        {
            if (wNotification == BN_CLICKED)
                CbutilEdit( pInfo->hwndCb, pInfo->hwndLvNumbers );
            break;
        }

        case CID_CB_PB_Delete:
        {
            if (wNotification == BN_CLICKED)
                CbutilDelete( pInfo->hwndCb, pInfo->hwndLvNumbers );
            break;
        }
    }

    return FALSE;
}


BOOL
CbInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    UPINFO* pInfo;

    TRACE("CbInit");

    pInfo = UpContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // For whistler 460931
    //
    if( TRUE == pInfo->fShowOnlyDiagnostic )
    {
        EnumChildWindows( hwndPage, 
                          PrefDisableAllChildWindows,
                          (LPARAM)FALSE);
    }

    /* Initialize page-specific context information.
    */
    pInfo->hwndCb = hwndPage;
    pInfo->hwndRbNo = GetDlgItem( hwndPage, CID_CB_RB_No );
    ASSERT(pInfo->hwndRbNo);
    pInfo->hwndRbMaybe = GetDlgItem( hwndPage, CID_CB_RB_Maybe );
    ASSERT(pInfo->hwndRbMaybe);
    pInfo->hwndRbYes = GetDlgItem( hwndPage, CID_CB_RB_Yes );
    ASSERT(pInfo->hwndRbYes);
    pInfo->hwndLvNumbers = GetDlgItem( hwndPage, CID_CB_LV_Numbers );
    ASSERT(pInfo->hwndLvNumbers);
    pInfo->hwndPbEdit = GetDlgItem( hwndPage, CID_CB_PB_Edit );
    ASSERT(pInfo->hwndPbEdit);
    pInfo->hwndPbDelete = GetDlgItem( hwndPage, CID_CB_PB_Delete );
    ASSERT(pInfo->hwndPbDelete);

    /* Initialize the listview.
    */
    CbutilFillLvNumbers(
        pInfo->hwndCb, pInfo->hwndLvNumbers,
        pInfo->user.pdtllistCallback, FALSE );

    /* Set the radio button selection, which triggers appropriate
    ** enabling/disabling.
    */
    {
        HWND  hwndRb;

        if (pInfo->user.dwCallbackMode == CBM_No)
            hwndRb = pInfo->hwndRbNo;
        else if (pInfo->user.dwCallbackMode == CBM_Maybe)
            hwndRb = pInfo->hwndRbMaybe;
        else
        {
            ASSERT(pInfo->user.dwCallbackMode==CBM_Yes);
            hwndRb = pInfo->hwndRbYes;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    // pmay: If there are no devices available for callback,
    // add some explanatory text and disable appropriate
    // controls.  Bug 168830
    if (ListView_GetItemCount(pInfo->hwndLvNumbers) == 0)
    {
        // Uncheck if needed
        if (Button_GetCheck(pInfo->hwndRbYes))
        {
            Button_SetCheck(pInfo->hwndRbMaybe, TRUE);
        }

        // Disable the windows.
        EnableWindow(pInfo->hwndRbYes, FALSE);
        EnableWindow(pInfo->hwndLvNumbers, FALSE);
    }
    
    return TRUE;
}


VOID
CbUpdateLvAndPbState(
    IN UPINFO* pInfo )

    /* Enables/disables the list view and associated buttons.  ListView is
    ** gray unless auto-callback is selected.  Buttons gray unless
    ** auto-callback selected and there is an item selected.
    */
{
    BOOL fEnableList;
    BOOL fEnableEditButton, fEnableDeleteButton;
    INT  iSel;
    HWND hwndLv;

    // By default, we don't enable any buttons
    fEnableDeleteButton = FALSE;
    fEnableEditButton = FALSE;
    
    // Only enable the list view if Yes is selected
    //
    fEnableList = Button_GetCheck( pInfo->hwndRbYes );
    if (fEnableList)
    {
        hwndLv = pInfo->hwndLvNumbers;

        if ( ListView_GetSelectedCount( hwndLv ) )
        {
            // The edit button should only be enabled if the 
            // listview is enabled and if one or more
            // items is selected.
            fEnableEditButton = TRUE;

            //
            // pmay: 213060
            //
            // The delete button is only enabled if all of the selected
            // devices are not configured on the system. (since only 
            // non-installed devices can be removed from the list).
            //
            fEnableDeleteButton = TRUE;
            for (iSel = ListView_GetNextItem( hwndLv, -1, LVNI_SELECTED );
                 iSel >= 0;
                 iSel = ListView_GetNextItem( hwndLv, iSel, LVNI_SELECTED )
                )
            {
                LV_ITEM item;
                ZeroMemory(&item, sizeof(item));

                item.iItem = iSel;
                item.mask = LVIF_PARAM;
                
                if ( ListView_GetItem(hwndLv, &item) )
                {
                    if (((CBCONTEXT*)item.lParam)->fConfigured)
                    {
                        fEnableDeleteButton = FALSE;
                    }
                }
            }  
        }            
    }

    EnableWindow( pInfo->hwndLvNumbers, fEnableList );
    EnableWindow( pInfo->hwndPbEdit, fEnableEditButton );
    EnableWindow( pInfo->hwndPbDelete, fEnableDeleteButton );
}

/*-----------------------------------------------------
** Utilities shared with router version of the listview
**-----------------------------------------------------
*/

VOID
CbutilDelete(
    IN HWND  hwndDlg,
    IN HWND  hwndLvNumbers )

    /* Called when the Delete button is pressed.  'PInfo' is the dialog
    ** context.
    */
{
    MSGARGS msgargs;
    INT     nResponse;

    TRACE("CbDelete");

    ZeroMemory( &msgargs, sizeof(msgargs) );
    msgargs.dwFlags = MB_YESNO + MB_ICONEXCLAMATION;
    nResponse = MsgDlg( hwndDlg, SID_ConfirmDelDevice, &msgargs );
    if (nResponse == IDYES)
    {
        INT iSel;

        /* User has confirmed deletion of selected devices, so do it.
        */
        while ((iSel = ListView_GetNextItem(
                           hwndLvNumbers, -1, LVNI_SELECTED )) >= 0)
        {
            ListView_DeleteItem( hwndLvNumbers, iSel );
        }
    }
}


VOID
CbutilEdit(
    IN HWND hwndDlg,
    IN HWND hwndLvNumbers )

    /* Called when the Edit button is pressed.  'HwndDlg' is the page/dialog
    ** window.  'HwndLvNumbers' is the callback number listview window.
    */
{
    INT    iSel;
    TCHAR  szBuf[ RAS_MaxCallbackNumber + 1 ];
    TCHAR* pszNumber;

    TRACE("CbutilEdit");

    /* Load 'szBuf' with the current phone number of the first selected item.
    */
    iSel = ListView_GetNextItem( hwndLvNumbers, -1, LVNI_SELECTED );
    if (iSel < 0)
        return;
    szBuf[ 0 ] = TEXT('\0');
    ListView_GetItemText( hwndLvNumbers, iSel, 1,
        szBuf, RAS_MaxCallbackNumber + 1 );

    /* Popup dialog to edit the number.
    */
    pszNumber = NULL;
    if (StringEditorDlg( hwndDlg, szBuf,
            SID_EcbnTitle, SID_EcbnLabel, RAS_MaxCallbackNumber,
            HID_ZE_ST_CallbackNumber, &pszNumber ))
    {
        /* OK pressed, so change the number on all selected items.
        */
        ASSERT(pszNumber);

        do
        {
            ListView_SetItemText( hwndLvNumbers, iSel, 1, pszNumber );
        }
        while ((iSel = ListView_GetNextItem(
                           hwndLvNumbers, iSel, LVNI_SELECTED )) >= 0);
    }
}


VOID
CbutilFillLvNumbers(
    IN HWND     hwndDlg,
    IN HWND     hwndLvNumbers,
    IN DTLLIST* pListCallback,
    IN BOOL     fRouter )

    /* Fill the listview with devices and phone numbers.  'HwndDlg' is the
    ** page/dialog window.  'HwndLvNumbers' is the callback listview.
    ** 'PListCallback' is the list of CALLBACKINFO.  'FRouter' is true if the
    ** router ports should be enumerated, or false for regular dial-out ports.
    **
    ** Note: This routine should be called only once.
    */
{
    DWORD    dwErr;
    DTLLIST* pListPorts;
    DTLNODE* pNodeCbi;
    DTLNODE* pNodePort;
    INT      iItem;
    TCHAR*   psz;

    TRACE("CbutilFillLvNumbers");

    ListView_DeleteAllItems( hwndLvNumbers );

    /* Add columns.
    */
    {
        LV_COLUMN col;
        TCHAR*    pszHeader0;
        TCHAR*    pszHeader1;

        pszHeader0 = PszFromId( g_hinstDll, SID_DeviceColHead );
        pszHeader1 = PszFromId( g_hinstDll, SID_PhoneNumberColHead );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader0) ? pszHeader0 : TEXT("");
        ListView_InsertColumn( hwndLvNumbers, 0, &col );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_SUBITEM + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader1) ? pszHeader1 : TEXT("");
        col.iSubItem = 1;
        ListView_InsertColumn( hwndLvNumbers, 1, &col );

        Free0( pszHeader0 );
        Free0( pszHeader1 );
    }

    /* Add the modem and adapter images.
    */
    ListView_SetDeviceImageList( hwndLvNumbers, g_hinstDll );

    /* Load listview with callback device/number pairs saved as user
    ** preferences.
    */
    iItem = 0;
    ASSERT(pListCallback);
    for (pNodeCbi = DtlGetFirstNode( pListCallback );
         pNodeCbi;
         pNodeCbi = DtlGetNextNode( pNodeCbi ), ++iItem)
    {
        CALLBACKINFO* pCbi;
        LV_ITEM       item;

        pCbi = (CALLBACKINFO* )DtlGetData( pNodeCbi );
        ASSERT(pCbi);
        ASSERT(pCbi->pszPortName);
        ASSERT(pCbi->pszDeviceName);
        ASSERT(pCbi->pszNumber);

        if (pCbi->dwDeviceType != RASET_Vpn) {
            psz = PszFromDeviceAndPort( pCbi->pszDeviceName, pCbi->pszPortName );
            if (psz)
            {
                // pmay: 213060
                //
                // Allocate and initialize the context.
                //
                CBCONTEXT * pCbCtx;

                pCbCtx = (CBCONTEXT*) Malloc (sizeof(CBCONTEXT));
                if (pCbCtx == NULL)
                {
                    continue;
                }
                pCbCtx->pszPortName = pCbi->pszPortName;
                pCbCtx->pszDeviceName = pCbi->pszDeviceName;
                pCbCtx->dwDeviceType = pCbi->dwDeviceType;
                pCbCtx->fConfigured = FALSE;
            
                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
                item.iItem = iItem;
                item.pszText = psz;
                item.iImage =
                    ((PBDEVICETYPE )pCbi->dwDeviceType == PBDT_Modem)
                        ? DI_Modem : DI_Adapter;
                item.lParam = (LPARAM )pCbCtx;
                ListView_InsertItem( hwndLvNumbers, &item );
                ListView_SetItemText( hwndLvNumbers, iItem, 1, pCbi->pszNumber );
                Free( psz );
            }
        }
    }

    /* Add any devices installed but not already in the list.
    */
    dwErr = LoadPortsList2( NULL, &pListPorts, fRouter );
    if (dwErr != 0)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadPortInfo, dwErr, NULL );
    }
    else
    {
        for (pNodePort = DtlGetFirstNode( pListPorts );
             pNodePort;
             pNodePort = DtlGetNextNode( pNodePort ))
        {
            PBPORT* pPort = (PBPORT* )DtlGetData( pNodePort );
            INT i = -1;
            BOOL bPortAlreadyInLv = FALSE;
            ASSERT(pPort);

            // pmay: 213060
            //
            // Search for the configured item in the list view
            //
            while ((i = ListView_GetNextItem( 
                            hwndLvNumbers, 
                            i, 
                            LVNI_ALL )) >= 0)
            {
                LV_ITEM item;
                CBCONTEXT * pCbCtx;
                
                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_PARAM;
                item.iItem = i;
                if (!ListView_GetItem( hwndLvNumbers, &item ))
                {
                    continue;
                }

                // Get the context
                //
                pCbCtx = (CBCONTEXT*)item.lParam;
                if (! pCbCtx)
                {
                    continue;
                }

                // If the current item in the list view matches the 
                // current port, then we know that the current item
                // is configured on the system.
                if ((lstrcmpi( pPort->pszPort, pCbCtx->pszPortName ) == 0) &&
                    (lstrcmpi( pPort->pszDevice, pCbCtx->pszDeviceName ) == 0)
                   )
                {
                    bPortAlreadyInLv = TRUE;
                    pCbCtx->fConfigured = TRUE;
                    break;
                }
            }
            
            if (! bPortAlreadyInLv)
            {
                LV_ITEM      item;
                PBDEVICETYPE pbdt;

                /* The device/port was not in the callback list.  Append it 
                ** to the listview with empty phone number.
                */
                if ((pPort->dwType != RASET_Vpn) && 
                    (pPort->dwType != RASET_Direct) &&
                    (pPort->dwType != RASET_Broadband)
                   ) 
                {
                    psz = PszFromDeviceAndPort( 
                                pPort->pszDevice, 
                                pPort->pszPort );
                    if (psz)
                    {
                        // pmay: 213060
                        //
                        // Allocate and initialize the context.
                        //
                        CBCONTEXT * pCbCtx;

                        pCbCtx = (CBCONTEXT*) Malloc (sizeof(CBCONTEXT));
                        if (pCbCtx == NULL)
                        {
                            continue;
                        }
                        pCbCtx->pszPortName = pPort->pszPort;
                        pCbCtx->pszDeviceName = pPort->pszDevice;
                        pCbCtx->dwDeviceType = (DWORD) pPort->pbdevicetype;
                        pCbCtx->fConfigured = TRUE;

                        ZeroMemory( &item, sizeof(item) );
                        item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
                        item.iItem = iItem;
                        item.pszText = psz;
                        item.iImage =
                            (pPort->pbdevicetype == PBDT_Modem)
                                ? DI_Modem : DI_Adapter;
                        item.lParam = (LPARAM ) pCbCtx;
                        ListView_InsertItem( hwndLvNumbers, &item );
                        ListView_SetItemText( 
                            hwndLvNumbers, 
                            iItem, 
                            1, 
                            TEXT(""));
                        ++iItem;
                        Free( psz );
                    }
                }
            }
        }

        DtlDestroyList( pListPorts, DestroyPortNode );
    }

    /* Auto-size columns to look good with the text they contain.
    */
    ListView_SetColumnWidth( hwndLvNumbers, 0, LVSCW_AUTOSIZE_USEHEADER );
    ListView_SetColumnWidth( hwndLvNumbers, 1, LVSCW_AUTOSIZE_USEHEADER );
}

VOID
CbutilLvNumbersCleanup(
    IN  HWND    hwndLvNumbers )

    /* Cleans up after CbutilFillLvNumbers.
    */
{
    INT      i;
    
    i = -1;
    while ((i = ListView_GetNextItem( hwndLvNumbers, i, LVNI_ALL )) >= 0)
    {
        LV_ITEM item;

        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_PARAM;
        item.iItem = i;
        if (!ListView_GetItem( hwndLvNumbers, &item ))
            continue;

        // Free the context
        Free0( (PVOID) item.lParam );
    }
}


LVXDRAWINFO*
CbutilLvNumbersCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    /* Enhanced list view callback to report drawing information.  'HwndLv' is
    ** the handle of the list view control.  'DwItem' is the index of the item
    ** being drawn.
    **
    ** Returns the address of the column information.
    */
{
    /* Use "wide selection bar" feature and the other recommended options.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info =
        { 2, 0, LVXDI_Blend50Dis + LVXDI_DxFill, { 0, 0 } };

    return &info;
}


VOID
CbutilSaveLv(
    IN  HWND     hwndLvNumbers,
    OUT DTLLIST* pListCallback )

    /* Replace list 'pListCallback' contents with that of the listview
    ** 'hwndLvNumbers'.
    */
{
    DTLNODE* pNode;
    INT      i;

    TRACE("CbutilSaveLv");

    /* Empty the list of callback info, then re-populate from the listview.
    */
    while (pNode = DtlGetFirstNode( pListCallback ))
    {
        DtlRemoveNode( pListCallback, pNode );
        DestroyCallbackNode( pNode );
    }

    i = -1;
    while ((i = ListView_GetNextItem( hwndLvNumbers, i, LVNI_ALL )) >= 0)
    {
        LV_ITEM item;
        TCHAR*  pszDevice;
        TCHAR*  pszPort;

        TCHAR szDP[ RAS_MaxDeviceName + 2 + MAX_PORT_NAME + 1 + 1 ];
        TCHAR szNumber[ RAS_MaxCallbackNumber + 1 ];

        szDP[ 0 ] = TEXT('\0');
        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = i;
        item.pszText = szDP;
        item.cchTextMax = sizeof(szDP) / sizeof(TCHAR);
        if (!ListView_GetItem( hwndLvNumbers, &item ))
            continue;

        szNumber[ 0 ] = TEXT('\0');
        ListView_GetItemText( hwndLvNumbers, i, 1,
            szNumber, RAS_MaxCallbackNumber + 1 );

        if (!DeviceAndPortFromPsz( szDP, &pszDevice, &pszPort ))
            continue;

        pNode = CreateCallbackNode(
                    pszPort, 
                    pszDevice, 
                    szNumber, 
                    ((CBCONTEXT*)item.lParam)->dwDeviceType );
        if (pNode)
            DtlAddNodeLast( pListCallback, pNode );

        Free( pszDevice );
        Free( pszPort );
    }
}

/*----------------------------------------------------------------------------
** Connections Preferences property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/
INT_PTR CALLBACK
CoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return CoInit( hwnd, (UPARGS* )(((PROPSHEETPAGE* )lparam)->lParam) );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwCoHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_APPLY:
                {
                    BOOL fValid;
                    UPINFO *pUpInfo;

                    TRACE("CoAPPLY");

                    pUpInfo = UpContext(hwnd);

                    if(NULL != pUpInfo)
                    {
                        CoApply( pUpInfo );
                    }

                    /* Call UpApply only on first page.
                    */
                    fValid = UpApply( hwnd );
                    SetWindowLong(
                        hwnd, DWLP_MSGRESULT,
                        (fValid)
                            ? PSNRET_NOERROR
                            : PSNRET_INVALID_NOCHANGEPAGE );
                    return TRUE;
                }
            }
            break;
        }

    }

    return FALSE;
}

BOOL
CoApply(
    IN UPINFO* pInfo )

    // Return true to allow application of property sheet, false
    // to refuse.
{
    BOOL bAllow;

    bAllow = IsDlgButtonChecked( 
                pInfo->hwndCo, 
                CID_CO_CB_AllowConnectionModification );

    if ( (!!bAllow) != (!!pInfo->userLogon.fAllowLogonPhonebookEdits) )
    {
        pInfo->userLogon.fAllowLogonPhonebookEdits = !!bAllow;
        pInfo->userLogon.fDirty = TRUE;
    }

    return TRUE;
}

BOOL
CoInit(
    IN     HWND    hwndPage,
    IN OUT UPARGS* pArgs )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    UPINFO * pInfo = NULL;

    /* We're first page, so initialize the property sheet.
    */
    pInfo = UpInit( hwndPage, pArgs );
    if (!pInfo)
        return TRUE;

    pInfo->hwndCo = hwndPage;

    // Set the flag for allowing phonebook edits
    Button_SetCheck (
        GetDlgItem (pInfo->hwndCo, CID_CO_CB_AllowConnectionModification),
        pInfo->userLogon.fAllowLogonPhonebookEdits);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\penettab.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// penettab.c
// Remote Access Common Dialog APIs
// Phonebook Entry property sheet (Networking tab)
//
// 12/10/97 Shaun Cox
//


#include "rasdlgp.h"
#include "entryps.h"
#include "inetcfgp.h"
#include "initguid.h"
#include "netcfgp.h"
#include "netconp.h"
#include "devguid.h"
#include "uiinfo.h"


typedef struct
_MAP_SZ_DWORD
{
    LPCTSTR pszValue;
    DWORD   dwValue;
}
MAP_SZ_DWORD;

//For whistler bug#194394
//For 64bit, IPX wont show up
//For 32/64 bit, NETBEUI wont show up
//
#ifdef _WIN64
    static const MAP_SZ_DWORD c_mapProtocols [] =
    {
        { NETCFG_TRANS_CID_MS_TCPIP,        NP_Ip  },
        { NETCFG_TRANS_CID_MS_NETMON,       NP_Netmon },
    };
#else
    static const MAP_SZ_DWORD c_mapProtocols [] =
    {
        { NETCFG_TRANS_CID_MS_TCPIP,        NP_Ip  },
        { NETCFG_TRANS_CID_MS_NWIPX,        NP_Ipx },
        { NETCFG_TRANS_CID_MS_NETMON,       NP_Netmon },
    };
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DwProtocolFromComponentId
//
//  Purpose:    Return the DWORD value of the protocol corresponding to
//              the string value in c_mapProtocols.
//
//  Arguments:
//      pszComponentId [in] Component id to find.
//
//  Returns:    NP_xxx value
//
//  Author:     shaunco   13 Dec 1997
//
//  Notes:      The input argument must exist in c_mapProtocols.
//
DWORD
DwProtocolFromComponentId (
    LPCTSTR pszComponentId)
{
    int i;
    for (i = 0; i < sizeof(c_mapProtocols) / sizeof(c_mapProtocols[0]); i++)
    {
        if (0 == lstrcmpi (pszComponentId, c_mapProtocols[i].pszValue))
        {
            return c_mapProtocols[i].dwValue;
        }
    }
    // Should never get here as we should never pass a protocol that is not
    // in c_mapProtocols.
    //
    ASSERT (FALSE);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetComponentImageIndex
//
//  Purpose:    Returns the index into pcild corresponding to the class of
//              pComponent.
//
//  Arguments:
//      pComponent [in] Component who's class should be used.
//      pcild      [in] Returned from SetupDiGetClassImageList
//
//  Returns:    A valid index or zero (which may also be valid).
//
//  Author:     shaunco   12 Dec 1997
//
//  Notes:
//
int
GetComponentImageIndex (
    INetCfgComponent*       pComponent,
    SP_CLASSIMAGELIST_DATA* pcild)
{
    int iImage = 0;

    GUID guidClass;
    HRESULT hr = INetCfgComponent_GetClassGuid (pComponent, &guidClass);
    if (SUCCEEDED(hr))
    {
        SetupDiGetClassImageIndex (pcild, &guidClass, &iImage);
    }

    return iImage;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrEnumComponentsForListView
//
//  Purpose:    Return an array of INetCfgComponents that are candidates
//              for adding to our list view.  This is composed of all
//              clients and servcies, and a few select protocols.  (No
//              net adapters.)  Hidden components could be returned and
//              should be checked before adding to the list view.
//
//  Arguments:
//      pNetCfg      [in]
//      celt         [in]
//      rgelt        [out]
//      pceltFetched [out]
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   12 Dec 1997
//
//  Notes:
//
HRESULT
HrEnumComponentsForListView (
    INetCfg*            pNetCfg,
    ULONG               celt,
    INetCfgComponent**  rgelt,
    ULONG*              pceltFetched)
{
    static const GUID* c_apguidClasses [] =
    {
        &GUID_DEVCLASS_NETCLIENT,
        &GUID_DEVCLASS_NETSERVICE,
    };

    HRESULT hr;
    int i;
    ULONG celtFetched = 0;

    // Initialize the output parameters.
    //
    ZeroMemory (rgelt, celt * sizeof (*rgelt));
    *pceltFetched = 0;

    // Enumerate the clients and services.
    //
    hr = HrEnumComponentsInClasses (pNetCfg,
            sizeof(c_apguidClasses) / sizeof(c_apguidClasses[0]),
            (GUID**)c_apguidClasses,
            celt, rgelt, &celtFetched);

    // Find the protocols if they are installed.
    //
    for (i = 0; i < sizeof(c_mapProtocols) / sizeof(c_mapProtocols[0]); i++)
    {
        INetCfgComponent* pComponent;
        hr = INetCfg_FindComponent (pNetCfg, c_mapProtocols[i].pszValue,
                        &pComponent);
        if (S_OK == hr)
        {
            rgelt [celtFetched++] = pComponent;
        }
    }

    *pceltFetched = celtFetched;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNeRefreshListView
//
//  Purpose:    Clear and re-add all of the items that belong in the list
//              view.
//
//  Arguments:
//      pInfo   [in]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   12 Dec 1997
//
//  Notes:
//
HRESULT
HrNeRefreshListView (
    PEINFO* pInfo)
{
    HRESULT             hr = S_OK;
    INetCfgComponent*   aComponents [256];
    ULONG               cComponents;
    HIMAGELIST          himlSmall;
    PBENTRY*            pEntry = pInfo->pArgs->pEntry;
    PBFILE*             pFile  = pInfo->pArgs->pFile;

    // Delete all existing items.  The LVN_DELETEITEM handler is expected to
    // release the objects we have attached prior.
    //
    ListView_DeleteAllItems (pInfo->hwndLvComponents);

    hr = HrEnumComponentsForListView (pInfo->pNetCfg,
            sizeof(aComponents)/sizeof(aComponents[0]),
            aComponents, &cComponents);
    if (SUCCEEDED(hr))
    {
        BOOL    fHasPermission = TRUE;
        ULONG   i;

        // check if user has any permission to change the bindings
        INetConnectionUiUtilities * pncuu = NULL;

        hr = HrCreateNetConnectionUtilities(&pncuu);
        if (SUCCEEDED(hr))
        {
            fHasPermission =
                INetConnectionUiUtilities_UserHasPermission(
                    pncuu, NCPERM_ChangeBindState);

            INetConnectionUiUtilities_Release(pncuu);
        }

        for (i = 0; i < cComponents; i++)
        {
            INetCfgComponent*   pComponent = aComponents [i];
            DWORD               dwCharacter;
            LPWSTR              pszwName = NULL;
            LPWSTR              pszwId = NULL;
            int                 iItem;
            LV_ITEM             item = {0};
            BOOL                fCheck, fForceCheck = FALSE;
            GUID                guid;
            BOOL                fDisableCheckbox = FALSE;

            // We'll release it if inserting it failed or we decided to
            // skip it.  By not releasing it, we pass ownership to the
            // list view.
            //
            BOOL fReleaseComponent = TRUE;

            // Don't add hidden components.  Silently skip components
            // that we fail to get the class GUID or display name for.
            // (After all, what could we have the user do to fix the error?
            //  Might as well show them what we can.)
            //
            if (   FAILED(INetCfgComponent_GetCharacteristics (pComponent, &dwCharacter))
                || (dwCharacter & NCF_HIDDEN)
                || FAILED(INetCfgComponent_GetDisplayName (pComponent, &pszwName)))
            {
                goto skip_component;
            }
            
            if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
            {
                WCHAR * pszwTmpId = NULL;


                //for whistler bug 29356 filter out Network Load Balancing
                //
                pszwTmpId  = StrDupWFromT(NETCFG_SERVICE_CID_MS_WLBS);

                if(pszwTmpId)
                {
                    if ( 0 == lstrcmpW(pszwId, pszwTmpId))
                    {
                        Free0(pszwTmpId);
                        CoTaskMemFree (pszwId);
                        goto skip_component;
                    }
                    
                    Free0(pszwTmpId);
               }

               // 
               //for .Net 605988 filter out IPX for x86  router case
               // IPX is already filtered our for 64 bit case
               //
               if( pInfo->pArgs->fRouter )
               {
                    pszwTmpId  = StrDupWFromT(NETCFG_TRANS_CID_MS_NWIPX);
                    
                    if(pszwTmpId)
                    {
                        if ( 0 == lstrcmpW(pszwId, pszwTmpId))
                        {
                            Free0(pszwTmpId);
                            CoTaskMemFree (pszwId);
                            goto skip_component;
                        }
                        
                        Free0(pszwTmpId);
                   }

                    pszwTmpId  = StrDupWFromT( TEXT("ms_nwnb") );
                        
                    if(pszwTmpId)
                    {
                        if ( 0 == lstrcmpW(pszwId, pszwTmpId))
                        {
                            Free0(pszwTmpId);
                            CoTaskMemFree(pszwId);
                            return FALSE;
                        }
                        
                        Free0(pszwTmpId);
                   }
                    
                }
                  
                CoTaskMemFree (pszwId);
            }

            // Disable the checkbox on components whose bindings are not user adjustable
            // or user has no permission to adjust binding
            if (NCF_FIXED_BINDING & dwCharacter)
            {
                fDisableCheckbox = TRUE;
            }

            // Bug #157213: Don't add any protocols other than IP if SLIP
            // is enabled
            //
            // Bug #294401: Also filter out CSNW when server type is SLIP
            if (pInfo->pArgs->pEntry->dwBaseProtocol == BP_Slip)
            {
                if (SUCCEEDED(INetCfgComponent_GetClassGuid(pComponent, &guid)))
                {
                    BOOL    fSkip = FALSE;

                    if (IsEqualGUID(&guid, &GUID_DEVCLASS_NETTRANS))
                    {
                        if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
                        {
                            if (DwProtocolFromComponentId(pszwId) == NP_Ip)
                            {
                                // This item is IP. We should disable the check
                                // box so the user can't disable TCP/IP in SLIP
                                // mode. This is done after the item is inserted.
                                //
                                fDisableCheckbox = TRUE;

                                // 122024
                                //
                                // We should also force the ui to show ip as enabled
                                // since IP is always used with SLIP.
                                //
                                fForceCheck = TRUE;
                                
                            }
                            else
                            {
                                fSkip = TRUE;
                            }

                            CoTaskMemFree (pszwId);
                        }
                    }
                    else if (IsEqualGUID(&guid, &GUID_DEVCLASS_NETCLIENT))
                    {
                        if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
                        {
                            // For whistler 522872
                            if ( CSTR_EQUAL == CompareStringW(
                                  LOCALE_INVARIANT,
                                  NORM_IGNORECASE,
                                  L"MS_NWCLIENT",
                                  -1,
                                  pszwId,
                                  -1
                                  )
                                  )
                            {
                                fSkip = TRUE;
                            }
                            CoTaskMemFree (pszwId);
                        }
                    }

                    if (fSkip)
                    {
                        goto skip_component;
                    }
                }
            }

            // pmay: 348623 
            //
            // If we are remote admining a router, only allow tcpip and
            // ipx to be displayed.
            //
            if (pInfo->pArgs->fRouter && pInfo->pArgs->fRemote)
            {
                if (SUCCEEDED(INetCfgComponent_GetClassGuid(pComponent, &guid)))
                {
                    BOOL    fSkip = TRUE;
                    DWORD   dwId;

                    if (IsEqualGUID(&guid, &GUID_DEVCLASS_NETTRANS))
                    {
                        if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
                        {
                            dwId = DwProtocolFromComponentId(pszwId);
                            if ((dwId == NP_Ip) || (dwId == NP_Ipx))
                            {
                                fSkip = FALSE;
                            }
                            CoTaskMemFree (pszwId);
                        }
                    }
                    
                    if (fSkip)
                    {
                        goto skip_component;
                    }
                }
            }

            item.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            item.pszText = pszwName;
            item.iImage  = GetComponentImageIndex (pComponent, &pInfo->cild);
            item.lParam  = (LPARAM)pComponent;

            // Add the item.
            //
            iItem = ListView_InsertItem (pInfo->hwndLvComponents, &item);
            if (-1 != iItem)
            {
                // List view now has it.  We can't release it.
                //
                fReleaseComponent = FALSE;

                // Set its check state.
                //
                if (! fForceCheck)
                {
                    fCheck = NeIsComponentEnabled (pInfo, pComponent);
                }
                else
                {
                    fCheck = TRUE;
                }
                ListView_SetCheck (pInfo->hwndLvComponents, iItem, fCheck);

                // Disable the checkbox if this is psched. We don't allow
                // users to change check state of psched from ras connections.
                // bug 255749 [raos].
                //
                if(SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
                {
                    // Check to see if this is psched.
                    //
                    if(     (0 == _wcsicmp(pszwId, L"ms_psched"))
                        ||  (0 == _wcsicmp(pszwId, L"ms_NetMon")))
                    {
                        fDisableCheckbox = TRUE;
                    }
                }

                if (fDisableCheckbox)
                {
                    ListView_DisableCheck(pInfo->hwndLvComponents, iItem);
                }
            }

        skip_component:

            if (fReleaseComponent)
            {
                ReleaseObj (pComponent);
            }

            CoTaskMemFree (pszwName);
        }

        // Select first item
        ListView_SetItemState(pInfo->hwndLvComponents, 0,
                              LVIS_SELECTED | LVIS_FOCUSED,
                              LVIS_SELECTED | LVIS_FOCUSED);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   PComponentFromItemIndex
//
//  Purpose:    Return the INetCfgComponent associated with the specified
//              list view item.
//
//  Arguments:
//      hwndLv [in]
//      iItem  [in]
//
//  Returns:    A (non-AddRef'd) copy of the INetCfgComponent pointer
//              associated with the item.
//
//  Author:     shaunco   14 Dec 1997
//
//  Notes:      The returned value is NOT AddRef'd.
//
INetCfgComponent*
PComponentFromItemIndex (
    HWND hwndLv,
    int  iItem)
{
    INetCfgComponent* pComponent = NULL;
    LV_ITEM           item = {0};

    item.mask = LVIF_PARAM;
    item.iItem = iItem;
    if (ListView_GetItem (hwndLv, &item))
    {
        pComponent = (INetCfgComponent*)item.lParam;
        ASSERT (pComponent);
    }
    return pComponent;
}

//+---------------------------------------------------------------------------
//
//  Function:   PComponentFromCurSel
//
//  Purpose:
//
//  Arguments:
//      hwndLv [in]  Window handle of list view
//      piItem [out] Optional address of integer to receive selected item.
//
//  Returns:
//
//  Author:     shaunco   30 Dec 1997
//
//  Notes:
//
INetCfgComponent*
PComponentFromCurSel (
    HWND hwndLv,
    int* piItem)
{
    INetCfgComponent* pComponent = NULL;

    // Get the current selection if it exists.
    //
    int iItem = ListView_GetNextItem (hwndLv, -1, LVNI_SELECTED);
    if (-1 != iItem)
    {
        // Get the component associated with the current selection.  It must
        // exist.
        //
        pComponent = PComponentFromItemIndex (hwndLv, iItem);
        ASSERT (pComponent);
    }

    // Return the index of the item if requested.
    //
    if (piItem)
    {
        *piItem = iItem;
    }

    return pComponent;
}

//+---------------------------------------------------------------------------
//
//  Function:   PeQueryOrChangeComponentEnabled
//
//  Purpose:
//
//  Arguments:
//      pInfo      []
//      pComponent []
//      fChange    []
//      fNewValue  []
//
//  Returns:
//
//  Author:     shaunco   14 Dec 1997
//
//  Notes:
//
BOOL
NeQueryOrChangeComponentEnabled (
    PEINFO*             pInfo,
    INetCfgComponent*   pComponent,
    BOOL                fChange,
    BOOL                fValue)
{
    BOOL    fOldValue;
    GUID    guidClass;
    HRESULT hr;

    hr = INetCfgComponent_GetClassGuid (pComponent, &guidClass);
    if (SUCCEEDED(hr))
    {
        LPWSTR pszwId;
        hr = INetCfgComponent_GetId (pComponent, &pszwId);
        if (SUCCEEDED(hr))
        {
            // We handle protocols in a hard-coded (er, well known) fashion.
            //
            if (IsEqualGUID (&guidClass, &GUID_DEVCLASS_NETTRANS))
            {
                DWORD* pdwValue = &pInfo->pArgs->pEntry->dwfExcludedProtocols;

                // Check if the protocol is exluded.
                //
                DWORD dwProtocol = DwProtocolFromComponentId (pszwId);

                if (fChange)
                {
                    if (fValue)
                    {
                        // Include the protocol.  (By not explicitly excluding
                        // it.
                        //
                        *pdwValue &= ~dwProtocol;
                    }
                    else
                    {
                        // Exclude the protocol.  (Remember, its a list of
                        // excluded protocols.
                        //
                        *pdwValue |= dwProtocol;
                    }
                }
                else
                {
                    fValue = !(dwProtocol & *pdwValue);
                }
            }
            else
            {
                if (fChange)
                {
                    EnableOrDisableNetComponent (pInfo->pArgs->pEntry,
                        pszwId, fValue);
                }
                else
                {
                    // Default to enabled for the case whenthe value isn't
                    // found in the entry.  This will be the case for pre-NT5
                    // entries and entries that have not yet been to the
                    // Networking tab for edits.
                    //
                    BOOL fEnabled;
                    fValue = TRUE;
                    if (FIsNetComponentListed(pInfo->pArgs->pEntry,
                            pszwId, &fEnabled, NULL))
                    {
                        fValue = fEnabled;
                    }
                }
            }

            CoTaskMemFree (pszwId);
        }
    }
    return fValue;
}

VOID
NeEnableComponent (
    PEINFO*             pInfo,
    INetCfgComponent*   pComponent,
    BOOL                fEnable)
{
    NeQueryOrChangeComponentEnabled (pInfo, pComponent, TRUE, fEnable);
}

BOOL
NeIsComponentEnabled (
    PEINFO*             pInfo,
    INetCfgComponent*   pComponent)
{
    return NeQueryOrChangeComponentEnabled (pInfo, pComponent, FALSE, FALSE);
}

VOID
NeShowComponentProperties (
    IN PEINFO* pInfo)
{
    HRESULT hr;

    // Get the component for the current selection.
    //
    INetCfgComponent* pComponent;
    pComponent = PComponentFromCurSel (pInfo->hwndLvComponents, NULL);
    ASSERT (pComponent);

    if(NULL == pComponent)
    {   
        return;
    }

    // Create the UI info callback object if we haven't done so yet.
    // If this fails, we can still show properties.  TCP/IP just might
    // not know which UI-variant to show.
    //
    if (!pInfo->punkUiInfoCallback)
    {
        HrCreateUiInfoCallbackObject (pInfo, &pInfo->punkUiInfoCallback);
    }

    // Show the component's property UI.  If S_OK is returned, it means
    // something changed.
    //
    hr = INetCfgComponent_RaisePropertyUi (pComponent,
            pInfo->hwndDlg,
            NCRP_SHOW_PROPERTY_UI,
            pInfo->punkUiInfoCallback);

    if (S_OK == hr)
    {
        // Get the INetCfgComponentPrivate interface so we can query the
        // notify object directly.
        //
        INetCfgComponentPrivate* pPrivate;
        hr = INetCfgComponent_QueryInterface (pComponent,
                    &IID_INetCfgComponentPrivate,
                    (VOID**)&pPrivate);
        if (SUCCEEDED(hr))
        {
            // Get the INetRasConnectionIpUiInfo interface from the notify
            // object.
            //
            INetRasConnectionIpUiInfo* pIpUiInfo;
            hr = INetCfgComponentPrivate_QueryNotifyObject (pPrivate,
                    &IID_INetRasConnectionIpUiInfo,
                    (VOID**)&pIpUiInfo);
            if (SUCCEEDED(hr))
            {
                // Get the UI info from TCP/IP.
                //
                RASCON_IPUI info;
                hr = INetRasConnectionIpUiInfo_GetUiInfo (pIpUiInfo, &info);
                if (SUCCEEDED(hr))
                {
                    PBENTRY* pEntry = pInfo->pArgs->pEntry;

                    // Get rid of our current data before we copy the new
                    // data.
                    //
                    pEntry->dwIpAddressSource = ASRC_ServerAssigned;
                    pEntry->dwIpNameSource = ASRC_ServerAssigned;

                    Free0 (pEntry->pszIpAddress);
                    pEntry->pszIpAddress = NULL;

                    Free0 (pEntry->pszIpDnsAddress);
                    pEntry->pszIpDnsAddress = NULL;

                    Free0 (pEntry->pszIpDns2Address);
                    pEntry->pszIpDns2Address = NULL;

                    Free0 (pEntry->pszIpWinsAddress);
                    pEntry->pszIpWinsAddress = NULL;

                    Free0 (pEntry->pszIpWins2Address);
                    pEntry->pszIpWins2Address = NULL;

                    Free0 (pEntry->pszIpDnsSuffix);
                    pEntry->pszIpDnsSuffix = StrDup (info.pszwDnsSuffix);

                    if ((info.dwFlags & RCUIF_USE_IP_ADDR) &&
                        *info.pszwIpAddr)
                    {
                        pEntry->dwIpAddressSource = ASRC_RequireSpecific;
                        pEntry->pszIpAddress = StrDup (info.pszwIpAddr);
                    }
                    else
                    {
                        pEntry->dwIpAddressSource = ASRC_ServerAssigned;
                        Free0 (pEntry->pszIpAddress);
                        pEntry->pszIpAddress = NULL;
                    }

                    if (info.dwFlags & RCUIF_USE_NAME_SERVERS)
                    {
                        if (*info.pszwDnsAddr)
                        {
                            pEntry->dwIpNameSource = ASRC_RequireSpecific;
                            pEntry->pszIpDnsAddress = StrDup (info.pszwDnsAddr);
                        }
                        if (*info.pszwDns2Addr)
                        {
                            pEntry->dwIpNameSource = ASRC_RequireSpecific;
                            pEntry->pszIpDns2Address = StrDup (info.pszwDns2Addr);
                        }
                        if (*info.pszwWinsAddr)
                        {
                            pEntry->dwIpNameSource = ASRC_RequireSpecific;
                            pEntry->pszIpWinsAddress = StrDup (info.pszwWinsAddr);
                        }
                        if (*info.pszwWins2Addr)
                        {
                            pEntry->dwIpNameSource = ASRC_RequireSpecific;
                            pEntry->pszIpWins2Address = StrDup (info.pszwWins2Addr);
                        }
                    }

                    // pmay: 389632  
                    // 
                    // Use this convoluted logic to store something reasonable
                    // about the registration process.
                    //
                    if (info.dwFlags & RCUIF_USE_DISABLE_REGISTER_DNS)
                    {
                        pEntry->dwIpDnsFlags = 0;
                    }
                    else 
                    {
                        BOOL bSuffix = 
                            ((pEntry->pszIpDnsSuffix) && (*(pEntry->pszIpDnsSuffix)));
                            
                        pEntry->dwIpDnsFlags = DNS_RegPrimary;
                        
                        if (info.dwFlags & RCUIF_USE_PRIVATE_DNS_SUFFIX)
                        {
                            if (bSuffix)
                            {
                                pEntry->dwIpDnsFlags |= DNS_RegPerConnection;
                            }
                            else
                            {
                                pEntry->dwIpDnsFlags |= DNS_RegDhcpInform;
                            }
                        }
                    }

                    // 277478
                    // Enable the NBT over IP controls
                    //
                    if (info.dwFlags & RCUIF_ENABLE_NBT)
                    {
                        pEntry->dwIpNbtFlags = PBK_ENTRY_IP_NBT_Enable;
                    }
                    else
                    {
                        pEntry->dwIpNbtFlags = 0;
                    }
                                        
                    if (pInfo->pArgs->fRouter)
                    {
                        pEntry->fIpPrioritizeRemote = FALSE;
                    }
                    else
                    {
                        pEntry->fIpPrioritizeRemote  = info.dwFlags & RCUIF_USE_REMOTE_GATEWAY;
                    }                        
                    pEntry->fIpHeaderCompression = info.dwFlags & RCUIF_USE_HEADER_COMPRESSION;
                    pEntry->dwFrameSize = info.dwFrameSize;
                }
                ReleaseObj (pIpUiInfo);
            }

            ReleaseObj (pPrivate);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\pref.h ===
#ifndef _RASDLG_PREF_H
#define _RASDLG_PREF_H


#include "rasdlgp.h"
#include <commdlg.h>  // FileOpen dialog

// 
// Defines flags the modify the behavior of the user preferences
// dialog
//
#define UP_F_AutodialMode  0x1      // Come up with focus on autodial page
// For whistler 460931, used in pref.c
//
#define UP_F_ShowOnlyDiagnostic  0x00000002


/*----------------------------------------------------------------------------
** Local datatypes (alphabetically)
**----------------------------------------------------------------------------
*/

/* User Preferences property sheet argument block.
*/
typedef  struct tagUPARGS
{
    /* Caller's arguments to the stub API.
    */
    HLINEAPP hlineapp;
    BOOL     fIsUserAdmin;
    PBUSER*  pUser;
    PBFILE** ppFile;

    /* Stub API return value.
    */
    BOOL fResult;

    /* Flags that provide more info see UP_F_* values
    */
    DWORD dwFlags;
}UPARGS;


/* User Preferences property sheet context block.  All property pages refer to
** the single context block associated with the sheet.
*/
typedef  struct tagUPINFO
{
    /* Stub API arguments from UpPropertySheet.
    */
    UPARGS* pArgs;

    /* TAPI session handle.  Should always be addressed thru the pointer since
    ** the handle passed down from caller, if any, will be used instead of
    ** 'hlineapp'.
    */
    HLINEAPP  hlineapp;
    HLINEAPP* pHlineapp;

    /* Property sheet dialog and property page handles.  'hwndFirstPage' is
    ** the handle of the first property page initialized.  This is the page
    ** that allocates and frees the context block.
    */
    HWND hwndDlg;
    HWND hwndFirstPage;
    HWND hwndCo;
    HWND hwndGp;
    HWND hwndAd;
    HWND hwndCb;
    HWND hwndPl;
    HWND hwndDg; //For whistler 460931
    

    /* Auto-dial page.
    */
    HWND hwndLvEnable;
    HWND hwndEbAttempts;
    HWND hwndEbSeconds;
    HWND hwndEbIdle;

    BOOL fChecksInstalled;

    // Diagnostic page  for whistler 460931
    //
    HWND hwndDgCbEnableDiagLog;
    HWND hwndDgPbClear;
    HWND hwndDgPbExport;
    BOOL fEnableLog;
    DiagnosticInfo  diagInfo;  
    BOOL fShowOnlyDiagnostic;


    /* Callback page.
    */
    HWND hwndRbNo;
    HWND hwndRbMaybe;
    HWND hwndRbYes;
    HWND hwndLvNumbers;
    HWND hwndPbEdit;
    HWND hwndPbDelete;

    /* Phone list page.
    */
    HWND hwndRbSystem;
    HWND hwndRbPersonal;
    HWND hwndRbAlternate;
    HWND hwndClbAlternates;
    HWND hwndPbBrowse;

    /* Working data read from and written to registry with phonebook library.
    */
    PBUSER user;        // Current user
    PBUSER userLogon;   // Logon preferences
}UPINFO;

UPINFO*
UpContext(
    IN HWND hwndPage );

VOID
UpExitInit(
    IN HWND hwndDlg );

DWORD
APIENTRY
RasUserPrefDiagOnly (
    HWND hwndParent,
    BOOL * pbCommit);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\rasdlgrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rasdlg.rc
//
#define BID_Dialer                      100
#define BID_Wizard                      101
#define BID_WizardHeader                102
#define DID_AN_AlternateNumbers         102
#define DID_AQ_AutoDialQuery            103
#define DID_BE_BundlingErrors           104
#define DID_CA_CustomAuth               105
#define DID_CC_ConnectComplete          106
#define DID_CE_ComplexPhoneEditor       107
#define DID_CP_ChangePassword           108
#define DID_CP_ChangePassword2          109
#define DID_DC_DialCallback             110
#define DID_DE_DialError                111
#define DID_DM_DialingMultipleLines     112
#define DID_DP_DialProgress             113
#define DID_DQ_DisableAutoDialQuery     114
#define DID_DR_DialerNL                 115
#define DID_DR_DialerU                  116
#define DID_DR_DialerUD                 117
#define DID_DR_DialerUDN                118
#define DID_DR_DialerUN                 119
#define DID_ES_EncryptionSettings       120
#define DID_IC_IsdnConfigure            121
#define DID_IC_IsdnConfigureMlink       122
#define DID_IT_SlipTerminal             123
#define DID_IT_Terminal                 124
#define DID_MC_ModemConfigure           125
#define DID_NE_AddComponent             126
#define DID_NW_NwcConnections           127
#define DID_OD_OperatorDial             128
#define DID_PR_ProjectionResult         129
#define DID_XS_X25Settings              133
#define IID_DnArr                       134
#define IID_DnArrDis                    135
#define IID_UpArr                       144
#define IID_UpArrDis                    145
#define PID_AD_AutoDial                 146
//#define                                 147
#define PID_CB_CallbackSettings         148
#define PID_DI_RouterDialIn             149
#define PID_DO_RouterDialOut            150
#define PID_EN_EntryName                153
#define PID_GE_GeneralMultiple          155
#define PID_GE_GeneralSingle            156
//#define                                 157
//#define                                 158
#define PID_IN_InterfaceName            160
#define PID_LO_Security                 162
#define PID_MA_ModemAdapter             163
#define PID_NE_Network                  165
#define PID_NS_RouterNameServers        166
#define PID_OE_Options                  167
#define PID_PA_PhoneNumber              168
#define PID_PL_PhoneList                169
#define PID_PL_PhoneListLogon           170
#define PID_RA_RouterIpAddress          171
#define PID_RC_RouterScripting          172
//#define                                 173
#define PID_RD_Router                   174
#define PID_RF_RouterFinish             175
#define PID_RN_RouterModemAdapter       179
#define PID_RP_RouterPhoneNumber        180
#define PID_SE_RouterSecuritySettings   181
#define PID_SE_SecuritySettings         182
#define PID_SS_ServerSettings           183
#define PID_ST_Start                    184
#define PID_US_Users                    186
#define SID_AQ_DoNotDialLabel           187
#define SID_AQ_Text                     188
#define SID_AddAlternateTitle           189
#define SID_AuthAny                     190
#define SID_DialOnlyFirst               190
#define SID_AuthCustom                  191
#define SID_DialAll                     191
#define SID_AuthEncrypted               192
#define SID_DialNeeded                  192
#define SID_AuthExplain                 193
#define SID_AuthMsEncrypted             194
#define SID_BadAreaCode                 195
#define SID_BadEntry                    196
#define SID_BadIpAddrRange              197
#define SID_CannotLoadConfigDll         198
#define SID_CantHangUpRouter            199
#define SID_CommentColHead              200
#define CID_CA_CB_W95MsChap             200
#define SID_ConfigDllApiFailed          201
#define SID_ConfigureIp                 202
#define SID_ConfigureIpx                203
#define SID_ConfirmDelDevice            204
#define SID_ConfirmDelEntry             205
#define SID_ConfirmHangUp               206
#define SID_ConfirmShortcut             207
#define SID_ConfirmViewScriptLog        208
#define SID_ConnectComplete             209
#define SID_ConnectComplete1            210
#define SID_AuthPassword                211
#define SID_Connected                   212
#define SID_CustomAuthConfigRequired    213
#define SID_CutDefExt                   214
#define SID_CutDescription              215
#define SID_CutFilter                   216
#define SID_CutTitle                    217
#define SID_DE_LinkFailed               218
#define SID_DS_CantGetFraming           219
#define SID_DS_CantGetPortInfo          220
#define SID_DS_CantGetProjection        221
#define SID_DS_CantGetRasconnList       222
#define SID_DS_Client                   223
#define SID_DS_Details                  224
#define SID_DS_Device                   225
#define SID_DS_Network                  226
#define SID_DS_NotConnected             227
#define SID_DU_Dial                     228
#define SID_DU_HangUp                   229
#define SID_DefaultEntryName            230
#define SID_DefaultModemSettings        231
#define SID_DefaultPort                 232
#define SID_DefaultRouterEntryName      233
#define SID_DeviceColHead               234
#define SID_DialOutUserName             235
#define SID_DuplicateEntry              236
#define SID_EC_Subtitle                 237
#define SID_EC_Title                    238
#define SID_EN_Subtitle                 239
#define SID_EN_Title                    240
#define SID_EcbnLabel                   241
#define SID_EcbnTitle                   242
#define SID_EditAlternateTitle          243
#define SID_EditConnected               244
#define SID_EmptyLogonPb                245
#define SID_EmptyPhonebook              246
#define SID_EncryptionBanned            247
#define SID_EnterX25Address             248
#define SID_FMT_Error                   249
#define SID_FMT_ErrorMsg                250
#define SID_FMT_ErrorMsgDiag            251
#define SID_FMT_ErrorMsgExt             252
#define SID_FMT_ErrorMsgF1              253
#define SID_FMT_ErrorMsgName            254
#define SID_FMT_ErrorMsgProject         255
#define SID_FMT_ErrorMsgResp            256
#define SID_FMT_FailCode                257
#define SID_FMT_Name                    258
#define SID_FMT_ProjectError            259
#define SID_FMT_ProjectOk               260
#define SID_FP_Subtitle                 261
#define SID_FP_Title                    262
#define SID_FinishWizard                263
#define SID_HelpFile                    264
#define SID_HuntCheckLabel              265
#define SID_HuntItemLabel               266
#define SID_HuntListLabel               267
#define SID_HuntTitle                   268
#define SID_IA_Subtitle                 269
#define SID_IA_Title                    270
#define SID_InternetWithoutIp           271
#define SID_Ip                          272
#define SID_IpsecDefault                273
#define SID_Ipx                         274
#define SID_IsCurLoc                    275
#define SID_Isdn                        276
#define SID_IsdnAdapter                 277
#define SID_IsdnLineType0               278
#define SID_IsdnLineType1               279
#define SID_IsdnLineType2               280
#define SID_LG_Subtitle                 281
#define SID_LG_Title                    282
#define SID_LS_PercentFmt               283
#define SID_LinkPhoneNumber             284
#define SID_LocationItemLabel           285
#define SID_LocationListLabel           286
#define SID_LocationTitle               287
#define SID_MA_Subtitle                 288
#define SID_MA_Title                    289
#define SID_MlinkNeedsPpp               290
#define SID_Modem                       291
#define SID_ModemNotInstalled           292
#define SID_Mppe128bit                  293
#define SID_Mppe40bit                   294
#define SID_MultiLink                   295
#define SID_MultiLinkNumber             296
#define SID_NA_Subtitle                 297
#define SID_NA_Title                    298
#define SID_NR_FT_Amb                   299
#define SID_NR_FT_Ppp                   300
#define SID_NR_FT_PppLcp                301
#define SID_NR_FT_Slip                  302
#define SID_Nbf                         303
#define SID_NewPhonebook                304
#define SID_NoAltPath                   305
#define SID_NoConfigure                 306
#define SID_NoDeleteConnected           307
#define SID_NoEntrySelected             308
#define SID_NoIpAddress                 309
#define SID_NoX25Address                310
#define SID_NoneSelected                311
#define SID_NotUnique                   312
#define SID_AuthPasswordAndData         313
#define SID_NpNotInstalled              314
#define SID_OP_CachePw                  315
#define SID_OP_DisplayData              316
#define SID_OP_GetADialInfo             317
#define SID_OP_LoadDlg                  318
#define SID_OP_UnshareConnection        319
#define SID_OP_LoadPage                 320
#define SID_OP_LoadPhonebook            321
#define SID_OP_LoadPortInfo             322
#define SID_OP_LoadPrefs                323
#define SID_OP_LoadScriptInfo           324
#define SID_OP_LoadScriptLog            325
#define SID_OP_LoadSwitchEditor         326
#define SID_OP_LoadTapiInfo             327
#define SID_OP_LoadX25Info              328
#define SID_OP_MakePhonebook            329
#define SID_OP_ShareConnection          330
#define SID_OP_RasDial                  331
#define SID_OP_RasGetBuffer             332
#define SID_OP_RasGetInfo               333
#define SID_OP_RasGetProtocolInfo       334
#define SID_OP_RasPortReceive           335
#define SID_OP_RasPortSend              336
#define SID_OP_RetrievingData           337
#define SID_OP_SaveTapiInfo             338
#define SID_OP_SavingData               339
#define SID_OP_ScriptHalted             340
#define SID_OP_ScriptHaltedOnError      341
#define SID_OP_SetADialInfo             342
#define SID_OP_UncachePw                343
#define SID_OP_WritePhonebook           344
#define SID_OP_WritePrefs               345
#define SID_OP_WriteShortcutFile        346
#define SID_OkLabel                     347
#define SID_PA_Subtitle                 348
#define SID_PA_Title                    349
#define SID_PasswordMismatch            350
#define SID_PasswordsDontMatch          351
#define SID_PbkDefExt                   352
#define SID_PbkDescription              353
#define SID_PbkFilter                   354
#define SID_PbkTitle                    355
#define SID_PeTitleClone                356
#define SID_PeTitleEdit                 357
#define SID_PeTitleNew                  358
#define SID_PhoneNumberColHead          359
#define SID_PhoneNumbersColHead         360
#define SID_PopupTitle                  361
#define SID_PppNeedsProtocol            362
#define SID_PppWithoutProtocol          363
#define SID_PrefixItemLabel             364
#define SID_PrefixListLabel             365
#define SID_PrefixTitle                 366
#define SID_ProjectionResult1           367
#define SID_ProjectionResult2           368
#define SID_ProtocolsInfo               369
#define SID_SavePasswordFrndly          370
#define SID_RasNeedsNbf                 405
#define SID_RasWithoutNbf               406
#define SID_RedialLabel                 407
#define SID_RemoveCP                    408
#define SID_SW_Title                    409
#define SID_RouterDialInAccount         410
#define SID_RouterDialOut               411
#define SID_RouterHelpFile              412
#define SID_RouterHuntCheckLabel        413
#define SID_RouterHuntItemLabel         414
#define SID_RouterHuntListLabel         415
#define SID_RouterHuntTitle             416
#define SID_ST_Ppp                      417
#define SID_DataEncNone                 418
#define SID_ST_Slip                     419
#define SID_S_AllDevicesConnected       420
#define SID_S_AuthAck                   421
#define SID_S_AuthCallback              422
#define SID_S_AuthChangePassword        423
#define SID_S_AuthLinkSpeed             424
#define SID_S_AuthNotify                425
#define SID_S_AuthProject               426
#define SID_S_AuthRetry                 427
#define SID_S_Authenticate              428
#define SID_S_Authenticated             429
#define SID_S_ConnectDevice             430
#define SID_S_ConnectModemNoNum         431
#define SID_S_ConnectModemOperator      432
#define SID_S_ConnectNull               433
#define SID_S_ConnectNumber             434
#define SID_S_ConnectPad                435
#define SID_S_ConnectPostSwitch         436
#define SID_S_ConnectPreSwitch          437
#define SID_S_Connected                 438
#define SID_S_DeviceConnected           439
#define SID_S_Disconnected              440
#define SID_S_ModemConnected            441
#define SID_S_NullConnected             442
#define SID_S_OpenPort                  443
#define SID_S_PadConnected              444
#define SID_S_PortOpened                445
#define SID_S_PostSwitchConnected       446
#define SID_S_PreSwitchConnected        447
#define SID_S_PrepareForCallback        448
#define SID_S_Projected                 449
#define SID_S_ReAuthenticate            450
#define SID_S_SubConnected              451
#define SID_S_Unknown                   452
#define SID_S_WaitForCallback           453
#define SID_S_WaitForModemReset         454
#define SID_SavePreview                 455
#define SID_ScpDefExt                   456
#define SID_ScpFilter                   457
#define SID_ScpFilterDesc               458
#define SID_ScpTitle                    459
#define SID_SelectOneLink               460
#define SID_SharedPhoneNumber           461
#define SID_SlipNeedsIp                 462
#define SID_SlipWithoutIp               463
#define SID_StatusColHead               464
#define SID_SuffixItemLabel             465
#define SID_SuffixListLabel             466
#define SID_SuffixTitle                 467
#define SID_TC_Subtitle                 468
#define SID_TC_Title                    469
#define SID_T_ManualDialTerminal        470
#define SID_T_PostconnectTerminal       471
#define SID_T_PreconnectTerminal        472
#define SID_T_SlipTerminal              473
#define SID_Time10m                     474
#define SID_Time10s                     475
#define SID_Time1h                      476
#define SID_Time1m                      477
#define SID_Time24h                     478
#define SID_Time2h                      479
#define SID_Time2m                      480
#define SID_Time30m                     481
#define SID_Time30s                     482
#define SID_Time3s                      483
#define SID_Time4h                      484
#define SID_Time4m                      485
#define SID_Time5m                      486
#define SID_Time5s                      487
#define SID_Time8h                      488
#define SID_TimeNever                   489
#define SID_US_Subtitle                 490
#define SID_US_Title                    491
#define SID_UnMultiLink                 492
#define SID_UnknownDevice               493
//#define                                 494
#define SID_UpTitle                     495
#define SID_X25                         496
#define SID_X25Pad                      497
#define DID_UA_RetryAuthenticationU     498
#define SID_SW_Subtitle                 498
#define SID_DA_Title                    499
#define DID_UA_RetryAuthenticationUD    500
#define SID_OP_EnableDemandDial         500
#define SID_DA_Subtitle                 501
#define DID_NE_PppSettings              502
#define SID_OP_DisableDemandDial        502
#define SID_PN_Title                    503
#define SID_PN_Subtitle                 504
#define SID_DefaultVpnPort              505
#define CID_BM_Wizard                   506
#define SID_SP_Title                    506
#define SID_SP_Subtitle                 507
#define SID_GH_Title                    508
#define PID_GH_GuestHost                509
#define SID_ChangeSharedConnection      509
#define SID_GH_Subtitle                 510
#define PID_DN_DccDevice                511
#define SID_EnableSharedAccess          511
#define SID_DN_Title                    512
#define SID_DN_Subtitle                 513
#define SID_ConnectButton               514
#define SID_DataEncServerDetermine      515
#define SID_DataEncAlways               516
#define SID_DataEncMppe40               517
#define SID_DataEncMppe128              518
#define SID_MschapOrEapRequired         519
#define SID_CustAuthMsgTitle            520
#define SID_AuthVpnNormal               521
#define SID_S_ConnectVpn                521
#define SID_AuthVpnSecure               522
#define SID_CN_Title                    522
#define SID_ST_VpnAuto                  523
#define SID_ST_VpnPptp                  524
#define SID_ST_VpnL2tp                  525
#define SID_LA_Subtitle                 526
#define SID_LA_Title                    527
#define PID_CO_Connections              528
#define SID_DialerHelpCmdLine           528
#define SID_DefaultVpnEntryName         529
#define SID_LO_DescPhysAny              530
#define SID_LO_DescPhysPassword         531
#define DID_CR_CallbackRouter           532
#define SID_TypeEntryName               532
#define SID_LO_DescPhysPassData         533
#define PID_OE_OptionsRouter            534
#define SID_TypePortNumber              534
#define SID_LO_DescPhysCustom           535
#define SID_LO_DescVpnNormal            536
#define SID_LO_DescVpnSecure            537
#define SID_LO_DescVpnCustom            538
#define DID_DR_DialerI                  539
#define SID_DuplicatePortNumber         539
#define DID_DR_DialerIN                 540
#define SID_TypeResponseList            540
#define DID_DR_DialerINL                541
#define SID_NoDeleteSelection           541
#define SID_Time1s                      542
#define SID_NoModifySelection           543
#define PID_SW_SharedAccess             544
#define PID_SP_SharedLan                545
#define PID_SC_SmartCard                546
#define PID_RW_RouterWelcome            547
#define PID_CT_RouterConnectionType     548
#define SID_CN_SubtitleDccGuest         549
#define PID_VD_RouterVpnDestination     550
#define DID_DR_DialerID                 551
#define DID_DR_DialerIDN                552
#define DID_DR_DialerIDNL               553
#define PID_GE_RouterGeneralMultiple    554
#define PID_GE_RouterGeneralSingle      555
#define DID_SA_Application              556
#define DID_SS_Service                  557
#define PID_SA_SharedAccessApplications 558
#define PID_SS_SharedAccessServices     559
#define DID_VI_VpnInitial               560
#define IID_Dun1                        562
#define IID_Broadband                   563
#define PID_BS_BroadbandService         567
#define PID_GE_GeneralBroadband         568
#define PID_LO_SecurityVpn              569
#define DID_CI_CustomIPSec              570
#define PID_FW_FirewallLogging          571
#define PID_FW_ICMP                     572
#define PID_SA_HomenetUnavailable       574
#define CID_SA_ST_ErrorText             575
#define SID_Time20m                     576
#define PID_CN_ConnectionName           577
#define SID_CN_SubtitleWork             579
#define PID_VT_RouterVpnType            580
#define SID_NetworkApplicationSettings  581
#define SID_CN_HMsgWork                 582
#define SID_CN_HMsgDccGuest             583
#define SID_CN_HMsgInternet             584
#define SID_CN_SubtitleInternet         585
#define SID_SS_TypeAddress              586
#define SID_SharedAccessSettings        587
#define SID_BadEntryWithDot             588
#define SID_PropertiesHeader            589
#define PID_SR_StaticRoute              590
#define DID_SR_StaticRoute              591
#define PID_DG_Diagnostics              592
#define DID_EL_ExportLog                593
#define DID_PB_Progress                 594
#define DID_DR_DialerB                  595
//#define                                 1001
//#define                                 1002
//#define                                 1003
#define CID_AD_LV_Enable                1004
//#define                                 1005
#define CID_AD_ST_Enable                1006
//#define                                 1007
//#define                                 1008
//#define                                 1009
#define CID_AN_CB_MoveToTop             1010
#define CID_AN_CB_TryNextOnFail         1011
#define CID_AN_LV_Numbers               1012
#define CID_AN_PB_Add                   1013
#define CID_AN_PB_Delete                1014
#define CID_AN_PB_Down                  1015
#define CID_AN_PB_Edit                  1016
#define CID_AN_PB_Up                    1017
#define CID_AN_ST_Explain               1018
#define CID_AN_ST_Numbers               1019
#define CID_AQ_CB_AlwaysPrompt          1020
#define CID_AQ_CB_DisableAutoDialForSession 1021
#define CID_AQ_I_DialUp                 1022
#define CID_AQ_CB_DisableAutoDial       1022
#define CID_AQ_CB_DisableThisSession    1022
#define CID_AQ_LB_DialFrom              1023
#define CID_AQ_PB_Dial                  1024
#define CID_AQ_PB_DoNotDial             1025
#define CID_AQ_PB_Expand                1026
#define CID_AQ_PB_Settings              1026
#define CID_AQ_ST_DialFrom              1027
#define CID_AQ_ST_Separator             1028
#define CID_AQ_ST_Text                  1029
#define CID_BE_CB_DisableLink           1030
#define CID_BE_I_Information            1031
#define CID_BE_LV_Errors                1032
#define CID_BE_ST_Text                  1033
#define CID_CA_LB_Packages              1034
#define CID_CA_LB_EapPackages           1034
#define CID_CA_PB_Properties            1035
#define CID_CA_ST_Packages              1036
#define CID_CB_LV_Numbers               1037
#define CID_CB_PB_Delete                1038
#define CID_CB_PB_Edit                  1039
#define CID_CB_RB_Maybe                 1040
#define CID_CB_RB_No                    1041
#define CID_CB_RB_Yes                   1042
#define CID_CB_ST_Explain               1043
#define CID_CC_CB_SkipMessage           1045
#define CID_CC_I_Rasmon                 1046
#define CID_CC_ST_Text                  1047
#define CID_CE_CB_UseDialingRules       1048
#define CID_CE_CLB_AreaCodes            1049
#define CID_CE_EB_Comment               1050
#define CID_CE_EB_PhoneNumber           1051
#define CID_CE_GB_Comment               1052
#define CID_CE_GB_PhoneNumber           1053
#define CID_CE_LB_CountryCodes          1054
#define CID_CE_ST_AreaCodes             1055
#define CID_CE_ST_CountryCodes          1056
#define CID_CE_ST_PhoneNumber           1057
#define CID_CP_EB_ConfirmPassword       1058
#define CID_CP_EB_OldPassword           1059
#define CID_CP_EB_Password              1060
#define CID_CP_ST_ConfirmPassword       1061
#define CID_CP_ST_Explain               1062
#define CID_CP_ST_OldPassword           1063
#define CID_CP_ST_Password              1064
#define CID_DC_EB_Number                1065
#define CID_DC_ST_Explain               1066
#define CID_DC_ST_Number                1067
#define CID_DE_I_Exclamation            1068
#define CID_DE_PB_More                  1069
#define CID_DE_ST_Text                  1070
#define CID_DI_EB_Confirm               1071
#define CID_DI_EB_Domain                1072
#define CID_DI_EB_Password              1073
#define CID_DI_EB_UserName              1074
#define CID_DI_ST_Confirm               1075
#define CID_DI_ST_Domain                1076
#define CID_DI_ST_Password              1077
#define CID_DI_ST_UserName              1078
#define CID_DM_LB_DialPercent           1079
#define CID_DM_LB_DialTime              1080
#define CID_DM_LB_HangUpPercent         1081
#define CID_DM_LB_HangUpTime            1082
#define CID_DM_ST_Dial                  1083
#define CID_DM_ST_DialOrMore            1084
#define CID_DM_ST_Explain               1085
#define CID_DM_ST_HangUp                1086
#define CID_DM_ST_HangUpOrLess          1087
#define CID_DO_EB_Confirm               1088
#define CID_DO_EB_Domain                1089
#define CID_DO_EB_Password              1090
#define CID_DO_EB_UserName              1091
#define CID_DO_ST_Confirm               1092
#define CID_DO_ST_Domain                1093
#define CID_DO_ST_Explain               1094
#define CID_DO_ST_Password              1095
#define CID_DO_ST_UserName              1096
#define CID_DP_ST_State                 1097
#define CID_DQ_I_DialUp                 1098
#define CID_DQ_ST_Text                  1099
#define CID_DR_BM_Useless               1100
#define CID_DR_CB_SavePassword          1101
#define CID_DR_EB_Domain                1102
#define CID_DR_EB_Password              1103
#define CID_DR_EB_User                  1104
#define CID_DR_PB_Properties            1107
#define CID_DR_PB_Rules                 1108
#define CID_DR_ST_Domain                1110
#define CID_DR_ST_Password              1112
#define CID_EN_EB_EntryName             1114
#define CID_ES_LB_Encryptions           1115
#define CID_ES_ST_Encryptions           1116
#define CID_GE_CB_SharedPhoneNumber     1119
#define CID_GE_CB_ShowIcon              1120
#define CID_GE_CB_UseDialingRules       1121
#define CID_GE_CLB_AreaCodes            1122
#define CID_GE_EB_PhoneNumber           1123
#define CID_GE_GB_ConnectUsing          1124
#define CID_GE_GB_PhoneNumber           1125
#define CID_GE_LB_CountryCodes          1126
#define CID_GE_LV_Device                1127
#define CID_GE_LV_Devices               1128
#define CID_GE_PB_Alternates            1129
#define CID_GE_PB_Configure             1130
#define CID_GE_PB_MoveDown              1131
#define CID_GE_PB_MoveUp                1132
#define CID_GE_ST_AreaCodes             1133
#define CID_GE_ST_CountryCodes          1134
#define CID_GE_ST_PhoneNumber           1135
#define CID_GP_CB_AutodialPrompt        1136
#define CID_GE_PB_DialingRules          1136
//#define                                 1137
//#define                                 1138
//#define                                 1139
//#define                                 1140
//#define                                 1141
//#define                                 1142
//#define                                 1143
//#define                                 1144
#define CID_IC_CB_Compression           1148
#define CID_IC_CB_DownLevel             1149
#define CID_IC_CB_Fallback              1150
#define CID_IC_EB_Channels              1151
#define CID_IC_GB_DownLevel             1152
#define CID_IC_LB_LineType              1153
#define CID_IC_ST_Channels              1154
#define CID_IC_ST_LineType              1155
#define CID_IN_CB_SkipWizard            1156
#define CID_IN_EB_InterfaceName         1157
#define CID_IN_ST_Explain               1158
#define CID_IN_ST_InterfaceName         1159
#define CID_IT_CC_IpAddress             1160
#define CID_IT_EB_Screen                1161
#define CID_IT_PB_BogusButton           1162
#define CID_IT_ST_IpAddress             1163
#define CID_LO_CB_Encryption            1169
#define CID_LO_CB_PreviewDomain         1170
#define CID_LO_CB_PreviewUserPw         1171
#define CID_LO_CB_RunScript             1172
#define CID_LO_CB_Terminal              1173
#define CID_LO_CB_UseWindowsPw          1174
#define CID_LO_CB_WindowsLogon          1174
#define CID_LO_GB_Encryption            1175
#define CID_LO_GB_Password              1176
#define CID_LO_GB_Scripting             1177
#define CID_LO_LB_Auths                 1178
#define CID_LO_LB_Authentication        1178
#define CID_LO_LB_Scripts               1179
#define CID_LO_PB_AuthSettings          1180
#define CID_LO_PB_Advanced              1180
#define CID_LO_PB_Browse                1181
#define CID_LO_PB_Edit                  1182
#define CID_LO_PB_EncryptionSettings    1183
#define CID_LS_EB_Condition             1184
#define CID_LS_EB_Response              1185
#define CID_LS_GB_ConnStats             1186
#define CID_LS_GB_DevStats              1187
#define CID_LS_GB_Errors                1188
#define CID_LS_LB_Devices               1189
#define CID_LS_PB_Details               1190
#define CID_LS_PB_HangUp                1191
#define CID_LS_PB_Reset                 1192
#define CID_LS_SL_Condition             1193
#define CID_LS_SL_ConnInBytes           1194
#define CID_LS_SL_ConnOutBytes          1195
#define CID_LS_SL_ConnectTime           1196
#define CID_LS_SL_DevInBytes            1197
#define CID_LS_SL_DevOutBytes           1198
#define CID_LS_SL_Devices               1199
#define CID_LS_SL_ErrAlignment          1200
#define CID_LS_SL_ErrBufOverruns        1201
#define CID_LS_SL_ErrCRC                1202
#define CID_LS_SL_ErrFraming            1203
#define CID_LS_SL_ErrHwOverruns         1204
#define CID_LS_SL_ErrTimeout            1205
#define CID_LS_SL_InCompRatio           1206
#define CID_LS_SL_InFrames              1207
#define CID_LS_SL_LineSpeed             1208
#define CID_LS_SL_OutCompRatio          1209
#define CID_LS_SL_OutFrames             1210
#define CID_LS_ST_ConnInBytes           1211
#define CID_LS_ST_ConnOutBytes          1212
#define CID_LS_ST_ConnectTime           1213
#define CID_LS_ST_DevInBytes            1214
#define CID_LS_ST_DevOutBytes           1215
#define CID_LS_ST_ErrAlignment          1216
#define CID_LS_ST_ErrBufOverruns        1217
#define CID_LS_ST_ErrCRC                1218
#define CID_LS_ST_ErrFraming            1219
#define CID_LS_ST_ErrHwOverruns         1220
#define CID_LS_ST_ErrTimeout            1221
#define CID_LS_ST_InCompRatio           1222
#define CID_LS_ST_InFrames              1223
#define CID_LS_ST_LineSpeed             1224
#define CID_LS_ST_OutCompRatio          1225
#define CID_LS_ST_OutFrames             1226
#define CID_LS_ST_Response              1227
#define CID_MA_LV_Devices               1228
#define CID_MC_CB_Compression           1229
#define CID_MC_CB_EnableSpeaker         1230
#define CID_MC_CB_ErrorControl          1231
#define CID_MC_CB_FlowControl           1232
#define CID_MC_CB_RunScript             1233
#define CID_MC_CB_Terminal              1234
#define CID_MC_EB_ModemValue            1235
#define CID_MC_GB_BeforeDial            1236
#define CID_MC_GB_Features              1237
#define CID_MC_I_Modem                  1238
#define CID_MC_LB_MaxBps                1239
#define CID_MC_LB_Scripts               1240
#define CID_MC_PB_Browse                1241
#define CID_MC_PB_Edit                  1242
#define CID_MC_ST_MaxBps                1243
#define CID_MC_ST_ModemProtocol         1244
#define CID_MC_LB_ModemProtocol         1245
#define CID_NE_LB_ComponentDesc         1250
#define CID_NE_LV_Components            1251
#define CID_NE_PB_Add                   1252
#define CID_NE_PB_Properties            1253
#define CID_NE_PB_Remove                1254
#define CID_NR_SL_Framing               1255
#define CID_NR_SL_IpAddress             1256
#define CID_NR_SL_IpServer              1257
#define CID_NR_SL_Ipx                   1258
#define CID_NR_SL_IpxNetNumber          1259
#define CID_NR_SL_IpxNodeID             1260
#define CID_NR_SL_NbfName               1261
#define CID_NR_SL_NetBeui               1262
#define CID_NR_SL_Tcpip                 1263
#define CID_NR_ST_Framing               1264
#define CID_NR_ST_IpAddress             1265
#define CID_NR_ST_IpServer              1266
#define CID_NR_ST_IpxNetNumber          1267
#define CID_NR_ST_IpxNodeID             1268
#define CID_NR_ST_NameString            1269
#define CID_NR_ST_NameTitle             1270
#define CID_NR_ST_NbfName               1271
#define CID_NS_CC_Dns                   1272
#define CID_NS_CC_Wins                  1273
#define CID_NS_ST_Dns                   1274
#define CID_NS_ST_Explain               1275
#define CID_NS_ST_Wins                  1276
#define CID_NW_CB_SkipPopup             1277
#define CID_NW_I_Exclamation            1278
#define CID_NW_ST_Explain1              1279
#define CID_NW_ST_Explain2              1280
#define CID_OD_ST_Explain               1281
#define CID_OD_ST_PhoneNumber           1282
#define CID_OD_ST_PhoneNumberValue      1283
#define CID_OE_CB_DisplayProgress       1284
#define CID_OE_CB_PreviewNumber         1285
#define CID_OE_CB_RedialOnDrop          1286
#define CID_OE_EB_RedialAttempts        1287
#define CID_OE_GB_MultipleDevices       1288
#define CID_OE_GB_Progress              1289
#define CID_OE_GB_Redial                1290
#define CID_OE_LB_IdleTimes             1291
#define CID_OE_LB_RedialTimes           1292
#define CID_OE_PB_Configure             1293
#define CID_OE_PB_Tunnel                1294
#define CID_OE_PB_X25                   1295
#define CID_OE_RB_DialAll               1296
#define CID_OE_CB_PromptBeforeDialing   1296
#define CID_OE_RB_DialNeeded            1297
#define CID_OE_CB_IncludeDomain         1297
#define CID_OE_RB_DialOnlyFirst         1298
#define CID_OE_ST_IdleTimes             1299
#define CID_OE_ST_RedialAttempts        1300
#define CID_OE_ST_RedialTimes           1301
#define CID_PA_CB_UseAreaCountry        1302
#define CID_OE_PB_Callback              1302
#define CID_PA_CLB_Area                 1303
#define CID_PA_EB_Number                1304
#define CID_PA_LB_Country               1305
#define CID_PA_ST_Area                  1306
#define CID_PA_ST_Country               1307
#define CID_PA_ST_Number                1308
#define CID_PF_GB_PlaySound             1309
#define CID_PF_GB_ShowLights            1310
#define CID_PF_PB_Lights                1311
#define CID_PF_PB_OnConnect             1312
#define CID_PF_PB_OnDisconnect          1313
#define CID_PF_PB_OnLineError           1314
#define CID_PF_PB_OnTransmission        1315
#define CID_PF_PB_Tasklist              1316
#define CID_PF_PB_Titlebar              1317
#define CID_PF_PB_Topmost               1318
#define CID_PF_RB_Desktop               1319
#define CID_PF_RB_Taskbar               1320
#define CID_PL_CL_Lists                 1321
#define CID_PL_PB_Browse                1322
#define CID_PL_RB_AlternateList         1323
#define CID_PL_RB_PersonalList          1324
#define CID_PL_RB_SystemList            1325
#define CID_PL_ST_Open                  1326
#define CID_PR_CB_DisableProtocols      1327
#define CID_PR_I_Information            1328
#define CID_PR_ST_Text                  1329
#define CID_RA_CC_Ip                    1330
#define CID_RA_ST_Explain               1331
#define CID_RA_ST_Ip                    1332
#define CID_RA_ST_Note                  1333
#define CID_RC_LB_Scripts               1334
#define CID_RC_PB_Edit                  1335
#define CID_RC_PB_Refresh               1336
#define CID_RC_RB_None                  1337
#define CID_RC_RB_Script                1338
#define CID_RC_ST_Explain               1339
#define CID_RD_EB_Attempts              1340
#define CID_RD_EB_Idle                  1341
#define CID_RD_EB_Seconds               1342
#define CID_RD_GB_DemandDial            1343
#define CID_RD_GB_DialingPolicy         1344
#define CID_RD_PB_Callback              1345
#define CID_RD_PB_MultipleLines         1346
#define CID_RD_RB_DemandDial            1347
#define CID_RD_RB_Persistent            1348
#define CID_RD_ST_Attempts              1349
#define CID_RD_ST_Idle                  1350
#define CID_RD_ST_Seconds               1351
#define CID_RF_ST_Explain               1352
#define CID_RF_ST_Interface             1353
#define CID_RF_ST_Note                  1354
#define CID_RN_LV_Devices               1355
#define CID_RF_ST_Note2                 1355
#define CID_RN_ST_Device                1356
#define CID_RN_ST_Explain               1357
#define CID_RP_EB_Number                1358
#define CID_RP_PB_Alternates            1359
#define CID_RP_ST_Explain               1360
#define CID_RP_ST_Number                1361
#define CID_SE_CB_AuthenticateServer    1362
#define CID_SE_CB_RequireDataEncryption 1363
#define CID_SE_CB_RequireStrongDataEncryption 1364
#define CID_SE_CB_SecureLocalFiles      1365
#define CID_SE_CB_UseLogonCredentials   1366
#define CID_SE_GB_AuthEncryption        1367
#define CID_SE_PB_Advanced              1368
#define CID_SE_PB_UnsavePw              1369
#define CID_SE_RB_AnyAuth               1370
#define CID_SE_RB_EncryptedAuth         1373
#define CID_SE_RB_MsEncryptedAuth       1374
#define CID_SL_LV_Devices               1375
#define CID_SL_PB_Header                1376
#define CID_SL_SL_Devices               1377
#define CID_SM_PB_Details               1378
#define CID_SM_PB_HangUp                1379
#define CID_SM_ST_Summary               1380
#define CID_SM_TL_Networks              1381
#define CID_SS_CB_AddUser               1382
#define CID_SS_CB_AuthRemote            1383
#define CID_SS_CB_NotNt                 1384
#define CID_SS_CB_PlainPw               1385
#define CID_SS_CB_RouteIp               1386
#define CID_SS_ST_CheckAll              1388
#define CID_UA_CB_SavePassword          1391
#define CID_UA_EB_Domain                1392
#define CID_UA_EB_Password              1393
#define CID_UA_EB_UserName              1394
#define CID_UA_ST_Domain                1395
#define CID_UA_ST_Explain               1396
#define CID_UA_ST_Password              1397
#define CID_UA_ST_Separator             1398
#define CID_UA_ST_UserName              1399
#define CID_US_RB_All                   1400
#define CID_US_RB_Myself                1401
#define CID_XS_EB_Address               1402
#define CID_XS_EB_Facilities            1403
#define CID_XS_EB_UserData              1404
#define CID_XS_GB_Optional              1405
#define CID_XS_LB_Networks              1406
#define CID_XS_ST_Address               1407
#define CID_XS_ST_Explain               1408
#define CID_XS_ST_Facilities            1409
#define CID_XS_ST_Networks              1410
#define CID_XS_ST_UserData              1411
#define CID_DR_ST_Numbers               1412
#define CID_DR_ST_User                  1413
#define CID_DR_LB_Locations             1414
#define CID_DR_ST_Locations             1415
#define CID_DR_CLB_Numbers              1416
#define CID_DP_Icon                     1417
#define CID_NE_LB_ServerType            1418
#define CID_NE_PB_Settings              1419
#define DID_DR_DialerN                  1420
#define DID_DR_DialerUNL                1421
#define DID_DR_DialerUDNL               1422
#define CID_NE_EnableLcp                1423
#define CID_NE_EnableCompression        1424
#define PID_GE_GeneralVpn               1425
#define PID_OE_OptionsVD                1426
#define CID_GE_EB_HostName              1427
#define PID_DA_VpnDestination           1427
#define CID_GE_CB_DialAnotherFirst      1428
#define PID_PN_PublicNetwork            1428
#define CID_GE_LB_DialAnotherFirst      1429
#define CID_GE_ST_HostName              1430
#define CID_GE_GB_FirstConnect          1431
#define CID_GE_ST_Explain               1432
#define CID_DA_EB_HostName              1433
#define CID_PN_LB_DialAnotherFirst      1435
#define PID_GE_GeneralDirect            1436
#define CID_GE_LB_Devices               1437
#define DID_DU_DialUpNetworking         1448
#define CID_DU_PB_Dial                  1449
#define CID_DU_PB_Location              1450
#define CID_DU_ST_DialPreview           1451
#define CID_DU_ST_DialFrom              1452
#define CID_DU_EB_DialPreview           1453
#define CID_DU_PB_Close                 1455
#define CID_DU_ST_Entries               1456
#define CID_DU_LB_Entries               1457
#define CID_DU_ST_Separator             1458
#define CID_DU_PB_New                   1459
#define CID_DU_PB_More                  1460
#define CID_RC_CB_Terminal              1462
#define CID_RC_CB_RunScript             1463
#define CID_RC_CLB_Scripts              1464
#define CID_RC_PB_Browse                1465
#define DID_LE_ListEditor               1466
#define DID_LE_ListEditor2              1467
#define DID_LE_ListEditor3              1468
#define CID_LE_ST_Item                  1469
#define PID_LA_NameAndType              1469
#define CID_LE_EB_Item                  1470
#define CID_LE_PB_Add                   1471
#define CID_LE_PB_Replace               1472
#define CID_LE_ST_List                  1473
#define CID_LE_LB_List                  1474
#define CID_LE_PB_Up                    1475
#define CID_LE_PB_Down                  1476
#define CID_LE_PB_Delete                1477
#define CID_LE_CB_Promote               1478
#define CID_LE_ST_Separator             1479
#define DID_ZE_StringEditor             1480
#define CID_ZE_ST_String                1481
#define PID_DT_DefaultInternet          1481
#define CID_ZE_EB_String                1482
#define CID_GH_RB_Host                  1483
#define CID_GH_RB_Guest                 1484
#define CID_DN_CB_DeviceSelect          1485
#define CID_LA_RB_Phone                 1488
#define CID_LA_RB_Tunnel                1489
#define CID_LA_RB_Direct                1490
#define CID_CA_CB_Pap                   1491
#define CID_LA_RB_Broadband             1491
#define CID_CA_CB_Eap                   1492
#define CID_CA_CB_MsChap2               1492
#define CID_CA_CB_MsChap                1493
#define CID_CA_CB_Chap                  1494
#define CID_CA_LB_Encryption            1495
#define CID_AD_CB_AskBeforeAutodial     1496
#define CID_CA_CB_Spap                  1496
#define CID_CO_CB_AllowConnectionModification 1497
#define CID_CO_CB_UseWizard             1498
#define CID_CR_RB_No                    1501
#define CID_CR_RB_Yes                   1502
#define CID_CR_LV_Numbers               1503
#define CID_CR_PB_Edit                  1504
#define CID_CR_PB_Delete                1505
#define CID_OE_RB_DemandDial            1506
#define CID_OE_RB_Persistent            1507
#define CID_LO_ST_AuthDescription       1508
#define CID_PN_RB_DoNotDialFirst        1509
#define CID_PN_RB_DialFirst             1510
#define CID_SW_PB_Shared                1512
#define SID_FriendlyComPort             1512
#define CID_SW_PB_DemandDial            1513
#define CID_SW_ST_DemandDial            1514
#define CID_SA_ST_PrivateLan            1515
#define CID_SA_LB_PrivateLan            1516
#define CID_SA_GB_Shared                1517
#define CID_SA_GB_PrivateLan            1518
#define CID_SA_SF_PrivateLan            1519
#define CID_SA_EB_PrivateLan            1521
#define CID_SP_LB_PrivateLan            1522
#define SID_Channel                     1523
#define CID_SC_RB_YesSmartCard          1524
#define CID_SC_RB_NoSmartCard           1525
#define SID_SC_Title                    1526
#define SID_SC_Subtitle                 1527
#define SID_DefaultDccEntryName         1528
#define CID_RF_EB_InterfaceName         1528
#define SID_SelectDevice                1529
#define CID_RF_ST_InterfaceName         1529
#define CID_RW_ST_Welcome               1530
#define SID_LargeFontName               1530
#define CID_RW_ST_Explain               1531
#define SID_LargeFontSize               1531
#define CID_CT_RB_Physical              1531
#define CID_RW_ST_Explain2              1532
#define SID_CT_Title                    1532
#define CID_CT_RB_Virtual               1532
#define CID_VT_RB_Pptp                  1532
#define SID_CT_Subtitle                 1533
#define CID_VT_RB_L2tp                  1533
#define SID_RN_Title                    1534
#define CID_VT_RB_Automatic             1534
#define SID_RN_Subtitle                 1535
#define CID_VD_ST_Explain               1535
#define SID_RP_Title                    1536
#define CID_VD_EB_NameOrAddress         1536
#define SID_RP_Subtitle                 1537
#define CID_VD_ST_HostBoxLabel          1537
#define CID_LO_ST_Authentication        1537
#define CID_LO_ST_Auths                 1537
#define SID_VT_Title                    1538
#define CID_SA_PB_Add                   1538
#define SID_VT_Subtitle                 1539
#define CID_LO_ST_AdvancedText          1539
#define SID_VD_Title                    1540
#define CID_LO_RB_TypicalSecurity       1540
#define SID_VD_Subtitle                 1541
#define CID_LO_RB_AdvancedSecurity      1541
#define SID_LO_GB_TypicalSecurity       1542
#define CID_LO_GB_TypicalSecurity       1542
#define SID_LO_GB_AdvancedSecurity      1543
#define CID_LO_GB_AdvancedSecurity      1543
#define SID_RA_Title                    1544
#define CID_CA_RB_Eap                   1544
#define SID_RA_Subtitle                 1545
#define CID_CA_RB_AllowedProtocols      1545
#define SID_NS_Title                    1546
#define CID_CA_ST_Encryption            1546
#define SID_NS_Subtitle                 1547
#define CID_CA_GB_LogonSecurity         1547
#define SID_RC_Title                    1548
#define CID_SA_PB_Tcp                   1548
#define SID_RC_Subtitle                 1549
#define CID_CA_CB_UseWindowsPw          1549
#define SID_DI_Title                    1550
#define CID_AD_CB_DisableThisSession    1550
#define SID_DI_Subtitle                 1551
#define CID_SA_EB_UdpResponse           1551
#define CID_OE_LB_MultipleDevices       1551
#define SID_DO_Title                    1552
#define CID_SS_EB_Service               1552
#define SID_DO_Subtitle                 1553
#define CID_SS_EB_Port                  1553
#define SID_IN_Title                    1554
#define CID_SS_PB_Tcp                   1554
#define CID_OE_CB_PreviewUserPw         1554
#define SID_IN_Subtitle                 1555
#define CID_SS_PB_Udp                   1555
#define CID_OE_CB_PreviewDomain         1555
#define SID_NoDevices                   1556
#define CID_SS_EB_Address               1556
#define CID_NE_NegotiateMultilinkAlways 1557
#define SID_RouterUserExists            1557
#define CID_SA_LV_Applications          1558
#define SID_NoAuthForSlip               1558
#define CID_SA_PB_Edit                  1559
#define SID_AuthUnsecured               1559
#define CID_SS_LV_Services              1560
#define SID_AuthSecured                 1560
#define CID_SS_PB_Add                   1561
#define SID_AuthCardOrCert              1561
#define CID_SS_PB_Delete                1562
#define SID_NoAuthChecked               1562
#define CID_SS_PB_Edit                  1563
#define SID_DE_None                     1563
#define CID_SA_PB_Settings              1564
#define SID_DE_IfPossible               1564
#define CID_SA_EB_Application           1565
#define SID_DE_Require                  1565
#define CID_SA_EB_Port                  1566
#define SID_DE_RequireMax               1566
#define CID_SA_PB_Udp                   1567
#define SID_EncEnabled                  1567
#define CID_SA_PB_Delete                1568
#define SID_NoEncryption                1568
#define SID_DT_Title                    1568
#define CID_SA_EB_TcpResponse           1569
#define IDS_STRING1569                  1569
#define SID_DT_Subtitle                 1569
#define SID_NeedEapKeys                 1570
#define SID_MsChapRequired              1571
#define SID_SS_Title                    1572
#define SID_SS_Subtitle                 1573
#define SID_OptionalAuthQuery           1574
#define CID_VI_I_Information            1575
#define SID_VI_ST_Explain               1575
#define CID_VI_ST_Explain               1576
#define SID_VI_CB_SkipMessage           1576
#define SID_S_ConnectParallel           1576
#define SID_S_ConnectIrda               1577
#define SID_S_ParallelConnected         1578
#define CID_VI_CB_SkipMessage           1579
#define SID_S_IrdaConnected             1579
#define CID_LO_GB_SecurityOptions       1580
#define SID_NoStrongEncryption          1580
#define CID_CO_ST_AllowConnectionModification 1581
#define SID_NE_VpnServerLabel           1581
#define CID_CO_GB_LogonPrivileges       1582
#define SID_MissingUserName             1582
#define CID_NE_ST_ServerType            1583
#define SID_DR_GlobalPassword           1583
#define CID_CN_HMsgWork2                1584
#define SID_CN_HMsgWork2                1584
#define CID_NE_GB_Description           1585
#define SID_DT_TitleWork                1585
#define SID_NE_Reboot                   1586
#define SID_NE_ReadOnly                 1587
#define SID_NE_AccessDenied             1588
#define CID_SA_I_SharedAccess           1588
#define SID_ReplyMessageFmt             1589
#define CID_DR_PB_DialConnect           1590
#define SID_DR_ReconnectTitle           1590
#define CID_DR_PB_Cancel                1591
#define SID_PS_Title                    1591
#define SID_BS_Title                    1591
#define CID_DR_PB_Help                  1592
#define SID_PS_Subtitle                 1592
#define SID_BS_Subtitle                 1592
#define CID_BS_EB_ServiceName           1593
#define IDS_STRING1593                  1593
#define SID_DT_SubtitleWork             1593
#define SID_DefaultBbPort               1594
#define CID_GE_EB_ServiceName           1594
#define SID_ST_BbPppoe                  1595
#define CID_DT_CB_Default               1595
#define SID_NE_BbServerLabel            1596
#define CID_DT_CB_UseSharedCredentials  1596
#define CID_GE_ST_Devices               1597
#define SID_OP_EmptyPSK                 1597
#define CID_LO_PB_IPSec                 1598
#define CID_LO_RB_IPSecPolicy           1599
#define CID_LO_ST_IPSecText             1600
#define CID_CI_ST_Key                   1602
#define CID_LO_CB_IPSecPolicy           1603
#define CID_CI_CB_PresharedKey          1604
#define CID_CI_EB_PSK                   1605
#define CID_CI_CB_UserCerts             1606
#define CID_CI_CB_SpecificCerts         1607
#define CID_CI_PB_Select                1608
#define CID_CI_LB_CertsList             1610
#define SID_DefaultBbEntryName          1611
#define SID_HavetoEnterPSK              1612
#define SID_OP_CredCommit               1613
#define CID_DT_EB_UserName              1614
#define CID_DT_EB_UserName2             1615
#define CID_DT_EB_Password              1615
#define CID_DT_EB_UserName3             1616
#define CID_DT_EB_Password2             1616
#define CID_US_EB_UserName              1617
#define CID_US_EB_UserName2             1618
#define CID_US_EB_UserName3             1619
#define CID_US_CB_UseSharedCredentials  1620
#define CID_US_CB_Default               1621
#define CID_DR_RB_SaveForMe             1622
#define CID_DR_RB_SaveForEveryone       1623
#define SID_SA_NoWMIError               1634
#define SID_SA_StoreError               1635
#define CID_DT_ST_UserName              1636
#define CID_DT_ST_Password              1637
#define CID_DT_ST_Password2             1638
#define CID_FL_PB_Browse                1639
#define CID_FL_EB_Filesize              1640
#define CID_FL_CB_LogOutboundConnections 1641
#define CID_FL_CB_LogDroppedInbound     1642
#define CID_FL_PB_RestoreDefaults       1643
#define CID_IC_LV_Settings              1644
#define CID_IC_ST_Description           1645
#define SID_ICMP_IECHO                  1646
#define SID_ICMP_ITIME                  1647
#define SID_ICMP_IMASK                  1648
#define SID_ICMP_IROUT                  1649
#define SID_ICMP_ODEST                  1650
#define SID_ICMP_OQNCH                  1651
#define SID_ICMP_OPRAM                  1652
#define SID_ICMP_OTIME                  1653
#define SID_ICMP_XRDRT                  1654
#define SID_FwbDefExt                   1655
#define SID_FwbFilter                   1656
#define SID_FwbFilterDesc               1657
#define SID_FwbTitle                    1658
#define CID_SA_ST_HNWLink               1659
#define DID_SA_DisableFirewallWarning   1660
#define CID_SA_ST_ICSText               1661
#define CID_SA_PB_DisableFirewallWarning 1662
#define SID_SA_SelectAdapter            1663
#define SID_SA_SelectAdapterError       1664
#define SID_ICMP_IECHO_DESC             1665
#define SID_ICMP_ITIME_DESC             1666
#define SID_ICMP_IMASK_DESC             1667
#define SID_ICMP_IROUT_DESC             1668
#define SID_ICMP_ODEST_DESC             1669
#define SID_ICMP_OQNCH_DESC             1670
#define SID_ICMP_OPRAM_DESC             1671
#define SID_ICMP_OTIME_DESC             1672
#define SID_ICMP_XRDRT_DESC             1673
#define CID_FL_EB_Filename              1674
#define SID_FwbInvalidSize              1675
#define CID_AQ_LK_UsingAutodial         1676
#define CID_AQ_LV_Connections           1677
#define BID_DialerHi                    1678
#define CID_CN_EB_ConnectionName        1680
#define CID_CN_ST_HMsg                  1681
#define CID_DT_CB_Firewall              1682
#define CID_CN_ST_HMsg2                 1683
#define CID_NE_ST_Components            1684
#define SID_OP_DeletePw                 1684
#define SID_OP_LoadRasAccessDenied      1685
#define CID_GE_ST_ServiceName           1686
#define SID_DT_HMsgWork                 1686
#define SID_CN_NameDccGuest             1687
#define CID_CT_RB_Broadband             1688
#define SID_CN_NameInternet             1688
#define CID_DT_HeadMessage              1689
#define SID_CN_NameWork                 1689
#define CID_CN_Name                     1690
#define SID_PA_SubtitleWork             1690
#define SID_SR_Title                    1691
#define CID_SR_LV_StaticRoutes          1692
#define SID_SR_SubTitle                 1692
#define CID_SR_PB_Add                   1693
#define SID_SR_Destination              1693
#define CID_SR_PB_Remove                1694
#define SID_SR_Netmask                  1694
#define CID_SR_Dest_Ip                  1695
#define SID_SR_Metric                   1696
#define CID_SR_NetMask_Ip               1696
#define SID_SR_DestinationRequired      1697
#define CID_SR_Metric                   1698
#define SID_SR_NetMask_Required         1698
#define SID_SR_MetricRequired           1699
#define SID_SR_InvalidMask              1700
#define CID_DG_PB_View                  1701
#define SID_SR_DuplicateRoute           1701
#define SID_DG_LoadDiag                 1702
#define CID_DG_PB_Clear                 1703
#define SID_EnterFileName               1704
#define CID_DG_PB_Export                1705
#define SID_EnterEmailAddress           1706
#define CID_DG_CB_EnableDiag            1707
#define CID_DG_CB_EnableLog             1708
#define SID_DG_CannotExportLog          1709
#define SID_DG_GetLogFailure            1710
#define SID_DG_LoadLogFailure           1711
#define CID_DE_CB_EnableDiag            1712
#define SID_DG_ExportWarning            1713
#define CID_DG_ST_Test                  1714
#define SID_DG_ToFileFail               1715
#define CID_DE_ST_ConfigureLnk          1716
#define SID_DG_ToEmailFail              1717
#define SID_EL_Waiting                  1718
#define CID_EL_RB_File                  1719
#define SID_EL_ToFileSucceed            1720
#define CID_EL_EB_FileName              1721
#define SID_EL_ToEmailSucceed           1722
#define CID_EL_RB_Email                 1723
#define SID_OPERATION_FAILURE           1724
#define IDC_EDIT3                       1725
#define CID_EL_EB_EmailAddress          1726
#define SID_EL_BrowseTitle              1727
#define CID_EL_CB_FaxNumber             1728
#define SID_PB_StepsDone                1728
#define CID_EL_EB_FaxNumber             1729
#define CID_EL_PB_Browse                1730
#define CID_EL_RB_ViewReport            1731
#define CID_EL_CB_SimpleReport          1732
#define CID_PB_ProgressBar              1733
#define CID_EL_ST_FileName              1734
#define CID_DE_ST_EnableHelp            1735
#define CID_DE_ST_LinkHelp              1736
#define CID_PB_ST_StepsDone             1737
#define CID_PB_ST_State                 1740
#define CID_SA_PB_Shared                15022
#define CID_SA_PB_DemandDial            15023
#define CID_SA_ST_DemandDial            15025
#define CID_FW_PB_Firewalled            15026
#define IID_RM_Modem                    15102
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        596
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1743
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\rasdlgp.h ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// rasdlgp.h
// Remote Access Common Dialog APIs
// Private pre-compiled header
//
// 06/18/95 Steve Cobb


#ifndef _RASDLGP_H_
#define _RASDLGP_H_

#define COBJMACROS

#include <nt.h>       // NT declarations
#include <ntrtl.h>    // NT general runtime-library
#include <nturtl.h>   // NT user-mode runtime-library
#include <windows.h>  // Win32 root
#include <windowsx.h> // Win32 macro extensions
#include <commctrl.h> // Win32 common controls
#include <commdlg.h>  // Win32 common dialogs
#include <prsht.h>    // Win32 property sheets
#include <setupapi.h> // Class image lists for network components
#include <shlobj.h>   // To get profile directory for user
#include <tapi.h>     // Telephony API
#include <rasdlg.h>   // Win32 RAS common dialogs (our public header)
#include <rasuip.h>   // RAS UI APIs (our private header)
#include <raserror.h> // Win32 RAS error codes
#include <netcfgx.h>  // INetCfg interfaces
#include <hnetcfg.h>  // IHNetCfg interfaces
#include <pbk.h>      // RAS phonebook library
#include <tapiutil.h> // TAPI helper library
#include <nouiutil.h> // No-HWND helper library
#include <phonenum.h> // Phone number helper library
#include <debug.h>    // Trace/assert library
#include <uiutil.h>   // HWND helper library
#include <wait.rch>   // LoadRas resource constants
#include <mdm.h>      // installs null modems for the dcc wizards.
#include <pwutil.h>   // password encoding, etc.
#include "rasdlgrc.h" // Our resource constants
#include "rasdlghc.h" // Our help context constants
#include "entry.h"    // High-level common phonebook entry helpers
#include "rassrv.h"
#include "rasdiagp.h" // For whistler 460931

// Fusion support
// For whistler bug 349866
#include "shfusion.h"

// Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
//
// Created this for the use of dial.c/terminal.c, max length of the IP address
// for the terminal dialog
//
#define TERM_IpAddress 17

// Positional offset of property sheets and wizards from the main dialog.
//
#define DXSHEET 12
#define DYSHEET 25

// List editor dialog option flags
//
#define LEDFLAG_NoDeleteLastItem 0x00000001
#define LEDFLAG_Sorted           0x00000002
#define LEDFLAG_Unique           0x00000004

//-----------------------------------------------------------------------------
// Datatypes
//-----------------------------------------------------------------------------

// For whistler 460931
//
typedef struct _tagDiagnosticInfo
{
    HINSTANCE hDiagDll;
    DiagGetDiagnosticFunctions pfnGetDiagFunc;
    RAS_DIAGNOSTIC_FUNCTIONS  strDiagFuncs;
} DiagnosticInfo;


// Defines arguments passed internally via reserved words in the public
// interface.  This is done so an API doesn't have to re-load the phonebook
// and user preferences when serving another API.
//
typedef struct
_INTERNALARGS
{
    PBFILE* pFile;
    PBUSER* pUser;
    RASNOUSER* pNoUser;
    BOOL fNoUser;
    BOOL fNoUserChanged;
    BOOL fMoveOwnerOffDesktop;
    BOOL fForceCloseOnDial;
    HANDLE hConnection;
    BOOL fInvalid;
    PVOID pvEapInfo;
    BOOL fDisableFirstConnect;
    PVOID * pvSRouteInfo;
}
INTERNALARGS;

// Static list table item.
//
typedef struct
_LBTABLEITEM
{
    DWORD sidItem;
    DWORD dwData;
}
LBTABLEITEM;


//-----------------------------------------------------------------------------
// Global declarations (defined in main.c)
//-----------------------------------------------------------------------------

extern HINSTANCE g_hinstDll;
extern LPCWSTR g_contextId;
extern HBITMAP g_hbmWizard;
extern TCHAR* g_pszHelpFile;
extern TCHAR* g_pszRouterHelpFile;
extern BOOL g_fEncryptionPermitted;
extern LONG g_ulCallbacksActive;
extern BOOL g_fTerminateAsap;
extern CRITICAL_SECTION  g_csDiagTab;   //For whistler 460931
extern CRITICAL_SECTION  g_csCallBacks; //for .Net 511810


//-----------------------------------------------------------------------------
// Macros
//-----------------------------------------------------------------------------

#define ErrorDlg(h,o,e,a) \
            ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_PopupTitle,SID_FMT_ErrorMsg)

#define MsgDlg(h,m,a) \
            MsgDlgUtil(h,m,a,g_hinstDll,SID_PopupTitle)

// Extended tracing macros.  Specifying a flag by name in the first parameter
// allows the caller to categorize messages printed e.g.
//
//     TRACEX(RASDLG_TIMER,"entering LsRefresh")
//
#define RASDLG_TIMER  ((DWORD)0x80000000|0x00000002)


//-----------------------------------------------------------------------------
// Cross-file prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOL
AdvancedSecurityDlg(
    IN HWND hwndOwner,
    IN OUT EINFO* pArgs );

BOOL
AllLinksAreModems(
    IN PBENTRY* pEntry );

BOOL
AllowDccWizard(
    IN HANDLE hConnection);

BOOL
AlternatePhoneNumbersDlg(
    IN HWND hwndOwner,
    IN OUT DTLNODE* pLinkNode,
    IN OUT DTLLIST* pListAreaCodes );

DWORD
AuthRestrictionsFromTypicalAuth(
    IN DWORD dwTypicalAuth );

LONG  GetGlobalCallbackActive( );

LONG  IncGlobalCallbackActive( );

LONG  DecGlobalCallbackActive( );

ULONG
CallbacksActive(
    INT nSetTerminateAsap,
    BOOL* pfTerminateAsap );

VOID
ContextHelp(
    IN const DWORD* padwMap,
    IN HWND hwndDlg,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
ContextHelpX(
    IN const DWORD* padwMap,
    IN HWND hwndDlg,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam,
    IN BOOL fRouter);

VOID
CopyLinkPhoneNumberInfo(
    OUT DTLNODE* pDstLinkNode,
    IN DTLNODE* pSrcLinkNode );

VOID
CopyPszListToPhoneList(
    IN OUT PBLINK* pLink,
    IN DTLLIST* pListPhoneNumbers );

HWND
CreateWizardBitmap(
    IN HWND hwndDlg,
    IN BOOL fPage );

BOOL
CustomAuthenticationDlg(
    IN HWND hwndOwner,
    IN OUT PBENTRY* pEntry,
    IN DTLLIST* pList,
    IN DTLNODE* pNodeToSelect,
    OUT DTLNODE** ppNodeSelected );

BOOL
DataEncryptionDlg(
    IN HWND hwndOwner,
    IN OUT PBENTRY* pEntry,
    IN DWORD dwfCaps );

VOID
DereferenceRunningCallbacks(
    VOID );

BOOL
DeviceConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink,
    IN PBENTRY* pEntry,
    IN BOOL fSingleLink,
    IN BOOL fRouter);

TCHAR*
DisplayPszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort );

TCHAR*
DisplayPszFromPpbport(
    IN PBPORT* pPort,
    OUT DWORD* pdwDeviceIcon );

DWORD
DwCustomTerminalDlg(TCHAR *pszPhonebook,
                    HRASCONN hrasconn,
                    PBENTRY *pEntry,
                    HWND hwndDlg,
                    RASDIALPARAMS *prasdialparams,
                    PVOID pvReserved);
BOOL
EditPhoneNumberDlg(
    IN HWND hwndOwner,
    IN OUT DTLNODE* pPhoneNode,
    IN OUT DTLLIST* pListAreaCodes,
    IN DWORD sidTitle );

VOID
EnableCbWithRestore(
    IN HWND hwndCb,
    IN BOOL fEnable,
    IN BOOL fDisabledCheck,
    IN OUT BOOL* pfRestore );

VOID
EnableLbWithRestore(
    IN HWND hwndLb,
    IN BOOL fEnable,
    IN OUT INT* piRestore );

DTLNODE*
FirstPhoneNodeFromPhoneList(
    IN DTLLIST* pListPhones );

VOID
FirstPhoneNodeToPhoneList(
    IN DTLLIST* pListPhones,
    IN DTLNODE* pNewNode );

TCHAR*
FirstPhoneNumberFromEntry(
    IN PBENTRY* pEntry );

TCHAR*
FirstPszFromList(
    IN DTLLIST* pPszList );

DWORD
FirstPhoneNumberToEntry(
    IN PBENTRY* pEntry,
    IN TCHAR* pszPhoneNumber );

DWORD
FirstPszToList(
    IN DTLLIST* pPszList,
    IN TCHAR* psz );

VOID 
GetBoldWindowFont(
    IN  HWND hwnd, 
    IN  BOOL fLargeFont, 
    OUT HFONT * pBoldFont);


DWORD
GetDefaultEntryName(
    IN  PBFILE* pFile,
    IN  DWORD dwType,
    IN  BOOL fRouter,
    OUT TCHAR** ppszName );

BOOL
IPSecPolicyDlg(
    IN HWND hwndOwner,
    IN OUT EINFO* pArgs );
    
BOOL
IsLocalPad(
    IN PBENTRY* pEntry );

/*
DWORD
IsNt40Machine (
    IN      PWCHAR      pszServer,
    OUT     PBOOL       pbIsNt40
    );
*/    

BOOL
ListEditorDlg(
    IN HWND hwndOwner,
    IN OUT DTLLIST* pList,
    IN OUT BOOL* pfCheck,
    IN DWORD dwMaxItemLen,
    IN TCHAR* pszTitle,
    IN TCHAR* pszItemLabel,
    IN TCHAR* pszListLabel,
    IN TCHAR* pszCheckLabel,
    IN TCHAR* pszDefaultItem,
    IN INT iSelInitial,
    IN DWORD* pdwHelp,
    IN DWORD dwfFlags,
    IN PDESTROYNODE pDestroyId );

BOOL
MultiLinkConfigureDlg(
    IN HWND hwndOwner,
    IN PBENTRY* pEntry,
    IN BOOL fRouter );

BOOL
MultiLinkDialingDlg(
    IN HWND hwndOwner,
    OUT PBENTRY* pEntry );

BOOL
NwConnectionCheck(
    IN HWND hwndOwner,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg,
    IN PBFILE* pFile,
    IN PBENTRY* pEntry );

BOOL
PhoneNodeIsBlank(
    IN DTLNODE* pNode );

BOOL
PhoneNumberDlg(
    IN HWND hwndOwner,
    IN BOOL fRouter,
    IN OUT DTLLIST* pList,
    IN OUT BOOL* pfCheck );

VOID
PositionDlg(
    IN HWND hwndDlg,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg );

LRESULT CALLBACK
PositionDlgStdCallWndProc(
    int code,
    WPARAM wparam,
    LPARAM lparam );

BOOL
PppTcpipDlg(
    IN HWND hwndOwner,
    IN OUT PBENTRY* pEntry,
    IN BOOL fRouter );

BOOL
PrefixSuffixLocationDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszLocation,
    IN DWORD dwLocationId,
    IN OUT PBUSER* pUser,
    IN OUT HLINEAPP* pHlineapp );

TCHAR*
PszFromPhoneNumberList(
    IN DTLLIST* pList );

LRESULT CALLBACK
SelectDesktopCallWndRetProc(
    int code,
    WPARAM wparam,
    LPARAM lparam );

HICON
GetCurrentIconEntryType(
    IN DWORD dwType,
    BOOL fSmall);
   
VOID
SetIconFromEntryType(
    IN HWND hwndIcon,
    IN DWORD dwType,
    BOOL fSmall);

BOOL
SlipTcpipDlg(
    IN HWND hwndOwner,
    IN OUT PBENTRY* pEntry );

BOOL
StringEditorDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszIn,
    IN DWORD dwSidTitle,
    IN DWORD dwSidLabel,
    IN DWORD cbMax,
    IN DWORD dwHelpId,
    IN OUT TCHAR** ppszOut );

BOOL
TerminalDlg(
    IN PBENTRY* pEntry,
    IN RASDIALPARAMS* pRdp,
    IN HWND hwndOwner,
    IN HRASCONN hrasconn,
    IN DWORD sidTitle,
    IN OUT TCHAR* pszIpAddress );

VOID
TweakTitleBar(
    IN HWND hwndDlg );

int CALLBACK
UnHelpCallbackFunc(
    IN HWND hwndDlg,
    IN UINT unMsg,
    IN LPARAM lparam );

BOOL
UserPreferencesDlg(
    IN HLINEAPP hlineapp,
    IN HWND hwndOwner,
    IN DWORD dwFlags,
    OUT PBUSER*  pUser,
    OUT PBFILE** ppFile );

BOOL
WaitForRasDialCallbacksToTerminate(
    VOID );

BOOL
X25LogonSettingsDlg(
    IN HWND hwndOwner,
    IN BOOL fLocalPad,
    IN OUT PBENTRY* pEntry );

//-----------------------------------------------------------------------------
//
// pmay: 213060
// Prototypes moved from pref.c and entryps.c, cleanup added
//
// Callback number utilities
//
//-----------------------------------------------------------------------------

// 
//  Per-callback number context.
//
//  CbutilFillLvNumbers will allocate one of these contexts for each
//  item it puts in the list (accessed as LV_ITEM.lParam).  
//  CbutilLvNumbersCleanup will cleanup these contexts.
//
typedef struct _CBCONTEXT
{
    TCHAR* pszPortName;  // Pointer to port name (not owned by struct)
    TCHAR* pszDeviceName;// Pointer to device name (not owned by struct)
    DWORD dwDeviceType;  // pointer to the type of the device
    BOOL fConfigured;    // Whether device referenced is installed on sys.
} CBCONTEXT;

VOID
CbutilFillLvNumbers(
    IN HWND     hwndDlg,
    IN HWND     hwndLvNumbers,
    IN DTLLIST* pListCallback,
    IN BOOL     fRouter );

VOID
CbutilLvNumbersCleanup(
    IN  HWND    hwndLvNumbers );

LVXDRAWINFO*
CbutilLvNumbersCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

VOID
CbutilEdit(
    IN HWND hwndDlg,
    IN HWND hwndLvNumbers );

VOID
CbutilDelete(
    IN HWND  hwndDlg,
    IN HWND  hwndLvNumbers );

VOID
CbutilSaveLv(
    IN  HWND     hwndLvNumbers,
    OUT DTLLIST* pListCallback );

// For whistler 460931
//
// Begin of functions implemented in diagnostic.c
//
INT_PTR CALLBACK
DgDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

DWORD
UnLoadDiagnosticDll(
    IN DiagnosticInfo * pInfo );

DWORD
LoadDiagnosticDll(
    IN DiagnosticInfo * pInfo);

// End of functions implemented in diagnostic.c
//


#endif // _RASDLGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\security.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// security.c
// Remote Access Common Dialog APIs
// Security dialogs
//
// 11/06/97 Steve Cobb
//


#include "rasdlgp.h"
#include <rasauth.h>
#include <rrascfg.h>

const IID IID_IEAPProviderConfig =  {0x66A2DB19,
                                    0xD706,
                                    0x11D0,
                                    {0xA3,0x7B,0x00,0xC0,0x4F,0xC9,0xDA,0x04}};

//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwCaHelp[] =
{
    CID_CA_ST_Encryption,       HID_CA_LB_Encryption,
    CID_CA_LB_Encryption,       HID_CA_LB_Encryption,
    CID_CA_GB_LogonSecurity,    HID_CA_GB_LogonSecurity,
    CID_CA_RB_Eap,              HID_CA_RB_Eap,
    CID_CA_LB_EapPackages,      HID_CA_LB_EapPackages,
    CID_CA_PB_Properties,       HID_CA_PB_Properties,
    CID_CA_RB_AllowedProtocols, HID_CA_RB_AllowedProtocols,
    CID_CA_CB_Pap,              HID_CA_CB_Pap,
    CID_CA_CB_Spap,             HID_CA_CB_Spap,
    CID_CA_CB_Chap,             HID_CA_CB_Chap,
    CID_CA_CB_MsChap,           HID_CA_CB_MsChap,
    CID_CA_CB_W95MsChap,        HID_CA_CB_W95MsChap,
    CID_CA_CB_MsChap2,          HID_CA_CB_MsChap2,
    CID_CA_CB_UseWindowsPw,     HID_CA_CB_UseWindowsPw,
    0, 0
};


//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// Custom authentication dialog argument block.
//
typedef struct
_CAARGS
{
    PBENTRY* pEntry;
    BOOL fStrongEncryption;

    // Set if we have been called via RouterEntryDlg.
    //
    BOOL fRouter;

    // Set if pszRouter is an NT4 steelhead machine.  Valid only 
    // if fRouter is true.
    //
    BOOL fNt4Router;

    // The name of the server in "\\server" form or NULL if none (or if
    // 'fRouter' is not set).
    //
    TCHAR* pszRouter;
}
CAARGS;

// Custom authentication dialog context block.
//
typedef struct
_CAINFO
{
    // Caller's arguments to the dialog.
    //
    CAARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndLbEncryption;
    HWND hwndRbEap;
    HWND hwndLbEapPackages;
    HWND hwndPbProperties;
    HWND hwndRbAllowedProtocols;
    HWND hwndCbPap;
    HWND hwndCbSpap;
    HWND hwndCbChap;
    HWND hwndCbMsChap;
    HWND hwndCbW95MsChap;
    HWND hwndCbMsChap2;
    HWND hwndCbUseWindowsPw;

    // List of EAPCFGs read from the registry, with the originally selected
    // node for use in consistency tests later.
    //
    DTLLIST* pListEapcfgs;
    DTLNODE* pOriginalEapcfgNode;

    // "Restore" states for controls that may be disabled with
    // EnableCbWithRestore or EnableLbWithRestore routines.
    //
    DWORD iLbEapPackages;
    BOOL fPap;
    BOOL fSpap;
    BOOL fChap;
    BOOL fMsChap;
    BOOL fW95MsChap;
    BOOL fMsChap2;
    BOOL fUseWindowsPw;
}
CAINFO;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
CaCbToggle(
    IN CAINFO* pInfo,
    IN HWND hwndCb );

BOOL
CaCommand(
    IN CAINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
CaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CaInit(
    IN HWND hwndDlg,
    IN CAARGS* pArgs );

VOID
CaLbEapPackagesSelChange(
    IN CAINFO* pInfo );

VOID
CaPropertiesLocal(
    IN CAINFO* pInfo );

VOID
CaPropertiesRemote(
    IN CAINFO* pInfo );

VOID
CaRbToggle(
    IN CAINFO* pInfo,
    IN BOOL fEapSelected );

BOOL
CaSave(
    IN CAINFO* pInfo );

VOID
CaTerm(
    IN HWND hwndDlg );


//----------------------------------------------------------------------------
// Advanced Security dialog routines
// Listed alphabetically following entrypoint and dialog proc
//----------------------------------------------------------------------------

BOOL
AdvancedSecurityDlg(
    IN HWND hwndOwner,
    IN OUT EINFO* pArgs )

    // Popup a dialog to select advanced security options for phonebook entry
    // represented by 'pArgs'.  'HwndOwner' is the owning window.
    //
    // Returns true if user pressed OK and succeeded or false on Cancel or
    // error.  If successful, the new configuration is written to the
    // appropriate 'pArgs->pEntry' fields.  The routine assumes that these same
    // 'pEntry' fields contain the desired defaults on entry.
    //
{
    INT_PTR nStatus;
    CAARGS args;

    TRACE( "AdvSecurityDlg" );

    args.pEntry = pArgs->pEntry;
    args.fStrongEncryption = pArgs->fStrongEncryption;
    args.fRouter = pArgs->fRouter;
    args.fNt4Router = pArgs->fNt4Router;
    args.pszRouter = pArgs->pszRouter;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CA_CustomAuth ),
            hwndOwner,
            CaDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
CaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Custom Authentication dialog.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "CaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return CaInit( hwnd, (CAARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwCaHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            CAINFO* pInfo = (CAINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return CaCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            CaTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
CaCommand(
    IN CAINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "CaCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_CA_RB_Eap:
        case CID_CA_RB_AllowedProtocols:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    CaRbToggle( pInfo, (wId == CID_CA_RB_Eap) );
                    return TRUE;
                }
            }
            break;
        }

        case CID_CA_LB_EapPackages:
        {
            CaLbEapPackagesSelChange( pInfo );
            return TRUE;
        }

        case CID_CA_PB_Properties:
        {
            if (   ( pInfo->pArgs->fRouter )
                && ( !pInfo->pArgs->fNt4Router )
                && ( pInfo->pArgs->pszRouter ) 
                && ( pInfo->pArgs->pszRouter[0] ) )
            {
                CaPropertiesRemote( pInfo );
            }
            else
            {
                CaPropertiesLocal( pInfo );
            }

            return TRUE;
        }

        case CID_CA_CB_Pap:
        case CID_CA_CB_Spap:
        case CID_CA_CB_Chap:
        case CID_CA_CB_MsChap:
        case CID_CA_CB_W95MsChap:
        case CID_CA_CB_MsChap2:
        {
            CaCbToggle( pInfo, hwndCtrl );
            return TRUE;
        }

        case IDOK:
        {
            if (CaSave( pInfo ))
            {
                EndDialog( pInfo->hwndDlg, TRUE );
            }
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
CaCbToggle(
    IN CAINFO* pInfo,
    IN HWND hwndCb )

    // Called when one of the 6 authentication protocol check boxes is toggled
    // and/or the toggle processing should be performed.  'HwndCb' is the
    // window handle of the toggled checkbox or NULL if none.  'PInfo' is the
    // dialog context.
    //
{
    BOOL fMsChap;
    BOOL fW95MsChap;
    BOOL fMsChap2;

    fMsChap = Button_GetCheck( pInfo->hwndCbMsChap );

    EnableCbWithRestore(
        pInfo->hwndCbW95MsChap,
        fMsChap,
        FALSE,
        &pInfo->fW95MsChap );

    if (IsWindowEnabled( pInfo->hwndCbW95MsChap ))
    {
        fW95MsChap = Button_GetCheck( pInfo->hwndCbW95MsChap );
    }
    else
    {
        fW95MsChap = FALSE;
    }

    fMsChap2 = Button_GetCheck( pInfo->hwndCbMsChap2 );

    EnableCbWithRestore(
        pInfo->hwndCbUseWindowsPw,
        fMsChap || fW95MsChap || fMsChap2,
        FALSE,
        &pInfo->fUseWindowsPw );
}


BOOL
CaInit(
    IN HWND hwndDlg,
    IN CAARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's arguments as passed to the stub
    // API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DWORD dwAr;
    CAINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "CaInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pEntry = pArgs->pEntry;

    pInfo->hwndLbEncryption = GetDlgItem( hwndDlg, CID_CA_LB_Encryption );
    ASSERT( pInfo->hwndLbEncryption );
    pInfo->hwndRbEap = GetDlgItem( hwndDlg, CID_CA_RB_Eap );
    ASSERT( pInfo->hwndRbEap );
    pInfo->hwndLbEapPackages = GetDlgItem( hwndDlg, CID_CA_LB_EapPackages );
    ASSERT( pInfo->hwndLbEapPackages );
    pInfo->hwndPbProperties = GetDlgItem( hwndDlg, CID_CA_PB_Properties );
    ASSERT( pInfo->hwndPbProperties );
    pInfo->hwndRbAllowedProtocols =
        GetDlgItem( hwndDlg, CID_CA_RB_AllowedProtocols );
    ASSERT( pInfo->hwndRbAllowedProtocols );
    pInfo->hwndCbPap = GetDlgItem( hwndDlg, CID_CA_CB_Pap );
    ASSERT( pInfo->hwndCbPap );
    pInfo->hwndCbSpap = GetDlgItem( hwndDlg, CID_CA_CB_Spap );
    ASSERT( pInfo->hwndCbSpap );
    pInfo->hwndCbChap = GetDlgItem( hwndDlg, CID_CA_CB_Chap );
    ASSERT( pInfo->hwndCbChap );
    pInfo->hwndCbMsChap = GetDlgItem( hwndDlg, CID_CA_CB_MsChap );
    ASSERT( pInfo->hwndCbMsChap );
    pInfo->hwndCbW95MsChap = GetDlgItem( hwndDlg, CID_CA_CB_W95MsChap );
    ASSERT( pInfo->hwndCbW95MsChap );
    pInfo->hwndCbMsChap2 = GetDlgItem( hwndDlg, CID_CA_CB_MsChap2 );
    ASSERT( pInfo->hwndCbMsChap2 );
    pInfo->hwndCbUseWindowsPw = GetDlgItem( hwndDlg, CID_CA_CB_UseWindowsPw );
    ASSERT( pInfo->hwndCbUseWindowsPw );

    // Initialize the encryption list.
    //
    {
        LBTABLEITEM* pItem;
        INT i;

        static LBTABLEITEM aItems[] =
        {
            SID_DE_None, DE_None,
            SID_DE_IfPossible, DE_IfPossible,
            SID_DE_Require, DE_Require,
            SID_DE_RequireMax, DE_RequireMax,
            0, 0
        };

        static LBTABLEITEM aItemsExport[] =
        {
            SID_DE_None, DE_None,
            SID_DE_IfPossible, DE_IfPossible,
            SID_DE_Require, DE_Require,
            0, 0
        };

        // Warn user if entry is configured for strong encryption and none is
        // available on the machine.  (See bug 289692)
        //
        if (pEntry->dwDataEncryption == DE_RequireMax
            && !pArgs->fStrongEncryption)
        {
            MsgDlg( pInfo->hwndDlg, SID_NoStrongEncryption, NULL );
            pEntry->dwDataEncryption = DE_Require;
        }

        for (pItem = (pArgs->fStrongEncryption) ? aItems : aItemsExport, i = 0;
             pItem->sidItem;
             ++pItem, ++i)
        {
            ComboBox_AddItemFromId(
                g_hinstDll, pInfo->hwndLbEncryption,
                pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

            if (pEntry->dwDataEncryption == pItem->dwData)
            {
                ComboBox_SetCurSel( pInfo->hwndLbEncryption, i );
            }
        }
    }

    // Initialize EAP package list.
    //
    {
        DTLNODE* pNode;
        TCHAR* pszEncEnabled;

        // Read the EAPCFG information from the registry and find the node
        // selected in the entry, or the default, if none.
        //
        if (   ( pInfo->pArgs->fRouter )
            && ( !pInfo->pArgs->fNt4Router )
            && ( pInfo->pArgs->pszRouter )
            && ( pInfo->pArgs->pszRouter[0] ) )
        {
            pInfo->pListEapcfgs = ReadEapcfgList( pInfo->pArgs->pszRouter );
        }
        else
        {
            pInfo->pListEapcfgs = ReadEapcfgList( NULL );
        }

        if (pInfo->pListEapcfgs)
        {
            DTLNODE* pNodeEap;
            DWORD cbData = 0;
            PBYTE pbData = NULL;
            DWORD dwkey = pEntry->dwCustomAuthKey;
            

            for (pNodeEap = DtlGetFirstNode(pInfo->pListEapcfgs);
                 pNodeEap;
                 pNodeEap = DtlGetNextNode(pNodeEap))
            {
                EAPCFG* pEapcfg = (EAPCFG* )DtlGetData(pNodeEap);
                ASSERT( pEapcfg );

                pEntry->dwCustomAuthKey = pEapcfg->dwKey;

                if(NO_ERROR == DwGetCustomAuthData(
                                    pEntry,
                                    &cbData,
                                    &pbData)
                    &&  (cbData > 0)
                    &&  (pbData))
                {
                    VOID *pData = Malloc(cbData);

                    if(pData)
                    {
                        CopyMemory(pData,
                                   pbData,
                                   cbData);

                        Free0(pEapcfg->pData);
                        pEapcfg->pData = pData;
                        pEapcfg->cbData = cbData;
                    }
                }
            }

            pEntry->dwCustomAuthKey = dwkey;

            if (pEntry->dwCustomAuthKey == (DWORD )-1)
            {
                pNode = DtlGetFirstNode( pInfo->pListEapcfgs );
            }
            else
            {

                pNode = EapcfgNodeFromKey(
                    pInfo->pListEapcfgs, pEntry->dwCustomAuthKey );
            }

            pInfo->pOriginalEapcfgNode = pNode;
        }

        // Fill the EAP packages listbox and select the previously identified
        // selection.  The Properties button is disabled by default, but may
        // be enabled when the EAP list selection is set.
        //
        EnableWindow( pInfo->hwndPbProperties, FALSE );

        pszEncEnabled = PszFromId( g_hinstDll, SID_EncEnabled );
        if (pszEncEnabled)
        {
            for (pNode = DtlGetFirstNode( pInfo->pListEapcfgs );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {
                DWORD cb;
                EAPCFG* pEapcfg;
                INT i;
                TCHAR* pszBuf;

                pEapcfg = (EAPCFG* )DtlGetData( pNode );
                ASSERT( pEapcfg );
                ASSERT( pEapcfg->pszFriendlyName );

                // Whistler bug 224074 use only lstrcpyn's to prevent
                // maliciousness
                //
                cb = lstrlen( pEapcfg->pszFriendlyName ) +
                     lstrlen( pszEncEnabled ) + 1;

                pszBuf = Malloc( cb * sizeof(TCHAR) );
                if (!pszBuf)
                {
                    continue;
                }

                // Whistler bug 224074 use only lstrcpyn's to prevent
                // maliciousness
                //
                lstrcpyn( pszBuf, pEapcfg->pszFriendlyName, cb );
                if (pEapcfg->fProvidesMppeKeys)
                {
                    lstrcat( pszBuf, pszEncEnabled );
                }

                i = ComboBox_AddItem(
                    pInfo->hwndLbEapPackages, pszBuf, pNode );

                if (pNode == pInfo->pOriginalEapcfgNode)
                {
                    ComboBox_SetCurSelNotify( pInfo->hwndLbEapPackages, i );
                }

                Free( pszBuf );
            }

            Free0( pszEncEnabled );
            ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbEapPackages );
        }

    }

    // Set initial check box settings.  The values may be changed when the
    // radio button handling does it's enabling/disabling.
    //
    dwAr = pEntry->dwAuthRestrictions;
    Button_SetCheck( pInfo->hwndCbPap, !!(dwAr & AR_F_AuthPAP) );
    Button_SetCheck( pInfo->hwndCbSpap, !!(dwAr & AR_F_AuthSPAP) );
    Button_SetCheck( pInfo->hwndCbChap, !!(dwAr & AR_F_AuthMD5CHAP) );
    Button_SetCheck( pInfo->hwndCbMsChap, !!(dwAr & AR_F_AuthMSCHAP) );
    Button_SetCheck( pInfo->hwndCbW95MsChap, !!(dwAr & AR_F_AuthW95MSCHAP) );
    Button_SetCheck( pInfo->hwndCbMsChap2, !!(dwAr & AR_F_AuthMSCHAP2) );

    if (!pInfo->pArgs->fRouter)
    {
        pInfo->fUseWindowsPw = pEntry->fAutoLogon;
        Button_SetCheck( pInfo->hwndCbUseWindowsPw, pInfo->fUseWindowsPw );
    }
    else
    {
        pInfo->fUseWindowsPw = FALSE;
        Button_SetCheck( pInfo->hwndCbUseWindowsPw, FALSE );
        EnableWindow( pInfo->hwndCbUseWindowsPw, FALSE );
        ShowWindow( pInfo->hwndCbUseWindowsPw, FALSE );
    }

    // Set the appropriate radio button which triggers appropriate
    // enabling/disabling.
    //
    {
        HWND hwndRb;

        if (dwAr & AR_F_AuthEAP)
        {
            hwndRb = pInfo->hwndRbEap;
        }
        else
        {
            hwndRb = pInfo->hwndRbAllowedProtocols;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    SetFocus( pInfo->hwndLbEncryption );

    return TRUE;
}


VOID
CaLbEapPackagesSelChange(
    IN CAINFO* pInfo )

    // Called when the EAP list selection changes.  'PInfo' is the dialog
    // context.
    //
{
    EAPCFG* pEapcfg;
    INT iSel;

    // Get the EAPCFG information for the selected EAP package.
    //
    pEapcfg = NULL;
    iSel = ComboBox_GetCurSel( pInfo->hwndLbEapPackages );
    if (iSel >= 0)
    {
        DTLNODE* pNode;

        pNode =
            (DTLNODE* )ComboBox_GetItemDataPtr(
                pInfo->hwndLbEapPackages, iSel );
        if (pNode)
        {
            pEapcfg = (EAPCFG* )DtlGetData( pNode );
        }
    }

    // Enable the Properties button if the selected package has a
    // configuration entrypoint.
    //
    EnableWindow(
        pInfo->hwndPbProperties, (pEapcfg && !!(pEapcfg->pszConfigDll)) );
}


VOID
CaPropertiesLocal(
    IN CAINFO* pInfo )

    // Called when the EAP properties button is pressed.  Call the
    // configuration DLL to popup the properties of the package.  'PInfo' is
    // the dialog context.
    //
{
    DWORD dwErr;
    DTLNODE* pNode;
    EAPCFG* pEapcfg;
    RASEAPINVOKECONFIGUI pInvokeConfigUi;
    RASEAPFREE pFreeConfigUIData;
    HINSTANCE h;
    BYTE* pConnectionData;
    DWORD cbConnectionData;

    // Look up the selected package configuration and load the associated
    // configuration DLL.
    //
    pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
        pInfo->hwndLbEapPackages,
        ComboBox_GetCurSel( pInfo->hwndLbEapPackages ) );
    ASSERT( pNode );

    if(NULL == pNode)
    {
        return;
    }
    
    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    ASSERT( pEapcfg );

    h = NULL;
    if (!(h = LoadLibrary( pEapcfg->pszConfigDll ))
        || !(pInvokeConfigUi =
                (RASEAPINVOKECONFIGUI )GetProcAddress(
                    h, "RasEapInvokeConfigUI" ))
        || !(pFreeConfigUIData =
                (RASEAPFREE) GetProcAddress(
                    h, "RasEapFreeMemory" )))
    {
        MsgDlg( pInfo->hwndDlg, SID_CannotLoadConfigDll, NULL );
        if (h)
        {
            FreeLibrary( h );
        }
        return;
    }

    // Call the configuration DLL to popup it's custom configuration UI.
    //
    pConnectionData = NULL;
    cbConnectionData = 0;

    dwErr = pInvokeConfigUi(
        pEapcfg->dwKey, pInfo->hwndDlg, 
        pInfo->pArgs->fRouter ? RAS_EAP_FLAG_ROUTER : 0,
        pEapcfg->pData,
        pEapcfg->cbData,
        &pConnectionData, &cbConnectionData
        );
    if (dwErr != 0)
    {
        if (dwErr != ERROR_CANCELLED)
            MsgDlg( pInfo->hwndDlg, SID_ConfigDllApiFailed, NULL );
        FreeLibrary( h );
        return;
    }

    // Store the configuration information returned in the package descriptor.
    //

    Free( pEapcfg->pData );
    pEapcfg->pData = NULL;
    pEapcfg->cbData = 0;

    if (pConnectionData)
    {
        if (cbConnectionData > 0)
        {
            // Copy it into the eap node
            pEapcfg->pData = Malloc( cbConnectionData );
            if (pEapcfg->pData)
            {
                CopyMemory( pEapcfg->pData, pConnectionData, cbConnectionData );
                pEapcfg->cbData = cbConnectionData;
            }
        }
    }

    pFreeConfigUIData( pConnectionData );

    // Note any "force user to configure" requirement on the package has been
    // satisfied.
    //
    pEapcfg->fConfigDllCalled = TRUE;

    FreeLibrary( h );
}


VOID
CaPropertiesRemote(
    IN CAINFO* pInfo )

    // Called when the EAP properties button is pressed.  Call the
    // configuration DLL to popup the properties of the package.  'PInfo' is
    // the dialog context.
    //
{
    DWORD               dwErr;
    HRESULT             hr;
    DTLNODE*            pNode;
    EAPCFG*             pEapcfg;
    BOOL                fComInitialized     = FALSE;
    BYTE*               pConnectionData     = NULL;
    DWORD               cbConnectionData    = 0;
    IEAPProviderConfig* pEapProv            = NULL;
    ULONG_PTR           uConnectionParam;
    BOOL                fInitialized        = FALSE;

    pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
        pInfo->hwndLbEapPackages,
        ComboBox_GetCurSel( pInfo->hwndLbEapPackages ) );
    ASSERT( pNode );

    if(NULL == pNode)
    {
        goto LDone;
    }
    
    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    ASSERT( pEapcfg );

    hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
    if ( RPC_E_CHANGED_MODE == hr )
    {
        hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    }

    if (   ( S_OK != hr )
        && ( S_FALSE != hr ) )
    {
        goto LDone;
    }

    fComInitialized = TRUE;

    hr = CoCreateInstance(
            &(pEapcfg->guidConfigCLSID),
            NULL,
            CLSCTX_SERVER,
            &IID_IEAPProviderConfig,
            (PVOID*)&pEapProv
            );

    if ( FAILED( hr ) )
    {
        pEapProv = NULL;
        goto LDone;
    }

    // Call the configuration DLL to popup it's custom configuration UI.
    //
    hr = IEAPProviderConfig_Initialize(
            pEapProv,
            pInfo->pArgs->pszRouter,
            pEapcfg->dwKey,
            &uConnectionParam );

    if ( FAILED( hr ) )
    {
        goto LDone;
    }

    fInitialized = TRUE;

    hr = IEAPProviderConfig_RouterInvokeConfigUI(
            pEapProv,
            pEapcfg->dwKey,
            uConnectionParam,
            pInfo->hwndDlg,
            RAS_EAP_FLAG_ROUTER,
            pEapcfg->pData,
            pEapcfg->cbData,
            &pConnectionData,
            &cbConnectionData );

    if ( FAILED( hr ) )
    {
        // if (dwErr != ERROR_CANCELLED)
            // MsgDlg( pInfo->hwndDlg, SID_ConfigDllApiFailed, NULL );
        goto LDone;
    }

    // Store the configuration information returned in the package descriptor.
    //

    Free( pEapcfg->pData );
    pEapcfg->pData = NULL;
    pEapcfg->cbData = 0;

    if (pConnectionData)
    {
        if (cbConnectionData > 0)
        {
            // Copy it into the eap node
            pEapcfg->pData = Malloc( cbConnectionData );
            if (pEapcfg->pData)
            {
                CopyMemory( pEapcfg->pData, pConnectionData, cbConnectionData );
                pEapcfg->cbData = cbConnectionData;
            }
        }
    }

    // Note any "force user to configure" requirement on the package has been
    // satisfied.
    //
    pEapcfg->fConfigDllCalled = TRUE;

LDone:

    if ( NULL != pConnectionData )
    {
        CoTaskMemFree( pConnectionData );
    }

    if ( fInitialized )
    {
        IEAPProviderConfig_Uninitialize(
            pEapProv,
            pEapcfg->dwKey,
            uConnectionParam );
    }

    if ( NULL != pEapProv )
    {
        IEAPProviderConfig_Release(pEapProv);
    }

    if ( fComInitialized )
    {
        CoUninitialize();
    }
}


VOID
CaRbToggle(
    IN CAINFO* pInfo,
    IN BOOL fEapSelected )

    // Called when the radio button setting is toggled.  'FEapSelected' is set
    // if the EAP option was selected, clear if the "Allowed protocols" option
    // was selected.  'PInfo' is the dialog context.
    //
{
    EnableLbWithRestore(
        pInfo->hwndLbEapPackages, fEapSelected, &pInfo->iLbEapPackages );

    EnableCbWithRestore(
        pInfo->hwndCbPap, !fEapSelected, FALSE, &pInfo->fPap );
    EnableCbWithRestore(
        pInfo->hwndCbSpap, !fEapSelected, FALSE, &pInfo->fSpap );
    EnableCbWithRestore(
        pInfo->hwndCbChap, !fEapSelected, FALSE, &pInfo->fChap );
    EnableCbWithRestore(
        pInfo->hwndCbMsChap, !fEapSelected, FALSE, &pInfo->fMsChap );
    EnableCbWithRestore(
        pInfo->hwndCbW95MsChap, !fEapSelected, FALSE, &pInfo->fW95MsChap );
    EnableCbWithRestore(
        pInfo->hwndCbMsChap2, !fEapSelected, FALSE, &pInfo->fMsChap2 );

    if (fEapSelected)
    {
        EnableCbWithRestore(
            pInfo->hwndCbUseWindowsPw, FALSE, FALSE, &pInfo->fUseWindowsPw );
    }
    else
    {
        CaCbToggle( pInfo, NULL );
    }
}


BOOL
CaSave(
    IN CAINFO* pInfo )

    // Saves control contents to caller's PBENTRY argument.  'PInfo' is the
    // dialog context.
    //
    // Returns TRUE if successful or false if invalid combination of
    // selections was detected and reported.
    //
{
    DWORD dwDe;
    PBENTRY* pEntry;
    DTLNODE* pNodeEap;
    DWORD    dwEapKey;

    pEntry = pInfo->pArgs->pEntry;

    dwDe =
        (DWORD )ComboBox_GetItemData(
            pInfo->hwndLbEncryption,
            ComboBox_GetCurSel( pInfo->hwndLbEncryption ) );

    if (Button_GetCheck( pInfo->hwndRbEap ))
    {
        DTLNODE* pNode;
        EAPCFG* pEapcfg;

        pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
            pInfo->hwndLbEapPackages,
            ComboBox_GetCurSel( pInfo->hwndLbEapPackages ) );
        ASSERT( pNode );

        if(NULL == pNode)
        {
            return FALSE;
        }
        pEapcfg = (EAPCFG* )DtlGetData( pNode );
        ASSERT( pEapcfg );

        // Tell user about required EAP configuration, if applicable.
        //
        if (pNode != pInfo->pOriginalEapcfgNode
            && pEapcfg->fForceConfig
            && !pEapcfg->fConfigDllCalled)
        {
            MsgDlg(
                pInfo->hwndDlg, SID_CustomAuthConfigRequired, NULL );
            ASSERT( IsWindowEnabled( pInfo->hwndPbProperties ) );
            SetFocus( pInfo->hwndPbProperties );
            return FALSE;
        }

        // Tell user EAP doesn't support encryption, if it doesn't and he
        // chose encryption.  This check doesn't apply to L2TP which does not
        // use MPPE.
        //
        if (!(pEntry->dwType == RASET_Vpn
              && pEntry->dwVpnStrategy == VS_L2tpOnly)
            && (dwDe != DE_None && !pEapcfg->fProvidesMppeKeys))
        {
            MsgDlg( pInfo->hwndDlg, SID_NeedEapKeys, NULL );
            return FALSE;
        }

        // Save settings.
        //
        pEntry->dwDataEncryption = dwDe;
        pEntry->dwAuthRestrictions = AR_F_AuthCustom | AR_F_AuthEAP;
        pEntry->fAutoLogon = FALSE;

        dwEapKey = pEapcfg->dwKey;
    }
    else
    {
        DWORD dwAr;

        if (dwDe != DE_None
            && dwDe != DE_IfPossible
            && !(pEntry->dwType == RASET_Vpn
                 && pEntry->dwVpnStrategy == VS_L2tpOnly)
            && !(Button_GetCheck( pInfo->hwndCbMsChap )
                 || Button_GetCheck( pInfo->hwndCbW95MsChap )
                 || Button_GetCheck( pInfo->hwndCbMsChap2 )))
        {
            MsgDlg( pInfo->hwndDlg, SID_MsChapRequired, NULL );
            return FALSE;
        }

        dwAr = AR_F_AuthCustom;
        if (Button_GetCheck( pInfo->hwndCbPap ))
        {
            dwAr |= AR_F_AuthPAP;
        }

        if (Button_GetCheck( pInfo->hwndCbSpap ))
        {
            dwAr |= AR_F_AuthSPAP;
        }

        if (Button_GetCheck( pInfo->hwndCbChap ))
        {
            dwAr |= AR_F_AuthMD5CHAP;
        }

        if (Button_GetCheck( pInfo->hwndCbMsChap ))
        {
            dwAr |= AR_F_AuthMSCHAP;
        }

        if (IsWindowEnabled( pInfo->hwndCbW95MsChap )
            && Button_GetCheck( pInfo->hwndCbW95MsChap ))
        {
            dwAr |= AR_F_AuthW95MSCHAP;
        }

        if (Button_GetCheck( pInfo->hwndCbMsChap2 ))
        {
            dwAr |= AR_F_AuthMSCHAP2;
        }

        if (dwDe != DE_None
            && !(pEntry->dwType == RASET_Vpn
                 && pEntry->dwVpnStrategy == VS_L2tpOnly)
            && (dwAr & (AR_F_AuthPAP | AR_F_AuthSPAP | AR_F_AuthMD5CHAP)))
        {
            MSGARGS msgargs;

            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.dwFlags = MB_YESNO | MB_DEFBUTTON2 | MB_ICONINFORMATION;

            if (MsgDlg(
                    pInfo->hwndDlg, SID_OptionalAuthQuery, &msgargs) == IDNO)
            {
                Button_SetCheck( pInfo->hwndCbPap, FALSE );
                Button_SetCheck( pInfo->hwndCbSpap, FALSE );
                Button_SetCheck( pInfo->hwndCbChap, FALSE );
                return FALSE;
            }
        }

        if (dwAr == AR_F_AuthCustom)
        {
            MsgDlg( pInfo->hwndDlg, SID_NoAuthChecked, NULL );
            return FALSE;
        }

        // Save settings.
        //
        pEntry->dwAuthRestrictions = dwAr;
        pEntry->dwDataEncryption = dwDe;

        if (IsWindowEnabled( pInfo->hwndCbUseWindowsPw ))
        {
            pEntry->fAutoLogon = Button_GetCheck( pInfo->hwndCbUseWindowsPw );
        }
        else
        {
            pEntry->fAutoLogon = FALSE;
        }
        
        dwEapKey = pEntry->dwCustomAuthKey;
    }

        
    for (pNodeEap = DtlGetFirstNode(pInfo->pListEapcfgs);
         pNodeEap;
         pNodeEap = DtlGetNextNode(pNodeEap))
    {
        EAPCFG* pcfg = (EAPCFG* )DtlGetData(pNodeEap);
        ASSERT( pcfg );

        pEntry->dwCustomAuthKey = pcfg->dwKey;

        (VOID) DwSetCustomAuthData(
                        pEntry,
                        pcfg->cbData,
                        pcfg->pData);

        Free0(pcfg->pData);
        pcfg->pData = NULL;                           
    }

    pEntry->dwCustomAuthKey = dwEapKey;

    return TRUE;
}


VOID
CaTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    CAINFO* pInfo;

    TRACE( "CaTerm" );

    pInfo = (CAINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        if (pInfo->pListEapcfgs)
        {
            DtlDestroyList( pInfo->pListEapcfgs, DestroyEapcfgNode );
        }

        Free( pInfo );
        TRACE( "Context freed" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\status.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    status.c
//
// History:
//  Abolade Gbadegesin  Nov-02-1995     Created.
//
// Code for the RAS Monitor property sheet.
//============================================================================

#include "rasdlgp.h"

#define RASMONITORDLG struct tagRASMONITORDLG
RASMONITORDLG
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  DWORD dwStartPage;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

//----------------------------------------------------------------------------
// Function:    RasMonitorDlgW
//
//
// Entry point for RAS status dialog.
//----------------------------------------------------------------------------

BOOL
APIENTRY
RasMonitorDlgW(
    IN LPWSTR lpszDeviceName,
    IN OUT RASMONITORDLG *lpApiArgs
    ) {
    //
    // 352118 Remove broken/legacy public RAS API - RasMonitorDlg
    //
    DbgPrint( "Unsupported Interface - RasMonitorDlg" );

    do
    {
        if (lpApiArgs == NULL) {
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }

        if (lpApiArgs->dwSize != sizeof(RASMONITORDLG)) {
            lpApiArgs->dwError = ERROR_INVALID_SIZE;
            break;
        }

        lpApiArgs->dwError = ERROR_CALL_NOT_IMPLEMENTED;

    } while (FALSE);

    return FALSE;
}

//----------------------------------------------------------------------------
// Function:    RasMonitorDlgA
//
//
// ANSI entry-point for RAS Monitor Dialog.
// This version invokes the Unicode entry-point
//----------------------------------------------------------------------------

BOOL
APIENTRY
RasMonitorDlgA(
    IN LPSTR lpszDeviceName,
    IN OUT RASMONITORDLG *lpApiArgs
    ) {
    //
    // 352118 Remove broken/legacy public RAS API - RasMonitorDlg
    //

    return RasMonitorDlgW(NULL, lpApiArgs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\rasdlghc.h ===
// Copyright (c) 1996, Microsoft Corporation, all rights reserved.
//
// rasdlghc.h
// Remote Access Common Dialogs
// Help constants
//
// 02/06/96 Steve Cobb
//
// The IDs used here should be kept in the range 1000 to 9999.  Each dialog is
// assigned a 2-letter code that appears in all associated constants.  Each
// control has an additional 2-letter code indicating the control class, where
// PB=PushButton, EB=EditBox, LB=ListBox, CB=CheckBox, RB=RadioButton,
// ST=StaticText, GB=GroupBox, CC=CustomControl and CL=ComboListBox.
//

#ifndef _RASDLG_HCH_
#define _RASDLG_HCH_


// Entry property sheet, General page
//
#define HID_GE_GB_ConnectUsing          1000
#define HID_GE_LV_Devices               1001
#define HID_GE_PB_MoveUp                1002
#define HID_GE_PB_MoveDown              1003
#define HID_GE_CB_SharedPhoneNumber     1004
#define HID_GE_PB_Configure             1005
#define HID_GE_CLB_AreaCodes            1007
#define HID_GE_EB_PhoneNumber           1009
#define HID_GE_LB_CountryCodes          1011
#define HID_GE_CB_UseDialingRules       1012
#define HID_GE_PB_Alternates            1013
#define HID_GE_CB_ShowIcon              1014
#define HID_GE_LV_Device                1015
#define HID_GE_EB_ServiceName           1016
#define HID_GE_GB_FirstConnect          1017
#define HID_GE_CB_DialAnotherFirst      1018
#define HID_GE_LB_DialAnotherFirst      1019
#define HID_GE_LB_Devices               1020
#define HID_GE_PB_DialingRules          1021
#define HID_GE_EB_HostName              1022

// Entry property sheet, Shared Access page
//
#define HID_SA_PB_Shared                1150
#define HID_SA_PB_DemandDial            1151
#define HID_SA_PB_Settings              1152
#define HID_SA_LB_PrivateLan            1153

// Entry property sheet, Options page
//
#define HID_OE_GB_Progress              1100
#define HID_OE_CB_DisplayProgress       1101
#define HID_OE_CB_PreviewUserPw         1102
#define HID_OE_CB_PreviewDomain         1103
#define HID_OE_CB_PreviewNumber         1104
#define HID_OE_GB_Redial                1105
#define HID_OE_EB_RedialAttempts        1106
#define HID_OE_LB_RedialTimes           1107
#define HID_OE_LB_IdleTimes             1108
#define HID_OE_CB_RedialOnDrop          1109
#define HID_OE_GB_MultipleDevices       1110
#define HID_OE_LB_MultipleDevices       1111
#define HID_OE_PB_Configure             1112
#define HID_OE_PB_X25                   1113
#define HID_OE_PB_Tunnel                1114
#define HID_OE_RB_DemandDial            1115
#define HID_OE_RB_Persistent            1116
#define HID_OE_LB_IdleTimesRouter       1117
#define HID_OE_PB_Callback              1118


// Entry property sheet, Security page
//
#define HID_LO_RB_TypicalSecurity       1200
#define HID_LO_LB_Auths                 1201
#define HID_LO_CB_UseWindowsPw          1202
#define HID_LO_CB_Encryption            1203
#define HID_LO_RB_AdvancedSecurity      1204
#define HID_LO_PB_Advanced              1205
#define HID_LO_GB_Scripting             1206
#define HID_LO_CB_RunScript             1207
#define HID_LO_CB_Terminal              1208
#define HID_LO_LB_Scripts               1209
#define HID_LO_PB_Edit                  1210
#define HID_LO_PB_Browse                1211
#define HID_LO_GB_SecurityOptions       1212
#define HID_LO_PB_IPSec                 1213
#define HID_LO_PB_IPSecServer			1214

// Entry property sheet, Networking page
//
#define HID_NE_LB_ServerType            1300
#define HID_NE_PB_Settings              1301
#define HID_NE_LV_Components            1302
#define HID_NE_PB_Add                   1303
#define HID_NE_PB_Remove                1304
#define HID_NE_PB_Properties            1305
#define HID_NE_LB_ComponentDesc         1306

// Entry property sheet, Networking page, PPP dialog box
//
#define HID_NE_EnableLcp                1350
#define HID_NE_EnableCompression        1351
#define HID_NE_NegotiateMultilinkAlways 1352

// Entry property sheet, Diagnostic page    for Whistler 460931
//
#define HID_DG_CB_EnableLog             1370
#define HID_DG_PB_Clear                 1371
#define HID_DG_PB_Export                1372

// Alternate numbers dialog
//
#define HID_AN_ST_Explain               1400
#define HID_AN_LV_Numbers               1402
#define HID_AN_PB_Up                    1403
#define HID_AN_PB_Down                  1404
#define HID_AN_PB_Add                   1405
#define HID_AN_PB_Edit                  1406
#define HID_AN_PB_Delete                1407
#define HID_AN_CB_MoveToTop             1408
#define HID_AN_CB_TryNextOnFail         1409

// Phone number editor dialog
//
#define HID_CE_GB_PhoneNumber           1500
#define HID_CE_CLB_AreaCodes            1502
#define HID_CE_EB_PhoneNumber           1504
#define HID_CE_LB_CountryCodes          1506
#define HID_CE_GB_Comment               1507
#define HID_CE_EB_Comment               1508
#define HID_CE_CB_UseDialingRules       1509

// X.25 Logon Settings dialog
//
#define HID_XS_ST_Explain               1600
#define HID_XS_LB_Networks              1602
#define HID_XS_EB_Address               1604
#define HID_XS_GB_Optional              1605
#define HID_XS_EB_UserData              1607
#define HID_XS_EB_Facilities            1609

// Automatic Dialing and Hanging Up dialog
//
#define HID_DM_ST_Explain               1700
#define HID_DM_LB_DialPercent           1702
#define HID_DM_LB_DialTime              1704
#define HID_DM_LB_HangUpPercent         1706
#define HID_DM_LB_HangUpTime            1708

// Custom Authentication dialog
//
#define HID_CA_LB_Encryption            1800
#define HID_CA_GB_LogonSecurity         1801
#define HID_CA_RB_Eap                   1802
#define HID_CA_LB_EapPackages           1803
#define HID_CA_PB_Properties            1804
#define HID_CA_RB_AllowedProtocols      1805
#define HID_CA_CB_Pap                   1806
#define HID_CA_CB_Spap                  1807
#define HID_CA_CB_Chap                  1808
#define HID_CA_CB_MsChap                1809
#define HID_CA_CB_W95MsChap             1810
#define HID_CA_CB_MsChap2               1811
#define HID_CA_CB_UseWindowsPw          1812

// Data Encryption dialog
//
#define HID_ES_LB_Encryptions           1900

// ISDN configure dialog.
//
#define HID_IC_LB_LineType              2000
#define HID_IC_CB_Fallback              2001
#define HID_IC_CB_DownLevel             2002
#define HID_IC_CB_Compression           2003
#define HID_IC_EB_Channels              2004

// Modem configure dialog.
//
#define HID_MC_I_Modem                  2100
#define HID_MC_EB_ModemValue            2101
#define HID_MC_LB_MaxBps                2103
#define HID_MC_GB_Features              2104
#define HID_MC_CB_FlowControl           2105
#define HID_MC_CB_ErrorControl          2106
#define HID_MC_CB_Compression           2107
#define HID_MC_GB_BeforeDial            2108
#define HID_MC_CB_RunScript             2109
#define HID_MC_LB_Scripts               2110
#define HID_MC_CB_Terminal              2111
#define HID_MC_PB_Edit                  2112
#define HID_MC_PB_Browse                2113
#define HID_MC_CB_EnableSpeaker         2114
#define HID_MC_LB_ModemProtocol         2115

// Change password dialog
//
#define HID_CP_ST_Explain               2200
#define HID_CP_EB_OldPassword           2201
#define HID_CP_EB_Password              2202
#define HID_CP_EB_ConfirmPassword       2203

// Dial callback dialog
//
#define HID_DC_ST_Explain               2300
#define HID_DC_EB_Number                2301

// Dial error dialog
//
#define HID_DE_PB_More                  2401
#define HID_DE_PB_Redial                2402
#define HID_DE_CB_EnableDiag            2403    //For whistler460931
#define HID_DE_ST_ConfigureLnk          2404      


// Projection result dialog
//
#define HID_PR_ST_Text                  2500
#define HID_PR_PB_Accept                2501
#define HID_PR_PB_HangUp                2502
#define HID_PR_CB_DisableProtocols      2503

// Retry Authentication dialog
//
#define HID_UA_ST_UserName              2600
#define HID_UA_EB_UserName              2601
#define HID_UA_ST_Password              2602
#define HID_UA_EB_Password              2603
#define HID_UA_ST_Domain                2604
#define HID_UA_EB_Domain                2605
#define HID_UA_CB_SavePassword          2606

// Terminal dialogs
//
#define HID_IT_EB_Screen                2900
#define HID_IT_CC_IpAddress             2901
#define HID_IT_PB_Done                  2902

// Dialer dialogs
//
#define HID_DR_BM_Useless               3000
#define HID_DR_EB_User                  3002
#define HID_DR_EB_Password              3004
#define HID_DR_EB_Domain                3006
#define HID_DR_CB_SavePassword          3007
#define HID_DR_CLB_Numbers              3009
#define HID_DR_LB_Locations             3011
#define HID_DR_PB_Rules                 3012
#define HID_DR_PB_Properties            3013
#define HID_DR_PB_DialConnect           3014
#define HID_DR_PB_Cancel                3016
#define HID_DR_PB_Help                  3017
#define HID_DR_RB_SaveForMe             3018
#define HID_DR_RB_SaveForEveryone       3019

// Main phonebook dialog (temporary).
//
#define HID_DU_BM_Wizard                3400
#define HID_DU_LB_Entries               3401
#define HID_DU_PB_New                   3402
#define HID_DU_PB_More                  3403
#define HID_DU_LB_DialPreview           3404
#define HID_DU_LB_DialFrom              3405
#define HID_DU_PB_Location              3406
#define HID_DU_PB_Dial                  3407
#define HID_DU_PB_Close                 3408

// Phone Number list dialog.
//
#define HID_PN_EB_NewNumber             3500
#define HID_PN_PB_Add                   3501
#define HID_PN_PB_Replace               3502
#define HID_PN_LB_List                  3503
#define HID_PN_PB_Up                    3504
#define HID_PN_PB_Down                  3505
#define HID_PN_PB_Delete                3506
#define HID_PN_CB_Promote               3507


//#if 0

// (Router) Dialing page.
//
#define HID_RD_RB_Persistent            3600
#define HID_RD_RB_DemandDial            3601
#define HID_RD_EB_Attempts              3602
#define HID_RD_EB_Seconds               3603
#define HID_RD_EB_Idle                  3604
#define HID_RD_PB_Callback              3605
#define HID_RD_PB_MultipleLines         3606

// (Router) Callback dialog
//
#define HID_CR_RB_No                    3700
#define HID_CR_RB_Yes                   3701
#define HID_CR_LV_Numbers               3702
#define HID_CR_PB_Edit                  3703
#define HID_CR_PB_Delete                3704

// User preferences property sheet, Appearance page.
//
#define HID_GP_CB_Preview               3801
#define HID_GP_CB_Location              3802
#define HID_GP_CB_Lights                3803
#define HID_GP_CB_Progress              3804
#define HID_GP_CB_CloseOnDial           3805
#define HID_GP_CB_PhonebookEdits        3807
#define HID_GP_CB_LocationEdits         3808
#define HID_GP_CB_UseWizard             3809
#define HID_GP_CB_AutodialPrompt        3810

// User preferences property sheet, Dialing page.
//
#define HID_AD_LV_Enable                3900
#define HID_AD_EB_Attempts              3901
#define HID_AD_EB_Seconds               3902
#define HID_AD_EB_Idle                  3903
#define HID_AD_CB_AskBeforeAutodial     3904
#define HID_AD_CB_DisableThisSession    3905

// User preferences property sheet, Callback page.
//
#define HID_CB_RB_No                    4001
#define HID_CB_RB_Maybe                 4002
#define HID_CB_RB_Yes                   4003
#define HID_CB_LV_Numbers               4004
#define HID_CB_PB_Edit                  4005
#define HID_CB_PB_Delete                4006

// User preferences property sheet, Phonebook page.
//
#define HID_PL_ST_Open                  4100
#define HID_PL_RB_SystemList            4101
#define HID_PL_RB_PersonalList          4102
#define HID_PL_RB_AlternateList         4103
#define HID_PL_CL_Lists                 4104
#define HID_PL_PB_Browse                4105

// Shared access settings property sheet, Applications page.
//
#define HID_SA_LV_Applications          4200
#define HID_SA_PB_Add                   4201
#define HID_SA_PB_Edit                  4202
#define HID_SA_PB_Delete                4203

// Shared access settings property sheet, Services page.
//
#define HID_SS_LV_Services              4250
#define HID_SS_PB_Add                   4251
#define HID_SS_PB_Edit                  4252
#define HID_SS_PB_Delete                4253

// Shared access settings property sheet, New Application dialog.
//
#define HID_SA_EB_Application           4300
#define HID_SA_EB_Port                  4301
#define HID_SA_PB_Tcp                   4302
#define HID_SA_PB_Udp                   4303
#define HID_SA_EB_TcpResponse           4304
#define HID_SA_EB_UdpResponse           4305

// Shared access settings property sheet, New Service dialog.
//
#define HID_SS_EB_Service               4350
#define HID_SS_EB_Port                  4351
#define HID_SS_PB_Tcp                   4352
#define HID_SS_PB_Udp                   4353
#define HID_SS_EB_Address               4354

// User preferences property sheet, Connections page.
//
#define HID_CO_GB_LogonPrivileges             4400
#define HID_CO_CB_AllowConnectionModification 4401

// User preferences property sheet, Callback page.
//
#define HID_ZE_ST_CallbackNumber        4450

// IP Security Policy Dialog box
//
#define HID_CI_CB_PresharedKey          4500
#define HID_CI_EB_PSK                   4501

// For diagnostic Generate Report dialog box    For whistler 460931
//
#define HID_EL_RB_ViewReport            4520
#define HID_EL_RB_File                  4521
#define HID_EL_EB_FileName              4522
#define HID_EL_PB_Browse                4523
#define HID_EL_RB_Email                 4524
#define HID_EL_EB_EmailAddress          4525
#define HID_EL_CB_SimpleReport          4526
#define HID_EL_ST_FileName              4527

//#endif


// Start of RAS error contexts and the single context for non-RAS errors.  So,
// 9700 is error 600, 9701 is error 601, etc.
//
#define HID_RASERRORBASE                9700
#define HID_RECONNECTING                9998
#define HID_NONRASERROR                 9999




#endif // _RASDLG_HCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\terminal.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// terminal.c
// Remote Access Common Dialog APIs
// Terminal dialogs
//
// 08/28/95 Steve Cobb


#include "rasdlgp.h"
#include "rasscrpt.h"


#define WM_EOLFROMDEVICE    (WM_USER+999)
#define SECS_ReceiveTimeout 1
#define SIZE_ReceiveBuf     1024
#define SIZE_SendBuf        1


//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwItHelp[] =
{
    CID_IT_EB_Screen,    HID_IT_EB_Screen,
    CID_IT_ST_IpAddress, HID_IT_CC_IpAddress,
    CID_IT_CC_IpAddress, HID_IT_CC_IpAddress,
    IDOK,                HID_IT_PB_Done,
    0, 0
};


//----------------------------------------------------------------------------
// Local datatypes (alphabetically)
//----------------------------------------------------------------------------

// Interactive terminal dialog argument block.
//
typedef struct
_ITARGS
{
    DWORD sidTitle;
    TCHAR* pszIpAddress;
    HRASCONN hrasconn;
    PBENTRY* pEntry;
    RASDIALPARAMS* pRdp;
}
ITARGS;


// Interactive terminal dialog context block.
//
typedef struct
_ITINFO
{
    // Caller's arguments to the dialog.
    //
    ITARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndEbScreen;
    HWND hwndCcIpAddress;
    HWND hwndPbBogus;

    // Set when waiting for the thread to terminate.
    //
    BOOL fAbortReceiveLoop;

    // Original dialog and screen edit box window proc.
    //
    WNDPROC pOldWndProc;
    WNDPROC pOldEbScreenWndProc;

    // buffers for RasScriptSend/RasScriptReceive.
    //
    BYTE pbyteReceiveBuf[SIZE_ReceiveBuf];
    BYTE pbyteSendBuf[SIZE_SendBuf];

    // handle to active script on this connection
    //
    HANDLE hscript;

    // Screen edit box font and brush.
    //
    HFONT hfontEbScreen;
    HBRUSH hbrEbScreen;
}
ITINFO;


//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

INT_PTR CALLBACK
ItDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ItCommand(
    IN ITINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

LRESULT APIENTRY
ItEbScreenWndProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam );

BOOL
ItInit(
    IN HWND    hwndDlg,
    IN ITARGS* pArgs );

BOOL
ItRasApiComplete(
    IN ITINFO* pInfo );

DWORD
ItReceiveMonitorThread(
    LPVOID pThreadArg );

VOID
ItTerm(
    IN HWND hwndDlg );

VOID
ItViewScriptLog(
    IN HWND   hwndOwner );

LRESULT APIENTRY
ItWndProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam );


//----------------------------------------------------------------------------
// Terminal dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
TerminalDlg(
    IN PBENTRY* pEntry,
    IN RASDIALPARAMS* pRdp,
    IN HWND hwndOwner,
    IN HRASCONN hrasconn,
    IN DWORD sidTitle,
    IN OUT TCHAR* pszIpAddress )

    // Pops-up the Terminal dialog.  'HwndOwner' is the window owning the
    // dialog.  'Hrasconn' is the RAS connection handle to talk on.
    // 'SidTitle' is ID of the string displayed as the window caption.
    // 'PszIpAddress' is caller's buffer of at least 16 characters containing
    // the initial IP address on entry and the edited IP address on exit.  If
    // 'pszIpAddress' is empty, no IP address field is displayed.
    //
    // Returns true if user pressed OK and succeeded, false if he pressed
    // Cancel or encountered an error.
    //
{
    INT_PTR nStatus;
    INT nDlg;
    ITARGS args;

    TRACE( "TerminalDlg" );

    if (pszIpAddress && pszIpAddress[ 0 ])
    {

        InitCommonControls();
        IpAddrInit( g_hinstDll, SID_PopupTitle, SID_BadIpAddrRange );

        nDlg = DID_IT_SlipTerminal;
    }
    else
    {
        nDlg = DID_IT_Terminal;
    }

    args.pszIpAddress = pszIpAddress;
    args.sidTitle = sidTitle;
    args.hrasconn = hrasconn;
    args.pEntry = pEntry;
    args.pRdp = pRdp;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( nDlg ),
            hwndOwner,
            ItDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        TRACE1("TerminalDlg: GLE=%d", GetLastError());
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
ItDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Interactive Terminal dialog.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "ItDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return ItInit( hwnd, (ITARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwItHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            ITINFO* pInfo = (ITINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return ItCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_RASAPICOMPLETE:
        {
            ITINFO* pInfo = (ITINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            // The notification code from the scripting-thread is in 'lparam'
            //
            switch (lparam)
            {
                case SCRIPTCODE_Done:
                {
                    EndDialog(hwnd, TRUE);
                    return TRUE;
                }

                case SCRIPTCODE_Halted:
                {
                    MSGARGS msg;

                    // The script has halted programmatically, for instance
                    // because of an explicit "halt" command.  Show a popup
                    // indicating things have stopped, but don't dismiss the
                    // dialog.
                    //
                    ZeroMemory(&msg, sizeof(msg));
                    msg.dwFlags = MB_OK | MB_ICONINFORMATION;
                    MsgDlg( hwnd, SID_OP_ScriptHalted, &msg );
                    return TRUE;
                }

                case SCRIPTCODE_HaltedOnError:
                {
                    MSGARGS msg;
                    INT nResponse;

                    // There was an execution-error in the script; show a
                    // popup asking if the user wants to view the errors, and
                    // if the user clicks 'Yes' invoke Notepad on the file
                    // %windir%\system32\ras\script.log.  Since this is an
                    // error condition, dismiss the dialog.
                    //
                    ZeroMemory(&msg, sizeof(msg));
                    msg.dwFlags = MB_YESNO | MB_ICONQUESTION;
                    nResponse = MsgDlg(
                        hwnd, SID_OP_ScriptHaltedOnError, &msg );

                    if (nResponse == IDYES)
                    {
                        ItViewScriptLog( hwnd );
                    }

                    EndDialog(hwnd, FALSE);
                    return TRUE;
                }

                case SCRIPTCODE_KeyboardEnable:
                {
                    // Allow keyboard input in the edit-box.
                    //
                    EnableWindow(pInfo->hwndEbScreen, TRUE);
                    return TRUE;
                }

                case SCRIPTCODE_KeyboardDisable:
                {
                    // Disallow keyboard input in the edit-box; if the
                    // edit-box currently has the focus, we first set the
                    // focus to the 'Done' button.
                    //
                    if (GetFocus() == pInfo->hwndEbScreen)
                    {
                        SetFocus( GetDlgItem (hwnd, IDOK ) );
                    }

                    EnableWindow( pInfo->hwndEbScreen, FALSE );
                    return TRUE;
                }

                case SCRIPTCODE_IpAddressSet:
                {
                    DWORD dwErr;
                    CHAR szAddress[ RAS_MaxIpAddress + 1 ];

                    // The script is notifying us that the IP address has been
                    // changed programmatically.
                    //
                    // Get the new IP address.
                    //
                    dwErr = RasScriptGetIpAddress( pInfo->hscript, szAddress );

                    if (dwErr == NO_ERROR)
                    {
                        TCHAR* psz;

                        // Save the new IP address.
                        //
                        psz = StrDupTFromA(szAddress);

                        if (NULL != psz)
                        {
                            // Whistler bug 224074 use only lstrcpyn's to
                            // prevent maliciousness
                            //
                            lstrcpyn(
                                pInfo->pArgs->pszIpAddress,
                                psz,
                                TERM_IpAddress);
                            Free0(psz);
                        }

                        // Display it in the IP-address edit-box
                        //
                        if (pInfo->hwndCcIpAddress)
                        {
                            SetWindowText( pInfo->hwndCcIpAddress,
                                pInfo->pArgs->pszIpAddress );
                        }
                    }

                    return TRUE;
                }

                case SCRIPTCODE_InputNotify:
                {
                    // Handle input-notification.
                    //
                    return ItRasApiComplete( pInfo );
                }

                return TRUE;
            }
        }

        case WM_DESTROY:
        {
            ItTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
ItCommand(
    IN ITINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "ItCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_IT_EB_Screen:
        {

            // Turn off the default button whenever the terminal window
            // has the focus.  Pressing [Return] in the terminal acts like
            // a normal terminal.
            //
            Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbBogus );

            // Don't select the entire string on entry.
            //
            Edit_SetSel( pInfo->hwndEbScreen, (UINT )-1, 0 );

            break;
        }

        case IDOK:
        {
            TRACE("OK pressed");

            if (pInfo->pArgs->pszIpAddress)
            {
                GetWindowText(
                    pInfo->hwndCcIpAddress, pInfo->pArgs->pszIpAddress, 16 );
            }

            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
            TRACE("Cancel pressed");
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
    }

    return FALSE;
}


LRESULT APIENTRY
ItEbScreenWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam )

    // Subclassed terminal edit box window procedure.
    //
    // Return value depends on message type.
    //
{
    ITINFO* pInfo;
    BOOL fSend;
    BOOL fSendTab;

    fSend = fSendTab = FALSE;

    if (unMsg == WM_EOLFROMDEVICE)
    {
        // An end-of-line in the device input was received.  Send a linefeed
        // character to the window.
        //
        wParam = '\n';
        unMsg = WM_CHAR;
    }
    else
    {
        BOOL fCtrlKeyDown = (GetKeyState( VK_CONTROL ) < 0);
        BOOL fShiftKeyDown = (GetKeyState( VK_SHIFT ) < 0);

        if (unMsg == WM_KEYDOWN)
        {
            // The key was pressed by the user.
            //
            if (wParam == VK_RETURN && !fCtrlKeyDown && !fShiftKeyDown)
            {
                // Enter key pressed without Shift or Ctrl is discarded.  This
                // prevents Enter from being interpreted as "press default
                // button" when pressed in the edit box.
                //
                return 0;
            }

            if (fCtrlKeyDown && wParam == VK_TAB)
            {
                fSend = TRUE;
                fSendTab = TRUE;
            }
        }
        else if (unMsg == WM_CHAR)
        {
            // The character was typed by the user.
            //
            if (wParam == VK_TAB)
            {
                // Ignore tabs...Windows sends this message when Tab (leave
                // field) is pressed but not when Ctrl+Tab (insert a TAB
                // character) is pressed...weird.
                //
                return 0;
            }

            fSend = TRUE;
        }
    }

    pInfo = (ITINFO* )GetWindowLongPtr( GetParent( hwnd ), DWLP_USER );
    ASSERT(pInfo);

    if (fSend)
    {
        DWORD dwErr;

        pInfo->pbyteSendBuf[ 0 ] = (BYTE )wParam;
        dwErr = RasScriptSend(
            pInfo->hscript, pInfo->pbyteSendBuf, SIZE_SendBuf);
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_RasPortSend, dwErr, NULL );
        }

        if (!fSendTab)
        {
            return 0;
        }
    }

    // Call the previous window procedure for everything else.
    //
    return
        CallWindowProc(
            pInfo->pOldEbScreenWndProc, hwnd, unMsg, wParam, lParam );
}


BOOL
ItInit(
    IN HWND hwndDlg,
    IN ITARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the phonebook
    // dialog window.  'pEntry' is caller's entry as passed to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    ITINFO* pInfo;
    WORD wReceiveSize;
    WORD wSendSize;
    WORD wSize;
    DWORD dwThreadId;

    TRACE( "ItInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndEbScreen = GetDlgItem( hwndDlg, CID_IT_EB_Screen );
    ASSERT( pInfo->hwndEbScreen );
    pInfo->hwndPbBogus = GetDlgItem( hwndDlg, CID_IT_PB_BogusButton );
    ASSERT( pInfo->hwndPbBogus );
    if (pArgs->pszIpAddress && pArgs->pszIpAddress[0])
    {
        pInfo->hwndCcIpAddress = GetDlgItem( hwndDlg, CID_IT_CC_IpAddress );
        ASSERT( pInfo->hwndCcIpAddress );

        if (*pArgs->pszIpAddress)
        {
            SetWindowText( pInfo->hwndCcIpAddress, pArgs->pszIpAddress );
        }
        else
        {
            SetWindowText( pInfo->hwndCcIpAddress, TEXT("0.0.0.0") );
        }
    }

    // Set the dialog title.
    //
    {
        TCHAR* psz = PszFromId( g_hinstDll, pArgs->sidTitle );
        if (psz)
        {
            SetWindowText( hwndDlg, psz );
            Free( psz );
        }
    }

    // Subclass the dialog and screen edit box.
    //
    pInfo->pOldWndProc =
        (WNDPROC )SetWindowLongPtr(
            pInfo->hwndDlg, GWLP_WNDPROC, (ULONG_PTR )ItWndProc );
    pInfo->pOldEbScreenWndProc =
        (WNDPROC )SetWindowLongPtr(
            pInfo->hwndEbScreen, GWLP_WNDPROC, (ULONG_PTR )ItEbScreenWndProc );

    // Prepare for special TTY-ish painting.
    //
    pInfo->hfontEbScreen =
        SetFont( pInfo->hwndEbScreen, TEXT("Courier New"),
            FIXED_PITCH | FF_MODERN, 9, FALSE, FALSE, FALSE, FALSE );

    pInfo->hbrEbScreen = (HBRUSH )GetStockObject( BLACK_BRUSH );

    // Initialize script-processing/data-receipt
    //
    {
        CHAR* pszUserName;
        CHAR* pszPassword;

        pszUserName = StrDupAFromT( pInfo->pArgs->pRdp->szUserName );

        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded by DpInteractive() -or- DwTerminalDlg()
        //
        DecodePassword( pInfo->pArgs->pRdp->szPassword );
        pszPassword = StrDupAFromT( pInfo->pArgs->pRdp->szPassword );
        EncodePassword( pInfo->pArgs->pRdp->szPassword );

        // Initialize the script.  The script DLL is 'delayload' hence the
        // exception handling.
        //
        __try
        {
            dwErr = RasScriptInit(
                pInfo->pArgs->hrasconn, pInfo->pArgs->pEntry,
                pszUserName, pszPassword, RASSCRIPT_NotifyOnInput |
                RASSCRIPT_HwndNotify, (HANDLE)hwndDlg, &pInfo->hscript );
            TRACE1( "RasScriptInit(e=%d)", dwErr );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            ErrorDlg(
                hwndDlg, SID_OP_LoadDlg, STATUS_PROCEDURE_NOT_FOUND, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        Free0( pszUserName );

        // Whistler bug 254385 encode password when not being used
        // Whistler bug 275526 NetVBL BVT Break: Routing BVT broken
        //
        if (pszPassword)
        {
            RtlSecureZeroMemory( pszPassword, strlen(pszPassword) + 1 );
            Free( pszPassword );
        }

        // See whether anything went wrong in the script-initialization
        //
        if (dwErr == ERROR_SCRIPT_SYNTAX)
        {
            MSGARGS msg;
            INT nResponse;

            // There was a syntax error in the script; show a popup asking if
            // the user wants to view the errors, and if so bring up Notepad
            // on %windir%\system32\ras\script.log.
            //
            // Center the dialog on our parent rather than on the dialog,
            // since the dialog is not yet visible.
            //
            ZeroMemory(&msg, sizeof(msg));
            msg.dwFlags = MB_YESNO | MB_ICONQUESTION;
            nResponse = MsgDlg( GetParent( hwndDlg ),
                SID_ConfirmViewScriptLog, &msg );

            if (nResponse == IDYES)
            {
                ItViewScriptLog( hwndDlg );
            }

            // Terminate the dialog.  This hangs up the connection.
            //
            EndDialog( hwndDlg, FALSE );

            return TRUE;
        }
        else if (dwErr != 0)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, dwErr, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }
    }

    // Center dialog on the owner window, and hide the owner window which is
    // currently assumed to be the dial progress dialog.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    SetOffDesktop( GetParent( hwndDlg ), SOD_MoveOff, NULL );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Set initial focus to the screen.
    //
    SetFocus( pInfo->hwndEbScreen );
    return FALSE;
}


BOOL
ItRasApiComplete(
    IN ITINFO* pInfo )

    // Called on WM_RASAPICOMPLETE, i.e. an asynchronous RasPortReceive
    // completed.  'PInfo' is the dialog context block.
    //
    // Returns true if processed the message, false otherwise.
    //
{
    DWORD dwErr;
    DWORD dwSize = SIZE_ReceiveBuf;
    RASMAN_INFO info;

    TRACE( "RasScriptReceive" );
    dwErr = RasScriptReceive(
        pInfo->hscript, pInfo->pbyteReceiveBuf, &dwSize);
    TRACE1( "RasScriptReceive=%d",dwErr );
    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_RasGetInfo, dwErr, NULL );
        EndDialog( pInfo->hwndDlg, FALSE );
        return TRUE;
    }

    info.RI_BytesReceived = (WORD )dwSize;

    // Send the device talk to the terminal edit box.
    //
    if (info.RI_BytesReceived > 0)
    {
        CHAR szBuf[ SIZE_ReceiveBuf + 1 ];
        CHAR* pch = szBuf;
        WORD i;

        TRACE1( "Read %d", info.RI_BytesReceived );

        for (i = 0; i < info.RI_BytesReceived; ++i)
        {
            CHAR ch = pInfo->pbyteReceiveBuf[ i ];

            // Formatting: Converts CRs to LFs (there seems to be no VK_ for
            // LF) and throws away LFs.  This prevents the user from exiting
            // the dialog when they press Enter (CR) in the terminal screen.
            // LF looks like CRLF in the edit box.  Also, throw away TABs
            // because otherwise they change focus to the next control.
            //
            if (ch == VK_RETURN)
            {
                // Must send whenever end-of-line is encountered because
                // EM_REPLACESEL doesn't handle VK_RETURN characters well
                // (prints garbage).
                //
                *pch = '\0';

                // Turn off current selection, if any, and replace the null
                // selection with the current buffer.  This has the effect of
                // adding the buffer at the caret.  Finally, send the EOL to
                // the window which (unlike EM_REPLACESEL) handles it
                // correctly.
                //
                Edit_SetSel( pInfo->hwndEbScreen, (UINT )-1, 0 );
                SendMessageA( pInfo->hwndEbScreen,
                    EM_REPLACESEL, (WPARAM )0, (LPARAM )szBuf );
                SendMessage( pInfo->hwndEbScreen, WM_EOLFROMDEVICE, 0, 0 );

                // Start afresh on the output buffer.
                //
                pch = szBuf;
                continue;
            }
            else if (ch == '\n' || ch == VK_TAB)
            {
                continue;
            }

            *pch++ = ch;
        }

        *pch = '\0';

        if (pch != szBuf)
        {
            // Send the last remnant of the line.
            //
            Edit_SetSel( pInfo->hwndEbScreen, (UINT )-1, 0 );
            SendMessageA( pInfo->hwndEbScreen,
                EM_REPLACESEL, (WPARAM )0, (LPARAM )szBuf );
        }
    }

    return TRUE;
}


VOID
ItTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    ITINFO* pInfo = (ITINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "ItTerm" );

    if (pInfo)
    {
        // Close RAS script resources
        //
        if (pInfo->hscript)
        {
            TRACE( "Stop script processing" );

            // Shutdown script processing
            //
            TRACE( "RasScriptTerm" );
            RasScriptTerm( pInfo->hscript );
            TRACE( "RasScriptTerm done" );
        }

        // De-activate WndProc hooks.
        //
        if (pInfo->pOldEbScreenWndProc)
        {
            SetWindowLongPtr( pInfo->hwndEbScreen,
                GWLP_WNDPROC, (ULONG_PTR )pInfo->pOldEbScreenWndProc );
        }
        if (pInfo->pOldWndProc)
        {
            SetWindowLongPtr( pInfo->hwndDlg,
                GWLP_WNDPROC, (ULONG_PTR )pInfo->pOldWndProc );
        }

        if (pInfo->hfontEbScreen)
        {
            DeleteObject( (HGDIOBJ )pInfo->hfontEbScreen );
        }

        SetOffDesktop( GetParent( hwndDlg ), SOD_MoveBackFree, NULL );

        Free( pInfo );
    }
}


VOID
ItViewScriptLog(
    IN HWND hwndOwner )

    // Starts notepad.exe on the script log file, script.log.  'HwndOwner' is
    // the window to center any error popup on.
    //
{
    DWORD dwSize;
    TCHAR szCmd[ (MAX_PATH * 2) + 50 + 1 ];
    TCHAR* pszCmd;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL f;

    // Format the command-line string invoking Notepad on the script-log; note
    // the double-quotes around the script-log's path, which are needed since
    // RASSCRIPT_LOG is %windir%\system32\ras\script.log and so the expanded
    // result may contain spaces.
    //
    wsprintf( szCmd, TEXT("notepad.exe \"%s\""), TEXT(RASSCRIPT_LOG) );

    // Get the size of the expanded command-line
    //
    dwSize = ExpandEnvironmentStrings(szCmd, NULL, 0);

    // Allocate enough space for the expanded command-line
    //
    pszCmd = Malloc( (dwSize + 1) * sizeof(TCHAR) );
    if (!pszCmd)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadScriptLog, GetLastError(), NULL );
        return;
    }

    // Expand the command-line into the allocated space
    //
    ExpandEnvironmentStrings(szCmd, pszCmd, dwSize);

    // Initialize the startup-info structure
    //
    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);

    // Launch Notepad on the script-log.
    //
    f = CreateProcess(
            NULL, pszCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi );
    Free(pszCmd);

    if (f)
    {
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
    }
    else
    {
        ErrorDlg( hwndOwner, SID_OP_LoadScriptLog, GetLastError(), NULL );
    }
}


LRESULT APIENTRY
ItWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam )

    // Subclassed dialog window procedure.
    //
    // Return value depends on message type.
    //
{
    ITINFO* pInfo = (ITINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
    ASSERT(pInfo);

#if 0
    TRACE4( "ItWndProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_CTLCOLOREDIT:
        {
            // Set terminal screen colors to TTY-ish green on black.
            //
            if (pInfo->hbrEbScreen)
            {
                SetBkColor( (HDC )wParam, RGB( 0, 0, 0 ) );
                SetTextColor( (HDC )wParam, RGB( 2, 208, 44 ) );
                return (LRESULT )pInfo->hbrEbScreen;
            }
            break;
        }
    }

    // Call the previous window procedure for everything else.
    //
    return
        CallWindowProc(
            pInfo->pOldWndProc, hwnd, unMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\uiinfo.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U I I N F O . H
//
//  Contents:   Declares a call-back COM object used to raise properties
//              on INetCfg components.  This object implements the
//              INetRasConnectionUiInfo interface.
//
//  Notes:
//
//  Author:     shaunco   1 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once
#include "entryps.h"

EXTERN_C
HRESULT
HrCreateUiInfoCallbackObject (
    PEINFO*     pInfo,
    IUnknown**  ppunk);

EXTERN_C
void
RevokePeinfoFromUiInfoCallbackObject (
    IUnknown*   punk);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasphone\netcfg.cpp ===
// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <ncnetcfg.h>
#include <initguid.h>
#include <devguid.h>
#include <netcfg_i.c>
#include "rasphone.rch"


EXTERN_C
VOID
Install(
    IN HINSTANCE hinst,
    IN HWND hwndOwner,
    INetCfg* pNetCfg )

    /* Runs the RAS install program.  'HwndOwner' is the owning window or NULL
    ** if none.  'PNetCfg' is the initialized net configuration object.
    */
{
    HRESULT hr;

    /* Install RAS.
    */
    hr = HrInstallComponentOboUser(
        pNetCfg, GUID_DEVCLASS_NETSERVICE,
        NETCFG_SERVICE_CID_MS_RASCLI,
        NULL );

    if (SUCCEEDED(hr))
    {
        hr = HrValidateAndApplyOrCancelINetCfg (pNetCfg, hwndOwner);

        if (NETCFG_S_REBOOT == hr)
        {
            LPCTSTR pszCaption = SzLoadString(hinst, SID_PopupTitle);
            LPCTSTR pszText    = SzLoadString(hinst, SID_RestartText1);
            MessageBox (hwndOwner, pszText, pszCaption, MB_OK);
        }
    }
}

EXTERN_C
HRESULT HrCreateAndInitINetCfg (BOOL fInitCom, INetCfg** ppnc)
{
    return HrCreateAndInitializeINetCfg (fInitCom, ppnc);
}

EXTERN_C
HRESULT HrUninitAndReleaseINetCfg (BOOL fUninitCom, INetCfg* pnc)
{
    return HrUninitializeAndReleaseINetCfg (fUninitCom, pnc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\uiinfo.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U I I N F O . C P P
//
//  Contents:   Implements a call-back COM object used to raise properties
//              on INetCfg components.  This object implements the
//              INetRasConnectionIpUiInfo interface.
//
//  Notes:
//
//  Author:     shaunco   1 Jan 1998
//
//----------------------------------------------------------------------------

#include "rasdlgp.h"
#include "netconp.h"
#include "uiinfo.h"


class CRasConnectionUiIpInfo :
    public INetRasConnectionIpUiInfo
{
private:
    ULONG   m_cRef;
    PEINFO* m_pInfo;

friend
    void
    RevokePeinfoFromUiInfoCallbackObject (
        IUnknown*   punk);

public:
    CRasConnectionUiIpInfo (PEINFO* pInfo);

    // IUnknown
    //
    STDMETHOD (QueryInterface) (REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)  (void);
    STDMETHOD_(ULONG, Release) (void);

    // INetRasConnectionIpUiInfo
    //
    STDMETHOD (GetUiInfo) (RASCON_IPUI*  pIpui);
};


// Constructor.  Set our reference count to 1 and initialize our members.
//
CRasConnectionUiIpInfo::CRasConnectionUiIpInfo (
    PEINFO* pInfo)
{
    m_cRef = 1;
    m_pInfo = pInfo;
}

// IUnknown
//
STDMETHODIMP
CRasConnectionUiIpInfo::QueryInterface (
    REFIID riid,
    void** ppv)
{
    static const IID IID_INetRasConnectionIpUiInfo =
        {0xFAEDCF58,0x31FE,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

    if (!ppv)
    {
        return E_POINTER;
    }
    if ((IID_IUnknown == riid) ||
        (IID_INetRasConnectionIpUiInfo == riid))
    {
        *ppv = static_cast<void*>(static_cast<IUnknown*>(this));
        AddRef ();
        return S_OK;
    }
    *ppv = NULL;
    return E_NOINTERFACE;
}

// Standard AddRef and Release implementations.
//
STDMETHODIMP_(ULONG)
CRasConnectionUiIpInfo::AddRef (void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CRasConnectionUiIpInfo::Release (void)
{
    ULONG cRef = --m_cRef;
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}

// INetRasConnectionIpUiInfo
//
STDMETHODIMP
CRasConnectionUiIpInfo::GetUiInfo (
    RASCON_IPUI*    pIpui)
{
    // Validate parameters.
    //
    if (!pIpui)
    {
        return E_POINTER;
    }

    ZeroMemory (pIpui, sizeof(*pIpui));

    // We need to have a PEINFO with which to answer the call.
    // If it was revoked, it means we're being called after everything
    // has gone away.  (The caller probably has not released us when he
    // he should have.)
    //
    if (!m_pInfo)
    {
        return E_UNEXPECTED;
    }

    PBENTRY* pEntry = m_pInfo->pArgs->pEntry;

    // Phonebook upgrade code needs to assure that pGuid is always present.
    //
    pIpui->guidConnection = *pEntry->pGuid;

    // Set whether its SLIP or PPP.
    //
    if (BP_Slip == pEntry->dwBaseProtocol)
    {
        pIpui->dwFlags = RCUIF_SLIP;
    }
    else
    {
        pIpui->dwFlags = RCUIF_PPP;
    }

    // Set whether this is demand dial or not
    //
    if (m_pInfo->pArgs->fRouter)
    {
        pIpui->dwFlags |= RCUIF_DEMAND_DIAL;
    }

    // Set whether we're in non-admin mode (406630)
    //
    if (m_pInfo->fNonAdmin)
    {
        pIpui->dwFlags |= RCUIF_NOT_ADMIN;
    }

// !!! This is temporary and can be removed when this flag has been added to
//     the checked in necomp IDL file.
//
#ifndef RCUIF_VPN
#define RCUIF_VPN 0x40
#endif

    // Note if it's a VPN connection.
    //
    if (pEntry->dwType == RASET_Vpn)
    {
        pIpui->dwFlags |= RCUIF_VPN;
    }

    // Set whether to use a specific IP address.
    //
    // Whistler bug 304064 NT4SLIP connection gets wrong IP settings on upgrade
    //
    if (pEntry->pszIpAddress &&
        ((BP_Slip == pEntry->dwBaseProtocol) ||
         (ASRC_RequireSpecific == pEntry->dwIpAddressSource)))
    {
        pIpui->dwFlags |= RCUIF_USE_IP_ADDR;

        if (pEntry->pszIpAddress &&
            lstrcmp(pEntry->pszIpAddress, TEXT("0.0.0.0")))
        {
            lstrcpynW (
                pIpui->pszwIpAddr,
                pEntry->pszIpAddress,
                sizeof(pIpui->pszwIpAddr) / sizeof(WCHAR));
        }
    }

    // Set whether to use specific name server addresses.
    //
    // Whistler bug 304064 NT4SLIP connection gets wrong IP settings on upgrade
    //
    if (((BP_Slip == pEntry->dwBaseProtocol) ||
         (ASRC_RequireSpecific == pEntry->dwIpNameSource)) &&
        (pEntry->pszIpDnsAddress  || pEntry->pszIpDns2Address ||
         pEntry->pszIpWinsAddress || pEntry->pszIpWins2Address))
    {
        pIpui->dwFlags |= RCUIF_USE_NAME_SERVERS;

        // Since the phonebook stores zeros even for unused IP address
        // strings, we need to ignore them explicitly.
        //
        if (pEntry->pszIpDnsAddress &&
            lstrcmp(pEntry->pszIpDnsAddress, TEXT("0.0.0.0")))
        {
            lstrcpynW (
                pIpui->pszwDnsAddr,
                pEntry->pszIpDnsAddress,
                sizeof(pIpui->pszwDnsAddr) / sizeof(WCHAR));
        }

        if (pEntry->pszIpDns2Address &&
            lstrcmp(pEntry->pszIpDns2Address, TEXT("0.0.0.0")))
        {
            lstrcpynW (
                pIpui->pszwDns2Addr,
                pEntry->pszIpDns2Address,
                sizeof(pIpui->pszwDns2Addr) / sizeof(WCHAR));
        }

        if (pEntry->pszIpWinsAddress &&
            lstrcmp(pEntry->pszIpWinsAddress, TEXT("0.0.0.0")))
        {
            lstrcpynW (
                pIpui->pszwWinsAddr,
                pEntry->pszIpWinsAddress,
                sizeof(pIpui->pszwWinsAddr) / sizeof(WCHAR));
        }

        if (pEntry->pszIpWins2Address &&
            lstrcmp(pEntry->pszIpWins2Address, TEXT("0.0.0.0")))
        {
            lstrcpynW (
                pIpui->pszwWins2Addr,
                pEntry->pszIpWins2Address,
                sizeof(pIpui->pszwWins2Addr) / sizeof(WCHAR));
        }
    }

    if (!m_pInfo->pArgs->fRouter && pEntry->fIpPrioritizeRemote)
    {
        pIpui->dwFlags |= RCUIF_USE_REMOTE_GATEWAY;
    }

    if (pEntry->fIpHeaderCompression)
    {
        pIpui->dwFlags |= RCUIF_USE_HEADER_COMPRESSION;
    }

    if (BP_Slip == pEntry->dwBaseProtocol)
    {
        pIpui->dwFrameSize = pEntry->dwFrameSize;
    }

    // pmay: 389632  
    // 
    // Initialize the dns controls
    //
    if (pEntry->dwIpDnsFlags & DNS_RegPrimary)
    {
        if ((pEntry->dwIpDnsFlags & DNS_RegPerConnection) ||
            (pEntry->dwIpDnsFlags & DNS_RegDhcpInform))
        {
            pIpui->dwFlags |= RCUIF_USE_PRIVATE_DNS_SUFFIX;
        }
    }
    else
    {
        pIpui->dwFlags |= RCUIF_USE_DISABLE_REGISTER_DNS;
    }

    if (pEntry->pszIpDnsSuffix)
    {
        lstrcpyn(
            pIpui->pszwDnsSuffix,
            pEntry->pszIpDnsSuffix,
            255);
    }

    if (pEntry->dwIpNbtFlags & PBK_ENTRY_IP_NBT_Enable)
    {
        pIpui->dwFlags |= RCUIF_ENABLE_NBT;
    }

    return S_OK;
}


EXTERN_C
HRESULT
HrCreateUiInfoCallbackObject (
    PEINFO*     pInfo,
    IUnknown**  ppunk)
{
    // Validate parameters.
    //
    if (!pInfo || !ppunk)
    {
        return E_POINTER;
    }

    // Create the object and return its IUnknown interface.
    // This assumes the object is created with a ref-count of 1.
    // (Check the constructor above to make sure.)
    //
    HRESULT hr = S_OK;
    CRasConnectionUiIpInfo* pObj = new CRasConnectionUiIpInfo (pInfo);
    if (pObj)
    {
        *ppunk = static_cast<IUnknown*>(pObj);
    }
    else
    {
        *ppunk = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// Set the m_pInfo member to NULL.  Since we don't have direct control over
// the lifetime of this object (clients can hold references as long as they
// want) revoking m_pInfo is a saftey net to keep us from trying to access
// memory that may have gone away.
//
EXTERN_C
void
RevokePeinfoFromUiInfoCallbackObject (
    IUnknown*   punk)
{
    CRasConnectionUiIpInfo* pObj = static_cast<CRasConnectionUiIpInfo*>(punk);
    pObj->m_pInfo = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\ast.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// ast.c
//
// This file contains the abstract syntax tree functions.
//
// History:
//  05-20-95 ScottH     Created
//


#include "proj.h"
#include "rcids.h"

#define RetInt(ppv, x)      (*((LPINT)*(ppv)) = (x))
#define RetStr(ppv, x)      (*((LPSTR)*(ppv)) = (x))
#define RetBool(ppv, x)     (*((LPBOOL)*(ppv)) = (x))


// 
// Wait case functions
//


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dump a waitcase structure

Returns: --
Cond:    --
*/
void PRIVATE Waitcase_Dump(
    PWAITCASE this)
    {
    Ast_Dump((PAST)this->pexpr);
    if (this->pszIdent)
        {
        TRACE_MSG(TF_ALWAYS, "      then %s", this->pszIdent);
        }
    }

#endif

/*----------------------------------------------------------
Purpose: Create a wait-case list.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Waitcase_Create(
    PHSA phsa)
    {
    RES res = RES_OK;

    if ( !SACreate(phsa, sizeof(WAITCASE), 8) )
        res = RES_E_OUTOFMEMORY;

    return res;
    }


/*----------------------------------------------------------
Purpose: Add a case to the given wait-case list.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Waitcase_Add(
    HSA hsa,
    PEXPR pexpr,
    LPCSTR pszIdent,        // This may be NULL
    DWORD dwFlags)
    {
    RES res = RES_OK;       // assume success
    WAITCASE wc;

    ASSERT(hsa);
    ASSERT(pexpr);

    wc.pexpr = pexpr;
    wc.dwFlags = dwFlags;
    wc.pszIdent = NULL;

    // Copy pszIdent since the parameter is freed by the caller.
    if ( pszIdent && !GSetString(&wc.pszIdent, pszIdent) )
        res = RES_E_OUTOFMEMORY;

    else if ( !SAInsertItem(hsa, SA_APPEND, &wc) )
        res = RES_E_OUTOFMEMORY;

    return res;
    }


/*----------------------------------------------------------
Purpose: Free the contents of the given pointer.

Returns: --

Cond:    Don't free the pointer itself!
*/
void CALLBACK Waitcase_FreeSA(
    PVOID pv,
    LPARAM lparam)
    {
    PWAITCASE pwc = (PWAITCASE)pv;

    if (pwc->pexpr)
        Expr_Delete(pwc->pexpr);

    if (pwc->pszIdent)
        GSetString(&pwc->pszIdent, NULL);       // free
    }


/*----------------------------------------------------------
Purpose: Destroy the wait case list.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Waitcase_Destroy(
    HSA hsa)
    {
    ASSERT(hsa);

    SADestroyEx(hsa, Waitcase_FreeSA, 0);
    return RES_OK;
    }


//
// Base level AST functions
//


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dump the AST
Returns: --
Cond:    --
*/
void PUBLIC Ast_Dump(
    PAST this)
    {
    ASSERT(this);

    if (IsFlagSet(g_dwDumpFlags, DF_AST))
        {
        switch (this->asttype)
            {
        case AT_BASE:
            TRACE_MSG(TF_ALWAYS, "Unknown AST");
            break;

        case AT_MODULE_DECL: {
            PMODULEDECL pmd = (PMODULEDECL)this;
            DWORD i;
            DWORD cprocs = PAGetCount(pmd->hpaProcs);

            TRACE_MSG(TF_ALWAYS, "module");

            for (i = 0; i < cprocs; i++)
                Ast_Dump(PAFastGetPtr(pmd->hpaProcs, i));
            }
            break;

        case AT_PROC_DECL: {
            PPROCDECL ppd = (PPROCDECL)this;
            DWORD i;
            DWORD cstmts = PAGetCount(ppd->hpaStmts);

            TRACE_MSG(TF_ALWAYS, "proc %s", ProcDecl_GetIdent(ppd));

            for (i = 0; i < cstmts; i++)
                Ast_Dump(PAFastGetPtr(ppd->hpaStmts, i));

            TRACE_MSG(TF_ALWAYS, "endproc");
            }
            break;

        case AT_ENTER_STMT:
            TRACE_MSG(TF_ALWAYS, "enter");
            break;

        case AT_LEAVE_STMT:
            TRACE_MSG(TF_ALWAYS, "leave");
            break;

        case AT_HALT_STMT:
            TRACE_MSG(TF_ALWAYS, "halt");
            break;

        case AT_ASSIGN_STMT:
            TRACE_MSG(TF_ALWAYS, "%s = ", AssignStmt_GetIdent(this));
            Ast_Dump((PAST)AssignStmt_GetExpr(this));
            break;

        case AT_LABEL_STMT:
            TRACE_MSG(TF_ALWAYS, "%s:", LabelStmt_GetIdent(this));
            break;

        case AT_GOTO_STMT:
            TRACE_MSG(TF_ALWAYS, "goto %s", GotoStmt_GetIdent(this));
            break;

        case AT_WHILE_STMT:
            TRACE_MSG(TF_ALWAYS, "while ");
            TRACE_MSG(TF_ALWAYS, "  do ");
            TRACE_MSG(TF_ALWAYS, "endwhile ");
            break;

        case AT_IF_STMT:
            TRACE_MSG(TF_ALWAYS, "if ");
            TRACE_MSG(TF_ALWAYS, "  then ");
            TRACE_MSG(TF_ALWAYS, "endif ");
            break;

        case AT_DELAY_STMT:
            TRACE_MSG(TF_ALWAYS, "delay");
            Ast_Dump((PAST)DelayStmt_GetExpr(this));
            break;

        case AT_WAITFOR_STMT: {
            PWAITFORSTMT pws = (PWAITFORSTMT)this;
            DWORD ccase = SAGetCount(pws->hsa);
            DWORD i;

            TRACE_MSG(TF_ALWAYS, "waitfor");

            for (i = 0; i < ccase; i++)
                {
                PVOID pv;
                SAGetItemPtr(pws->hsa, i, &pv);
                Waitcase_Dump(pv);
                }

            if (WaitforStmt_GetUntilExpr(this))
                {
                TRACE_MSG(TF_ALWAYS, "until");
                Ast_Dump((PAST)WaitforStmt_GetUntilExpr(this));
                }
            }
            break;

        case AT_TRANSMIT_STMT:
            TRACE_MSG(TF_ALWAYS, "transmit");
            Ast_Dump((PAST)TransmitStmt_GetExpr(this));
            break;

        case AT_SET_STMT:
            switch (SetStmt_GetType(this))
                {
            case ST_IPADDR:
                TRACE_MSG(TF_ALWAYS, "set ipaddr getip");
                Ast_Dump((PAST)SetIPStmt_GetExpr(this));
                break;

            case ST_PORT:
                if (IsFlagSet(SetPortStmt_GetFlags(this), SPF_DATABITS))
                    TRACE_MSG(TF_ALWAYS, "set port databits %u", SetPortStmt_GetDatabits(this));

                if (IsFlagSet(SetPortStmt_GetFlags(this), SPF_STOPBITS))
                    TRACE_MSG(TF_ALWAYS, "set port stopbits %u", SetPortStmt_GetStopbits(this));

                if (IsFlagSet(SetPortStmt_GetFlags(this), SPF_PARITY))
                    TRACE_MSG(TF_ALWAYS, "set port parity %u", SetPortStmt_GetParity(this));
                break;

            case ST_SCREEN:
                if (IsFlagSet(SetScreenStmt_GetFlags(this), SPF_KEYBRD))
                    TRACE_MSG(TF_ALWAYS, "set screen keyboard %s", SetScreenStmt_GetKeybrd(this) ? "on" : "off");
                break;

            default:
                ASSERT(0);
                break;
                }
            break;

        case AT_INT_EXPR:
            TRACE_MSG(TF_ALWAYS, "  %d", IntExpr_GetVal(this));
            break;

        case AT_STRING_EXPR:
            TRACE_MSG(TF_ALWAYS, "  %s", StrExpr_GetStr(this));
            break;

        case AT_BOOL_EXPR:
            TRACE_MSG(TF_ALWAYS, "  %s", BoolExpr_GetVal(this) ? (LPSTR)"TRUE" : (LPSTR)"FALSE");
            break;

        case AT_VAR_EXPR:
            TRACE_MSG(TF_ALWAYS, "  %s", VarExpr_GetIdent(this));
            break;

        case AT_BINOP_EXPR: {
            PBINOPEXPR pbo = (PBINOPEXPR)this;

            Ast_Dump((PAST)pbo->pexpr1);

            switch (BinOpExpr_GetType(this))
                {
            case BOT_OR:
                TRACE_MSG(TF_ALWAYS, "    or");
                break;

            case BOT_AND:
                TRACE_MSG(TF_ALWAYS, "    and");
                break;

            case BOT_LT:
                TRACE_MSG(TF_ALWAYS, "    <");
                break;

            case BOT_LEQ:
                TRACE_MSG(TF_ALWAYS, "    <=");
                break;

            case BOT_GT:
                TRACE_MSG(TF_ALWAYS, "    >");
                break;

            case BOT_GEQ:
                TRACE_MSG(TF_ALWAYS, "    >=");
                break;

            case BOT_EQ:
                TRACE_MSG(TF_ALWAYS, "    ==");
                break;

            case BOT_NEQ:
                TRACE_MSG(TF_ALWAYS, "    !=");
                break;

            case BOT_PLUS:
                TRACE_MSG(TF_ALWAYS, "    +");
                break;

            case BOT_MINUS:
                TRACE_MSG(TF_ALWAYS, "    -");
                break;

            case BOT_MULT:
                TRACE_MSG(TF_ALWAYS, "    *");
                break;

            case BOT_DIV:
                TRACE_MSG(TF_ALWAYS, "    /");
                break;

            default:
                ASSERT(0);
                break;
                }

            Ast_Dump((PAST)pbo->pexpr2);
            }
            break;

        case AT_UNOP_EXPR: {
            PUNOPEXPR puo = (PUNOPEXPR)this;

            switch (UnOpExpr_GetType(this))
                {
            case UOT_NEG:
                TRACE_MSG(TF_ALWAYS, "  -");
                break;

            case UOT_NOT:
                TRACE_MSG(TF_ALWAYS, "  !");
                break;

            case UOT_GETIP:
                TRACE_MSG(TF_ALWAYS, "  getip");
                break;

            default:
                ASSERT(0);
                break;
                }

            Ast_Dump((PAST)puo->pexpr);
            }
            break;

        default:
            ASSERT(0);
            break;
            }
        }
    }

#endif // DEBUG


/*----------------------------------------------------------
Purpose: Creates a new AST 

Returns: RES_OK

         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Ast_New(
    LPVOID * ppv,
    ASTTYPE asttype,
    DWORD cbSize,
    DWORD iLine)
    {
    PAST past;

    ASSERT(ppv);

    past = GAlloc(cbSize);
    if (past)
        {
        Ast_SetSize(past, cbSize);
        Ast_SetType(past, asttype);
        Ast_SetLine(past, iLine);
        }
    *ppv = past;

    return NULL != past ? RES_OK : RES_E_OUTOFMEMORY;
    }


/*----------------------------------------------------------
Purpose: Destroys the given AST.
Returns: 
Cond:    --
*/
void PUBLIC Ast_Delete(
    PAST this)
    {
    GFree(this);
    }


/*----------------------------------------------------------
Purpose: Duplicate the given AST.

Returns: RES_OK

         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Ast_Dup(
    PAST this,
    PAST * ppast)
    {
    PAST past;
    DWORD cbSize;

    ASSERT(this);
    ASSERT(ppast);

    cbSize = Ast_GetSize(this);

    past = GAlloc(cbSize);
    if (past)
        {
        BltByte(past, this, cbSize);
        }
    *ppast = past;

    return NULL != past ? RES_OK : RES_E_OUTOFMEMORY;
    }


// 
// Expressions
//

/*----------------------------------------------------------
Purpose: Callback for PADestroyEx.

Returns: --
Cond:    --
*/
void CALLBACK Expr_DeletePAPtr(
    LPVOID pv,
    LPARAM lparam)
    {
    Expr_Delete(pv);
    }              


/*----------------------------------------------------------
Purpose: Destroys an Expr.

Returns: RES_OK

         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Expr_Delete(
    PEXPR this)
    {
    RES res;

    DBG_ENTER(Expr_Delete);

    if (this)
        {
        res = RES_OK;

        switch (this->ast.asttype)
            {
        case AT_INT_EXPR:
        case AT_BOOL_EXPR:
            // (Nothing to free inside)
            break;

        case AT_STRING_EXPR: {
            PSTREXPR ps = (PSTREXPR)this;

            if (ps->psz)
                GSetString(&ps->psz, NULL);     // free
            }
            break;

        case AT_VAR_EXPR: {
            PVAREXPR ps = (PVAREXPR)this;

            if (ps->pszIdent)
                GSetString(&ps->pszIdent, NULL);     // free
            }
            break;

        case AT_BINOP_EXPR: {
            PBINOPEXPR pbo = (PBINOPEXPR)this;

            if (pbo->pexpr1)
                Expr_Delete(pbo->pexpr1);

            if (pbo->pexpr2)
                Expr_Delete(pbo->pexpr2);

            }
            break;

        case AT_UNOP_EXPR: {
            PUNOPEXPR puo = (PUNOPEXPR)this;

            if (puo->pexpr)
                Expr_Delete(puo->pexpr);
            }
            break;

        default:
            ASSERT(0);
            res = RES_E_INVALIDPARAM;
            break;
            }

        if (RSUCCEEDED(res))
            {
            // Most of the time when the evaluated result 
            // is a string, it is just a copy of the pointer
            // in the specific class structure.  In these
            // cases it does not need to be freed again,
            // because it was freed above.

            if (this->er.psz && IsFlagSet(this->dwFlags, EF_ALLOCATED))
                {
                ASSERT(DATA_STRING == Expr_GetDataType(this));

                GSetString(&this->er.psz, NULL);    // free
                }

            Ast_Delete((PAST)this);
            }
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Expr_Delete, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a IntExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC IntExpr_New(
    PEXPR * ppexpr,
    int nVal,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(IntExpr_New);

    ASSERT(ppexpr);

    if (ppexpr)
        {
        PINTEXPR this;

        res = Ast_New(&this, AT_INT_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            IntExpr_SetVal(this, nVal);
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(IntExpr_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a StrExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC StrExpr_New(
    PEXPR * ppexpr,
    LPCSTR psz,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(StrExpr_New);

    ASSERT(ppexpr);
    ASSERT(psz);

    if (ppexpr)
        {
        PSTREXPR this;

        res = Ast_New(&this, AT_STRING_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;

            if (!GSetString(&this->psz, psz))
                res = RES_E_OUTOFMEMORY;

            if (RFAILED(res))
                {
                Ast_Delete((PAST)this);
                this = NULL;
                }
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(StrExpr_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a BoolExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC BoolExpr_New(
    PEXPR * ppexpr,
    BOOL bVal,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(BoolExpr_New);

    ASSERT(ppexpr);

    if (ppexpr)
        {
        PBOOLEXPR this;

        res = Ast_New(&this, AT_BOOL_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            BoolExpr_SetVal(this, bVal);
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(BoolExpr_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a VarExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC VarExpr_New(
    PEXPR * ppexpr,
    LPCSTR pszIdent,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(VarExpr_New);

    ASSERT(ppexpr);
    ASSERT(pszIdent);

    if (ppexpr)
        {
        PVAREXPR this;

        res = Ast_New(&this, AT_VAR_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;

            if (!GSetString(&this->pszIdent, pszIdent))
                res = RES_E_OUTOFMEMORY;

            if (RFAILED(res))
                {
                Ast_Delete((PAST)this);
                this = NULL;
                }
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(VarExpr_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a BinOpExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC BinOpExpr_New(
    PEXPR * ppexpr,
    BINOPTYPE binoptype,
    PEXPR pexpr1,
    PEXPR pexpr2,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(BinOpExpr_New);

    ASSERT(ppexpr);
    ASSERT(pexpr1);
    ASSERT(pexpr2);

    if (ppexpr)
        {
        PBINOPEXPR this;

        res = Ast_New(&this, AT_BINOP_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;

            BinOpExpr_SetType(this, binoptype);

            this->pexpr1 = pexpr1;
            this->pexpr2 = pexpr2;
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(BinOpExpr_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a UnOpExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC UnOpExpr_New(
    PEXPR * ppexpr,
    UNOPTYPE unoptype,
    PEXPR pexpr,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(UnOpExpr_New);

    ASSERT(ppexpr);
    ASSERT(pexpr);

    if (ppexpr)
        {
        PUNOPEXPR this;

        res = Ast_New(&this, AT_UNOP_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            UnOpExpr_SetType(this, unoptype);

            this->pexpr = pexpr;
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(UnOpExpr_New, res);

    return res;
    }


// 
// Stmt
//

/*----------------------------------------------------------
Purpose: Callback for PADestroyEx.

Returns: --
Cond:    --
*/
void CALLBACK Stmt_DeletePAPtr(
    LPVOID pv,
    LPARAM lparam)
    {
    Stmt_Delete(pv);
    }              


/*----------------------------------------------------------
Purpose: Destroys a Stmt.

Returns: RES_OK

         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Stmt_Delete(
    PSTMT this)
    {
    RES res;

    DBG_ENTER(Stmt_Delete);

    if (this)
        {
        PEXPR pexpr;
        HSA hsa;

        res = RES_OK;

        switch (this->ast.asttype)
            {
        case AT_ENTER_STMT:
            // (don't free pst -- it belongs to the decl structs)
        case AT_LEAVE_STMT:
        case AT_HALT_STMT:
            break;

        case AT_ASSIGN_STMT: {
            PASSIGNSTMT pls = (PASSIGNSTMT)this;

            if (pls->pszIdent)
                GSetString(&pls->pszIdent, NULL);        // free

            pexpr = AssignStmt_GetExpr(this);

            if (pexpr)
                Expr_Delete(pexpr);
            }
            break;

        case AT_WHILE_STMT: {
            PWHILESTMT pls = (PWHILESTMT)this;

            pexpr = WhileStmt_GetExpr(this);

            if (pexpr)
                Expr_Delete(pexpr);

            if (pls->hpaStmts)
                PADestroyEx(pls->hpaStmts, Stmt_DeletePAPtr, 0);
            }
            break;

        case AT_IF_STMT: {
            PIFSTMT pls = (PIFSTMT)this;

            pexpr = IfStmt_GetExpr(this);

            if (pexpr)
                Expr_Delete(pexpr);

            if (pls->hpaStmts)
                PADestroyEx(pls->hpaStmts, Stmt_DeletePAPtr, 0);
            }
            break;

        case AT_LABEL_STMT: {
            PLABELSTMT pls = (PLABELSTMT)this;

            if (pls->psz)
                GSetString(&pls->psz, NULL);        // free
            }
            break;

        case AT_GOTO_STMT: {
            PGOTOSTMT pgs = (PGOTOSTMT)this;

            if (pgs->psz)
                GSetString(&pgs->psz, NULL);        // free
            }
            break;

        case AT_DELAY_STMT:
            pexpr = DelayStmt_GetExpr(this);

            if (pexpr)
                Expr_Delete(pexpr);
            break;

        case AT_TRANSMIT_STMT:
            pexpr = TransmitStmt_GetExpr(this);

            if (pexpr)
                Expr_Delete(pexpr);
            break;

        case AT_WAITFOR_STMT:
            
            hsa = WaitforStmt_GetCaseList(this);
            if (hsa)
                Waitcase_Destroy(hsa);

            pexpr = WaitforStmt_GetUntilExpr(this);
            if (pexpr)
                Expr_Delete(pexpr);
            break;

        case AT_SET_STMT:
            switch (SetStmt_GetType(this))
                {
            case ST_IPADDR:
                pexpr = SetIPStmt_GetExpr(this);

                if (pexpr)
                    Expr_Delete(pexpr);
                break;

            case ST_PORT:
            case ST_SCREEN:
                break;

            default:
                ASSERT(0);
                res = RES_E_INVALIDPARAM;
                break;
                }
            break;

        default:
            ASSERT(0);
            res = RES_E_INVALIDPARAM;
            break;
            }

        if (RSUCCEEDED(res))
            Ast_Delete((PAST)this);
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Stmt_Delete, res);

    return res;
    }


// 
// Statements
//


/*----------------------------------------------------------
Purpose: Creates a WaitforStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC WaitforStmt_New(
    PSTMT * ppstmt,
    HSA hsa,
    PEXPR pexprUntil,           // May be NULL
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(WaitforStmt_New);

    ASSERT(ppstmt);
    ASSERT(hsa);

    if (ppstmt)
        {
        PWAITFORSTMT this;

        res = Ast_New(&this, AT_WAITFOR_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            this->hsa = hsa;
            this->pexprUntil = pexprUntil;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(WaitforStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a TransmitStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC TransmitStmt_New(
    PSTMT * ppstmt,
    PEXPR pexpr,
    DWORD dwFlags,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(TransmitStmt_New);

    ASSERT(ppstmt);
    ASSERT(pexpr);

    if (ppstmt)
        {
        PTRANSMITSTMT this;

        res = Ast_New(&this, AT_TRANSMIT_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            this->pexpr = pexpr;
            this->dwFlags = dwFlags;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(TransmitStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a DelayStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC DelayStmt_New(
    PSTMT * ppstmt,
    PEXPR pexpr,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(DelayStmt_New);

    ASSERT(ppstmt);
    ASSERT(pexpr);

    if (ppstmt)
        {
        PDELAYSTMT this;

        res = Ast_New(&this, AT_DELAY_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            this->pexprSecs = pexpr;

            res = RES_OK;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(DelayStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a HaltStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC HaltStmt_New(
    PSTMT * ppstmt,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(HaltStmt_New);

    ASSERT(ppstmt);

    if (ppstmt)
        {
        PHALTSTMT this;

        res = Ast_New(&this, AT_HALT_STMT, sizeof(*this), iLine);

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(HaltStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates an EnterStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC EnterStmt_New(
    PSTMT * ppstmt,
    PSYMTAB pst,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(EnterStmt_New);

    ASSERT(ppstmt);

    if (ppstmt)
        {
        PENTERSTMT this;

        res = Ast_New(&this, AT_ENTER_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            this->pst = pst;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(EnterStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates an LeaveStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC LeaveStmt_New(
    PSTMT * ppstmt,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(LeaveStmt_New);

    ASSERT(ppstmt);

    if (ppstmt)
        {
        PLEAVESTMT this;

        res = Ast_New(&this, AT_LEAVE_STMT, sizeof(*this), iLine);

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(LeaveStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates an AssignStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC AssignStmt_New(
    PSTMT * ppstmt,
    LPCSTR pszIdent,
    PEXPR pexpr,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(AssignStmt_New);

    ASSERT(ppstmt);
    ASSERT(pszIdent);
    ASSERT(pexpr);

    if (ppstmt)
        {
        PASSIGNSTMT this;

        res = Ast_New(&this, AT_ASSIGN_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;   // assume success

            if (!GSetString(&this->pszIdent, pszIdent))
                res = RES_E_OUTOFMEMORY;
            else
                this->pexpr = pexpr;

            if (RFAILED(res))
                {
                Ast_Delete((PAST)this);
                this = NULL;
                }
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(AssignStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a LabelStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC LabelStmt_New(
    PSTMT * ppstmt,
    LPCSTR psz,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(LabelStmt_New);

    ASSERT(ppstmt);
    ASSERT(psz);

    if (ppstmt)
        {
        PLABELSTMT this;

        res = Ast_New(&this, AT_LABEL_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;   // assume success

            if (!GSetString(&this->psz, psz))
                {
                res = RES_E_OUTOFMEMORY;
                Ast_Delete((PAST)this);
                this = NULL;
                }
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(LabelStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a GotoStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC GotoStmt_New(
    PSTMT * ppstmt,
    LPCSTR psz,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(GotoStmt_New);

    ASSERT(ppstmt);
    ASSERT(psz);

    if (ppstmt)
        {
        PGOTOSTMT this;

        res = Ast_New(&this, AT_GOTO_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;   // assume success

            if (!GSetString(&this->psz, psz))
                {
                res = RES_E_OUTOFMEMORY;
                Ast_Delete((PAST)this);
                this = NULL;
                }
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(GotoStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a WhileStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC WhileStmt_New(
    PSTMT * ppstmt,
    PEXPR pexpr,
    HPA hpa,
    LPCSTR pszTopLabel,
    LPCSTR pszEndLabel,
    DWORD iLine)
    {
    RES res;

    ASSERT(ppstmt);
    ASSERT(hpa);
    ASSERT(pexpr);
    ASSERT(pszTopLabel);
    ASSERT(pszEndLabel);

    if (ppstmt)
        {
        PWHILESTMT this;

        res = Ast_New(&this, AT_WHILE_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            this->pexpr = pexpr;
            this->hpaStmts = hpa;
            lstrcpyn(this->szTopLabel, pszTopLabel, sizeof(this->szTopLabel));
            lstrcpyn(this->szEndLabel, pszEndLabel, sizeof(this->szEndLabel));
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates an IfStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC IfStmt_New(
    PSTMT * ppstmt,
    PEXPR pexpr,
    HPA hpa,
    LPCSTR pszElseLabel,
    LPCSTR pszEndLabel,
    DWORD iLine)
    {
    RES res;

    ASSERT(ppstmt);
    ASSERT(hpa);
    ASSERT(pexpr);
    ASSERT(pszElseLabel);
    ASSERT(pszEndLabel);

    if (ppstmt)
        {
        PIFSTMT this;

        res = Ast_New(&this, AT_IF_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            this->pexpr = pexpr;
            this->hpaStmts = hpa;
            lstrcpyn(this->szElseLabel, pszElseLabel, sizeof(this->szElseLabel));
            lstrcpyn(this->szEndLabel, pszEndLabel, sizeof(this->szEndLabel));
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a SetStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PRIVATE SetStmt_New(
    PVOID * ppv,
    SETTYPE settype,
    DWORD cbSize,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(SetStmt_New);

    ASSERT(ppv);
    ASSERT(sizeof(SETSTMT) <= cbSize);

    if (ppv)
        {
        PSETSTMT this;

        res = Ast_New(&this, AT_SET_STMT, cbSize, iLine);
        if (RSUCCEEDED(res))
            {
            SetStmt_SetType(this, settype);

            res = RES_OK;           
            }

        *ppv = this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(SetStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a SetIPStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC SetIPStmt_New(
    PSTMT * ppstmt,
    PEXPR pexpr,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(SetIPStmt_New);

    ASSERT(ppstmt);
    ASSERT(pexpr);

    if (ppstmt)
        {
        PSETIPSTMT this;

        res = SetStmt_New(&this, ST_IPADDR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            this->pexpr = pexpr;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(SetIPStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a SetPortStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC SetPortStmt_New(
    PSTMT * ppstmt,
    PPORTSTATE pstate,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(SetPortStmt_New);

    ASSERT(ppstmt);
    ASSERT(pstate);

    if (ppstmt && pstate)
        {
        PSETPORTSTMT this;

        res = SetStmt_New(&this, ST_PORT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            DWORD dwFlags = pstate->dwFlags;

            res = RES_OK;           // assume success

            this->portstate.dwFlags = dwFlags;

            if (IsFlagSet(dwFlags, SPF_DATABITS))
                this->portstate.nDatabits = pstate->nDatabits;

            if (IsFlagSet(dwFlags, SPF_STOPBITS))
                this->portstate.nStopbits = pstate->nStopbits;

            if (IsFlagSet(dwFlags, SPF_PARITY))
                this->portstate.nParity = pstate->nParity;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(SetPortStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a SetScreenStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC SetScreenStmt_New(
    PSTMT * ppstmt,
    PSCREENSET pstate,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(SetScreenStmt_New);

    ASSERT(ppstmt);
    ASSERT(pstate);

    if (ppstmt && pstate)
        {
        PSETSCREENSTMT this;

        res = SetStmt_New(&this, ST_SCREEN, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            DWORD dwFlags = pstate->dwFlags;

            res = RES_OK;           // assume success

            this->screenset.dwFlags = dwFlags;

            if (IsFlagSet(dwFlags, SPF_KEYBRD))
                this->screenset.fKBOn = pstate->fKBOn;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(SetScreenStmt_New, res);

    return res;
    }


// 
// Decl
//


/*----------------------------------------------------------
Purpose: Callback for PADestroyEx.

Returns: --
Cond:    --
*/
void CALLBACK Decl_DeletePAPtr(
    LPVOID pv,
    LPARAM lparam)
    {
    Decl_Delete(pv);
    }              


/*----------------------------------------------------------
Purpose: Destroys a Decl.

Returns: RES_OK

         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Decl_Delete(
    PDECL this)
    {
    RES res;

    DBG_ENTER(Decl_Delete);

    if (this)
        {
        res = RES_OK;

        switch (this->ast.asttype)
            {
        case AT_MODULE_DECL: {
            PMODULEDECL pmd = (PMODULEDECL)this;

            if (pmd->hpaProcs)
                PADestroyEx(pmd->hpaProcs, Decl_DeletePAPtr, 0);

            if (pmd->pst)
                Symtab_Destroy(pmd->pst);
            }
            break;

        case AT_PROC_DECL: {
            PPROCDECL ppd = (PPROCDECL)this;

            if (ppd->hpaStmts)
                PADestroyEx(ppd->hpaStmts, Stmt_DeletePAPtr, 0);

            if (ppd->pst)
                Symtab_Destroy(ppd->pst);

            if (ppd->pszIdent)
                GSetString(&ppd->pszIdent, NULL);      // free
            }
            break;

        default:
            ASSERT(0);
            res = RES_E_INVALIDPARAM;
            break;
            }

        if (RSUCCEEDED(res))
            Ast_Delete((PAST)this);
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Decl_Delete, res);

    return res;
    }


// 
// ProcDecl
//


/*----------------------------------------------------------
Purpose: Creates a ProcDecl object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC ProcDecl_New(
    PDECL * ppdecl,
    LPCSTR pszIdent,
    HPA hpa,
    PSYMTAB pst,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(ProcDecl_New);

    ASSERT(ppdecl);
    ASSERT(hpa);
    ASSERT(pst);

    if (ppdecl)
        {
        PPROCDECL this;

        res = Ast_New(&this, AT_PROC_DECL, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            if (!GSetString(&this->pszIdent, pszIdent))
                res = RES_E_OUTOFMEMORY;

            else
                {
                this->hpaStmts = hpa;
                this->pst = pst;
                }
        
            if (RFAILED(res))
                {
                Decl_Delete((PDECL)this);
                this = NULL;
                }
            }

        *ppdecl = (PDECL)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(ProcDecl_New, res);

    return res;
    }


// 
// ModuleDecl
//


/*----------------------------------------------------------
Purpose: Creates a ModuleDecl object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC ModuleDecl_New(
    PDECL * ppdecl,
    HPA hpa,
    PSYMTAB pst,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(ModuleDecl_New);

    ASSERT(ppdecl);
    ASSERT(hpa);
    ASSERT(pst);

    if (ppdecl)
        {
        PMODULEDECL this;

        res = Ast_New(&this, AT_MODULE_DECL, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;       // assume success

            this->hpaProcs = NULL;
            if ( !PAClone(&this->hpaProcs, hpa) )
                res = RES_E_OUTOFMEMORY;

            else
                {
                this->pst = pst;
                }
                
            if (RFAILED(res))
                {
                Decl_Delete((PDECL)this);
                this = NULL;
                }
            }

        *ppdecl = (PDECL)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(ModuleDecl_New, res);

    return res;
    }


//
// AST Exec block
//

#define SZ_SUCCESS      "$SUCCESS"
#define SZ_FAILURE      "$FAILURE"


/*----------------------------------------------------------
Purpose: Initialize the AST exec block.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Astexec_Init(
    PASTEXEC this,
    HANDLE hport,
    PSESS_CONFIGURATION_INFO psci,
    HSA hsaStxerr)
    {
    RES res;

    ASSERT(this);
    ASSERT(psci);
    ASSERT(hsaStxerr);

    // For this first version, we only support one module and one
    // main procedure, so set the starting point on the first 
    // statement in that procedure.
    if (this)
        {
        ZeroInit(this, ASTEXEC);

        this->hport = hport;
        this->psci = psci;
        // Don't free hsaStxerr -- it belongs to the caller
        this->hsaStxerr = hsaStxerr;

        if ( !PACreate(&this->hpaPcode, 8) )
            res = RES_E_OUTOFMEMORY;
        else
            {
            res = Symtab_Create(&this->pstSystem, NULL);
            if (RSUCCEEDED(res))
                {
                // Add the system variables
                PSTE pste;
                struct 
                    {
                    LPCSTR pszIdent;
                    DATATYPE dt;
                    EVALRES er;
                    } s_rgvars[] = 
                        {
                        { "$USERID", DATA_STRING, psci->szUserName },
                        { "$PASSWORD", DATA_STRING, psci->szPassword },
                        { SZ_SUCCESS, DATA_BOOL, (LPSTR)TRUE },
                        { SZ_FAILURE, DATA_BOOL, (LPSTR)FALSE },
                        };
                int i;

                for (i = 0; i < ARRAY_ELEMENTS(s_rgvars); i++)
                    {
                    res = STE_Create(&pste, s_rgvars[i].pszIdent, s_rgvars[i].dt);
                    if (RFAILED(res))
                        break;

                    pste->er.dw = s_rgvars[i].er.dw;

                    res = Symtab_InsertEntry(this->pstSystem, pste);
                    if (RFAILED(res))
                        break;
                    }

                }
            }

        // Did something fail above?
        if (RFAILED(res))
            {
            // Yes; clean up
            Astexec_Destroy(this);
            }
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Destroys the AST exec block.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Astexec_Destroy(
    PASTEXEC this)
    {
    RES res;

    if (this)
        {
        if (this->hpaPcode)
            {
            PADestroy(this->hpaPcode);
            this->hpaPcode = NULL;
            }
    
        if (this->pstSystem)
            {
            Symtab_Destroy(this->pstSystem);
            this->pstSystem = NULL;
            }

        // ('this' was not allocated.  Do not free it.)
        // (hsaStxerr is not owned by this class.  Do not free it.)
                
        res = RES_OK;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Sets the success/failure code

Returns: --
Cond:    --
*/
void PUBLIC Astexec_SetError(
    PASTEXEC this,
    BOOL bSuccess,              // TRUE: success
    BOOL bFailure)
    {
    PSTE pste;

    ASSERT(this);

    if (RES_OK == Symtab_FindEntry(this->pstSystem, SZ_SUCCESS, STFF_DEFAULT, &pste, NULL))
        {
        // Set the code for success
        pste->er.bVal = bSuccess;

        if (RES_OK == Symtab_FindEntry(this->pstSystem, SZ_FAILURE, STFF_DEFAULT, &pste, NULL))
            {
            // Set the code for failure
            pste->er.bVal = bFailure;
            }
        else
            ASSERT(0);
        }
    else
        ASSERT(0);
    }


/*----------------------------------------------------------
Purpose: Adds the statement to the executable list.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Astexec_Add(
    PASTEXEC this,
    PSTMT pstmt)
    {
    RES res;

    ASSERT(this);
    ASSERT(pstmt);

    if (PAInsertPtr(this->hpaPcode, PA_APPEND, pstmt))
        res = RES_OK;
    else
        res = RES_E_OUTOFMEMORY;

    return res;
    }


/*----------------------------------------------------------
Purpose: Inserts a label into the executable list by recording
         the current ipaCur into the label entry in the 
         symbol table.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Astexec_InsertLabel(
    PASTEXEC this,
    LPCSTR pszIdent,
    PSYMTAB pst)
    {
    RES res;
    DWORD ipa;
    PSTE pste;

    ASSERT(this);
    ASSERT(pszIdent);
    ASSERT(pst);

    ipa = PAGetCount(this->hpaPcode);
    if (RES_OK == Symtab_FindEntry(pst, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        // Set the current code location in the symbol table
        pste->er.dw = ipa;
        res = RES_OK;
        }
    else
        {
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Jumps to the given label.

Returns: RES_OK
Cond:    --
*/
RES PUBLIC Astexec_JumpToLabel(
    PASTEXEC this,
    LPCSTR pszIdent)
    {
    RES res;
    PSTE pste;

    ASSERT(pszIdent);
    ASSERT(this);
    ASSERT(this->pstCur);

    if (RES_OK == Symtab_FindEntry(this->pstCur, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        EVALRES er;

        STE_GetValue(pste, &er);

        // Set instruction pointer
        Astexec_SetIP(this, (DWORD) er.dw);
        res = RES_OK;
        }
    else
        {
        // The label should have been in the symbol table!
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Sends psz to the port (via hwnd)

Returns: --
Cond:    --
*/
void PUBLIC Astexec_SendString(
    PASTEXEC this,
    LPCSTR pszSend,
    BOOL bRaw)          // TRUE: send unformatted
    {
    // Send string
    LPCSTR psz;
    char ch;
    HWND hwnd = this->hwnd;

    // Send unformatted?
    if (bRaw)
        {
        // Yes
        for (psz = pszSend; *psz; )
            {
            ch = *psz;

            psz++;

            SendByte(hwnd, ch);
            }
        }
    else
        {
        // No
        DWORD dwFlags = 0;

        for (psz = pszSend; *psz; )
            {
            psz = MyNextChar(psz, &ch, &dwFlags);

            SendByte(hwnd, ch);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Destroy the find format handle

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Astexec_DestroyFindFormat(
    PASTEXEC this)
    {
    // Reset the pending statement so we can handle multiple 
    // expressions that can pend in a single evaluation.
    Astexec_SetPending(this, NULL);

    DestroyFindFormat(this->hFindFmt);
    this->hFindFmt = NULL;

    return RES_OK;
    }


/*----------------------------------------------------------
Purpose: Make another pass at finding a string.

Returns: RES_OK (if string was found)
         RES_FALSE (if the string was not found yet)

Cond:    --
*/
RES PUBLIC Astexec_FindFormat(
    PASTEXEC this,
    LPDWORD piFound)
    {
    RES res;

    ASSERT(piFound);

    while (TRUE)
        {
        // Did we get the IP address?
        res = FindFormat(this->hwnd, this->hFindFmt, piFound);
        if (RES_OK == res)
            {
            // Yes
            this->nIter--;
            ASSERT(0 <= this->nIter);

            // Is this the right one?
            if (0 >= this->nIter)
                {
                // Yes; reset the pending statement so we
                // can handle multiple pending expressions
                // in a single evaluation.
                Astexec_DestroyFindFormat(this);
                break;
                }
            }
        else
            {
            // No; return read-pending RES_FALSE
            if (RES_E_MOREDATA == res)
                {
                TRACE_MSG(TF_GENERAL, "Buffer to FindFormat is too small");
                res = RES_OK;       // don't blow up
                }
            break;
            }
        }

    ASSERT(RSUCCEEDED(res));

    return res;
    }


/*----------------------------------------------------------
Purpose: Sets the IP address.

Returns: RES_OK
         RES_E_FAIL (if IP address cannot be set)

Cond:    --
*/
RES PUBLIC Astexec_SetIPAddr(
    PASTEXEC this,
    LPCSTR psz)
    {
    DWORD dwRet;

    ASSERT(this);
    ASSERT(psz);

    TRACE_MSG(TF_GENERAL, "Setting IP address to {%s}", psz);

#ifndef WINNT_RAS
//
// On NT, the IP address is set by calling RxSetIPAddress,
// which writes a new value to the phonebook if the connection uses SLIP.
//

    dwRet = TerminalSetIP(this->hwnd, psz);

#else // !WINNT_RAS

    dwRet = RxSetIPAddress(((SCRIPTDATA*)this->hwnd)->hscript, psz);

#endif // !WINNT_RAS
    return ERROR_SUCCESS == dwRet ? RES_OK : RES_E_FAIL;
    }


#define Astexec_Validate(this)      ((this)->hpaPcode && (this)->psci)

/*----------------------------------------------------------
Purpose: Returns the source line number of the current
         command that is executing.

Returns: see above
Cond:    --
*/
DWORD PUBLIC Astexec_GetCurLine(
    PASTEXEC this)
    {
    DWORD iLine;

    if (Astexec_Validate(this) &&
        (this->ipaCur < PAGetCount(this->hpaPcode)))
        {
        PSTMT pstmt = PAFastGetPtr(this->hpaPcode, this->ipaCur);
        iLine = Ast_GetLine(pstmt);
        }
    else
        iLine = 0;

    return iLine;
    }


/*----------------------------------------------------------
Purpose: Execute a statement and process the results.

Returns: RES_OK
         other error values

Cond:    --
*/
RES PRIVATE Astexec_ProcessStmt(
    PASTEXEC this,
    PSTMT pstmt)
    {
    RES res;

    ASSERT(this);
    ASSERT(pstmt);

    // (Re-)Execute the (possibly pending) statement
    res = Stmt_Exec(pstmt, this);

    // Set the pending statement based on the return value
    if (RES_OK == res)
        Astexec_SetPending(this, NULL);
    else if (RES_FALSE == res)
        {
        // (Re-set the current pending statement since
        // it could have been reset in Stmt_Exec.  For
        // example, the evaluation of an expression could 
        // have continued on to the next sub-expression
        // that caused another pending read.)

        Astexec_SetPending(this, pstmt);
        res = RES_OK;
        }
    else if (RFAILED(res))
        {
        Stxerr_ShowErrors(this->hsaStxerr, this->hwnd);

        // Halt script
        SetFlag(this->dwFlags, AEF_HALT);
        }
    
    return res;
    }


/*----------------------------------------------------------
Purpose: Executes the next command in the AST.

Returns: RES_OK
         RES_FALSE (if at end of script)
         RES_HALT (if at end of script)

         RES_E_FAIL (invalid command -- should never happen)
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Astexec_Next(
    PASTEXEC this)
    {
    RES res;

    DBG_ENTER(Astexec_Next);

    if (this)
        {
        if (!Astexec_Validate(this))
            {
            // No script
            res = RES_E_FAIL;
            }
        else if (Astexec_IsDone(this) || Astexec_IsHalted(this))
            {
            res = RES_HALT;
            }
        else if (Astexec_IsReadPending(this))
            {
            PSTMT pstmt = Astexec_GetPending(this);

            // ("Read pending" and "Paused" are mutually exclusive)
            ASSERT( !Astexec_IsPaused(this) );

            res = Astexec_ProcessStmt(this, pstmt);
            }
        else if (Astexec_IsPaused(this))
            {
            // ("Read pending" and "Paused" are mutually exclusive)
            ASSERT( !Astexec_IsReadPending(this) );

            // Do nothing while we're paused
            res = RES_OK;
            }
        else if (this->ipaCur < PAGetCount(this->hpaPcode))
            {
            PSTMT pstmt = PAFastGetPtr(this->hpaPcode, this->ipaCur++);

            res = Astexec_ProcessStmt(this, pstmt);
            }
        else
            {
            // We reach here if there is an error in the script.
            TRACE_MSG(TF_ASTEXEC, "Exec: (reached end of script)");

            SetFlag(this->dwFlags, AEF_DONE);
            res = RES_HALT;
            }
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Astexec_Next, res);

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasdlg\util.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// util.c
// Remote Access Common Dialog APIs
// Utility routines
// Listed alphabetically
//
// Steve Cobb 06/20/95


#include "rasdlgp.h"   // Our private header
#include <dlgs.h>      // Common dialog resource constants
#include <lmwksta.h>   // NetWkstaGetInfo
#include <lmapibuf.h>  // NetApiBufferFree
#include <dsrole.h>    // machine is a member of a workgroup or domain, etc.
#include <tchar.h>

typedef struct _COUNT_FREE_COM_PORTS_DATA
{
    DTLLIST* pListPortsInUse;
    DWORD dwCount;
} COUNT_FREE_COM_PORTS_DATA;

const WCHAR c_szCurrentBuildNumber[]      = L"CurrentBuildNumber";
const WCHAR c_szWinVersionPath[]          =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
const WCHAR c_szNt40BuildNumber[]         = L"1381";

//-----------------------------------------------------------------------------
// Help maps
//-----------------------------------------------------------------------------

static DWORD g_adwPnHelp[] =
{
    CID_LE_ST_Item,    HID_PN_EB_NewNumber,
    CID_LE_EB_Item,    HID_PN_EB_NewNumber,
    CID_LE_PB_Add,     HID_PN_PB_Add,
    CID_LE_PB_Replace, HID_PN_PB_Replace,
    CID_LE_ST_List,    HID_PN_LB_List,
    CID_LE_LB_List,    HID_PN_LB_List,
    CID_LE_PB_Up,      HID_PN_PB_Up,
    CID_LE_PB_Down,    HID_PN_PB_Down,
    CID_LE_PB_Delete,  HID_PN_PB_Delete,
    CID_LE_CB_Promote, HID_PN_CB_Promote,
    0, 0
};


//-----------------------------------------------------------------------------
// Local helper prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOL 
CountFreeComPorts(
    IN PWCHAR pszPort,
    IN HANDLE hData);
    
//-----------------------------------------------------------------------------
// Utility routines (alphabetically)
//-----------------------------------------------------------------------------

BOOL
AllLinksAreModems(
    IN PBENTRY* pEntry )

    // Returns true if all links associated with the entry are modem links
    // (MXS or Unimodem), false otherwise.
    //
{
    DTLNODE* pNode;

    if (pEntry->pdtllistLinks)
    {
        for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );

            if (pLink->pbport.pbdevicetype != PBDT_Modem)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL 
AllowDccWizard(
    IN HANDLE hConnection)

    // Finds out if there are any dcc devices installed on the local
    // machine or if there are any available com ports.  If neither
    // condition is satisfied, then we return FALSE, otherwise TRUE.
{
    DWORD dwErr, dwUsedCount = 0;
    COUNT_FREE_COM_PORTS_DATA CountFreeComPortsData,
                              *pCfcpd = &CountFreeComPortsData;
    DTLNODE* pNodeP, *pNodeL, *pNode;
    BOOL bRet = FALSE;

    // Initialize
    ZeroMemory(pCfcpd, sizeof(COUNT_FREE_COM_PORTS_DATA));

    do 
    {
        // Load ras if it wasn't already loaded
        dwErr = LoadRas( g_hinstDll, NULL );
        if (dwErr != 0)
        {
            return FALSE;
        }
    
        // Load in all of the ports and count the number of 
        // dcc devices
        dwErr = LoadPortsList2(
                    hConnection, 
                    &(pCfcpd->pListPortsInUse),
                    FALSE);
        if (dwErr != NO_ERROR)
        {
            bRet = FALSE;
            break;
        }

        // Count the dcc devices
        for (pNodeL = DtlGetFirstNode( pCfcpd->pListPortsInUse );
             pNodeL;
             pNodeL = DtlGetNextNode( pNodeL ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNodeL );
            if (pLink->pbport.dwType == RASET_Direct)
            {
                bRet = TRUE;
                break;
            }
        }
        if (bRet == TRUE)
        {
            break;
        }

        // pmay: 249346
        //
        // Only merge the com ports if the user is an admin since
        // admin privilege is required to install a null modem.
        //
        if (FIsUserAdminOrPowerUser())
        {
            // Count the number of available com ports
            dwErr = MdmEnumComPorts (
                        CountFreeComPorts, 
                        (HANDLE)pCfcpd);
            if (dwErr != NO_ERROR)
            {
                bRet = FALSE;
                break;
            }

            bRet = (pCfcpd->dwCount > 0) ? TRUE : FALSE;
        }

    } while (FALSE);

    // Cleanup
    {
        if ( pCfcpd->pListPortsInUse )
        {
            DtlDestroyList(pCfcpd->pListPortsInUse, DestroyPortNode);
        }
    }

    return bRet;
}


DWORD
AuthRestrictionsFromTypicalAuth(
    IN DWORD dwTypicalAuth )

    // Return the AR_F_* flag corresponding to the TA_* value 'dwTypicalAuth',
    // i.e. convert a typical authentication selection to a bitmask of
    // authentication protocols.
    //
{
    if (dwTypicalAuth == TA_Secure)
    {
        return AR_F_TypicalSecure;
    }
    else if (dwTypicalAuth == TA_CardOrCert)
    {
        return AR_F_TypicalCardOrCert;
    }
    else
    {
        return AR_F_TypicalUnsecure;
    }
}

LONG  GetGlobalCallbackActive( )
{
    LONG ret = 0;
    
    __try
    {
        EnterCriticalSection( &g_csCallBacks );

        ret = g_ulCallbacksActive;
        TRACE1("GlobalActive Calls are:%ld",g_ulCallbacksActive);
    }
    __finally
    {
        LeaveCriticalSection( &g_csCallBacks );
    }

    return ret;
}

LONG  IncGlobalCallbackActive( )
{
    LONG ret = 0;
    
    __try
    {
        EnterCriticalSection( &g_csCallBacks );

        g_ulCallbacksActive++;
        
        ret = g_ulCallbacksActive;
        TRACE1("GlobalActive Calls are:%ld",g_ulCallbacksActive);
    }
    __finally
    {
        LeaveCriticalSection( &g_csCallBacks );
    }

    return ret;
}

LONG  DecGlobalCallbackActive( )
{
    LONG ret = 0;
    
    __try
    {
        EnterCriticalSection( &g_csCallBacks );

        if( 0 < g_ulCallbacksActive )
        {
            g_ulCallbacksActive -- ;
        }
        
        ret = g_ulCallbacksActive;

        TRACE1("GlobalActive Calls are:%ld", g_ulCallbacksActive);
    }
    __finally
    {
        LeaveCriticalSection( &g_csCallBacks );
    }

    return ret;
}


ULONG
CallbacksActive(
    INT nSetTerminateAsap,
    BOOL* pfTerminateAsap )

    // If 'fSetTerminateAsap' >= 0, sets 'g_fTerminateAsap' flag to 'nSetTerminateAsap'.
    // If non-NULL, caller's '*pfTerminateAsap' is filled with the current value of
    // 'g_fTerminateAsap'.
    //
    // Returns the number of Rasdial callback threads active.
    //
{
    ULONG ul;

    TRACE1( "CallbacksActive(%d)", nSetTerminateAsap );

    ul = 0;

    //For XPSP2 511810 and .Net 668164
    //
    __try
    {
        EnterCriticalSection( &g_csCallBacks );
        
        if (pfTerminateAsap)
        {
            *pfTerminateAsap = g_fTerminateAsap;
        }

        if (nSetTerminateAsap >= 0)
        {
            g_fTerminateAsap = (BOOL )nSetTerminateAsap;
        }

        ul = g_ulCallbacksActive;

    }
    __finally

    {
        LeaveCriticalSection( &g_csCallBacks );
    }
        

    TRACE1( "CallbacksActive=%d", ul );

    return ul;
}


VOID
ContextHelp(
    IN const DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam)
{
    ContextHelpX( padwMap, hwndDlg, unMsg, wparam, lparam, FALSE );
}


VOID
ContextHelpX(
    IN const DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam,
    IN BOOL   fRouter)

    // Calls WinHelp to popup context sensitive help.  'PadwMap' is an array
    // of control-ID help-ID pairs terminated with a 0,0 pair.  'UnMsg' is
    // WM_HELP or WM_CONTEXTMENU indicating the message received requesting
    // help.  'Wparam' and 'lparam' are the parameters of the message received
    // requesting help.
    //
{
    HWND hwnd;
    UINT unType;
    TCHAR* pszHelpFile;

    ASSERT( unMsg==WM_HELP || unMsg==WM_CONTEXTMENU );

    // Don't try to do help if it won't work.  See common\uiutil\ui.c.
    //
    {
        extern BOOL g_fNoWinHelp;
        if (g_fNoWinHelp)
        {
            return;
        }
    }

    if (unMsg == WM_HELP)
    {
        LPHELPINFO p = (LPHELPINFO )lparam;

        TRACE3( "ContextHelp(WM_HELP,t=%d,id=%d,h=$%08x)",
            p->iContextType, p->iCtrlId,p->hItemHandle );

        if (p->iContextType != HELPINFO_WINDOW)
        {
            return;
        }

        hwnd = p->hItemHandle;
        ASSERT( hwnd );
        unType = HELP_WM_HELP;
    }
    else
    {
        // Standard Win95 method that produces a one-item "What's This?" menu
        // that user must click to get help.
        //
        TRACE1( "ContextHelp(WM_CONTEXTMENU,h=$%08x)", wparam );

        hwnd = (HWND )wparam;
        unType = HELP_CONTEXTMENU;
    };

    if (fRouter)
    {
        pszHelpFile = g_pszRouterHelpFile;
    }
    else
    {
        pszHelpFile = g_pszHelpFile;
    }

    TRACE1( "WinHelp(%s)", pszHelpFile );
    WinHelp( hwnd, pszHelpFile, unType, (ULONG_PTR ) padwMap );
}


VOID
CopyLinkPhoneNumberInfo(
    OUT DTLNODE* pDstLinkNode,
    IN DTLNODE* pSrcLinkNode )

    // Copies the source link's phone number information to the destination
    // link.  Any existing destination information is properly destroyed.  The
    // arguments are DTLNODEs containing PBLINKs.
    //
{
    PBLINK* pSrcLink;
    PBLINK* pDstLink;
    DTLLIST* pDstList;

    pSrcLink = (PBLINK* )DtlGetData( pSrcLinkNode );
    pDstLink = (PBLINK* )DtlGetData( pDstLinkNode );

    pDstList =
         DtlDuplicateList(
             pSrcLink->pdtllistPhones, DuplicatePhoneNode, DestroyPhoneNode );

    if (pDstList)
    {
        DtlDestroyList( pDstLink->pdtllistPhones, DestroyPhoneNode );
        pDstLink->pdtllistPhones = pDstList;

        pDstLink->fPromoteAlternates = pSrcLink->fPromoteAlternates;
        pDstLink->fTryNextAlternateOnFail = pSrcLink->fTryNextAlternateOnFail;
    }
}


VOID
CopyPszListToPhoneList(
    IN OUT PBLINK* pLink,
    IN DTLLIST* pListPhoneNumbers )

    // Converts the phone number list of 'pLink' to be list created using the
    // the list of Psz phone numbers 'pListPhoneNumbers' for phone numbers.
    //
{
    DTLNODE* pNodeP;
    DTLNODE* pNodeZ;

    // Empty the existing list of PBPHONE nodes.
    //
    while (pNodeP = DtlGetFirstNode( pLink->pdtllistPhones ))
    {
        DtlRemoveNode( pLink->pdtllistPhones, pNodeP );
        DestroyPhoneNode( pNodeP );
    }

    // Recreate the list of PBPHONE nodes from the list of PSZ nodes.
    //
    for (pNodeZ = DtlGetFirstNode( pListPhoneNumbers );
         pNodeZ;
         pNodeZ = DtlGetNextNode( pNodeZ ))
    {
        PBPHONE* pPhone;

        pNodeP = CreatePhoneNode();
        if (!pNodeP)
        {
            continue;
        }

        pPhone = (PBPHONE* )DtlGetData( pNodeP );
        ASSERT( pPhone );

        Free0( pPhone->pszPhoneNumber );
        pPhone->pszPhoneNumber =
            StrDup( (TCHAR* )DtlGetData( pNodeZ ) );

        DtlAddNodeLast( pLink->pdtllistPhones, pNodeP );
    }
}

BOOL 
CountFreeComPorts(
    IN PWCHAR pszPort,
    IN HANDLE hData)

    // Com port enumeration function that counts the list of
    // free com ports.  Returns TRUE to stop enumeration (see 
    // MdmEnumComPorts)
{
    COUNT_FREE_COM_PORTS_DATA* pfcpData = (COUNT_FREE_COM_PORTS_DATA*)hData;
    DTLLIST* pListUsed = pfcpData->pListPortsInUse;
    DTLNODE* pNodeP, *pNodeL, *pNode;

    // If the given port is in the used list, then return 
    // so that it is not added to the list of free ports and
    // so that enumeration continues.
    for (pNodeL = DtlGetFirstNode( pListUsed );
         pNodeL;
         pNodeL = DtlGetNextNode( pNodeL ))
    {
        PBLINK* pLink = (PBLINK* )DtlGetData( pNodeL );
        ASSERT( pLink->pbport.pszPort );

        // The port already appears in a link in the list.
        if (lstrcmp( pLink->pbport.pszPort, pszPort ) == 0)
            return FALSE;
    }

    // The port is not in use.  Increment the count.
    pfcpData->dwCount += 1;

    return FALSE;
}


HWND
CreateWizardBitmap(
    IN HWND hwndDlg,
    IN BOOL fPage )

    // Create a static control that displays the RAS wizard bitmap at the
    // standard place on dialog 'hwndDlg'.  'FPage' is set if the bitmap is
    // being placed on a property page, false for the equivalent placement on
    // a dialog.
    //
    // Returns the bitmap window handle or NULL or error.
    //
{
    HWND hwnd;
    INT x;
    INT y;

    if (fPage)
    {
        x = y = 0;
    }
    else
    {
        x = y = 10;
    }

    hwnd =
        CreateWindowEx(
            0,
            TEXT("static"),
            NULL,
            WS_VISIBLE | WS_CHILD | SS_SUNKEN | SS_BITMAP,
            x, y, 80, 140,
            hwndDlg,
            (HMENU )CID_BM_Wizard,
            g_hinstDll,
            NULL );

    if (hwnd)
    {
        if (!g_hbmWizard)
        {
            g_hbmWizard = LoadBitmap(
                g_hinstDll, MAKEINTRESOURCE( BID_Wizard ) );
        }

        SendMessage( hwnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM )g_hbmWizard );
    }

    return hwnd;
}

TCHAR*
DisplayPszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort )

    // Returns address of heap block psz containing the MXS modem list display
    // form, i.e. the device name 'pszDevice' followed by the port name
    // 'pszPort'.  It's caller's responsibility to Free the returned string.
    //
{
    TCHAR* pszResult;
    TCHAR* pszD;

    if (pszDevice)
    {
        pszD = NULL;
    }
    else
    {
        pszD = pszDevice = PszFromId( g_hinstDll, SID_UnknownDevice );
    }

    pszResult = PszFromDeviceAndPort( pszDevice, pszPort );
    Free0( pszD );

    return pszResult;
}


TCHAR*
DisplayPszFromPpbport(
    IN PBPORT* pPort,
    OUT DWORD* pdwDeviceIcon )

    // Returns address of heap block psz containing the device display form of
    // the 'pPort', e.g. "Modem - KTel 28.8 Fax Plus" It's caller's
    // responsibility to Free the returned string.  If non-NULL,
    // '*pdwDeviceIcon' is set to the DI_* device icon code corresponding to
    // the device.  DI_* codes are used with the RAS ListView extensions to
    // show the correct item icon.
    //
{
    TCHAR* pszFormat;
    TCHAR* pszD;
    TCHAR* pszDT;
    TCHAR* pszDevice;
    TCHAR* pszDeviceType;
    TCHAR* pszResult;
    DWORD dwDeviceIcon;
    LPCTSTR pszChannel = NULL;

    // These are set if a resource string is read that must be Freed later.
    //
    pszDT = NULL;
    pszD = NULL;

    if (pPort->pszDevice)
    {
        pszDevice = pPort->pszDevice;
    }
    else
    {
        pszDevice = PszFromId( g_hinstDll, SID_UnknownDevice );

        if(NULL == pszDevice)
        {
            return NULL;
        }
        
        pszD = pszDevice;
    }

    // Set default format and device icon, though they may be changed below.
    //
    pszFormat = TEXT("%s - %s (%s)");
    dwDeviceIcon = DI_Adapter;

    if (pPort->pbdevicetype == PBDT_Modem
        && !(pPort->dwFlags & PBP_F_NullModem))
    {
        pszDeviceType = PszFromId( g_hinstDll, SID_Modem );
        pszDT = pszDeviceType;
        dwDeviceIcon = DI_Modem;
    }
    else if (pPort->pbdevicetype == PBDT_Isdn)
    {
        pszDeviceType = PszFromId( g_hinstDll, SID_Isdn );
        pszDT = pszDeviceType;
        pszFormat = TEXT("%s %s - %s");
    }
    else if (pPort->pbdevicetype == PBDT_X25)
    {
        pszDeviceType = PszFromId( g_hinstDll, SID_X25 );
        pszDT = pszDeviceType;
    }
    else if (pPort->pbdevicetype == PBDT_Pad)
    {
        pszDeviceType = PszFromId( g_hinstDll, SID_X25Pad );
        pszDT = pszDeviceType;
    }
    else
    {
        // Don't know the device type, so just bag the device descriptive word
        // and let the device name stand alone.
        //
        pszDeviceType = TEXT("");
        pszFormat = TEXT("%s%s (%s)");
    }

    if(NULL == pszDeviceType)
    {   
        pszDeviceType = TEXT("");
    }

    if(pPort->pbdevicetype != PBDT_Isdn)
    {
        pszResult = Malloc(
            (lstrlen( pszFormat ) + lstrlen( pszDeviceType ) + lstrlen( pszDevice ) + lstrlen( pPort->pszPort ))
                * sizeof(TCHAR) );
    }
    else
    {

        pszChannel = PszLoadString( g_hinstDll, SID_Channel );

        if(NULL == pszChannel)
        {
            pszChannel = TEXT("");
        }

        // For isdn use the following format
        // "Isdn channel - <DeviceName>
        // Talk to steve falcon about this if you have issues
        // with special casing isdn.
        //
        pszResult = Malloc(
            (lstrlen( pszFormat ) + lstrlen( pszDeviceType ) + lstrlen(pszChannel) + lstrlen( pszDevice ))
                * sizeof(TCHAR));
    }
    

    if (pszResult)
    {
        if(pPort->pbdevicetype != PBDT_Isdn)
        {
            wsprintf( pszResult, pszFormat, pszDeviceType, pszDevice, pPort->pszPort);
        }
        else
        {
            ASSERT(NULL != pszChannel);
            wsprintf( pszResult, pszFormat, pszDeviceType, pszChannel, pszDevice);
        }
    }

    if (pdwDeviceIcon)
    {
#if 1
        // Per SteveFal.  Wants "modem" icon for all if Device-Manager-style
        // physically descriptive icons cannot be used.
        //
        dwDeviceIcon = DI_Modem;
#endif
        *pdwDeviceIcon = dwDeviceIcon;
    }

    Free0( pszD );
    Free0( pszDT );

    return pszResult;
}


VOID
EnableCbWithRestore(
    IN HWND hwndCb,
    IN BOOL fEnable,
    IN BOOL fDisabledCheck,
    IN OUT BOOL* pfRestore )

    // Enable/disable the checkbox 'hwndCb' based on the 'fEnable' flag
    // including stashing and restoring a cached value '*pfRestore' when
    // disabled.  When disabling, the check value is set to 'fDisabledCheck'.
    //
{
    if (fEnable)
    {
        if (!IsWindowEnabled( hwndCb ))
        {
            // Toggling to enabled.  Restore the stashed check value.
            //
            Button_SetCheck( hwndCb, *pfRestore );
            EnableWindow( hwndCb, TRUE );
        }
    }
    else
    {
        if (IsWindowEnabled( hwndCb ))
        {
            // Toggling to disabled.  Stashed the current check value.
            //
            *pfRestore = Button_GetCheck( hwndCb );
            Button_SetCheck( hwndCb, fDisabledCheck );
            EnableWindow( hwndCb, FALSE );
        }
    }
}


VOID
EnableLbWithRestore(
    IN HWND hwndLb,
    IN BOOL fEnable,
    IN OUT INT* piRestore )

    // Enable/disable the combobox 'hwndLb' based on the 'fEnable' flag.  If
    // disabling, '*piRestore' is loaded with the stashed selection index and
    // a blank item is added to the front of the list and selected.  This is
    // undone if enabling.
    //
{
    if (fEnable)
    {
        if (!IsWindowEnabled( hwndLb ))
        {
            // Toggling to enabled.  Restore the stashed selection.
            //
            ComboBox_DeleteString( hwndLb, 0 );
            ComboBox_SetCurSelNotify( hwndLb, *piRestore );
            EnableWindow( hwndLb, TRUE );
        }
    }
    else
    {
        if (IsWindowEnabled( hwndLb ))
        {
            // Toggling to disabled.  Stash the selection index.
            //
            *piRestore = ComboBox_GetCurSel( hwndLb );
            ComboBox_InsertString( hwndLb, 0, TEXT("") );
            ComboBox_SetItemData( hwndLb, 0, NULL );
            ComboBox_SetCurSelNotify( hwndLb, 0 );
            EnableWindow( hwndLb, FALSE );
        }
    }
}


DTLNODE*
FirstPhoneNodeFromPhoneList(
    IN DTLLIST* pListPhones )

    // Return the first PBPHONE node in list of PBPHONEs 'pListPhones' or a
    // default node if none.  Returns NULL if out of memory.
    //
{
    DTLNODE* pFirstNode;
    DTLNODE* pNode;

    pFirstNode = DtlGetFirstNode( pListPhones );
    if (pFirstNode)
    {
        pNode = DuplicatePhoneNode( pFirstNode );
    }
    else
    {
        pNode = CreatePhoneNode();
    }

    return pNode;
}


VOID
FirstPhoneNodeToPhoneList(
    IN DTLLIST* pListPhones,
    IN DTLNODE* pNewNode )

    // Replace the first PBPHONE node in list of PBPHONEs 'pListPhones' with
    // 'pNewNode', deleting any existing first node.  Caller's actual
    // 'pNewNode', not a copy, is linked.
    //
{
    DTLNODE* pFirstNode;
    DTLNODE* pNode;

    pFirstNode = DtlGetFirstNode( pListPhones );
    if (pFirstNode)
    {
        DtlRemoveNode( pListPhones, pFirstNode );
        DestroyPhoneNode( pFirstNode );
    }

    DtlAddNodeFirst( pListPhones, pNewNode );
}


#if 0 //!!!
TCHAR*
FirstPhoneNumberFromEntry(
    IN PBENTRY* pEntry )

    // Returns the first phone number of the first link of entry 'pEntry' or
    // an empty string if none.  The returned address is into the list of
    // phone numbers and should be copied if it needs to be stored.
    //
{
    TCHAR* pszPhoneNumber;
    DTLNODE* pNode;
    PBLINK*  pLink;

    TRACE( "FirstPhoneNumberFromEntry" );

    ASSERT( pEntry->pdtllistLinks );
    pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
    ASSERT( pNode );
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT( pLink );

    return FirstPszFromList( pLink->pdtllistPhoneNumbers );
}
#endif


TCHAR*
FirstPszFromList(
    IN DTLLIST* pPszList )

    // Returns the first string from the first node of 'pPszList' or an empty
    // string if none.  The returned address is into the list and should be
    // copied if it needs to be stored.
    //
{
    TCHAR* psz;
    DTLNODE* pNode;

    TRACE( "FirstPszFromList" );

    if (DtlGetNodes( pPszList ) > 0)
    {
        pNode = DtlGetFirstNode( pPszList );
        ASSERT( pNode );
        psz = (TCHAR* )DtlGetData( pNode );
        ASSERT( psz );
    }
    else
    {
        psz = TEXT("");
    }

    return psz;
}


#if 0 //!!!
DWORD
FirstPhoneNumberToEntry(
    IN PBENTRY* pEntry,
    IN TCHAR* pszPhoneNumber )

    // Sets the first phone number of the first link of entry 'pEntry' to
    // 'pszPhoneNumber'.
    //
    // Returns 0 if successful, or an error code.
    //
{
    DTLNODE* pNode;
    PBLINK* pLink;
    TCHAR* pszNew;

    TRACE( "FirstPhoneNumberToEntry" );

    ASSERT( pEntry->pdtllistLinks );
    pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
    ASSERT( pNode );
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT( pLink );
    ASSERT( pLink->pdtllistPhoneNumbers );

    return FirstPszToList( pLink->pdtllistPhoneNumbers, pszPhoneNumber );
}
#endif


DWORD
FirstPszToList(
    IN DTLLIST* pPszList,
    IN TCHAR* psz )

    // Sets the string of the first node of the list 'pPszList' to a copy of
    // 'psz'.  If 'psz' is "" the first node is deleted.
    //
    // Returns 0 if successful, or an error code.
    //
{
    DTLNODE* pNode;
    TCHAR* pszNew;

    ASSERT( pPszList );

    // Delete the existing first node, if any.
    //
    if (DtlGetNodes( pPszList ) > 0)
    {
        pNode = DtlGetFirstNode( pPszList );
        DtlRemoveNode( pPszList, pNode );
        DestroyPszNode( pNode );
    }

    // Create a new first node and link it.  An empty string is not added.
    //
    if (*psz == TEXT('\0'))
        return 0;

    pszNew = StrDup( psz );
    pNode = DtlCreateNode( pszNew, 0 );
    if (!pszNew || !pNode)
    {
        Free0( pszNew );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DtlAddNodeFirst( pPszList, pNode );
    return 0;
}

//
// Function:    GetBoldWindowFont
//
// Purpose:     Generate bold or large bold fonts based on the font of the
//              window specified
//
// Parameters:  hwnd       [IN] - Handle of window to base font on
//              fLargeFont [IN] - If TRUE, generate a 12 point bold font for
//                                use in the wizard "welcome" page.
//              pBoldFont [OUT] - The newly generated font, NULL if the
//
// Returns:     nothing
//
VOID 
GetBoldWindowFont(
    IN  HWND hwnd, 
    IN  BOOL fLargeFont, 
    OUT HFONT * pBoldFont)
{
    LOGFONT BoldLogFont;
    HFONT   hFont;
    TCHAR   FontSizeString[MAX_PATH];
    INT     FontSize;
    HDC     hdc;
    
    *pBoldFont = NULL;

    // Get the font used by the specified window
    //
    hFont = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0L);
    if (NULL == hFont)
    {
        // If not found then the control is using the system font
        //
        hFont = (HFONT)GetStockObject(SYSTEM_FONT);
    }

    if (hFont)
    {
        // Get the font info so we can generate the BOLD version
        //
        if (GetObject(hFont, sizeof(BoldLogFont), &BoldLogFont))
        {
            // Create the Bold Font
            //
            BoldLogFont.lfWeight   = FW_BOLD;

            hdc = GetDC(hwnd);
            if (hdc)
            {
                // Large (tall) font is an option
                //
                if (fLargeFont)
                {
                    // Load size and name from resources, 
                    // since these may change
                    // from locale to locale based on the 
                    // size of the system font, etc.
                    //
                    UINT nLen;
                    PWCHAR pszFontName = NULL, pszFontSize = NULL;

                    pszFontName = (PWCHAR)PszLoadString(
                                        g_hinstDll, 
                                        SID_LargeFontName);
                    pszFontSize = (PWCHAR)PszLoadString(
                                        g_hinstDll, 
                                        SID_LargeFontSize);
                    if (pszFontName != NULL)
                    {
                        lstrcpyn(
                            BoldLogFont.lfFaceName, 
                            pszFontName, 
                            sizeof(BoldLogFont.lfFaceName) / sizeof(TCHAR));
                    }

                    FontSize = 12;
                    nLen = lstrlen(pszFontName);
                    if (pszFontSize)
                    {
                        lstrcpyn(
                            FontSizeString, 
                            pszFontSize,
                            sizeof(FontSizeString) / sizeof(TCHAR));
                        FontSize = wcstoul((const TCHAR*)FontSizeString, NULL, 10);
                    }

                    BoldLogFont.lfHeight = 
                        0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

                    //Free0(pszFontName);
                    //Free0(pszFontSize);
                }

                *pBoldFont = CreateFontIndirect(&BoldLogFont);
                ReleaseDC(hwnd, hdc);
            }
        }
    }
}

DWORD
GetDefaultEntryName(
    IN  PBFILE* pFile,
    IN  DWORD dwType,
    IN  BOOL fRouter,
    OUT TCHAR** ppszName )

    // Loads a default entry name into '*ppszName' that is unique within open
    // phonebook 'pFile', or if NULL, in all default phonebooks.  'FRouter' is
    // set if a router-style name should be chosen rather than a client-style
    // name.  It is caller's responsibility to Free the returned string.
    //
    // Returns 0 if successful or an error code.
    //
{
    DWORD dwErr;
    TCHAR szBuf[ RAS_MaxEntryName + 1 ];
    UINT unSid;
    LPCTSTR pszDefault;
    DWORD dwDefaultLen;
    LONG lNum;
    PBFILE file;
    DTLNODE* pNode;

    *ppszName = NULL;

    if (fRouter)
    {
        unSid = SID_DefaultRouterEntryName;
    }
    else
    {
        unSid = SID_DefaultEntryName;

        if (RASET_Vpn == dwType)
        {
            unSid = SID_DefaultVpnEntryName;
        }

        else if (RASET_Direct == dwType)
        {
            unSid = SID_DefaultDccEntryName;
        }

        else if (RASET_Broadband == dwType)
        {
            unSid = SID_DefaultBbEntryName;
        }
    }

    pszDefault = PszLoadString( g_hinstDll, unSid );
    lstrcpyn( szBuf, pszDefault, sizeof(szBuf) / sizeof(TCHAR) );
    dwDefaultLen = lstrlen( pszDefault ) + 1;   // +1 for extra space below
    lNum = 2;

    for (;;)
    {
        if (pFile)
        {
            if (!EntryNodeFromName( pFile->pdtllistEntries, szBuf ))
            {
                break;
            }
        }
        else
        {
            if (GetPbkAndEntryName(
                    NULL, szBuf, RPBF_NoCreate, &file, &pNode ) == 0)
            {
                ClosePhonebookFile( &file );
            }
            else
            {
                break;
            }
        }

        // Duplicate entry found so increment the default name and try the
        // next one.
        //
        lstrcpyn( szBuf, pszDefault, sizeof(szBuf) / sizeof(TCHAR) );
        lstrcat( szBuf, TEXT(" "));
        LToT( lNum, szBuf + dwDefaultLen, 10 );
        ++lNum;
    }

    *ppszName = StrDup( szBuf );
    if (!*ppszName)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return ERROR_SUCCESS;
}

BOOL
IsLocalPad(
    IN PBENTRY* pEntry )

    // Returns true if 'pEntry' is a local PAD device, i.e. the first link of
    // the entry has device type "pad", false otherwise.
    //
{
    PBLINK* pLink;
    DTLNODE* pNode;

    if (!pEntry)
    {
        return FALSE;
    }

    ASSERT( pEntry->pdtllistLinks );
    pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
    ASSERT( pNode );
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT( pLink );

    return (pLink->pbport.pbdevicetype == PBDT_Pad);
}

#if 0
//----------------------------------------------------------------------------
// Function:    IsNt40Machine
//
// Returns whether the given machine is running nt40
//----------------------------------------------------------------------------

DWORD
IsNt40Machine (
    IN      PWCHAR      pszServer,
    OUT     PBOOL       pbIsNt40)
{

    DWORD dwErr, dwType = REG_SZ, dwLength;
    HKEY hkMachine, hkVersion;
    WCHAR pszBuildNumber[64];
    PWCHAR pszMachine = NULL;

    //
    // Validate and initialize
    //

    if (!pbIsNt40) 
    { 
        return ERROR_INVALID_PARAMETER; 
    }
    *pbIsNt40 = FALSE;

    do 
    {
        // Format the machine name
        if ( (pszServer) && (wcslen(pszServer) > 0) ) 
        {
            dwLength = wcslen( pszServer ) + 3;
            pszMachine = (PWCHAR) Malloc ( dwLength * sizeof( WCHAR ) );
            if (pszMachine == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            if ( *pszMachine == L'\\' )
            {
                wcscpy( pszMachine, pszServer );
            }
            else
            {
                wcscpy( pszMachine, L"\\\\" );
                wcscat( pszMachine, pszServer );
            }
        }
        else
        {
            pszMachine = NULL;
        }
    
        //
        // Connect to the remote server
        //
        dwErr = RegConnectRegistry(
                    pszMachine,
                    HKEY_LOCAL_MACHINE,
                    &hkMachine);
        if ( dwErr != ERROR_SUCCESS )        
        {
            break;
        }

        //
        // Open the windows version key
        //

        dwErr = RegOpenKeyEx(
                    hkMachine, 
                    c_szWinVersionPath, 
                    0, 
                    KEY_ALL_ACCESS, 
                    &hkVersion
                    );

        if ( dwErr != NO_ERROR ) 
        { 
            break; 
        }

        //
        // Read in the current version key
        //
        dwLength = sizeof(pszBuildNumber);
        dwErr = RegQueryValueEx (
                    hkVersion, 
                    c_szCurrentBuildNumber, 
                    NULL, 
                    &dwType,
                    (BYTE*)pszBuildNumber, 
                    &dwLength
                    );
        
        if (dwErr != NO_ERROR) 
        { 
            break; 
        }

        if (lstrcmp (pszBuildNumber, c_szNt40BuildNumber) == 0) 
        {
            *pbIsNt40 = TRUE;
        }
        
    } while (FALSE);


    // Cleanup
    {
        if ( hkVersion )
        {
            RegCloseKey( hkVersion );
        }
        if ( hkMachine )
        {
            RegCloseKey( hkMachine );
        }
        Free0( pszMachine );            
    }

    return dwErr;
}    

#endif

BOOL
PhoneNodeIsBlank(
    IN DTLNODE* pNode )

    // Returns true if the phone number in PBPHONE node 'pNode' is "blank",
    // i.e. it contains no area code, phone number, or comment strings.
    //
{
    PBPHONE* pPhone;

    pPhone = (PBPHONE* )DtlGetData( pNode );
    ASSERT( pPhone );

    if ((!pPhone->pszAreaCode || IsAllWhite( pPhone->pszAreaCode ))
        && (!pPhone->pszPhoneNumber || IsAllWhite( pPhone->pszPhoneNumber ))
        && (!pPhone->pszComment || IsAllWhite( pPhone->pszComment )))
    {
        return TRUE;
    }

    return FALSE;
}


BOOL
PhoneNumberDlg(
    IN HWND hwndOwner,
    IN BOOL fRouter,
    IN OUT DTLLIST* pList,
    IN OUT BOOL* pfCheck )

    // Popup the phone number list dialog.  'HwndOwner' is the owner of the
    // created dialog.  'FRouter' indicates router-style labels should be used
    // rather than client-style.  'PList' is a list of Psz nodes containing
    // the phone numbers.  'PfCheck' is the address that contains the initial
    // "promote number" checkbox setting and which receives the value set by
    // user.
    //
    // Returns true if user presses OK and succeeds, false if he presses
    // Cancel or encounters an error.
    //
{
    DWORD sidHuntTitle;
    DWORD sidHuntItemLabel;
    DWORD sidHuntListLabel;
    DWORD sidHuntCheckLabel;

    //For whistler bug 227538
    TCHAR *pszTitle = NULL, *pszItem = NULL, *pszList = NULL, *pszCheck = NULL;
    DWORD dwErr = NO_ERROR;

    TRACE( "PhoneNumberDlg" );

    if (fRouter)
    {
        sidHuntTitle = SID_RouterHuntTitle;
        sidHuntItemLabel = SID_RouterHuntItemLabel;
        sidHuntListLabel = SID_RouterHuntListLabel;
        sidHuntCheckLabel = SID_RouterHuntCheckLabel;
    }
    else
    {
        sidHuntTitle = SID_HuntTitle;
        sidHuntItemLabel = SID_HuntItemLabel;
        sidHuntListLabel = SID_HuntListLabel;
        sidHuntCheckLabel = SID_HuntCheckLabel;
    }

    pszTitle = PszFromId( g_hinstDll, sidHuntTitle );
    pszItem  = PszFromId( g_hinstDll, sidHuntItemLabel );
    pszList  = PszFromId( g_hinstDll, sidHuntListLabel );
    pszCheck = PszFromId( g_hinstDll, sidHuntCheckLabel );

    dwErr=ListEditorDlg(
            hwndOwner,
            pList,
            pfCheck,
            RAS_MaxPhoneNumber,
            pszTitle, 
            pszItem,
            pszList,
            pszCheck,
            NULL,
            0,
            g_adwPnHelp,
            0,
            NULL );

     Free0( pszTitle );
     Free0( pszItem );
     Free0( pszList );
     Free0( pszCheck );

     return dwErr;
}


VOID
PositionDlg(
    IN HWND hwndDlg,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg )

    // Positions the dialog 'hwndDlg' based on caller's API settings, where
    // 'fPosition' is the RASxxFLAG_PositionDlg flag and 'xDlg' and 'yDlg' are
    // the coordinates.
    //
{
    if (fPosition)
    {
        // Move it to caller's coordinates.
        //
        SetWindowPos( hwndDlg, NULL, xDlg, yDlg, 0, 0,
            SWP_NOZORDER + SWP_NOSIZE );
        UnclipWindow( hwndDlg );
    }
    else
    {
        // Center it on the owner window, or on the screen if none.
        //
        CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    }
}


LRESULT CALLBACK
PositionDlgStdCallWndProc(
    int code,
    WPARAM wparam,
    LPARAM lparam )

    // Standard Win32 CallWndProc hook callback that positions the next dialog
    // to start in this thread at our standard offset relative to owner.
    //
{
    // Arrive here when any window procedure associated with our thread is
    // called.
    //
    if (!wparam)
    {
        CWPSTRUCT* p = (CWPSTRUCT* )lparam;

        // The message is from outside our process.  Look for the MessageBox
        // dialog initialization message and take that opportunity to position
        // the dialog at the standard place relative to the calling dialog.
        //
        if (p->message == WM_INITDIALOG)
        {
            RECT rect;
            HWND hwndOwner;

            hwndOwner = GetParent( p->hwnd );
            GetWindowRect( hwndOwner, &rect );
            SetWindowPos( p->hwnd, NULL,
                rect.left + DXSHEET, rect.top + DYSHEET,
                0, 0, SWP_NOZORDER + SWP_NOSIZE );
            UnclipWindow( p->hwnd );
        }
    }

    return 0;
}


TCHAR*
PszFromPhoneNumberList(
    IN DTLLIST* pList )

    // Returns the phone numbers in phone number list 'pList' in a comma
    // string or NULL on error.  It is caller's responsiblity to Free the
    // returned string.
    //
{
    TCHAR* pszResult, *pszTemp;
    DTLNODE* pNode;
    DWORD cb;

    const TCHAR* pszSeparator = TEXT(", ");

    cb = (DtlGetNodes( pList ) *
             (RAS_MaxPhoneNumber + lstrlen( pszSeparator )) + 1)
             * sizeof(TCHAR);
    pszResult = Malloc( cb );
    if (!pszResult)
    {
        return NULL;
    }

    *pszResult = TEXT('\0');

    for (pNode = DtlGetFirstNode( pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz = (TCHAR* )DtlGetData( pNode );
        ASSERT( psz );

        if (*pszResult)
            lstrcat( pszResult, pszSeparator );
        lstrcat( pszResult, psz );
    }

    pszTemp = Realloc( pszResult,
        (lstrlen( pszResult ) + 1) * sizeof(TCHAR) );
    ASSERT( pszTemp );
    if (pszTemp)
    {
        pszResult = pszTemp;
    }

    return pszResult;
}


#if 0
LRESULT CALLBACK
SelectDesktopCallWndRetProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam )

    // Standard Win32 CallWndRetProc hook callback that makes "Desktop" the
    // initial selection of the FileOpen "Look in" combo-box.
    //
{
    // Arrive here when any window procedure associated with our thread is
    // called.
    //
    if (!wparam)
    {
        CWPRETSTRUCT* p = (CWPRETSTRUCT* )lparam;

        // The message is from outside our process.  Look for the MessageBox
        // dialog initialization message and take that opportunity to set the
        // "Look in:" combo box to the first item, i.e. "Desktop".  FileOpen
        // keys off CBN_CLOSEUP rather than CBN_SELCHANGE to update the
        // "contents" listbox.
        //
        if (p->message == WM_INITDIALOG)
        {
            HWND hwndLbLookIn;

            hwndLbLookIn = GetDlgItem( p->hwnd, cmb2 );
            ComboBox_SetCurSel( hwndLbLookIn, 0 );
            SendMessage( p->hwnd, WM_COMMAND,
                MAKELONG( cmb2, CBN_CLOSEUP ), (LPARAM )hwndLbLookIn );
        }
    }

    return 0;
}
#endif

//We want to get rid of the Icon resources from rasdlg, they take too much
//memory resource. instead, we retrieve them from netman.dll, if failed, we
//use the default one IID_Broadband         gangz
//Also, for whistler bug 372078 364763 364876
//

HICON
GetCurrentIconEntryType(
    IN DWORD dwType,
    IN BOOL  fSmall)
{
    HICON hIcon = NULL;
    DWORD dwSize, dwConnectionIcon;
    HRESULT hr = E_FAIL;
    NETCON_MEDIATYPE ncm;
    HMODULE hNetshell = NULL;

    HRESULT (WINAPI * pHrGetIconFromMediaType) (DWORD ,
                                                NETCON_MEDIATYPE ,
                                                NETCON_SUBMEDIATYPE ,
                                                DWORD ,
                                                DWORD ,
                                                HICON *);

    dwSize = fSmall ? 16 : 32;

    switch (dwType)
    {
        case RASET_Direct:
        {
            ncm = NCM_DIRECT;
            break;
        }

        case RASET_Vpn:
        {
            ncm = NCM_TUNNEL;
            break;
        }

        case RASET_Broadband:
        {
            ncm = NCM_PPPOE;
            break;
        }

        case RASET_Phone:
        default:
        {
            ncm = NCM_PHONE;
            break;
        }
    }

    hNetshell = LoadLibrary(TEXT("netshell.dll"));

    if( hNetshell )
    {
        pHrGetIconFromMediaType =(HRESULT (WINAPI*)(
                           DWORD ,
                           NETCON_MEDIATYPE ,
                           NETCON_SUBMEDIATYPE ,
                           DWORD ,
                           DWORD ,
                           HICON *) )GetProcAddress(
                                        hNetshell,
                                        "HrGetIconFromMediaType");

        if ( NULL != pHrGetIconFromMediaType )
        {
            /*******************************************************************
            **  dwConnectionIcon - (This is the little Computer part of the icon):
            **  0 - no connection overlay 
            **  4 - Connection Icon with both lights off (Disabled status)
            **  5 - Connection Icon with left light on (Transmitting Data)
            **  6 - Connection Icon with right light on (Receiving Data)
            **  7 - Connection Icon with both lights on (Enabled status)
            *********************************************************************/

            dwConnectionIcon = 7;
            hr = pHrGetIconFromMediaType(dwSize,
                                ncm,
                                NCSM_NONE,
                                7,
                                0,
                                &hIcon);
            
        }
        FreeLibrary( hNetshell );
    }

    if ( !SUCCEEDED(hr) || !hIcon)
    {
        ICONINFO iInfo;
        HICON hTemp;
        hTemp = LoadIcon( g_hinstDll, MAKEINTRESOURCE( IID_Broadband ) );

        if(hTemp)
        {
            if( GetIconInfo(hTemp, &iInfo) )
            {
                hIcon = CreateIconIndirect(&iInfo);
            }
        }
    }

    return hIcon;
}
    

VOID
SetIconFromEntryType(
    IN HWND hwndIcon,
    IN DWORD dwType,
    IN BOOL fSmall)

    // Set the icon image of icon control 'dwType' to the image corresponding
    // to the entry type 'dwType'.
    //
{
    HICON hIcon = NULL;

    hIcon = GetCurrentIconEntryType( dwType, fSmall );
    
    if (hIcon)
    {
        Static_SetIcon( hwndIcon, hIcon );
    }
}


VOID
TweakTitleBar(
    IN HWND hwndDlg )

    // Adjust the title bar to include an icon if unowned and the modal frame
    // if not.  'HwndDlg' is the dialog window.
    //
{
    if (GetParent( hwndDlg ))
    {
        LONG lStyle;
        LONG lStyleAdd;

        // Drop the system menu and go for the dialog look.
        //
        lStyleAdd = WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE;

        lStyle = GetWindowLong( hwndDlg, GWL_EXSTYLE );
        if (lStyle)
            SetWindowLong( hwndDlg, GWL_EXSTYLE, lStyle | lStyleAdd );
    }
    else
    {
        // Stick a DUN1 icon in the upper left of the dialog, and more
        // importantly on the task bar
        //
        // Whistler bug: 343455 RAS: Connection dialogs need to use new icons
        //
        //For whistler bug 381099 372078        gangz
        //
        HICON hIcon = NULL;

      SendMessage( hwndDlg, WM_SETICON, ICON_SMALL,
            (LPARAM )LoadIcon( g_hinstDll, MAKEINTRESOURCE( IID_Dun1 ) ) );
 	
        /*
       //Use small Icon         gangz   
       //Icon returned from GetCurrentIconEntryType() has to be destroyed after use
       //In the future, Deonb will return a Icon for IID_Dun1 or dun1.ico for us.
       
       hIcon = GetCurrentIconEntryType(RASET_Broadband , TRUE); 

        ASSERT(hIcon);
        if(hIcon)
        {
            SendMessage( hwndDlg, WM_SETICON, ICON_SMALL, (LPARAM)(hIcon) );
            SetProp( hwndDlg, TEXT("TweakTitleBar_Icon"), hIcon);
        }
        */
    }
}


int CALLBACK
UnHelpCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam )

    // A standard Win32 commctrl PropSheetProc.  See MSDN documentation.
    //
    // Returns 0 always.
    //
{
    TRACE2( "UnHelpCallbackFunc(m=%d,l=%08x)",unMsg, lparam );

    if (unMsg == PSCB_PRECREATE)
    {
        extern BOOL g_fNoWinHelp;

        // Turn off context help button if WinHelp won't work.  See
        // common\uiutil\ui.c.
        //
        if (g_fNoWinHelp)
        {
            DLGTEMPLATE* pDlg = (DLGTEMPLATE* )lparam;
            pDlg->style &= ~(DS_CONTEXTHELP);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasphone\rasphone.c ===
/* Copyright (c) 1995-1996, Microsoft Corporation, all rights reserved
**
** rasphone.c
** Remote Access Phonebook
** Main routines
**
** 05/31/95 Steve Cobb
*/

#include <windows.h>     // Win32 core
#include <stdlib.h>      // __argc and __argv
#include <rasdlg.h>      // RAS common dialog APIs
#include <raserror.h>    // RAS error constants
#include <debug.h>       // Trace/Assert
#include <nouiutil.h>    // No-HWND utilities
#include <uiutil.h>      // HWND utilities
#include <rnk.h>         // Dial-up shortcut file
#include <rasphone.rch>  // Our resource constants
#include <lmsname.h>     // for SERVICE_NETLOGON definition
#include <commctrl.h>    // added to be "Fusionized"
#include <shfusion.h>    // added to be "Fusionized"


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Identifies a running mode of the application.  The non-default entries
** indicate some alternate behavior has been specified on the command line,
** e.g. command line delete entry.
*/
#define RUNMODE enum tagRUNMODE
RUNMODE
{
    RM_None,
    RM_AddEntry,
    RM_EditEntry,
    RM_CloneEntry,
    RM_RemoveEntry,
    RM_DialEntry,
    RM_HangUpEntry,
};


/*----------------------------------------------------------------------------
** Globals
**----------------------------------------------------------------------------
*/

HINSTANCE g_hinst = NULL;
RUNMODE   g_mode = RM_None;
BOOL      g_fNoRename = FALSE;
TCHAR*    g_pszAppName = NULL;
TCHAR*    g_pszPhonebookPath = NULL;
TCHAR*    g_pszEntryName = NULL;
TCHAR*    g_pszShortcutPath = NULL;


/*-----------------------------------------------------------------------------
** Local prototypes
**-----------------------------------------------------------------------------
*/

DWORD
HangUpEntry(
    void );

DWORD
ParseCmdLineArgs(
    void );

DWORD
RemoveEntry(
    void );

DWORD
Run(
    void );

DWORD
StringArgFollows(
    IN     UINT     argc,
    IN     CHAR**   argv,
    IN OUT UINT*    piCurArg,
    OUT    TCHAR**  ppszOut );

INT WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     pszCmdLine,
    int       nCmdShow );


/*-----------------------------------------------------------------------------
** Routines
**-----------------------------------------------------------------------------
*/

INT WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     pszCmdLine,
    int       nCmdShow )

    /* Standard Win32 application entry point.
    */
{
    DWORD dwErr;

    DEBUGINIT("RASPHONE");
    TRACE("WinMain");

    g_hinst = hInstance;

    /* Whistler bug 293751 rasphone.exe / rasautou.exe need to be "Fusionized"
    ** for UI conistency w/Connections Folder
    */
    SHFusionInitializeFromModule( g_hinst );

    dwErr = ParseCmdLineArgs();
    if (dwErr == 0)
    {
        /* Execute based on command line arguments.
        */
        dwErr = Run();
    }
    else
    {
        MSGARGS msgargs;

        /* Popup a "usage" message.
        */
        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = g_pszAppName;
        msgargs.apszArgs[ 1 ] = PszFromId( g_hinst, SID_Usage2 );
        msgargs.apszArgs[ 2 ] = PszFromId( g_hinst, SID_Usage3 );
        msgargs.apszArgs[ 3 ] = PszFromId( g_hinst, SID_Usage4 );
        msgargs.apszArgs[ 4 ] = PszFromId( g_hinst, SID_Usage5 );
        msgargs.apszArgs[ 5 ] = PszFromId( g_hinst, SID_Usage6 );
        MsgDlgUtil( NULL, SID_Usage, &msgargs, g_hinst, SID_UsageTitle );
        Free0( msgargs.apszArgs[ 1 ] );
        Free0( msgargs.apszArgs[ 2 ] );
        Free0( msgargs.apszArgs[ 3 ] );
        Free0( msgargs.apszArgs[ 4 ] );
        Free0( msgargs.apszArgs[ 5 ] );
    }

    Free0( g_pszAppName );
    Free0( g_pszPhonebookPath );
    Free0( g_pszEntryName );

    /* Whistler bug 293751 rasphone.exe / rasautou.exe need to be "Fusionized"
    ** for UI conistency w/Connections Folder
    */
    SHFusionUninitialize();

    TRACE1("WinMain=%d",dwErr);
    DEBUGTERM();

    return (INT )dwErr;
}


BOOL
FIsRasInstalled ()
{
    static const TCHAR c_szRegKeyRasman[] =
            TEXT("SYSTEM\\CurrentControlSet\\Services\\Rasman");

    BOOL fIsRasInstalled = FALSE;

    HKEY hkey;
    if (RegOpenKey( HKEY_LOCAL_MACHINE, c_szRegKeyRasman, &hkey ) == 0)
    {
        fIsRasInstalled = TRUE;
        RegCloseKey( hkey );
    }

    return fIsRasInstalled;
}


DWORD
HangUpEntry(
    void )

    /* Hang up the entry specified on the command line.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD    dwErr;
    HRASCONN hrasconn;

    TRACE("HangUpEntry");

    if (!g_pszEntryName)
        return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;

    dwErr = LoadRasapi32Dll();
    if (dwErr != 0)
        return dwErr;

    /* Currently, if user does not specify a phonebook path on the command
    ** line we look for any entry with the name he selected disregarding what
    ** phonebook it comes from.  Should probably map it specifically to the
    ** default phonebook as the other options do, but that would mean linking
    ** in all of PBK.LIB.  Seems like overkill for this little quibble.  Maybe
    ** we need a RasGetDefaultPhonebookName API.
    */
    hrasconn = HrasconnFromEntry( g_pszPhonebookPath, g_pszEntryName );
    if (hrasconn)
    {
        ASSERT(g_pRasHangUp);
        TRACE("RasHangUp");
        dwErr = g_pRasHangUp( hrasconn );
        TRACE1("RasHangUp=%d",dwErr);
    }

    UnloadRasapi32Dll();

    return dwErr;
}


DWORD
ParseCmdLineArgs(
    void )

    /* Parse command line arguments, filling in global settings accordingly.
    **
    ** Returns 0 if successful, or a non-0 error code.
    */
{
    DWORD  dwErr;
    UINT   argc;
    CHAR** argv;
    UINT   i;

    /* Usage: appname [-v] [-f file] [-e|-c|-d|-h|-r entry]
    **        appname [-v] [-f file] -a [entry]
    **        appname [-v] -lx link
    **        appname -s
    **
    **    '-a'    Popup new entry dialogs
    **    '-e'    Popup edit entry dialogs
    **    '-d'    Popup dial entry dialogs
    **    '-h'    Quietly hang up the entry
    **    '-r'    Quietly delete the entry
    **    '-lx'   Execute command 'x' on dial-up shortcut file
    **    'x'     Any of the commands e, v, c, r, d, h, or a
    **    'entry' The entry name to which the operation applies
    **    'file'  The full path to the dial-up phonebook file (.pbk)
    **    'link'  The full path to the dial-up shortcut file (.rnk)
    **
    **    'entry' without a preceding flag starts the phone list dialog with
    **    the entry selected.
    */

    argc = __argc;
    argv = __argv;
    dwErr = 0;

    {
        CHAR* pStart = argv[ 0 ];
        CHAR* p;

        for (p = pStart + lstrlenA( pStart ) - 1; p >= pStart; --p)
        {
            if (*p == '\\' || *p == ':')
                break;
        }

        g_pszAppName = StrDupTFromA( p + 1 );
    }

    for (i = 1; i < argc && dwErr == 0; ++i)
    {
        CHAR* pszArg = argv[ i ];

        if (*pszArg == '-' || *pszArg == '/')
        {
            switch (pszArg[ 1 ])
            {
                case 'a':
                case 'A':
                    g_mode = RM_AddEntry;
                    StringArgFollows( argc, argv, &i, &g_pszEntryName );
                    break;

                case 'e':
                case 'E':
                    g_mode = RM_EditEntry;
                    dwErr = StringArgFollows( argc, argv, &i, &g_pszEntryName );
                    break;
                    
                case 'r':
                case 'R':
                    g_mode = RM_RemoveEntry;
                    dwErr = StringArgFollows( argc, argv, &i, &g_pszEntryName );
                    break;

                case 'd':
                case 'D':
                case 't':
                case 'T':
                    g_mode = RM_DialEntry;
                    dwErr = StringArgFollows( argc, argv, &i, &g_pszEntryName );
                    break;
                    
                case 'h':
                case 'H':
                    g_mode = RM_HangUpEntry;
                    dwErr = StringArgFollows( argc, argv, &i, &g_pszEntryName );
                    break;

                case 'f':
                case 'F':
                    dwErr = StringArgFollows(
                        argc, argv, &i, &g_pszPhonebookPath );
                    break;

                case 'l':
                case 'L':
                    switch (pszArg[ 2 ])
                    {
                        case 'a':
                        case 'A':
                            g_mode = RM_AddEntry;
                            StringArgFollows( argc, argv, &i, &g_pszEntryName );
                            break;

                        case 'e':
                        case 'E':
                            g_mode = RM_EditEntry;
                            break;

                        case 'c':
                        case 'C':
                            g_mode = RM_CloneEntry;
                            break;

                        case 'v':
                        case 'V':
                            g_fNoRename = TRUE;
                            break;

                        case 'r':
                        case 'R':
                            g_mode = RM_RemoveEntry;
                            break;

                        case 'd':
                        case 'D':
                        case 't':
                        case 'T':
                            g_mode = RM_DialEntry;
                            break;

                        case 'h':
                        case 'H':
                            g_mode = RM_HangUpEntry;
                            break;

                        default:
                            dwErr = ERROR_INVALID_PARAMETER;
                            break;
                    }

                    if (dwErr == 0)
                    {
                        dwErr = StringArgFollows(
                            argc, argv, &i, &g_pszShortcutPath );
                    }
                    break;

                default:
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
            }
        }
        else if (i == 1)
        {
            --i;
            dwErr = StringArgFollows( argc, argv, &i, &g_pszEntryName );
            break;
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    if (dwErr == 0 && g_pszShortcutPath)
    {
        RNKINFO* pInfo;

        /* Read the phonebook and entry from the dial-up shortcut file.
        */
        pInfo = ReadShortcutFile( g_pszShortcutPath );
        if (!pInfo)
            dwErr = ERROR_OPEN_FAILED;
        else
        {
            g_pszPhonebookPath = StrDup( pInfo->pszPhonebook );
            if (g_mode != RM_AddEntry)
                g_pszEntryName = StrDup( pInfo->pszEntry );

            FreeRnkInfo( pInfo );
        }
    }

    TRACE2("CmdLine: m=%d,v=%d",g_mode,g_fNoRename);
    TRACEW1("CmdLine: e=%s",(g_pszEntryName)?g_pszEntryName:TEXT(""));
    TRACEW1("CmdLine: f=%s",(g_pszPhonebookPath)?g_pszPhonebookPath:TEXT(""));
    TRACEW1("CmdLine: l=%s",(g_pszShortcutPath)?g_pszShortcutPath:TEXT(""));

    return dwErr;
}


DWORD
RemoveEntry(
    void )

    /* Remove the entry specified on the command line.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD dwErr;
    HRASCONN hrasconn = NULL;

    TRACE("RemoveEntry");

    dwErr = LoadRasapi32Dll();
    if (dwErr != 0)
        return dwErr;

    //If this entry is currently connected, we wont delete it
    //for whislter bug 311846       gangz
    //
    hrasconn = HrasconnFromEntry( g_pszPhonebookPath, g_pszEntryName );
    if (hrasconn)
    {
        TRACE("RemoveEntry: Connection is Active, wont delete it");
        dwErr = ERROR_CAN_NOT_COMPLETE;
    }
    else
    {
        ASSERT(g_pRasDeleteEntry);
        TRACE("RasDeleteEntry");
        dwErr = g_pRasDeleteEntry( g_pszPhonebookPath, g_pszEntryName );
        TRACE1("RasDeleteEntry=%d",dwErr);
    }

    UnloadRasapi32Dll();

    return dwErr;
}


DWORD
Run(
    void )

    /* Execute the command line instructions.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD  dwErr;
    BOOL   fStatus;
    TCHAR* pszEntry;
    HINSTANCE hInstRasapi32 = NULL;

    TRACE("Run");

    if (g_mode == RM_HangUpEntry)
        return HangUpEntry();
    else if (g_mode == RM_RemoveEntry)
        return RemoveEntry();

    dwErr = LoadRasdlgDll();
    if (dwErr != 0)
        return dwErr;

    switch (g_mode)
    {
        case RM_DialEntry:
        {
            RASDIALDLG info;

            ZeroMemory( &info, sizeof(info) );
            info.dwSize = sizeof(info);
            pszEntry = g_pszEntryName;

            ASSERT(g_pRasDialDlg);
            TRACE("RasDialDlg");
            fStatus = g_pRasDialDlg(
                g_pszPhonebookPath, g_pszEntryName, NULL, &info );
            TRACE2("RasDialDlg=%d,e=%d",fStatus,info.dwError);

            dwErr = info.dwError;
            break;
        }

        case RM_None:
        {
            RASPBDLG info;
            DWORD    dwGupErr;
            PBUSER   user;

            ZeroMemory( &info, sizeof(info) );
            info.dwSize = sizeof(info);
            info.dwFlags = RASPBDFLAG_UpdateDefaults;

            dwGupErr = GetUserPreferences( NULL, &user, FALSE );
            if (dwGupErr == 0)
            {
                if (user.dwXPhonebook != 0x7FFFFFFF)
                {
                    info.dwFlags |= RASPBDFLAG_PositionDlg;
                    info.xDlg = user.dwXPhonebook;
                    info.yDlg = user.dwYPhonebook;
                }

                pszEntry = user.pszDefaultEntry;
            }
            else
                pszEntry = NULL;

            if (g_pszEntryName)
                pszEntry = g_pszEntryName;

            ASSERT(g_pRasPhonebookDlg);
            TRACE("RasPhonebookDlg...");
            fStatus = g_pRasPhonebookDlg( g_pszPhonebookPath, pszEntry, &info );
            TRACE2("RasPhonebookDlg=%d,e=%d",fStatus,info.dwError);

            if (dwGupErr == 0)
                DestroyUserPreferences( &user );

            dwErr = info.dwError;
            break;
        }

        case RM_AddEntry:
        case RM_EditEntry:
        case RM_CloneEntry:
        {
            RASENTRYDLG info;

            ZeroMemory( &info, sizeof(info) );
            info.dwSize = sizeof(info);

            if (g_mode == RM_AddEntry)
                info.dwFlags |= RASEDFLAG_NewEntry;
            else if (g_mode == RM_CloneEntry)
                info.dwFlags |= RASEDFLAG_CloneEntry;

            if (g_fNoRename)
                info.dwFlags |= RASEDFLAG_NoRename;

#if 0
            ASSERT(g_pRouterEntryDlg);
            TRACE("RouterEntryDlg");
            fStatus = g_pRouterEntryDlg(
                TEXT("stevec5"), TEXT("\\\\stevec5\\admin$\\system32\\ras\\router.pbk"), g_pszEntryName, &info );
            TRACE2("RouterEntryDlg=%f,e=%d",fStatus,info.dwError);
#else
            ASSERT(g_pRasEntryDlg);
            TRACE("RasEntryDlg");
            fStatus = g_pRasEntryDlg(
                g_pszPhonebookPath, g_pszEntryName, &info );
            TRACE2("RasEntryDlg=%f,e=%d",fStatus,info.dwError);
#endif

            dwErr = info.dwError;
            break;
        }

        default:
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    if(NULL != (hInstRasapi32 = GetModuleHandle(L"rasapi32.dll")))
    {
        FARPROC pRasUninitialize = GetProcAddress(hInstRasapi32,
                                                   "DwRasUninitialize");

        if(NULL != pRasUninitialize)
        {
            (void) pRasUninitialize();
        }    
    }

    UnloadRasdlgDll();

    TRACE1("Run=%d",dwErr);
    return dwErr;
}


DWORD
StringArgFollows(
    IN     UINT     argc,
    IN     CHAR**   argv,
    IN OUT UINT*    piCurArg,
    OUT    TCHAR**  ppszOut )

    /* Loads a copy of the next argument into callers '*ppszOut'.
    **
    ** Returns 0 if successful, or a non-0 error code.  If successful, it is
    ** caller's responsibility to Free the returned '*ppszOut'.
    */
{
    TCHAR* psz;

    if (++(*piCurArg) >= argc)
        return ERROR_INVALID_PARAMETER;

    psz = StrDupTFromAUsingAnsiEncoding( argv[ *piCurArg ] );
    if (!psz)
        return ERROR_NOT_ENOUGH_MEMORY;

    *ppszOut = psz;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\ast.h ===
//
// Copyright (c) Microsoft Corporation 1995
//
// ast.h
//
// Header file for the abstract syntax tree.
//
// History:
//  05-20-95 ScottH     Created
//

#ifndef __AST_H__
#define __AST_H__

typedef struct tagASTEXEC * PASTEXEC;


//
// AST 
//

typedef enum 
    {
    AT_BASE,
    
    AT_MODULE_DECL,
    AT_PROC_DECL,

    AT_ENTER_STMT,
    AT_LEAVE_STMT,    
    AT_ASSIGN_STMT,
    AT_HALT_STMT,
    AT_LABEL_STMT,
    AT_GOTO_STMT,
    AT_TRANSMIT_STMT,
    AT_WAITFOR_STMT,
    AT_DELAY_STMT,
    AT_SET_STMT,
    AT_WHILE_STMT,
    AT_IF_STMT,
    
    AT_INT_EXPR,
    AT_STRING_EXPR,
    AT_VAR_EXPR,
    AT_BOOL_EXPR,
    AT_UNOP_EXPR,
    AT_BINOP_EXPR,
    AT_GETIP_EXPR,
    } ASTTYPE;


// Basic AST 

typedef struct tagAST
    {
    DWORD   cbSize;
    ASTTYPE asttype;
    DWORD   iLine;
    } AST;                            // Basic AST
DECLARE_STANDARD_TYPES(AST);

#define Ast_GetSize(p)      (((PAST)(p))->cbSize)
#define Ast_GetType(p)      (((PAST)(p))->asttype)
#define Ast_GetLine(p)      (((PAST)(p))->iLine)

#define Ast_SetSize(p, s)   (((PAST)(p))->cbSize = (s))
#define Ast_SetType(p, t)   (((PAST)(p))->asttype = (t))
#define Ast_SetLine(p, v)   (((PAST)(p))->iLine = (v))

RES     PUBLIC Ast_New(LPVOID * ppv, ASTTYPE asttype, DWORD cbSize, DWORD iLine);
void    PUBLIC Ast_Delete(PAST this);
RES     PUBLIC Ast_Dup(PAST this, PAST * ppast);

#ifdef DEBUG
void    PUBLIC Ast_Dump(PAST this);
#else
#define Ast_Dump(past)    
#endif

// Decl

typedef struct tagDECL
    {
    AST     ast;
    PSYMTAB pst;        // symbol table
    } DECL;
DECLARE_STANDARD_TYPES(DECL);

RES     PUBLIC Decl_Delete(PDECL this);
void    CALLBACK Decl_DeletePAPtr(LPVOID pv, LPARAM lparam);

// Proc Declaration 

typedef struct tagPROCDECL
    {
    DECL    decl;
    LPSTR   pszIdent;
    HPA     hpaStmts;
    PSYMTAB pst;
    } PROCDECL;
DECLARE_STANDARD_TYPES(PROCDECL);

RES     PUBLIC ProcDecl_New(PDECL * ppdecl, LPCSTR pszIdent, HPA hpa, PSYMTAB pst, DWORD iLine);

#define ProcDecl_GetIdent(p)        (((PPROCDECL)(p))->pszIdent)
#define ProcDecl_GetSymtab(p)       (((PPROCDECL)(p))->pst)


// Module Declaration 

typedef struct tagMODULEDECL
    {
    DECL    decl;
    HPA     hpaProcs;
    PSYMTAB pst;
    } MODULEDECL;
DECLARE_STANDARD_TYPES(MODULEDECL);

RES     PUBLIC ModuleDecl_New(PDECL * ppdecl, HPA hpa, PSYMTAB pst, DWORD iLine);
RES     PUBLIC ModuleDecl_Parse(PMODULEDECL * ppmoduledecl, PSCANNER pscanner, PSYMTAB pst);
RES     PUBLIC ModuleDecl_Typecheck(PMODULEDECL this, HSA hsaStxerr);
RES     PUBLIC ModuleDecl_Codegen(PMODULEDECL this, PASTEXEC pastexec);

#define ModuleDecl_GetSymtab(p)     (((PMODULEDECL)(p))->pst)


// Expressions

typedef struct tagEXPR
    {
    AST     ast;
    DATATYPE dt;
    DWORD   dwFlags;        // EF_*
    EVALRES er;             // Used when evaluated at runtime
    } EXPR;
DECLARE_STANDARD_TYPES(EXPR);

// Expression flags
#define EF_DEFAULT      0x0000
#define EF_DONE         0X0001
#define EF_ALLOCATED    0x0002

RES     PUBLIC Expr_Eval(PEXPR this, PASTEXEC pastexec);
RES     PUBLIC Expr_Delete(PEXPR this);
void    CALLBACK Expr_DeletePAPtr(LPVOID pv, LPARAM lparam);

#define Expr_GetDataType(p)         (((PEXPR)(p))->dt)
#define Expr_GetRes(p)              (&((PEXPR)(p))->er)

#define Expr_SetDataType(p, x)      (((PEXPR)(p))->dt = (x))
#define Expr_SetDone(p)             SetFlag(((PEXPR)(p))->dwFlags, EF_DONE)
#define Expr_SetRes(p, x)           (Expr_SetDone(p),((PEXPR)(p))->er.dw = (ULONG_PTR)(x))


// Integer Expression

typedef struct tagINTEXPR
    {
    EXPR    expr;
    int     nVal;       // signed value by design
    } INTEXPR;
DECLARE_STANDARD_TYPES(INTEXPR);

RES     PUBLIC IntExpr_New(PEXPR * ppexpr, int nVal, DWORD iLine);

#define IntExpr_GetVal(p)           (((PINTEXPR)(p))->nVal)

#define IntExpr_SetVal(p, n)        (((PINTEXPR)(p))->nVal = (n))


// String Expression

typedef struct tagSTREXPR
    {
    EXPR    expr;
    LPSTR   psz;
    } STREXPR;
DECLARE_STANDARD_TYPES(STREXPR);

RES     PUBLIC StrExpr_New(PEXPR * ppexpr, LPCSTR psz, DWORD iLine);

#define StrExpr_GetStr(p)           (((PSTREXPR)(p))->psz)

#define StrExpr_SetStr(p, n)        (((PINTEXPR)(p))->nVal = (n))


// Bool Expression

typedef struct tagBOOLEXPR
    {
    EXPR    expr;
    BOOL    bVal;
    } BOOLEXPR;
DECLARE_STANDARD_TYPES(BOOLEXPR);

RES     PUBLIC BoolExpr_New(PEXPR * ppexpr, BOOL bVal, DWORD iLine);

#define BoolExpr_GetVal(p)          (((PBOOLEXPR)(p))->bVal)

#define BoolExpr_SetVal(p, b)       (((PBOOLEXPR)(p))->bVal = (b))


// Variable Expression

typedef struct tagVAREXPR
    {
    EXPR    expr;
    LPSTR   pszIdent;
    } VAREXPR;
DECLARE_STANDARD_TYPES(VAREXPR);

RES     PUBLIC VarExpr_New(PEXPR * ppexpr, LPCSTR pszIdent, DWORD iLine);

#define VarExpr_GetIdent(p)         (((PVAREXPR)(p))->pszIdent)


// Binary Operation Expression

typedef enum
    {
    // WARNING: These types must match the order of their 
    // corresponding SYM and OP values.

    BOT_OR,
    BOT_AND,

    BOT_LEQ,        
    BOT_LT,         
    BOT_GEQ,        
    BOT_GT,         
    BOT_NEQ,
    BOT_EQ,

    BOT_PLUS,
    BOT_MINUS,
    BOT_MULT,
    BOT_DIV,

    } BINOPTYPE;

typedef struct tagBINOPEXPR
    {
    EXPR    expr;
    BINOPTYPE binoptype;
    PEXPR   pexpr1;
    PEXPR   pexpr2;
    } BINOPEXPR;
DECLARE_STANDARD_TYPES(BINOPEXPR);

RES     PUBLIC BinOpExpr_New(PEXPR * ppexpr, BINOPTYPE binoptype, PEXPR pexpr1, PEXPR pexpr2, DWORD iLine);

#define BinOpExpr_GetType(p)        (((PBINOPEXPR)(p))->binoptype)
#define BinOpExpr_GetExpr1(p)       (((PBINOPEXPR)(p))->pexpr1)
#define BinOpExpr_GetExpr2(p)       (((PBINOPEXPR)(p))->pexpr2)

#define BinOpExpr_SetType(p, t)     (((PBINOPEXPR)(p))->binoptype = (t))
#define BinOpExpr_SetRes(p, x)      (((PBINOPEXPR)(p))->er.dw = (DWORD)(x))


// Unary Operation Expression

typedef enum
    {
    UOT_NEG,
    UOT_NOT,
    UOT_GETIP,
    } UNOPTYPE;

typedef struct tagUNOPEXPR
    {
    EXPR    expr;
    UNOPTYPE unoptype;
    PEXPR   pexpr;
    EVALRES er;         // Used for UOT_GETIP on strings
    } UNOPEXPR;
DECLARE_STANDARD_TYPES(UNOPEXPR);

RES     PUBLIC UnOpExpr_New(PEXPR * ppexpr, UNOPTYPE unoptype, PEXPR pexpr, DWORD iLine);

#define UnOpExpr_GetType(p)         (((PUNOPEXPR)(p))->unoptype)
#define UnOpExpr_GetExpr(p)         (((PUNOPEXPR)(p))->pexpr)

#define UnOpExpr_SetType(p, t)      (((PUNOPEXPR)(p))->unoptype = (t))
#define UnOpExpr_SetRes(p, x)       (((PUNOPEXPR)(p))->er.dw = (DWORD)(x))


// Statements

typedef struct tagSTMT
    {
    AST     ast;
    } STMT;
DECLARE_STANDARD_TYPES(STMT);

RES     PUBLIC Stmt_Delete(PSTMT this);
void    CALLBACK Stmt_DeletePAPtr(LPVOID pv, LPARAM lparam);

RES     PUBLIC Stmt_Exec(PSTMT this, PASTEXEC pastexec);


// Enter Statement

typedef struct tagENTERSTMT
    {
    STMT    stmt;
    PSYMTAB pst;
    } ENTERSTMT;
DECLARE_STANDARD_TYPES(ENTERSTMT);

RES     PUBLIC EnterStmt_New(PSTMT * ppstmt, PSYMTAB pst, DWORD iLine);

#define EnterStmt_GetSymtab(p)      (((PENTERSTMT)(p))->pst)


// Leave Statement

typedef struct tagLEAVESTMT
    {
    STMT    stmt;
    } LEAVESTMT;
DECLARE_STANDARD_TYPES(LEAVESTMT);

RES     PUBLIC LeaveStmt_New(PSTMT * ppstmt, DWORD iLine);


// Halt Statement

typedef struct tagHALTSTMT
    {
    STMT    stmt;
    } HALTSTMT;
DECLARE_STANDARD_TYPES(HALTSTMT);

RES     PUBLIC HaltStmt_New(PSTMT * ppstmt, DWORD iLine);


// Assignment Statement

typedef struct tagASSIGNSTMT
    {
    STMT    stmt;
    LPSTR   pszIdent;
    PEXPR   pexpr;
    } ASSIGNSTMT;
DECLARE_STANDARD_TYPES(ASSIGNSTMT);

RES     PUBLIC AssignStmt_New(PSTMT * ppstmt, LPCSTR pszIdent, PEXPR pexpr, DWORD iLine);

#define AssignStmt_GetIdent(p)          (((PASSIGNSTMT)(p))->pszIdent)
#define AssignStmt_GetExpr(p)           (((PASSIGNSTMT)(p))->pexpr)


// While Statement

typedef struct tagWHILESTMT
    {
    STMT    stmt;
    PEXPR   pexpr;
    HPA     hpaStmts;
    char    szTopLabel[MAX_BUF_KEYWORD];
    char    szEndLabel[MAX_BUF_KEYWORD];
    } WHILESTMT;
DECLARE_STANDARD_TYPES(WHILESTMT);

RES     PUBLIC WhileStmt_New(PSTMT * ppstmt, PEXPR pexpr, HPA hpaStmts, LPCSTR pszTopLabel, LPCSTR pszEndLabel, DWORD iLine);

#define WhileStmt_GetExpr(p)            (((PWHILESTMT)(p))->pexpr)
#define WhileStmt_GetStmtBlock(p)       (((PWHILESTMT)(p))->hpaStmts)
#define WhileStmt_GetTopLabel(p)        (((PWHILESTMT)(p))->szTopLabel)
#define WhileStmt_GetEndLabel(p)        (((PWHILESTMT)(p))->szEndLabel)

// If Statement

typedef struct tagIFSTMT
    {
    STMT    stmt;
    PEXPR   pexpr;
    HPA     hpaStmts;
    char    szElseLabel[MAX_BUF_KEYWORD];
    char    szEndLabel[MAX_BUF_KEYWORD];
    } IFSTMT;
DECLARE_STANDARD_TYPES(IFSTMT);

RES     PUBLIC IfStmt_New(PSTMT * ppstmt, PEXPR pexpr, HPA hpaStmts, LPCSTR pszElseLabel, LPCSTR pszEndLabel, DWORD iLine);

#define IfStmt_GetExpr(p)               (((PIFSTMT)(p))->pexpr)
#define IfStmt_GetStmtBlock(p)          (((PIFSTMT)(p))->hpaStmts)
#define IfStmt_GetElseLabel(p)          (((PIFSTMT)(p))->szElseLabel)
#define IfStmt_GetEndLabel(p)           (((PIFSTMT)(p))->szEndLabel)

// Label Statement

typedef struct tagLABELSTMT
    {
    STMT    stmt;
    LPSTR   psz;
    } LABELSTMT;
DECLARE_STANDARD_TYPES(LABELSTMT);

RES     PUBLIC LabelStmt_New(PSTMT * ppstmt, LPCSTR psz, DWORD iLine);

#define LabelStmt_GetIdent(p)       (((PLABELSTMT)(p))->psz)


// Goto Statement

typedef struct tagGOTOSTMT
    {
    STMT    stmt;
    LPSTR   psz;
    } GOTOSTMT;
DECLARE_STANDARD_TYPES(GOTOSTMT);

RES     PUBLIC GotoStmt_New(PSTMT * ppstmt, LPCSTR psz, DWORD iLine);

#define GotoStmt_GetIdent(p)        (((PGOTOSTMT)(p))->psz)


// Delay Statement

typedef struct tagDELAYSTMT
    {
    STMT    stmt;
    PEXPR   pexprSecs;
    } DELAYSTMT;
DECLARE_STANDARD_TYPES(DELAYSTMT);

RES     PUBLIC DelayStmt_New(PSTMT * ppstmt, PEXPR pexprSecs, DWORD iLine);

#define DelayStmt_GetExpr(p)        (((PDELAYSTMT)(p))->pexprSecs)


// WaitFor Statement

typedef struct tagWAITCASE
    {
    PEXPR   pexpr;
    LPSTR   pszIdent;           // label to jump to; may be NULL
    DWORD   dwFlags;            // WCF_*
    } WAITCASE;
DECLARE_STANDARD_TYPES(WAITCASE);

// Flags for WaitforStmt
#define WCF_DEFAULT     0x0000
#define WCF_MATCHCASE   0x0001

RES     PUBLIC Waitcase_Create(PHSA phsa);
RES     PUBLIC Waitcase_Add(HSA hsa, PEXPR pexpr, LPCSTR pszIdent, DWORD dwFlags);
RES     PUBLIC Waitcase_Destroy(HSA hsa);

typedef struct tagWAITFORSTMT
    {
    STMT    stmt;
    HSA     hsa;                // List of strings to wait for
    PEXPR   pexprUntil;         // Optional; may be NULL
    } WAITFORSTMT;
DECLARE_STANDARD_TYPES(WAITFORSTMT);

RES     PUBLIC WaitforStmt_New(PSTMT * ppstmt, HSA hsa, PEXPR pexprUntil, DWORD iLine);

#define WaitforStmt_GetCaseList(p)  (((PWAITFORSTMT)(p))->hsa)
#define WaitforStmt_GetUntilExpr(p) (((PWAITFORSTMT)(p))->pexprUntil)


// Transmit Statement

typedef struct tagTRANSMITSTMT
    {
    STMT    stmt;
    PEXPR   pexpr;
    DWORD   dwFlags;        // TSF_*
    } TRANSMITSTMT;
DECLARE_STANDARD_TYPES(TRANSMITSTMT);

// Flags for TransmitStmt
#define TSF_DEFAULT     0x0000
#define TSF_RAW         0x0001

RES     PUBLIC TransmitStmt_New(PSTMT * ppstmt, PEXPR pexpr, DWORD dwFlags, DWORD iLine);

#define TransmitStmt_GetExpr(p)     (((PTRANSMITSTMT)(p))->pexpr)
#define TransmitStmt_GetFlags(p)    (((PTRANSMITSTMT)(p))->dwFlags)


// Set Statement

typedef enum
    {
    ST_IPADDR,
    ST_PORT,
    ST_SCREEN,
    } SETTYPE;

typedef struct tagSETSTMT
    {
    STMT    stmt;
    SETTYPE settype;
    } SETSTMT;
DECLARE_STANDARD_TYPES(SETSTMT);

#define SetStmt_GetType(p)          (((PSETSTMT)(p))->settype)

#define SetStmt_SetType(p, t)       (((PSETSTMT)(p))->settype = (t))


// Set IP Statement

typedef struct tagSETIPSTMT
    {
    SETSTMT setstmt;
    PEXPR   pexpr;
    } SETIPSTMT;
DECLARE_STANDARD_TYPES(SETIPSTMT);

RES     PUBLIC SetIPStmt_New(PSTMT * ppstmt, PEXPR pexpr, DWORD iLine);

#define SetIPStmt_GetExpr(p)        (((PSETIPSTMT)(p))->pexpr)


// Set Port Statement

typedef struct tagPORTSTATE
    {
    DWORD   dwFlags;        // SPF_*
    BYTE    nDatabits;
    BYTE    nParity;        // 0-4: none, odd, even, mark, space
    BYTE    nStopbits;      // 0,1,2: 1 bit, 1.5 bits, 2 bits
    } PORTSTATE;
DECLARE_STANDARD_TYPES(PORTSTATE);

// Flags for PortState
#define SPF_DATABITS    0x0001
#define SPF_PARITY      0x0002
#define SPF_STOPBITS    0x0004

typedef struct tagSETPORTSTMT
    {
    SETSTMT setstmt;
    PORTSTATE portstate;
    } SETPORTSTMT;
DECLARE_STANDARD_TYPES(SETPORTSTMT);

RES     PUBLIC SetPortStmt_New(PSTMT * ppstmt, PPORTSTATE pstate, DWORD iLine);

#define SetPortStmt_GetFlags(p)     (((PSETPORTSTMT)(p))->portstate.dwFlags)
#define SetPortStmt_GetDatabits(p)  (((PSETPORTSTMT)(p))->portstate.nDatabits)
#define SetPortStmt_GetStopbits(p)  (((PSETPORTSTMT)(p))->portstate.nStopbits)
#define SetPortStmt_GetParity(p)    (((PSETPORTSTMT)(p))->portstate.nParity)


// Set Screen Statement

typedef struct tagSCREENSET
    {
    DWORD   dwFlags;        // SPF_*
    BOOL    fKBOn;          // TRUE/FALSE: on, off
    } SCREENSET;
DECLARE_STANDARD_TYPES(SCREENSET);

// Flags for Screen settings
#define SPF_KEYBRD      0x0001

typedef struct tagSETSCREENSTMT
    {
    SETSTMT setstmt;
    SCREENSET screenset;
    } SETSCREENSTMT;
DECLARE_STANDARD_TYPES(SETSCREENSTMT);

RES     PUBLIC SetScreenStmt_New(PSTMT * ppstmt, PSCREENSET pstate, DWORD iLine);

#define SetScreenStmt_GetFlags(p)   (((PSETSCREENSTMT)(p))->screenset.dwFlags)
#define SetScreenStmt_GetKeybrd(p)  (((PSETSCREENSTMT)(p))->screenset.fKBOn)



//
// AST execute block
//

#define MAX_BUF_IP  (3+1+3+1+3+1+3 + 1)

typedef struct tagASTEXEC
    {
    DWORD   dwFlags;
    HWND    hwnd;

    HANDLE  hport;
    PSESS_CONFIGURATION_INFO psci;
    HANDLE  hFindFmt;
    PSYMTAB pstSystem;      // Allocated: system symbol table

    HPA     hpaPcode;
    DWORD   ipaCur;         // current statement executing
    PSYMTAB pstCur;         // symbol table for current frame
    PSTMT   pstmtPending;   // pending statement 
    int     cProcDepth;     // call depth

    HSA     hsaStxerr;

    char    szIP[MAX_BUF_IP];
    int     nIter;          // scratch iterative value
    } ASTEXEC;
DECLARE_STANDARD_TYPES(ASTEXEC);

RES     PUBLIC Astexec_Init(PASTEXEC this, HANDLE hport, PSESS_CONFIGURATION_INFO psci, HSA hsaStxerr);
RES     PUBLIC Astexec_Destroy(PASTEXEC this);
RES     PUBLIC Astexec_Add(PASTEXEC this, PSTMT pstmt);
RES     PUBLIC Astexec_InsertLabel(PASTEXEC this, LPCSTR pszIdent, PSYMTAB pst);
RES     PUBLIC Astexec_JumpToLabel(PASTEXEC this, LPCSTR pszIdent);
void    PUBLIC Astexec_SetError(PASTEXEC this, BOOL bSuccess, BOOL bFailure);

RES     PUBLIC Astexec_Next(PASTEXEC this);
DWORD   PUBLIC Astexec_GetCurLine(PASTEXEC this);
void    PUBLIC Astexec_SendString(PASTEXEC this, LPCSTR pszSend, BOOL bRaw);
RES     PUBLIC Astexec_SetIPAddr(PASTEXEC this, LPCSTR psz);
RES     PUBLIC Astexec_FindFormat(PASTEXEC this, LPDWORD piFound);
RES     PUBLIC Astexec_DestroyFindFormat(PASTEXEC this);

// Flags for Astexec
#define AEF_DONE            0x0001
#define AEF_PAUSED          0x0002
#define AEF_HALT            0x0004
#define AEF_WAITUNTIL       0x0010
#define AEF_STOPWAITING     0x0020

#define Astexec_IsDone(this)            IsFlagSet((this)->dwFlags, AEF_DONE)
#define Astexec_IsReadPending(this)     (NULL != (this)->pstmtPending)
#define Astexec_IsPaused(this)          IsFlagSet((this)->dwFlags, AEF_PAUSED)
#define Astexec_IsHalted(this)          IsFlagSet((this)->dwFlags, AEF_HALT)
#define Astexec_IsWaitUntil(this)       IsFlagSet((this)->dwFlags, AEF_WAITUNTIL)

#define Astexec_GetIPAddr(this)         ((this)->szIP)
#define Astexec_GetPending(this)        ((this)->pstmtPending)

#define Astexec_ClearPause(this)        ClearFlag((this)->dwFlags, AEF_PAUSED)
#define Astexec_ClearWaitUntil(this)    ClearFlag((this)->dwFlags, AEF_WAITUNTIL)
#define Astexec_SetStopWaiting(this)    SetFlag((this)->dwFlags, AEF_STOPWAITING)

#define Astexec_SetIP(this, ipa)        ((this)->ipaCur = (ipa))
#define Astexec_SetHwnd(this, hwndT)    ((this)->hwnd = hwndT)
#define Astexec_SetPending(this, pstmt) ((this)->pstmtPending = (pstmt))

#endif // __AST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\codegen.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// codegen.c
//
// This file contains the code-generating functions.
//
// The "code" is actually just an intermediate representation.
// Currently this is an array of ASTs.
//
// History:
//  06-18-95 ScottH     Created
//


#include "proj.h"
#include "rcids.h"

RES     PRIVATE Stmt_Codegen(PSTMT this, PASTEXEC pastexec, PSYMTAB pst);


/*----------------------------------------------------------
Purpose: Generate code for the 'while' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE WhileStmt_Codegen(
    PSTMT this,
    PASTEXEC pastexec,
    PSYMTAB pst)
    {
    RES res;
    LPSTR pszTop;
    LPSTR pszEnd;

    ASSERT(this);
    ASSERT(pastexec);
    ASSERT(AT_WHILE_STMT == Ast_GetType(this));

    pszTop = WhileStmt_GetTopLabel(this);
    pszEnd = WhileStmt_GetEndLabel(this);

    res = Astexec_InsertLabel(pastexec, pszTop, pst);
    if (RSUCCEEDED(res))
        {
        // add the 'while' statement for the test expression
        res = Astexec_Add(pastexec, this);
        if (RSUCCEEDED(res))
            {
            // add the statements in the statement block
            DWORD i;
            DWORD cstmts;
            HPA hpaStmts = WhileStmt_GetStmtBlock(this);

            res = RES_OK;

            cstmts = PAGetCount(hpaStmts);

            // Add each statement
            for (i = 0; i < cstmts; i++)
                {
                PSTMT pstmt = PAFastGetPtr(hpaStmts, i);

                res = Stmt_Codegen(pstmt, pastexec, pst);
                if (RFAILED(res))
                    break;
                }

            if (RSUCCEEDED(res))
                {
                // add the end label
                res = Astexec_InsertLabel(pastexec, pszEnd, pst);
                }
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Generate code for the 'if' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE IfStmt_Codegen(
    PSTMT this,
    PASTEXEC pastexec,
    PSYMTAB pst)
    {
    RES res;
    LPSTR pszElse;
    LPSTR pszEnd;

    ASSERT(this);
    ASSERT(pastexec);
    ASSERT(AT_IF_STMT == Ast_GetType(this));

    pszElse = IfStmt_GetElseLabel(this);
    pszEnd = IfStmt_GetEndLabel(this);

    // add the 'if' statement for the test expression
    res = Astexec_Add(pastexec, this);
    if (RSUCCEEDED(res))
        {
        // add the statements in the 'then' statement block
        DWORD i;
        DWORD cstmts;
        HPA hpaStmts = IfStmt_GetStmtBlock(this);

        res = RES_OK;

        cstmts = PAGetCount(hpaStmts);

        // Add each statement
        for (i = 0; i < cstmts; i++)
            {
            PSTMT pstmt = PAFastGetPtr(hpaStmts, i);

            res = Stmt_Codegen(pstmt, pastexec, pst);
            if (RFAILED(res))
                break;
            }

        if (RSUCCEEDED(res))
            {
            // add the else label
            res = Astexec_InsertLabel(pastexec, pszElse, pst);
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Generate code for the label statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE LabelStmt_Codegen(
    PSTMT this,
    PASTEXEC pastexec,
    PSYMTAB pst)
    {
    LPSTR pszIdent;

    ASSERT(this);
    ASSERT(pastexec);
    ASSERT(AT_LABEL_STMT == Ast_GetType(this));

    pszIdent = LabelStmt_GetIdent(this);

    return Astexec_InsertLabel(pastexec, pszIdent, pst);
    }


/*----------------------------------------------------------
Purpose: Generate code for the 'set' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE SetStmt_Codegen(
    PSTMT this,
    PASTEXEC pastexec,
    PSYMTAB pst)
    {
    RES res = RES_OK;

    ASSERT(this);
    ASSERT(pastexec);
    ASSERT(AT_SET_STMT == Ast_GetType(this));

    switch (SetStmt_GetType(this))
        {
    case ST_IPADDR:
    case ST_PORT:
    case ST_SCREEN:
        res = Astexec_Add(pastexec, this);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Generate code for a statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE Stmt_Codegen(
    PSTMT this,
    PASTEXEC pastexec,
    PSYMTAB pst)
    {
    RES res;

    ASSERT(this);
    ASSERT(pastexec);

    switch (Ast_GetType(this))
        {
    case AT_ENTER_STMT:
    case AT_LEAVE_STMT:
    case AT_HALT_STMT:
    case AT_TRANSMIT_STMT:
    case AT_WAITFOR_STMT:
    case AT_DELAY_STMT:
    case AT_GOTO_STMT:
    case AT_ASSIGN_STMT:
        res = Astexec_Add(pastexec, this);
        break;

    case AT_WHILE_STMT:
        res = WhileStmt_Codegen(this, pastexec, pst);
        break;

    case AT_IF_STMT:
        res = IfStmt_Codegen(this, pastexec, pst);
        break;

    case AT_SET_STMT:
        res = SetStmt_Codegen(this, pastexec, pst);
        break;

    case AT_LABEL_STMT:
        res = LabelStmt_Codegen(this, pastexec, pst);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Generate code for a procedure declaration.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE ProcDecl_Codegen(
    PPROCDECL this,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    DWORD i;
    DWORD cstmts;

    ASSERT(this);
    ASSERT(pastexec);

    cstmts = PAGetCount(this->hpaStmts);

    // Generate for each statement
    for (i = 0; i < cstmts; i++)
        {
        PSTMT pstmt = PAFastGetPtr(this->hpaStmts, i);

        res = Stmt_Codegen(pstmt, pastexec, this->pst);
        if (RFAILED(res))
            break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Find the proc decl that has the given identifier.

Returns: TRUE (if found)

Cond:    --
*/
BOOL PRIVATE FindProc(
    PMODULEDECL pmd,
    LPCSTR pszIdent,
    PPROCDECL * ppprocdecl)
    {
    DWORD i;
    DWORD cprocs = PAGetCount(pmd->hpaProcs);

    *ppprocdecl = NULL;

    for (i = 0; i < cprocs; i++)
        {
        PPROCDECL pprocdecl = PAFastGetPtr(pmd->hpaProcs, i);

        if (IsSzEqualC(ProcDecl_GetIdent(pprocdecl), pszIdent))
            {
            *ppprocdecl = pprocdecl;
            break;
            }
        }

    return NULL != *ppprocdecl;
    }


/*----------------------------------------------------------
Purpose: Generate code for the module declaration.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PUBLIC ModuleDecl_Codegen(
    PMODULEDECL this,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    DWORD i;
    DWORD cprocs;
    PPROCDECL ppdMain;

    ASSERT(this);
    ASSERT(pastexec);

    TRACE_MSG(TF_GENERAL, "Generating code...");

    cprocs = PAGetCount(this->hpaProcs);

    // Generate code for the main proc first.
    if (FindProc(this, "main", &ppdMain))
        {
        res = ProcDecl_Codegen(ppdMain, pastexec);
        if (RSUCCEEDED(res))
            {
            // Generate code for the rest of the procs
            for (i = 0; i < cprocs; i++)
                {
                PPROCDECL pprocdecl = PAFastGetPtr(this->hpaProcs, i);

                if (pprocdecl != ppdMain)
                    {
                    res = ProcDecl_Codegen(pprocdecl, pastexec);
                    if (RFAILED(res))
                        break;
                    }
                }
            }
        }
    else
        {
        // Typechecking should have guaranteed that the main
        // proc was here
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\eval.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// eval.c
//
// This file contains the evaluation functions for the
// abstract syntax tree.
//
// History:
//  06-15-95 ScottH     Created
//

#include "proj.h"
#include "rcids.h"
#include "debug.h"

#define MSECS_FROM_SECS(s)  ((s)*1000)
#define RAS_DUMMY_PASSWORD "****************"

//
// Clean expressions
//


/*----------------------------------------------------------
Purpose: Clean expressions.

Returns: --
Cond:    --
*/
void PRIVATE Expr_Clean(
    PEXPR this)
    {
    ASSERT(this);

    switch (Ast_GetType(this))
        {
    case AT_INT_EXPR:
    case AT_BOOL_EXPR:
    case AT_STRING_EXPR:
    case AT_VAR_EXPR:
        ClearFlag(this->dwFlags, EF_DONE);
        break;

    case AT_UNOP_EXPR:
        ClearFlag(this->dwFlags, EF_DONE);
        Expr_Clean(UnOpExpr_GetExpr(this));
        break;

    case AT_BINOP_EXPR:
        ClearFlag(this->dwFlags, EF_DONE);
        Expr_Clean(BinOpExpr_GetExpr1(this));
        Expr_Clean(BinOpExpr_GetExpr2(this));
        break;

    default:
        ASSERT(0);
        break;
        }
    }


/*----------------------------------------------------------
Purpose: Clean the expressions in the 'waitfor' statement.

Returns: --
Cond:    --
*/
void PRIVATE WaitforStmt_Clean(
    PSTMT this)
    {
    PEXPR pexpr;
    HSA hsa = WaitforStmt_GetCaseList(this);
    DWORD ccase = SAGetCount(hsa);
    DWORD i;

    pexpr = WaitforStmt_GetUntilExpr(this);
    if (pexpr)
        Expr_Clean(pexpr);

    for (i = 0; i < ccase; i++)
        {
        PWAITCASE pwc;

        SAGetItemPtr(hsa, i, &pwc);
        ASSERT(pwc);

        Expr_Clean(pwc->pexpr);
        }
    }


/*----------------------------------------------------------
Purpose: Clean the expressions in the statement

Returns: --
Cond:    --
*/
void PRIVATE Stmt_Clean(
    PSTMT this)
    {
    PEXPR pexpr;

    ASSERT(this);

    switch (Ast_GetType(this))
        {
    case AT_ENTER_STMT:
    case AT_LEAVE_STMT:
    case AT_HALT_STMT:
    case AT_LABEL_STMT:
    case AT_GOTO_STMT:
        break;

    case AT_WHILE_STMT:
        pexpr = WhileStmt_GetExpr(this);
        Expr_Clean(pexpr);
        break;

    case AT_IF_STMT:
        pexpr = IfStmt_GetExpr(this);
        Expr_Clean(pexpr);
        break;

    case AT_ASSIGN_STMT:
        pexpr = AssignStmt_GetExpr(this);
        Expr_Clean(pexpr);
        break;

    case AT_TRANSMIT_STMT:
        pexpr = TransmitStmt_GetExpr(this);
        Expr_Clean(pexpr);
        break;

    case AT_WAITFOR_STMT:
        WaitforStmt_Clean(this);
        break;

    case AT_DELAY_STMT:
        pexpr = DelayStmt_GetExpr(this);
        Expr_Clean(pexpr);
        break;

    case AT_SET_STMT:
        switch (SetStmt_GetType(this))
            {
        case ST_IPADDR:
            pexpr = SetIPStmt_GetExpr(this);
            Expr_Clean(pexpr);
            break;

        case ST_PORT:
        case ST_SCREEN:
            break;

        default:
            ASSERT(0);
            break;
            }
        break;

    default:
        ASSERT(0);
        break;
        }
    }


//
// Evaluate expressions
//


/*----------------------------------------------------------
Purpose: Evaluates the expression and returns an integer.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE IntExpr_Eval(
    PEXPR this)
    {
    ASSERT(this);
    ASSERT(AT_INT_EXPR == Ast_GetType(this));
    ASSERT(DATA_INT == Expr_GetDataType(this));

    Expr_SetRes(this, IntExpr_GetVal(this));

    return RES_OK;
    }


/*----------------------------------------------------------
Purpose: Evaluates the expression and returns a string.

         The returned string should not be freed.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE StrExpr_Eval(
    PEXPR this)
    {
    ASSERT(this);
    ASSERT(AT_STRING_EXPR == Ast_GetType(this));
    ASSERT(DATA_STRING == Expr_GetDataType(this));

    Expr_SetRes(this, (ULONG_PTR) StrExpr_GetStr(this));

    return RES_OK;
    }


/*----------------------------------------------------------
Purpose: Evaluates the expression and returns a boolean

Returns: RES_OK

Cond:    --
*/
RES PRIVATE BoolExpr_Eval(
    PEXPR this)
    {
    ASSERT(this);
    ASSERT(AT_BOOL_EXPR == Ast_GetType(this));
    ASSERT(DATA_BOOL == Expr_GetDataType(this));

    Expr_SetRes(this, BoolExpr_GetVal(this));

    return RES_OK;
    }


/*----------------------------------------------------------
Purpose: Returns the value of the variable.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE VarExpr_Eval(
    PEXPR this,
    PASTEXEC pastexec)
    {
    RES res;
    PSTE pste;
    LPSTR pszIdent;

    ASSERT(this);
    ASSERT(AT_VAR_EXPR == Ast_GetType(this));

    pszIdent = VarExpr_GetIdent(this);
    if (RES_OK == Symtab_FindEntry(pastexec->pstCur, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        EVALRES er;

        STE_GetValue(pste, &er);
        Expr_SetRes(this, er.dw);
        res = RES_OK;
        }
    else
        {
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Evaluates the expression..

         The returned string should not be freed.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE BinOpExpr_Eval(
    PEXPR this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr1;
    PEXPR pexpr2;

    ASSERT(this);
    ASSERT(AT_BINOP_EXPR == Ast_GetType(this));

    pexpr1 = BinOpExpr_GetExpr1(this);
    res = Expr_Eval(pexpr1, pastexec);
    if (RES_OK == res)
        {
        pexpr2 = BinOpExpr_GetExpr2(this);
        res = Expr_Eval(pexpr2, pastexec);
        if (RES_OK == res)
            {
            PEVALRES per1 = Expr_GetRes(pexpr1);
            PEVALRES per2 = Expr_GetRes(pexpr2);
            DATATYPE dt = Expr_GetDataType(pexpr1);

            // Data types must be the same.  This was checked
            // during the typechecking phase.
            ASSERT(Expr_GetDataType(pexpr1) == Expr_GetDataType(pexpr2));

            switch (BinOpExpr_GetType(this))
                {
            case BOT_OR:
                ASSERT(DATA_BOOL == dt);

                Expr_SetRes(this, per1->bVal || per2->bVal);
                break;

            case BOT_AND:
                ASSERT(DATA_BOOL == dt);

                Expr_SetRes(this, per1->bVal && per2->bVal);
                break;

            case BOT_LEQ:
                ASSERT(DATA_INT == dt);

                Expr_SetRes(this, per1->nVal <= per2->nVal);
                break;

            case BOT_LT:
                ASSERT(DATA_INT == dt);

                Expr_SetRes(this, per1->nVal < per2->nVal);
                break;

            case BOT_GEQ:
                ASSERT(DATA_INT == dt);

                Expr_SetRes(this, per1->nVal >= per2->nVal);
                break;

            case BOT_GT:
                ASSERT(DATA_INT == dt);

                Expr_SetRes(this, per1->nVal > per2->nVal);
                break;

            case BOT_NEQ:
                switch (dt)
                    {
                case DATA_INT:
                    Expr_SetRes(this, per1->nVal != per2->nVal);
                    break;

                case DATA_STRING:
                    Expr_SetRes(this, !IsSzEqualC(per1->psz, per2->psz));
                    break;

                case DATA_BOOL:
                    Expr_SetRes(this, per1->bVal != per2->bVal);
                    break;

                default:
                    ASSERT(0);
                    break;
                    }
                break;

            case BOT_EQ:
                switch (dt)
                    {
                case DATA_INT:
                    Expr_SetRes(this, per1->nVal == per2->nVal);
                    break;

                case DATA_STRING:
                    Expr_SetRes(this, IsSzEqualC(per1->psz, per2->psz));
                    break;

                case DATA_BOOL:
                    Expr_SetRes(this, per1->bVal == per2->bVal);
                    break;

                default:
                    ASSERT(0);
                    break;
                    }
                break;

            case BOT_PLUS:
                switch (dt)
                    {
                case DATA_INT:
                    // Add two integers
                    Expr_SetRes(this, per1->nVal + per2->nVal);
                    break;

                case DATA_STRING: {
                    LPSTR psz = NULL;

                    // Concatenate strings
                    if ( !GSetString(&psz, per1->psz) ||
                         !GCatString(&psz, per2->psz))
                        {
                        // Free whatever was allocated
                        GSetString(&psz, NULL);

                        res = Stxerr_Add(pastexec->hsaStxerr, NULL, Ast_GetLine(this), RES_E_OUTOFMEMORY);
                        }

                    Expr_SetRes(this, (ULONG_PTR) psz);
                    SetFlag(this->dwFlags, EF_ALLOCATED);
                    }
                    break;

                default:
                    ASSERT(0);
                    break;
                    }
                break;

            case BOT_MINUS:
                ASSERT(DATA_INT == dt);

                Expr_SetRes(this, per1->nVal - per2->nVal);
                break;

            case BOT_MULT:
                ASSERT(DATA_INT == dt);
                
                Expr_SetRes(this, per1->nVal * per2->nVal);
                break;

            case BOT_DIV:
                ASSERT(DATA_INT == dt);
            
                if (0 == per2->nVal)    
                    res = Stxerr_Add(pastexec->hsaStxerr, NULL, Ast_GetLine(this), RES_E_DIVBYZERO);
                else
                    Expr_SetRes(this, per1->nVal / per2->nVal);
                break;

            default:
                ASSERT(0);
                res = RES_E_INVALIDPARAM;
                break;
                }
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Evaluate 'getip'.

Returns: RES_OK
         RES_FALSE (if the IP address was not read yet)

Cond:    --
*/
RES PRIVATE GetIPExpr_Eval(
    PEXPR this,
    PASTEXEC pastexec,
    int nIter)
    {
    RES res;
    DWORD iDummy;

    ASSERT(this);
    ASSERT(pastexec);
    ASSERT(0 < nIter);

    TRACE_MSG(TF_ASTEXEC, "Exec: getip %d", nIter);

    // Is this function getting re-called due to a pending read?
    if ( !Astexec_IsReadPending(pastexec) )
        {
        // No; prepare to extract the nth IP address
        ClearFlag(this->dwFlags, EF_DONE);

        ASSERT(NULL == pastexec->hFindFmt);

        res = CreateFindFormat(&pastexec->hFindFmt);
        if (RSUCCEEDED(res))
            {
            res = AddFindFormat(pastexec->hFindFmt, "%u.%u.%u.%u", FFF_DEFAULT,
                               pastexec->szIP, sizeof(pastexec->szIP));
            if (RSUCCEEDED(res))
                {
                // Extract the nth IP address.
                pastexec->nIter = nIter;
                ASSERT(0 < pastexec->nIter);
                }
            }
        }

    if(NULL != pastexec->hFindFmt)
        {
        res = Astexec_FindFormat(pastexec, &iDummy);
        if (RES_OK == res)
            {
            // Allocate or resize the pointer we already have
            LPSTR psz = Expr_GetRes(this)->psz;

            if ( !GSetString(&psz, Astexec_GetIPAddr(pastexec)) )
                res = Stxerr_Add(pastexec->hsaStxerr, NULL, 
                        Ast_GetLine(this), RES_E_OUTOFMEMORY);
            else
                {
                Expr_SetRes(this, (ULONG_PTR) psz);
                SetFlag(this->dwFlags, EF_ALLOCATED);
                }
            }
        }        
    else
        {
        res = RES_E_FAIL;
        }
    
    return res;
    }    


/*----------------------------------------------------------
Purpose: Evaluates the expression and returns an integer.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE UnOpExpr_Eval(
    PEXPR this,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    PEVALRES per;
    PEXPR pexpr;
    DATATYPE dt;

    ASSERT(this);
    ASSERT(AT_UNOP_EXPR == Ast_GetType(this));

    pexpr = UnOpExpr_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        per = Expr_GetRes(pexpr);
        dt = Expr_GetDataType(pexpr);

        switch (UnOpExpr_GetType(this))
            {
        case UOT_NEG:
            ASSERT(DATA_INT == dt);

            Expr_SetRes(this, -per->nVal);
            break;

        case UOT_NOT:
            ASSERT(DATA_BOOL == dt);

            Expr_SetRes(this, !per->bVal);
            break;

        case UOT_GETIP:
            ASSERT(DATA_INT == dt);

            if (0 < per->nVal)
                res = GetIPExpr_Eval(this, pastexec, per->nVal);
            else
                res = Stxerr_Add(pastexec->hsaStxerr, "'getip' parameter", Ast_GetLine(pexpr), RES_E_INVALIDRANGE);
            break;

        default:
            ASSERT(0);
            break;
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Evaluates the expression and returns a value.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Expr_Eval(
    PEXPR this,
    PASTEXEC pastexec)
    {
    RES res;

    ASSERT(this);
    ASSERT(pastexec);

    // Has this expression already been evaluated?
    if (IsFlagSet(this->dwFlags, EF_DONE))
        {
        // Yes; just return
        res = RES_OK;
        }
    else
        {
        // No; evaluate it
        switch (Ast_GetType(this))
            {
        case AT_INT_EXPR:
            res = IntExpr_Eval(this);
            break;

        case AT_BOOL_EXPR:
            res = BoolExpr_Eval(this);
            break;

        case AT_STRING_EXPR:
            res = StrExpr_Eval(this);
            break;

        case AT_VAR_EXPR:
            res = VarExpr_Eval(this, pastexec);
            break;

        case AT_UNOP_EXPR:
            res = UnOpExpr_Eval(this, pastexec);
            break;

        case AT_BINOP_EXPR:
            res = BinOpExpr_Eval(this, pastexec);
            break;

        default:
            ASSERT(0);
            res = RES_E_INVALIDPARAM;
            break;
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the prolog

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE EnterStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    ASSERT(this);
    ASSERT(pastexec);

    TRACE_MSG(TF_ASTEXEC, "Exec: enter");

    pastexec->cProcDepth++;
    pastexec->pstCur = EnterStmt_GetSymtab(this);
    ASSERT(pastexec->pstCur);

    return RES_OK;
    }


/*----------------------------------------------------------
Purpose: Execute the epilog

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE LeaveStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;

    ASSERT(this);
    ASSERT(pastexec);

    TRACE_MSG(TF_ASTEXEC, "Exec: leave");

    ASSERT(0 < pastexec->cProcDepth);
    pastexec->cProcDepth--;
    
    pastexec->pstCur = Symtab_GetNext(pastexec->pstCur);
    ASSERT(pastexec->pstCur);

    // Leaving main procedure?
    if (0 == pastexec->cProcDepth)
        {
        // Yes
        SetFlag(pastexec->dwFlags, AEF_DONE);
        res = RES_HALT;
        }
    else
        res = RES_OK;
        
    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the assignment statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE AssignStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    LPSTR pszIdent;
    PSTE pste;

    ASSERT(this);
    ASSERT(pastexec);

    pszIdent = AssignStmt_GetIdent(this);
    if (RES_OK == Symtab_FindEntry(pastexec->pstCur, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        PEXPR pexpr;

        pexpr = AssignStmt_GetExpr(this);
        res = Expr_Eval(pexpr, pastexec);
        if (RES_OK == res)
            {
            PEVALRES per = Expr_GetRes(pexpr);
            DEBUG_CODE( DATATYPE dt; )

#ifdef DEBUG
            dt = Expr_GetDataType(pexpr);
            switch (dt)
                {
            case DATA_STRING:
                TRACE_MSG(TF_ASTEXEC, "Exec: %s = \"%s\"", pszIdent, per->psz);
                break;

            case DATA_INT:
                TRACE_MSG(TF_ASTEXEC, "Exec: %s = %d", pszIdent, per->nVal);
                break;

            case DATA_BOOL:
                TRACE_MSG(TF_ASTEXEC, "Exec: %s = %s", pszIdent, per->bVal ? (LPSTR)"TRUE" : (LPSTR)"FALSE");
                break;

            default:
                ASSERT(0);
                break;
                }
#endif

            pste->er.dw = per->dw;
            }
        }
    else
        {
        // The identifier should have been in the symbol table!
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'while' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE WhileStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(pastexec);

    pexpr = WhileStmt_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        PEVALRES per = Expr_GetRes(pexpr);

        if (!per->bVal)
            {
            res = Astexec_JumpToLabel(pastexec, WhileStmt_GetEndLabel(this));
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'if' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE IfStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(pastexec);

    pexpr = IfStmt_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        PEVALRES per = Expr_GetRes(pexpr);

        if (!per->bVal)
            {
            res = Astexec_JumpToLabel(pastexec, IfStmt_GetElseLabel(this));
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'halt' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE HaltStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    ASSERT(this);
    ASSERT(pastexec);

    TRACE_MSG(TF_ASTEXEC, "Exec: halt");

    SetFlag(pastexec->dwFlags, AEF_HALT);
    return RES_HALT;
    }


/*----------------------------------------------------------
Purpose: Execute the 'goto' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE GotoStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    LPSTR pszIdent;

    ASSERT(this);
    ASSERT(pastexec);

    pszIdent = GotoStmt_GetIdent(this);

    TRACE_MSG(TF_ASTEXEC, "Exec: goto %s", pszIdent);

    return Astexec_JumpToLabel(pastexec, pszIdent);
    }


/*----------------------------------------------------------
Purpose: Execute the 'transmit' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE TransmitStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(pastexec);

    pexpr = TransmitStmt_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        PEVALRES per = Expr_GetRes(pexpr);
        DWORD dwFlags = TransmitStmt_GetFlags(this);
        CHAR *pszPassword;

        TRACE_MSG(TF_ASTEXEC, "Exec: transmit \"%s\"", per->psz);

#ifdef WINNT_RAS        
        //
        // JEFFSI WHISTLER
        //
        // RASSCRPT_TRACE1("Exec: transmit \"%s\"", per->psz);

        if (pszPassword = strstr(per->psz, RAS_DUMMY_PASSWORD))
            {
            CHAR *psz;
            CHAR controlchar = '\0';

            #define IS_CARET(ch)            ('^' == (ch))

            if(per->psz != pszPassword)
            {
                CHAR *pszT, *pszPrefix = LocalAlloc(LPTR, strlen(per->psz));
                if(NULL == pszPrefix)
                {
                    res = E_OUTOFMEMORY;
                    return res;
                }

                psz = per->psz;
                pszT = pszPrefix;
                while(psz != pszPassword)
                {
                    *pszT++ = *psz++;
                }

                Astexec_SendString(pastexec, pszPrefix, 
                        IsFlagSet(dwFlags, TSF_RAW));

                RASSCRPT_TRACE1("Exec: transmi \"%s\"", pszPrefix);

                LocalFree(pszPrefix);
            }
            
            //
            // Check to see if we need to send a control char
            // at the end.
            //
            psz = pszPassword + lstrlen(RAS_DUMMY_PASSWORD);

            if(IS_CARET(*psz))
            {
                psz++;
                if(!*psz)
                {
                ;
                }
                if (InRange(*psz, '@', '_'))
                    {
                    controlchar = *psz - '@';
                    }
                else if (InRange(*psz, 'a', 'z'))
                    {
                    controlchar = *psz - 'a' + 1;
                    }
            }
            
            (VOID) RxSendCreds(((SCRIPTDATA*)pastexec->hwnd)->hscript,
                               controlchar);
            }
        else
            {
            Astexec_SendString(pastexec, per->psz, IsFlagSet(dwFlags, TSF_RAW));
            }
#else
            Astexec_SendString(pastexec, per->psz, IsFlagSet(dwFlags, TSF_RAW));
#endif
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Evaluates each of the wait-case expressions.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE WaitforStmt_EvalCaseList(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res = RES_E_FAIL;
    HSA hsa = WaitforStmt_GetCaseList(this);
    DWORD i;
    DWORD ccase = SAGetCount(hsa);
    PWAITCASE pwc;

    ASSERT(0 < ccase);

    for (i = 0; i < ccase; i++)
        {
        SAGetItemPtr(hsa, i, &pwc);
        ASSERT(pwc);

        res = Expr_Eval(pwc->pexpr, pastexec);
        if (RES_OK != res)
            break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Packages each of the evaluated wait-case expressions
         into an array of strings to search for.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE WaitforStmt_WrapEmUp(
    PSTMT this,
    HANDLE hFindFmt)
    {
    RES res = RES_OK;
    HSA hsa = WaitforStmt_GetCaseList(this);
    DWORD i;
    DWORD ccase = SAGetCount(hsa);
    PWAITCASE pwc;
    PEVALRES per;

    ASSERT(0 < ccase);

    for (i = 0; i < ccase; i++)
        {
        DWORD dwFlags = FFF_DEFAULT;

        SAGetItemPtr(hsa, i, &pwc);
        ASSERT(pwc);

        if (IsFlagSet(pwc->dwFlags, WCF_MATCHCASE))
            SetFlag(dwFlags, FFF_MATCHCASE);

        per = Expr_GetRes(pwc->pexpr);
        res = AddFindFormat(hFindFmt, per->psz, dwFlags, NULL, 0);
        if (RFAILED(res))
            break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the then clause based upon the given case 
         index.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE WaitforStmt_ExecThen(
    PSTMT this,
    DWORD isa,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    HSA hsa = WaitforStmt_GetCaseList(this);
    PWAITCASE pwc;

    if (SAGetItemPtr(hsa, isa, &pwc))
        {
        ASSERT(pwc);

        // If there is a label, jump to it
        if (pwc->pszIdent)
            res = Astexec_JumpToLabel(pastexec, pwc->pszIdent);
        }
    else
        {
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'waitfor' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE WaitforStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    PEXPR pexpr;
    int nTimeoutSecs = -1;

    ASSERT(this);
    ASSERT(pastexec);

    // First evaluate the optional 'until' time
    pexpr = WaitforStmt_GetUntilExpr(this);
    if (pexpr)
        {
        res = Expr_Eval(pexpr, pastexec);
        if (RES_OK == res)
            {
            PEVALRES per = Expr_GetRes(pexpr);
            nTimeoutSecs = per->nVal;
            if (0 >= nTimeoutSecs)
                res = Stxerr_Add(pastexec->hsaStxerr, "'until' parameter", Ast_GetLine(this), RES_E_INVALIDRANGE);
            }
        }

    if (RES_OK == res)
        {
        // Evaluate the waitfor string
        res = WaitforStmt_EvalCaseList(this, pastexec);
        if (RES_OK == res)
            {
            if (-1 == nTimeoutSecs)
                TRACE_MSG(TF_ASTEXEC, "Exec: waitfor ...");
            else
                TRACE_MSG(TF_ASTEXEC, "Exec: waitfor ... until %d", nTimeoutSecs);

            // Is this function getting re-called due to a pending read?
            if ( !Astexec_IsReadPending(pastexec) )
                {
                // No; prepare to wait for the string(s)
                ASSERT(NULL == pastexec->hFindFmt);

                res = CreateFindFormat(&pastexec->hFindFmt);
                if (RSUCCEEDED(res))
                    {
                    res = WaitforStmt_WrapEmUp(this, pastexec->hFindFmt);
                    if (RSUCCEEDED(res))
                        {
                        ASSERT(IsFlagClear(pastexec->dwFlags, AEF_WAITUNTIL));
                        ASSERT(IsFlagClear(pastexec->dwFlags, AEF_STOPWAITING));
                        ASSERT(IsFlagClear(pastexec->dwFlags, AEF_PAUSED));

                        pastexec->nIter = 1;

                        if (-1 != nTimeoutSecs)
                            {
#ifndef WINNT_RAS
//
// On NT, timeouts are handled by setting dwTimeout in the SCRIPTDATA struct
// for the current script.
//

                            if (0 != SetTimer(pastexec->hwnd, TIMER_DELAY, MSECS_FROM_SECS(nTimeoutSecs), NULL))

#else // WINNT_RAS

                            ((SCRIPTDATA *)pastexec->hwnd)->dwTimeout = MSECS_FROM_SECS(nTimeoutSecs);

#endif // WINNT_RAS
                                {
                                SetFlag(pastexec->dwFlags, AEF_WAITUNTIL);
                                }
#ifndef WINNT_RAS                                
                            else
                                {
                                res = Stxerr_Add(pastexec->hsaStxerr, "waitfor", Ast_GetLine(this), RES_E_FAIL);
                                }
#endif                                
                            }
                        }
                    }
                }

            // Have we timed out yet?
            if (IsFlagSet(pastexec->dwFlags, AEF_STOPWAITING))
                {
                // Yes; don't wait for string anymore
                ClearFlag(pastexec->dwFlags, AEF_STOPWAITING);

                Astexec_SetError(pastexec, FALSE, FALSE);

                res = Astexec_DestroyFindFormat(pastexec);
                }
            else
                {
                // No; did we find a matching string?
                DWORD isa = 0;

                res = Astexec_FindFormat(pastexec, &isa);
                if (RES_OK == res)
                    {
                    // Yes; determine the next action
                    ClearFlag(pastexec->dwFlags, AEF_WAITUNTIL);

                    Astexec_SetError(pastexec, TRUE, FALSE);

                    res = WaitforStmt_ExecThen(this, isa, pastexec);
                    }
                }
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'delay' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE DelayStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(pastexec);

    pexpr = DelayStmt_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        PEVALRES per = Expr_GetRes(pexpr);

        if (0 >= per->nVal)
            res = Stxerr_Add(pastexec->hsaStxerr, "'delay' parameter", Ast_GetLine(this), RES_E_INVALIDRANGE);
        else
            {
            TRACE_MSG(TF_ASTEXEC, "Exec: delay %ld", per->nVal);

#ifndef WINNT_RAS
//
// On NT, timeouts are handled by setting dwTimeout in the SCRIPTDATA struct
// for the current script.
//

            if (0 != SetTimer(pastexec->hwnd, TIMER_DELAY, MSECS_FROM_SECS(per->nVal), NULL))

#else // WINNT_RAS

            ((SCRIPTDATA *)pastexec->hwnd)->dwTimeout = MSECS_FROM_SECS(per->nVal);

#endif // WINNT_RAS
                {
                // Success
                SetFlag(pastexec->dwFlags, AEF_PAUSED);
                }
#ifndef WINNT_RAS                
            else
                res = Stxerr_Add(pastexec->hsaStxerr, "delay", Ast_GetLine(this), RES_E_FAIL);
#endif                
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'set ipaddr' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE IPAddrData_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(pastexec);

    pexpr = SetIPStmt_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        PEVALRES per = Expr_GetRes(pexpr);

        ASSERT(per->psz);

        TRACE_MSG(TF_ASTEXEC, "Exec: set ipaddr \"%s\"", per->psz);

        Astexec_SetIPAddr(pastexec, per->psz);
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'set port' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE PortData_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    DCB dcb;
    DWORD dwFlags = SetPortStmt_GetFlags(this);

    ASSERT(this);
    ASSERT(pastexec);

#ifdef DEBUG

    if (IsFlagSet(dwFlags, SPF_DATABITS))
        TRACE_MSG(TF_ASTEXEC, "Exec: set port databits %u", SetPortStmt_GetDatabits(this));

    if (IsFlagSet(dwFlags, SPF_STOPBITS))
        TRACE_MSG(TF_ASTEXEC, "Exec: set port stopbits %u", SetPortStmt_GetStopbits(this));

    if (IsFlagSet(dwFlags, SPF_PARITY))
        TRACE_MSG(TF_ASTEXEC, "Exec: set port parity %u", SetPortStmt_GetParity(this));

#endif


#ifndef WINNT_RAS
//
// On NT, changes to port settings are done through the RasPortSetInfo API.
//

    if (GetCommState(pastexec->hport, &dcb))
        {
        if (IsFlagSet(dwFlags, SPF_DATABITS))
            dcb.ByteSize = SetPortStmt_GetDatabits(this);

        if (IsFlagSet(dwFlags, SPF_STOPBITS))
            dcb.StopBits = SetPortStmt_GetStopbits(this);

        if (IsFlagSet(dwFlags, SPF_PARITY))
            dcb.Parity = SetPortStmt_GetParity(this);

        if (!SetCommState(pastexec->hport, &dcb))
            res = Stxerr_Add(pastexec->hsaStxerr, "set port", Ast_GetLine(this), RES_E_FAIL);
        }
    else
        res = Stxerr_Add(pastexec->hsaStxerr, "set port", Ast_GetLine(this), RES_E_FAIL);

#else // WINNT_RAS

    res = (RES)RxSetPortData(
                ((SCRIPTDATA*)pastexec->hwnd)->hscript, this
                );

#endif // WINNT_RAS

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'set screen' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE Screen_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    DWORD dwFlags = SetScreenStmt_GetFlags(this);

    ASSERT(this);
    ASSERT(pastexec);

#ifdef DEBUG

    if (IsFlagSet(dwFlags, SPF_KEYBRD))
        TRACE_MSG(TF_ASTEXEC, "Exec: set screen keyboard %s", SetScreenStmt_GetKeybrd(this) ? "on" : "off");

#endif

    if (IsFlagSet(dwFlags, SPF_KEYBRD))
        {
#ifndef WINNT_RAS
//
// On NT, we change the keyboard state by calling RxSetKeyboard
// which will signal an event-code telling whoever started this script
// that the keyboard should be disabled.
//

        TerminalSetInput(pastexec->hwnd, SetScreenStmt_GetKeybrd(this));

#else // !WINNT_RAS

        RxSetKeyboard(
            ((SCRIPTDATA*)pastexec->hwnd)->hscript,
            SetScreenStmt_GetKeybrd(this)
            );

#endif // !WINNT_RAS
        res = RES_OK;
        }
    else
        {
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'set' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE SetStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;

    ASSERT(this);
    ASSERT(pastexec);

    switch (SetStmt_GetType(this))
        {
    case ST_IPADDR:
        res = IPAddrData_Exec(this, pastexec);
        break;

    case ST_PORT:
        res = PortData_Exec(this, pastexec);
        break;

    case ST_SCREEN:
        res = Screen_Exec(this, pastexec);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute a statement.  This function should not be
         called to execute a pending statement or expression.
         Ast_ExecPending should be used for that purpose.

         statements are executed--expressions are evaluated
         by the statement execs.

         The one exception is when an expression is being
         evaluated and it must wait for pending events 
         (such as more data from the port).  In this case it
         is put on the pending queue and re-executed here.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PUBLIC Stmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;

    ASSERT(this);
    ASSERT(pastexec);

    switch (Ast_GetType(this))
        {
    case AT_ENTER_STMT:
        res = EnterStmt_Exec(this, pastexec);
        break;
        
    case AT_LEAVE_STMT:
        res = LeaveStmt_Exec(this, pastexec);
        break;

    case AT_WHILE_STMT:
        res = WhileStmt_Exec(this, pastexec);
        break;

    case AT_IF_STMT:
        res = IfStmt_Exec(this, pastexec);
        break;

    case AT_ASSIGN_STMT:
        res = AssignStmt_Exec(this, pastexec);
        break;

    case AT_HALT_STMT:
        res = HaltStmt_Exec(this, pastexec);
        break;

    case AT_TRANSMIT_STMT:
        res = TransmitStmt_Exec(this, pastexec);
        break;

    case AT_WAITFOR_STMT:
        res = WaitforStmt_Exec(this, pastexec);
        break;

    case AT_DELAY_STMT:
        res = DelayStmt_Exec(this, pastexec);
        break;

    case AT_LABEL_STMT:
        ASSERT(0);          // shouldn't really get here
        res = RES_E_FAIL;
        break;

    case AT_GOTO_STMT:
        res = GotoStmt_Exec(this, pastexec);
        break;

    case AT_SET_STMT:
        res = SetStmt_Exec(this, pastexec);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    // Was the statement completed?
    if (RES_OK == res)
        {
        // Yes; mark all the expressions in the statement as "not done"
        // so they will be evaluated from scratch if this statement
        // is executed again.
        Stmt_Clean(this);
        }

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\ipaddr.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//      MODULE:         ipaddr.c
//
//      PURPOSE:        IP address handler
//
//	PLATFORMS:	Windows 95
//
//      FUNCTIONS:
//              CheckAddress()
//              ParseIPAddress()
//              ConvertIPAddress()
//              AssignIPAddress()
//
//	SPECIAL INSTRUCTIONS: N/A
//

#include "proj.h"    // includes common header files and global declarations
#include <rnap.h>

#define MAXNUMBER       80
#define MAX_IP_FIELDS   4
#define MIN_FIELD1	1	// min allowed value for field 1
#define MAX_FIELD1	223	// max allowed value for field 1
#define MIN_FIELD2	0	// min for field 2
#define MAX_FIELD2	255	// max for field 2
#define MIN_FIELD3	0	// min for field 3
#define MAX_FIELD3	254	// max for field 3
#define MIN_FIELD4      1       // 0 is reserved for broadcast
#define MIN_IP_VALUE    0       /* default minimum allowable field value */
#define MAX_IP_VALUE    255     /* default maximum allowable field value */

typedef struct tagIPaddr {
    DWORD cField;
    BYTE  bIP[MAX_IP_FIELDS];
} IPADDR, *PIPADDR;

static int atoi (LPCSTR szBuf)
{
  int   iRet = 0;

  // Find the first nonspace
  //
  while ((*szBuf == ' ') || (*szBuf == '\t'))
    szBuf++;

  while ((*szBuf >= '0') && (*szBuf <= '9'))
  {
    iRet = (iRet*10)+(int)(*szBuf-'0');
    szBuf++;
  };
  return iRet;
}

//
//
//   FUNCTION: CheckAddress (DWORD)
//
//   PURPOSE: Check an address to see if its valid.
//
//   RETURN: The first field that has an invalid value,
//           or (WORD)-1 if the address is okay.
//

DWORD CheckAddress(DWORD ip)
{
    BYTE b;

    b = HIBYTE(HIWORD(ip));
    if (b < MIN_FIELD1 || b > MAX_FIELD1 || b == 127)    return 0;
    b = LOBYTE(LOWORD(ip));
    if (b > MAX_FIELD3)    return 3;
    return (DWORD)-1;
}

//
//
//   FUNCTION: ParseIPAddress (PIPADDR, LPCSTR)
//
//   PURPOSE: parse the IP address string
//

DWORD NEAR PASCAL ParseIPAddress (PIPADDR pIPAddr, LPCSTR szIPAddress)
{
  LPCSTR szNextIP, szNext;
  char  szNumber[MAXNUMBER+1];
  int   cField, cb, iValue;

  szNext = szNextIP = szIPAddress;
  cField = 0;
  while ((*szNext) && (cField < MAX_IP_FIELDS))
  {
    // Check address separator
    //
    if (*szNext == '.')
    {
      // We have a new number
      //
      cb = (DWORD)(szNext-szNextIP);
      if ((cb > 0) && (cb <= MAXNUMBER))
      {
        lstrcpyn(szNumber, szNextIP, cb+1);
        iValue = atoi(szNumber);
        if ((iValue >= MIN_IP_VALUE) && (iValue <= MAX_IP_VALUE))
        {
          pIPAddr->bIP[cField] = (UCHAR)iValue;
          cField++;
        };
      };
      szNextIP = szNext+1;
    };
    szNext++;
  };

  // Get the last number
  //
  if (cField < MAX_IP_FIELDS)
  {
    cb = (int) (szNext-szNextIP);
    if ((cb > 0) && (cb <= MAXNUMBER))
    {
      lstrcpyn(szNumber, szNextIP, cb+1);
      iValue = atoi(szNumber);
      if ((iValue >= MIN_IP_VALUE) && (iValue <= MAX_IP_VALUE))
      {
        pIPAddr->bIP[cField] = (UCHAR) iValue;
        cField++;
      };
    };
  }
  else
  {
    // Not a valid IP address
    //
    return ERROR_INVALID_ADDRESS;
  };

  pIPAddr->cField = cField;
  return ERROR_SUCCESS;
}

//
//
//   FUNCTION: ConvertIPAddress (LPDWORD, LPCSTR)
//
//   PURPOSE: convert the IP address string to a number
//

DWORD NEAR PASCAL ConvertIPAddress (LPDWORD lpdwAddr, LPCSTR szIPAddress)
{
  IPADDR ipAddr;
  DWORD  dwIPAddr;
  DWORD  dwRet;
  DWORD  i;

  // Parse the IP address string
  //
  if ((dwRet = ParseIPAddress(&ipAddr, szIPAddress)) == ERROR_SUCCESS)
  {
    // Validate the number fields
    //
    if (ipAddr.cField == MAX_IP_FIELDS)
    {
      // Conver the IP address into one number
      //
      dwIPAddr = 0;
      for (i = 0; i < ipAddr.cField; i++)
      {
        dwIPAddr = (dwIPAddr << 8) + ipAddr.bIP[i];
      };

      // Validate the address
      //
      if (CheckAddress(dwIPAddr) > MAX_IP_FIELDS)
      {
        *lpdwAddr = dwIPAddr;
        dwRet = ERROR_SUCCESS;
      }
      else
      {
        dwRet = ERROR_INVALID_ADDRESS;
      };
    }
    else
    {
      dwRet = ERROR_INVALID_ADDRESS;
    };
  };

  return dwRet;
}

//
//
//   FUNCTION: AssignIPAddress (LPCSTR, LPCSTR)
//
//   PURPOSE: assign an IP address to the connection
//

DWORD NEAR PASCAL AssignIPAddress (LPCSTR szEntryName, LPCSTR szIPAddress)
{
  IPDATA    ipData;
  DWORD     dwIPAddr;
  DWORD     dwRet;

  // Validate and convert IP address string into a number
  //
  if ((dwRet = ConvertIPAddress(&dwIPAddr, szIPAddress))
       == ERROR_SUCCESS)
  {
    // Get the current IP settings for the connection
    //
    ipData.dwSize = sizeof(ipData);

#ifndef WINNT_RAS
//
// WINNT_RAS: the functions RnaGetIPInfo and RnaSetIPInfo don't exist on NT
//

    if ((dwRet = RnaGetIPInfo((LPSTR)szEntryName, &ipData, FALSE)) == ERROR_SUCCESS)
    {
      // We want to specify the IP address
      //
      ipData.fdwTCPIP |= IPF_IP_SPECIFIED;

      // Set the IP address
      //
      ipData.dwIPAddr = dwIPAddr;

      // Set the IP settings for the connection
      //
      dwRet = RnaSetIPInfo((LPSTR)szEntryName, &ipData);
    };
#endif // WINNT_RAS
  };

  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\common.c ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// common.c
//
// This files contains common utility and helper functions.
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//  04-26-95 ScottH     Transferred and expanded from Briefcase code
//


#include "proj.h"
#include "common.h"


#ifdef NORTL

// Some of these are replacements for the C runtime routines.
//  This is so we don't have to link to the CRT libs.
//

/*----------------------------------------------------------
Purpose: memset

         Swiped from the C 7.0 runtime sources.

Returns: 
Cond:    
*/
LPSTR PUBLIC lmemset(
    LPSTR dst,
    char val,
    UINT count)
    {
    LPSTR start = dst;
    
    while (count--)
        *dst++ = val;
    return(start);
    }


/*----------------------------------------------------------
Purpose: memmove

         Swiped from the C 7.0 runtime sources.

Returns: 
Cond:    
*/
LPSTR PUBLIC lmemmove(
    LPSTR dst, 
    LPCSTR src, 
    int count)
    {
    LPSTR ret = dst;
    
    if (dst <= src || dst >= (src + count)) {
        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        while (count--)
            *dst++ = *src++;
        }
    else {
        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        dst += count - 1;
        src += count - 1;
        
        while (count--)
            *dst-- = *src--;
        }
    
    return(ret);
    }


#endif // NORTL


#ifndef NOSTRING
// WARNING: all of these APIs do not setup DS, so you can not access
// any data in the default data seg of this DLL.
//
// do not create any global variables... talk to chrisg if you don't
// understand this

#define FASTCALL _fastcall


/*----------------------------------------------------------
Purpose: Case sensitive character comparison for DBCS

Returns: FALSE if they match, TRUE if no match
Cond:    --
*/
BOOL PRIVATE ChrCmp(
    WORD w1, 
    WORD wMatch)
    {
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
        {
        if (IsDBCSLeadByte(LOBYTE(w1)))
            {
            return(w1 != wMatch);
            }
        return FALSE;
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Case insensitive character comparison for DBCS

Returns: FALSE if match, TRUE if not
Cond:    --
*/
BOOL PRIVATE ChrCmpI(
    WORD w1, 
    WORD wMatch)
    {
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
        {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
        }
    else
        sz1[1] = '\0';

    *(WORD FAR *)sz2 = wMatch;
    sz2[2] = '\0';
    return lstrcmpi(sz1, sz2);
    }


/*----------------------------------------------------------
Purpose: strnicmp

         Swiped from the C 7.0 runtime sources.

Returns: 
Cond:    
*/
int PUBLIC lstrnicmp(
    LPCSTR psz1,
    LPCSTR psz2,
    UINT count)
    {
    int ch1;
    int ch2;
    int result = 0;
    LPCSTR pszTmp;
    
    if (count) 
        {
        do      
            {
            pszTmp = CharLower((LPSTR)LongToPtr(MAKELONG(*psz1, 0)));
            ch1 = *pszTmp;
            pszTmp = CharLower((LPSTR)LongToPtr(MAKELONG(*psz2, 0)));
            ch2 = *pszTmp;
            psz1 = AnsiNext(psz1);
            psz2 = AnsiNext(psz2);
            } while (--count && ch1 && ch2 && !ChrCmp((WORD)ch1, (WORD)ch2));
        result = ch1 - ch2;
        }
    return(result);
    }


/*----------------------------------------------------------
Purpose: My verion of atoi.  Supports hexadecimal too.
Returns: integer
Cond:    --
*/
int PUBLIC AnsiToInt(
    LPCSTR pszString)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = AnsiNext(psz))
        ;
      
    // Determine possible explicit signage
    //  
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz = AnsiNext(psz);
        }

    // Or is this hexadecimal?
    //
    pszAdj = AnsiNext(psz);
    if (*psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        bNeg = FALSE;   // Never allow negative sign with hexadecimal numbers
        psz = AnsiNext(pszAdj);

        // Do the conversion
        //
        for (n = 0; ; psz = AnsiNext(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                char ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }
        }
    else
        {
        for (n = 0; IS_DIGIT(*psz); psz = AnsiNext(psz))
            n = 10 * n + *psz - '0';
        }

    return bNeg ? -n : n;
    }    


/*----------------------------------------------------------
Purpose: Find first occurrence of character in string

Returns: Pointer to the first occurrence of ch in 
Cond:    --
*/
LPSTR PUBLIC AnsiChr(
    LPCSTR psz, 
    WORD wMatch)
    {
    for ( ; *psz; psz = AnsiNext(psz))
        {
        if (!ChrCmp(*(WORD FAR *)psz, wMatch))
            return (LPSTR)psz;
        }
    return NULL;
    }

#endif // NOSTRING


#ifndef NODIALOGHELPER

/*----------------------------------------------------------
Purpose: General front end to invoke dialog boxes
Returns: result from EndDialog
Cond:    --
*/
int PUBLIC DoModal(
    HWND hwndParent,            // owner of dialog
    DLGPROC lpfnDlgProc,        // dialog proc
    UINT uID,                   // dialog template ID
    LPARAM lParam)              // extra parm to pass to dialog (may be NULL)
    {
    int nResult = -1;

    nResult = DialogBoxParam(g_hinst, MAKEINTRESOURCE(uID), hwndParent,
        lpfnDlgProc, lParam);

    return nResult;
    }


/*----------------------------------------------------------
Purpose: Sets the rectangle with the bounding extent of the given string.
Returns: Rectangle
Cond:    --
*/
void PUBLIC SetRectFromExtent(
    HDC hdc,
    LPRECT lprect,
    LPCSTR lpcsz)
    {
    SIZE size;

    GetTextExtentPoint(hdc, lpcsz, lstrlen(lpcsz), &size);
    SetRect(lprect, 0, 0, size.cx, size.cy);
    }

#endif // NODIALOGHELPER


#ifndef NODRAWTEXT

#pragma data_seg(DATASEG_READONLY)

char const FAR c_szEllipses[] = "...";

#pragma data_seg()

// Global variables
int g_cxLabelMargin = 0;
int g_cxBorder = 0;
int g_cyBorder = 0;

COLORREF g_clrHighlightText = 0;
COLORREF g_clrHighlight = 0;
COLORREF g_clrWindowText = 0;
COLORREF g_clrWindow = 0;

HBRUSH g_hbrHighlight = 0;
HBRUSH g_hbrWindow = 0;


/*----------------------------------------------------------
Purpose: Get the system metrics we need
Returns: --
Cond:    --
*/
void PUBLIC GetCommonMetrics(
    WPARAM wParam)      // wParam from WM_WININICHANGE
    {
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
        {
        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);

        g_cxLabelMargin = (g_cxBorder * 2);
        }
    }


/*----------------------------------------------------------
Purpose: Sees whether the entire string will fit in *prc.
         If not, compute the numbder of chars that will fit
         (including ellipses).  Returns length of string in
         *pcchDraw.

         Taken from COMMCTRL.

Returns: TRUE if the string needed ellipses
Cond:    --
*/
BOOL PRIVATE NeedsEllipses(
    HDC hdc, 
    LPCSTR pszText, 
    RECT * prc, 
    int * pcchDraw, 
    int cxEllipses)
    {
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;

    cxRect = prc->right - prc->left;

    cchText = lstrlen(pszText);

    if (cchText == 0)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    GetTextExtentPoint(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
        {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
            {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPoint(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
                {
                ichMin = ichMid;
                cxRect -= siz.cx;
                }
            else if (siz.cx > cxRect)
                {
                ichMax = ichMid - 1;
                }
            else
                {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
                }
            }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
        }

    *pcchDraw = ichMax;
    return TRUE;
    }


#define CCHELLIPSES     3
#define DT_LVWRAP       (DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)

/*----------------------------------------------------------
Purpose: Draws text the shell's way.  

         Taken from COMMCTRL.

Returns: --

Cond:    This function requires TRANSPARENT background mode
         and a properly selected font.
*/
void PUBLIC MyDrawText(
    HDC hdc, 
    LPCSTR pszText, 
    RECT FAR* prc, 
    UINT flags, 
    int cyChar, 
    int cxEllipses, 
    COLORREF clrText, 
    COLORREF clrTextBk)
    {
    int cchText;
    COLORREF clrSave;
    COLORREF clrSaveBk;
    UINT uETOFlags = 0;
    RECT rc;
    char ach[MAX_PATH + CCHELLIPSES];

    // REVIEW: Performance idea:
    // We could cache the currently selected text color
    // so we don't have to set and restore it each time
    // when the color is the same.
    //
    if (!pszText)
        return;

    rc = *prc;

    // If needed, add in a little extra margin...
    //
    if (IsFlagSet(flags, MDT_EXTRAMARGIN))
        {
        rc.left  += g_cxLabelMargin * 3;
        rc.right -= g_cxLabelMargin * 3;
        }
    else
        {
        rc.left  += g_cxLabelMargin;
        rc.right -= g_cxLabelMargin;
        }

    if (IsFlagSet(flags, MDT_ELLIPSES) &&
        NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
        {
        hmemcpy(ach, pszText, cchText);
        lstrcpy(ach + cchText, c_szEllipses);

        pszText = ach;

        // Left-justify, in case there's no room for all of ellipses
        //
        ClearFlag(flags, (MDT_RIGHT | MDT_CENTER));
        SetFlag(flags, MDT_LEFT);

        cchText += CCHELLIPSES;
        }
    else
        {
        cchText = lstrlen(pszText);
        }

    if (IsFlagSet(flags, MDT_TRANSPARENT))
        {
        clrSave = SetTextColor(hdc, 0x000000);
        }
    else
        {
        uETOFlags |= ETO_OPAQUE;

        if (IsFlagSet(flags, MDT_SELECTED))
            {
            clrSave = SetTextColor(hdc, g_clrHighlightText);
            clrSaveBk = SetBkColor(hdc, g_clrHighlight);

            if (IsFlagSet(flags, MDT_DRAWTEXT))
                {
                FillRect(hdc, prc, g_hbrHighlight);
                }
            }
        else 
            {
            if (clrText == CLR_DEFAULT && clrTextBk == CLR_DEFAULT)
                {
                clrSave = SetTextColor(hdc, g_clrWindowText);
                clrSaveBk = SetBkColor(hdc, g_clrWindow);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    FillRect(hdc, prc, g_hbrWindow);
                    }
                }
            else
                {
                HBRUSH hbr;

                if (clrText == CLR_DEFAULT)
                    clrText = g_clrWindowText;

                if (clrTextBk == CLR_DEFAULT)
                    clrTextBk = g_clrWindow;

                clrSave = SetTextColor(hdc, clrText);
                clrSaveBk = SetBkColor(hdc, clrTextBk);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    hbr = CreateSolidBrush(GetNearestColor(hdc, clrTextBk));
                    if (hbr)
                        {
                        FillRect(hdc, prc, hbr);
                        DeleteObject(hbr);
                        }
                    else
                        FillRect(hdc, prc, GetStockObject(WHITE_BRUSH));
                    }
                }
            }
        }

    // If we want the item to display as if it was depressed, we will
    // offset the text rectangle down and to the left
    if (IsFlagSet(flags, MDT_DEPRESSED))
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    if (IsFlagSet(flags, MDT_DRAWTEXT))
        {
        UINT uDTFlags = DT_LVWRAP;

        if (IsFlagClear(flags, MDT_CLIPPED))
            uDTFlags |= DT_NOCLIP;

        DrawText(hdc, pszText, cchText, &rc, uDTFlags);
        }
    else
        {
        if (IsFlagClear(flags, MDT_LEFT))
            {
            SIZE siz;

            GetTextExtentPoint(hdc, pszText, cchText, &siz);

            if (IsFlagSet(flags, MDT_CENTER))
                rc.left = (rc.left + rc.right - siz.cx) / 2;
            else    
                {
                ASSERT(IsFlagSet(flags, MDT_RIGHT));
                rc.left = rc.right - siz.cx;
                }
            }

        if (IsFlagSet(flags, MDT_VCENTER))
            {
            // Center vertically
            rc.top += (rc.bottom - rc.top - cyChar) / 2;
            }

        if (IsFlagSet(flags, MDT_CLIPPED))
            uETOFlags |= ETO_CLIPPED;

        ExtTextOut(hdc, rc.left, rc.top, uETOFlags, prc, pszText, cchText, NULL);
        }

    if (flags & (MDT_SELECTED | MDT_DESELECTED | MDT_TRANSPARENT))
        {
        SetTextColor(hdc, clrSave);
        if (IsFlagClear(flags, MDT_TRANSPARENT))
            SetBkColor(hdc, clrSaveBk);
        }
    }
#endif // NODRAWTEXT


#ifndef NOFILEINFO

/*----------------------------------------------------------
Purpose: Takes a DWORD value and converts it to a string, adding
         commas on the way.

         This was taken from the shell.

Returns: Pointer to buffer

Cond:    --
*/
LPSTR PRIVATE AddCommas(
    DWORD dw, 
    LPSTR pszBuffer,
    UINT cbBuffer)
    {
    char  szTemp[30];
    char  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, sizeof(szSep));
    nfmt.Grouping = AnsiToInt(szSep);
    GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, sizeof(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    wsprintf(szTemp, "%lu", dw);

    GetNumberFormatA(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszBuffer, cbBuffer);
    return pszBuffer;
    }


const short s_rgidsOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB, IDS_ORDERGB, IDS_ORDERTB};

/*----------------------------------------------------------
Purpose: Converts a number into a short, string format.

         This code was taken from the shell.

            532     -> 523 bytes
            1340    -> 1.3KB
            23506   -> 23.5KB
                    -> 2.4MB
                    -> 5.2GB

Returns: pointer to buffer
Cond:    --
*/
LPSTR PRIVATE ShortSizeFormat64(
    __int64 dw64, 
    LPSTR szBuf)
    {
    int i;
    UINT wInt, wLen, wDec;
    char szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000) 
        {
        wsprintf(szTemp, "%d", LODWORD(dw64));
        i = 0;
        goto AddOrder;
        }

    for (i = 1; i < ARRAY_ELEMENTS(s_rgidsOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    AddCommas(wInt, szTemp, sizeof(szTemp));
    wLen = lstrlen(szTemp);
    if (wLen < 3)
        {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, "%02d");

        szFormat[2] = '0' + 3 - wLen;
        GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, sizeof(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
        }

AddOrder:
    LoadString(g_hinst, s_rgidsOrders[i], szOrder, sizeof(szOrder));
    wsprintf(szBuf, szOrder, (LPSTR)szTemp);

    return szBuf;
    }



/*----------------------------------------------------------
Purpose: Converts a number into a short, string format.

         This code was taken from the shell.

            532     -> 523 bytes
            1340    -> 1.3KB
            23506   -> 23.5KB
                    -> 2.4MB
                    -> 5.2GB

Returns: pointer to buffer
Cond:    --
*/
LPSTR PRIVATE ShortSizeFormat(DWORD dw, LPSTR szBuf)
    {
    return(ShortSizeFormat64((__int64)dw, szBuf));
    }


/*----------------------------------------------------------
Purpose: Gets the file info given a path.  If the path refers
         to a directory, then simply the path field is filled.

         If himl != NULL, then the function will add the file's
         image to the provided image list and set the image index
         field in the *ppfi.

Returns: standard hresult
Cond:    --
*/
HRESULT PUBLIC FICreate(
    LPCSTR pszPath,
    FileInfo ** ppfi,
    UINT uFlags)
    {
    HRESULT hres = ResultFromScode(E_OUTOFMEMORY);
    int cchPath;
    SHFILEINFO sfi;
    UINT uInfoFlags = SHGFI_DISPLAYNAME | SHGFI_ATTRIBUTES;
    DWORD dwAttr;

    ASSERT(pszPath);
    ASSERT(ppfi);

    // Get shell file info 
    if (IsFlagSet(uFlags, FIF_ICON))
        uInfoFlags |= SHGFI_ICON;
    if (IsFlagSet(uFlags, FIF_DONTTOUCH))
        {
        uInfoFlags |= SHGFI_USEFILEATTRIBUTES;

        // Today, FICreate is not called for folders, so this is ifdef'd out
#ifdef SUPPORT_FOLDERS
        dwAttr = IsFlagSet(uFlags, FIF_FOLDER) ? FILE_ATTRIBUTE_DIRECTORY : 0;
#else
        dwAttr = 0;
#endif
        }
    else
        dwAttr = 0;

    if (SHGetFileInfo(pszPath, dwAttr, &sfi, sizeof(sfi), uInfoFlags))
        {
        // Allocate enough for the structure, plus buffer for the fully qualified
        // path and buffer for the display name (and extra null terminator).
        cchPath = lstrlen(pszPath);

        *ppfi = GAlloc(sizeof(FileInfo)+cchPath+1-sizeof((*ppfi)->szPath)+lstrlen(sfi.szDisplayName)+1);
        if (*ppfi)
            {
            FileInfo * pfi = *ppfi;

            pfi->pszDisplayName = pfi->szPath+cchPath+1;
            lstrcpy(pfi->pszDisplayName, sfi.szDisplayName);

            if (IsFlagSet(uFlags, FIF_ICON))
                pfi->hicon = sfi.hIcon;

            pfi->dwAttributes = sfi.dwAttributes;

            // Does the path refer to a directory?
            if (FIIsFolder(pfi))
                {
                // Yes; just fill in the path field
                lstrcpy(pfi->szPath, pszPath);
                hres = NOERROR;
                }
            else
                {
                // No; assume the file exists?
                if (IsFlagClear(uFlags, FIF_DONTTOUCH))
                    {
                    // Yes; get the time, date and size of the file
                    HANDLE hfile = CreateFile(pszPath, GENERIC_READ, 
                                FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                NULL);

                    if (hfile == INVALID_HANDLE_VALUE)
                        {
                        GFree(*ppfi);
                        *ppfi = NULL;
                        hres = ResultFromScode(E_HANDLE);
                        }
                    else
                        {
                        hres = NOERROR;

                        lstrcpy(pfi->szPath, pszPath);
                        pfi->dwSize = GetFileSize(hfile, NULL);
                        GetFileTime(hfile, NULL, NULL, &pfi->ftMod);
                        CloseHandle(hfile);
                        }
                    }
                else
                    {
                    // No; use what we have
                    hres = NOERROR;
                    lstrcpy(pfi->szPath, pszPath);
                    }
                }
            }
        }
    else if (!WPPathExists(pszPath))
        {
        // Differentiate between out of memory and file not found
        hres = E_FAIL;
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Get some file info of the given path.
         The returned string is of the format "# bytes <date>"

         If the path is a folder, the string is empty.

Returns: FALSE if path is not found
Cond:    --
*/
BOOL PUBLIC FIGetInfoString(
    FileInfo * pfi,
    LPSTR pszBuf,
    int cchBuf)
    {
    BOOL bRet;

    ASSERT(pfi);
    ASSERT(pszBuf);

    *pszBuf = NULL_CHAR;

    if (pfi)
        {
        // Is this a file?
        if ( !FIIsFolder(pfi) )
            {
            // Yes
            char szSize[MAX_BUF_MED];
            char szDate[MAX_BUF_MED];
            char szTime[MAX_BUF_MED];
            LPSTR pszMsg;
            SYSTEMTIME st;
            FILETIME ftLocal;

            // Construct the string
            FileTimeToLocalFileTime(&pfi->ftMod, &ftLocal);
            FileTimeToSystemTime(&ftLocal, &st);
            GetDateFormatA(LOCALE_USER_DEFAULT, DATE_LONGDATE, &st, NULL, szDate, sizeof(szDate));
            GetTimeFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL, szTime, sizeof(szTime));

            if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(IDS_DATESIZELINE),
                ShortSizeFormat(FIGetSize(pfi), szSize), szDate, szTime))
                {
                lstrcpy(pszBuf, pszMsg);
                GFree(pszMsg);
                }
            else
                *pszBuf = 0;

            bRet = TRUE;
            }
        else
            bRet = FALSE;
        }
    else
        bRet = FALSE;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Set the path entry.  This can move the pfi.

Returns: FALSE on out of memory
Cond:    --
*/
BOOL PUBLIC FISetPath(
    FileInfo ** ppfi,
    LPCSTR pszPathNew,
    UINT uFlags)
    {
    ASSERT(ppfi);
    ASSERT(pszPathNew);

    FIFree(*ppfi);

    return SUCCEEDED(FICreate(pszPathNew, ppfi, uFlags));
    }


/*----------------------------------------------------------
Purpose: Free our file info struct
Returns: --
Cond:    --
*/
void PUBLIC FIFree(
    FileInfo * pfi)
    {
    if (pfi)
        {
        if (pfi->hicon)
            DestroyIcon(pfi->hicon);

        GFree(pfi);     // This macro already checks for NULL pfi condition
        }
    }


/*----------------------------------------------------------
Purpose: Convert FILETIME struct to a readable string

Returns: String 
Cond:    --
*/
void PUBLIC FileTimeToDateTimeString(
    LPFILETIME pft, 
    LPSTR pszBuf,
    int cchBuf)
    {
    SYSTEMTIME st;
    FILETIME ftLocal;

    FileTimeToLocalFileTime(pft, &ftLocal);
    FileTimeToSystemTime(&ftLocal, &st);
    GetDateFormatA(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, pszBuf, cchBuf/2);
    pszBuf += lstrlen(pszBuf);
    *pszBuf++ = ' ';
    GetTimeFormatA(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszBuf, cchBuf/2);
    }

#endif // NOFILEINFO


#ifndef NOSYNC
CRITICAL_SECTION g_csCommon = { 0 };
DEBUG_CODE( UINT g_cRefCommonCS = 0; )

/*----------------------------------------------------------
Purpose: Waits for on object to signal.  This function "does 
         the right thing" to prevent deadlocks which can occur
         because the calculation thread calls SendMessage.

Returns: value of MsgWaitForMultipleObjects
Cond:    --
*/
DWORD PUBLIC MsgWaitObjectsSendMessage(
    DWORD cObjects,
    LPHANDLE phObjects,
    DWORD dwTimeout)
    {
    DWORD dwRet;

    while (TRUE)
        {
        dwRet = MsgWaitForMultipleObjects(cObjects, phObjects, FALSE,
                                        dwTimeout, QS_SENDMESSAGE);

        // If it is not a message, return
        if ((WAIT_OBJECT_0 + cObjects) != dwRet)
            {
            return dwRet;
            }
        else
            {
            // Process all the sent messages
            MSG msg;
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Initialize the critical section.

Returns: --

Cond:    Note that critical sections differ between Win95
         and NT.  On Win95, critical sections synchronize
         across processes.  On NT, they are per-process.
*/
void PUBLIC Common_InitExclusive(void)
    {
    ReinitializeCriticalSection(&g_csCommon);
    ASSERT(0 != *((LPDWORD)&g_csCommon));

#ifdef DEBUG
    g_cRefCommonCS = 0;
#endif
    }


/*----------------------------------------------------------
Purpose: Enter a critical section
Returns: --

Cond:    Note that critical sections differ between Win95
         and NT.  On Win95, critical sections synchronize
         across processes.  On NT, they are per-process.
*/
void PUBLIC Common_EnterExclusive(void)
    {
    EnterCriticalSection(&g_csCommon);
#ifdef DEBUG
    g_cRefCommonCS++;
#endif
    }


/*----------------------------------------------------------
Purpose: Leave a critical section
Returns: --

Cond:    Note that critical sections differ between Win95
         and NT.  On Win95, critical sections synchronize
         across processes.  On NT, they are per-process.
*/
void PUBLIC Common_LeaveExclusive(void)
    {
#ifdef DEBUG
    g_cRefCommonCS--;
#endif
    LeaveCriticalSection(&g_csCommon);
    }

#endif // NOSYNC


#ifndef NOMESSAGESTRING

/*----------------------------------------------------------
Purpose: Load the string (if necessary) and format the string
         properly.

Returns: A pointer to the allocated string containing the formatted
         message or
         NULL if out of memory

Cond:    free pointer with LocalFree()
*/
LPSTR PUBLIC ConstructVMessageString(
    HINSTANCE hinst, 
    LPCSTR pszMsg, 
    va_list *ArgList)
    {
    char szTemp[MAX_BUF];
    LPSTR pszRet;
    LPSTR pszRes;

    if (HIWORD(pszMsg))
        pszRes = (LPSTR)pszMsg;
    else if (LOWORD(pszMsg) && LoadString(hinst, LOWORD(pszMsg), szTemp, sizeof(szTemp)))
        pszRes = szTemp;
    else
        pszRes = NULL;

    if (pszRes)
        {
        if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                           pszRes, 0, 0, (LPTSTR)&pszRet, 0, ArgList)) 
            {
            pszRet = NULL;
            }
        }
    else
        {
        // Bad parameter
        pszRet = NULL;
        }

    return pszRet;      // free with LocalFree()
    }


/*----------------------------------------------------------
Purpose: Constructs a formatted string.  The returned string 
         must be freed using GFree().

Returns: TRUE on success

Cond:    Free pointer with GFree()
*/
BOOL PUBLIC ConstructMessage(
    LPSTR * ppsz,
    HINSTANCE hinst, 
    LPCSTR pszMsg, ...)
    {
    BOOL bRet;
    LPSTR pszRet;
    va_list ArgList;

    va_start(ArgList, pszMsg);

    pszRet = ConstructVMessageString(hinst, pszMsg, &ArgList);

    va_end(ArgList);

    *ppsz = NULL;

    if (pszRet)
        {
        bRet = GSetString(ppsz, pszRet);
        LocalFree(pszRet);
        }
    else
        bRet = FALSE;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Invoke a message box.

Returns: ID of button that terminated the dialog
Cond:    --
*/
int PUBLIC MsgBox(
    HINSTANCE hinst,
    HWND hwndOwner,
    LPCSTR pszText,
    LPCSTR pszCaption,
    HICON hicon,            // May be NULL
    DWORD dwStyle, ...)
    {
    int iRet = -1;
    int ids;
    char szCaption[MAX_BUF];
    LPSTR pszRet;
    va_list ArgList;

    va_start(ArgList, dwStyle);
    
    pszRet = ConstructVMessageString(hinst, pszText, &ArgList);

    va_end(ArgList);

    if (pszRet)
        {
        // Is pszCaption a resource ID?
        if (0 == HIWORD(pszCaption))
            {
            // Yes; load it
            ids = LOWORD(pszCaption);
            SzFromIDS(hinst, ids, szCaption, sizeof(szCaption));
            pszCaption = szCaption;
            }

        // Invoke dialog
        if (pszCaption)
            {
            MSGBOXPARAMS mbp;

            mbp.cbSize = sizeof(mbp);
            mbp.hwndOwner = hwndOwner;
            mbp.hInstance = hinst;
            mbp.lpszText = pszRet;
            mbp.lpszCaption = pszCaption;
            mbp.dwStyle = dwStyle | MB_SETFOREGROUND;
            mbp.lpszIcon = MAKEINTRESOURCE(hicon);
            mbp.lpfnMsgBoxCallback = NULL;
            mbp.dwLanguageId = LANG_NEUTRAL;

            iRet = MessageBoxIndirect(&mbp);
            }
        LocalFree(pszRet);
        }

    return iRet;
    }

#endif // NOMESSAGESTRING


#ifndef NODEBUGHELP

#ifdef DEBUG

// Globals
DWORD g_dwBreakFlags = 0;
DWORD g_dwDumpFlags = 0;
DWORD g_dwTraceFlags = 0;


#pragma data_seg(DATASEG_READONLY)

char const FAR c_szNewline[] = "\r\n";
char const FAR c_szTrace[] = "t " SZ_MODULE "  ";
char const FAR c_szDbg[] = SZ_MODULE "  ";
char const FAR c_szAssertFailed[] = SZ_MODULE "  Assertion failed in %s on line %d\r\n";

#ifdef WANT_OLE_SUPPORT
struct _RIIDMAP
    {
    REFIID  riid;
    LPCSTR  psz;
    } const c_rgriidmap[] = {
        { &IID_IUnknown,        "IID_IUnknown" },
        { &IID_IBriefcaseStg,   "IID_IBriefcaseStg" },
        { &IID_IEnumUnknown,    "IID_IEnumUnknown" },
        { &IID_IShellBrowser,   "IID_IShellBrowser" },
        { &IID_IShellView,      "IID_IShellView" },
        { &IID_IContextMenu,    "IID_IContextMenu" },
        { &IID_IShellFolder,    "IID_IShellFolder" },
        { &IID_IShellExtInit,   "IID_IShellExtInit" },
        { &IID_IShellPropSheetExt, "IID_IShellPropSheetExt" },
        { &IID_IPersistFolder,  "IID_IPersistFolder" },
        { &IID_IExtractIcon,    "IID_IExtractIcon" },
        { &IID_IShellDetails,   "IID_IShellDetails" },
        { &IID_IDelayedRelease, "IID_IDelayedRelease" },
        { &IID_IShellLink,      "IID_IShellLink" },
        };
#endif // WANT_OLE_SUPPORT

struct _SCODEMAP
    {
    SCODE  sc;
    LPCSTR psz;
    } const c_rgscodemap[] = {
        { S_OK,             "S_OK" },
        { S_FALSE,          "S_FALSE" },
        { E_UNEXPECTED,     "E_UNEXPECTED" },
        { E_NOTIMPL,        "E_NOTIMPL" },
        { E_OUTOFMEMORY,    "E_OUTOFMEMORY" },
        { E_INVALIDARG,     "E_INVALIDARG" },
        { E_NOINTERFACE,    "E_NOINTERFACE" },
        { E_POINTER,        "E_POINTER" },
        { E_HANDLE,         "E_HANDLE" },
        { E_ABORT,          "E_ABORT" },
        { E_FAIL,           "E_FAIL" },
        { E_ACCESSDENIED,   "E_ACCESSDENIED" },
        };

#pragma data_seg()

/*----------------------------------------------------------
Purpose: Return English reason for the debug break
Returns: String
Cond:    --
*/
LPCSTR PRIVATE GetReasonString(
    DWORD flag)      // One of BF_ flags
    {
    LPCSTR psz;

    if (IsFlagSet(flag, BF_ONOPEN))
        psz = "BREAK ON OPEN\r\n";

    else if (IsFlagSet(flag, BF_ONCLOSE))
        psz = "BREAK ON CLOSE\r\n";

    else if (IsFlagSet(flag, BF_ONVALIDATE))
        psz = "BREAK ON VALIDATION FAILURE\r\n";

    else if (IsFlagSet(flag, BF_ONTHREADATT))
        psz = "BREAK ON THREAD ATTACH\r\n";

    else if (IsFlagSet(flag, BF_ONTHREADDET))
        psz = "BREAK ON THREAD DETACH\r\n";

    else if (IsFlagSet(flag, BF_ONPROCESSATT))
        psz = "BREAK ON PROCESS ATTACH\r\n";

    else if (IsFlagSet(flag, BF_ONPROCESSDET))
        psz = "BREAK ON PROCESS DETACH\r\n";

    else
        psz = c_szNewline;

    return psz;
    }


/*----------------------------------------------------------
Purpose: Perform a debug break based on the flag
Returns: --
Cond:    --
*/
void PUBLIC CommonDebugBreak(
    DWORD flag)      // One of BF_ flags
    {
    if (IsFlagSet(g_dwBreakFlags, flag))
        {
        TRACE_MSG(TF_ALWAYS, GetReasonString(flag));
        DebugBreak();
        }
    }


/*----------------------------------------------------------
Purpose: Assert failed
Returns: --
Cond:    --
*/
void PUBLIC CommonAssertFailed(
    LPCSTR pszFile, 
    int line)
    {
    LPCSTR psz;
    char ach[256];

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
        {
#ifdef  DBCS
        if ((AnsiPrev(pszFile, psz) != (psz-2)) && *(psz - 1) == '\\')
#else
        if (*(psz - 1) == '\\')
#endif
            break;
        }
    wsprintf(ach, c_szAssertFailed, psz, line);
    OutputDebugString(ach);
    
    if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
        DebugBreak();
    }


/*----------------------------------------------------------
Purpose: Assert failed message only
Returns: --
Cond:    --
*/
void CPUBLIC CommonAssertMsg(
    BOOL f, 
    LPCSTR pszMsg, ...)
    {
    char ach[MAX_PATH+40];    // Largest path plus extra

    if (!f)
        {
        lstrcpy(ach, c_szTrace);
        wvsprintf(&ach[sizeof(c_szTrace)-1], pszMsg, (va_list)(&pszMsg + 1));
        OutputDebugString(ach);
        OutputDebugString(c_szNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Debug spew
Returns: --
Cond:    --
*/
void CPUBLIC CommonDebugMsg(
    DWORD flag,
    LPCSTR pszMsg, ...)
    {
    char ach[MAX_PATH+40];    // Largest path plus extra

    if (TF_ALWAYS == flag || IsFlagSet(g_dwTraceFlags, flag))
        {
        lstrcpy(ach, c_szTrace);
        wvsprintf(&ach[sizeof(c_szTrace)-1], pszMsg, (va_list)(&pszMsg + 1));
        OutputDebugString(ach);
        OutputDebugString(c_szNewline);
        }
    }


#ifdef WANT_OLE_SUPPORT
/*----------------------------------------------------------
Purpose: Returns the string form of an known interface ID.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_GetRiidName(
    REFIID riid)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(c_rgriidmap); i++)
        {
        if (IsEqualIID(riid, c_rgriidmap[i].riid))
            return c_rgriidmap[i].psz;
        }
    return "Unknown riid";
    }
#endif


/*----------------------------------------------------------
Purpose: Returns the string form of an scode given an hresult.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_GetScode(
    HRESULT hres)
    {
    int i;
    SCODE sc;

    sc = GetScode(hres);
    for (i = 0; i < ARRAY_ELEMENTS(c_rgscodemap); i++)
        {
        if (sc == c_rgscodemap[i].sc)
            return c_rgscodemap[i].psz;
        }
    return "Unknown scode";
    }


/*----------------------------------------------------------
Purpose: Returns a string safe enough to print...and I don't
         mean swear words.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_SafeStr(
    LPCSTR psz)
    {
    if (psz)
        return psz;
    else
        return "NULL";
    }

#endif // DEBUG

#endif // NODEBUGHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\profile.c ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// profile.c
//
// This file contains profile (.ini) routines.
// Meant to be used in conjunction with common.c.
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//  05-05-95 ScottH     Made generic from Briefcase code
//


#include "proj.h"
#include "common.h"

#ifndef NOPROFILE

#pragma data_seg(DATASEG_READONLY)

char const FAR c_szIniFile[] = SZ_DEBUGINI;
char const FAR c_szIniSecDebugUI[] = SZ_DEBUGSECTION;

char const FAR c_szZero[] = "0";
char const FAR c_szIniKeyBreakFlags[] = "BreakFlags";
char const FAR c_szIniKeyTraceFlags[] = "TraceFlags";
char const FAR c_szIniKeyDumpFlags[] = "DumpFlags";

#pragma data_seg()


// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCSTR pszSectionName;
    LPCSTR pszKeyName;
    LPCSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPUINT puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPUINT puStorage;
    } INTINIKEY;


// Some of these macros taken from prefs.h in Pen project...
//
#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {char sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


#ifdef SHARED_DLL
#pragma data_seg(DATASEG_PERINSTANCE)
#endif

// Array of keys with Integer RHSs to be processed by ProcessIniFile() 

static INTINIKEY s_rgiik[] = 
    {
        {
        { c_szIniSecDebugUI,    c_szIniKeyTraceFlags, c_szZero },
        &g_dwTraceFlags
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyDumpFlags, c_szZero },
        &g_dwDumpFlags
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakFlags, c_szZero },
        &g_dwBreakFlags
        },

    };

// Array of keys with Boolean RHSs to be processed by ProcessIniFile() 

#if 0   // (use this as an example)
static BOOLINIKEY s_rgbik[] =
    {
        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnOpen, c_szZero },
        &g_uBreakFlags,
        BF_ONOPEN
        },

    };
#endif

#ifdef SHARED_DLL
#pragma data_seg()
#endif


/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCSTR s_rgpszTrue[] =
    {
    "1",
    "On",
    "True",
    "Y",
    "Yes"
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCSTR s_rgpszFalse[] =
    {
    "0",
    "Off",
    "False",
    "N",
    "No"
    };




/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
Cond:    --
*/
BOOL PRIVATE IsIniYes(
    LPCSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    ASSERT(psz); 

    /* Is the value TRUE? */

    for (i = 0; i < ARRAY_ELEMENTS(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAY_ELEMENTS(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            TRACE_MSG(TF_WARNING, "IsIniYes() called on unknown Boolean RHS '%s'.", psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


#if 0   // (use this as an example)
/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
Returns: --
Cond:    --
*/
void PRIVATE ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        char szRHS[MAX_BUF];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, "", szRHS,
                                   sizeof(szRHS), c_szIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                TRACE_MSG(TF_GENERAL, "ProcessIniFile(): %s set in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                TRACE_MSG(TF_GENERAL, "ProcessIniFile(): %s cleared in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }
#endif


/*----------------------------------------------------------
Purpose: Process keys with integer RHSs.
Returns: --
Cond:    --
*/
void PRIVATE ProcessIntegers(void)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(s_rgiik); i++)
        {
        DWORD dwcbKeyLen;
        char szRHS[MAX_BUF];
        INTINIKEY * piik = &(s_rgiik[i]);
        LPCSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(piik->ikh.pszSectionName,
                                   piik->ikh.pszKeyName, "", szRHS,
                                   sizeof(szRHS), c_szIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = piik->ikh.pszDefaultRHS;

        *(piik->puStorage) = AnsiToInt(lpcszRHS);

        TRACE_MSG(TF_GENERAL, "ProcessIniFile(): %s set to %#04x.", 
                 piik->ikh.pszKeyName, *(piik->puStorage));
        }
    }


/*----------------------------------------------------------
Purpose: Process initialization file
Returns: TRUE if initialization is successful
Cond:    --
*/
BOOL PUBLIC ProcessIniFile(void)
    {
    BOOL bResult = TRUE;

    // Currently, all integer keys are for DEBUG use only.
    //
    ProcessIntegers();

    return bResult;
    }


#endif // NOPROFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\mem.c ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// mem.c
//
// This file contains memory management and dynamic 
// array functions.
//
// History:
//  09-27-94 ScottH     Taken from commctrl
//  04-29-95 ScottH     Taken from briefcase and cleaned up
//  


#include "proj.h"
#include "common.h"

#ifndef NOMEM

//////////////////////////////////////////////////////////////////

#ifndef WIN32
//
// Subsegment Allocation for 16-bit
//

#define MAX_WORD    0xffff

DECLARE_HANDLE(HHEAP);

typedef struct 
    {        //  maps to the bottom of a 16bit DS
    WORD reserved[8];
    WORD cAlloc;
    WORD cbAllocFailed;
    HHEAP hhpFirst;
    HHEAP hhpNext;
    } HEAP;

#define PHEAP(hhp)          ((HEAP FAR*)MAKELP(hhp, 0))
#define MAKEHP(sel, off)    ((void _huge*)MAKELP((sel), (off)))

#define CBSUBALLOCMAX   0x0000f000L

HHEAP g_hhpFirst = NULL;

BOOL NEAR DestroyHeap(HHEAP hhp);

void Mem_Terminate()
{
    while (g_hhpFirst)
        DestroyHeap(g_hhpFirst);
}

BOOL NEAR CreateHeap(WORD cbInitial)
{
    HHEAP hhp;

    if (cbInitial < 1024)
        cbInitial = 1024;

    hhp = (HHEAP)GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cbInitial);

    if (!hhp)
        return FALSE;

    if (!LocalInit((WORD)hhp, sizeof(HEAP), cbInitial - 1))
    {
        GlobalFree(hhp);
        return FALSE;
    }

    PHEAP(hhp)->cAlloc = 0;
    PHEAP(hhp)->cbAllocFailed = MAX_WORD;
    PHEAP(hhp)->hhpNext = g_hhpFirst;
    g_hhpFirst = hhp;

    DebugMsg(DM_TRACE, "CreateHeap: added new local heap %x", hhp);

    return TRUE;
}

#pragma optimize("o", off)		// linked list removals don't optimize correctly
BOOL NEAR DestroyHeap(HHEAP hhp)
{
    ASSERT(hhp);
    ASSERT(g_hhpFirst);

    if (g_hhpFirst == hhp)
    {
        g_hhpFirst = PHEAP(hhp)->hhpNext;
    }
    else
    {
        HHEAP hhpT = g_hhpFirst;

        while (PHEAP(hhpT)->hhpNext != hhp)
        {
            hhpT = PHEAP(hhpT)->hhpNext;
            if (!hhpT)
                return FALSE;
        }

        PHEAP(hhpT)->hhpNext = PHEAP(hhp)->hhpNext;
    }
    if (GlobalFree((HGLOBAL)hhp) != NULL)
        return FALSE;

    return TRUE;
}
#pragma optimize("", on)	// back to default optimizations

#pragma optimize("lge", off) // Suppress warnings associated with use of _asm...
void NEAR* NEAR HeapAlloc(HHEAP hhp, WORD cb)
{
    void NEAR* pb;

    _asm {
        push    ds
        mov     ds,hhp
    }

    pb = (void NEAR*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb);

    if (pb)
        ((HEAP NEAR*)0)->cAlloc++;

    _asm {
        pop     ds
    }

    return pb;
}
#pragma optimize("o", off)		// linked list removals don't optimize correctly

void _huge* WINAPI SharedAlloc(long cb)
{
    void NEAR* pb;
    HHEAP hhp;
    HHEAP hhpPrev;

    // If this is a big allocation, just do a global alloc.
    //
    if (cb > CBSUBALLOCMAX)
    {
        void FAR* lpb = MAKEHP(GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cb), 0);
        if (!lpb)
            DebugMsg(DM_ERROR, "Alloc: out of memory");
        return lpb;
    }

    hhp = g_hhpFirst;

    while (TRUE)
    {
        if (hhp == NULL)
        {
            if (!CreateHeap(0))
            {
                DebugMsg(DM_ERROR, "Alloc: out of memory");
                return NULL;
            }

            hhp = g_hhpFirst;
        }

        pb = HeapAlloc(hhp, (WORD)cb);
        if (pb)
            return MAKEHP(hhp, pb);

        // Record the size of the allocation that failed.
        // Later attempts to allocate more than this amount
        // will not succeed.  This gets reset anytime anything
        // is freed in the heap.
        //
        PHEAP(hhp)->cbAllocFailed = (WORD)cb;

        // First heap is full... see if there's room in any other heap...
        //
        for (hhpPrev = hhp; hhp = PHEAP(hhp)->hhpNext; hhpPrev = hhp)
        {
            // If the last allocation to fail in this heap
            // is not larger than cb, don't even try an allocation.
            //
            if ((WORD)cb >= PHEAP(hhp)->cbAllocFailed)
                continue;

            pb = HeapAlloc(hhp, (WORD)cb);
            if (pb)
            {
                // This heap had room: move it to the front...
                //
                PHEAP(hhpPrev)->hhpNext = PHEAP(hhp)->hhpNext;
                PHEAP(hhp)->hhpNext = g_hhpFirst;
                g_hhpFirst = hhp;

                return MAKEHP(hhp, pb);
            }
            else
            {
                // The alloc failed.  Set cbAllocFailed...
                //
                PHEAP(hhp)->cbAllocFailed = (WORD)cb;
            }
        }
    }
}
#pragma optimize("", on)	// back to default optimizations

#pragma optimize("lge", off) // Suppress warnings associated with use of _asm...

void _huge* WINAPI SharedReAlloc(void _huge* pb, long cb)
{
    void NEAR* pbNew;
    void _huge* lpbNew;
    UINT cbOld;

    // does not work with cb > 64k
    if (!pb)
        return SharedAlloc(cb);

    if (OFFSETOF(pb) == 0)
        return MAKEHP(GlobalReAlloc((HGLOBAL)SELECTOROF(pb), cb, GMEM_MOVEABLE | GMEM_ZEROINIT), 0);

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    pbNew = (void NEAR*)LocalReAlloc((HLOCAL)OFFSETOF(pb), (int)cb, LMEM_MOVEABLE | LMEM_ZEROINIT);
    if (!pbNew)
        cbOld = LocalSize((HLOCAL)OFFSETOF(pb));

    _asm {
        pop     ds
    }

    if (pbNew)
        return MAKEHP(SELECTOROF(pb), pbNew);

    lpbNew = SharedAlloc(cb);
    if (lpbNew)
    {
        hmemcpy((void FAR*)lpbNew, (void FAR*)pb, cbOld);
        Free(pb);
    }
    else
    {
        DebugMsg(DM_ERROR, "ReAlloc: out of memory");
    }
    return lpbNew;
}

BOOL WINAPI SharedFree(void _huge* FAR * ppb)
{
    BOOL fSuccess;
    UINT cAlloc;
    void _huge * pb = *ppb;

    if (!pb)
        return FALSE;

    *ppb = 0;

    if (OFFSETOF(pb) == 0)
        return (GlobalFree((HGLOBAL)SELECTOROF(pb)) == NULL);

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    fSuccess = (LocalFree((HLOCAL)OFFSETOF(pb)) ? FALSE : TRUE);

    cAlloc = 1;
    if (fSuccess)
    {
        cAlloc = --((HEAP NEAR*)0)->cAlloc;
        ((HEAP NEAR*)0)->cbAllocFailed = MAX_WORD;
    }

    _asm {
        pop     ds
    }

    if (cAlloc == 0)
        DestroyHeap((HHEAP)SELECTOROF(pb));

    return fSuccess;
}


DWORD WINAPI SharedGetSize(void _huge* pb)
{
    WORD wSize;

    if (OFFSETOF(pb) == 0)
        return GlobalSize((HGLOBAL)SELECTOROF(pb));

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    wSize = LocalSize((HLOCAL)OFFSETOF(pb));

    _asm {
        pop     ds
    }

    return (DWORD)wSize;
}

#pragma optimize("", on)

//////////////////////////////////////////////////////////////////

#else // WIN32
//
// Win32 memory management wrappers
//

// Define a Global Shared Heap that we use to allocate memory 
// out of that we need to share between multiple instances.
//
static HANDLE g_hSharedHeap = NULL;

#define MAXHEAPSIZE     2097152
#define HEAP_SHARED     0x04000000      /* put heap in shared memory */


/*----------------------------------------------------------
Purpose: Clean up heap.  This function should be called at
         the program's termination.

Returns: --
Cond:    --
*/
void PUBLIC Mem_Terminate()
    {
    // Assuming that everything else has exited
    //
    if (g_hSharedHeap != NULL)
        HeapDestroy(g_hSharedHeap);
    g_hSharedHeap = NULL;
    }


/*----------------------------------------------------------
Purpose: Copies psz into *ppszBuf.  Will alloc or realloc *ppszBuf
         accordingly.

         If psz is NULL, this function frees *ppszBuf.  This is
         the preferred method of freeing the allocated buffer.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC GSetString(
    LPSTR * ppszBuf,
    LPCSTR psz)             // NULL to free *ppszBuf
    {
    BOOL bRet = FALSE;

    ASSERT(ppszBuf);

    // Free the buffer?
    if (!psz)
        {
        // Yes
        if (ppszBuf)
            {
            GFree(*ppszBuf);
            *ppszBuf = NULL;
            }
        bRet = TRUE;
        }
    else
        {
        // No; (re)allocate and set buffer
        DWORD cb = CbFromCch(lstrlen(psz)+CCH_NUL);

        if (*ppszBuf)
            {
            // Need to reallocate?
            if (cb > GGetSize(*ppszBuf))
                {
                // Yes
                LPSTR pszT = GReAlloc(*ppszBuf, cb);
                if (pszT)
                    {
                    *ppszBuf = pszT;
                    bRet = TRUE;
                    }
                }
            else
                {
                // No
                bRet = TRUE;
                }
            }
        else
            {
            *ppszBuf = (LPSTR)GAlloc(cb);
            if (*ppszBuf)
                {
                bRet = TRUE;
                }
            }

        if (bRet)
            {
            ASSERT(*ppszBuf);
            lstrcpy(*ppszBuf, psz);
            }
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Concatenates psz onto *ppszBuf.  Will alloc or 
         realloc *ppszBuf accordingly.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC GCatString(
    LPSTR * ppszBuf,
    LPCSTR psz)
    {
    BOOL bRet = FALSE;
    DWORD cb;

    ASSERT(ppszBuf);
    ASSERT(psz);

    cb = CbFromCch(lstrlen(psz)+CCH_NUL);

    if (*ppszBuf)
        {
        // (Don't need to count nul because it is already counted in cb)
        DWORD cbExisting = CbFromCch(lstrlen(*ppszBuf));  

        // Need to reallocate?
        if ((cb+cbExisting) > GGetSize(*ppszBuf))
            {
            // Yes; realloc at least MAX_BUF to cut down on the amount
            // of calls in the future
            LPSTR pszT = GReAlloc(*ppszBuf, cbExisting+max(cb, MAX_BUF));
            if (pszT)
                {
                *ppszBuf = pszT;
                bRet = TRUE;
                }
            }
        else
            {
            // No
            bRet = TRUE;
            }
        }
    else
        {
        *ppszBuf = (LPSTR)GAlloc(max(cb, MAX_BUF));
        if (*ppszBuf)
            {
            bRet = TRUE;
            }
        }

    if (bRet)
        {
        ASSERT(*ppszBuf);
        lstrcat(*ppszBuf, psz);
        }
    return bRet;
    }


//
// Shared heap memory management
//
#ifndef NOSHAREDHEAP

/*----------------------------------------------------------
Purpose: Allocate out of shared heap

Returns: Pointer to allocate memory
Cond:    --
*/
void * PUBLIC SharedAlloc(
    DWORD cb)
    {
    // I will assume that this is the only one that needs the checks to
    // see if the heap has been previously created or not

    if (g_hSharedHeap == NULL)
        {
        ENTER_EXCLUSIVE()
            {
            if (g_hSharedHeap == NULL)
                {
                g_hSharedHeap = HeapCreate(HEAP_SHARED, 1, MAXHEAPSIZE);
                }
            }
        LEAVE_EXCLUSIVE()

        // If still NULL we have problems!
        if (g_hSharedHeap == NULL)
            return(NULL);
        }

    return HeapAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, cb);
    }


/*----------------------------------------------------------
Purpose: Realloc out of shared heap.

Returns: Possibly new pointer to resized block
Cond:    --
*/
void * PUBLIC SharedReAlloc(
    PVOID pv, 
    DWORD cb)
    {
    if (NULL == pv)
        {
        return SharedAlloc(cb);
        }
    return HeapReAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, pv, cb);
    }


/*----------------------------------------------------------
Purpose: Free shared memory

Returns: --
Cond:    --
*/
void PUBLIC _SharedFree(
    PVOID pv)
    {
    ASSERT(pv);

    if (pv)
        {
        HeapFree(g_hSharedHeap, 0, pv);
        }
    }


/*----------------------------------------------------------
Purpose: Returns the allocated size of a block

Returns: see above
Cond:    --
*/
DWORD PUBLIC SharedGetSize(
    PVOID pv)
    {
    return HeapSize(g_hSharedHeap, 0, pv);
    }


/*----------------------------------------------------------
Purpose: Copies psz into *ppszBuf.  Will alloc or realloc *ppszBuf
         accordingly.

         If psz is NULL, this function frees *ppszBuf.  This is
         the preferred method of freeing the allocated buffer.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC SharedSetString(
    LPSTR * ppszBuf,
    LPCSTR psz)             // NULL to free *ppszBuf
    {
    BOOL bRet;

    ASSERT(ppszBuf);

    // Free the buffer?
    if (!psz)
        {
        // Yes
        if (ppszBuf)
            {
            SharedFree(*ppszBuf);
            *ppszBuf = NULL;
            }
        bRet = TRUE;
        }
    else
        {
        // No; (re)allocate and set buffer
        DWORD cb = CbFromCch(lstrlen(psz)+CCH_NUL);

        LPSTR pszT = SharedReAlloc(*ppszBuf, cb);
        if (pszT)
            {
            *ppszBuf = pszT;
            lstrcpy(*ppszBuf, psz);
            bRet = TRUE;
            }
        else
            bRet = FALSE;
        }
    return bRet;
    }
#endif // NOSHAREDHEAP


//
// Memory tracking functions
//

#ifdef DEBUG

typedef struct _HEAPTRACE
{
    DWORD   cAlloc;
    DWORD   cFailure;
    DWORD   cReAlloc;
    DWORD   cbMaxTotal;
    DWORD   cCurAlloc;
    DWORD   cbCurTotal;
} HEAPTRACE;

HEAPTRACE g_htSync = {0};      // Start of zero...

#endif // DEBUG


/*----------------------------------------------------------
Purpose: Allocate from a heap.

Returns: pointer to block of memory
         NULL (if out of memory)

Cond:    --
*/
LPVOID PUBLIC MemAlloc(
    HANDLE hheap, 
    DWORD cb)
    {
    LPVOID lp;

    if (hheap)
        {
        lp = HeapAlloc(hheap, HEAP_ZERO_MEMORY, cb);
        }
    else
        {
        lp = GAlloc(cb);
        }

    if (lp == NULL)
        {
        DEBUG_CODE( g_htSync.cFailure++; )
        return NULL;
        }

#ifdef DEBUG

    // Update counts.
    g_htSync.cAlloc++;
    g_htSync.cCurAlloc++;
    g_htSync.cbCurTotal += cb;
    if (g_htSync.cbCurTotal > g_htSync.cbMaxTotal)
        g_htSync.cbMaxTotal = g_htSync.cbCurTotal;

#endif

    return lp;
    }


/*----------------------------------------------------------
Purpose: Reallocate a block of memory in a given heap.

Returns: Pointer to reallocated block
         NULL (if out of memory)

Cond:    --
*/
LPVOID PUBLIC MemReAlloc(
    HANDLE hheap, 
    LPVOID pb, 
    DWORD cb)
    {
    LPVOID lp;
    DEBUG_CODE( DWORD cbOld; )

    if (hheap)
        {
        DEBUG_CODE( cbOld = HeapSize(hheap, 0, pb); )

        lp = HeapReAlloc(hheap, HEAP_ZERO_MEMORY, pb, cb);
        }
    else
        {
        if (pb)
            {
            DEBUG_CODE( cbOld = GGetSize(pb); )

            lp = GReAlloc(pb, cb);
            }
        else
            {
            DEBUG_CODE( cbOld = 0; )

            lp = GAlloc(cb);
            }
        }

    if (lp == NULL)
        {
        DEBUG_CODE( g_htSync.cFailure++; )
        return NULL;
        }

#ifdef DEBUG

    // Update counts.
    g_htSync.cReAlloc++;
    g_htSync.cbCurTotal += cb - cbOld;
    if (g_htSync.cbCurTotal > g_htSync.cbMaxTotal)
        g_htSync.cbMaxTotal = g_htSync.cbCurTotal;

#endif

    return lp;
    }


/*----------------------------------------------------------
Purpose: Free block of memory in heap.

Returns: TRUE 
         FALSE (if failure)

Cond:    --
*/
BOOL PUBLIC MemFree(
    HANDLE hheap, 
    LPVOID pb)
    {
    BOOL fRet;
    DEBUG_CODE( DWORD cbOld; )

    if (hheap)
        {
        DEBUG_CODE( cbOld = HeapSize(hheap, 0, pb); )

        fRet = HeapFree(hheap, 0, pb);
        }
    else
        {
        DEBUG_CODE( cbOld = GGetSize(pb); )

        GFree(pb);
        fRet = TRUE;
        }

#ifdef DEBUG

    if (fRet)
        {
        // Update counts.
        g_htSync.cCurAlloc--;
        g_htSync.cbCurTotal -= cbOld;
        }

#endif

    return fRet;
    }


/*----------------------------------------------------------
Purpose: Returns the size of the given block.

Returns: size in bytes
Cond:    --
*/
DWORD PUBLIC MemSize(
    HANDLE hheap, 
    LPVOID pb)
    {
    if (hheap)
        return (DWORD)HeapSize(hheap, 0, pb);
    else
        return (DWORD)GGetSize(pb);
    }

#endif // WIN32


//////////////////////////////////////////////////////////////////


#ifndef NODA

/*----------------------------------------------------------
Purpose: Private alloc for pointer array functions.

Returns: pointer to block of memory
         NULL (if out of memory)

Cond:    --
*/
LPVOID PRIVATE PrvAlloc(
    DWORD dwFlags,          // PAF_* flags
    HANDLE hheap, 
    DWORD cb)
    {
    LPVOID lp;

    ASSERT(PAF_SHARED == SAF_SHARED);

    if (IsFlagSet(dwFlags, PAF_SHARED))
        {
        lp = SharedAlloc(cb);
        }
    else
        {
        lp = MemAlloc(hheap, cb);
        }

    return lp;
    }


// Heapsort is a bit slower, but it doesn't use any stack or memory...
// Mergesort takes a bit of memory (O(n)) and stack (O(log(n)), but very fast...
//
#ifdef WIN32
#define MERGESORT
#else
#define USEHEAPSORT
#endif

#ifdef DEBUG
#define SA_MAGIC   ('S' | ('A' << 256))
#define IsSA(psa) ((psa) && (psa)->magic == SA_MAGIC)
#define PA_MAGIC   ('P' | ('A' << 256))
#define IsPA(ppa) ((ppa) && (ppa)->magic == PA_MAGIC)
#else
#define IsSA(psa)
#define IsPA(ppa)
#endif


typedef struct 
    {
    PVOID * pp;
    PFNPACOMPARE pfnCmp;
    LPARAM lParam;
    int cp;
#ifdef MERGESORT
    PVOID * ppT;
#endif
    } SORTPARAMS;


//
// Structure Array
//

typedef struct _SA 
    {
    // NOTE: The following field MUST be defined at the beginning of the
    // structure in order for SAGetCount() to work.
    DWORD cItem;          // number of elements in sa

    PVOID aItem;          // memory for elements
    DWORD cItemAlloc;     // number items which fit in aItem
    DWORD cbItem;         // size of each item
    DWORD cItemGrow;      // number items to grow cItemAlloc by
    DWORD dwFlags;
    HANDLE hheap;

#ifdef DEBUG
    UINT  magic;
#endif
    } SA;

#define SA_PITEM(psa, index)    ((PVOID)(((char FAR*)(psa)->aItem) + ((index) * (psa)->cbItem)))


/*----------------------------------------------------------
Purpose: Create a structure array.

Returns: TRUE 
         FALSE (if out of memory or invalid parameters)
Cond:    --
*/
BOOL PUBLIC SACreateEx(
    PHSA phsa,
    DWORD cbItem, 
    DWORD cItemGrow,
    HANDLE hheap,           // Must be non-NULL if SAF_HEAP set
    DWORD dwFlags)
    {
    HSA psa;

    ASSERT(phsa);
    ASSERT(0 < cbItem);

    psa = PrvAlloc(dwFlags, hheap, sizeof(SA));

    if (IsFlagSet(dwFlags, PAF_SHARED))
        hheap = g_hSharedHeap;

    if (psa)
        {
        psa->cItem = 0;
        psa->cItemAlloc = 0;
        psa->cbItem = cbItem;
        psa->cItemGrow = (0 == cItemGrow ? 1 : cItemGrow);
        psa->aItem = NULL;
        psa->dwFlags = dwFlags;
        psa->hheap = hheap;

#ifdef DEBUG
        psa->magic = SA_MAGIC;
#endif
        }

    *phsa = psa;

    return NULL != psa;
    }


/*----------------------------------------------------------
Purpose: Destroys a structure array.

Returns: 
Cond:    --
*/
BOOL PUBLIC SADestroyEx(
    HSA psa,
    PFNSAFREE pfnFree,
    LPARAM lParam)
    {
    ASSERT(IsSA(psa));

    if (psa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

    if (psa->aItem)
        {
        if (pfnFree)
            {
            DWORD i = SAGetCount(psa);

            while (0 < i)
                {
                i--;

                // Caller should not free the actual pointer being
                // passed, only the contents!
                pfnFree(SA_PITEM(psa, i), lParam);
                }
            }
        
        if (!MemFree(psa->hheap, psa->aItem))
            return FALSE;
        }

#ifdef DEBUG
    psa->cItem = 0;
    psa->cItemAlloc = 0;
    psa->cbItem = 0;
    psa->magic = 0;
#endif

    return MemFree(psa->hheap, psa);
    }


/*----------------------------------------------------------
Purpose: Copy structure at index into buffer.

Returns: TRUE
         FALSE
Cond:    --
*/
BOOL PUBLIC SAGetItem(
    HSA psa, 
    DWORD index, 
    PVOID pitem)
    {
    ASSERT(IsSA(psa));
    ASSERT(pitem);

    if (SA_ERR == index || index >= psa->cItem)
        {
        TRACE_MSG(TF_ERROR, "SA: Invalid index: %lu", index);
        return FALSE;
        }

    hmemcpy(pitem, SA_PITEM(psa, index), psa->cbItem);
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Get pointer to structure in array

Returns: TRUE (if the index is within range)

Cond:    --
*/
BOOL PUBLIC SAGetItemPtr(
    HSA psa, 
    DWORD index,
    LPVOID * ppv)
    {
    BOOL bRet;

    ASSERT(IsSA(psa));
    ASSERT(ppv);

    bRet = !(SA_ERR == index || index >= psa->cItem);

    if (bRet)
        {
        *ppv = SA_PITEM(psa, index);
        }
    else
        {
        TRACE_MSG(TF_ERROR, "SA: Invalid index: %lu", index);
        *ppv = NULL;
        }
        
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Set item

Returns: 
Cond:    --
*/
BOOL PUBLIC SASetItem(
    HSA psa, 
    DWORD index, 
    PVOID pitem)
    {
    ASSERT(pitem);
    ASSERT(IsSA(psa));

    if (SA_ERR == index)
        {
        TRACE_MSG(TF_ERROR, "SA: Invalid index: %lu", index);
        return FALSE;
        }

    if (index >= psa->cItem)
        {
        if (index + 1 > psa->cItemAlloc)
            {
            int cItemAlloc = (((index + 1) + psa->cItemGrow - 1) / psa->cItemGrow) * psa->cItemGrow;

            PVOID aItemNew = MemReAlloc(psa->hheap, psa->aItem, cItemAlloc * psa->cbItem);
            if (!aItemNew)
                return FALSE;

            psa->aItem = aItemNew;
            psa->cItemAlloc = cItemAlloc;
            }
        psa->cItem = index + 1;
        }

    hmemcpy(SA_PITEM(psa, index), pitem, psa->cbItem);

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Inserts the given item.  If *piIndex is greater than
         the current size of the array, the item is appended
         to the end.  Otherwise, the item is inserted at 
         *piIndex.

         If piIndex is NULL, the item is appended to the end.

         Use SASetItem to place an item at a specified index,
         regardless of the array size.

         When this function completes successfully, it sets
         *piIndex to the index that the item really gets 
         inserted at.  Otherwise, it sets *piIndex to SA_ERR.

Returns: TRUE (on successful insertion)
         FALSE 
Cond:    --
*/
BOOL PUBLIC SAInsertItem(
    HSA psa, 
    LPDWORD pindex,         // May be NULL
    PVOID pitem)
    {
    BOOL bRet = TRUE;       // assume success

    ASSERT(pitem);
    ASSERT(IsSA(psa));

    if (pindex && SA_ERR == *pindex)
        {
        TRACE_MSG(TF_ERROR, "SA: Invalid index: %lu", *pindex);
        bRet = FALSE;
        }
    else
        {
        DWORD index;

        if (NULL == pindex || *pindex > psa->cItem)
            index = psa->cItem;
        else
            index = *pindex;

        if (psa->cItem + 1 > psa->cItemAlloc)
            {
            PVOID aItemNew = MemReAlloc(psa->hheap, psa->aItem,
                    (psa->cItemAlloc + psa->cItemGrow) * psa->cbItem);
            if (!aItemNew)
                bRet = FALSE;
            else
                {
                psa->aItem = aItemNew;
                psa->cItemAlloc += psa->cItemGrow;
                }
            }

        if (bRet)
            {
            // If we are inserting, we need to slide everybody up
            if (index < psa->cItem)
                {
                hmemcpy(SA_PITEM(psa, index + 1), SA_PITEM(psa, index),
                    (psa->cItem - index) * psa->cbItem);
                }
            psa->cItem++;
            hmemcpy(SA_PITEM(psa, index), pitem, psa->cbItem);

            if (pindex)
                *pindex = index;
            }
        else if (pindex)
            {
            *pindex = SA_ERR;
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: 
Returns: 
Cond:    --
*/
BOOL PUBLIC SADeleteItem(
    HSA psa, 
    DWORD index)
    {
    ASSERT(IsSA(psa));

    if (SA_ERR == index || index >= psa->cItem)
        {
        TRACE_MSG(TF_ERROR, "SA: Invalid index: %lu", index);
        return FALSE;
        }

    if (index < psa->cItem - 1)
        {
        hmemcpy(SA_PITEM(psa, index), SA_PITEM(psa, index + 1),
            (psa->cItem - (index + 1)) * psa->cbItem);
        }
    psa->cItem--;

    if (psa->cItemAlloc - psa->cItem > psa->cItemGrow)
        {
        PVOID aItemNew = MemReAlloc(psa->hheap, psa->aItem,
                (psa->cItemAlloc - psa->cItemGrow) * psa->cbItem);

        ASSERT(aItemNew);
        psa->aItem = aItemNew;
        psa->cItemAlloc -= psa->cItemGrow;
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: 
Returns: 
Cond:    --
*/
BOOL PUBLIC SADeleteAllItems(
    HSA psa)
    {
    ASSERT(IsSA(psa));

    if (psa->aItem)
        {
        MemFree(psa->hheap, psa->aItem);
        }

    psa->aItem = NULL;
    psa->cItem = psa->cItemAlloc = 0;
    return TRUE;
    }


//================== Dynamic pointer array implementation ===========

typedef struct _PA {
// NOTE: The following two fields MUST be defined in this order, at
// the beginning of the structure in order for the macro APIs to work.
//
    DWORD   cp;
    DWORD   dwAlignPad;
    PVOID * pp;

    HANDLE  hheap;        // Heap to allocate from if NULL use shared

    DWORD   cpAlloc;
    DWORD   cpGrow;
    DWORD   dwFlags;

#ifdef DEBUG
    UINT magic;
#endif
} PA;



/*----------------------------------------------------------
Purpose: Creates a pointer array.

Returns: TRUE
         FALSE (if out of memory)

Cond:    --
*/
BOOL PUBLIC PACreateEx(
    PHPA phpa,
    DWORD cpGrow,
    HANDLE hheap,           // Must be non-null if PAF_HEAP set
    DWORD dwFlags)          // PAF_*
    {
    HPA ppa;

    ASSERT(phpa);

    ppa = PrvAlloc(dwFlags, hheap, sizeof(PA));

    if (IsFlagSet(dwFlags, PAF_SHARED))
        hheap = g_hSharedHeap;
        
    if (ppa)
        {
        ppa->dwFlags = dwFlags;
        ppa->cp = 0;
        ppa->cpAlloc = 0;
        ppa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);
        ppa->pp = NULL;

#ifdef WIN32
        ppa->hheap = hheap;
#else
        ppa->hheap = NULL;       
#endif

#ifdef DEBUG
        ppa->magic = PA_MAGIC;
#endif
        }

    *phpa = ppa;

    return NULL != ppa;
    }


/*----------------------------------------------------------
Purpose: Destroy a pointer array, and call the given pfnFree
         function for each element in the array.

Returns: TRUE
         FALSE (on failure)

Cond:    --
*/
BOOL PUBLIC PADestroyEx(
    HPA ppa,
    PFNPAFREE pfnFree,
    LPARAM lParam)
    {
    ASSERT(IsPA(ppa));

    if (ppa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

    if (ppa->pp)
        {
        if (pfnFree)
            {
            DWORD i = PAGetCount(ppa);

            while (0 < i)
                {
                i--;
                pfnFree(PAFastGetPtr(ppa, i), lParam);
                }
            }
        
        if (!MemFree(ppa->hheap, ppa->pp))
            return FALSE;
        }

#ifdef DEBUG
    ppa->cp = 0;
    ppa->cpAlloc = 0;
    ppa->magic = 0;
#endif

    return MemFree(ppa->hheap, ppa);
    }


/*----------------------------------------------------------
Purpose: Clone a pointer array.  If *phpa was previously 
         allocated, this function simply grows the array
         to the appropriate size before copying the contents
         of the array.

Returns: TRUE
         FALSE (if out of memory)

Cond:    --
*/
BOOL PUBLIC PAClone(
    PHPA phpa,
    HPA ppa)
    {
    BOOL bRet;
    HPA ppaNew;

    ASSERT(phpa);

    if (NULL == *phpa)
        {
        bRet = PACreateEx(&ppaNew, ppa->cpGrow, ppa->hheap, ppa->dwFlags);
        }
    else
        {
        ppaNew = *phpa;
        bRet = TRUE;
        }

    if (bRet)
        {
        bRet = PAGrow(ppaNew, ppa->cpAlloc);
        if (!bRet)
            {
            if (NULL == *phpa)
                PADestroy(ppaNew);
            }
        else
            {
            ppaNew->cp = ppa->cp;
            hmemcpy(ppaNew->pp, ppa->pp, ppa->cp * sizeof(PVOID));
            *phpa = ppaNew;
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Get a pointer stored in index

Returns: TRUE
         FALSE (if index out of range)

Cond:    --
*/
BOOL PUBLIC PAGetPtr(
    HPA ppa, 
    DWORD index,
    LPVOID * ppv)
    {
    BOOL bRet;

    ASSERT(IsPA(ppa));
    ASSERT(ppv);

    bRet = !(PA_ERR == index || index >= ppa->cp);

    if (bRet)
        {
        *ppv = ppa->pp[index];
        }
    else
        {
        *ppv = NULL;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Gets the index that pointer p is stored at

Returns: index
Cond:    --
*/
BOOL PUBLIC PAGetPtrIndex(
    HPA ppa, 
    PVOID p,
    LPDWORD pindex)
    {
    BOOL bRet = FALSE;
    PVOID * pp;
    PVOID * ppMax;

    ASSERT(IsPA(ppa));
    ASSERT(pindex);

    if (ppa->pp)
        {
        pp = ppa->pp;
        ppMax = pp + ppa->cp;
        for ( ; pp < ppMax; pp++)
            {
            if (*pp == p)
                {
                *pindex = (DWORD)(pp - ppa->pp);
                bRet = TRUE;
                break;
                }
            }
        }

    if (!bRet)
        *pindex = PA_ERR;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Grow the pointer array

Returns: 
Cond:    --
*/
BOOL PUBLIC PAGrow(
    HPA ppa, 
    DWORD cpAlloc)
    {
    ASSERT(IsPA(ppa));

    if (cpAlloc > ppa->cpAlloc)
        {
        PVOID * ppNew;

        cpAlloc = ((cpAlloc + ppa->cpGrow - 1) / ppa->cpGrow) * ppa->cpGrow;

        if (ppa->pp)
            ppNew = (PVOID *)MemReAlloc(ppa->hheap, ppa->pp, cpAlloc * sizeof(PVOID));
        else
            ppNew = (PVOID *)PrvAlloc(ppa->dwFlags, ppa->hheap, cpAlloc * sizeof(PVOID));
        if (!ppNew)
            return FALSE;

        ppa->pp = ppNew;
        ppa->cpAlloc = cpAlloc;
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Store a pointer at index.  Grows the array accordingly.

Returns: TRUE
         FALSE (if out of memory)
Cond:    --
*/
BOOL PUBLIC PASetPtr(
    HPA ppa, 
    DWORD index, 
    PVOID p)
    {
    ASSERT(IsPA(ppa));

    if (PA_ERR == index)
        {
        TRACE_MSG(TF_ERROR, "PA: Invalid index: %lu", index);
        return FALSE;
        }

    if (index >= ppa->cp)
        {
        if (!PAGrow(ppa, index + 1))
            return FALSE;
        ppa->cp = index + 1;
        }

    ppa->pp[index] = p;

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Inserts the given item.  If *piIndex is greater than
         the current size of the array, the item is appended
         to the end.  Otherwise, the item is inserted at 
         *piIndex.

         If piIndex is NULL, the item is appended to the end.

         Use SASetItem to place an item at a specified index,
         regardless of the array size.

         When this function completes successfully, it sets
         *piIndex to the index that the item really gets 
         inserted at.  Otherwise, it sets *piIndex to SA_ERR.

Returns: TRUE (on successful insertion)
         FALSE 
Cond:    --
*/
BOOL PUBLIC PAInsertPtr(
    HPA ppa, 
    LPDWORD pindex,         // May be NULL
    PVOID p)
    {
    BOOL bRet;

    ASSERT(IsPA(ppa));

    if (pindex && PA_ERR == *pindex)
        {
        TRACE_MSG(TF_ERROR, "PA: Invalid index: %lu", *pindex);
        bRet = FALSE;
        }
    else
        {
        DWORD index;

        bRet = TRUE;        // assume success

        if (NULL == pindex || *pindex > ppa->cp)
            index = ppa->cp;
        else
            index = *pindex;

        // Make sure we have room for one more item
        //
        if (ppa->cp + 1 > ppa->cpAlloc)
            {
            bRet = PAGrow(ppa, ppa->cp + 1);
            }

        if (bRet)
            {
            // If we are inserting, we need to slide everybody up
            if (index < ppa->cp)
                {
                hmemcpy(&ppa->pp[index + 1], &ppa->pp[index],
                    (ppa->cp - index) * sizeof(PVOID));
                }

            ppa->pp[index] = p;
            ppa->cp++;

            if (pindex)
                *pindex = index;
            }
        else if (pindex)
            {
            *pindex = PA_ERR;
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Delete a pointer from index.

Returns: the deleted pointer
         NULL (if index is out of range)

Cond:    --
*/
PVOID PUBLIC PADeletePtr(
    HPA ppa, 
    DWORD index)
    {
    PVOID p;

    ASSERT(IsPA(ppa));

    if (PA_ERR == index || index >= ppa->cp)
        {
        TRACE_MSG(TF_ERROR, "PA: Invalid index: %lu", index);
        return NULL;
        }

    p = ppa->pp[index];

    if (index < ppa->cp - 1)
        {
        hmemcpy(&ppa->pp[index], &ppa->pp[index + 1],
            (ppa->cp - (index + 1)) * sizeof(PVOID));
        }
    ppa->cp--;

    if (ppa->cpAlloc - ppa->cp > ppa->cpGrow)
        {
        PVOID * ppNew;
        ppNew = MemReAlloc(ppa->hheap, ppa->pp, (ppa->cpAlloc - ppa->cpGrow) * sizeof(PVOID));

        ASSERT(ppNew);
        ppa->pp = ppNew;
        ppa->cpAlloc -= ppa->cpGrow;
        }
    return p;
    }


/*----------------------------------------------------------
Purpose: Delete all the pointers in the array.  If pfnFree
         is non-NULL, this function will free each of the
         pointer elements in this array using pfnFree.

Returns: TRUE
         FALSE

Cond:    --
*/
BOOL PUBLIC PADeleteAllPtrsEx(
    HPA ppa,
    PFNPAFREE pfnFree,
    LPARAM lParam)
    {
    ASSERT(IsPA(ppa));

    if (ppa->pp)
        {
        if (pfnFree)
            {
            int i = PAGetCount(ppa);

            while (0 < i)
                {
                i--;
                pfnFree(PAFastGetPtr(ppa, i), lParam);
                }
            }

        if (!MemFree(ppa->hheap, ppa->pp))
            return FALSE;
        }
        
    ppa->pp = NULL;
    ppa->cp = ppa->cpAlloc = 0;
    return TRUE;
    }


#ifdef USEQUICKSORT
BOOL NEAR PAQuickSort2(
    DWORD i, 
    DWORD j, 
    SORTPARAMS FAR* psp)
    {
    PVOID * pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNPACOMPARE pfnCmp = psp->pfnCmp;

    DWORD iPivot;
    PVOID pFirst;
    DWORD k;
    int result;

    iPivot = PA_ERR;
    pFirst = pp[i];
    for (k = i + 1; k <= j; k++)
        {
        result = (*pfnCmp)(pp[k], pFirst, lParam);

        if (result > 0)
            {
            iPivot = k;
            break;
            }
        else if (result < 0)
            {
            iPivot = i;
            break;
            }
        }

    if (iPivot != PA_ERR)
        {
        DWORD l = i;
        DWORD r = j;
        PVOID pivot = pp[iPivot];

        do
            {
            PVOID p;

            p = pp[l];
            pp[l] = pp[r];
            pp[r] = p;

            while ((*pfnCmp)(pp[l], pivot, lParam) < 0)
                l++;
            while ((*pfnCmp)(pp[r], pivot, lParam) >= 0)
                r--;
            } 
            while (l <= r);

        if (l - 1 > i)
            PAQuickSort2(i, l - 1, psp);
        if (j > l)
            PAQuickSort2(l, j, psp);
        }
    return TRUE;
    }


BOOL NEAR PAQuickSort(
    SORTPARAMS FAR* psp)
    {
    return PAQuickSort2(0, psp->cp - 1, psp);
    }
#endif  // USEQUICKSORT

#ifdef USEHEAPSORT

void NEAR PAHeapSortPushDown(
    DWORD first, 
    DWORD last, 
    SORTPARAMS FAR* psp)
    {
    PVOID * pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNPACOMPARE pfnCmp = psp->pfnCmp;
    DWORD r;
    DWORD r2;

    r = first;
    while (r <= last / 2)
        {
        int wRTo2R;
        r2 = r * 2;

        wRTo2R = (*pfnCmp)(pp[r-1], pp[r2-1], lParam);

        if (r2 == last)
            {
            if (wRTo2R < 0)
                {
                Swap(pp[r-1], pp[r2-1]);
                }
            break;
            }
        else
            {
            int wR2toR21 = (*pfnCmp)(pp[r2-1], pp[r2+1-1], lParam);

            if (wRTo2R < 0 && wR2toR21 >= 0)
                {
                Swap(pp[r-1], pp[r2-1]);
                r = r2;
                }
            else if ((*pfnCmp)(pp[r-1], pp[r2+1-1], lParam) < 0 && wR2toR21 < 0)
                {
                Swap(pp[r-1], pp[r2+1-1]);
                r = r2 + 1;
                }
            else
                {
                break;
                }
            }
        }
    }


BOOL NEAR PAHeapSort(SORTPARAMS FAR* psp)
    {
    PVOID * pp = psp->pp;
    DWORD c = psp->cp;
    DWORD i;

    for (i = c / 2; i >= 1; i--)
        PAHeapSortPushDown(i, c, psp);

    for (i = c; i >= 2; i--)
        {
        Swap(pp[0], pp[i-1]);

        PAHeapSortPushDown(1, i - 1, psp);
        }
    return TRUE;
    }
#endif  // USEHEAPSORT

#if defined(MERGESORT) && defined(WIN32)

#define SortCompare(psp, pp1, i1, pp2, i2) \
    (psp->pfnCmp(pp1[i1], pp2[i2], psp->lParam))

//
//  This function merges two sorted lists and makes one sorted list.
//   psp->pp[iFirst, iFirst+cItes/2-1], psp->pp[iFirst+cItems/2, iFirst+cItems-1]
//
void NEAR PAMergeThem(
    SORTPARAMS FAR* psp, 
    DWORD iFirst, 
    DWORD cItems)
    {
    //
    // Notes:
    //  This function is separated from PAMergeSort2() to avoid comsuming
    // stack variables. Never inline this.
    //
    DWORD cHalf = cItems/2;
    DWORD iIn1, iIn2, iOut;
    LPVOID * ppvSrc = &psp->pp[iFirst];

    // Copy the first part to temp storage so we can write directly into
    // the final buffer.  Note that this takes at most psp->cp/2 DWORD's
    hmemcpy(psp->ppT, ppvSrc, cHalf*sizeof(LPVOID));

    for (iIn1=0, iIn2=cHalf, iOut=0;;)
        {
        if (SortCompare(psp, psp->ppT, iIn1, ppvSrc, iIn2) <= 0) 
            {
            ppvSrc[iOut++] = psp->ppT[iIn1++];

            if (iIn1==cHalf) 
                {
                // We used up the first half; the rest of the second half
                // should already be in place
                break;
                }
            } 
        else 
            {
            ppvSrc[iOut++] = ppvSrc[iIn2++];
            if (iIn2==cItems) 
                {
                // We used up the second half; copy the rest of the first half
                // into place
                hmemcpy(&ppvSrc[iOut], &psp->ppT[iIn1], (cItems-iOut)*sizeof(LPVOID));
                break;
                }
            }
        }
    }

//
//  This function sorts a give list (psp->pp[iFirst,iFirst-cItems-1]).
//
void NEAR PAMergeSort2(
    SORTPARAMS FAR* psp, 
    DWORD iFirst, 
    DWORD cItems)
    {
    //
    // Notes:
    //   This function is recursively called. Therefore, we should minimize
    //  the number of local variables and parameters. At this point, we
    //  use one local variable and three parameters.
    //
    DWORD cHalf;

    switch(cItems)
        {
    case 1:
        return;

    case 2:
        // Swap them, if they are out of order.
        if (SortCompare(psp, psp->pp, iFirst, psp->pp, iFirst+1) > 0)
            {
            psp->ppT[0] = psp->pp[iFirst];
            psp->pp[iFirst] = psp->pp[iFirst+1];
            psp->pp[iFirst+1] = psp->ppT[0];
            }
        break;

    default:
        cHalf = cItems/2;

        // Sort each half
        PAMergeSort2(psp, iFirst, cHalf);
        PAMergeSort2(psp, iFirst+cHalf, cItems-cHalf);

        // Then, merge them.
        PAMergeThem(psp, iFirst, cItems);
        break;
        }
    }


BOOL NEAR PAMergeSort(
    SORTPARAMS FAR* psp)
    {
    if (psp->cp == 0)
        return TRUE;

    // Note that we divide by 2 below; we want to round down
    psp->ppT = GAlloc(psp->cp/2 * sizeof(LPVOID));
    if (!psp->ppT)
        return FALSE;

    PAMergeSort2(psp, 0, psp->cp);
    GFree(psp->ppT);
    return TRUE;
    }
#endif // MERGESORT

/*----------------------------------------------------------
Purpose: Sort the array.

Returns: 
Cond:    --
*/
BOOL PUBLIC PASort(
    HPA ppa, 
    PFNPACOMPARE pfnCmp, 
    LPARAM lParam)
    {
    SORTPARAMS sp;

    sp.cp = ppa->cp;
    sp.pp = ppa->pp;
    sp.pfnCmp = pfnCmp;
    sp.lParam = lParam;

#ifdef USEQUICKSORT
    return PAQuickSort(&sp);
#endif
#ifdef USEHEAPSORT
    return PAHeapSort(&sp);
#endif
#ifdef MERGESORT
    return PAMergeSort(&sp);
#endif
    }


/*----------------------------------------------------------
Purpose: Search for pFind in array.

Returns: 
Cond:    --
*/
DWORD PUBLIC PASearch(
    HPA ppa, 
    PVOID pFind, 
    DWORD iStart,
    PFNPACOMPARE pfnCompare, 
    LPARAM lParam, 
    UINT options)
    {
    DWORD cp = PAGetCount(ppa);

    ASSERT(pfnCompare);
    ASSERT(PA_ERR != iStart);

    // Only allow these wierd flags if the list is sorted
    ASSERT((options & PAS_SORTED) || !(options & (PAS_INSERTBEFORE | PAS_INSERTAFTER)));

    if (!(options & PAS_SORTED))
        {
        // Not sorted: do linear search.
        DWORD i;

        for (i = iStart; i < cp; i++)
            {
            if (0 == pfnCompare(pFind, PAFastGetPtr(ppa, i), lParam))
                return i;
          }
        return PA_ERR;
        }
    else
        {
        // Search the array using binary search.  If several adjacent 
        // elements match the target element, the index of the first
        // matching element is returned.

        DWORD iRet = PA_ERR;      // assume no match
        BOOL bFound = FALSE;
        int nCmp = 0;
        DWORD iLow = 0;       // Don't bother using iStart for binary search
        DWORD iMid = 0;

        if (0 < cp)
            {
            DWORD iHigh = cp - 1;

            // (OK for cp == 0)
            while (iLow <= iHigh)
                {
                iMid = (iLow + iHigh) / 2;

                nCmp = pfnCompare(pFind, PAFastGetPtr(ppa, iMid), lParam);

                if (0 > nCmp)
                    {
                    // Account for the fact we are working with
                    // unsigned values
                    if (0 == iMid)
                        break;
                    iHigh = iMid - 1;       // First is smaller
                    }
                else if (0 < nCmp)
                    iLow = iMid + 1;        // First is larger
                else
                    {
                    // Match; search back for first match
                    bFound = TRUE;
                    while (0 < iMid)
                        {
                        if (0 != pfnCompare(pFind, PAFastGetPtr(ppa, iMid-1), lParam))
                            break;
                        else
                            iMid--;
                        }
                    break;
                    }
                }
            }

        if (bFound)
            {
            ASSERT(0 <= iMid);
            iRet = iMid;
            }

        // Did the search fail AND
        // is one of the strange search flags set?
        if (!bFound && (options & (PAS_INSERTAFTER | PAS_INSERTBEFORE)))
            {
            // Yes; return the index where the target should be inserted
            // if not found
            if (0 < nCmp)       // First is larger
                iRet = iLow;
            else
                iRet = iMid;
            // (We don't distinguish between the two flags anymore)
            }
        else if ( !(options & (PAS_INSERTAFTER | PAS_INSERTBEFORE)) )
            {
            // Sanity check with linear search
            ASSERT(PASearch(ppa, pFind, iStart, pfnCompare, lParam, options & ~PAS_SORTED) == iRet);
            }
        return iRet;
        }
    }

#endif // NODA

#endif // NOMEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\parser.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// parser.c
//
// This file contains the parsing functions.
//
// Conventions:
//
//   <Foo>      where Foo is a non-terminal
//   { Bar }    where there are 0 or more occurrences of Bar
//   "x"        where x is the literal character/string
//   CAPS       where CAPS is a token type
//
// The grammar is as follows:
//
//  <ModuleDecl>    ::= { <ProcDecl> }
//  <ProcDecl>      ::= proc IDENT { <VarDecl> } <StmtBlock> endproc
//  <VarDecl>       ::= <VarType> IDENT [ = <Expr> ]
//  <VarType>       ::= integer | string | boolean
//
//  <StmtBlock>     ::= { <Stmt> }
//  <Stmt>          ::= <HaltStmt> | <WaitforStmt> | <TransmitStmt> |
//                      <DelayStmt> | <SetStmt> | <LabelStmt> |
//                      <GotoStmt> | <AssignStmt> | <WhileStmt> |
//                      <IfStmt>
//
//  <HaltStmt>      ::= halt
//  <WaitforStmt>   ::= waitfor <Expr> [ , matchcase ]
//                       [ then IDENT 
//                          { , <Expr> [ , matchcase ] then IDENT } ]
//                       [ until <Expr> ]
//  <TransmitStmt>  ::= transmit <Expr> [ , raw ]
//  <DelayStmt>     ::= delay <Expr>
//  <SetStmt>       ::= set <SetParam>
//  <AssignStmt>    ::= IDENT = <Expr>
//  <LabelStmt>     ::= IDENT :
//  <GotoStmt>      ::= goto IDENT
//  <WhileStmt>     ::= while <Expr> do <StmtBlock> endwhile
//  <IfStmt>        ::= if <Expr> then <StmtBlock> endif
//
//  <SetParam>      ::= ipaddr <Expr> | port <PortData> |
//                      screen <ScreenSet>
//  <PortData>      ::= databits <DataBitsExpr> | parity <ParityExpr> |
//                      stopbits <StopBitsExpr>
//  <ScreenSet>     ::= keyboard <KeybrdExpr>
//
//  <ExprList>      ::= <Expr> { , <Expr> }
//  <Expr>          ::= <ConjExpr> { or <ConjExpr> }
//  <ConjExpr>      ::= <TestExpr> { and <TestExpr> }
//  <TestExpr>      ::= <Sum> <RelOp> <Sum> | <Sum>
//  <RelOp>         ::= <= | != | < | >= | > | ==
//  <Sum>           ::= <Term> { (+|-) <Term> }
//  <Term>          ::= <Factor> { (*|/) <Factor> }
//  <Factor>        ::= - <Factor> | INT | "(" <Expr> ")" | IDENT |
//                      STRING | <GetIPExpr> | "TRUE" | "FALSE" |
//                      ! <Factor>
//  <GetIPExpr>     ::= getip [ <Expr> ]
//
//  <DataBitsExpr>  ::= 5 | 6 | 7 | 8
//  <ParityExpr>    ::= none | odd | even | mark | space
//  <StopBitsExpr>  ::= 1 | 2
//  <KeybrdExpr>    ::= on | off
//
//
// History:
//  05-20-95 ScottH     Created
//


#include "proj.h"
#include "rcids.h"

RES     PRIVATE StmtBlock_Parse(HPA hpa, PSCANNER pscanner, PSYMTAB pstProc, SYM symEnd);


/*----------------------------------------------------------
Purpose: Parses the next token as an identifier.  If the 
         token is an identifier, it is returned in *pptok
         and the function returns RES_OK.

         Otherwise, *pptok is NULL and an error is returned.

Returns: RES_OK
         RES_E_IDENTMISSING

Cond:    The caller must destroy *pptok if RES_OK is returned.

*/
RES PRIVATE Ident_Parse(
    PSCANNER pscanner,
    PTOK * pptok)
    {
    RES res;
    PTOK ptok;

    *pptok = NULL;

    res = Scanner_GetToken(pscanner, &ptok);
    if (RSUCCEEDED(res))
        {
        if (SYM_IDENT == Tok_GetSym(ptok))
            {
            res = RES_OK;
            *pptok = ptok;
            }
        else
            {
            res = Scanner_AddError(pscanner, NULL, RES_E_IDENTMISSING);
            Tok_Delete(ptok);
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Adds an identifier to the symbol table.  If the 
         identifier has already been defined in this scope,
         this function adds the error to the error list,
         and returns the error value.

Returns: RES_OK

         RES_E_REDEFINED
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Ident_Add(
    LPCSTR pszIdent,
    DATATYPE dt,
    PTOK ptok,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;

    // Is this identifier unique?
    if (RES_OK == Symtab_FindEntry(pst, pszIdent, STFF_DEFAULT, NULL, NULL))
        {
        // No; we have a redefinition
        res = Scanner_AddError(pscanner, ptok, RES_E_REDEFINED);
        }
    else
        {
        // Yes; add to symbol table
        PSTE pste;

        res = STE_Create(&pste, pszIdent, dt);
        if (RSUCCEEDED(res))
            {
            res = Symtab_InsertEntry(pst, pste);
            }
        }

    return res;
    }


           

//
// Exprs
//

RES PRIVATE Expr_Parse(PEXPR * ppexpr, PSCANNER pscanner, PSYMTAB pst);


/*----------------------------------------------------------
Purpose: Look ahead to see if the next token indicates an
         expression of some kind.

Returns: TRUE if the next token is a leader to an expression

Cond:    --
*/
BOOL PRIVATE IsExprSneakPeek(
    PSCANNER pscanner)
    {
    BOOL bRet;
    SYM sym;

    Scanner_Peek(pscanner, &sym);
    switch (sym)
        {
    case SYM_MINUS:
    case SYM_NOT:
    case SYM_INT_LITERAL:
    case SYM_LPAREN:
    case SYM_STRING_LITERAL:
    case SYM_GETIP:
    case SYM_IDENT:
    case SYM_TRUE:
    case SYM_FALSE:
        bRet = TRUE;
        break;

    default:
        bRet = FALSE;
        break;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Parses a factor expression.

         Grammar is:

                <Factor>        ::= - <Factor> | INT | "(" <Expr> ")" | IDENT |
                                    STRING | <GetIPExpr> | TRUE | FALSE |
                                    ! <Factor>
                <GetIPExpr>     ::= getip [ <Expr> ]

Returns: RES_OK

Cond:    --
*/
RES PRIVATE FactorExpr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;
    PTOK ptok;
    DWORD iLine = Scanner_GetLine(pscanner);

    DBG_ENTER(FactorExpr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    if (RES_OK == Scanner_CondReadToken(pscanner, SYM_MINUS, NULL))
        {
        // Negation
        res = FactorExpr_Parse(&pexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            res = UnOpExpr_New(ppexpr, UOT_NEG, pexpr, iLine);

            if (RFAILED(res))
                Expr_Delete(pexpr);
            }
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_NOT, NULL))
        {
        // One's complement
        res = FactorExpr_Parse(&pexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            res = UnOpExpr_New(ppexpr, UOT_NOT, pexpr, iLine);

            if (RFAILED(res))
                Expr_Delete(pexpr);
            }
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_LPAREN, NULL))
        {
        // "("
        res = Expr_Parse(ppexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            if (RES_OK != Scanner_ReadToken(pscanner, SYM_RPAREN))
                {
                Expr_Delete(*ppexpr);

                res = Scanner_AddError(pscanner, NULL, RES_E_RPARENMISSING);
                }
            }
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_INT_LITERAL, &ptok))
        {
        // Integer literal
        res = IntExpr_New(ppexpr, TokInt_GetVal(ptok), iLine);

        Tok_Delete(ptok);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_STRING_LITERAL, &ptok))
        {
        res = StrExpr_New(ppexpr, TokSz_GetSz(ptok), iLine);

        Tok_Delete(ptok);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_TRUE, &ptok))
        {
        res = BoolExpr_New(ppexpr, TRUE, iLine);

        Tok_Delete(ptok);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_FALSE, &ptok))
        {
        res = BoolExpr_New(ppexpr, FALSE, iLine);

        Tok_Delete(ptok);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_IDENT, &ptok))
        {
        res = VarExpr_New(ppexpr, Tok_GetLexeme(ptok), iLine);

        Tok_Delete(ptok);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_GETIP, NULL))
        {
        // 'getip'

        // Parse optional nth parameter
        if (IsExprSneakPeek(pscanner))
            {
            res = Expr_Parse(&pexpr, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                res = UnOpExpr_New(ppexpr, UOT_GETIP, pexpr, iLine);
                }
            }
        else
            {
            // Default to 1st IP address
            res = IntExpr_New(&pexpr, 1, iLine);
            if (RSUCCEEDED(res))
                res = UnOpExpr_New(ppexpr, UOT_GETIP, pexpr, iLine);
            }
        }
    else
        res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);

    DBG_EXIT_RES(FactorExpr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses a term expression.

         Grammar is:

                <Term>          ::= <Factor> { (*|/) <Factor> }

Returns: RES_OK

Cond:    --
*/
RES PRIVATE TermExpr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr1;

    DBG_ENTER(TermExpr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    // Parse factor expression
    res = FactorExpr_Parse(&pexpr1, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        DWORD iLine = Scanner_GetLine(pscanner);
        PEXPR pexprTerm = pexpr1;
        SYM sym;

        // Parse optional factor operator
        Scanner_Peek(pscanner, &sym);

        while (SYM_MULT == sym || SYM_DIV == sym)
            {
            PEXPR pexpr2;

            Scanner_ReadToken(pscanner, sym);

            res = FactorExpr_Parse(&pexpr2, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                BINOPTYPE binoptype = sym - SYM_PLUS + BOT_PLUS;

                res = BinOpExpr_New(&pexprTerm, binoptype, pexpr1, pexpr2, iLine);

                if (RFAILED(res))
                    {
                    Expr_Delete(pexpr2);
                    break;
                    }
                }
            else
                break;

            pexpr1 = pexprTerm;
            Scanner_Peek(pscanner, &sym);
            }

        if (RFAILED(res))
            {
            Expr_Delete(pexpr1);            // pexpr1 by design
            pexprTerm = NULL;               // pexprTerm by design
            }

        *ppexpr = pexprTerm;
        }

    DBG_EXIT_RES(TermExpr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses a sum expression.

         Grammar is:

                <Sum>           ::= <Term> { (+|-) <Term> }

Returns: RES_OK

Cond:    --
*/
RES PRIVATE SumExpr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr1;

    DBG_ENTER(SumExpr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    // Parse term expression
    res = TermExpr_Parse(&pexpr1, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        DWORD iLine = Scanner_GetLine(pscanner);
        PEXPR pexprSum = pexpr1;
        SYM sym;

        // Parse optional sum operator
        Scanner_Peek(pscanner, &sym);

        while (SYM_PLUS == sym || SYM_MINUS == sym)
            {
            PEXPR pexpr2;

            Scanner_ReadToken(pscanner, sym);

            res = TermExpr_Parse(&pexpr2, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                BINOPTYPE binoptype = sym - SYM_PLUS + BOT_PLUS;

                res = BinOpExpr_New(&pexprSum, binoptype, pexpr1, pexpr2, iLine);

                if (RFAILED(res))
                    {
                    Expr_Delete(pexpr2);
                    break;
                    }
                }
            else
                break;

            pexpr1 = pexprSum;
            Scanner_Peek(pscanner, &sym);
            }

        if (RFAILED(res))
            {
            Expr_Delete(pexpr1);
            pexprSum = NULL;
            }

        *ppexpr = pexprSum;
        }

    DBG_EXIT_RES(SumExpr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses a test expression.

         Grammar is:

                <TestExpr>      ::= <Sum> <RelOp> <Sum> | <Sum>
                <RelOp>         ::= <= | != | < | >= | > | ==

Returns: RES_OK

Cond:    --
*/
RES PRIVATE TestExpr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;

    DBG_ENTER(TestExpr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    // Parse sum expression
    res = SumExpr_Parse(&pexpr, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        DWORD iLine = Scanner_GetLine(pscanner);
        PEXPR pexpr2;
        SYM sym;

        // Parse optional relational operator
        Scanner_Peek(pscanner, &sym);
        switch (sym)
            {
        case SYM_LEQ:
        case SYM_NEQ:
        case SYM_LT:
        case SYM_GEQ:
        case SYM_GT:
        case SYM_EQ:
            Scanner_ReadToken(pscanner, sym);

            res = SumExpr_Parse(&pexpr2, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                BINOPTYPE binoptype = sym - SYM_LEQ + BOT_LEQ;

                res = BinOpExpr_New(ppexpr, binoptype, pexpr, pexpr2, iLine);

                if (RFAILED(res))
                    Expr_Delete(pexpr2);
                }
            break;

        default:
            *ppexpr = pexpr;
            break;
            }

        if (RFAILED(res))
            Expr_Delete(pexpr);
        }

    DBG_EXIT_RES(TestExpr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses a conjunction expression.

         Grammar is:

            <ConjExpr>      ::= <TestExpr> { and <TestExpr> }

Returns: RES_OK

Cond:    --
*/
RES PRIVATE ConjExpr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr1;

    DBG_ENTER(ConjExpr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    // Parse test expression
    res = TestExpr_Parse(&pexpr1, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        DWORD iLine = Scanner_GetLine(pscanner);
        PEXPR pexprConj = pexpr1;
        SYM sym;

        Scanner_Peek(pscanner, &sym);

        while (SYM_AND == sym)
            {
            PEXPR pexpr2;

            Scanner_ReadToken(pscanner, sym);

            res = TestExpr_Parse(&pexpr2, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                res = BinOpExpr_New(&pexprConj, BOT_AND, pexpr1, pexpr2, iLine);

                if (RFAILED(res))
                    {
                    Expr_Delete(pexpr2);
                    break;
                    }
                }
            else
                break;

            pexpr1 = pexprConj;
            Scanner_Peek(pscanner, &sym);
            }

        if (RFAILED(res))
            {
            Expr_Delete(pexpr1);
            pexprConj = NULL;
            }

        *ppexpr = pexprConj;
        }

    DBG_EXIT_RES(ConjExpr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses an expression.

         Grammar is:

            <Expr>          ::= <ConjExpr> { or <ConjExpr> }

Returns: RES_OK

Cond:    --
*/
RES PRIVATE Expr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr1;

    DBG_ENTER(Expr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    // Parse conjunction expression
    res = ConjExpr_Parse(&pexpr1, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        DWORD iLine = Scanner_GetLine(pscanner);
        PEXPR pexprDisj = pexpr1;
        SYM sym;

        // Parse optional 'or'
        Scanner_Peek(pscanner, &sym);

        while (SYM_OR == sym)
            {
            PEXPR pexpr2;

            Scanner_ReadToken(pscanner, sym);

            res = ConjExpr_Parse(&pexpr2, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                res = BinOpExpr_New(&pexprDisj, BOT_OR, pexpr1, pexpr2, iLine);

                if (RFAILED(res))
                    {
                    Expr_Delete(pexpr2);
                    break;
                    }
                }
            else
                break;

            pexpr1 = pexprDisj;
            Scanner_Peek(pscanner, &sym);
            }

        if (RFAILED(res))
            {
            Expr_Delete(pexpr1);
            pexprDisj = NULL;
            }

        *ppexpr = pexprDisj;
        }

    DBG_EXIT_RES(Expr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'set port' statement

         Grammar is:

            <PortData>      ::= databits <DataBitsExpr> | parity <ParityExpr> |
                                stopbits <StopBitsExpr>

            <DataBitsExpr>  ::= 5 | 6 | 7 | 8
            <ParityExpr>    ::= none | odd | even | mark | space
            <StopBitsExpr>  ::= 1 | 2

Returns: RES_OK

Cond:    --
*/
RES PRIVATE PortData_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine = Scanner_GetLine(pscanner);
    PORTSTATE ps;
    PTOK ptok;

    DBG_ENTER(PortData_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);

    // Parse 'databits'
    if (RES_OK == Scanner_CondReadToken(pscanner, SYM_DATABITS, NULL))
        {
        ps.dwFlags = SPF_DATABITS;

        // Parse 5 | 6 | 7 | 8

        res = Scanner_GetToken(pscanner, &ptok);
        if (RSUCCEEDED(res))
            {
            if (TT_INT == Tok_GetType(ptok))
                {
                DWORD dwVal = TokInt_GetVal(ptok);

                if (InRange(dwVal, 5, 8))
                    {
                    // Create object
                    ps.nDatabits = LOBYTE(LOWORD(dwVal));

                    res = SetPortStmt_New(ppstmt, &ps, iLine);
                    }
                else
                    res = Scanner_AddError(pscanner, ptok, RES_E_INVALIDRANGE);
                }
            else
                res = Scanner_AddError(pscanner, ptok, RES_E_SYNTAXERROR);

            Tok_Delete(ptok);
            }
        else
            res = Scanner_AddError(pscanner, ptok, RES_E_INTMISSING);
        }

    // Parse 'parity'
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_PARITY, NULL))
        {
        SYM sym;

        ps.dwFlags = SPF_PARITY;

        res = RES_OK;       // assume success

        Scanner_Peek(pscanner, &sym);
        switch (sym)
            {
        case SYM_NONE:
            ps.nParity = NOPARITY;
            break;

        case SYM_ODD:
            ps.nParity = ODDPARITY;
            break;

        case SYM_EVEN:
            ps.nParity = EVENPARITY;
            break;

        case SYM_MARK:
            ps.nParity = MARKPARITY;
            break;

        case SYM_SPACE:
            ps.nParity = SPACEPARITY;
            break;

        default:
            res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            break;
            }

        if (RES_OK == res)
            {
            res = SetPortStmt_New(ppstmt, &ps, iLine);

            // eat token
            Scanner_GetToken(pscanner, &ptok);
            Tok_Delete(ptok);
            }
        }

    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_STOPBITS, NULL))
        {
        PTOK ptok_scan;

        ps.dwFlags = SPF_STOPBITS;

        // Parse 1 | 2

        res = Scanner_GetToken(pscanner, &ptok_scan);
        if (RSUCCEEDED(res))
            {
            if (TT_INT == Tok_GetType(ptok_scan))
                {
                DWORD dwVal = TokInt_GetVal(ptok_scan);

                if (InRange(dwVal, 1, 2))
                    {
                    // Create object
                    ps.nStopbits = LOBYTE(LOWORD(dwVal));

                    res = SetPortStmt_New(ppstmt, &ps, iLine);
                    }
                else
                    res = Scanner_AddError(pscanner, ptok_scan, RES_E_INVALIDRANGE);
                }
            else
                res = Scanner_AddError(pscanner, ptok_scan, RES_E_SYNTAXERROR);

            Tok_Delete(ptok_scan);
            }
        else
            res = Scanner_AddError(pscanner, ptok_scan, RES_E_INTMISSING);
        }

    else
        res = Scanner_AddError(pscanner, NULL, RES_E_INVALIDPORTPARAM);

    DBG_EXIT_RES(PortData_Parse, res);

    return res;
    }

/*----------------------------------------------------------
Purpose: Parses the 'set screen' statement

         Grammar is:

            <ScreenSet>     ::= keyboard <KeybrdExpr>

            <KeybrdExpr>    ::= on | off

Returns: RES_OK

Cond:    --
*/
RES PRIVATE ScreenSet_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine = Scanner_GetLine(pscanner);
    SCREENSET ss;
    PTOK ptok;

    DBG_ENTER(ScreenSet_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);

    // Parse 'keyboard'
    if (RES_OK == Scanner_CondReadToken(pscanner, SYM_KEYBRD, NULL))
        {
        SYM sym;

        ss.dwFlags = SPF_KEYBRD;

        res = RES_OK;       // assume success

        Scanner_Peek(pscanner, &sym);
        switch (sym)
            {
        case SYM_ON:
            ss.fKBOn = TRUE;
            break;

        case SYM_OFF:
            ss.fKBOn = FALSE;
            break;

        default:
            res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            break;
            }

        if (RES_OK == res)
            {
            res = SetScreenStmt_New(ppstmt, &ss, iLine);

            // eat token
            Scanner_GetToken(pscanner, &ptok);
            Tok_Delete(ptok);
            }
        }
    else
        res = Scanner_AddError(pscanner, NULL, RES_E_INVALIDSCRNPARAM);

    DBG_EXIT_RES(ScreenSet_Parse, res);

    return res;
    }


// 
// Stmt
//


/*----------------------------------------------------------
Purpose: Parse the case-portion of the 'waitfor' statement.
         This portion is:

                 <Expr> [ , matchcase ] [ then IDENT ]

         and:

                 <Expr> [ , matchcase ] then IDENT

         Set bThenOptional to TRUE to parse the first case,
         FALSE to parse the second case.

Returns: RES_OK
         RES_FALSE (if bThenOptional and "[ then IDENT ]" was not parsed)

Cond:    --
*/
RES PUBLIC WaitforStmt_ParseCase(
    HSA hsa,
    PSCANNER pscanner,
    PSYMTAB pst,
    BOOL bThenOptional)
    {
    RES res;
    PEXPR pexpr;

    // Parse string expression
    res = Expr_Parse(&pexpr, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        BOOL bParseThen;
        DWORD dwFlags = WCF_DEFAULT;

        // Parse optional ", matchcase"
        if (RES_OK == Scanner_CondReadToken(pscanner, SYM_COMMA, NULL))
            {
            if (RES_OK == Scanner_ReadToken(pscanner, SYM_MATCHCASE))
                SetFlag(dwFlags, WCF_MATCHCASE);
            else
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            }

        // Is 'then IDENT' optional?
        if (bThenOptional)
            {
            // Yes; determine whether to parse it
            SYM sym;

            Scanner_Peek(pscanner, &sym);
            bParseThen = (SYM_THEN == sym);
            if (!bParseThen)
                res = RES_FALSE;
            }
        else
            {
            // No; we don't have a choice, parse it
            bParseThen = TRUE;
            }

        if (bParseThen)
            {
            res = Scanner_ReadToken(pscanner, SYM_THEN);
            if (RSUCCEEDED(res))
                {
                PTOK ptok;

                // Parse identifier
                res = Ident_Parse(pscanner, &ptok);
                if (RSUCCEEDED(res))
                    {
                    // (Wait until typechecking phase to check for 
                    // existence of identifier)
                    LPSTR pszIdent = Tok_GetLexeme(ptok);

                    // Add this case to the list
                    res = Waitcase_Add(hsa, pexpr, pszIdent, dwFlags);

                    Tok_Delete(ptok);
                    }   
                }
            else
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            }
        else
            {
            // Add this case to the list
            res = Waitcase_Add(hsa, pexpr, NULL, dwFlags);
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'waitfor' statement

         Grammar is:

            <WaitforStmt>   ::= waitfor <Expr> [ , matchcase ]
                                 [ then IDENT 
                                    { , <Expr> [ , matchcase ] then IDENT } ]
                                 [ until <Expr> ]

Returns: RES_OK

Cond:    --
*/
RES PRIVATE WaitforStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine;
    HSA hsa;

    DBG_ENTER(WaitforStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);
    *ppstmt = NULL;

    // Parse 'waitfor'
    res = Scanner_ReadToken(pscanner, SYM_WAITFOR);
    ASSERT(RES_OK == res);

    res = Waitcase_Create(&hsa);
    if (RSUCCEEDED(res))
        {
        // Parse <Expr> [ , matchcase ] [ then IDENT { , <Expr> [ , matchcase ] then IDENT } ]

        // (Note we explicitly check for RES_OK only)
        res = WaitforStmt_ParseCase(hsa, pscanner, pst, TRUE);
        if (RES_OK == res)
            {
            // Parse { , <Expr> then IDENT }
            while (RES_OK == Scanner_CondReadToken(pscanner, SYM_COMMA, NULL))
                {
                res = WaitforStmt_ParseCase(hsa, pscanner, pst, FALSE);
                if (RFAILED(res))
                    break;
                }
            }

        if (RSUCCEEDED(res))
            {
            PEXPR pexprUntil = NULL;

            // Parse optional 'until <Expr>'
            if (RES_OK == Scanner_CondReadToken(pscanner, SYM_UNTIL, NULL))
                {
                res = Expr_Parse(&pexprUntil, pscanner, pst);
                }

            if (RSUCCEEDED(res))
                {
                // Create object
                res = WaitforStmt_New(ppstmt, hsa, pexprUntil, iLine);
                }
            }

        if (RFAILED(res))
            Waitcase_Destroy(hsa);
        }

    DBG_EXIT_RES(WaitforStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'transmit' statement

         Grammar is:

            <TransmitStmt>  ::= transmit <Expr> [ , raw ]

Returns: RES_OK

Cond:    --
*/
RES PRIVATE TransmitStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;
    DWORD iLine;
    DWORD dwFlags = TSF_DEFAULT;

    DBG_ENTER(TransmitStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);
    *ppstmt = NULL;

    // Parse 'transmit'
    res = Scanner_ReadToken(pscanner, SYM_TRANSMIT);
    ASSERT(RES_OK == res);

    // Parse string expression
    res = Expr_Parse(&pexpr, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        // Parse optional ", raw" parameter
        if (RES_OK == Scanner_CondReadToken(pscanner, SYM_COMMA, NULL))
            {
            if (RSUCCEEDED(Scanner_ReadToken(pscanner, SYM_RAW)))
                SetFlag(dwFlags, TSF_RAW);
            else
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            }

        if (RSUCCEEDED(res))
            {
            // Create object
            res = TransmitStmt_New(ppstmt, pexpr, dwFlags, iLine);
            }
        }
    else
        res = Scanner_AddError(pscanner, NULL, RES_E_STRINGMISSING);

    DBG_EXIT_RES(TransmitStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'delay' statement

         Grammar is:

            <DelayStmt>     ::= delay <Expr>

Returns: RES_OK

Cond:    --
*/
RES PRIVATE DelayStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;
    DWORD iLine = Scanner_GetLine(pscanner);

    DBG_ENTER(DelayStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    *ppstmt = NULL;

    // Parse 'delay'
    res = Scanner_ReadToken(pscanner, SYM_DELAY);
    ASSERT(RES_OK == res);

    // Parse expression
    res = Expr_Parse(&pexpr, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        res = DelayStmt_New(ppstmt, pexpr, iLine);
        }

    DBG_EXIT_RES(DelayStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'while' statement

         Grammar is:

            <WhileStmt>     ::= while <Expr> do <StmtBlock> endwhile

Returns: RES_OK

Cond:    --
*/
RES PRIVATE WhileStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;
    DWORD iLine;
    HPA hpa;

    DBG_ENTER(WhileStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);
    *ppstmt = NULL;

    if (PACreate(&hpa, 8))
        {
        // Parse 'while'
        res = Scanner_ReadToken(pscanner, SYM_WHILE);
        ASSERT(RES_OK == res);

        // Parse <Expr>
        res = Expr_Parse(&pexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            // Parse 'do'
            res = Scanner_ReadToken(pscanner, SYM_DO);
            if (RSUCCEEDED(res))
                {
                char szTop[MAX_BUF_KEYWORD];
                char szEnd[MAX_BUF_KEYWORD];

                // Generate unique label names
                res = Symtab_NewLabel(pst, szTop);
                if (RSUCCEEDED(res))
                    {
                    res = Symtab_NewLabel(pst, szEnd);
                    if (RSUCCEEDED(res))
                        {
                        // Parse statement block
                        res = StmtBlock_Parse(hpa, pscanner, pst, SYM_ENDWHILE);

                        if (RSUCCEEDED(res))
                            {
                            PSTMT pstmtT;

                            // Add a goto statement to loop to the top again
                            res = GotoStmt_New(&pstmtT, szTop, Scanner_GetLine(pscanner));
                            if (RSUCCEEDED(res))
                                {
                                if (!PAInsertPtr(hpa, PA_APPEND, pstmtT))
                                    res = RES_E_OUTOFMEMORY;
                                else
                                    {
                                    // Create object
                                    res = WhileStmt_New(ppstmt, pexpr, hpa, szTop, szEnd, iLine);
                                    }
                                }
                            }
                        }
                    }
                }
            else
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            }
        }
    else
        res = RES_E_OUTOFMEMORY;


    DBG_EXIT_RES(WhileStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'if' statement

         Grammar is:

            <IfStmt>        ::= if <Expr> then <StmtBlock> endif

Returns: RES_OK

Cond:    --
*/
RES PRIVATE IfStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;
    DWORD iLine;
    HPA hpa;

    DBG_ENTER(IfStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);
    *ppstmt = NULL;

    if (PACreate(&hpa, 8))
        {
        // Parse 'if'
        res = Scanner_ReadToken(pscanner, SYM_IF);
        ASSERT(RES_OK == res);

        // Parse <Expr>
        res = Expr_Parse(&pexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            // Parse 'then'
            res = Scanner_ReadToken(pscanner, SYM_THEN);
            if (RFAILED(res))
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            }
        }
    else
        res = RES_E_OUTOFMEMORY;


    if (RSUCCEEDED(res))
        {
        char szElse[MAX_BUF_KEYWORD];
        char szEnd[MAX_BUF_KEYWORD];

        // Generate unique label names
        res = Symtab_NewLabel(pst, szElse);
        if (RSUCCEEDED(res))
            {
            res = Symtab_NewLabel(pst, szEnd);
            if (RSUCCEEDED(res))
                {
                // Parse statement block for the 'then' block
                res = StmtBlock_Parse(hpa, pscanner, pst, SYM_ENDIF);
                if (RSUCCEEDED(res))
                    {
                    // Create object
                    res = IfStmt_New(ppstmt, pexpr, hpa, szElse, szEnd, iLine);
                    }
                }
            }
        }

    DBG_EXIT_RES(IfStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'halt' statement

         Grammar is:

            <HaltStmt>      ::= halt

Returns: RES_OK

Cond:    --
*/
RES PRIVATE HaltStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine = Scanner_GetLine(pscanner);

    DBG_ENTER(HaltStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    *ppstmt = NULL;

    // Parse 'halt'
    res = Scanner_ReadToken(pscanner, SYM_HALT);
    ASSERT(RES_OK == res);

    // Create object
    res = HaltStmt_New(ppstmt, iLine);

    DBG_EXIT_RES(HaltStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the assignment statement

         Grammar is:

            <AssignStmt>    ::= IDENT = <Expr>

Returns: RES_OK

Cond:    --
*/
RES PRIVATE AssignStmt_Parse(
    PSTMT * ppstmt,
    PTOK ptok,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine;
    PEXPR pexpr;

    DBG_ENTER(AssignStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(ptok);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);

    // (We already have the IDENT in the ptok passed in.  We
    // also already parsed the '='.  Skip parsing these.)

    // Parse <Expr>
    res = Expr_Parse(&pexpr, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        // (Wait until typechecking phase to check for existence
        // of identifier)
        LPSTR pszIdent = Tok_GetLexeme(ptok);

        // Create object
        res = AssignStmt_New(ppstmt, pszIdent, pexpr, iLine);
        }

    DBG_EXIT_RES(AssignStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the label statement

         Grammar is:

            <LabelStmt>     ::= IDENT :

Returns: RES_OK

Cond:    --
*/
RES PRIVATE LabelStmt_Parse(
    PSTMT * ppstmt,
    PTOK ptok,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine;
    LPSTR pszIdent;

    DBG_ENTER(LabelStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(ptok);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);

    pszIdent = Tok_GetLexeme(ptok);

    res = Ident_Add(pszIdent, DATA_LABEL, ptok, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        // Create label object
        res = LabelStmt_New(ppstmt, pszIdent, iLine);
        }
        
    DBG_EXIT_RES(LabelStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'goto' statement

         Grammar is:

            <GotoStmt>      ::= goto IDENT

Returns: RES_OK

Cond:    --
*/
RES PRIVATE GotoStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine = Scanner_GetLine(pscanner);
    PTOK ptok;

    DBG_ENTER(GotoStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    // Parse 'goto'
    res = Scanner_ReadToken(pscanner, SYM_GOTO);
    ASSERT(RES_OK == res);

    // Parse identifier
    res = Ident_Parse(pscanner, &ptok);
    if (RSUCCEEDED(res))
        {
        // (Wait until typechecking phase to check for existence
        // of identifier)
        LPSTR pszIdent = Tok_GetLexeme(ptok);

        // Create object
        res = GotoStmt_New(ppstmt, pszIdent, iLine);

        Tok_Delete(ptok);
        }

    DBG_EXIT_RES(GotoStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'set' statement

         Grammar is:

            <SetStmt>       ::= set <SetParam>
            <SetParam>      ::= ipaddr <Expr> | port <PortData> |
                                screen <ScreenSet>

Returns: RES_OK

Cond:    --
*/
RES PRIVATE SetStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;

    DBG_ENTER(SetStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    *ppstmt = NULL;

    // Parse 'set'
    res = Scanner_ReadToken(pscanner, SYM_SET);
    ASSERT(RES_OK == res);

    // Parse set parameter
    if (RES_OK == Scanner_CondReadToken(pscanner, SYM_IPADDR, NULL))
        {
        // Parse <Expr>
        PEXPR pexpr;
        DWORD iLine = Scanner_GetLine(pscanner);

        res = Expr_Parse(&pexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            res = SetIPStmt_New(ppstmt, pexpr, iLine);
            }
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_PORT, NULL))
        {
        res = PortData_Parse(ppstmt, pscanner, pst);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_SCREEN, NULL))
        {
        res = ScreenSet_Parse(ppstmt, pscanner, pst);
        }
    else
        {
        res = Scanner_AddError(pscanner, NULL, RES_E_INVALIDSETPARAM);
        }

    DBG_EXIT_RES(SetStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses a statement.

         Grammar is:

            <Stmt>          ::= <HaltStmt> | <WaitforStmt> | <TransmitStmt> |
                                <DelayStmt> | <SetStmt> | <LabelStmt> |
                                <GotoStmt> | <AssignStmt> | <WhileStmt> |
                                <IfStmt>

Returns: RES_OK

Cond:    --
*/
RES PRIVATE Stmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    SYM sym;
    PTOK ptok;

    DBG_ENTER(Stmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    *ppstmt = NULL;

    Scanner_Peek(pscanner, &sym);
    switch (sym)
        {
    case SYM_WHILE:
        res = WhileStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_IF:
        res = IfStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_WAITFOR:
        res = WaitforStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_TRANSMIT:
        res = TransmitStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_DELAY:
        res = DelayStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_HALT:
        res = HaltStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_SET:
        res = SetStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_IDENT:
        // This can be a label or an assignment
        res = Scanner_GetToken(pscanner, &ptok);
        ASSERT(RES_OK == res);

        if (RSUCCEEDED(res))
            {
            // Is this a label?
            if (RES_OK == Scanner_CondReadToken(pscanner, SYM_COLON, NULL))
                {
                // Yes
                res = LabelStmt_Parse(ppstmt, ptok, pscanner, pst);
                }
            // Is this an assignment?
            else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_ASSIGN, NULL))
                {
                // Yes
                res = AssignStmt_Parse(ppstmt, ptok, pscanner, pst);
                }
            else
                {
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
                }
            Tok_Delete(ptok);
            }
        break;

    case SYM_GOTO:
        res = GotoStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_EOF:
        res = Scanner_AddError(pscanner, NULL, RES_E_EOFUNEXPECTED);
        break;

    default:
        res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
        break;
        }
    
    DBG_EXIT_RES(Stmt_Parse, res);

    return res;
    }


// 
// ProcDecl
//


/*----------------------------------------------------------
Purpose: Parse the variable declarations for the proc decl.

         Grammar is:

            <VarDecl>       ::= <VarType> IDENT [ = <Expr> ]
            <VarType>       ::= integer | string | boolean

Returns: RES_OK
Cond:    --
*/
RES PRIVATE ProcDecl_ParseVarDecl(
    HPA hpa,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res = RES_OK;
    PTOK ptok;
    DATATYPE dt;

    // Parse the variable decl block
    while (RES_OK == res)
        {
        SYM sym;

        Scanner_Peek(pscanner, &sym);
        switch (sym)
            {
        case SYM_BOOLEAN:
        case SYM_STRING:
        case SYM_INTEGER:
            if (RES_OK == Scanner_CondReadToken(pscanner, SYM_INTEGER, NULL))
                dt = DATA_INT;
            else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_STRING, NULL))
                dt = DATA_STRING;
            else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_BOOLEAN, NULL))
                dt = DATA_BOOL;
            else
                ASSERT(0);

            res = Ident_Parse(pscanner, &ptok);
            if (RSUCCEEDED(res))
                {
                LPSTR pszIdent = Tok_GetLexeme(ptok);

                res = Ident_Add(pszIdent, dt, ptok, pscanner, pst);

                // Parse optional '= <Expr>'
                if (RES_OK == Scanner_CondReadToken(pscanner, SYM_ASSIGN, NULL))
                    {
                    PEXPR pexpr;
                    PSTMT pstmt;
                    DWORD iLine = Scanner_GetLine(pscanner);

                    res = Expr_Parse(&pexpr, pscanner, pst);
                    if (RSUCCEEDED(res))
                        {
                        res = AssignStmt_New(&pstmt, pszIdent, pexpr, iLine);
                        if (RSUCCEEDED(res))
                            {
                            if (!PAInsertPtr(hpa, PA_APPEND, pstmt))
                                res = RES_E_OUTOFMEMORY;
                            }
                        }
                    }

                Tok_Delete(ptok);
                }
            break;

        default:
            // Continue on with further parsing
            res = RES_FALSE;
            break;
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Parse a statement block

Returns: RES_OK
Cond:    --
*/
RES PRIVATE StmtBlock_Parse(
    HPA hpa,
    PSCANNER pscanner,
    PSYMTAB pstProc,
    SYM symEnd)
    {
    RES res = RES_OK;

    // Parse the statement block
    while (RES_OK == res)
        {
        SYM sym;
        PSTMT pstmt;

        Scanner_Peek(pscanner, &sym);
        switch (sym)
            {
        case SYM_EOF:
            res = Scanner_AddError(pscanner, NULL, RES_E_EOFUNEXPECTED);
            break;

        default:
            // Is this the end of the block?
            if (symEnd == sym)
                {
                // Yes
                Scanner_ReadToken(pscanner, symEnd);
                res = RES_FALSE;
                }
            else
                {
                // No
                res = Stmt_Parse(&pstmt, pscanner, pstProc);
                if (RSUCCEEDED(res))
                    {
                    if (!PAInsertPtr(hpa, PA_APPEND, pstmt))
                        res = RES_E_OUTOFMEMORY;
                    }
                }
            break;
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Work function that parses the proc declaration.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE ProcDecl_PrivParse(
    PPROCDECL * ppprocdecl,
    PSCANNER pscanner,
    HPA hpa,
    PSYMTAB pstProc,
    PSYMTAB pst)
    {
    RES res;
    PTOK ptok;
    DWORD iLine = Scanner_GetLine(pscanner);

    // Parse 'proc'
    res = Scanner_ReadToken(pscanner, SYM_PROC);
    ASSERT(RES_OK == res);

    // Parse the proc name 
    res = Scanner_GetToken(pscanner, &ptok);
    if (RSUCCEEDED(res))
        {
        if (SYM_IDENT == Tok_GetSym(ptok))
            {
            LPCSTR pszIdent = Tok_GetLexeme(ptok);

            // Add the identifier to the symbol table
            res = Ident_Add(pszIdent, DATA_PROC, ptok, pscanner, pst);
           
            // Parse the variable declaration block
            if (RSUCCEEDED(res))
                res = ProcDecl_ParseVarDecl(hpa, pscanner, pstProc);

            // Parse the statement block
            if (RSUCCEEDED(res))
                res = StmtBlock_Parse(hpa, pscanner, pstProc, SYM_ENDPROC);

            if (RSUCCEEDED(res))
                {
                // Create object
                PDECL pdecl;

                res = ProcDecl_New(&pdecl, pszIdent, hpa, pstProc, iLine);

                *ppprocdecl = (PPROCDECL)pdecl;
                }
            }
        else
            res = Scanner_AddError(pscanner, ptok, RES_E_IDENTMISSING);

        Tok_Delete(ptok);
        }
    else
        res = Scanner_AddError(pscanner, NULL, RES_E_IDENTMISSING);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the proc declaration

         Grammar is:

            <ProcDecl>      ::= proc IDENT { <VarDecl> } <StmtBlock> endproc
            <StmtBlock>     ::= {<Stmt>}*

Returns: RES_OK

Cond:    --
*/
RES PRIVATE ProcDecl_Parse(
    PPROCDECL * ppprocdecl,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    HPA hpa;
    PSYMTAB pstProc;

    DBG_ENTER(ProcDecl_Parse);

    ASSERT(ppprocdecl);
    ASSERT(pscanner);

    *ppprocdecl = NULL;

    if (PACreate(&hpa, 8))
        {
        res = Symtab_Create(&pstProc, pst);
        if (RSUCCEEDED(res))
            {
            PSTMT pstmtT;
            DWORD iLine = Scanner_GetLine(pscanner);

            // Add the prolog
            res = EnterStmt_New(&pstmtT, pstProc, iLine);
            if (RSUCCEEDED(res))
                {
                if (!PAInsertPtr(hpa, PA_APPEND, pstmtT))
                    {
                    res = RES_E_OUTOFMEMORY;
                    Stmt_Delete(pstmtT);
                    }
                else
                    {
                    res = ProcDecl_PrivParse(ppprocdecl, pscanner, hpa, pstProc, pst);
                    if (RSUCCEEDED(res))
                        {
                        // Add the epilog
                        res = LeaveStmt_New(&pstmtT, Scanner_GetLine(pscanner));
                        if (RSUCCEEDED(res))
                            {
                            if (!PAInsertPtr(hpa, PA_APPEND, pstmtT))
                                {
                                res = RES_E_OUTOFMEMORY;
                                Stmt_Delete(pstmtT);
                                }
                            }
                        }
                    }
                }

            // Did something fail up above?
            if (RFAILED(res))
                {
                // Yes; cleanup
                Symtab_Destroy(pstProc);
                }
            }

        // Clean up
        if (RFAILED(res))
            PADestroyEx(hpa, Stmt_DeletePAPtr, 0);
        }
    else
        res = RES_E_OUTOFMEMORY;
    
    DBG_EXIT_RES(ProcDecl_Parse, res);

    return res;
    }


// 
// ModuleDecl
//


/*----------------------------------------------------------
Purpose: Parses the script at the module level.

         Grammar is:

            <ModuleDecl>    ::= {<ProcDecl>}*

Returns: RES_OK

         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC ModuleDecl_Parse(
    PMODULEDECL * ppmoduledecl,
    PSCANNER pscanner,
    PSYMTAB pstSystem)          // May be NULL
    {
    RES res = RES_OK;
    HPA hpa;

    DBG_ENTER(ModuleDecl_Parse);

    ASSERT(ppmoduledecl);
    ASSERT(pscanner);

    TRACE_MSG(TF_GENERAL, "Parsing...");

    *ppmoduledecl = NULL;

    if (PACreate(&hpa, 8))
        {
        PSYMTAB pst;
        PDECL pdecl = NULL;

        res = Symtab_Create(&pst, pstSystem);
        if (RSUCCEEDED(res))
            {
            // Parse the module block
            while (RES_OK == res)
                {
                SYM sym;

                Scanner_Peek(pscanner, &sym);

                switch (sym)
                    {
                case SYM_EOF:
                    res = RES_FALSE;        // Time to stop
                    break;

                case SYM_PROC:
                    {
                    PPROCDECL pprocdecl;

                    res = ProcDecl_Parse(&pprocdecl, pscanner, pst);
                    if (RSUCCEEDED(res))
                        {
                        if (!PAInsertPtr(hpa, PA_APPEND, pprocdecl))
                            res = RES_E_OUTOFMEMORY;
                        }
                    }
                    break;

                default:
                    res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
                    break;
                    }
                }

            if (RSUCCEEDED(res))
                {
                DWORD iLine = Scanner_GetLine(pscanner);

                res = ModuleDecl_New(&pdecl, hpa, pst, iLine);

#ifdef DEBUG
                if (RSUCCEEDED(res))
                    Ast_Dump((PAST)pdecl);
#endif
                }

            // Clean up after parsing
            if (RSUCCEEDED(res))
                PADestroy(hpa);     // keep pointer elements allocated for pdecl
            else
                {
                // Something failed

                PADestroyEx(hpa, Decl_DeletePAPtr, 0);
                
                Symtab_Destroy(pst);

                // Parse errors were added to the scanner's list
                // of errors already.  However, errors such as 
                // out of memory still need to be added.
                if (FACILITY_PARSE != RFACILITY(res))
                    Scanner_AddError(pscanner, NULL, res);
                }

            // Now typecheck the script
            if (pdecl)
                {
                res = ModuleDecl_Typecheck((PMODULEDECL)pdecl, Scanner_GetStxerrHandle(pscanner));
                if (RFAILED(res))
                    {
                    Decl_Delete(pdecl);
                    pdecl = NULL;
                    }
                }
            }

        *ppmoduledecl = (PMODULEDECL)pdecl;
        }
    else
        res = RES_E_OUTOFMEMORY;
    
    DBG_EXIT_RES(ModuleDecl_Parse, res);

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\nthdr2.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    nthdr2.h
//
// History:
//  Abolade-Gbadegesin  04-02-96    Created.
//
// This file contains macros to hide differences in implementation
// of the scripting between Win9x and Windows NT
//============================================================================

#ifndef _NTHDR2_H_
#define _NTHDR2_H_


//----------------------------------------------------------------------------
// Struct:      SCRIPTDATA
//
// The following structure is designed to be a subset of the TERMDLG struct
// in terminal.c.
//
// The structure has fields whose names are the same as corresponding fields
// in the TERMDLG struct. The only fields reproduced here are those which
// pertain to the Win9x script-processing.
//
// This is done in order to minimize changes to the Win9x code, since
// we can then pass the structure below to ReadIntoBuffer() and FindFormat(),
// thankfully eliminating the need to edit the code for either function.
//----------------------------------------------------------------------------

#define SCRIPTDATA  struct tagSCRIPTDATA
SCRIPTDATA {

    //
    // Handle to script for this SCRIPTDATA,
    // and current timeout, if any
    //
    HANDLE          hscript;
    DWORD           dwTimeout;


    //
    // Send and receive buffers
    //
    BYTE            pbReceiveBuf[SIZE_RecvBuffer];
    BYTE            pbSendBuf[SIZE_SendBuffer];


    //
    // Current search position index
    // 
    UINT            ibCurFind;


    //
    // Pointer to tail of buffer (into which new data will be read)
    //
    UINT            ibCurRead;


    //
    // Count of total bytes received since the session began
    //
    UINT            cbReceiveMax;


    //
    // Variables containing the script-processing control information;
    //  the scanner which reads the script file,
    //  the parsed module-declaration containing the "main" procedure,
    //  the script-execution handler control block,
    //  and the script information (including the path)
    //
    SCANNER*        pscanner;
    MODULEDECL*     pmoduledecl;
    ASTEXEC*        pastexec;
    SCRIPT          script;
};



BOOL
PRIVATE
ReadIntoBuffer(
    IN  SCRIPTDATA* pdata,
    OUT PDWORD      pibStart,
    OUT PDWORD      pcbRead
    );


#endif // _NTHDR2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\nthdr1.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    nthdr1.h
//
// History:
//  Abolade-Gbadegesin  04-02-96    Created.
//
// This file contains macros to hide differences in implementation
// of the scripting between Win9x and Windows NT
//============================================================================

#ifndef _NTHDR1_H_
#define _NTHDR1_H_


//
// declare data-type for return codes
//

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;
#endif //!_HRESULT_DEFINED


//
// undefine registry-string redefined by rnap.h
//

#ifdef REGSTR_VAL_MODE
#undef REGSTR_VAL_MODE
#endif


//
// define critical-section initialization function needed by common.c
//

#define ReinitializeCriticalSection     InitializeCriticalSection


//
// provide dummy definiton of ContextHelp for terminal.c
//

#define ContextHelp(a,b,c,d)


//
// macros used for CRT-style Unicode<->ANSI conversion
//
#define WCSTOMBS(a,b) \
        WideCharToMultiByte( \
            CP_ACP, 0, (b), -1, (a), lstrlenW(b) + 1, NULL, NULL \
            )
#define MBSTOWCS(a, b) \
        MultiByteToWideChar( \
            CP_ACP, 0, (b), -1, (a), (lstrlenW(b) + 1) * sizeof(WCHAR) \
            )



//
// constants used for RASMAN I/O
//

#define SIZE_RecvBuffer     1024
#define SIZE_ReceiveBuf     SIZE_RecvBuffer
#define SIZE_SendBuffer     1
#define SIZE_SendBuf        SIZE_SendBuffer
#define SECS_RecvTimeout    1



//----------------------------------------------------------------------------
// Function:    RxLogErrors
//
// Logs script-syntax-errors to a file.
//----------------------------------------------------------------------------

DWORD
RxLogErrors(
    IN      HANDLE      hscript,
    IN      VOID*       hsaStxerr
    );



//----------------------------------------------------------------------------
// Function:    RxReadFile
//
// Transfers data out of a RASMAN buffer into the circular buffer
// used by the Win9x scripting code
//----------------------------------------------------------------------------

BOOL
RxReadFile(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN      DWORD       dwBufferSize,
    OUT     DWORD*      pdwBytesRead
    );



//----------------------------------------------------------------------------
// Function:    RxSetIPAddress
//
// Sets the IP address for the script's RAS entry
//----------------------------------------------------------------------------

DWORD
RxSetIPAddress(
    IN      HANDLE      hscript,
    IN      LPCSTR      lpszAddress
    );



//----------------------------------------------------------------------------
// Function:    RxSetKeyboard
//
// Signals the script-owner to enable or disable keyboard input.
//----------------------------------------------------------------------------

DWORD
RxSetKeyboard(
    IN      HANDLE      hscript,
    IN      BOOL        bEnable
    );


//----------------------------------------------------------------------------
// Function:    RxSendCreds
//
// Sends users password over the wire.
//----------------------------------------------------------------------------
DWORD
RxSendCreds(
    IN HANDLE hscript,
    IN CHAR controlchar
    );


//----------------------------------------------------------------------------
// Function:    RxSetPortData
//
// Changes settings for the COM port.
//----------------------------------------------------------------------------

DWORD
RxSetPortData(
    IN      HANDLE      hscript,
    IN      VOID*       pStatement
    );



//----------------------------------------------------------------------------
// Function:    RxWriteFile
//
// Transmits the given buffer thru RASMAN on a port
//----------------------------------------------------------------------------

VOID
RxWriteFile(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN      DWORD       dwBufferSize,
    OUT     DWORD*      pdwBytesWritten
    );


#endif // _NTHDR1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\proj.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//      MODULE:         proj.h
//
//      PURPOSE:        Global header files, data types and function prototypes
//
//	PLATFORMS:	Windows 95
//
//      FUNCTIONS:      N/A
//
//	SPECIAL INSTRUCTIONS: N/A
//

#ifndef _SMMSCRIPT_PROJ_H_
#define _SMMSCRIPT_PROJ_H_


//****************************************************************************
// Global Include File
//****************************************************************************

#include <windows.h>            // also includes windowsx.h
#include <windowsx.h>
#include <regstr.h>

#include <ras.h>                // Dial-Up Networking Session API
#include <raserror.h>           // Dial-Up Networking Session API

#ifdef WINNT_RAS
//
// The following header is included before all the Win9x Dial-Up definitions,
// since it provides definitions used in the scripting headers.
//
#include "nthdr1.h"

#endif // WINNT_RAS


#include <rnaspi.h>             // Service Provider Interface

#include <rnap.h>

#define NORTL
#define NOFILEINFO
#define NOCOLOR
#define NODRAWTEXT
#define NODIALOGHELPER
#define NOPATH
#define NOSHAREDHEAP

#define SZ_MODULE       "SMMSCRPT"
#define SZ_DEBUGINI     "rover.ini"
#define SZ_DEBUGSECTION "SMM Script"

#include "common.h"

// 
// Error codes - we use HRESULT.  See winerror.h.
//  

#define RSUCCEEDED(res)         SUCCEEDED(res)
#define RFAILED(res)            FAILED(res)
#define RFACILITY(res)          HRESULT_FACILITY(res)

typedef HRESULT   RES;

#define RES_OK                  S_OK
#define RES_FALSE               S_FALSE
#define RES_HALT                0x00000002L

#define FACILITY_SCRIPT         0x70

#define RES_E_FAIL              E_FAIL
#define RES_E_OUTOFMEMORY       E_OUTOFMEMORY
#define RES_E_INVALIDPARAM      E_INVALIDARG
#define RES_E_EOF               0x80700000
#define RES_E_MOREDATA          0x80700001

#define FACILITY_PARSE          0x71

#define RES_E_SYNTAXERROR       0x80710000
#define RES_E_EOFUNEXPECTED     0x80710001
#define RES_E_REDEFINED         0x80710002
#define RES_E_UNDEFINED         0x80710003
#define RES_E_DIVBYZERO         0x80710004

#define RES_E_MAINMISSING       0x80710020
#define RES_E_IDENTMISSING      0x80710021
#define RES_E_STRINGMISSING     0x80710022
#define RES_E_INTMISSING        0x80710023
#define RES_E_RPARENMISSING     0x80710024

#define RES_E_INVALIDTYPE       0x80710040
#define RES_E_INVALIDIPPARAM    0x80710041
#define RES_E_INVALIDSETPARAM   0x80710042
#define RES_E_INVALIDPORTPARAM  0x80710043
#define RES_E_INVALIDRANGE      0x80710044
#define RES_E_INVALIDSCRNPARAM  0x80710045

#define RES_E_REQUIREINT        0x80710050
#define RES_E_REQUIRESTRING     0x80710051
#define RES_E_REQUIREBOOL       0x80710052
#define RES_E_REQUIREINTSTRING  0x80710053
#define RES_E_REQUIRELABEL      0x80710054
#define RES_E_REQUIREINTSTRBOOL 0x80710055

#define RES_E_TYPEMISMATCH      0x80710060


#include "scanner.h"
#include "symtab.h"
#include "ast.h"

//****************************************************************************
// Macros
//****************************************************************************

#define IS_DIGIT(ch)            InRange(ch, '0', '9')
#define IS_ESCAPE(ch)           ('%' == (ch))
#define IS_BACKSLASH(ch)        ('\\' == (ch))

#define ENTERCRITICALSECTION(x)         EnterCriticalSection(&x)
#define LEAVECRITICALSECTION(x)         LeaveCriticalSection(&x)

#define TIMER_DELAY         1

// Trace flags
#define TF_ASTEXEC          0x00010000
#define TF_BUFFER           0x00020000

#ifdef DEBUG
// DBG_EXIT_RES(fn, res)  -- Generates a function exit debug spew for
//                          functions that return a RES.
//
#define DBG_EXIT_RES(fn, res)       DBG_EXIT_TYPE(fn, res, Dbg_GetRes)

LPCSTR  PUBLIC Dbg_GetRes(RES res);

// Dump flags
#define DF_ATOMS            0x00000001
#define DF_STACK            0x00000002
#define DF_READBUFFER       0x00000004
#define DF_TOKEN            0x00000008
#define DF_AST              0x00000010
#define DF_PGM              0x00000020

#else

#define DBG_EXIT_RES(fn, res)

#endif 

//****************************************************************************
// Type definitions
//****************************************************************************

typedef struct tagSCRIPT
    {
    char szPath[MAX_PATH];
    UINT uMode;
    } SCRIPT;
DECLARE_STANDARD_TYPES(SCRIPT);

//****************************************************************************
// SMM error
//****************************************************************************

#define SESS_GETERROR_FUNC          "RnaSessGetErrorString"
typedef DWORD (WINAPI * SESSERRORPROC)(UINT, LPSTR, DWORD);

//****************************************************************************
// Global Parameters
//****************************************************************************

extern HANDLE    g_hinst;

//****************************************************************************
// Function Prototypes
//****************************************************************************

RES     PUBLIC CreateFindFormat(PHANDLE phFindFmt);
RES     PUBLIC AddFindFormat(HANDLE hFindFmt, LPCSTR pszFindFmt, DWORD dwFlags, LPSTR pszBuf, DWORD cbBuf);

// Flags for FINDFMT
#define FFF_DEFAULT         0x0000
#define FFF_MATCHEDONCE     0x0001      // (private)
#define FFF_MATCHCASE       0x0002

RES     PUBLIC DestroyFindFormat(HANDLE hFindFmt);
RES     PUBLIC FindFormat(HWND hwnd, HANDLE hFindFmt, LPDWORD piFound);


BOOL    PUBLIC FindStringInBuffer(HWND hwnd, LPCSTR pszFind);
RES     PUBLIC CopyToDelimiter(HWND hwnd, LPSTR pszBuf, UINT cbBuf, LPCSTR pszTok);
void    PUBLIC SendByte(HWND hwnd, BYTE byte);
DWORD   NEAR PASCAL TerminalSetIP(HWND hwnd, LPCSTR szIPAddr);
void    NEAR PASCAL TerminalSetInput(HWND hwnd, BOOL fEnable);

BOOL    PUBLIC GetScriptInfo(LPCSTR pszConnection, PSCRIPT pscriptBuf);
BOOL    PUBLIC GetSetTerminalPlacement(LPCSTR pszConnection,
                                       LPWINDOWPLACEMENT pwp, BOOL fGet);

LPCSTR  PUBLIC MyNextChar(LPCSTR psz, char * pch, DWORD * pdwFlags);

// Flags for MyNextChar
#define MNC_ISLEADBYTE  0x00000001
#define MNC_ISTAILBYTE  0x00000002

UINT    PUBLIC IdsFromRes(RES res);

BOOL    PUBLIC TransferData(HWND hwnd, HANDLE hComm, PSESS_CONFIGURATION_INFO psci);

DWORD   NEAR PASCAL AssignIPAddress (LPCSTR szEntryName, LPCSTR szIPAddress);



#ifdef WINNT_RAS
//
// The following header is included after the Win9x scripting definitions.
// It changes some definitions set up by the headers, and provides
// other definitions needed for the Win9x->NT port.
//
#include "nthdr2.h"

#endif // WINNT_RAS

#endif  //_SMMSCRIPT_PROJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\rnap.h ===
/*****************************************************************************\
*                                                                             *
* rnap.h -      Remote Network Access (RNA) private interface                 *
*                                                                             *
*               Version 1.00                                                  *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
******************************************************************************/

#ifndef _RNAP_H_
#define _RNAP_H_

#define RAS_MaxPortName     128
#define RAS_MaxComment      255
#define RAS_MaxCountry      3
#define RAS_MaxAreaCode     10
#define RAS_MaxLocal        36
#define RAS_MaxExtension    5
#define RAS_MaxSMMDesc      63
#define RAS_MaxProtocolDesc 63

/******************************************************************************
 Private RASCONNSTATE
******************************************************************************/

#define RASCS_PrivateStart  RASCS_Disconnected+1

#define RASCS_StartClosing  RASCS_PrivateStart
#define RASCS_LoggingOff    RASCS_PrivateStart+1
#define RASCS_Closing       RASCS_PrivateStart+2
#define RASCS_Closed        RASCS_PrivateStart+3
#define RASCS_Terminating   RASCS_PrivateStart+4

/******************************************************************************
 Registry key paths
******************************************************************************/

#define REGSTR_KEY_RNA        "RemoteAccess"
#define REGSTR_PATH_RNA       REGSTR_PATH_SERVICES"\\"REGSTR_KEY_RNA
#define REGSTR_VAL_IMPLICIT   "EnableImplicit"
#define REGSTR_VAL_DIALUI     "DialUI"

#define REGSTR_KEY_PROF       REGSTR_KEY_RNA"\\Profile"
#define REGSTR_VAL_USER       "User"
#define REGSTR_VAL_DOMAIN     "Domain"
#define REGSTR_VAL_NUMBER     "Number"
#define REGSTR_VAL_SCRIPT     "PPPScript"
#define REGSTR_VAL_MODE       "Mode"
#define REGSTR_VAL_TERM       "Terminal"
#define REGSTR_VAL_AUTODIALDLL "AutodialDllName"
#define REGSTR_VAL_AUTODIALFN  "AutodialFcnName"
#define REGSTR_VAL_ML          "MultiLink"

/******************************************************************************
 Related RNA module names and internal exported
******************************************************************************/

#define RNA_SERVER_MOD_NAME     "RNASERV.DLL"
#define CALLER_ACCESS_FUNC_NAME "CallerAccess"

#define RNADLL_MODULE_NAME      "RASAPI32.DLL"

#define RNASCRIPT_MODULE_NAME   "SMMSCRPT.DLL"
#define RUN_SCRIPT_FUNC_NAME    "RunRnaScript"

#define RNAUI_MODULE_NAME       "RNAUI.DLL"
#define CREATE_ENTRY_FUNC_NAME  "Remote_CreateEntry"
#define EDIT_ENTRY_FUNC_NAME    "Remote_EditEntry"
#define NOTIFY_FUNC_NAME        "Remote_Notify"

/******************************************************************************
 Asynchronous event notification from RNA engine via WM_RASDIALEVENT
******************************************************************************/

#define     RNA_ASYNCEVENT      0xFFFFFFFF  // wParam value

#define     RNA_ADD_DEVICE      0           // A new device was added
#define     RNA_DEL_DEVICE      1           // A new device was removed
#define     RNA_REINIT_DEVICE   2           // The device needs to be reintied
#define     RNA_SHUTDOWN        3           // The engine needs to shutdown
#define     RNA_TRANSLATECHANGE 4           // Translate address caps changed

/******************************************************************************
 Communication with RNA engine
******************************************************************************/

#define     CLIENT_CONNECTION   1           // Client connection
#define     SERVER_CONNECTION   2           // Server connection

#define     WM_RNAMSG       WM_USER+10

#define     RL_MINMSG       WM_RNAMSG
#define     RL_CREATE       RL_MINMSG       // create a connection
#define     RL_TERMINATE    RL_MINMSG+1     // terminate the connection
#define     RL_CONNECTED    RL_MINMSG+2     // a connection is active
#define     RL_DISCONNECTED RL_MINMSG+3     // a connection is not active
#define     RL_SUPRV        RL_MINMSG+4     // initialize supervisor
#define     RL_ACTIVATE     RL_MINMSG+5     // activate supervisor change
#define     RL_REINIT       RL_MINMSG+6     // Reinitialize the engine
#define     RL_REG_DEVCHG   RL_MINMSG+7     // Register device notification
#define     RL_GET_COUNT    RL_MINMSG+8     // Get the count
#define     RL_GW_NOTIFY    RL_MINMSG+9     // Gateway callback

/******************************************************************************
 Communication with Dial engine
******************************************************************************/

#define     DL_MINMSG       WM_RNAMSG
#define     DL_DIALEVENT    DL_MINMSG       // continue dial-up sequence
#define     DL_DISCONNECTED DL_MINMSG+1     // a connection is not active
#define     DL_AUTHENTICATE DL_MINMSG+2     // auth module sent a message
#define     DL_CONNECTED    DL_MINMSG+3     // a new connection is active
#define     DL_CLOSE        DL_MINMSG+4     // Terminate the connection window
#define     DL_MAC_MSG      DL_MINMSG+5     // MAC requests disconnection
#define     DL_RECONNECT    DL_MINMSG+6     // a connection needs reconnect
#define     DL_NOTIFYICON   DL_MINMSG+7     // tray icon notification
#define     DL_SHOW_STAT    DL_MINMSG+8     // display the status dialog

//****************************************************************************
// Communication with gateway manager
//****************************************************************************

#define     GW_MINMSG       WM_RNAMSG
#define     GW_DIALEVENT    DL_DIALEVENT    // !!WARNING!! shared message
#define     GW_CONNECTED    GW_MINMSG + 1
#define     GW_DISCONNECTED GW_MINMSG + 2
#define     GW_LOG          GW_MINMSG + 3
#define     GW_CLOSE        DL_CLOSE        // !!WARNING!! shared message
#define     GW_MAC_MSG      DL_MAC_MSG      // MAC requests disconnection

#define MAX_AUTODISCONNECT  60000       // server autodisconnect sec.

//
// Gateway to Supervisor Communication
//
LRESULT WINAPI DialInMessage(HWND, UINT, WPARAM, LPARAM);

/******************************************************************************
 Request for services from RNADLL
******************************************************************************/

DWORD WINAPI RnaEngineRequest  (UINT uCommand, DWORD dwParam);
DWORD WINAPI DialEngineRequest (UINT uCommand, DWORD dwParam1, DWORD dwParam2);
DWORD WINAPI SuprvRequest      (UINT uCommand, DWORD dwParam1, DWORD dwParam2);

#define     RA_MINCMD       0
#define     RA_LOAD         RA_MINCMD       // Notify Rna process is a loader
#define	    RA_INIT         RA_MINCMD+1	    // Initialize the rna engine
#define     RA_TERMINATE    RA_MINCMD+2     // rna engine terminated
#define     RA_REG_DEVCHG   RA_MINCMD+3     // register dev change notification
#define     RA_DEREG_DEVCHG RA_MINCMD+4     // deregister dev change notification
#define	    RA_REINIT       RA_MINCMD+5	    // Reinitialize the rna engine
#define     RA_ADD_DEVICE   RA_MINCMD+6     // Device added
#define     RA_DEL_DEVICE   RA_MINCMD+7     // Device removed
#define     RA_GET_PROP     RA_MINCMD+8     // Get property page
#define     RA_MAXCMD       RA_MINCMD+50

#define     GA_MINCMD       RA_MAXCMD+1
#define     GA_INIT_SUPRV   GA_MINCMD       // Initialize supervisor
#define     GA_ACTIVE_SUPRV GA_MINCMD+1     // Activate supervisor
#define     GA_SHUTDOWN     RA_MINCMD+2     // Shutdown the system
#define     GA_LOG_SUPRV    GA_MINCMD+3     // Register log event
#define     GA_LOGON_INFO   GA_MINCMD+4     // Logon session information
#define     GA_DISCONNECT   GA_MINCMD+5     // Terminate logon session
#define     GA_START_SUPRV  GA_MINCMD+6     // Start the host
#define     GA_STOP_SUPRV   GA_MINCMD+7     // Stop the host
#define     GA_DEV_CHANGE   GA_MINCMD+8     // A device changed
#define     GA_GET_STATS    GA_MINCMD+9     // Get the server information
#define     GA_COUNT_ACTIVE GA_MINCMD+10    // Count the active connection
#define     GA_MAXCMD       GA_MINCMD+50

#define     DA_MINCMD       GA_MAXCMD+1
#define     DA_CONNINFO     DA_MINCMD       // connection information
#define     DA_DISCONNECT   DA_MINCMD+1     // disconnect an active connection
#define     DA_RECONNECT    DA_MINCMD+2     // reconnect a dropped connection
#define	    DA_NEWCONN      DA_MINCMD+3	    // a new connection is added
#define     DA_SHUTDOWN     DA_MINCMD+4     // Shutdown the system
#define     DA_NEWEVENT     DA_MINCMD+5     // Notify a new event
#define     DA_COMPASYN     DA_MINCMD+6     // Notify a async operation completion
#define     DA_DEV_CHANGE   DA_MINCMD+7     // A device changed
#define     DA_GET_UI_WND   DA_MINCMD+8     // Get the UI window
#define     DA_SET_WND_POS  DA_MINCMD+9     // Set the status window position
#define     DA_GETSTATS     DL_MINMSG+10    // a connection needs stats
#define     DA_GET_CONNSTAT DL_MINMSG+11    // Get current connection status
#define     DA_GET_SUBENTRY DL_MINMSG+12    // Get sub-entry information
#define     DA_DIAL_SUBENTRY DL_MINMSG+13   // Dial a sub-entry
#define     DA_MAXCMD       DA_MINCMD+50

typedef struct  tagConnInfo {
    char        szEntryName[RAS_MaxEntryName+1];
    DWORD       dwRate;
    char        szSMMDesc[RAS_MaxSMMDesc+1];
    DWORD       fdwProtocols;
    char        szDeviceType[RAS_MaxDeviceType+1];
    char        szDeviceName[RAS_MaxDeviceName+1];
} CONNINFO, *PCONNINFO, FAR* LPCONNINFO;

typedef struct  tagMLInfo {
    BOOL        fEnabled;
    DWORD       cSubEntries;
} MLINFO, *PMLINFO, FAR* LPMLINFO;

typedef struct  tagSubConnInfo {
    DWORD       iSubEntry;
    MLINFO      mli;
} SUBCONNINFO, *PSUBCONNINFO, FAR* LPSUBCONNINFO;

#define PARENT_ENTRY_ID 0xFFFFFFFF

// Flags for protocols in fdwProtocols
//
#define PROTOCOL_AMB            0x00000001
#define PROTOCOL_PPPNBF         0x00000002
#define PROTOCOL_PPPIPX         0x00000004
#define PROTOCOL_PPPIP          0x00000008

//****************************************************************************
// RNAAPP Command line interface
//****************************************************************************

#define RNAAPP_EXE_NAME             "rnaapp"
#define LOAD_REQ                    "-l"      // RnaDll loads Rnaapp

//****************************************************************************
// RNAUI Private Interface
//****************************************************************************

#define DT_NULLMODEM    "null"
#define DT_MODEM        "modem"
#define DT_ISDN         "isdn"
#define DT_UNKNOWN      "unknown"

#define DIRECTCC        "Direct Cable Connection Host Logon"

typedef HICON   FAR* LPHICON;

// SMM Usage type flags
//
#define CLIENT_SMM          0x00000001
#define SERVER_SMM          0x00000002

typedef struct  tagSMMCFG  {
    DWORD       dwSize;
    DWORD       fdwOptions;
    DWORD       fdwProtocols;
}   SMMCFG, *PSMMCFG, FAR* LPSMMCFG;

typedef struct  tagSMMINFO  {
    char        szSMMType[RNA_MaxSMMType+1];
    SMMCFG      SMMConfig;
}   SMMINFO, *PSMMINFO, FAR* LPSMMINFO;

typedef struct tagIPData   {
    DWORD     dwSize;
    DWORD     fdwTCPIP;
    DWORD     dwIPAddr;
    DWORD     dwDNSAddr;
    DWORD     dwDNSAddrAlt;
    DWORD     dwWINSAddr;
    DWORD     dwWINSAddrAlt;
}   IPDATA, *PIPDATA, FAR *LPIPDATA;

typedef struct tagSMMData   {
    struct    tagSMMData *pNext;
    SMMINFO   smmi;
    DWORD     fdwOptAllow;
    DWORD     fdwProtAllow;
    IPDATA    ipData;
}   SMMDATA, *PSMMDATA, FAR *LPSMMDATA;

// Flags for the fdwTCPIP field
//

#define IPF_IP_SPECIFIED    0x00000001
#define IPF_NAME_SPECIFIED  0x00000002
#define IPF_NO_COMPRESS     0x00000004
#define IPF_NO_WAN_PRI      0x00000008

typedef struct  tagDEVICEINFO  {
    DWORD       dwVersion;
    UINT        uSize;
    char        szDeviceName[RAS_MaxDeviceName+1];
    char        szDeviceType[RAS_MaxDeviceType+1];
}   DEVICEINFO, *PDEVICEINFO, FAR* LPDEVICEINFO;

typedef struct  tagDevConfig    {
    HICON       hIcon;
    SMMINFO     smmi;
    DEVICEINFO  di;
}   DEVCONFIG, *PDEVCONFIG, FAR* LPDEVCONFIG;

typedef struct tagPhoneNum  {
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    char        szAreaCode[RAS_MaxAreaCode+1];
    char        szLocal[RAS_MaxLocal+1];
    char        szExtension[RAS_MaxExtension+1];
} PHONENUM, *PPHONENUM, FAR *LPPHONENUM;

typedef struct  tagCountryInfo {
    DWORD       dwCountryID;
    DWORD       dwNextCountryID;
    DWORD       dwCountryCode;
    DWORD       dwCountryNameOffset;
}   COUNTRYINFO, *PCOUNTRYINFO, FAR* LPCOUNTRYINFO;

typedef struct  tagConnEntry    {
    PSTR        pszEntry;
    PHONENUM    pn;
    PDEVCONFIG  pDevConfig;
    DWORD       dwFlags;
    DWORD       cSubEntry;
}   CONNENTRY, *PCONNENTRY, FAR* LPCONNENTRY;

#define CESZENTRY(pCE)         ((PSTR)(((PBYTE)pCE)+sizeof(CONNENTRY)))

#define DEVCONFIGSIZE(diSize)  (diSize+(sizeof(DEVCONFIG)-sizeof(DEVICEINFO)))

typedef struct  tagSubConnEntry    {
    DWORD       dwSize;
    DWORD       dwFlags;
    char        szDeviceType[RAS_MaxDeviceType+1];
    char        szDeviceName[RAS_MaxDeviceName+1];
    char        szLocal[RAS_MaxPhoneNumber+1];
}   SUBCONNENTRY, *PSUBCONNENTRY, FAR* LPSUBCONNENTRY;

typedef struct tagConnEntDlg    {
    PCONNENTRY  pConnEntry;
    PDEVCONFIG  pDevConfig;
    PSMMDATA    pSMMList;
    PSMMDATA    pSMMType;
    PMLINFO     pmli;
    DWORD       cmlChannel;
} CONNENTDLG, *PCONNENTDLG, FAR *LPCONNENTDLG;

typedef struct tagRNAPropPage {
    UINT      idPage;
    HMODULE   hModule;
    UINT      idRes;
    DLGPROC   pfn;
} RNAPROPPAGE, *PRNAPROPPAGE, FAR *LPRNAPROPPAGE;

#define SRV_TYPE_PAGE       0   // Server Type page id

DWORD      WINAPI RnaEnumConnEntries(LPSTR lpBuf, UINT cb, LPDWORD lpcEntries);
PCONNENTRY WINAPI RnaGetConnEntry(LPSTR szEntry, BOOL bNeedIcon, BOOL fDevice);
BOOL       WINAPI RnaFreeConnEntry(PCONNENTRY);
DWORD      WINAPI RnaSaveConnEntry(PCONNENTRY lpConnEntry);
BOOL       WINAPI RnaDeleteConnEntry(LPSTR szEntry);
DWORD      WINAPI RnaRenameConnEntry(LPSTR szOldEntry, LPSTR szNewEntry);
DWORD      WINAPI RnaValidateEntryName (LPSTR szEntry, BOOL fNew);

DWORD      WINAPI RnaEnumCountryInfo (LPCOUNTRYINFO, LPDWORD);
DWORD      WINAPI RnaGetAreaCodeList (LPSTR, LPDWORD);
DWORD      WINAPI RnaGetCurrentCountry (LPDWORD);

DWORD      WINAPI RnaEnumDevices (LPBYTE lpBuff, LPDWORD lpcbSize,
                                  LPDWORD lpcEntries);
PDEVCONFIG WINAPI RnaGetDefaultDevConfig (LPSTR szDeviceName);
DWORD      WINAPI RnaGetDeviceInfo(LPSTR szDeviceName, LPDEVICEINFO lpdi);
DWORD      WINAPI RnaGetDeviceChannel (LPSTR szDeviceName);
PDEVCONFIG WINAPI RnaBuildDevConfig (PDEVCONFIG pDevConfig, HICON hIcon, BOOL bNeedIcon);
DWORD      WINAPI RnaDevConfigDlg(HWND hWnd, PDEVCONFIG pDevConfig);
BOOL       WINAPI RnaFreeDevConfig(PDEVCONFIG pDevConfig);

DWORD      WINAPI RnaSMMInfoDialog(HWND hWnd, LPSTR szEntryName,
                                   LPSTR szDeviceName,
                                   LPSMMINFO lpsmmi, DWORD dwUsage);
DWORD      WINAPI RnaEnumerateMacNames (LPSTR szDeviceName, LPBYTE lpBuff,
                                        LPDWORD lpcb);
DWORD      WINAPI RnaEnumerateSMMNames (LPSTR szDeviceName, LPBYTE lpBuff,
                                        LPDWORD lpcb,   DWORD dwType);
DWORD      WINAPI RnaGetDefaultSMMInfo(LPSTR szDeviceName, LPSMMINFO lpsmmi,
                                       BOOL fClient);
DWORD      WINAPI RnaGetIPInfo(LPSTR szEntryName, PIPDATA pIpData,
                               BOOL fDefault);
DWORD      WINAPI RnaSetIPInfo(LPSTR szEntryName, PIPDATA pIpData);


DWORD      WINAPI RnaLogon(HWND);
DWORD      WINAPI RnaActivateEngine();
DWORD      WINAPI RnaDeactivateEngine();
DWORD      WINAPI RnaUIDial(HWND, LPSTR);
DWORD      WINAPI RnaImplicitDial(HWND, LPSTR);

DWORD      WINAPI RnaFindDriver(HWND hwnd, LPSTR lpszDriverList);
DWORD      WINAPI RnaInstallDriver (HWND hwnd, LPSTR lpszDriverList);

DWORD      WINAPI RnaExportEntry (LPSTR szEntryName, LPSTR szFileName);
DWORD      WINAPI RnaImportEntry (LPSTR szFileName, LPBYTE lpBuff, DWORD cb);
DWORD      WINAPI RnaValidateImportEntry (LPSTR szFileName);

DWORD      WINAPI RnaGetMultiLinkInfo (LPSTR, LPMLINFO);
DWORD      WINAPI RnaSetMultiLinkInfo (LPSTR, LPMLINFO);
DWORD      WINAPI RnaGetSubEntry (LPSTR, DWORD, PSUBCONNENTRY, LPDWORD);
DWORD      WINAPI RnaSetSubEntry (LPSTR, DWORD, PSUBCONNENTRY, DWORD);

#define    LOG_INACTIVE            0
#define    LOG_DISCONNECTION       1
#define    LOG_ACTIVE              2
#define    LOG_LISTEN              3
#define    LOG_AUTH_TIMEOUT        4
#define    LOG_CALLBACK            5
#define    LOG_ANSWERED            6
#define    LOG_ERROR               7
    
typedef struct tagLOGINFO {
    LPSTR   szPortName;
    HWND    hwnd;
    UINT    uLogEvent;
} LOGINFO, *PLOGINFO, FAR* LPLOGINFO;

typedef struct tagGWLOGONINFO {
    LPSTR   szPortName;
    char    szUserName[UNLEN+1];
    SYSTEMTIME sysTime;
} GWLOGONINFO, *PGWLOGONINFO, FAR* LPGWLOGONINFO;

typedef enum tagRNASECURITY { RNAPASSWORD, RNAPASSTHROUGH } RNASECURITY;

#define RNAADMIN_DIALIN 1

#define	USERTYPE_USER		0x00000001
#define USERTYPE_GROUP		0x00000002
#define	USERTYPE_WORLD		0x00000004

typedef struct tagUSER_ACCESS {
        RNAACCESSTYPE accesstype;
        BOOL        fUseCallbacks;
        DWORD       dwUsertype;
} USERACCESS, *PUSERACCESS, FAR *LPUSERACCESS;

typedef struct tagPORTSTATS
{
    char            szPortName[RAS_MaxPortName+1];
    char            szDeviceType[RAS_MaxDeviceType+1];
    BOOL            fAccessEnabled;
    UINT            TimeOut;
    SMMINFO         smmi;
    char            szComment[RAS_MaxComment+1];
    BOOL            AdminAccess;
    RNASECURITY     security;
    union {
      struct        tagPassthru {
        DWORD       cUsers;
        DWORD       dwOffsetUsers; }
                    Passthru;

      struct        tagPassword {
        USERACCESS  shareaccess;
        char        szPassword[PWLEN+1]; }
                    Password;
    };
} RNAPORTSTATS, *PRNAPORTSTATS, FAR *LPRNAPORTSTATS;

DWORD WINAPI SuprvEnumAccessInfo (LPBYTE, LPINT, LPINT);
DWORD WINAPI SuprvGetAccessInfo (LPSTR, LPRNAPORTSTATS, LPDWORD);
DWORD WINAPI SuprvSetAccessInfo (LPRNAPORTSTATS);
DWORD WINAPI SuprvInitialize (LPDWORD);
DWORD WINAPI SuprvDeInitialize();
DWORD WINAPI SuprvGetAdminConfig();

DWORD WINAPI RnaSetCallbackList (DWORD, LPSTR, LPSTR, int);

DWORD WINAPI RnaAllocateLana(HANDLE hConn, LPDWORD lpLana);
DWORD WINAPI RnaDeallocateLana(HANDLE hConn);

DWORD WINAPI RnaRunScript(HANDLE hConn, PSESS_CONFIGURATION_INFO lpSCI,
                          BOOL fForce);

typedef DWORD (WINAPI * LPFNCREATE)(HWND);
typedef DWORD (WINAPI * LPFNEDIT)(HWND, LPSTR);
typedef void  (WINAPI * LPFNUINOTIFY)(LPSTR);

DWORD WINAPI Remote_CreateEntry (HWND);
DWORD WINAPI Remote_EditEntry (HWND, LPSTR);
void  WINAPI Remote_Notify (LPSTR);

//***************************************************************************
// Dial global setting for redial and implicit connection
//***************************************************************************

#define MAX_REDIAL_COUNT        100
#define MIN_REDIAL_COUNT        1
#define MAX_REDIAL_MINUTE       119
#define MIN_REDIAL_MINUTE       0
#define MAX_REDIAL_SECOND       59
#define MIN_REDIAL_SECOND       0

typedef struct tagRnaSetting    {
    BOOL    fRedial;
    DWORD   cRetry;
    DWORD   dwMin;
    DWORD   dwSec;
    BOOL    fImplicit;
    DWORD   dwDialUI;
} RNASETTING, *PRNASETTING, FAR *LPRNASETTING;

#define DIALUI_NO_PROMPT        0x00000001  // Do not display connect prompt
#define DIALUI_NO_CONFIRM       0x00000002  // Do not display connect confirm
#define DIALUI_NO_TRAY          0x00000004  // No tray icon

DWORD WINAPI RnaGetDialSettings(LPRNASETTING);
DWORD WINAPI RnaSetDialSettings(LPRNASETTING);

//***************************************************************************
// The following are SMM Interface we cut from version 1.0
//***************************************************************************
#ifndef WINNT_RAS
//
// CALLBACKINFO conflicts with a structure defined in "pbuser.h",
// and RAS_STATISTICS conflicts with a structure in "rasman.h".
// The Win9x scripting code uses neither, so they have been commented out.
//

// Callback request information
//
typedef struct tagCALLBACKINFO
{
    DWORD            dwSize;
    BOOL             fUseCallbackDelay;
    DWORD            dwCallbackDelay;
    char             szPhoneNumber[RAS_MaxPhoneNumber+1];
} CALLBACKINFO, *PCALLBACKINFO, FAR* LPCALLBACKINFO;

DWORD WINAPI RnaSetCallbackInfo( HANDLE hConn, LPCALLBACKINFO lpcbinfo );

DWORD WINAPI RnaReportLinkSpeed( HANDLE hConn, DWORD dwLinkSpeed );
DWORD WINAPI RnaUIStatus( HANDLE hConn, LPSTR lpszStatusMsg );
DWORD WINAPI RnaLog( HANDLE hConn, LPSTR lpszLogMsg );

//***************************************************************************
// The following are connection statistics
//***************************************************************************

#define NUM_RAS_SERIAL_STATS    14

#define BYTES_XMITED            0       //Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR                 4       //Serial Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define SERIAL_OVERRUN_ERR      7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#define BYTES_XMITED_UNCOMP     10      //Compression Stats
#define BYTES_RCVED_UNCOMP      11
#define BYTES_XMITED_COMP       12
#define BYTES_RCVED_COMP        13

typedef struct  tagRAS_STATISTICS
{
    DWORD   S_NumOfStatistics ;
    DWORD   S_Statistics[NUM_RAS_SERIAL_STATS] ;
} RAS_STATISTICS, FAR* LPRAS_STATISTICS;
#endif // WINNT_RAS

//**************************************************************************
//  Script support
//**************************************************************************

// Script processing mode
//
#define NORMAL_MODE         0
#define TEST_MODE           1

typedef DWORD (WINAPI * PFN_RUN_SCRIPT)(HANDLE, LPSESS_CONFIGURATION_INFO);

#endif // _RNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\scanner.h ===
//
// Copyright (c) Microsoft Corporation 1995
//
// scanner.h
//
// Header file for the scanner.
//
// History:
//  04-05-95 ScottH     Created
//

#ifndef __SCANNER_H__
#define __SCANNER_H__

//
// Symbols
//


typedef enum
    {
    SYM_EOF,            // end of file
    SYM_UNKNOWN,        // unknown lexeme

    SYM_COLON,          // ':'
    SYM_COMMA,          // ','

    SYM_IDENT,          // identifier
    SYM_STRING_LITERAL, // a string literal
    SYM_INT_LITERAL,    // an integer literal

    SYM_INTEGER,        // 'integer'
    SYM_STRING,         // 'string'
    SYM_BOOLEAN,        // 'boolean'

    SYM_WAITFOR,        // 'waitfor'
    SYM_THEN,           // 'then'
    SYM_UNTIL,          // 'until'
    SYM_TRANSMIT,       // 'transmit'
    SYM_PROC,           // 'proc'
    SYM_ENDPROC,        // 'endproc'
    SYM_DELAY,          // 'delay'
    SYM_HALT,           // 'halt'
    SYM_GETIP,          // 'getip'
    SYM_GOTO,           // 'goto'
    SYM_WHILE,          // 'while'
    SYM_DO,             // 'do'
    SYM_ENDWHILE,       // 'endwhile'
    SYM_IF,             // 'if'
    SYM_ENDIF,          // 'endif'

    SYM_RAW,            // 'raw'
    SYM_MATCHCASE,      // 'matchcase'

    SYM_SET,            // 'set'

    SYM_IPADDR,         // 'ipaddr'

    SYM_PORT,           // 'port'
    SYM_DATABITS,       // 'databits'

    SYM_STOPBITS,       // 'stopbits'

    SYM_PARITY,         // 'parity'
    SYM_NONE,           // 'none'
    SYM_ODD,            // 'odd'
    SYM_EVEN,           // 'even'
    SYM_MARK,           // 'mark'
    SYM_SPACE,          // 'space'

    SYM_SCREEN,         // 'screen'
    SYM_KEYBRD,         // 'keyboard'
    SYM_ON,             // 'on'
    SYM_OFF,            // 'off'

    SYM_LPAREN,         // '('
    SYM_RPAREN,         // ')'
    SYM_ASSIGN,         // = (assignment)
    SYM_TRUE,           // 'TRUE'
    SYM_FALSE,          // 'FALSE'
    SYM_NOT,            // '!'

    // WARNING: The types below must match the order of their 
    // corresponding BOT values.

    SYM_OR,             // 'or'
    SYM_AND,            // 'and'

    SYM_LEQ,            // '<='    
    SYM_LT,             // '<'     
    SYM_GEQ,            // '>='    
    SYM_GT,             // '>'     
    SYM_NEQ,            // '!='
    SYM_EQ,             // '=='

    SYM_PLUS,           // '+'
    SYM_MINUS,          // '-'
    SYM_MULT,           // '*'
    SYM_DIV,            // '/'
    } SYM;
DECLARE_STANDARD_TYPES(SYM);


//
// Tokens
//


#define MAX_BUF_KEYWORD     32

typedef enum
    {
    TT_BASE,
    TT_SZ,
    TT_INT,
    } TOKTYPE;


// Basic Token Type

typedef struct tagTOK
    {
    DWORD   cbSize;
    SYM     sym;
    TOKTYPE toktype;
    DWORD   iLine;
    char    szLexeme[MAX_BUF_KEYWORD];
    } TOK;                            // Basic token type
DECLARE_STANDARD_TYPES(TOK);

#define Tok_GetSize(p)      (((PTOK)(p))->cbSize)
#define Tok_GetSym(p)       (((PTOK)(p))->sym)
#define Tok_GetType(p)      (((PTOK)(p))->toktype)
#define Tok_GetLine(p)      (((PTOK)(p))->iLine)
#define Tok_GetLexeme(p)    (((PTOK)(p))->szLexeme)

#define Tok_SetSize(p, s)   (((PTOK)(p))->cbSize = (s))
#define Tok_SetSym(p, s)    (((PTOK)(p))->sym = (s))
#define Tok_SetType(p, tt)  (((PTOK)(p))->toktype = (tt))
#define Tok_SetLine(p, l)   (((PTOK)(p))->iLine = (l))
#define Tok_SetLexeme(p, s) lstrcpyn(((PTOK)(p))->szLexeme, s, sizeof(((PTOK)(p))->szLexeme))

RES     PUBLIC Tok_New(PTOK * pptok, SYM sym, LPCSTR pszLexeme, DWORD iLine);
void    PUBLIC Tok_Delete(PTOK this);


// String Token

typedef struct tagTOKSZ
    {
    TOK  tok;
    char sz[MAX_BUF];
    } TOKSZ;
DECLARE_STANDARD_TYPES(TOKSZ);

#define TokSz_GetSz(p)      (((PTOKSZ)(p))->sz)

#define TokSz_SetSz(p, s)   lstrcpyn(((PTOKSZ)(p))->sz, s, sizeof(((PTOKSZ)(p))->sz))

RES     PUBLIC TokSz_New(PTOK * pptok, SYM sym, LPCSTR pszLexeme, DWORD iLine, LPCSTR pszID);


// Integer Token

typedef struct tagTOKINT
    {
    TOK  tok;
    int  n;
    } TOKINT;
DECLARE_STANDARD_TYPES(TOKINT);

#define TokInt_GetVal(p)        (((PTOKINT)(p))->n)

#define TokInt_SetVal(p, v)     (((PTOKINT)(p))->n = (v))

RES     PUBLIC TokInt_New(PTOK * pptok, SYM sym, LPCSTR pszLexeme, DWORD iLine, int n);

//
// Syntax error object
//

typedef struct tagSTXERR
    {
    char    szLexeme[MAX_BUF_KEYWORD];
    DWORD   iLine;
    RES     res;
    } STXERR;
DECLARE_STANDARD_TYPES(STXERR);

#define Stxerr_GetLexeme(p)     ((p)->szLexeme)
#define Stxerr_GetLine(p)       ((p)->iLine)
#define Stxerr_GetRes(p)        ((p)->res)


//
// Scanner
//

typedef struct tagSCANNER
    {
    DWORD  dwFlags;         // SCF_*

    PSESS_CONFIGURATION_INFO psci;

    char   szScript[MAX_PATH];
    HANDLE hfile;
    LPBYTE pbBuffer;        // Read buffer
    LPBYTE pbCur;           // Current unread position in buffer
    DWORD  cbUnread;        // Count of unread bytes in buffer

    char   chCur;           // Current character, set by Scanner_GetChar()
    char   chTailByte;      // Tail byte for DBCS characters
    char   chUnget;         // Ungotten character

    PTOK   ptokCur;         // Current token, set by Scanner_GetToken()
    PTOK   ptokUnget;       // Ungotten token

    DWORD  iLine;           // The current line number

    HSA    hsaStxerr;       // List of errors
    DWORD  isaStxerr;       // Current error

    } SCANNER;
DECLARE_STANDARD_TYPES(SCANNER);

// Scanner flags
#define SCF_NOSCRIPT    0x0001

#define Scanner_GetStxerrHandle(this)       ((this)->hsaStxerr)

RES     PUBLIC Scanner_Create(PSCANNER * ppscanner, PSESS_CONFIGURATION_INFO psci);
RES     PUBLIC Scanner_Destroy(PSCANNER this);
RES     PUBLIC Scanner_OpenScript(PSCANNER this, LPCSTR pszPath);

RES     PUBLIC Scanner_GetToken(PSCANNER this, PTOK * pptok);
RES     PUBLIC Scanner_UngetToken(PSCANNER this);
RES     PUBLIC Scanner_Peek(PSCANNER this, PSYM psym);
RES     PUBLIC Scanner_ReadToken(PSCANNER this, SYM sym);
RES     PUBLIC Scanner_CondReadToken(PSCANNER this, SYM symExpect, PTOK * pptok);
DWORD   PUBLIC Scanner_GetLine(PSCANNER this);

RES     PUBLIC Scanner_AddError(PSCANNER this, PTOK ptok, RES resErr);

RES     PUBLIC Stxerr_ShowErrors(HSA hsaStxerr, HWND hwndOwner);
RES     PUBLIC Stxerr_Add(HSA hsaStxerr, LPCSTR pszLexeme, DWORD iLine, RES resErr);
RES     PUBLIC Stxerr_AddTok(HSA hsaStxerr, PTOK ptok, RES resErr);

#endif // __SCANNER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\scrpthlp.h ===
//****************************************************************************
//
//  Module:     SMMSCRPT.DLL
//  File:       scrpthlp.h
//  Content:    This file contains the context-sensitive help header.
//
//  Copyright (c) Microsoft Corporation 1991-1994
//
//****************************************************************************

#ifndef WINNT_RAS
//
// We are not using the help supplied with the Win9x code,
// so the header below has been commented out. Note that there is 
// a header of the same name in this file's directory, so if the #include
// is uncommented below, the preprocessor will go into an infinite loop.
// This doesn't happen on Win9x because there is a header named scrpthlp.h
// in the compiler's include-file search-path.
//
#include <scrpthlp.h>

#endif // !WINNT_RAS

//****************************************************************************
// Context-sentive help/control mapping arrays
//****************************************************************************

extern DWORD gaTerminal[];
extern DWORD gaDebug[];

void NEAR PASCAL ContextHelp (LPDWORD aHelp, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\scriptp.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    scriptp.h
//
// History:
//  Abolade-Gbadegesin  04-01-96    Created.
//
// Contains private declarations for dial-up scripting.
//
// Most of the code for script-processing is Win9x code.
// The port consisted of wiring the Win9x code to NT entry-points,
// in order to allow scripts to work without a terminal window.
// This DLL thus exports a function which can be called to run a script
// to completion (RasScriptExecute), as well as a set of functions
// which together provide a way for the caller to start script-processing
// and receive notification when data is received or when certain events
// occur during script execution. The notification may be event-based
// or message-based (i.e. via SetEvent or via SendNotifyMessage).
//
// The code is rewired at the upper level, by providing the functions
// defined in RASSCRPT.H as the interface to scripting, as well as
// at the lower level, by replacing Win9x's Win32 COMM calls with calls
// to RASMAN to send and receive data. The changes to the Win9x code
// can be found by searching for the string "WINNT_RAS" which is used
// in #ifdef statements to demarcate modifications.
// Generally, the upper-level functions have names like Rs*
// and the lower-level functions have names like Rx*.
//
// The Win9x code is heavily dependent on there being an HWND
// for messages to be sent to. This is not always the case on NT,
// and so code which uses an HWND on Win9x has been modified on NT
// to expect instead a pointer to a SCRIPTDATA structure; this structure
// contains enough information for the code to achieve whatever is needed.
//
// Script initialization produces a HANDLE which is actually a pointer
// to a SCRIPTCB. The SCRIPTCB contains all information needed to manage
// an interactive session over a connected RAS link, including the RASMAN port
// and the RASMAN buffers. If the connected link is associated with
// a phonebook entry, then the pdata field of the SCRIPTCB structure
// will be initialized with a SCRIPTDATA, which contains all information
// needed to execute the entry's script during the interactive session.
//
// This SCRIPTDATA contains the Win9x script-processing structures
// (scanner, parsed module, and abstract syntax tree; see NTHDR2.H).
// It also contains fields needed for the Win9x circular-buffer management,
// which is implemented to allow searching for strings across read-boundaries
// (see ReadIntoBuffer() in TERMINAL.C).
//
// Initialization also creates a thread which handles the script-processing.
// This thread runs until the script completes or halts, or until
// RasScriptTerm is called with the HANDLE supplied during initialization.
// (This allows a script to be cancelled while running.)
//
// The Win9x code is completely ANSI based. Rather than edit its code
// to use generic-text (TCHAR), this port uses ANSI as well.
// In certain places, this requires conversions from Unicode,
// which is used by the rest of the RAS UI.
// To find all instances of such conversions, search for UNICODEUI
// in the source code.
//============================================================================


#ifndef _SCRIPTP_H_
#define _SCRIPTP_H_

#include "proj.h"

#ifdef UNICODEUI
#define UNICODE
#undef LPTSTR
#define LPTSTR WCHAR*
#undef TCHAR
#define TCHAR WCHAR
#include <debug.h>
#include <nouiutil.h>
#include <pbk.h>
#undef TCHAR
#define TCHAR CHAR
#undef LPTSTR
#define LPTSTR CHAR*
#undef UNICODE
#endif // UNICODEUI

#include <rasscrpt.h>



//
// flags used in internally in the "dwFlags" field
// of the SCRIPTCB structure; these are in addition to the public flags,
// and start from the high-end of the flags DWORD
//
#define RASSCRIPT_ThreadCreated     0x80000000
#define RASSCRIPT_PbuserLoaded      0x40000000
#define RASSCRIPT_PbfileLoaded      0x20000000


//----------------------------------------------------------------------------
// struct:  SCRIPTCB
//
// control block containing data and state for a script.
//----------------------------------------------------------------------------

#define SCRIPTCB    struct tagSCRIPTCB
SCRIPTCB {


    //
    // connection handle, flags for script processing,
    // notification handle (event or HWND, depending on flags)
    //
    HRASCONN    hrasconn;
    DWORD       dwFlags;
    HANDLE      hNotifier;

    //
    // phonebook entry information
    //
    PBENTRY*    pEntry;
    CHAR*       pszIpAddress;


    //
    // port input/output variables:
    //  RASMAN port handle for data I/O
    //  RASMAN send buffer
    //  RASMAN receive buffer
    //  size of current contents of receive buffer
    //  size of contents read so far by script-interpreter
    //
    HPORT       hport;
    BYTE*       pSendBuffer;
    BYTE*       pRecvBuffer;
    DWORD       dwRecvSize;
    DWORD       dwRecvRead;


    //
    // thread control variables:
    //  event signalled by RASMAN when data is received
    //  event signalled by RasScriptReceive when data has been read
    //  event signalled to stop the thread
    //  event signalled to tell that the ip address changed     bug #75226
    //  event code to be read using RasScriptGetEventCode
    //
    HANDLE      hRecvRequest;
    HANDLE      hRecvComplete;
    HANDLE      hStopRequest;
    HANDLE      hStopComplete;
    DWORD       dwEventCode;


    //
    // script processing variables; the following will be NULL
    // if the entry has no associated script:
    //  Win9x-compatible script-processing structure;
    //  Win9x-compatible connection information
    //
    SCRIPTDATA* pdata;
    SESS_CONFIGURATION_INFO sci;
};



DWORD
RsDestroyData(
    IN      SCRIPTCB*   pscript
    );

DWORD
RsInitData(
    IN      SCRIPTCB*   pscript,
    IN      LPCSTR      pszScriptPath
    );

DWORD
RsThread(
    IN      PVOID       pParam
    );

DWORD
RsThreadProcess(
    IN      SCRIPTCB*   pscript
    );


#ifdef UNICODEUI
#define lstrlenUI               lstrlenW
#define lstrcmpiUI              lstrcmpiW
#define StrCpyAFromUI           WCSTOMBS
#define StrDupUIFromA           StrDupWFromA
#define GetFileAttributesUI     GetFileAttributesW
#else
#define lstrlenUI               lstrlenA
#define lstrcmpiUI              lstrcmpiA
#define StrCpyAFromUI           lstrcpyA
#define StrDupUIFromA           StrDup
#define GetFileAttributesUI     GetFileAttributesA
#endif


#endif // _SCRIPTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\rnaspi.h ===
/* Copyright (c) 1992-1995, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access Session Management Service Provider Interface
** Public header for Session Management Provider Interface
*/

#ifndef _RNASPI_H_
#define _RNASPI_H_


//****************************************************************************
// RNA Session Management Module Service Provider Interface
//****************************************************************************

#define     RNA_MaxSMMType         32

// The type of RNA session
//
typedef enum {
    SESSTYPE_INITIATOR,
    SESSTYPE_RESPONDER
} SESSTYPE;

// Session configuration options
//
#define SMMCFG_SW_COMPRESSION       0x00000001  // Software compression is on
#define SMMCFG_PW_ENCRYPTED         0x00000002  // Encrypted password only
#define SMMCFG_NW_LOGON             0x00000004  // Logon to the network
#define SMMCFG_SW_ENCRYPTION        0x00000010  // SW encryption is okay

#define SMMCFG_ALL                  0x00000017  // All the user-specified options

// Negotiated protocols
//
#define SMMPROT_NB                  0x00000001  // NetBEUI
#define SMMPROT_IPX                 0x00000002  // IPX
#define SMMPROT_IP                  0x00000004  // TCP/IP

#define SMMPROT_ALL                 0x00000007  // all protocols negotiated

// Error codes that a MAC can return when posting disconnect message
//
#define MACERR_REMOTE_DISCONNECTING 0x00000001
#define MACERR_REMOTE_NO_RESPONSE   0x00000002


// The session confuration information
//
typedef struct tagSESS_CONFIGURATION_INFO
{
    DWORD           dwSize;
    char            szEntryName[RAS_MaxEntryName + 1];
    SESSTYPE        stSessType;
    DWORD           fdwSessOption;
    DWORD           fdwProtocols;
    BOOL            fUserSecurity;
    char            szUserName[UNLEN + 1];
    char            szPassword[PWLEN + 1];
    char            szDomainName[DNLEN + 1];
} SESS_CONFIGURATION_INFO, *PSESS_CONFIGURATION_INFO,
  FAR *LPSESS_CONFIGURATION_INFO;

// Session configuration start/stop functions
//
typedef DWORD (WINAPI * SESSSTARTPROC)(HANDLE, LPSESS_CONFIGURATION_INFO);
typedef DWORD (WINAPI * SESSSTOPPROC)(HANDLE);

// Session configuration entry point table
//
typedef struct tagRNA_FUNCS
{
    DWORD           dwSize;                    // The structure size
    SESSSTARTPROC   lpfnStart;                 // RnaSessStart Entry
    SESSSTOPPROC    lpfnStop;                  // RnaSessStop Entry
} RNA_FUNCS, *PRNA_FUNCS, FAR *LPRNA_FUNCS;

// Session Management Module initialization function
//
typedef DWORD (WINAPI * SESSINITIALIZEPROC)(LPSTR, LPRNA_FUNCS);

//****************************************************************************
// RNA Session Manager Service Interface
//****************************************************************************

typedef struct  tagRnaComplete_Info
{
    DWORD           dwSize;                     // The structure size
    DWORD           dwResult;                   // The returning error code
    UINT            idMsg;                      // SMM-specific error message ID
    BOOL            fUnload;                    // Unload the module on success?
    HANDLE          hThread;                    // Event to wait for unloading
} COMPLETE_INFO, *PCOMPLETE_INFO, FAR *LPCOMPLETE_INFO;

typedef struct  tagProjection_Info
{
    DWORD           dwSize;                     // The structure size
    RASPROJECTION   RasProjection;              // The projection type
    union {
        RASAMB      RasAMB;
        RASPPPNBF   RasPPPNBF;
        RASPPPIPX   RasPPPIPX;
        RASPPPIP    RasPPPIP;
    }               ProjInfo;
} PROJECTION_INFO, *PPROJECTION_INFO, FAR *LPPROJECTION_INFO;

//
// Responses to Session Management Request
//
DWORD WINAPI RnaComplete( HANDLE hConn, LPCOMPLETE_INFO lpci,
                          LPPROJECTION_INFO lppi, DWORD cEntries);
DWORD WINAPI RnaTerminate( HANDLE hConn, HANDLE hThread );

//
// MAC management services
//

#define IEEE_ADDRESS_LENGTH	6   // Token-ring and Ethernet address lengths

typedef struct tagMAC_FEATURES {
    DWORD           SendFeatureBits;	// A bit field of compression/features sendable
    DWORD           RecvFeatureBits;	// A bit field of compression/features receivable
    DWORD           MaxSendFrameSize;	// Maximum frame size that can be sent
                                        // must be less than or equal default
    DWORD           MaxRecvFrameSize;	// Maximum frame size that can be rcvd
                                        // must be less than or equal default
    DWORD           LinkSpeed;		// New RAW link speed in bits/sec
                                        // Ignored if 0
} MAC_FEATURES, *PMAC_FEATURES, FAR* LPMAC_FEATURES;

#ifdef _WIN64
#pragma pack(8)
#else
#pragma pack(4)
#endif
typedef struct tagMAC_OPEN {
    WORD            hRasEndpoint;        // unique for each endpoint assigned
    LPVOID          MacAdapter;          // Which binding to AsyMac to use
                                         // if NULL, will default to last binding
    DWORD           LinkSpeed;           // RAW link speed in bits per sec
    WORD            QualOfConnect;       // NdisAsyncRaw, NdisAsyncErrorControl, ...

    BYTE            IEEEAddress[IEEE_ADDRESS_LENGTH];	// The 802.5 or 802.3
    MAC_FEATURES    macFeatures;         // Readable configuration parameters
    enum {                               // All different types of device drivers
                    SERIAL_DEVICE,       // are listed here.  For instance
                    SNA_DEVICE,          // the serial driver requires diff.
                                         // irps than the SNA driver.
                    MINIPORT_DEVICE      // NDIS WAN Miniport Devices.

    }               DeviceType;

    union {                              // handles required for above device
                                         // driver types.
        LONG        FileHandle;          // the Win32 or Nt File Handle
        struct SNAHandle {
            LPVOID  ReadHandle;
            LPVOID  WriteHandle;
        };
    }               Handles;

    DWORD           hWndConn;            // Window handle for connection
    DWORD           wMsg;                // The msg to post when disconnecting
    DWORD           dwStatus;            // The status of the open call
} MAC_OPEN, *PMAC_OPEN, FAR* LPMAC_OPEN;
#pragma pack()

typedef struct tagDEVICE_PORT_INFO {
    DWORD   dwSize;
    HANDLE  hDevicePort;
    HANDLE  hLine;
    HANDLE  hCall;
    DWORD   dwAddressID;
    DWORD   dwLinkSpeed;
    char    szDeviceClass[RAS_MaxDeviceType+1];
} DEVICE_PORT_INFO, *PDEVICE_PORT_INFO, FAR* LPDEVICE_PORT_INFO;

DWORD WINAPI RnaGetDevicePort( HANDLE hConn, LPDEVICE_PORT_INFO lpdpi );
DWORD WINAPI RnaOpenMac( HANDLE hConn, HANDLE *lphMAC,
                         LPMAC_OPEN lpmo, DWORD dwSize, HANDLE hEvent );
DWORD WINAPI RnaCloseMac( HANDLE hConn );

//
// User Profile Services
//

typedef enum tagRNAACCESSTYPE { PCONLY, NETANDPC } RNAACCESSTYPE;

typedef struct tagUSER_PROFILE
{
    DWORD           dwSize;
    char            szUserName[UNLEN + 1];
    char            szPassword[PWLEN + 1];
    char            szDomainName[DNLEN + 1];
    BOOL            fUseCallbacks;
    RNAACCESSTYPE   accesstype;
    UINT            uTimeOut;
    
} USER_PROFILE, *PUSER_PROFILE, FAR *LPUSER_PROFILE;

DWORD WINAPI RnaGetUserProfile( HANDLE hConn, LPUSER_PROFILE lpUserProfile );

//
// Callback security services
//

// Callback security type
//
enum {
    CALLBACK_SECURE,
    CALLBACK_CONVENIENCE
};

DWORD WINAPI RnaGetCallbackList( DWORD * lpdwType,
                                 LPSTR lpszLocList, LPINT lpcbLoc,
                                 LPSTR lpszPhoneList, LPINT lpcbPhone,
                                 LPINT lpcEntries);
DWORD WINAPI RnaUICallbackDialog( HANDLE hConn, LPSTR lpszLocList,
                                  DWORD dwType, BOOL  fOptional,
                                  LPINT lpIndex,
                                  LPSTR lpszSelectLocation, UINT cbBuff);
DWORD WINAPI RnaStartCallback( HANDLE hConn, HANDLE hEvent);

// Miscellaneous services
//
DWORD WINAPI RnaUIUsernamePassword( HANDLE hConn,    LPSTR lpszUsername,
                                    UINT cbUsername, LPSTR lpszPassword,
                                    UINT cbPassword, LPSTR lpszDomain,
                                    UINT cbDomain);
DWORD WINAPI RnaUIChangePassword( HANDLE hConn,    LPSTR lpszUsername,
                                  UINT cbPassword);
DWORD WINAPI RnaGetOverlaidSMM ( LPSTR lpszSMMType, LPSTR lpszModuleName,
                                 LPBYTE lpBuf, DWORD dwSize);

#endif // _RNASPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\scanner.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// scanner.c
//
// This file contains the scanner functions.
//
// History:
//  05-04-95 ScottH     Created
//


#include "proj.h"
#include "rcids.h"

// This is a hack global string used by error messages.
// This should be removed when Stxerr encapsulates the script
// filename within itself.
static char g_szScript[MAX_PATH];

#define SCANNER_BUF_SIZE        1024

#define IS_WHITESPACE(ch)       (' ' == (ch) || '\t' == (ch) || '\n' == (ch) || '\r' == (ch))
#define IS_QUOTE(ch)            ('\"' == (ch))
#define IS_KEYWORD_LEAD(ch)     ('$' == (ch) || '_' == (ch) || IsCharAlpha(ch))
#define IS_KEYWORD(ch)          ('_' == (ch) || IsCharAlphaNumeric(ch))
#define IS_COMMENT_LEAD(ch)     (';' == (ch))
#define IS_EOL(ch)              ('\n' == (ch))

typedef BOOL (CALLBACK * SCANEVALPROC)(char ch, LPBOOL pbEatIt, LPARAM);

//
// Lexical mapping 
//
typedef struct tagLEX
    {
    LPSTR pszLexeme;
    SYM   sym;
    } LEX;
DECLARE_STANDARD_TYPES(LEX);


#pragma data_seg(DATASEG_READONLY)

// (The keywords are case-sensitive)
//
// This table is sorted alphabetically for binary search.
//
const LEX c_rglexKeywords[] = {
    { "FALSE",      SYM_FALSE },
    { "TRUE",       SYM_TRUE },
    { "and",        SYM_AND },
    { "boolean",    SYM_BOOLEAN },
    { "databits",   SYM_DATABITS },
    { "delay",      SYM_DELAY },
    { "do",         SYM_DO },
    { "endif",      SYM_ENDIF },
    { "endproc",    SYM_ENDPROC },
    { "endwhile",   SYM_ENDWHILE },
    { "even",       SYM_EVEN },
    { "getip",      SYM_GETIP },
    { "goto",       SYM_GOTO },
    { "halt",       SYM_HALT },
    { "if",         SYM_IF },
    { "integer",    SYM_INTEGER },
    { "ipaddr",     SYM_IPADDR },
    { "keyboard",   SYM_KEYBRD },
    { "mark",       SYM_MARK },
    { "matchcase",  SYM_MATCHCASE },
    { "none",       SYM_NONE },
    { "odd",        SYM_ODD },
    { "off",        SYM_OFF },
    { "on",         SYM_ON },
    { "or",         SYM_OR },
    { "parity",     SYM_PARITY },
    { "port",       SYM_PORT },
    { "proc",       SYM_PROC },
    { "raw",        SYM_RAW },
    { "screen",     SYM_SCREEN },
    { "set",        SYM_SET },
    { "space",      SYM_SPACE },
    { "stopbits",   SYM_STOPBITS },
    { "string",     SYM_STRING },
    { "then",       SYM_THEN },
    { "transmit",   SYM_TRANSMIT },
    { "until",      SYM_UNTIL },
    { "waitfor",    SYM_WAITFOR },
    { "while",      SYM_WHILE },
    };

#pragma data_seg()


//
// Tokens
//


#ifdef DEBUG

#pragma data_seg(DATASEG_READONLY)
struct tagSYMMAP
    {
    SYM sym;
    LPCSTR psz;
    } const c_rgsymmap[] = {
        DEBUG_STRING_MAP(SYM_EOF),
        DEBUG_STRING_MAP(SYM_IDENT),
        DEBUG_STRING_MAP(SYM_STRING_LITERAL),
        DEBUG_STRING_MAP(SYM_STRING),
        DEBUG_STRING_MAP(SYM_INTEGER),
        DEBUG_STRING_MAP(SYM_BOOLEAN),
        DEBUG_STRING_MAP(SYM_WAITFOR),
        DEBUG_STRING_MAP(SYM_WHILE),
        DEBUG_STRING_MAP(SYM_TRANSMIT),
        DEBUG_STRING_MAP(SYM_DELAY),
        DEBUG_STRING_MAP(SYM_THEN),
        DEBUG_STRING_MAP(SYM_INT_LITERAL),
        DEBUG_STRING_MAP(SYM_GETIP),
        DEBUG_STRING_MAP(SYM_IPADDR),
        DEBUG_STRING_MAP(SYM_ASSIGN),
        DEBUG_STRING_MAP(SYM_PROC),
        DEBUG_STRING_MAP(SYM_ENDPROC),
        DEBUG_STRING_MAP(SYM_HALT),
        DEBUG_STRING_MAP(SYM_IF),
        DEBUG_STRING_MAP(SYM_ENDIF),
        DEBUG_STRING_MAP(SYM_DO),
        DEBUG_STRING_MAP(SYM_RAW),
        DEBUG_STRING_MAP(SYM_MATCHCASE),
        DEBUG_STRING_MAP(SYM_SET),
        DEBUG_STRING_MAP(SYM_PORT),
        DEBUG_STRING_MAP(SYM_DATABITS),
        DEBUG_STRING_MAP(SYM_STOPBITS),
        DEBUG_STRING_MAP(SYM_PARITY),
        DEBUG_STRING_MAP(SYM_NONE),
        DEBUG_STRING_MAP(SYM_EVEN),
        DEBUG_STRING_MAP(SYM_MARK),
        DEBUG_STRING_MAP(SYM_SPACE),
        DEBUG_STRING_MAP(SYM_SCREEN),
        DEBUG_STRING_MAP(SYM_ON),
        DEBUG_STRING_MAP(SYM_OFF),
        DEBUG_STRING_MAP(SYM_NOT),
        DEBUG_STRING_MAP(SYM_OR),
        DEBUG_STRING_MAP(SYM_AND),
        DEBUG_STRING_MAP(SYM_LEQ),
        DEBUG_STRING_MAP(SYM_NEQ),
        DEBUG_STRING_MAP(SYM_LT),
        DEBUG_STRING_MAP(SYM_GT),
        DEBUG_STRING_MAP(SYM_GEQ),
        DEBUG_STRING_MAP(SYM_EQ),
        DEBUG_STRING_MAP(SYM_PLUS),
        DEBUG_STRING_MAP(SYM_MINUS),
        DEBUG_STRING_MAP(SYM_MULT),
        DEBUG_STRING_MAP(SYM_DIV),
        DEBUG_STRING_MAP(SYM_LPAREN),
        DEBUG_STRING_MAP(SYM_RPAREN),
        DEBUG_STRING_MAP(SYM_TRUE),
        DEBUG_STRING_MAP(SYM_FALSE),
        DEBUG_STRING_MAP(SYM_COLON),
        DEBUG_STRING_MAP(SYM_GOTO),
        DEBUG_STRING_MAP(SYM_COMMA),
        DEBUG_STRING_MAP(SYM_UNTIL),
        };
#pragma data_seg()

/*----------------------------------------------------------
Purpose: Returns the string form of a RES value.

Returns: String ptr
Cond:    --
*/
LPCSTR PRIVATE Dbg_GetSym(
    SYM sym)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(c_rgsymmap); i++)
        {
        if (c_rgsymmap[i].sym == sym)
            return c_rgsymmap[i].psz;
        }
    return "Unknown SYM";
    }


/*----------------------------------------------------------
Purpose: Dump the token
Returns: --
Cond:    --
*/
void PRIVATE Tok_Dump(
    PTOK this)
    {
    ASSERT(this);

    if (IsFlagSet(g_dwDumpFlags, DF_TOKEN))
        {
        switch (this->toktype)
            {
        case TT_BASE:
            TRACE_MSG(TF_ALWAYS, "line %ld: %s, '%s'", Tok_GetLine(this),
                Dbg_GetSym(Tok_GetSym(this)), Tok_GetLexeme(this));
            break;

        case TT_SZ: {
            PTOKSZ ptoksz = (PTOKSZ)this;

            TRACE_MSG(TF_ALWAYS, "line %ld: %s, {%s}", Tok_GetLine(this),
                Dbg_GetSym(Tok_GetSym(this)), TokSz_GetSz(ptoksz));
            }
            break;

        case TT_INT: {
            PTOKINT ptokint = (PTOKINT)this;

            TRACE_MSG(TF_ALWAYS, "line %ld: %s, {%d}", Tok_GetLine(this),
                Dbg_GetSym(Tok_GetSym(this)), TokInt_GetVal(ptokint));
            }
            break;

        default:
            ASSERT(0);
            break;
            }
        }
    }


#else // DEBUG

#define Dbg_GetSym(sym)   ((LPSTR)"")
#define Tok_Dump(ptok)    

#endif // DEBUG


/*----------------------------------------------------------
Purpose: Creates a new token with the given symbol sym.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Tok_New(
    PTOK * pptok,
    SYM sym,
    LPCSTR pszLexeme,
    DWORD iLine)
    {
    PTOK ptok;

    ASSERT(pptok);
    ASSERT(pszLexeme);

    ptok = GAllocType(TOK);
    if (ptok)
        {
        Tok_SetSize(ptok, sizeof(*ptok));
        Tok_SetSym(ptok, sym);
        Tok_SetType(ptok, TT_BASE);
        Tok_SetLine(ptok, iLine);
        Tok_SetLexeme(ptok, pszLexeme);
        }
    *pptok = ptok;

    return NULL != ptok ? RES_OK : RES_E_OUTOFMEMORY;
    }


/*----------------------------------------------------------
Purpose: Destroys the given token.
Returns: 
Cond:    --
*/
void PUBLIC Tok_Delete(
    PTOK this)
    {
    GFree(this);
    }


/*----------------------------------------------------------
Purpose: Duplicate the given token.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Tok_Dup(
    PTOK this,
    PTOK * pptok)
    {
    PTOK ptok;
    DWORD cbSize;

    ASSERT(this);
    ASSERT(pptok);

    cbSize = Tok_GetSize(this);

    ptok = GAlloc(cbSize);
    if (ptok)
        {
        BltByte(ptok, this, cbSize);
        }
    *pptok = ptok;

    return NULL != ptok ? RES_OK : RES_E_OUTOFMEMORY;
    }


/*----------------------------------------------------------
Purpose: Creates a new string token with the given string.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC TokSz_New(
    PTOK * pptok,
    SYM sym,
    LPCSTR pszLexeme,
    DWORD iLine,
    LPCSTR psz)
    {
    PTOKSZ ptoksz;

    ASSERT(pptok);

    ptoksz = GAllocType(TOKSZ);
    if (ptoksz)
        {
        Tok_SetSize(ptoksz, sizeof(*ptoksz));
        Tok_SetSym(ptoksz, sym);
        Tok_SetType(ptoksz, TT_SZ);
        Tok_SetLine(ptoksz, iLine);
        Tok_SetLexeme(ptoksz, pszLexeme);
        if (psz)
            TokSz_SetSz(ptoksz, psz);
        else
            *ptoksz->sz = 0;
        }
    *pptok = (PTOK)ptoksz;

    return NULL != ptoksz ? RES_OK : RES_E_OUTOFMEMORY;
    }


/*----------------------------------------------------------
Purpose: Creates a new integer token with the given value.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC TokInt_New(
    PTOK * pptok,
    SYM sym,
    LPCSTR pszLexeme,
    DWORD iLine,
    int n)
    {
    PTOKINT ptokint;

    ASSERT(pptok);

    ptokint = GAllocType(TOKINT);
    if (ptokint)
        {
        Tok_SetSize(ptokint, sizeof(*ptokint));
        Tok_SetSym(ptokint, sym);
        Tok_SetType(ptokint, TT_INT);
        Tok_SetLine(ptokint, iLine);
        Tok_SetLexeme(ptokint, pszLexeme);
        TokInt_SetVal(ptokint, n);
        }
    *pptok = (PTOK)ptokint;

    return NULL != ptokint ? RES_OK : RES_E_OUTOFMEMORY;
    }


/*----------------------------------------------------------
Purpose: Compare two strings.  This function does not take
         localization into account, so the comparison of two
         strings will be based off the English code page.

         This is required because the lexical keyword table
         is hand-sorted to the English language.  Using the
         NLS lstrcmp would not produce the correct results.

Returns: strcmp standard
Cond:    --
*/
int PRIVATE strcmpraw(
    LPCSTR psz1,
    LPCSTR psz2)
    {
    for (; *psz1 == *psz2; 
        psz1 = CharNext(psz1), 
        psz2 = CharNext(psz2))
        {
        if (0 == *psz1)
            return 0;
        }
    return *psz1 - *psz2;
    }


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Returns the SYM value that matches the given lexeme.
         If the given lexeme is not found in the list of 
         keyword token values, then SYM_IDENT is returned.

         Performs a linear search.

Returns: see above
Cond:    --
*/
SYM PRIVATE SymFromKeywordLinear(
    LPCSTR pszLex)
    {
    int i;

    ASSERT(pszLex);

    for (i = 0; i < ARRAY_ELEMENTS(c_rglexKeywords); i++)
        {
        // Case-sensitive
        if (0 == strcmpraw(c_rglexKeywords[i].pszLexeme, pszLex))
            {
            return c_rglexKeywords[i].sym;
            }
        }
    return SYM_IDENT;
    }
#endif


/*----------------------------------------------------------
Purpose: Returns the SYM value that matches the given lexeme.
         If the given lexeme is not found in the list of 
         keyword token values, then SYM_IDENT is returned.

         Peforms a binary search.

Returns: see above
Cond:    --
*/
SYM PRIVATE SymFromKeyword(
    LPCSTR pszLex)
    {
    static const s_cel = ARRAY_ELEMENTS(c_rglexKeywords);

    SYM symRet = SYM_IDENT;    // assume no match
    int nCmp;
    int iLow = 0;
    int iMid;
    int iHigh = s_cel - 1;

    ASSERT(pszLex);

    // (OK for cp == 0.  Duplicate lexemes not allowed.)

    while (iLow <= iHigh)
        {
        iMid = (iLow + iHigh) / 2;

        nCmp = strcmpraw(pszLex, c_rglexKeywords[iMid].pszLexeme);

        if (0 > nCmp)
            iHigh = iMid - 1;       // First is smaller
        else if (0 < nCmp)
            iLow = iMid + 1;        // First is larger
        else
            {
            // Match
            symRet = c_rglexKeywords[iMid].sym;
            break;
            }
        }

    // Check if we get the same result with linear search
    ASSERT(SymFromKeywordLinear(pszLex) == symRet);

    return symRet;
    }


//
// Stxerr
//


/*----------------------------------------------------------
Purpose: Initializes a syntax error structure

Returns: --
Cond:    --
*/
void PUBLIC Stxerr_Init(
    PSTXERR this,
    LPCSTR pszLex,
    DWORD iLine,
    RES res)
    {
    ASSERT(this);
    ASSERT(pszLex);

    lstrcpyn(this->szLexeme, pszLex, sizeof(this->szLexeme));
    this->iLine = iLine;
    this->res = res;
    }


// 
// Scanner
//


/*----------------------------------------------------------
Purpose: Returns TRUE if the scanner structure is valid
         to read a file.

Returns: See above
Cond:    --
*/
BOOL PRIVATE Scanner_Validate(
    PSCANNER this)
    {
    return (this && 
            (IsFlagSet(this->dwFlags, SCF_NOSCRIPT) || 
                INVALID_HANDLE_VALUE != this->hfile) && 
            this->pbBuffer &&
            this->psci);
    }


/*----------------------------------------------------------
Purpose: Creates a scanner.

Returns: RES_OK
         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_Create(
    PSCANNER * ppscanner,
    PSESS_CONFIGURATION_INFO psci)
    {
    RES res;

    DBG_ENTER(Scanner_Create);

    ASSERT(ppscanner);
    ASSERT(psci);

    if (ppscanner)
        {
        PSCANNER pscanner;

        res = RES_OK;       // assume success

        pscanner = GAllocType(SCANNER);
        if (!pscanner)
            res = RES_E_OUTOFMEMORY;
        else
            {
            pscanner->pbBuffer = GAlloc(SCANNER_BUF_SIZE);
            if (!pscanner->pbBuffer)
                res = RES_E_OUTOFMEMORY;
            else
                {
                if ( !SACreate(&pscanner->hsaStxerr, sizeof(STXERR), 8) )
                    res = RES_E_OUTOFMEMORY;
                else
                    {
                    pscanner->hfile = INVALID_HANDLE_VALUE;
                    pscanner->psci = psci;
                    SetFlag(pscanner->dwFlags, SCF_NOSCRIPT);
                    }
                }
            }
    
        if (RFAILED(res))
            {
            Scanner_Destroy(pscanner);
            pscanner = NULL;
            }

        *ppscanner = pscanner;    
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Scanner_Create, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Destroys a scanner.

Returns: RES_OK
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_Destroy(
    PSCANNER this)
    {
    RES res;

    DBG_ENTER(Scanner_Destroy);

    if (this)
        {
        if (INVALID_HANDLE_VALUE != this->hfile)
            {
            TRACE_MSG(TF_GENERAL, "Closing script");
            CloseHandle(this->hfile);
            }

        if (this->pbBuffer)
            {
            GFree(this->pbBuffer);
            }

        if (this->hsaStxerr)
            {
            SADestroy(this->hsaStxerr);
            }

        GFree(this);
        res = RES_OK;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Scanner_Destroy, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Opens a script file and associates it with this scanner.

Returns: RES_OK
         RES_E_FAIL (script cannot be opened)
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_OpenScript(
    PSCANNER this,
    LPCSTR pszPath)
    {
    RES res;

    DBG_ENTER_SZ(Scanner_OpenScript, pszPath);

    if (this && pszPath)
        {
        DEBUG_BREAK(BF_ONOPEN);

        // (shouldn't have a file open already)
        ASSERT(INVALID_HANDLE_VALUE == this->hfile);    

        // Open script
        this->hfile = CreateFile(pszPath, GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (INVALID_HANDLE_VALUE == this->hfile)
            {
            TRACE_MSG(TF_GENERAL, "Failed to open script \"%s\"", pszPath);

            res = RES_E_FAIL;
            }
        //
        // .Net bug# 522307 Specifying the dialup script file as the COM
        // Port of the Modem will cause explorer to AV.
        //
        else if (GetFileType(this->hfile) != FILE_TYPE_DISK)
        {
            res = RES_E_FAIL;
        }
        else
            {
            // Reset buffer fields
            TRACE_MSG(TF_GENERAL, "Opened script \"%s\"", pszPath);

            lstrcpyn(this->szScript, pszPath, sizeof(this->szScript));
            lstrcpyn(g_szScript, pszPath, sizeof(g_szScript));

            ClearFlag(this->dwFlags, SCF_NOSCRIPT);

            this->pbCur = this->pbBuffer;
            this->cbUnread = 0;
            this->chUnget = 0;
            this->chTailByte = 0;
            this->iLine = 1;
            res = RES_OK;
            }
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Scanner_OpenScript, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Reads enough bytes from the file to fill the buffer.

Returns: RES_OK
         RES_E_FAIL (if ReadFile failed)
         RES_E_EOF

Cond:    --
*/
RES PRIVATE Scanner_Read(
    PSCANNER this)
    {
    RES res;
    BOOL bResult;
    LPBYTE pb;
    DWORD cb;
    DWORD cbUnread;

    DBG_ENTER(Scanner_Read);

    ASSERT(Scanner_Validate(this));

    // Move the unread bytes to the front of the buffer before reading
    // more bytes.  This function may get called when there are still 
    // some unread bytes in the buffer.  We do not want to lose those 
    // bytes.  

    // I'm too lazy to make this a circular buffer.
    BltByte(this->pbBuffer, this->pbCur, this->cbUnread);
    this->pbCur = this->pbBuffer;

    pb = this->pbBuffer + this->cbUnread;
    cb = (DWORD)(SCANNER_BUF_SIZE - (pb - this->pbBuffer));
    bResult = ReadFile(this->hfile, pb, cb, &cbUnread, NULL);
    if (!bResult)
        {
        res = RES_E_FAIL;
        }
    else
        {
        // End of file?
        if (0 == cbUnread)
            {
            // Yes
            res = RES_E_EOF;
            }
        else
            {
            // No
            this->cbUnread += cbUnread;

            res = RES_OK;
            }
        }

    DBG_EXIT_RES(Scanner_Read, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Gets the next character in the file (buffer).  This
         function will scan the file buffer using CharNext,
         and store the current byte in chCur.  
         
         Note for DBCS characters this means that only the 
         lead byte will be stored in chCur.  If chCur is a 
         lead byte, the trailing byte will be stored in 
         chTailByte.

Returns: RES_OK
         RES_E_EOF
Cond:    --
*/
RES PRIVATE Scanner_GetChar(
    PSCANNER this)
    {
    RES res = RES_OK;       // assume success

    ASSERT(Scanner_Validate(this));

    if (0 != this->chUnget)
        {
        this->chCur = this->chUnget;
        this->chUnget = 0;
        }
    else
        {
        // Time to read more into the buffer?
        if (0 == this->cbUnread)
            {
            // Yes
            res = Scanner_Read(this);
            }

        if (RSUCCEEDED(res))
            {
            LPBYTE pbCur = this->pbCur;
            LPBYTE pbNext = CharNext(pbCur);
            DWORD cb;
            BOOL bIsLeadByte;

            this->chCur = *pbCur;

            bIsLeadByte = IsDBCSLeadByte(this->chCur);

            // We might be at the end of the unread characters, where
            // a DBCS character is cut in half (ie, the trailing byte
            // is missing).  Are we in this case?
            if (bIsLeadByte && 1 == this->cbUnread)
                {
                // Yes; read more into the buffer, we don't care about
                // the return value
                Scanner_Read(this);

                // this->pbCur might have changed
                pbCur = this->pbCur;
                pbNext = CharNext(pbCur);
                }

            cb = (DWORD)(pbNext - pbCur);

            this->cbUnread -= cb;
            this->pbCur = pbNext;

            // Do we need to save away the whole DBCS character?
            if (bIsLeadByte)
                {
                // Yes
                ASSERT(2 == cb);        // We don't support MBCS
                this->chTailByte = pbCur[1];
                }

            if (IS_EOL(this->chCur))
                {
                this->iLine++;
                };
            }
        else
            this->chCur = 0;
        }
    return res;
    }


/*----------------------------------------------------------
Purpose: Ungets the current character back to the buffer.

Returns: RES_OK
         RES_E_FAIL (if a character was already ungotten since the last get)
Cond:    --
*/
RES PRIVATE Scanner_UngetChar(
    PSCANNER this)
    {
    RES res;

    ASSERT(Scanner_Validate(this));

    if (0 != this->chUnget)
        {
        res = RES_E_FAIL;
        }
    else
        {
        this->chUnget = this->chCur;
        this->chCur = 0;
        res = RES_OK;
        }
    return res;
    }


/*----------------------------------------------------------
Purpose: Skips white space

Returns: --
Cond:    --
*/
void PRIVATE Scanner_SkipBlanks(
    PSCANNER this)
    {
    ASSERT(Scanner_Validate(this));

    while (IS_WHITESPACE(this->chCur))
        {
        Scanner_GetChar(this);
        }
    }


/*----------------------------------------------------------
Purpose: Skips commented line

Returns: --
Cond:    --
*/
void PRIVATE Scanner_SkipComment(
    PSCANNER this)
    {
    RES res;
    char chSav = this->chCur;

    ASSERT(Scanner_Validate(this));
    ASSERT(IS_COMMENT_LEAD(this->chCur));

    // Scan to end of line
    do
        {
        res = Scanner_GetChar(this);
        } while (RES_OK == res && !IS_EOL(this->chCur));

    if (IS_EOL(this->chCur))
        Scanner_GetChar(this);
    }


/*----------------------------------------------------------
Purpose: Skips white space and comments

Returns: --
Cond:    --
*/
void PRIVATE Scanner_SkipBadlands(
    PSCANNER this)
    {
    ASSERT(Scanner_Validate(this));

    Scanner_GetChar(this);

    Scanner_SkipBlanks(this);
    while (IS_COMMENT_LEAD(this->chCur))
        {
        Scanner_SkipComment(this);
        Scanner_SkipBlanks(this);
        }
    }


/*----------------------------------------------------------
Purpose: This function scans and copies the characters that are
         scanned into pszBuf until the provided callback says to stop.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Scanner_ScanForCharacters(
    PSCANNER this,
    LPSTR pszBuf,
    UINT cbBuf,
    SCANEVALPROC pfnEval,
    LPARAM lParam)
    {
    RES res = RES_E_MOREDATA;

    ASSERT(this);
    ASSERT(pszBuf);
    ASSERT(pfnEval);

    // Don't use CharNext because we are iterating on a single-byte
    // basis.
    for (; 0 < cbBuf; cbBuf--, pszBuf++)
        {
        res = Scanner_GetChar(this);
        if (RES_OK == res)
            {
            // Delimiter?
            BOOL bEatIt = FALSE;

            if (pfnEval(this->chCur, &bEatIt, lParam))
                {
                if (!bEatIt)
                    Scanner_UngetChar(this);
                break;  // done
                }

            // Save the whole DBCS character?
            if (IsDBCSLeadByte(this->chCur))
                {
                // Yes; is there enough room?
                if (2 <= cbBuf)
                    {
                    // Yes
                    *pszBuf = this->chCur;
                    pszBuf++;      // Increment by single byte
                    cbBuf--;
                    *pszBuf = this->chTailByte;
                    }
                else
                    {
                    // No; stop iterating
                    break;
                    }
                }
            else
                {
                // No; this is just a single byte
                *pszBuf = this->chCur;
                }
            }
        else
            break;
        }

    *pszBuf = 0;    // add terminator

    return res;
    }


/*----------------------------------------------------------
Purpose: Determines if the given character is a delimiter
         for a keyword.

Returns: TRUE (if the character is a delimiter)
         FALSE (otherwise)

Cond:    --
*/
BOOL CALLBACK EvalKeywordChar(
    char ch,            // Always the first byte of a DBCS character
    LPBOOL pbEatIt,     // Default is FALSE on entry
    LPARAM lparam)
    {
    return !IS_KEYWORD(ch);
    }


/*----------------------------------------------------------
Purpose: Scans for the keyword.  Returns a new token.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Scanner_GetKeywordTok(
    PSCANNER this,
    PTOK * pptok)
    {
    char sz[MAX_BUF_KEYWORD];
    UINT cbBuf;
    SYM sym;

    ASSERT(this);
    ASSERT(pptok);

    *sz = this->chCur;
    cbBuf = sizeof(sz) - 1 - 1;     // reserve place for terminator

    Scanner_ScanForCharacters(this, &sz[1], cbBuf, EvalKeywordChar, 0);

    sym = SymFromKeyword(sz);
    return Tok_New(pptok, sym, sz, this->iLine);
    }


/*----------------------------------------------------------
Purpose: Determines if the given character is a delimiter
         for a string constant.

         *pbEatIt is set to TRUE if the character must be 
         eaten (not copied to the buffer).  Only used if
         this function returns TRUE.

Returns: TRUE (if the character is a delimiter)
         FALSE (otherwise)

Cond:    --
*/
BOOL CALLBACK EvalStringChar(
    char ch,            // Always the first byte of a DBCS character
    LPBOOL pbEatIt,     // Default is FALSE on entry
    LPARAM lparam)      
    {
    BOOL bRet;
    PBOOL pbEncounteredBS = (PBOOL)lparam;
    BOOL bBS = *pbEncounteredBS;

    *pbEncounteredBS = FALSE;

    if (IS_QUOTE(ch))
        {
        // Is this after
        if (bBS)
            bRet = FALSE;
        else
            {
            *pbEatIt = TRUE;
            bRet = TRUE;
            }
        }
    else if (IS_BACKSLASH(ch))
        {
        if (!bBS)
            *pbEncounteredBS = TRUE;
        bRet = FALSE;
        }
    else
        bRet = FALSE;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Scans for the string constant.  Returns a new token.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Scanner_GetStringTok(
    PSCANNER this,
    PTOK * pptok)
    {
    char sz[MAX_BUF];
    UINT cbBuf;
    BOOL bBS;

    ASSERT(this);
    ASSERT(pptok);

    *sz = 0;
    cbBuf = sizeof(sz) - 1;     // reserve place for terminator
    bBS = FALSE;

    Scanner_ScanForCharacters(this, sz, cbBuf, EvalStringChar, (LPARAM)&bBS);

    return TokSz_New(pptok, SYM_STRING_LITERAL, "\"", this->iLine, sz);
    }


/*----------------------------------------------------------
Purpose: Determines if the given character is a delimiter
         for a keyword.

Returns: TRUE (if the character is a delimiter)
         FALSE (otherwise)

Cond:    --
*/
BOOL CALLBACK EvalNumberChar(
    char ch,            // Always the first byte of a DBCS character
    LPBOOL pbEatIt,     // Default is FALSE on entry
    LPARAM lparam)
    {
    return !IS_DIGIT(ch);
    }


/*----------------------------------------------------------
Purpose: Scans for the number constant.  Returns a new token.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Scanner_GetNumberTok(
    PSCANNER this,
    PTOK * pptok)
    {
    char sz[MAX_BUF];
    UINT cbBuf;
    int n;

    ASSERT(this);
    ASSERT(pptok);

    *sz = this->chCur;
    cbBuf = sizeof(sz) - 1 - 1;     // reserve place for terminator

    Scanner_ScanForCharacters(this, &sz[1], cbBuf, EvalNumberChar, 0);

    n = AnsiToInt(sz);
    return TokInt_New(pptok, SYM_INT_LITERAL, sz, this->iLine, n);
    }


/*----------------------------------------------------------
Purpose: Scans for the punctuation.  Returns a new token.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Scanner_GetPuncTok(
    PSCANNER this,
    PTOK * pptok)
    {
    SYM sym = SYM_UNKNOWN;
    char rgch[3];
    char chT;

    ASSERT(this);
    ASSERT(pptok);

    chT = this->chCur;
    *rgch = this->chCur;
    rgch[1] = 0;

    switch (chT)
        {
    case '=':
    case '<':
    case '>':
        Scanner_GetChar(this);
        if ('=' == this->chCur)
            {
            switch (chT)
                {
            case '=':
                sym = SYM_EQ;
                break;

            case '<':
                sym = SYM_LEQ;
                break;

            case '>':
                sym = SYM_GEQ;
                break;

            default:
                // Should never get here
                ASSERT(0);
                break;
                }
            rgch[1] = this->chCur;
            rgch[2] = 0;
            }
        else
            {
            switch (chT)
                {
            case '=':
                sym = SYM_ASSIGN;
                break;

            case '<':
                sym = SYM_LT;
                break;

            case '>':
                sym = SYM_GT;
                break;

            default:
                // Should never get here
                ASSERT(0);
                break;
                }
            Scanner_UngetChar(this);
            }
        break;

    case '!':
        Scanner_GetChar(this);
        if ('=' == this->chCur)
            {
            sym = SYM_NEQ;
            rgch[1] = this->chCur;
            rgch[2] = 0;
            }
        else
            {
            sym = SYM_NOT;
            Scanner_UngetChar(this);
            }
        break;

    case '+':
        sym = SYM_PLUS;
        break;

    case '-':
        sym = SYM_MINUS;
        break;

    case '*':
        sym = SYM_MULT;
        break;

    case '/':
        sym = SYM_DIV;
        break;

    case '(':
        sym = SYM_LPAREN;
        break;

    case ')':
        sym = SYM_RPAREN;
        break;

    case ':':
        sym = SYM_COLON;
        break;

    case ',':
        sym = SYM_COMMA;
        break;

    default:
        if (0 == this->chCur)
            {
            *rgch = 0;
            sym = SYM_EOF;
            }
        else
            {
            sym = SYM_UNKNOWN;
            }
        break;
        }


    return Tok_New(pptok, sym, rgch, this->iLine);
    }


/*----------------------------------------------------------
Purpose: Scans for the next token.  The next token is created
         and returned in *pptok.

Returns: RES_OK
         RES_E_FAIL (unexpected character)

Cond:    --
*/
RES PUBLIC Scanner_GetToken(
    PSCANNER this,
    PTOK * pptok)
    {
    RES res;

    DBG_ENTER(Scanner_GetToken);

    ASSERT(Scanner_Validate(this));
    ASSERT(pptok);

    if (this->ptokUnget)
        {
        this->ptokCur = this->ptokUnget;
        *pptok = this->ptokCur;
        this->ptokUnget = NULL;
        res = RES_OK;
        }
    else
        {
        Scanner_SkipBadlands(this);
        
        // Is this a keyword?
        if (IS_KEYWORD_LEAD(this->chCur))
            {
            // Yes; or maybe an identifier
            res = Scanner_GetKeywordTok(this, pptok);
            }

        // Is this a string constant?
        else if (IS_QUOTE(this->chCur))
            {
            // Yes
            res = Scanner_GetStringTok(this, pptok);
            }

        // Is this a number?
        else if (IS_DIGIT(this->chCur))
            {
            // Yes
            res = Scanner_GetNumberTok(this, pptok);
            }

        // Is this punctuation or something else?
        else
            {
            res = Scanner_GetPuncTok(this, pptok);
            }

        this->ptokCur = *pptok;

#ifdef DEBUG
        if (RSUCCEEDED(res))
            {
            Tok_Dump(*pptok);
            }
#endif
        }

    DBG_EXIT_RES(Scanner_GetToken, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Ungets the current token.

Returns: RES_OK

         RES_E_FAIL (if a token was already ungotten since the
                   last get)

Cond:    --
*/
RES PUBLIC Scanner_UngetToken(
    PSCANNER this)
    {
    RES res;

    ASSERT(Scanner_Validate(this));

    if (this->ptokUnget)
        {
        ASSERT(0);
        res = RES_E_FAIL;
        }
    else
        {
        this->ptokUnget = this->ptokCur;
        this->ptokCur = NULL;
        res = RES_OK;
        }
    return res;
    }


/*----------------------------------------------------------
Purpose: Returns the line of the currently read token.

Returns: see above
Cond:    --
*/
DWORD PUBLIC Scanner_GetLine(
    PSCANNER this)
    {
    DWORD iLine;

    ASSERT(this);

    if (this->ptokUnget)
        {
        iLine = Tok_GetLine(this->ptokUnget);
        }
    else
        {
        iLine = this->iLine;
        }
    return iLine;
    }    

/*----------------------------------------------------------
Purpose: This function peeks at the next token and returns 
         the sym type.

Returns: RES_OK

         RES_E_FAIL
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_Peek(
    PSCANNER this,
    PSYM psym)
    {
    RES res;
    PTOK ptok;

    ASSERT(this);
    ASSERT(psym);

    DBG_ENTER(Scanner_Peek);

    res = Scanner_GetToken(this, &ptok);
    if (RSUCCEEDED(res))
        {
        *psym = Tok_GetSym(ptok);
        Scanner_UngetToken(this);
        res = RES_OK;
        }

    DBG_EXIT_RES(Scanner_Peek, res);

    return res;
    }
    

/*----------------------------------------------------------
Purpose: This function expects that the next token that will
         be read from the scanner is of the given sym type.
         
         If the next token is of the expected type, the function
         eats the token and returns RES_OK.  Otherwise, the
         function fails.

Returns: RES_OK

         RES_E_FAIL
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_ReadToken(
    PSCANNER this,
    SYM sym)
    {
    RES res;
    PTOK ptok;

    DBG_ENTER(Scanner_ReadToken);

    res = Scanner_GetToken(this, &ptok);
    if (RSUCCEEDED(res))
        {
        if (Tok_GetSym(ptok) == sym)
            {
            // Eat the token
            Tok_Delete(ptok);
            res = RES_OK;
            }
        else
            {
            Scanner_UngetToken(this);
            res = RES_E_FAIL;
            }
        }

    DBG_EXIT_RES(Scanner_ReadToken, res);

    return res;
    }
    

/*----------------------------------------------------------
Purpose: This function reads the next token only if it is of
         the given type.
         
         If the next token is of the expected type, the function
         eats the token and returns RES_OK.  Otherwise, the
         token is retained for the next read, and RES_FALSE is 
         returned.

         If pptok is non-NULL and RES_OK is returned, the 
         retrieved token is returned in *pptok.

Returns: RES_OK
         RES_FALSE (if the next token is not of the expected type)

         RES_E_FAIL
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_CondReadToken(
    PSCANNER this,
    SYM symExpect,
    PTOK * pptok)       // May be NULL
    {
    RES res;
    PTOK ptok;

    DBG_ENTER(Scanner_CondReadToken);

    res = Scanner_GetToken(this, &ptok);
    if (RSUCCEEDED(res))
        {
        if (Tok_GetSym(ptok) == symExpect)
            {
            // Eat the token
            if (pptok)
                *pptok = ptok;
            else
                Tok_Delete(ptok);

            res = RES_OK;
            }
        else
            {
            if (pptok)
                *pptok = NULL;

            Scanner_UngetToken(this);

            res = RES_FALSE;        // not a failure
            }
        }

    DBG_EXIT_RES(Scanner_CondReadToken, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Wrapper to add an error for the scanner.

Returns: resErr 

Cond:    --
*/
RES PUBLIC Scanner_AddError(
    PSCANNER this,
    PTOK ptok,          // May be NULL
    RES resErr)
    {
    STXERR stxerr;

    ASSERT(this);
    ASSERT(this->hsaStxerr);

    // Initialize the structure

    if (NULL == ptok)
        {
        if (RSUCCEEDED(Scanner_GetToken(this, &ptok)))
            {
            Stxerr_Init(&stxerr, Tok_GetLexeme(ptok), Tok_GetLine(ptok), resErr);

            Tok_Delete(ptok);
            }
        else
            {
            Stxerr_Init(&stxerr, "", Scanner_GetLine(this), resErr);
            }
        }
    else
        {
        Stxerr_Init(&stxerr, Tok_GetLexeme(ptok), Tok_GetLine(ptok), resErr);
        }

    // Add to the list of errors
    SAInsertItem(this->hsaStxerr, SA_APPEND, &stxerr);

    return resErr;
    }


/*----------------------------------------------------------
Purpose: Adds an error to the list.

Returns: resErr
Cond:    --
*/
RES PUBLIC Stxerr_Add(
    HSA hsaStxerr,
    LPCSTR pszLexeme,
    DWORD iLine,
    RES resErr)
    {
    STXERR stxerr;
    LPCSTR psz;

    ASSERT(hsaStxerr);

    if (pszLexeme)
        psz = pszLexeme;
    else
        psz = "";

    // Add to the list of errors
    Stxerr_Init(&stxerr, psz, iLine, resErr);
    
    SAInsertItem(hsaStxerr, SA_APPEND, &stxerr);

    return resErr;
    }


/*----------------------------------------------------------
Purpose: Adds an error to the list.

Returns: resErr
Cond:    --
*/
RES PUBLIC Stxerr_AddTok(
    HSA hsaStxerr,
    PTOK ptok,
    RES resErr)
    {
    LPCSTR pszLexeme;
    DWORD iLine;

    ASSERT(hsaStxerr);

    if (ptok)
        {
        pszLexeme = Tok_GetLexeme(ptok);
        iLine = Tok_GetLine(ptok);
        }
    else
        {
        pszLexeme = NULL;
        iLine = 0;
        }
    
    return Stxerr_Add(hsaStxerr, pszLexeme, iLine, resErr);
    }


/*----------------------------------------------------------
Purpose: Shows a series of message boxes of all the errors 
         found in the script.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Stxerr_ShowErrors(
    HSA hsaStxerr,
    HWND hwndOwner)
    {
    DWORD cel;
    DWORD i;
    STXERR stxerr;

#ifndef WINNT_RAS
//
// On Win95, syntax-errors are reported using a series of message-boxes.
// On NT, syntax-error information is written to a file
// named %windir%\system32\ras\script.log.
//

    cel = SAGetCount(hsaStxerr);
    for (i = 0; i < cel; i++)
        {
        BOOL bRet = SAGetItem(hsaStxerr, i, &stxerr);
        ASSERT(bRet);

        if (bRet)
            {
            UINT ids = IdsFromRes(Stxerr_GetRes(&stxerr));
            if (0 != ids)
                {
                MsgBox(g_hinst,
                    hwndOwner,
                    MAKEINTRESOURCE(ids),
                    MAKEINTRESOURCE(IDS_CAP_Script),
                    NULL,
                    MB_ERROR,
                    g_szScript,
                    Stxerr_GetLine(&stxerr),
                    Stxerr_GetLexeme(&stxerr));
                }
            }
        }

#else // !WINNT_RAS

    RxLogErrors(((SCRIPTDATA*)hwndOwner)->hscript, (VOID*)hsaStxerr);

#endif // !WINNT_RAS
    return RES_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\typechk.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// typechk.c
//
// This file contains the typechecking functions.
//
// The typechecking rules are:
//
// waitfor      Takes a string expression
// transmit     Takes a string expression
// delay        Takes an integer expression
// while        Evaluates a boolean expression
// set ipaddr   Takes a string expression
// getip        Takes an integer expression
// 
//
//
// History:
//  06-15-95 ScottH     Created
//


#include "proj.h"
#include "rcids.h"

RES     PRIVATE Stmt_Typecheck(PSTMT this, PSYMTAB pst, HSA hsaStxerr);


/*----------------------------------------------------------
Purpose: Typechecks whether an identifier is a valid type.

Returns: RES_OK
         RES_E_REQUIRELABEL
         RES_E_UNDEFINED

Cond:    --
*/
RES PRIVATE Ident_Typecheck(
    LPCSTR pszIdent,
    DATATYPE dt,
    PDATATYPE pdt,          // May be NULL
    DWORD iLine,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res = RES_OK;
    PSTE pste;

    if (RES_OK == Symtab_FindEntry(pst, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        if (pdt)
            {
            *pdt = STE_GetDataType(pste);
            res = RES_OK;
            }
        else if (dt == STE_GetDataType(pste))
            {
            res = RES_OK;
            }
        else
            {
            switch (dt)
                {
            case DATA_LABEL:
                res = RES_E_REQUIRELABEL;
                break;

            case DATA_STRING:
                res = RES_E_REQUIRESTRING;
                break;

            case DATA_INT:
                res = RES_E_REQUIREINT;
                break;

            case DATA_BOOL:
                res = RES_E_REQUIREBOOL;
                break;

            default:
                ASSERT(0);
                break;
                }
            Stxerr_Add(hsaStxerr, pszIdent, iLine, res);
            }
        }
    else
        {
        res = Stxerr_Add(hsaStxerr, pszIdent, iLine, RES_E_UNDEFINED);
        }
        
    return res;
    }


//
// Exprs
//

RES PRIVATE Expr_Typecheck(PEXPR this, PSYMTAB pst, HSA hsaStxerr);


/*----------------------------------------------------------
Purpose: Return a string given a binoptype.

Returns: Pointer to string
Cond:    --
*/
LPCSTR PRIVATE SzFromBot(
    BINOPTYPE bot)
    {
#pragma data_seg(DATASEG_READONLY)
    static const LPCSTR s_mpbotsz[] = 
        { "'or' operand", 
          "'and' operand", 
          "'<=' operand", 
          "'<' operand", 
          "'>=' operand", 
          "'>' operand", 
          "'!=' operand", 
          "'==' operand", 
          "'+' operand", 
          "'-' operand", 
          "'*' operand", 
          "'/' operand",
        };
#pragma data_seg()
    
    if (ARRAY_ELEMENTS(s_mpbotsz) <= bot)
        {
        ASSERT(0);
        return "";
        }

    return s_mpbotsz[bot];
    }


/*----------------------------------------------------------
Purpose: Return a string given a unoptype.

Returns: Pointer to string
Cond:    --
*/
LPCSTR PRIVATE SzFromUot(
    UNOPTYPE uot)
    {
#pragma data_seg(DATASEG_READONLY)
    static const LPCSTR s_mpuotsz[] = 
        {
        "unary '-' operand", 
        "'!' operand", 
        "'getip' parameter",
        };
#pragma data_seg()
    
    if (ARRAY_ELEMENTS(s_mpuotsz) <= uot)
        {
        ASSERT(0);
        return "";
        }

    return s_mpuotsz[uot];
    }


/*----------------------------------------------------------
Purpose: Typechecks a variable reference expression.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE VarExpr_Typecheck(
    PEXPR this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    LPSTR pszIdent;
    PSTE pste;

    ASSERT(this);
    ASSERT(hsaStxerr);

    pszIdent = VarExpr_GetIdent(this);

    if (RES_OK == Symtab_FindEntry(pst, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        DATATYPE dt = STE_GetDataType(pste);

        ASSERT(DATA_BOOL == dt || DATA_INT == dt || DATA_STRING == dt);

        Expr_SetDataType(this, dt);
        res = RES_OK;
        }
    else
        {
        res = Stxerr_Add(hsaStxerr, pszIdent, Ast_GetLine(this), RES_E_UNDEFINED);
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typechecks a binary operator expression.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE BinOpExpr_Typecheck(
    PEXPR this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr1;
    PEXPR pexpr2;

    ASSERT(this);
    ASSERT(hsaStxerr);

    pexpr1 = BinOpExpr_GetExpr1(this);
    res = Expr_Typecheck(pexpr1, pst, hsaStxerr);
    if (RSUCCEEDED(res))
        {
        pexpr2 = BinOpExpr_GetExpr2(this);
        res = Expr_Typecheck(pexpr2, pst, hsaStxerr);
        if (RSUCCEEDED(res))
            {
            BINOPTYPE bot = BinOpExpr_GetType(this);

            // Types must match
            if (Expr_GetDataType(pexpr1) != Expr_GetDataType(pexpr2))
                {
                res = RES_E_TYPEMISMATCH;
                }
            else
                {
                // Just choose one of the datatypes, since they
                // should be the same.
                DATATYPE dt = Expr_GetDataType(pexpr1);

                switch (bot)
                    {
                case BOT_OR:
                case BOT_AND:
                    Expr_SetDataType(this, DATA_BOOL);

                    if (DATA_BOOL != dt)
                        res = RES_E_REQUIREBOOL;
                    break;

                case BOT_PLUS:
                    Expr_SetDataType(this, dt);

                    // String + string means concatenate.
                    if (DATA_INT != dt && DATA_STRING != dt)
                        res = RES_E_REQUIREINTSTRING;
                    break;

                case BOT_NEQ:
                case BOT_EQ:
                    Expr_SetDataType(this, DATA_BOOL);

                    if (DATA_INT != dt && DATA_STRING != dt && 
                        DATA_BOOL != dt)
                        res = RES_E_REQUIREINTSTRBOOL;
                    break;

                case BOT_LEQ:
                case BOT_LT:
                case BOT_GEQ:
                case BOT_GT:
                    Expr_SetDataType(this, DATA_BOOL);

                    if (DATA_INT != dt)
                        res = RES_E_REQUIREINT;
                    break;

                case BOT_MINUS:
                case BOT_MULT:
                case BOT_DIV:
                    Expr_SetDataType(this, DATA_INT);

                    if (DATA_INT != dt)
                        res = RES_E_REQUIREINT;
                    break;

                default:
                    ASSERT(0);
                    res = RES_E_INVALIDPARAM;
                    break;
                    }
                }

            if (RFAILED(res))
                Stxerr_Add(hsaStxerr, SzFromBot(bot), Ast_GetLine(this), res);
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typechecks a unary operator expression.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE UnOpExpr_Typecheck(
    PEXPR this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);

    pexpr = UnOpExpr_GetExpr(this);
    res = Expr_Typecheck(pexpr, pst, hsaStxerr);

    if (RSUCCEEDED(res))
        {
        UNOPTYPE uot = UnOpExpr_GetType(this);
        DATATYPE dt = Expr_GetDataType(pexpr);

        // Check the type of the expression
        switch (uot)
            {
        case UOT_NEG:
            Expr_SetDataType(this, DATA_INT);

            if (DATA_INT != dt)
                res = RES_E_REQUIREINT;
            break;

        case UOT_NOT:
            Expr_SetDataType(this, DATA_BOOL);

            if (DATA_BOOL != dt)
                res = RES_E_REQUIREBOOL;
            break;

        case UOT_GETIP:
            Expr_SetDataType(this, DATA_STRING);

            if (DATA_INT != dt)
                res = RES_E_REQUIREINT;
            break;

        default:
            ASSERT(0);
            res = RES_E_INVALIDPARAM;
            break;
            }

        if (RFAILED(res))
            Stxerr_Add(hsaStxerr, SzFromUot(uot), Ast_GetLine(this), res);
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typechecks an expression.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE Expr_Typecheck(
    PEXPR this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;

    ASSERT(this);
    ASSERT(hsaStxerr);

    switch (Ast_GetType(this))
        {
    case AT_INT_EXPR:
        Expr_SetDataType(this, DATA_INT);
        res = RES_OK;
        break;

    case AT_STRING_EXPR:
        Expr_SetDataType(this, DATA_STRING);
        res = RES_OK;
        break;

    case AT_BOOL_EXPR:
        Expr_SetDataType(this, DATA_BOOL);
        res = RES_OK;
        break;

    case AT_VAR_EXPR:
        res = VarExpr_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_UNOP_EXPR:
        res = UnOpExpr_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_BINOP_EXPR:
        res = BinOpExpr_Typecheck(this, pst, hsaStxerr);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the assignment statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE AssignStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    LPSTR pszIdent;
    DATATYPE dt;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_ASSIGN_STMT == Ast_GetType(this));

    pszIdent = AssignStmt_GetIdent(this);
    res = Ident_Typecheck(pszIdent, 0, &dt, Ast_GetLine(this), pst, hsaStxerr);
    if (RSUCCEEDED(res))
        {
        PEXPR pexpr = AssignStmt_GetExpr(this);

        res = Expr_Typecheck(pexpr, pst, hsaStxerr);

        // Types must match
        if (dt != Expr_GetDataType(pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "=", Ast_GetLine(pexpr), RES_E_TYPEMISMATCH);
            }
        }
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'while' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE WhileStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_WHILE_STMT == Ast_GetType(this));

    pexpr = WhileStmt_GetExpr(this);
    res = Expr_Typecheck(pexpr, pst, hsaStxerr);
    if (RSUCCEEDED(res))
        {
        if (DATA_BOOL != Expr_GetDataType(pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "'while' expression", Ast_GetLine(pexpr), RES_E_REQUIREBOOL);
            }
        else
            {
            // Typecheck the statement block
            DWORD i;
            DWORD cstmts;
            HPA hpaStmts = WhileStmt_GetStmtBlock(this);

            res = RES_OK;

            cstmts = PAGetCount(hpaStmts);

            // Typecheck each statement
            for (i = 0; i < cstmts; i++)
                {
                PSTMT pstmt = PAFastGetPtr(hpaStmts, i);

                res = Stmt_Typecheck(pstmt, pst, hsaStxerr);
                if (RFAILED(res))
                    break;
                }
            }
        }
        
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'if' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE IfStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_IF_STMT == Ast_GetType(this));

    pexpr = IfStmt_GetExpr(this);
    res = Expr_Typecheck(pexpr, pst, hsaStxerr);
    if (RSUCCEEDED(res))
        {
        if (DATA_BOOL != Expr_GetDataType(pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "'if' expression", Ast_GetLine(pexpr), RES_E_REQUIREBOOL);
            }
        else
            {
            // Typecheck the statement block
            DWORD i;
            DWORD cstmts;
            HPA hpaStmts = IfStmt_GetStmtBlock(this);

            res = RES_OK;

            cstmts = PAGetCount(hpaStmts);

            // Typecheck each statement
            for (i = 0; i < cstmts; i++)
                {
                PSTMT pstmt = PAFastGetPtr(hpaStmts, i);

                res = Stmt_Typecheck(pstmt, pst, hsaStxerr);
                if (RFAILED(res))
                    break;
                }
            }
        }
        
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the label statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE LabelStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PSTE pste;
    LPSTR pszIdent;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_LABEL_STMT == Ast_GetType(this));

    pszIdent = LabelStmt_GetIdent(this);

    if (RES_OK == Symtab_FindEntry(pst, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        if (DATA_LABEL == STE_GetDataType(pste))
            res = RES_OK;
        else
            res = Stxerr_Add(hsaStxerr, pszIdent, Ast_GetLine(this), RES_E_REQUIRELABEL);
        }
    else
        {
        // This should never get here
        ASSERT(0);
        res = RES_E_FAIL;
        }
        
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'goto' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE GotoStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    LPSTR pszIdent;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_GOTO_STMT == Ast_GetType(this));

    pszIdent = GotoStmt_GetIdent(this);

    return Ident_Typecheck(pszIdent, DATA_LABEL, NULL, Ast_GetLine(this), pst, hsaStxerr);
    }


/*----------------------------------------------------------
Purpose: Typecheck the transmit statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE TransmitStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_TRANSMIT_STMT == Ast_GetType(this));

    pexpr = TransmitStmt_GetExpr(this);
    res = Expr_Typecheck(pexpr, pst, hsaStxerr);
    if (DATA_STRING != Expr_GetDataType(pexpr))
        {
        res = Stxerr_Add(hsaStxerr, "'transmit' parameter", Ast_GetLine(pexpr), RES_E_REQUIRESTRING);
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'waitfor' statement

            waitfor <Expr> 
                [ then IDENT { , <Expr> then IDENT } ]
                [ until <UntilExpr> ]
         
         where:
            <Expr>          is a string
            IDENT           is a label
            <UntilExpr>     is an integer

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE WaitforStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res = RES_E_FAIL;
    PEXPR pexpr;
    HSA hsa;
    DWORD i;
    DWORD ccase;
    PWAITCASE pwc;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_WAITFOR_STMT == Ast_GetType(this));

    // Typecheck that <Expr> is of type string, and any 
    // IDENTs are labels.

    hsa = WaitforStmt_GetCaseList(this);
    ccase = SAGetCount(hsa);
    for (i = 0; i < ccase; i++)
        {
        SAGetItemPtr(hsa, i, &pwc);
        ASSERT(pwc);

        // Typecheck <Expr>
        res = Expr_Typecheck(pwc->pexpr, pst, hsaStxerr);
        if (DATA_STRING != Expr_GetDataType(pwc->pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "'waitfor' parameter", Ast_GetLine(pwc->pexpr), RES_E_REQUIRESTRING);
            break;
            }

        // Typecheck IDENT label.  If there is only one <Expr>, there
        // may not be an IDENT label.

        if (pwc->pszIdent)
            {
            res = Ident_Typecheck(pwc->pszIdent, DATA_LABEL, NULL, Ast_GetLine(pwc->pexpr), pst, hsaStxerr);
            if (RFAILED(res))
                break;
            }
        else
            ASSERT(1 == ccase);
        }

    // 'until' expression is optional
    if (RSUCCEEDED(res) &&
        NULL != (pexpr = WaitforStmt_GetUntilExpr(this)))
        {
        res = Expr_Typecheck(pexpr, pst, hsaStxerr);
        if (DATA_INT != Expr_GetDataType(pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "'until' parameter", Ast_GetLine(pexpr), RES_E_REQUIREINT);
            }
        }    
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'delay' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE DelayStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_DELAY_STMT == Ast_GetType(this));

    pexpr = DelayStmt_GetExpr(this);
    res = Expr_Typecheck(pexpr, pst, hsaStxerr);
    if (DATA_INT != Expr_GetDataType(pexpr))
        {
        res = Stxerr_Add(hsaStxerr, "'delay' parameter", Ast_GetLine(pexpr), RES_E_REQUIREINT);
        }
        
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'set' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE SetStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_SET_STMT == Ast_GetType(this));

    switch (SetStmt_GetType(this))
        {
    case ST_IPADDR:
        pexpr = SetIPStmt_GetExpr(this);
        res = Expr_Typecheck(pexpr, pst, hsaStxerr);
        if (DATA_STRING != Expr_GetDataType(pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "'ipaddr' parameter", Ast_GetLine(pexpr), RES_E_REQUIRESTRING);
            }
        break;

    case ST_PORT:
    case ST_SCREEN:
        res = RES_OK;
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck a statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE Stmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;

    ASSERT(this);
    ASSERT(hsaStxerr);

    switch (Ast_GetType(this))
        {
    case AT_ENTER_STMT:
    case AT_LEAVE_STMT:
        res = RES_OK;
        break;

    case AT_WHILE_STMT:
        res = WhileStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_IF_STMT:
        res = IfStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_ASSIGN_STMT:
        res = AssignStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_HALT_STMT:
        // Nothing to typecheck here
        res = RES_OK;
        break;

    case AT_TRANSMIT_STMT:
        res = TransmitStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_WAITFOR_STMT:
        res = WaitforStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_DELAY_STMT:
        res = DelayStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_LABEL_STMT:
        res = LabelStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_GOTO_STMT:
        res = GotoStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_SET_STMT:
        res = SetStmt_Typecheck(this, pst, hsaStxerr);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck a procedure declaration.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE ProcDecl_Typecheck(
    PPROCDECL this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res = RES_OK;
    DWORD i;
    DWORD cstmts;

    ASSERT(this);
    ASSERT(hsaStxerr);

    cstmts = PAGetCount(this->hpaStmts);

    // Typecheck each statement
    for (i = 0; i < cstmts; i++)
        {
        PSTMT pstmt = PAFastGetPtr(this->hpaStmts, i);

        res = Stmt_Typecheck(pstmt, this->pst, hsaStxerr);
        if (RFAILED(res))
            break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck a module declaration.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PUBLIC ModuleDecl_Typecheck(
    PMODULEDECL this,
    HSA hsaStxerr)
    {
    RES res = RES_OK;
    DWORD i;
    DWORD cprocs;
    BOOL bFoundMain = FALSE;

    ASSERT(this);
    ASSERT(hsaStxerr);

    TRACE_MSG(TF_GENERAL, "Typechecking...");

    cprocs = PAGetCount(this->hpaProcs);

    // Typecheck each proc
    for (i = 0; i < cprocs; i++)
        {
        PPROCDECL pprocdecl = PAFastGetPtr(this->hpaProcs, i);

        if (IsSzEqualC(ProcDecl_GetIdent(pprocdecl), "main"))
            bFoundMain = TRUE;

        res = ProcDecl_Typecheck(pprocdecl, this->pst, hsaStxerr);
        if (RFAILED(res))
            break;
        }

    // There must be a main proc
    if (RSUCCEEDED(res) && !bFoundMain)
        res = Stxerr_AddTok(hsaStxerr, NULL, RES_E_MAINMISSING);

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\terminal.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//      MODULE:         terminal.c
//
//      PURPOSE:        Terminal screen simulation
//
//	PLATFORMS:	Windows 95
//
//      FUNCTIONS:
//              TransferData()
//              TerminalDlgWndProc()
//              TerminalScreenWndProc()
//              OnCommand()
//              InitTerminalDlg()
//              TerminateTerminal()
//              GetInput()
//              SendByte()
//              AdjustTerminal()
//              UpdateTerminalCaption()
//              TerminalThread()
//
//	SPECIAL INSTRUCTIONS: N/A
//

#include "proj.h"    // includes common header files and global declarations
#include "rcids.h"   // includes the resource definitions
#ifndef WINNT_RAS
//
// See scrpthlp.h for information on why this has been commented out.
//
#include "scrpthlp.h"// include context-sensitive help

#endif // WINNT_RAS

//****************************************************************************
// Constants Declaration
//****************************************************************************

#define MAXTITLE               32
#define MAXMESSAGE             256

#define WM_MODEMNOTIFY         (WM_USER + 998)
#define WM_EOLFROMDEVICE       (WM_USER + 999)
#define WM_PROCESSSCRIPT       (WM_USER + 1000)

#ifndef WINNT_RAS
//
// The definitions below are overriden in nthdr2.h, and have been removed here
// to avoid multiple definitions
//

#define SIZE_ReceiveBuf        1024
#define SIZE_SendBuf           1

#endif // !WINNT_RAS

#define Y_MARGIN               4
#define Y_SMALL_MARGIN         2
#define X_SPACING              2
#define MIN_X                  170
#define MIN_Y                  80

#define TERMINAL_BK_COLOR      (RGB( 0, 0, 0 ))
#define TERMINAL_FR_COLOR      (RGB( 255, 255, 255 ))
#define MAXTERMLINE            24

#define READ_EVENT             0
#define STOP_EVENT             1
#define MAX_EVENT              2

#define SENDTIMEOUT            50

#define CE_DELIM               256

#define TRACE_MARK             "->"
#define TRACE_UNMARK           "  "
#define INVALID_SCRIPT_LINE    0xFFFFFFFF

#define PROMPT_AT_COMPLETION   1

//****************************************************************************
// Type Definitions
//****************************************************************************

typedef struct tagFINDFMT 
  {
  LPSTR pszFindFmt;     // Allocated: formatted string to find
  LPSTR pszBuf;         // Optional pointer to buffer; may be NULL
  UINT  cbBuf;
  DWORD dwFlags;        // FFF_*
  } FINDFMT;
DECLARE_STANDARD_TYPES(FINDFMT);

typedef struct  tagTERMDLG {
    HANDLE   hport;
    HANDLE   hThread;
    HANDLE   hEvent[MAX_EVENT];
    HWND     hwnd;
    PBYTE    pbReceiveBuf;  // circular buffer
    PBYTE    pbSendBuf;
    UINT     ibCurFind;
    UINT     ibCurRead;
    UINT     cbReceiveMax;  // count of read bytes
    HBRUSH   hbrushScreenBackgroundE;
    HBRUSH   hbrushScreenBackgroundD;
    HFONT    hfontTerminal;
    PSCANNER pscanner;
    PMODULEDECL pmoduledecl;
    ASTEXEC  astexec;
    SCRIPT   script;
    WNDPROC  WndprocOldTerminalScreen;
    BOOL     fInputEnabled;
    BOOL     fStartRestored;
    BOOL     rgbDelim[CE_DELIM];

    // The following fields are strictly for test screen
    //
    BOOL     fContinue;
    HWND     hwndDbg;
    DWORD    iMarkLine;

}   TERMDLG, *PTERMDLG, FAR* LPTERMDLG;

#define IS_TEST_SCRIPT(ptd)     (ptd->script.uMode == TEST_MODE)

//****************************************************************************
// Function prototypes
//****************************************************************************

INT_PTR CALLBACK   TerminalDlgWndProc(HWND   hwnd,
                                      UINT   wMsg,
                                      WPARAM wParam,
                                      LPARAM lParam );
LRESULT FAR PASCAL TerminalScreenWndProc(HWND   hwnd,
                                         UINT   wMsg,
                                         WPARAM wParam,
                                         LPARAM lParam );
BOOL NEAR PASCAL OnCommand (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT NEAR PASCAL InitTerminalDlg(HWND hwnd);
void NEAR PASCAL TerminateTerminal(HWND hwnd, UINT id);
BOOL NEAR PASCAL GetInput  (HWND hwnd);
VOID NEAR PASCAL AdjustTerminal (HWND hwnd, int wWidth, int wHeight);
void NEAR PASCAL UpdateTerminalCaption(PTERMDLG ptd, UINT ids);
void WINAPI      TerminalThread (PTERMDLG  pTerminaldialog);
void PRIVATE Terminal_NextCommand(PTERMDLG ptd, HWND hwnd);

// The following functions are used by test screen only
//
BOOL NEAR PASCAL DisplayScript (PTERMDLG ptd);
LRESULT FAR PASCAL DbgScriptDlgProc(HWND   hwnd,
                                    UINT   wMsg,
                                    WPARAM wParam,
                                    LPARAM lParam );
BOOL NEAR PASCAL InitDebugWindow (HWND hwnd);
void NEAR PASCAL TrackScriptLine(PTERMDLG ptd, DWORD iLine);

/*----------------------------------------------------------------------------
** Terminal dialog routines
**----------------------------------------------------------------------------
*/

BOOL PUBLIC TransferData(
    HWND   hwnd,
    HANDLE hComm,
    PSESS_CONFIGURATION_INFO psci)

    /* Executes the Terminal dialog including error handling.  'hwndOwner' is
    ** the handle of the parent window.  'hport' is the open RAS Manager port
    ** handle to talk on.  'msgidTitle' is the string ID for the Terminal window
    ** caption.
    **
    ** Returns true if successful, false otherwise.
    */
{
  PTERMDLG  ptd;
  COMMTIMEOUTS commtimeout;
  DWORD     id;
  int       i;
  int       iRet;

  // Allocate the terminal buffer
  //
  if ((ptd = (PTERMDLG)LocalAlloc(LPTR, sizeof(*ptd)))
      == NULL)
    return FALSE;

  if ((ptd->pbReceiveBuf = (PBYTE)LocalAlloc(LPTR,
                                           SIZE_ReceiveBuf+ SIZE_SendBuf))
      == NULL)
  {
    LocalFree((HLOCAL)ptd);
    return FALSE;
  };
  ptd->pbSendBuf = ptd->pbReceiveBuf + SIZE_ReceiveBuf;
  ptd->ibCurFind = 0;
  ptd->ibCurRead = 0;
  ptd->cbReceiveMax = 0;
  ptd->fInputEnabled= FALSE;
  ptd->fStartRestored = FALSE;
  ptd->iMarkLine = 0;

  // Initialize the terminal buffer
  //
  ptd->hport   = hComm;
  ptd->hbrushScreenBackgroundE = (HBRUSH)GetStockObject( BLACK_BRUSH );
  ptd->hbrushScreenBackgroundD = (HBRUSH)GetStockObject( WHITE_BRUSH );
  ptd->hfontTerminal = (HFONT)GetStockObject( SYSTEM_FIXED_FONT );
  
  // Create the scanner
  if (RFAILED(Scanner_Create(&ptd->pscanner, psci)))
  {
    LocalFree((HLOCAL)ptd->pbReceiveBuf);
    LocalFree((HLOCAL)ptd);
    return FALSE;
  };

  // Is there a script for this connection?
  if (GetScriptInfo(psci->szEntryName, &ptd->script))
    {
    // Yes; open the script file for scanning
    RES res = Scanner_OpenScript(ptd->pscanner, ptd->script.szPath);

    if (RES_E_FAIL == res)
        {
        MsgBox(g_hinst, 
            hwnd,
            MAKEINTRESOURCE(IDS_ERR_ScriptNotFound),
            MAKEINTRESOURCE(IDS_CAP_Script),
            NULL,
            MB_WARNING,
            ptd->script.szPath);

        ptd->fInputEnabled= TRUE;
        *ptd->script.szPath = '\0';
        ptd->script.uMode = NORMAL_MODE;
        }
    else if (RFAILED(res))
        {
        Scanner_Destroy(ptd->pscanner);
        //
        // .Net bug# 522307 Specifying the dialup script file as the COM
        // Port of the Modem will cause explorer to AV.
        //
        ptd->pscanner = NULL;
        LocalFree((HLOCAL)ptd->pbReceiveBuf);
        LocalFree((HLOCAL)ptd);
        return FALSE;
        }
    else
        {
        res = Astexec_Init(&ptd->astexec, hComm, psci, 
                           Scanner_GetStxerrHandle(ptd->pscanner));
        if (RSUCCEEDED(res))
            {
            // Parse the script
            res = ModuleDecl_Parse(&ptd->pmoduledecl, ptd->pscanner, ptd->astexec.pstSystem);
            if (RSUCCEEDED(res))
                {
                res = ModuleDecl_Codegen(ptd->pmoduledecl, &ptd->astexec);
                }

            if (RFAILED(res))
                {
                Stxerr_ShowErrors(Scanner_GetStxerrHandle(ptd->pscanner), hwnd);
                }
            }
        }
    }
  else
      {
      ptd->fInputEnabled= TRUE;
      ptd->script.uMode = NORMAL_MODE;
      ptd->fStartRestored = TRUE;
      };

  // Set comm timeout
  //
  commtimeout.ReadIntervalTimeout = MAXDWORD;
  commtimeout.ReadTotalTimeoutMultiplier = 0;
  commtimeout.ReadTotalTimeoutConstant   = 0;
  commtimeout.WriteTotalTimeoutMultiplier= SENDTIMEOUT;
  commtimeout.WriteTotalTimeoutConstant  = 0;
  SetCommTimeouts(hComm, &commtimeout);

  // Start receiving from the port
  //
  SetCommMask(hComm, EV_RXCHAR);

  // Create read thread and the synchronization objects
  for (i = 0; i < MAX_EVENT; i++)
  {
    ptd->hEvent[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
  };

  ptd->hThread = CreateThread(NULL, 0,
                              (LPTHREAD_START_ROUTINE) TerminalThread,
                              ptd, 0, &id);


  // Create the terminal window
#ifdef MODAL_DIALOG
  iRet = DialogBoxParam(g_hinst,
                        MAKEINTRESOURCE(IDD_TERMINALDLG),
                        hwnd,
                        TerminalDlgWndProc,
                        (LPARAM)(LPTERMDLG)ptd);
#else
  if (CreateDialogParam(g_hinst,
                        MAKEINTRESOURCE(IDD_TERMINALDLG),
                        hwnd,
                        TerminalDlgWndProc,
                        (LPARAM)(LPTERMDLG)ptd))
  {
    MSG msg;

    while(GetMessage(&msg, NULL, 0, 0))
    {
      if ((!IsDialogMessage(ptd->hwnd, &msg)) &&
          ((ptd->hwndDbg == NULL) || !IsDialogMessage(ptd->hwndDbg, &msg)))
      {
        TranslateMessage(&msg);    /* Translates virtual key codes           */
        DispatchMessage(&msg);     /* Dispatches message to window           */
      };
    };
    iRet = (int)msg.wParam;
    DestroyWindow(ptd->hwnd);
  }
  else
  {
    iRet = IDCANCEL;
  };
#endif // MODAL_DIALOG

  // The terminal dialog was terminated, free resources
  //
  SetEvent(ptd->hEvent[STOP_EVENT]);
  SetCommMask(hComm, 0);

  DEBUG_MSG (TF_ALWAYS, "Set stop event and cleared comm mask.");
  WaitForSingleObject(ptd->hThread, INFINITE);
  DEBUG_MSG (TF_ALWAYS, "Read thread was terminated.");

  for (i = 0; i < MAX_EVENT; i++)
  {
    CloseHandle(ptd->hEvent[i]);
  };
  CloseHandle(ptd->hThread);

  Decl_Delete((PDECL)ptd->pmoduledecl);
  Astexec_Destroy(&ptd->astexec);
  Scanner_Destroy(ptd->pscanner);
  //
  // .Net bug# 522307 Specifying the dialup script file as the COM
  // Port of the Modem will cause explorer to AV.
  //
  ptd->pscanner = NULL;

  LocalFree((HLOCAL)ptd->pbReceiveBuf);
  LocalFree((HLOCAL)ptd);
  return (iRet == IDOK);
}


/*----------------------------------------------------------------------------
** Terminal Window Procedure
**----------------------------------------------------------------------------
*/

void PRIVATE PostProcessScript(
    HWND hwnd)
{
  MSG msg;

  if (!PeekMessage(&msg, hwnd, WM_PROCESSSCRIPT, WM_PROCESSSCRIPT,
                   PM_NOREMOVE))
  {
    PostMessage(hwnd, WM_PROCESSSCRIPT, 0, 0);
  }
}


/*----------------------------------------------------------
Purpose: Execute next command in the script

Returns: --
Cond:    --
*/
void PRIVATE Terminal_NextCommand(
  PTERMDLG ptd,
  HWND hwnd)
{
  if (RES_OK == Astexec_Next(&ptd->astexec))
  {
    if (!Astexec_IsReadPending(&ptd->astexec) &&
      !Astexec_IsPaused(&ptd->astexec))
    {
      HWND hwndNotify;

      if (IS_TEST_SCRIPT(ptd))
      {
        // Do not start processing the next one yet
        //
        ptd->fContinue = FALSE;
        hwndNotify = ptd->hwndDbg;
      }
      else
      {
        hwndNotify = hwnd;
      };

      // Process the next command
      //
      PostProcessScript(hwndNotify);
    };
  };
};


INT_PTR CALLBACK TerminalDlgWndProc(HWND   hwnd,
                                    UINT   wMsg,
                                    WPARAM wParam,
                                    LPARAM lParam )
{
  PTERMDLG ptd;

  switch (wMsg)
  {
    case WM_INITDIALOG:

      ptd = (PTERMDLG)lParam;
      DEBUG_MSG (TF_ALWAYS, "ptd = %x", ptd);
      SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
      ptd->hwnd = hwnd;

      Astexec_SetHwnd(&ptd->astexec, hwnd);

      return (InitTerminalDlg(hwnd));

    case WM_CTLCOLOREDIT:

      // Adjust the screen window only
      //
      if ((HWND)lParam == GetDlgItem(hwnd, CID_T_EB_SCREEN))
      {
        HBRUSH hBrush;
        COLORREF crColorBk, crColorTxt;

        ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

        if (ptd->fInputEnabled)
        {
          hBrush = ptd->hbrushScreenBackgroundE;
          crColorBk = TERMINAL_BK_COLOR;
          crColorTxt = TERMINAL_FR_COLOR;
        }
        else
        {
          hBrush = ptd->hbrushScreenBackgroundD;
          crColorBk = TERMINAL_FR_COLOR;
          crColorTxt = TERMINAL_BK_COLOR;
        };

        /* Set terminal screen colors to TTY-ish green on black.
        */
        if (hBrush)
        {
          SetBkColor( (HDC)wParam,  crColorBk );
          SetTextColor((HDC)wParam, crColorTxt );

          return (LRESULT)hBrush;
        }
      };
      break;

    case WM_MODEMNOTIFY:
        ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

        TRACE_MSG(TF_BUFFER, "Received WM_MODEMNOTIFY");

        GetInput(hwnd);

        // Kick the script processing
        //
        PostProcessScript(hwnd);
        return TRUE;

    case WM_PROCESSSCRIPT:
    {
        ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

        TRACE_MSG(TF_BUFFER, "Received WM_PROCESSSCRIPT");

        if (!ptd->fContinue)
        {
          // We are not allowed to process a new command yet
          //
          return TRUE;
        };

        Terminal_NextCommand(ptd, hwnd);

        // If we are done or halt, show the status
        //
        if (Astexec_IsDone(&ptd->astexec) ||
            Astexec_IsHalted(&ptd->astexec))
        {
          BOOL bHalted = Astexec_IsHalted(&ptd->astexec);

          // Update the title
          //
          UpdateTerminalCaption(ptd, bHalted ? IDS_HALT : IDS_COMPLETE);

          // If the script completes successfully, continue the connection
          //
          if (!bHalted)
          {
            // Terminate the script successfully
            //
            TerminateTerminal(hwnd, IDOK);
          }
          else
          {
            // We are halted, need the user's attention.
            //
            if (IsIconic(hwnd))
            {
              ShowWindow(hwnd, SW_RESTORE);
            };
            SetForegroundWindow(hwnd);
          };

        };
        return TRUE;
    }

    case WM_TIMER: {
        HWND hwndNotify;

        ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
        
        TRACE_MSG(TF_GENERAL, "Killing timer");

        Astexec_ClearPause(&ptd->astexec);
        KillTimer(hwnd, TIMER_DELAY);

        // Did we time out on a 'wait..until' statement?
        if (Astexec_IsWaitUntil(&ptd->astexec))
        {
          // Yes; we need to finish processing the 'wait' statement
          // before we step to the next command
          Astexec_SetStopWaiting(&ptd->astexec);
          Astexec_ClearWaitUntil(&ptd->astexec);
          hwndNotify = hwnd;

          ASSERT(TRUE == ptd->fContinue);
        }
        else
        {
          if (IS_TEST_SCRIPT(ptd))
          {
            // Do not start processing the next one yet
            //
            ptd->fContinue = FALSE;
            hwndNotify = ptd->hwndDbg;
          }
          else
          {
            hwndNotify = hwnd;
            ASSERT(TRUE == ptd->fContinue);
          }
        }
        PostProcessScript(hwndNotify);
        }
        return TRUE;

    case WM_COMMAND:

      // Handle the control activities
      //
      return OnCommand(hwnd, wMsg, wParam, lParam);

    case WM_DESTROY:
      ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
      SetWindowLongPtr( GetDlgItem(hwnd, CID_T_EB_SCREEN), GWLP_WNDPROC,
                     (ULONG_PTR)ptd->WndprocOldTerminalScreen );
      break;

    case WM_SIZE:
      AdjustTerminal(hwnd, (int)LOWORD(lParam), (int)HIWORD(lParam));
      break;

    case WM_GETMINMAXINFO:
    {
      MINMAXINFO FAR* lpMinMaxInfo = (MINMAXINFO FAR*)lParam;
      DWORD           dwUnit = GetDialogBaseUnits();

      lpMinMaxInfo->ptMinTrackSize.x = (MIN_X*LOWORD(dwUnit))/4;
      lpMinMaxInfo->ptMinTrackSize.y = (MIN_Y*LOWORD(dwUnit))/4;
      break;
    };

    case WM_HELP:
    case WM_CONTEXTMENU:
      ContextHelp(gaTerminal, wMsg, wParam, lParam);
      break;
  };

  return 0;
}

/*----------------------------------------------------------------------------
** Terminal Screen Subclasses Window Procedure
**----------------------------------------------------------------------------
*/

LRESULT FAR PASCAL TerminalScreenWndProc(HWND   hwnd,
                                         UINT   wMsg,
                                         WPARAM wParam,
                                         LPARAM lParam )
{
  HWND     hwndParent;
  PTERMDLG pTerminaldialog;

  hwndParent      = GetParent(hwnd);
  pTerminaldialog = (PTERMDLG)GetWindowLongPtr(hwndParent, DWLP_USER);

  if (wMsg == WM_EOLFROMDEVICE)
  {
    /* Remove the first line if the next line exceeds the maximum line
    */
    if (SendMessage(hwnd, EM_GETLINECOUNT, 0, 0L) == MAXTERMLINE)
    {
      SendMessage(hwnd, EM_SETSEL, 0,
                  SendMessage(hwnd, EM_LINEINDEX, 1, 0L));
      SendMessage(hwnd, EM_REPLACESEL, 0, (LPARAM)(LPSTR)"");
      SendMessage(hwnd, EM_SETSEL, 32767, 32767);
      SendMessage(hwnd, EM_SCROLLCARET, 0, 0);
    };

    /* An end-of-line in the device input was received.  Send a linefeed
    ** character to the window.
    */
    wParam = '\n';
    wMsg = WM_CHAR;
  }
  else
  {
    BOOL fCtrlKeyDown = (GetKeyState( VK_CONTROL ) < 0);
    BOOL fShiftKeyDown = (GetKeyState( VK_SHIFT ) < 0);

    if (wMsg == WM_KEYDOWN)
    {
      /* The key was pressed by the user.
      */
      if (wParam == VK_RETURN && !fCtrlKeyDown && !fShiftKeyDown)
      {
        /* Enter key pressed without Shift or Ctrl is discarded.  This
        ** prevents Enter from being interpreted as "press default
        ** button" when pressed in the edit box.
        */
        return 0;
      }

      if (fCtrlKeyDown && wParam == VK_TAB)
      {
        /* Ctrl+Tab pressed.  Send a tab character to the device.
        ** Pass tab thru to let the edit box handle the visuals.
        ** Ctrl+Tab doesn't generate a WM_CHAR.
        */
        if (pTerminaldialog->fInputEnabled)
        {
          SendByte(hwndParent, (BYTE)VK_TAB);
        };
      }

      if (GetKeyState( VK_MENU ) < 0)
      {
        return (CallWindowProc(pTerminaldialog->WndprocOldTerminalScreen, hwnd, wMsg, wParam, lParam ));
      };
    }
    else if (wMsg == WM_CHAR)
    {
      /* The character was typed by the user.
      */
      if (wParam == VK_TAB)
      {
        /* Ignore tabs...Windows sends this message when Tab (leave
        ** field) is pressed but not when Ctrl+Tab (insert a TAB
        ** character) is pressed...weird.
        */
        return 0;
      }

      if (pTerminaldialog->fInputEnabled)
      {
        SendByte(hwndParent, (BYTE)wParam);
      };
      return 0;
    }
  }

  /* Call the previous window procedure for everything else.
  */
  return (CallWindowProc(pTerminaldialog->WndprocOldTerminalScreen, hwnd, wMsg, wParam, lParam ));
}

/*----------------------------------------------------------------------------
** Terminal Window's Control Handler
**----------------------------------------------------------------------------
*/

BOOL NEAR PASCAL OnCommand (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch (LOWORD(wParam))
  {
    case CID_T_EB_SCREEN:
    {
      switch (HIWORD(wParam))
      {
        case EN_SETFOCUS:
        {
          /* Turn off the default button whenever the terminal
          ** window has the focus.  Pressing [Return] in the
          ** terminal acts like a normal terminal.
          */
          SendDlgItemMessage(hwnd, CID_T_PB_ENTER, BM_SETSTYLE,
                             (WPARAM)BS_DEFPUSHBUTTON, TRUE);

          /* Don't select the entire string on entry.
          */
          SendDlgItemMessage(hwnd, CID_T_EB_SCREEN, EM_SETSEL,
                             32767, 32767);
          SendMessage(hwnd, EM_SCROLLCARET, 0, 0);
          break;
        };
      };

      break;
    };

    case CID_T_CB_INPUT:
    {
      PTERMDLG ptd;

      ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

      ptd->fInputEnabled = IsDlgButtonChecked(hwnd, CID_T_CB_INPUT);
      InvalidateRect(hwnd, NULL, FALSE);
      SetFocus(GetDlgItem(hwnd, CID_T_EB_SCREEN));
      break;
    }

    case IDOK:
    case IDCANCEL:
      TerminateTerminal(hwnd, LOWORD(wParam));
      break;
  };
  return 0;
}

/*----------------------------------------------------------------------------
** Initialize Terminal window
**----------------------------------------------------------------------------
*/

LRESULT NEAR PASCAL InitTerminalDlg(HWND hwnd)
{
  HWND hwndScrn;
  RECT rect;
  PTERMDLG ptd;
  WINDOWPLACEMENT wp;
  BOOL fRet;

  ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  // Install subclassed WndProcs.
  //
  hwndScrn = GetDlgItem(hwnd, CID_T_EB_SCREEN);
  ptd->WndprocOldTerminalScreen =
      (WNDPROC)SetWindowLongPtr( hwndScrn, GWLP_WNDPROC,
                              (ULONG_PTR)TerminalScreenWndProc );

  // Set the terminal screen font
  //
  SendMessage(hwndScrn, WM_SETFONT, (WPARAM)ptd->hfontTerminal,
              0L);


  // Get the recorded window placement
  //
  if ((fRet = GetSetTerminalPlacement(ptd->pscanner->psci->szEntryName,
                                      &wp, TRUE)) &&
      (wp.length >= sizeof(wp)))
  {
    // We have one, set it
    //
    SetWindowPlacement(hwnd, &wp);
  }
  else
  {
    // If nothing was specified at all, default to minimized
    // otherwise use the state set by scripter
    //
    if (!fRet)
    {
      wp.showCmd = SW_SHOWMINNOACTIVE;
    };

    // Start with minimized window
    //
    ShowWindow(hwnd, wp.showCmd);
  };

  // Adjust the dimension
  //
  GetClientRect(hwnd, &rect);
  AdjustTerminal(hwnd, rect.right-rect.left, rect.bottom-rect.top);

  // Adjust window activation
  //
  if (!IsIconic(hwnd))
  {
    SetForegroundWindow(hwnd);
  }
  else
  {
    CheckDlgButton(hwnd, CID_T_CB_MIN, BST_CHECKED);

    // if we are in debug mode, just bring it up
    //
    if (IS_TEST_SCRIPT(ptd) || ptd->fStartRestored)
    {
      ShowWindow(hwnd, SW_NORMAL);
      SetForegroundWindow(hwnd);
    };
  };

  // Initialize the input enable
  //
  CheckDlgButton(hwnd, CID_T_CB_INPUT,
                 ptd->fInputEnabled ? BST_CHECKED : BST_UNCHECKED);

  // Set the window icon
  //
  SendMessage(hwnd, WM_SETICON, TRUE,
              (LPARAM)LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCRIPT)));

  // Set the input focus to the screen
  //
  UpdateTerminalCaption(ptd, IDS_RUN);

  // Display the script window
  //
  if (IS_TEST_SCRIPT(ptd))
  {
    // Do not start until the debug window says so
    //
    ptd->fContinue = FALSE;

    // Start the debug window
    //
    if (!DisplayScript(ptd))
    {
      // Cannot start the debug window, switch to normal mode
      //
      ptd->fContinue = TRUE;
      ptd->script.uMode = NORMAL_MODE;
    };
  }
  else
  {
    // Start immediately
    //
    ptd->fContinue = TRUE;
    ptd->hwndDbg   = NULL;
  };

  // Start receiving from the port
  //
  PostMessage(hwnd, WM_MODEMNOTIFY, 0, 0);

  return 0;
}

/*----------------------------------------------------------------------------
** Terminal window termination
**----------------------------------------------------------------------------
*/

void NEAR PASCAL TerminateTerminal(HWND hwnd, UINT id)
{
  PTERMDLG ptd;
  WINDOWPLACEMENT wp;

  ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  // Get the current window placement and record it
  //
  wp.length = sizeof(wp);
  if (GetWindowPlacement(hwnd, &wp))
  {
    // If user specifies start-minimized, remember it
    //
    if (IsDlgButtonChecked(hwnd, CID_T_CB_MIN) == BST_CHECKED)
    {
      wp.showCmd = SW_SHOWMINNOACTIVE;
    };

    // Recorded the window placement
    //
    GetSetTerminalPlacement(ptd->pscanner->psci->szEntryName, &wp, FALSE);
  };

  if (IS_TEST_SCRIPT(ptd))
  {
    // Destroy the script window here
    //
    DestroyWindow(ptd->hwndDbg);
  };

  // Terminate the window
  //
#ifdef MODAL_DIALOG
  EndDialog(hwnd, id);
#else
  PostQuitMessage(id);
#endif // MODAL_DIALOG
  return;
}

/*----------------------------------------------------------------------------
** Terminal Input Handler
**----------------------------------------------------------------------------
*/


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dumps the read buffer
Returns: 
Cond:    --
*/
void PRIVATE DumpBuffer(
    PTERMDLG ptd)
    {
    #define IS_PRINTABLE(ch)    InRange(ch, 32, 126)

    if (IsFlagSet(g_dwDumpFlags, DF_READBUFFER))
        {
        UINT ib;
        UINT cb;
        UINT cbMax = ptd->cbReceiveMax;
        char szBuf[SIZE_ReceiveBuf+1];
        LPSTR psz = szBuf;

        ASSERT(ptd->ibCurRead >= ptd->ibCurFind);
        ASSERT(SIZE_ReceiveBuf > ptd->ibCurFind);
        ASSERT(SIZE_ReceiveBuf > ptd->ibCurRead);
        ASSERT(SIZE_ReceiveBuf >= cbMax);

        *szBuf = 0;

        for (ib = ptd->ibCurFind, cb = 0; 
            cb < cbMax; 
            ib = (ib + 1) % SIZE_ReceiveBuf, cb++)
            {
            char ch = ptd->pbReceiveBuf[ib];

            if (IS_PRINTABLE(ch))
                *psz++ = ch;
            else
                *psz++ = '.';
            }
        *psz = 0;   // add null terminator

        TRACE_MSG(TF_ALWAYS, "Read buffer: {%s}", (LPSTR)szBuf);
        }
    }

#endif // DEBUG
    

/*----------------------------------------------------------
Purpose: Creates a find format handle.  This function should
         be called to get a handle to use with FindFormat.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC CreateFindFormat(
  PHANDLE phFindFmt)
{
  RES res = RES_OK;
  HSA hsa;

  ASSERT(phFindFmt);

  if ( !SACreate(&hsa, sizeof(FINDFMT), 8) )
    res = RES_E_OUTOFMEMORY;

  *phFindFmt = (HANDLE)hsa;

  return res;
}


/*----------------------------------------------------------
Purpose: Adds a formatted search string to the list.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC AddFindFormat(
  HANDLE hFindFmt,
  LPCSTR pszFindFmt,
  DWORD dwFlags,      // FFF_*
  LPSTR pszBuf,       // May be NULL
  DWORD cbBuf)
{
  RES res = RES_OK;
  FINDFMT ff;
  HSA hsa = (HSA)hFindFmt;

  ZeroInit(&ff, FINDFMT);

  if (GSetString(&ff.pszFindFmt, pszFindFmt))
    {
    ff.pszBuf = pszBuf;
    ff.cbBuf = cbBuf;
    ff.dwFlags = dwFlags;

    if ( !SAInsertItem(hsa, SA_APPEND, &ff) )
      res = RES_E_OUTOFMEMORY;
    }
  else
    res = RES_E_OUTOFMEMORY;

  return res;
}


/*----------------------------------------------------------
Purpose: Free a find format item

Returns: --
Cond:    --
*/
void CALLBACK FreeSAFindFormat(
  PVOID pv,
  LPARAM lParam)
  {
  PFINDFMT pff = (PFINDFMT)pv;

  if (pff->pszFindFmt)
    GSetString(&pff->pszFindFmt, NULL);   // free
  }


/*----------------------------------------------------------
Purpose: Destroys a find format handle.

Returns: RES_OK

         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC DestroyFindFormat(
  HANDLE hFindFmt)
  {
  RES res;
  HSA hsa = (HSA)hFindFmt;

  if (hsa)
    {
    SADestroyEx(hsa, FreeSAFindFormat, 0);
    res = RES_OK;
    }
  else
    res = RES_E_INVALIDPARAM;
    
  return res;
  }


BOOL PRIVATE ChrCmp(WORD w1, WORD wMatch);
BOOL PRIVATE ChrCmpI(WORD w1, WORD wMatch);


/*----------------------------------------------------------
Purpose: Compares the given character with the current format
         string.  If the character matches the expected format,
         the function returns RES_OK.

         If the current character does not match the expected
         format, but the minimum sequence of characters for
         the format has been fulfilled, this function will 
         increment *ppszFind to the next appropriate character
         or escape sequence, and check for the next expected
         format match.

         If the end of the format string is reached, RES_HALT
         is returned.  

Returns: RES_OK (if the character compares)
         RES_HALT (to stop immediately)
         RES_FALSE (if the character does not compare)

Cond:    --
*/
RES PRIVATE CompareFormat(
  PFINDFMT pff,
  LPCSTR * ppszFind,
  char chRec)
  {
  RES res = RES_FALSE;
  LPCSTR pszFind = *ppszFind;
  LPCSTR pszNext;
  DWORD dwFlags = 0;
  char ch;
  char chNext;

  #define IS_ESCAPE(ch)            ('%' == (ch))

  pszNext = MyNextChar(pszFind, &ch, &dwFlags);

  // Is this a DBCS trailing byte?
  if (IsFlagSet(dwFlags, MNC_ISTAILBYTE))
    {
    // Yes; handle this normally
    goto CompareNormal;
    }
  else
    {
    // No; check for special formatting characters first
    switch (ch)
      {
    case '%':
      chNext = *pszNext;
      if ('u' == chNext)
        {
        // Look for unsigned digits
        if (IS_DIGIT(chRec))
          {
          res = RES_OK;
          SetFlag(pff->dwFlags, FFF_MATCHEDONCE);
          }
        else
          {
          // Have we already found some digits?
          if (IsFlagSet(pff->dwFlags, FFF_MATCHEDONCE))
            {
            // Yes; then move on to the next thing to find
            ClearFlag(pff->dwFlags, FFF_MATCHEDONCE);
            pszNext = CharNext(pszNext);
            res = CompareFormat(pff, &pszNext, chRec);

            if (RES_FALSE != res)
              *ppszFind = pszNext;
            }
          else
            {
            // No
            res = RES_FALSE;
            }
          }
        }
      else if (IS_ESCAPE(chNext))
        {
        // Looking for a single '%'
        res = (chNext == chRec) ? RES_OK : RES_FALSE;

        if (RES_OK == res)
          *ppszFind = CharNext(pszNext);
        }
      else
        {
        goto CompareNormal;
        }
      break;

    case 0:       // null terminator
      res = RES_HALT;
      break;

    default: {
      BOOL bMatch;

CompareNormal:
      // (The ChrCmp* functions return FALSE if they match)

      if (IsFlagSet(pff->dwFlags, FFF_MATCHCASE))
        bMatch = !ChrCmp(ch, chRec);
      else
        bMatch = !ChrCmpI(ch, chRec);

      if (bMatch)
        {
        res = RES_OK;
        *ppszFind = pszNext;
        }
      else
        res = RES_FALSE;
      }
      break;
      }
    }

  return res;
  }


/*----------------------------------------------------------
Purpose: Scans for the specific find format string.  

         The function returns two indexes and the count of
         matched bytes.  Both indexes refer to the read
         buffer.  *pibMark indexes the first character 
         of a substring candidate.  *pib indexes the 
         character that was compared last.

         If the sequence of characters completely match the 
         requested string, the function returns RES_OK.  The
         matching sequence of characters is copied into 
         the collection buffer (if one is given).

         If there is no complete match, the function returns
         RES_FALSE.  The caller should read in more data
         before calling this function with the same requested
         string.

         If some trailing string in the read buffer matches
         the requested string, 

         If the collection buffer becomes full before a 
         complete match is found, this function returns 
         RES_E_MOREDATA.

Returns: see above
Cond:    --
*/
RES PRIVATE ScanFormat(
  PFINDFMT pff,
  UINT ibCurFind,
  LPCSTR pszRecBuf,
  UINT cbRecMax,
  LPUINT pibMark,
  LPUINT pib,
  LPINT pcbMatched)
  {
  // The trick is keeping track of when we've found a partial
  // string across read boundaries.  Consider the search string
  // "ababc".  We need to find it in the following cases (the
  // character '|' indicates read boundary, '.' is an arbitrary
  // byte):
  //
  //   |...ababc..|
  //   |.abababc..|
  //   |......abab|c.........|
  //   |......abab|abc.......|
  //
  // This assumes the read buffer is larger than the search
  // string.  In order to do this, the read buffer must be
  // a circular buffer, always retaining that portion of the
  // possible string match from the last read.
  //
  //   1st read:  |...ababc..|  -> match found
  //
  //   1st read:  |.abababc..|  -> match found
  //
  //   1st read:  |......abab|  -> possible match (retain "abab")
  //   2nd read:  |ababc.....|  -> match found
  //
  //   1st read:  |......abab|  -> possible match (retain "abab")
  //   2nd read:  |abababc...|  -> match found
  //
  #define NOT_MARKED      ((UINT)-1)

  RES res = RES_FALSE;    // assume the string is not here
  LPSTR psz;
  LPSTR pszBuf;
  UINT ib;
  UINT ibMark = NOT_MARKED;
  UINT cb;
  int cbMatched = 0;
  int cbThrowAway = 0;
  UINT cbBuf;

  pszBuf = pff->pszBuf;
  if (pszBuf)
    {
    TRACE_MSG(TF_GENERAL, "FindFormat: current buffer is {%s}", pszBuf);

    cbBuf = pff->cbBuf;
    
    if (cbBuf == pff->cbBuf)
      {
      ASSERT(0 < cbBuf);
      cbBuf--;            // save space for null terminator (first time only)
      }
    }

  // Search for the (formatted) string in the receive
  // buffer.  Optionally store the matching received
  // characters in the findfmt buffer.

  for (psz = pff->pszFindFmt, ib = ibCurFind, cb = 0; 
    *psz && cb < cbRecMax;
    ib = (ib + 1) % SIZE_ReceiveBuf, cb++)
    {
    // Match?
    RES resT = CompareFormat(pff, &psz, pszRecBuf[ib]);
    if (RES_OK == resT)
      {
      // Yes
      if (NOT_MARKED == ibMark)
        {
        ibMark = ib;       // Mark starting position
        cbMatched = 0;
        }

      cbMatched++;

      if (pszBuf)
        {
        if (0 == cbBuf)
          {
          res = RES_E_MOREDATA;
          break;
          }
          
        *pszBuf++ = pszRecBuf[ib];  // Copy character to buffer
        cbBuf--;
        }
      }
    else if (RES_HALT == resT)
      {
      ASSERT(0 == *psz);
      res = RES_HALT;
      break;
      }
    else
      {
      // No; add this to our throw away count
      cbThrowAway++;

      // Are we in a partial find?
      if (NOT_MARKED != ibMark)
        {
        // Yes; go back to where we thought the string might
        // have started.  The loop will increment one 
        // position and then resume search.
        cb -= cbMatched;
        ib = ibMark;
        ibMark = NOT_MARKED;
        psz = pff->pszFindFmt;
        if (pszBuf)
          {
          pszBuf = pff->pszBuf;
          cbBuf += cbMatched;
          }
        }
      }
    }
  
  ASSERT(RES_FALSE == res || RES_HALT == res || RES_E_MOREDATA == res);

  if (0 == *psz)
    res = RES_OK;

  if (pszBuf)
    *pszBuf = 0;    // add null terminator

  ASSERT(RES_FALSE == res || RES_OK == res || RES_E_MOREDATA == res);

  *pib = ib;
  *pibMark = ibMark;
  *pcbMatched = cbMatched;

  if (RES_OK == res)
    {
    // Include any junk characters that preceded the matched string.
    *pcbMatched += cbThrowAway;
    }
  else if (RES_FALSE == res)
    {
    // Should be at the end of the read buffer.
    ASSERT(cb == cbRecMax);
    }

  return res;
  }


/*----------------------------------------------------------
Purpose: This function attempts to find a formatted string in
         the read buffer.  See description of ScanFormat.
         
Returns: RES_OK (if complete string is found)
         RES_FALSE (otherwise)

         RES_E_MOREDATA (if no string found and pszBuf is full)

Cond:    --
*/
RES PUBLIC FindFormat(
  HWND hwnd,
  HANDLE hFindFmt,
  LPDWORD piFound)
  {
  RES res = RES_E_FAIL;
#ifndef WINNT_RAS
//
// On NT, the 'hwnd' parameter is actually a pointer to the SCRIPTDATA
// for the current script, hence the #if-#else.
//

  PTERMDLG ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

#else // !WINNT_RAS

  SCRIPTDATA* ptd = (SCRIPTDATA*)hwnd;

#endif // !WINNT_RAS

  HSA hsa = (HSA)hFindFmt;
  UINT ib = NOT_MARKED;
  UINT ibMark = NOT_MARKED;
  int cbMatched = -1;
  DWORD iff;
  DWORD cff;

  ASSERT(hsa);

  DBG_ENTER(FindFormat);

  DEBUG_CODE( DumpBuffer(ptd); )

  // Consider each of the requested strings separately.  If
  // there are multiple candidate matches, choose the one 
  // that has the most matched characters.

  cff = SAGetCount(hsa);
  for (iff = 0; iff < cff; iff++)
    {
    PFINDFMT pff;
    RES resT;
    UINT ibMarkT;
    UINT ibT;
    int cbMatchedT;

    SAGetItemPtr(hsa, iff, &pff);

    resT = ScanFormat(pff, ptd->ibCurFind, ptd->pbReceiveBuf,
                      ptd->cbReceiveMax, &ibMarkT, &ibT, &cbMatchedT);

    // Did this string match?
    switch (resT)
      {
    case RES_OK:
      // Yes; stop right now
      ibMark = ibMarkT;
      ib = ibT;
      cbMatched = cbMatchedT;
      *piFound = iff;
      
      // Fall thru

    case RES_E_MOREDATA:
      res = resT;
      goto GetOut;

    case RES_FALSE:
      if (cbMatchedT > cbMatched)
      {
        res = resT;
        ibMark = ibMarkT;
        ib = ibT;
        cbMatched = cbMatchedT;
      }
      break;

    default:
      ASSERT(0);
      break;
      }
    }

GetOut:

  // Update the read buffer pointers to preserve any trailing
  // substring that may have matched.  
  if (RES_OK == res)
    {
    // Found string!
    TRACE_MSG(TF_BUFFER, "Found string in buffer");

    // It is okay to have characters following the matched string
    // that have not been scanned yet.  However, it is not okay
    // to still think there are characters preceding the matched
    // string that need scanning.
    ASSERT((UINT)cbMatched == ptd->cbReceiveMax && ib == ptd->ibCurRead ||
           (UINT)cbMatched <= ptd->cbReceiveMax);

    ptd->ibCurFind = ib;
    ptd->cbReceiveMax -= cbMatched;
    }
  else if (RES_E_MOREDATA == res)
    {
    // Throw away whatever is in the receive buffer
    TRACE_MSG(TF_BUFFER, "String too long in buffer");
    ptd->ibCurFind = ptd->ibCurRead;
    ptd->cbReceiveMax = 0;
    }
  else 
    {
    ASSERT(RES_FALSE == res);

    // End of receive buffer; did we even find a potential substring?
    if (NOT_MARKED == ibMark)
      {
      // No; throw away whatever is in the receive buffer
      TRACE_MSG(TF_BUFFER, "String not found in buffer");
      ptd->ibCurFind = ptd->ibCurRead;
      ptd->cbReceiveMax = 0;
      }
    else
      {
      // Yes; keep the substring part
      TRACE_MSG(TF_BUFFER, "Partial string found in buffer");

      ASSERT(ibMark >= ptd->ibCurFind);
      ptd->ibCurFind = ibMark;
      ptd->cbReceiveMax = cbMatched;
      }
    }

  DBG_EXIT_RES(FindFormat, res);

  return res;
  }


#ifdef OLD_FINDFORMAT
/*----------------------------------------------------------
Purpose: This function attempts to find a formatted string in
         the read buffer.  If a sequence of characters match 
         the complete string, the function returns TRUE.  The
         matching sequence of characters is copied into pszBuf.

         If a portion of the string (ie, from the beginning
         of pszFindFmt to some middle of pszFindFmt) is found 
         in the buffer, the buffer is marked so the next read will
         not overwrite the possible substring match.  This 
         function then returns FALSE.  The caller should 
         read in more data before calling this function again.

         The formatted string may have the following characters:

           %u   - expect a number (to first non-digit)
           ^M   - expect a carriage-return
           <cr> - expect a carriage-return
           <lf> - expect a line-feed

         All other characters are taken literally.

         If pszBuf becomes full before a delimiter is 
         encountered, this function returns RES_E_MOREDATA.

Returns: RES_OK (if complete string is found)
         RES_FALSE (otherwise)

         RES_E_MOREDATA (if no delimiter encountered and pszBuf is full)

Cond:    --
*/
RES PUBLIC FindFormat(
  HWND hwnd,
  HANDLE hFindFmt)
  {
  // The trick is keeping track of when we've found a partial
  // string across read boundaries.  Consider the search string
  // "ababc".  We need to find it in the following cases (the
  // character '|' indicates read boundary, '.' is an arbitrary
  // byte):
  //
  //   |...ababc..|
  //   |.abababc..|
  //   |......abab|c.........|
  //   |......abab|abc.......|
  //
  // This assumes the read buffer is larger than the search
  // string.  In order to do this, the read buffer must be
  // a circular buffer, always retaining that portion of the
  // possible string match from the last read.
  //
  //   1st read:  |...ababc..|  -> match found
  //
  //   1st read:  |.abababc..|  -> match found
  //
  //   1st read:  |......abab|  -> possible match (retain "abab")
  //   2nd read:  |ababc.....|  -> match found
  //
  //   1st read:  |......abab|  -> possible match (retain "abab")
  //   2nd read:  |abababc...|  -> match found
  //
  #define NOT_MARKED      ((UINT)-1)

  RES res = RES_FALSE;
  PTERMDLG ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
  PFINDFMT pff = (PFINDFMT)hFindFmt;
  LPCSTR psz;
  LPSTR pszBuf;
  LPSTR pszRecBuf = ptd->pbReceiveBuf;
  UINT ib;
  UINT ibMark = NOT_MARKED;
  UINT cb;
  UINT cbMatched = 0;
  UINT cbRecMax = ptd->cbReceiveMax;
  UINT cbBuf;

  ASSERT(pff);

  DBG_ENTER_SZ(FindFormat, pff->pszFindFmt);

  DEBUG_CODE( DumpBuffer(ptd); )

  pszBuf = pff->pszBuf;
  if (pszBuf)
    {
    TRACE_MSG(TF_GENERAL, "FindFormat: current buffer is {%s}", pff->pszBuf);

    cbBuf = pff->cbBuf;
    
    if (cbBuf == pff->cbBuf)
      {
      ASSERT(0 < cbBuf);
      cbBuf--;            // save space for null terminator (first time only)
      }
    }

  // Search for the (formatted) string in the receive
  // buffer.  Optionally store the matching received
  // characters in the findfmt buffer.

  for (psz = pff->pszFindFmt, ib = ptd->ibCurFind, cb = 0; 
    *psz && cb < cbRecMax;
    ib = (ib + 1) % SIZE_ReceiveBuf, cb++)
    {
    // Match?
    res = CompareFormat(pff, &psz, pszRecBuf[ib]);
    if (RES_OK == res)
      {
      // Yes
      if (NOT_MARKED == ibMark)
        {
        ibMark = ib;       // Mark starting position
        cbMatched = 0;
        }

      cbMatched++;

      if (pszBuf)
        {
        if (0 == cbBuf)
          {
          res = RES_E_MOREDATA;
          break;
          }
          
        *pszBuf++ = pszRecBuf[ib];  // Copy character to buffer
        cbBuf--;
        }
      }
    else if (RES_HALT == res)
      {
      ASSERT(0 == *psz);
      break;
      }
    else if (NOT_MARKED != ibMark)
      {
      // No; go back to where we thought the string might
      // have started.  The loop will increment one 
      // position and then resume search.
      cb -= cbMatched;
      ib = ibMark;
      ibMark = NOT_MARKED;
      psz = pff->pszFindFmt;
      if (pszBuf)
        {
        pszBuf = pff->pszBuf;
        cbBuf += cbMatched;
        }
      }
    }

  if (pszBuf)
    *pszBuf = 0;    // add null terminator

  if ( !*psz )
    {
    // Found string!
    TRACE_MSG(TF_BUFFER, "Found string in buffer");
    ASSERT(cbMatched <= ptd->cbReceiveMax);

    ptd->ibCurFind = ib;
    ptd->cbReceiveMax -= cbMatched;
    res = RES_OK;
    }
  else if (RES_E_MOREDATA == res)
    {
    // Throw away whatever is in the receive buffer
    TRACE_MSG(TF_BUFFER, "String too long in buffer");
    ptd->ibCurFind = ptd->ibCurRead;
    ptd->cbReceiveMax = 0;
    }
  else 
    {
    // End of receive buffer; did we even find a potential substring?
    ASSERT(cb == cbRecMax);

    if (NOT_MARKED == ibMark)
      {
      // No; throw away whatever is in the receive buffer
      TRACE_MSG(TF_BUFFER, "String not found in buffer");
      ptd->ibCurFind = ptd->ibCurRead;
      ptd->cbReceiveMax = 0;
      }
    else
      {
      // Yes; keep the substring part
      TRACE_MSG(TF_BUFFER, "Partial string found in buffer");

      ASSERT(ibMark >= ptd->ibCurFind);
      ptd->ibCurFind = ibMark;
      ptd->cbReceiveMax = cbMatched;
      }
        
    res = RES_FALSE;
    }

  DBG_EXIT_RES(FindFormat, res);

  return res;
  }
#endif

#ifdef COPYTODELIM
/*----------------------------------------------------------
Purpose: Sets or clears the list of delimiters

Returns: --
Cond:    --
*/
void PRIVATE SetDelimiters(
    PTERMDLG ptd,
    LPCSTR pszTok,
    BOOL bSet)
    {
    PBOOL rgbDelim = ptd->rgbDelim;
    LPCSTR psz;
    char ch;

    for (psz = pszTok; *psz; )
        {
        psz = MyNextChar(psz, &ch);

        ASSERT(InRange(ch, 0, CE_DELIM-1));
        rgbDelim[ch] = bSet;
        }
    }


/*----------------------------------------------------------
Purpose: This function reads to one of the given token 
         delimiters.  All characters in the read buffer (to
         the delimiter) are copied into pszBuf, not including
         the delimiter.
         
         Any token delimiters that are encountered before the
         first non-token delimiter are skipped, and the function
         starts at the first non-token delimiter.

         If a token delimiter is found, the function 
         returns RES_OK.

         If a token delimiter is not found in the current 
         read buffer, the function returns RES_FALSE and the
         characters that were read are still copied into 
         pszBuf.  The caller should read in more data before 
         calling this function again.

         If pszBuf becomes full before a delimiter is 
         encountered, this function returns RES_E_MOREDATA.

         The string returned in pszBuf is null terminated.

Returns: RES_OK 
         RES_FALSE (if no delimiter encountered this time)

         RES_E_MOREDATA (if no delimiter encountered and pszBuf is full)

Cond:    --
*/
RES PUBLIC CopyToDelimiter(
    HWND hwnd,
    LPSTR pszBuf,
    UINT cbBuf,
    LPCSTR pszTok)
    {
    RES res;
    PTERMDLG ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
    PBOOL rgbDelim = ptd->rgbDelim;
    LPSTR pszReadBuf = ptd->pbReceiveBuf;
    LPSTR psz;
    UINT ib;
    UINT cb;
    UINT cbMax = ptd->cbReceiveMax;

    DBG_ENTER_SZ(CopyToDelimiter, pszTok);

    DEBUG_CODE( DumpBuffer(ptd); )

#ifdef DEBUG

    for (ib = 0; ib < CE_DELIM; ib++)
        ASSERT(FALSE == rgbDelim[ib]);

#endif

    // Initialize the delimiters
    SetDelimiters(ptd, pszTok, TRUE);

    cbBuf--;        // save space for terminator

    // Skip to the first non-delimiter
    for (ib = ptd->ibCurFind, cb = 0;     
        cb < cbMax;
        ib = (ib + 1) % SIZE_ReceiveBuf, cb++)
        {
        char ch = pszReadBuf[ib];

        ASSERT(InRange(ch, 0, CE_DELIM-1));

        // Is this one of the delimiters?
        if ( !rgbDelim[ch] )
            {
            // No; stop
            break;
            }
        }

    if (cb < cbMax || 0 == cbMax)
        res = RES_FALSE;    // assume no delimiter in this pass
    else
        res = RES_OK;

    // Copy to the first delimiter encountered 

    for (psz = pszBuf; 
        0 < cbBuf && cb < cbMax;
        psz++, ib = (ib + 1) % SIZE_ReceiveBuf, cb++, cbBuf--)
        {
        char ch = pszReadBuf[ib];

        ASSERT(InRange(ch, 0, CE_DELIM-1));

        // Is this one of the delimiters?
        if (rgbDelim[ch])
            {
            // Yes; we're done
            res = RES_OK;
            break;
            }
        else
            {
            // No; 
            *psz = ch;
            }
        }

    *psz = 0;       // add null terminator

    ptd->ibCurFind = ib;
    ptd->cbReceiveMax -= cb;

    if (RES_FALSE == res)
        {
        res = (0 == cbBuf) ? RES_E_MOREDATA : RES_FALSE;
        }
    else
        {
        TRACE_MSG(TF_BUFFER, "Copied to delimiter %#02x", pszReadBuf[ib]);
        }

    // Deinitialize the delimiters
    SetDelimiters(ptd, pszTok, FALSE);

    DBG_EXIT_RES(CopyToDelimiter, res);

    return res;
    }
#endif // COPYTODELIM


/*----------------------------------------------------------
Purpose: Reads from the comm port into the circular buffer.
         This functions sets *ppbBuf to the location of
         the first new character read.

         there is a potential but rare bug
         that can occur with Internet providers that send
         DBCS over the wire.  If the last character in the
         buffer is a DBCS lead-byte, and it is being thrown
         away, then the next byte might be matched with an
         existing character.  The entire string following 
         this must match for us to find a false match.  

Returns: TRUE (if a character was read successfully)
         FALSE (otherwise)

Cond:    --
*/
BOOL PRIVATE ReadIntoBuffer(
#ifndef WINNT_RAS
//
// On NT, we use a SCRIPTDATA pointer to access the circular-buffer.
//
    PTERMDLG ptd,
#else // !WINNT_RAS
    SCRIPTDATA *ptd,
#endif // !WINNT_RAS
    PDWORD pibStart,        // start of newly read characters
    PDWORD pcbRead)         // count of newly read characters
    {
    BOOL bRet;
    OVERLAPPED ov;
    DWORD cb;
    DWORD cbRead;
    DWORD ib;

    DBG_ENTER(ReadIntoBuffer);

    ASSERT(pibStart);
    ASSERT(pcbRead);

    ov.Internal     = 0;
    ov.InternalHigh = 0;
    ov.Offset       = 0;
    ov.OffsetHigh   = 0;
    ov.hEvent       = NULL;
    *pcbRead        = 0;

    // This is a circular buffer, so at most do two reads
    ASSERT(ptd->ibCurRead >= ptd->ibCurFind);
    ASSERT(SIZE_ReceiveBuf > ptd->ibCurFind);
    ASSERT(SIZE_ReceiveBuf > ptd->ibCurRead);

    *pcbRead = 0;
    *pibStart = ptd->ibCurRead;
    // (*pibStart can be different from ptd->ibCurFind)

    ib = ptd->ibCurRead;
    cb = SIZE_ReceiveBuf - ib;

    do 
        {
        DWORD ibNew;

        ASSERT(SIZE_ReceiveBuf > *pcbRead);

#ifndef WINNT_RAS
//
// In order to read data on NT, we go through RxReadFile
// which reads from the buffer which was filled by RASMAN.
//

        bRet = ReadFile(ptd->hport, &ptd->pbReceiveBuf[ib], cb, &cbRead, &ov);
        SetEvent(ptd->hEvent[READ_EVENT]);

#else // !WINNT_RAS

        bRet = RxReadFile(
                    ptd->hscript, &ptd->pbReceiveBuf[ib], cb, &cbRead
                    );

#endif // !WINNT_RAS

        ptd->cbReceiveMax += cbRead;
        *pcbRead += cbRead;

        // Is this going to wrap around?
        ibNew = (ib + cbRead) % SIZE_ReceiveBuf;
        if (ibNew > ib)
            cb -= cbRead;           // No
        else
            cb = ptd->ibCurFind;    // Yes

        ib = ibNew;

        } while (bRet && 0 != cbRead && SIZE_ReceiveBuf > *pcbRead);

    ptd->ibCurRead = (ptd->ibCurRead + *pcbRead) % SIZE_ReceiveBuf;

    DEBUG_CODE( DumpBuffer(ptd); )

    DBG_EXIT_BOOL(ReadIntoBuffer, bRet);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Get input from the com port

Returns: TRUE
Cond:    --
*/
BOOL NEAR PASCAL GetInput(
    HWND hwnd)
    {
    BOOL bRet = TRUE;
    PTERMDLG ptd;
    DWORD cbRead;
    DWORD ibStart;

    DBG_ENTER(GetInput);

    ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

#ifndef WINNT_RAS
//
// On NT, the information for the script is stored in a SCRIPTDATA.
// The code below exists only to allow this file to compile;
// "GetInput" is not called at all on NT.
//

    if (ReadIntoBuffer(ptd, &ibStart, &cbRead) && 0 < cbRead)

#else // !WINNT_RAS

    if (ReadIntoBuffer((SCRIPTDATA *)ptd, &ibStart, &cbRead) && 0 < cbRead)

#endif // !WINNT_RAS
        {
        char  szBuf[SIZE_ReceiveBuf + 1];
        LPSTR pch = szBuf;
        UINT ib;
        UINT cb;
        HWND hwndScrn = GetDlgItem(hwnd, CID_T_EB_SCREEN);

        for (ib = ibStart, cb = 0; cb < cbRead; cb++, ib = (ib + 1) % SIZE_ReceiveBuf)
            {
            char ch = ptd->pbReceiveBuf[ib];

            /* Formatting: Converts CRs to LFs (there seems to be no VK_
            ** for LF) and throws away LFs.  This prevents the user from
            ** exiting the dialog when they press Enter (CR) in the
            ** terminal screen.  LF looks like CRLF in the edit box.  Also,
            ** throw away TABs because otherwise they change focus to the
            ** next control.
            */
            if (ch == VK_RETURN)
                {
                /* Must send whenever end-of-line is encountered because
                ** EM_REPLACESEL doesn't handle VK_RETURN characters well
                ** (prints garbage).
                */
                *pch = '\0';

                /* Turn off current selection, if any, and replace the null
                ** selection with the current buffer.  This has the effect
                ** of adding the buffer at the caret.  Finally, send the
                ** EOL to the window which (unlike EM_REPLACESEL) handles
                ** it correctly.
                */
                SendMessage(hwndScrn, WM_SETREDRAW, (WPARAM )FALSE, 0);

                SendMessage(hwndScrn, EM_SETSEL, 32767, 32767 );
                SendMessage(hwndScrn, EM_REPLACESEL, 0, (LPARAM )szBuf );
                SendMessage(hwndScrn, WM_EOLFROMDEVICE, 0, 0 );

                SendMessage(hwndScrn, WM_SETREDRAW, (WPARAM )TRUE, 0);
                SendMessage(hwndScrn, EM_SCROLLCARET, 0, 0);
                InvalidateRect(hwndScrn, NULL, FALSE);

                /* Start afresh on the output buffer.
                */
                pch = szBuf;
                continue;
                }
            else if (ch == '\n' || ch == VK_TAB)
                continue;

            *pch++ = ch;
            }

        *pch = '\0';

        if (pch != szBuf)
            {
            /* Send the last remnant of the line.
            */
            SendMessage(hwndScrn, EM_SETSEL, 32767, 32767);
            SendMessage(hwndScrn, EM_REPLACESEL, 0, (LPARAM)szBuf );
            SendMessage(hwndScrn, EM_SCROLLCARET, 0, 0);
            }
        }

    DBG_EXIT_BOOL(GetInput, bRet);

    return bRet;
    }

/*----------------------------------------------------------------------------
** Terminal Output Handler
**----------------------------------------------------------------------------
*/

/*----------------------------------------------------------
Purpose: Send a byte to the device.
Returns: --
Cond:    --
*/
void PUBLIC SendByte(
    HWND hwnd, 
    BYTE byte)
    {
#ifndef WINNT_RAS
//
// On NT. we use a SCRIPTDATA structure to hold information about the script.
//
    PTERMDLG  ptd;
#else // !WINNT_RAS
    SCRIPTDATA* ptd;
#endif // !WINNT_RAS
    DWORD     cbWrite;
    OVERLAPPED ov;

    DBG_ENTER(SendByte);

#ifndef WINNT_RAS
//
// On NT, the "hwnd" argument is actually a pointer to a SCRIPTDATA structure
// for the script being parsed.
//

    ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

#else // !WINNT_RAS

    ptd = (SCRIPTDATA *)hwnd;

#endif // !WINNT_RAS

    /* Send the character to the device.  It is not passed thru
    ** because the device will echo it.
    */
    ptd->pbSendBuf[0] = (BYTE)byte;

    /* Make sure we still have the comm port
    */
    ov.Internal     = 0;
    ov.InternalHigh = 0;
    ov.Offset       = 0;
    ov.OffsetHigh   = 0;
    ov.hEvent       = NULL;
    cbWrite = 0;

#ifndef WINNT_RAS
//
// On NT, we output data on the COM port by calling RxWriteFile
// which in turn passes the data to RasPortSend
//

    WriteFile(ptd->hport, ptd->pbSendBuf, SIZE_SendBuf, &cbWrite, &ov);

#else // !WINNT_RAS

    RxWriteFile(ptd->hscript, ptd->pbSendBuf, SIZE_SendBuf, &cbWrite);

#endif // !WINNT_RAS

    TRACE_MSG(TF_BUFFER, "Sent byte %#02x", byte);

    DBG_EXIT(SendByte);
    }


/*----------------------------------------------------------------------------
** Terminal Appearance Adjuster
**----------------------------------------------------------------------------
*/

VOID NEAR PASCAL AdjustTerminal (HWND hwnd, int wWidth, int wHeight)
{
  HWND  hwndCtrl;
  RECT  rect;
  SIZE  sizeButton;
  POINT ptPos;
  DWORD dwUnit;

  // Get the sizes of the push buttons
  //
  dwUnit = GetDialogBaseUnits();
  hwndCtrl = GetDlgItem(hwnd, IDOK);
  GetWindowRect(hwndCtrl, &rect);
  sizeButton.cx = rect.right  - rect.left;
  sizeButton.cy = rect.bottom - rect.top;
  ptPos.x   = wWidth/2 - ((X_SPACING*LOWORD(dwUnit))/4)/2 - sizeButton.cx;
  ptPos.y   = wHeight - (sizeButton.cy+((Y_MARGIN*HIWORD(dwUnit))/4));

  // Move the push buttons
  MoveWindow(hwndCtrl, ptPos.x, ptPos.y, sizeButton.cx, sizeButton.cy, TRUE);

  ptPos.x  += ((X_SPACING*LOWORD(dwUnit))/4) + sizeButton.cx;
  MoveWindow(GetDlgItem(hwnd, IDCANCEL), ptPos.x, ptPos.y,
             sizeButton.cx, sizeButton.cy, TRUE);

  // Move the input enable box
  hwndCtrl = GetDlgItem(hwnd, CID_T_CB_MIN);
  GetWindowRect(hwndCtrl, &rect);
  sizeButton.cx = rect.right  - rect.left;
  sizeButton.cy = rect.bottom - rect.top;
  ptPos.y -= (sizeButton.cy + ((Y_MARGIN*HIWORD(dwUnit))/4));
  ScreenToClient(hwnd, (LPPOINT)&rect);
  MoveWindow(hwndCtrl, rect.left, ptPos.y,
             sizeButton.cx,
             sizeButton.cy,
             TRUE);

  // Move the start-minimized box
  hwndCtrl = GetDlgItem(hwnd, CID_T_CB_INPUT);
  GetWindowRect(hwndCtrl, &rect);
  sizeButton.cx = rect.right  - rect.left;
  sizeButton.cy = rect.bottom - rect.top;
  ptPos.y -= (sizeButton.cy + ((Y_SMALL_MARGIN*HIWORD(dwUnit))/4));
  ScreenToClient(hwnd, (LPPOINT)&rect);
  MoveWindow(hwndCtrl, rect.left, ptPos.y,
             sizeButton.cx,
             sizeButton.cy,
             TRUE);

  // Get the current position of the terminal screen
  hwndCtrl = GetDlgItem(hwnd, CID_T_EB_SCREEN);
  GetWindowRect(hwndCtrl, &rect);
  ScreenToClient(hwnd, (LPPOINT)&rect);
  MoveWindow(hwndCtrl, rect.left, rect.top,
             wWidth - 2*rect.left,
             ptPos.y - rect.top - ((Y_SMALL_MARGIN*HIWORD(dwUnit))/4),
             TRUE);

  InvalidateRect(hwnd, NULL, TRUE);
  return;
}

/*----------------------------------------------------------------------------
** Terminal caption update
**----------------------------------------------------------------------------
*/

void NEAR PASCAL UpdateTerminalCaption(PTERMDLG ptd, UINT ids)
{
  LPSTR szTitle, szFmt;
  UINT  iRet;

  // If we are not running a script, do not update the caption
  //
  if (*ptd->script.szPath == '\0')
    return;

  // Allocate buffer
  //
  if ((szFmt = (LPSTR)LocalAlloc(LMEM_FIXED, 2*MAX_PATH)) != NULL)
  {
    // Load the display format
    //
    if((iRet = LoadString(g_hinst, ids, szFmt, MAX_PATH)))
    {
      // Get the title buffer
      //
      szTitle = szFmt+iRet+1;
      {
        // Build up the title
        //
        wsprintf(szTitle, szFmt, ptd->script.szPath);
        SetWindowText(ptd->hwnd, szTitle);
      };
    };
    LocalFree((HLOCAL)szFmt);
  };
  return;
}

/*----------------------------------------------------------------------------
** Terminal read-notification thread
**----------------------------------------------------------------------------
*/

void WINAPI TerminalThread (PTERMDLG  ptd)
    {
    DWORD     dwEvent;
    DWORD     dwMask;

    while((dwEvent = WaitForMultipleObjects(MAX_EVENT, ptd->hEvent,
                                            FALSE, INFINITE))
            < WAIT_OBJECT_0+MAX_EVENT)
        {
        switch (dwEvent)
            {
        case READ_EVENT:
            // Are we stopped?
            if (WAIT_TIMEOUT == WaitForSingleObject(ptd->hEvent[STOP_EVENT], 0))
                {
                // No; wait for next character
                dwMask = 0;

                TRACE_MSG(TF_BUFFER, "Waiting for comm traffic...");
                WaitCommEvent(ptd->hport, &dwMask, NULL);

                if ((dwMask & EV_RXCHAR) && (ptd->hwnd != NULL))
                    {
                    TRACE_MSG(TF_BUFFER, "...EV_RXCHAR incoming");
                    PostMessage(ptd->hwnd, WM_MODEMNOTIFY, 0, 0);
                    }
                else
                    {
                    TRACE_MSG(TF_BUFFER, "...EV_other (%#08lx) incoming", dwMask);
                    }
                }
            else
                {
                // Yes; just get out of here
                ExitThread(ERROR_SUCCESS);
                }
            break;

        case STOP_EVENT:
            ExitThread(ERROR_SUCCESS);
            break;

        default:
            ASSERT(0);
            break;
            }
        }
    }

/*----------------------------------------------------------------------------
** Set IP address
**----------------------------------------------------------------------------
*/

DWORD   NEAR PASCAL TerminalSetIP(HWND hwnd, LPCSTR pszIPAddr)
{
  PTERMDLG  ptd;
  DWORD dwRet;

  ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  if (IS_TEST_SCRIPT(ptd))
  {
    // We are testing, just display the ip address
    //
    MsgBox(g_hinst,
           hwnd,
           MAKEINTRESOURCE(IDS_IP_Address),
           MAKEINTRESOURCE(IDS_CAP_Script),
           NULL,
           MB_OK | MB_ICONINFORMATION,
           pszIPAddr);
  };

  // Set the IP address permanently
  //
  dwRet = AssignIPAddress(ptd->pscanner->psci->szEntryName,
                          pszIPAddr);
  return dwRet;
}

/*----------------------------------------------------------------------------
** Terminal Input settings
**----------------------------------------------------------------------------
*/

void NEAR PASCAL TerminalSetInput(HWND hwnd, BOOL fEnable)
{
  PTERMDLG ptd;

  ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  // If the status is not changed, do nothing
  //
  if ((ptd->fInputEnabled && !fEnable) ||
      (!ptd->fInputEnabled && fEnable))
  {
    // Mark the input enabling flag
    //
    ptd->fInputEnabled = fEnable;

    // Check the control properly
    //
    CheckDlgButton(hwnd, CID_T_CB_INPUT,
                   fEnable ? BST_CHECKED : BST_UNCHECKED);

    // Repaint the terminal screen
    //
    InvalidateRect(hwnd, NULL, FALSE);

    // If enable and the window is iconic, restore it
    //
    if (fEnable)
    {
      if (IsIconic(hwnd))
      {
        ShowWindow(hwnd, SW_RESTORE);
      };

      SetFocus(GetDlgItem(hwnd, CID_T_EB_SCREEN));
    };
  };
}

/*----------------------------------------------------------------------------
** Dump the script window
**----------------------------------------------------------------------------
*/

BOOL NEAR PASCAL DisplayScript (PTERMDLG ptd)
{
  // Create the debug script window
  //
  ptd->hwndDbg = CreateDialogParam(g_hinst,
                                   MAKEINTRESOURCE(IDD_TERMINALTESTDLG),
                                   NULL,
                                   DbgScriptDlgProc,
                                   (LPARAM)ptd);

  // Did we have the debug window?
  //
  if (!IsWindow(ptd->hwndDbg))
  {
    ptd->hwndDbg = NULL;
    return FALSE;
  };
  return TRUE;
}

/*----------------------------------------------------------------------------
** Script debug window procedure
**----------------------------------------------------------------------------
*/

LRESULT FAR PASCAL DbgScriptDlgProc(HWND   hwnd,
                                    UINT   wMsg,
                                    WPARAM wParam,
                                    LPARAM lParam )
{
  PTERMDLG ptd;

  switch (wMsg)
  {
    case WM_INITDIALOG:
    {
      HMENU  hMenuSys;

      ptd = (PTERMDLG)lParam;
      SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR)lParam);
      ptd->hwndDbg = hwnd;

      // Show its own icon
      //
      SendMessage(hwnd, WM_SETICON, TRUE,
                  (LPARAM)LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCRIPT)));

      // Always gray out size and maximize command
      //
      hMenuSys   = GetSystemMenu(hwnd, FALSE);
      EnableMenuItem(hMenuSys, SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);

      return (InitDebugWindow(hwnd));
    }
    case WM_PROCESSSCRIPT:
    {
      HWND     hCtrl;

      //
      // The main window notifies that it is done with the current line
      //
      ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

      // Make sure we do not continue processing the script
      //
      ptd->fContinue = FALSE;

      hCtrl = GetDlgItem(hwnd, CID_T_PB_STEP);
      EnableWindow(hCtrl, TRUE);
      SetFocus(hCtrl);
      TrackScriptLine(ptd, Astexec_GetCurLine(&ptd->astexec)-1);

      break;
    }

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
        case CID_T_EB_SCRIPT:
        {
          HWND hCtrl = GET_WM_COMMAND_HWND(wParam, lParam);

          if (GET_WM_COMMAND_CMD(wParam, lParam)==EN_SETFOCUS)
          {
            ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
            TrackScriptLine(ptd, ptd->iMarkLine);
          };
          break;
        }

        case CID_T_PB_STEP:
        {
          ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

          // Allow the next step
          //
          EnableWindow(GET_WM_COMMAND_HWND(wParam, lParam), FALSE);

          // Tell the main window to process the next script line
          //
          ptd->fContinue = TRUE;
          PostProcessScript(ptd->hwnd);
          break;
        }

      };
      break;

    case WM_HELP:
    case WM_CONTEXTMENU:
      ContextHelp(gaDebug, wMsg, wParam, lParam);
      break;
  };

  return 0;
}

/*----------------------------------------------------------------------------
** Init script debug window
**----------------------------------------------------------------------------
*/

BOOL NEAR PASCAL InitDebugWindow (HWND hwnd)
{
  PTERMDLG ptd;
  HANDLE hFile;
  LPBYTE lpBuffer;
  DWORD  cbRead;
  HWND   hCtrl;
  UINT   iLine, cLine, iMark;

  ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  ASSERT(IS_TEST_SCRIPT(ptd));

  // Do not start the script yet
  //
  ptd->fContinue = FALSE;

  // Allocate the read buffer
  //
  if ((lpBuffer = (LPBYTE)LocalAlloc(LMEM_FIXED, SIZE_ReceiveBuf)) == NULL)
    return FALSE;

  hCtrl = GetDlgItem(hwnd, CID_T_EB_SCRIPT);
  hFile = CreateFile(ptd->script.szPath, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  if (INVALID_HANDLE_VALUE != hFile)
  {
    while(ReadFile(hFile, lpBuffer, sizeof(SIZE_ReceiveBuf), &cbRead, NULL) &&
          (cbRead != 0))
    {
      // Clean up the end garbage
      //
      if (cbRead < SIZE_ReceiveBuf)
        lpBuffer[cbRead] = '\0';

      SendMessage(hCtrl, EM_SETSEL, 32767, 32767 );
      SendMessage(hCtrl, EM_REPLACESEL, 0, (LPARAM)lpBuffer );
    };
    CloseHandle(hFile);
  };

  // Display the file name
  //
  cbRead = GetDlgItemText(hwnd, CID_T_ST_FILE, lpBuffer, SIZE_ReceiveBuf) + 1;
  if(SIZE_ReceiveBuf >= (cbRead + (lstrlen(ptd->script.szPath) * sizeof(TCHAR))))
  {
      wsprintf(lpBuffer+cbRead, lpBuffer, ptd->script.szPath);
      SetDlgItemText(hwnd, CID_T_ST_FILE, lpBuffer+cbRead);
  }
  else
  {
    ASSERT(FALSE);
    SetDlgItemText(hwnd, CID_T_ST_FILE, ptd->script.szPath);
  }
  
  LocalFree(lpBuffer);

  // Init script track
  //
  for (iLine = 0, cLine = Edit_GetLineCount(hCtrl);
       iLine < cLine; iLine++)
  {
    iMark = Edit_LineIndex(hCtrl, iLine);
    Edit_SetSel(hCtrl, iMark, iMark);
    Edit_ReplaceSel(hCtrl, TRACE_UNMARK);
  };

  // Initialize script tracking
  //
  PostProcessScript(hwnd);

  return TRUE;
}

/*----------------------------------------------------------------------------
** Trace the script
**----------------------------------------------------------------------------
*/

void NEAR PASCAL TrackScriptLine(PTERMDLG ptd, DWORD iLine)
{
  HWND hCtrl;
  UINT iMark, iRange;
#pragma data_seg(DATASEG_READONLY)
const static char c_szLastline[] = {0x0d, 0x0a, ' '};
#pragma data_seg()

  ASSERT(0 <= iLine || INVALID_SCRIPT_LINE == iLine);

  hCtrl = GetDlgItem(ptd->hwndDbg, CID_T_EB_SCRIPT);

  // Do not update the screen until we are done
  //
  SendMessage(hCtrl, WM_SETREDRAW, (WPARAM )FALSE, 0);

  if ((ptd->iMarkLine != iLine) || (iLine == INVALID_SCRIPT_LINE))
  {
    // Remove the old mark
    //
    iMark = Edit_LineIndex(hCtrl, ptd->iMarkLine);
    Edit_SetSel(hCtrl, iMark, iMark+sizeof(TRACE_MARK)-1);
    Edit_ReplaceSel(hCtrl, TRACE_UNMARK);

    // If this is the last line, make a dummy line
    //
    if (iLine == INVALID_SCRIPT_LINE)
    {
      Edit_SetSel(hCtrl, 32767, 32767);
      Edit_ReplaceSel(hCtrl, c_szLastline);
      iLine = Edit_GetLineCount(hCtrl);
      EnableWindow(GetDlgItem(ptd->hwndDbg, CID_T_PB_STEP), FALSE);

#ifdef PROMPT_AT_COMPLETION
      // Prompt the user to continue
      //
      SetFocus(GetDlgItem(ptd->hwnd, IDOK));
#else
      // We are done processing the script, continue automatically
      //
      ptd->fContinue = TRUE;
      PostProcessScript(ptd->hwnd);
#endif // PROMPT_AT_COMPLETION

    };

    // Mark the current line
    //
    iMark = Edit_LineIndex(hCtrl, iLine);
    Edit_SetSel(hCtrl, iMark, iMark+sizeof(TRACE_UNMARK)-1);
    Edit_ReplaceSel(hCtrl, TRACE_MARK);
    ptd->iMarkLine = iLine;
  }
  else
  {
    iMark = Edit_LineIndex(hCtrl, iLine);
  };

  // Select the current line
  //
  iRange = Edit_LineLength(hCtrl, iMark)+1;
  Edit_SetSel(hCtrl, iMark, iMark+iRange);

  // Update the screen now
  //
  SendMessage(hCtrl, WM_SETREDRAW, (WPARAM )TRUE, 0);
  InvalidateRect(hCtrl, NULL, FALSE);
  Edit_ScrollCaret(hCtrl);

  return;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\symtab.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// symtab.c
//
// This file contains the symbol table functions.
//
// History:
//  04-30-95 ScottH     Created
//


#include "proj.h"

#define SYMTAB_SIZE_GROW    10      // in elements

//
// Symbol table entry routines
//


/*----------------------------------------------------------
Purpose: Create a symbol table entry

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC STE_Create(
    PSTE * ppste,
    LPCSTR pszIdent,
    DATATYPE dt)
    {
    RES res;
    PSTE pste;

    ASSERT(ppste);
    ASSERT(pszIdent);

    pste = GAllocType(STE);
    if (pste)
        {
        res = RES_OK;       // assume success

        if ( !GSetString(&pste->pszIdent, pszIdent) )
            res = RES_E_OUTOFMEMORY;
        else
            {
            pste->dt = dt;
            }
        }
    else
        res = RES_E_OUTOFMEMORY;

    // Did anything above fail?
    if (RFAILED(res))
        {
        // Yes; clean up
        STE_Destroy(pste);
        pste = NULL;
        }
    *ppste = pste;

    return res;
    }


/*----------------------------------------------------------
Purpose: Destroy the STE element

Returns: --
Cond:    --
*/
void CALLBACK STE_DeletePAPtr(
    LPVOID pv,
    LPARAM lparam)
    {
    STE_Destroy(pv);
    }


/*----------------------------------------------------------
Purpose: Destroys symbol table entry

Returns: RES_OK
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC STE_Destroy(
    PSTE this)
    {
    RES res;

    if (this)
        {
        if (this->pszIdent)
            GSetString(&this->pszIdent, NULL);  // free

        // (The evalres field should not be freed.  It is
        // a copy from somewhere else.)

        GFree(this);

        res = RES_OK;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Retrieves the symbol table entry value.  The type
         depends on the datatype.

Returns: RES_OK

         RES_E_FAIL (for a type that does not have a value)
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC STE_GetValue(
    PSTE this,
    PEVALRES per)
    {
    RES res;

    ASSERT(this);
    ASSERT(per);

    if (this && per)
        {
        res = RES_OK;       // assume success

        switch (this->dt)
            {
        case DATA_INT:
        case DATA_BOOL:
        case DATA_STRING:
        case DATA_LABEL:
        case DATA_PROC:
            per->dw = this->er.dw;
            break;

        default:
            ASSERT(0);
            res = RES_E_FAIL;
            break;
            }
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


//
// Symbol Table functions
//

/*----------------------------------------------------------
Purpose: Creates a symbol table

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Symtab_Create(
    PSYMTAB * ppst,
    PSYMTAB pstNext)            // May be NULL
    {
    RES res;
    PSYMTAB pst;

    ASSERT(ppst);

    pst = GAllocType(SYMTAB);
    if (pst)
        {
        if (PACreate(&pst->hpaSTE, SYMTAB_SIZE_GROW))
            {
            pst->pstNext = pstNext;
            res = RES_OK;
            }
        else
            res = RES_E_OUTOFMEMORY;
        }
    else
        res = RES_E_INVALIDPARAM;

    // Did anything above fail?
    if (RFAILED(res) && pst)
        {
        // Yes; clean up
        Symtab_Destroy(pst);
        pst = NULL;
        }
    *ppst = pst;

    return res;
    }


/*----------------------------------------------------------
Purpose: Destroys a symbol table

Returns: RES_OK
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Symtab_Destroy(
    PSYMTAB this)
    {
    RES res;

    if (this)
        {
        if (this->hpaSTE)
            {
            PADestroyEx(this->hpaSTE, STE_DeletePAPtr, 0);
            }
        GFree(this);
        res = RES_OK;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Compare symbol table entries by name.

Returns: 
Cond:    --
*/
int CALLBACK Symtab_Compare(
    LPVOID pv1,
    LPVOID pv2,
    LPARAM lParam)
    {
    PSTE pste1 = pv1;
    PSTE pste2 = pv2;

    return lstrcmpi(pste1->pszIdent, pste2->pszIdent);
    }


/*----------------------------------------------------------
Purpose: Looks for pszIdent in the symbol table entry.
         If STFF_IMMEDIATEONLY is not set, this function will
         look in successive scopes if the symbol is not found
         within this immediate scope.

         Symbol table entry is returned in *psteOut.

Returns: RES_OK (if found)
         RES_FALSE (if not found)

         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Symtab_FindEntry(
    PSYMTAB this,
    LPCSTR pszIdent,
    DWORD dwFlags,
    PSTE * ppsteOut,        // May be NULL
    PSYMTAB * ppstScope)    // May be NULL
    {
    RES res;

    // Default return values to NULL 
    if (ppsteOut)
        *ppsteOut = NULL;
    if (ppstScope)
        *ppstScope = NULL;

    if (this && pszIdent)
        {
        DWORD iste;
        STE ste;

        // Peform a binary search.  Find a match?

        ste.pszIdent = (LPSTR)pszIdent;
        iste = PASearch(this->hpaSTE, &ste, 0, Symtab_Compare, (LPARAM)this, PAS_SORTED);
        if (PA_ERR != iste)
            {
            // Yes
            PSTE pste = PAFastGetPtr(this->hpaSTE, iste);

            if (ppsteOut)
                *ppsteOut = pste;

            if (ppstScope)
                *ppstScope = this;

            res = RES_OK;
            }
        // Check other scopes?
        else if (IsFlagClear(dwFlags, STFF_IMMEDIATEONLY) && this->pstNext)
            {
            // Yes
            res = Symtab_FindEntry(this->pstNext, pszIdent, dwFlags, ppsteOut, ppstScope);
            }
        else
            res = RES_FALSE;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Insert the given symbol table entry into the symbol
         table.  This function does not prevent duplicate symbols.

Returns: RES_OK

         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Symtab_InsertEntry(
    PSYMTAB this,
    PSTE pste)
    {
    RES res;

    ASSERT(this);
    ASSERT(pste);

    if (PAInsertPtr(this->hpaSTE, PA_APPEND, pste))
        {
        PASort(this->hpaSTE, Symtab_Compare, (LPARAM)this);
        res = RES_OK;
        }
    else
        res = RES_E_OUTOFMEMORY;
    
    return res;
    }



/*----------------------------------------------------------
Purpose: This function generates a unique label name.

Returns: RES_OK
         RES_INVALIDPARAM

Cond:    Caller must free *ppszIdent.

*/
RES PUBLIC Symtab_NewLabel(
    PSYMTAB this,
    LPSTR pszIdentBuf)          // must be size MAX_BUF_KEYWORD
    {
    static int s_nSeed = 0;

#pragma data_seg(DATASEG_READONLY)
    const static char c_szLabelPrefix[] = "__ssh%u";
#pragma data_seg()

    RES res;
    char sz[MAX_BUF_KEYWORD];
    PSTE pste;

    ASSERT(pszIdentBuf);

    do
        {
        // Generate name
        wsprintf(sz, c_szLabelPrefix, s_nSeed++);

        // Is this unique?
        res = Symtab_FindEntry(this, sz, STFF_DEFAULT, NULL, NULL);
        if (RES_FALSE == res)
            {
            // Yes
            res = STE_Create(&pste, sz, DATA_LABEL);
            if (RSUCCEEDED(res))
                {
                res = Symtab_InsertEntry(this, pste);
                if (RSUCCEEDED(res))
                    {
                    lstrcpyn(pszIdentBuf, sz, MAX_BUF_KEYWORD);
                    res = RES_FALSE;    // break out of this loop
                    }
                }
            }
        }
        while(RES_OK == res);

    if (RES_FALSE == res)
        res = RES_OK;

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\util.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//      MODULE:         util.c
//
//      PURPOSE:        Common utilities
//
//	PLATFORMS:	Windows 95
//
//      FUNCTIONS:
//              InitACBList() - initializes the session control block list
//              DeInitACBList() - cleans up the session control block list
//              FindACBFromConn() - searches or allocates a session control block
//              CleanupACB() - removes the session control block
//              EnumCloseThreadWindow() - closes each window for the SMM thread
//              CloseThreadWindows() - enumerates the SMM thread window
//
//	SPECIAL INSTRUCTIONS: N/A
//

#include "proj.h"     // includes common header files and global declarations
#include "rcids.h"
#include <rtutils.h>

 DWORD g_dwRasscrptTraceId = INVALID_TRACEID;

#pragma data_seg(DATASEG_READONLY)
const static char c_szScriptEntry[] = {REGSTR_KEY_PROF"\\%s"};
#pragma data_seg()

/*----------------------------------------------------------
Purpose: Determines the script info that may be associated with
         the given connection name.

Returns: TRUE if an associated script was found (in registry)
         
Cond:    --
*/
BOOL PUBLIC GetScriptInfo(
    LPCSTR pszConnection,
    PSCRIPT pscriptBuf)
    {
#pragma data_seg(DATASEG_READONLY)
    const static char c_szScript[] = REGSTR_VAL_SCRIPT;
    const static char c_szMode[]   = REGSTR_VAL_MODE;
#pragma data_seg()
    BOOL bRet;
    char szSubKey[MAX_BUF];
    DWORD cbSize;
    DWORD dwType;
    HKEY hkey;

    ASSERT(pszConnection);
    ASSERT(pscriptBuf);

    // Assume non-test mode
    pscriptBuf->uMode = NORMAL_MODE;

    // Is there a script for this connection?
    cbSize = sizeof(pscriptBuf->szPath);
    wsprintf(szSubKey, c_szScriptEntry, pszConnection);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szSubKey, 0, KEY_ALL_ACCESS, &hkey))
        {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szScript, NULL, 
            &dwType, pscriptBuf->szPath, &cbSize) &&
            REG_SZ == dwType)
            {
            // Yes
            TRACE_MSG(TF_GENERAL, "Found script \"%s\" for connection \"%s\"", 
                pscriptBuf->szPath, pszConnection);

            // Get the test mode
            cbSize = sizeof(pscriptBuf->uMode);
            if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szMode, NULL,
                &dwType, (LPBYTE)&(pscriptBuf->uMode), &cbSize) ||
                REG_BINARY != dwType)
                {
                pscriptBuf->uMode = NORMAL_MODE;
                }

            bRet = TRUE;
            }
        else
            {
            // No
            TRACE_MSG(TF_GENERAL, "No script found for connection \"%s\"", 
                pszConnection);

            *(pscriptBuf->szPath) = 0;
            bRet = FALSE;
            }
        RegCloseKey(hkey);
        }
    else
        {
        TRACE_MSG(TF_GENERAL, "Connection \"%s\" not found", pszConnection);
        bRet = FALSE;
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Get/set the window placement of the terminal window with
         the given connection name.

Returns: TRUE if an associated script was found (in registry)
         
Cond:    --
*/
BOOL PUBLIC GetSetTerminalPlacement(
    LPCSTR pszConnection,
    LPWINDOWPLACEMENT pwp,
    BOOL fGet)
    {
#pragma data_seg(DATASEG_READONLY)
const static char c_szPlacement[] = REGSTR_VAL_TERM;
#pragma data_seg()
    BOOL bRet;
    char szSubKey[MAX_BUF];
    DWORD cbSize;
    DWORD dwType;
    HKEY hkey;

    ASSERT(pszConnection);
    ASSERT(pwp);

    bRet = FALSE;
    wsprintf(szSubKey, c_szScriptEntry, pszConnection);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szSubKey, 0, KEY_ALL_ACCESS, &hkey))
        {
        if (fGet)
            {
            cbSize = sizeof(*pwp);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szPlacement, NULL,
                &dwType, (LPBYTE)pwp, &cbSize) &&
                REG_BINARY == dwType)
                {
                bRet = TRUE;
                };
             }
        else
            {
            if (ERROR_SUCCESS == RegSetValueEx(hkey, c_szPlacement, 0,
                REG_BINARY, (LPBYTE)pwp, sizeof(*pwp)))
                {
                bRet = TRUE;
                };
            };
        RegCloseKey(hkey);
        };
    return bRet;
    }

/*----------------------------------------------------------
Purpose: This function gets the current character from the
         given psz string, and returns the pointer to the
         next character position.  

         This function should increment on a byte-basis only.
         The callers need to compare or send on a byte basis.

         The *pbIsTailByte parameter is updated to reflect whether
         the current character is a DBCS lead-byte character.
         The caller may use this state information to determine
         whether *pch is part of a DBCS character.

Returns: see above
Cond:    --
*/
LPCSTR PUBLIC MyNextChar(
    LPCSTR psz,
    char * pch,
    DWORD * pdwFlags)       // One of MNC_* 
    {
    BOOL bIsTailByte;

    #define IS_CARET(ch)            ('^' == (ch))
    #define IS_SPECIAL_LEAD(ch)     ('<' == (ch))
    #define BYTE_CR                 0x0D
    #define BYTE_LF                 0x0A

    ASSERT(psz);
    ASSERT(pch);
    ASSERT(pdwFlags);

    bIsTailByte = IsFlagSet(*pdwFlags, MNC_ISTAILBYTE);

    // bIsTailByte should only be true for trailing bytes on entry
    ASSERT(FALSE == bIsTailByte || (bIsTailByte && !IsDBCSLeadByte(*psz)));

    // These flags must be mutually exclusive
    ASSERT(IsFlagSet(*pdwFlags, MNC_ISLEADBYTE) && IsFlagClear(*pdwFlags, MNC_ISTAILBYTE) ||
           IsFlagClear(*pdwFlags, MNC_ISLEADBYTE) && IsFlagSet(*pdwFlags, MNC_ISTAILBYTE) ||
           0 == *pdwFlags); 

    // Remember whether we're in a DBCS trailing byte for next time
    if (IsDBCSLeadByte(*psz))
        {
        SetFlag(*pdwFlags, MNC_ISLEADBYTE);
        ClearFlag(*pdwFlags, MNC_ISTAILBYTE);
        }
    else if (IsFlagSet(*pdwFlags, MNC_ISLEADBYTE))
        {
        ClearFlag(*pdwFlags, MNC_ISLEADBYTE);
        SetFlag(*pdwFlags, MNC_ISTAILBYTE);
        }
    else
        {
        *pdwFlags = 0;
        }

    // Is this a DBCS trailing byte?
    if (IsFlagSet(*pdwFlags, MNC_ISTAILBYTE))
        {
        // Yes
        *pch = *psz;
        }

    // Is this a lead control character?
    else if (IS_CARET(*psz))
        {
        // Yes; look at next character for control character
        LPCSTR pszT = psz + 1;
        if (0 == *pszT)
            {
            // Reached end of string
            *pch = '^';
            }
        else if (InRange(*pszT, '@', '_'))
            {
            *pch = *pszT - '@';
            psz = pszT;
            }
        else if (InRange(*pszT, 'a', 'z'))
            {
            *pch = *pszT - 'a' + 1;
            psz = pszT;
            }
        else 
            {
            // Show the caret as a plain old caret
            *pch = *pszT;
            }
        }
    else if (IS_SPECIAL_LEAD(*psz))
        {
        // Is this <cr> or <lf>?
        int i;
        char rgch[4];   // big enough to hold "lf>" or "cr>"
        LPCSTR pszT = psz + 1;
        LPCSTR pszTPrev = psz;

        for (i = 0; 
            *pszT && i < sizeof(rgch)-1; 
            i++, pszT++)
            {
            rgch[i] = *pszT;
            pszTPrev = pszT;
            }
        rgch[i] = 0;    // add null terminator

        if (IsSzEqualC(rgch, "cr>"))
            {
            *pch = BYTE_CR;
            psz = pszTPrev;
            }
        else if (IsSzEqual(rgch, "lf>"))
            {
            *pch = BYTE_LF;
            psz = pszTPrev;
            }
        else
            {
            *pch = *psz;
            }
        }
    else if (IS_BACKSLASH(*psz))
        {
        // Is this \", \^, \<, or \\?
        LPCSTR pszT = psz + 1;

        switch (*pszT)
            {
        case '"':
        case '\\':
        case '^':
        case '<':
            *pch = *pszT;
            psz = pszT;
            break;

        default:
            *pch = *psz;
            break;
            }
        }
    else
        {
        *pch = *psz;
        }

    return psz + 1;
    }


#pragma data_seg(DATASEG_READONLY)
struct tagMPRESIDS
    {
    RES  res;
    UINT ids;
    } const c_mpresids[] = {
        { RES_E_FAIL,               IDS_ERR_InternalError },
        { RES_E_INVALIDPARAM,       IDS_ERR_InternalError },
        { RES_E_OUTOFMEMORY,        IDS_ERR_OutOfMemory },
        { RES_E_EOF,                IDS_ERR_UnexpectedEOF },
        { RES_E_MAINMISSING,        IDS_ERR_MainProcMissing },
        { RES_E_SYNTAXERROR,        IDS_ERR_SyntaxError },
        { RES_E_REDEFINED,          IDS_ERR_Redefined },
        { RES_E_UNDEFINED,          IDS_ERR_Undefined },
        { RES_E_IDENTMISSING,       IDS_ERR_IdentifierMissing },
        { RES_E_EOFUNEXPECTED,      IDS_ERR_UnexpectedEOF },
        { RES_E_STRINGMISSING,      IDS_ERR_StringMissing },
        { RES_E_INTMISSING,         IDS_ERR_IntMissing },
        { RES_E_INVALIDTYPE,        IDS_ERR_InvalidType },
        { RES_E_INVALIDSETPARAM,    IDS_ERR_InvalidParam },
        { RES_E_INVALIDIPPARAM,     IDS_ERR_InvalidIPParam },
        { RES_E_INVALIDPORTPARAM,   IDS_ERR_InvalidPortParam },
        { RES_E_INVALIDRANGE,       IDS_ERR_InvalidRange },
        { RES_E_INVALIDSCRNPARAM,   IDS_ERR_InvalidScreenParam },
        { RES_E_RPARENMISSING,      IDS_ERR_RParenMissing },
        { RES_E_REQUIREINT,         IDS_ERR_RequireInt },
        { RES_E_REQUIRESTRING,      IDS_ERR_RequireString },
        { RES_E_REQUIREBOOL,        IDS_ERR_RequireBool },
        { RES_E_REQUIREINTSTRING,   IDS_ERR_RequireIntString },
        { RES_E_REQUIREINTSTRBOOL,  IDS_ERR_RequireIntStrBool },
        { RES_E_REQUIRELABEL,       IDS_ERR_RequireLabel },
        { RES_E_TYPEMISMATCH,       IDS_ERR_TypeMismatch },
        { RES_E_DIVBYZERO,          IDS_ERR_DivByZero },
        };
#pragma data_seg()

/*----------------------------------------------------------
Purpose: Returns a string resource ID given the specific result
         value.  This function returns 0 if the result does
         not have an associated message string.

Returns: see above
Cond:    --
*/
UINT PUBLIC IdsFromRes(
    RES res)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(c_mpresids); i++)
        {
        if (res == c_mpresids[i].res)
            return c_mpresids[i].ids;
        }
    return 0;
    }

#ifdef DEBUG

#pragma data_seg(DATASEG_READONLY)
struct tagRESMAP
    {
    RES res;
    LPCSTR psz;
    } const c_rgresmap[] = {
        DEBUG_STRING_MAP(RES_OK),
        DEBUG_STRING_MAP(RES_FALSE),
        DEBUG_STRING_MAP(RES_HALT),
        DEBUG_STRING_MAP(RES_E_FAIL),
        DEBUG_STRING_MAP(RES_E_OUTOFMEMORY),
        DEBUG_STRING_MAP(RES_E_INVALIDPARAM),
        DEBUG_STRING_MAP(RES_E_EOF),
        DEBUG_STRING_MAP(RES_E_MOREDATA),
        DEBUG_STRING_MAP(RES_E_MAINMISSING),     
        DEBUG_STRING_MAP(RES_E_SYNTAXERROR),
        DEBUG_STRING_MAP(RES_E_REDEFINED),
        DEBUG_STRING_MAP(RES_E_UNDEFINED),
        DEBUG_STRING_MAP(RES_E_IDENTMISSING),    
        DEBUG_STRING_MAP(RES_E_EOFUNEXPECTED),   
        DEBUG_STRING_MAP(RES_E_STRINGMISSING),   
        DEBUG_STRING_MAP(RES_E_INTMISSING),   
        DEBUG_STRING_MAP(RES_E_INVALIDTYPE),     
        DEBUG_STRING_MAP(RES_E_INVALIDSETPARAM),
        DEBUG_STRING_MAP(RES_E_INVALIDIPPARAM),
        DEBUG_STRING_MAP(RES_E_INVALIDPORTPARAM),
        DEBUG_STRING_MAP(RES_E_INVALIDRANGE),
        DEBUG_STRING_MAP(RES_E_INVALIDSCRNPARAM),
        DEBUG_STRING_MAP(RES_E_RPARENMISSING),
        DEBUG_STRING_MAP(RES_E_REQUIREINT),
        DEBUG_STRING_MAP(RES_E_REQUIRESTRING),
        DEBUG_STRING_MAP(RES_E_REQUIREBOOL),
        DEBUG_STRING_MAP(RES_E_REQUIREINTSTRING),
        DEBUG_STRING_MAP(RES_E_REQUIREINTSTRBOOL),
        DEBUG_STRING_MAP(RES_E_REQUIRELABEL),
        DEBUG_STRING_MAP(RES_E_TYPEMISMATCH),
        DEBUG_STRING_MAP(RES_E_DIVBYZERO),
        };
#pragma data_seg()

/*----------------------------------------------------------
Purpose: Returns the string form of a RES value.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_GetRes(
    RES res)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(c_rgresmap); i++)
        {
        if (res == c_rgresmap[i].res)
            return c_rgresmap[i].psz;
        }
    return "Unknown RES";
    }


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\symtab.h ===
//
// Copyright (c) Microsoft Corporation 1995
//
// symtab.h
//
// Header file for the symbol table.
//
// History:
//  04-30-95 ScottH     Created
//

#ifndef __SYMTAB_H__
#define __SYMTAB_H__

//
// DATATYPE
//

typedef enum
    {
    DATA_INT,           // Uses er.nVal
    DATA_BOOL,          // Uses er.bVal
    DATA_STRING,        // Uses er.psz
    DATA_LABEL,         // Uses er.dw as code address
    DATA_PROC,
    } DATATYPE;
DECLARE_STANDARD_TYPES(DATATYPE);


//
// EVALRES (evaluation result)
//

typedef struct tagEVALRES
    {
    union
        {
        LPSTR   psz;
        int     nVal;
        BOOL    bVal;
        ULONG_PTR   dw;
        };
    } EVALRES;
DECLARE_STANDARD_TYPES(EVALRES);

//
// Symbol Table Entry
//

typedef struct tagSTE
    {
    LPSTR   pszIdent;
    DATATYPE dt;
    EVALRES er;
    } STE;      // symbol table entry
DECLARE_STANDARD_TYPES(STE);

RES     PUBLIC STE_Create(PSTE * ppste, LPCSTR pszIdent, DATATYPE dt);
RES     PUBLIC STE_Destroy(PSTE this);
RES     PUBLIC STE_GetValue(PSTE this, PEVALRES per);

#define STE_GetIdent(pste)      ((pste)->pszIdent)
#define STE_GetDataType(pste)   ((pste)->dt)

//
// Symbol Table
//

typedef struct tagSYMTAB
    {
    HPA     hpaSTE;        // element points to STE
    struct tagSYMTAB * pstNext;
    } SYMTAB;
DECLARE_STANDARD_TYPES(SYMTAB);

#define Symtab_GetNext(pst)         ((pst)->pstNext)

RES     PUBLIC Symtab_Destroy(PSYMTAB this);
RES     PUBLIC Symtab_Create(PSYMTAB * ppst, PSYMTAB pstNext);

// Symtab_Find flags
#define STFF_DEFAULT        0x0000
#define STFF_IMMEDIATEONLY  0x0001

RES     PUBLIC Symtab_FindEntry(PSYMTAB this, LPCSTR pszIdent, DWORD dwFlags, PSTE * ppsteOut, PSYMTAB * ppstScope);
RES     PUBLIC Symtab_InsertEntry(PSYMTAB this, PSTE pste);

RES     PUBLIC Symtab_NewLabel(PSYMTAB this, LPSTR pszIdentBuf);


#endif // __SYMTAB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\devicedb.c ===
/*
    File    devicedb.c

    Definition of the device database for the ras dialup server.

    Paul Mayfield, 10/2/97
*/

#include "rassrv.h"
#include "precomp.h"
//
// Definitions
//
#define DEV_FLAG_DEVICE      0x1
#define DEV_FLAG_NULL_MODEM  0x2
#define DEV_FLAG_PORT        0x4
#define DEV_FLAG_FILTERED    0x10
#define DEV_FLAG_DIRTY       0x20
#define DEV_FLAG_ENABLED     0x40

// ===================================
// Definitions of the database objects
// ===================================
typedef struct _RASSRV_DEVICE 
{
    PWCHAR pszName;       // Name of device
    DWORD dwType;         // Type of device
    DWORD dwId;           // Id of the item (for tapi properties)
    DWORD dwEndpoints;    // Number of enpoints item has
    DWORD dwFlags;        // see DEV_FLAG_XXX
    WCHAR pszPort[MAX_PORT_NAME + 1];
    struct _RASSRV_DEVICE * pModem; // Modem installed on a com port
                                    // only valid if DEV_FLAG_PORT set
} RASSRV_DEVICE;

typedef struct _RASSRV_DEVICEDB 
{
    DWORD dwDeviceCount;
    RASSRV_DEVICE ** pDeviceList;
    BOOL bFlushOnClose;
    BOOL bVpnEnabled;               // whether pptp or l2tp is enabled
    BOOL bVpnEnabledOrig;           // original value of vpn enabling
} RASSRV_DEVICEDB;

//
// Structure defines a node in a list of ports
//
typedef struct _RASSRV_PORT_NODE 
{
    PWCHAR pszName;
    WCHAR pszPort[MAX_PORT_NAME + 1];
    struct _RASSRV_DEVICE * pModem;     // modem installed on this port
    struct _RASSRV_PORT_NODE * pNext;
} RASSRV_PORT_NODE;

//
// Structure defines a list of ports
//
typedef struct _RASSRV_PORT_LIST 
{
    DWORD dwCount;
    RASSRV_PORT_NODE * pHead;
    WCHAR pszFormat[256];
    DWORD dwFmtLen;
} RASSRV_PORT_LIST;

// Reads device information from the system.
DWORD 
devGetSystemDeviceInfo(
    OUT RAS_DEVICE_INFO ** ppDevice, 
    OUT LPDWORD lpdwCount) 
{
    DWORD dwErr, dwSize, dwVer, dwCount;
    
    // Calculate the size required to enumerate the ras devices
    dwVer = RAS_VERSION;
    dwSize = 0;
    dwCount =0;
    dwErr = RasGetDeviceConfigInfo(NULL, &dwVer, &dwCount, &dwSize, NULL);
    if ((dwErr != ERROR_SUCCESS) && (dwErr != ERROR_BUFFER_TOO_SMALL)) 
    {
        DbgOutputTrace(
            "devGetSysDevInfo: 0x%08x from RasGetDevCfgInfo (1)", 
            dwErr);
        return dwErr;
    }
    *lpdwCount = dwCount;
    
    // If there is nothing to allocate, return with zero devices
    if (dwSize == 0) 
    {
        *lpdwCount = 0;
        return NO_ERROR;
    }
    
    // Allocate the buffer
    if ((*ppDevice = RassrvAlloc(dwSize, FALSE)) == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Enumerate the devices
    dwErr = RasGetDeviceConfigInfo(
                NULL,
                &dwVer, 
                lpdwCount, 
                &dwSize, 
                (LPBYTE)(*ppDevice));
    if (dwErr != ERROR_SUCCESS)
    {                                        
        DbgOutputTrace(
            "devGetSysDevInfo: 0x%08x from RasGetDevCfgInfo (2)", dwErr);
        return dwErr;
    }

    return NO_ERROR;
}

//
// Frees the buffer returned by devGetSystemDeviceInfo
//
DWORD 
devFreeSystemDeviceInfo(
    IN RAS_DEVICE_INFO * pDevice) 
{
    if (pDevice)
    {
        RassrvFree(pDevice);
    }
    
    return NO_ERROR;
}

//
// Returns whether the given device is a physical (i.e. not tunnel) device.
//
BOOL 
devIsPhysicalDevice(
    IN RAS_DEVICE_INFO * pDevice) 
{
    DWORD dwClass = RAS_DEVICE_CLASS (pDevice->eDeviceType);

    return ((dwClass & RDT_Direct)     || 
            (dwClass & RDT_Null_Modem) ||
            (dwClass == 0));
}

//
// Returns whether the given device is a tunneling device
//
BOOL 
devIsTunnelDevice(
    IN RAS_DEVICE_INFO * pDevice) 
{
    DWORD dwClass = RAS_DEVICE_CLASS (pDevice->eDeviceType);

    return (dwClass & RDT_Tunnel); 
}

//
// Finds the device information associated with the given device
// based on its tapi line id
//
DWORD 
devFindDevice(
    IN  RAS_DEVICE_INFO * pDevices, 
    IN  DWORD dwCount,
    OUT RAS_DEVICE_INFO ** ppDevice, 
    IN  DWORD dwTapiLineId) 
{
    DWORD i; 

    // Validate parameters
    if (!pDevices || !ppDevice)
        return ERROR_INVALID_PARAMETER;

    // Initialize
    *ppDevice = NULL;

    // Search the list
    for (i = 0; i < dwCount; i++) 
    {
        if (devIsPhysicalDevice(&pDevices[i])) 
        {
            if (pDevices[i].dwTapiLineId == dwTapiLineId) 
            {
                *ppDevice = &(pDevices[i]);
                break;
            }
        }
    }

    // See if a match was found;
    if (*ppDevice)
    {
        return NO_ERROR;
    }
    
    return ERROR_NOT_FOUND;
}

//
// Determine the type of the device in question
//
DWORD 
devDeviceType(
    IN RAS_DEVICE_INFO * pDevice) 
{
    DWORD dwClass = RAS_DEVICE_CLASS (pDevice->eDeviceType);
    DWORD dwType = RAS_DEVICE_TYPE (pDevice->eDeviceType);

    if ((dwClass & RDT_Direct)     || 
        (dwClass & RDT_Null_Modem) ||
        (dwType  == RDT_Irda)      ||
        (dwType == RDT_Parallel) )
    {
        return INCOMING_TYPE_DIRECT;
    }
    else if (dwClass == RDT_Tunnel)
    {
        return INCOMING_TYPE_VPN;
    }

    return INCOMING_TYPE_PHONE;
}

//
// Returns the flags of a given device
//
DWORD 
devInitFlags(
    IN RAS_DEVICE_INFO * pDevice) 
{
    DWORD dwClass = RAS_DEVICE_CLASS (pDevice->eDeviceType),
          dwRet = 0;

    // Set the device's enabling
    if (pDevice->fRasEnabled)
    {
        dwRet |= DEV_FLAG_ENABLED;
    }

    // Determine if it's a null modem or a device.  It 
    // can't be a port, since those are not reported 
    // through ras.
    if (dwClass & RDT_Null_Modem)
    {
        dwRet |= DEV_FLAG_NULL_MODEM;
    }
    else
    {
        dwRet |= DEV_FLAG_DEVICE;
    }

    // Since the filtered and dirty flags are to be
    // initialized to false, we're done.
    
    return dwRet;
}

//
// Generates the device name
//
PWCHAR 
devCopyDeviceName(
    IN RAS_DEVICE_INFO * pDevice, 
    IN DWORD dwType) 
{
    PWCHAR pszReturn;
    DWORD dwSize;
    PWCHAR pszDccFmt = (PWCHAR) 
        PszLoadString(Globals.hInstDll, SID_DEVICE_DccDeviceFormat);
    PWCHAR pszMultiFmt = (PWCHAR) 
        PszLoadString(Globals.hInstDll, SID_DEVICE_MultiEndpointDeviceFormat);
    WCHAR pszPort[MAX_PORT_NAME + 1];
    WCHAR pszDevice[MAX_DEVICE_NAME + 1];

    // Sanity check the resources
    //
    if (!pszDccFmt || !pszMultiFmt)
    {
        return NULL;
    }

    // Get the unicode versions of the port/device
    //
    pszPort[0] = L'\0';
    pszDevice[0] = L'\0';
    if (pDevice->szPortName)
    {
        StrCpyWFromAUsingAnsiEncoding(
            pszPort, 
            pDevice->szPortName,
            strlen(pDevice->szPortName) + 1);
    } 
    if (pDevice->szDeviceName)
    {
#if 0    
        StrCpyWFromAUsingAnsiEncoding(
            pszDevice, 
            pDevice->szDeviceName,
            strlen(pDevice->szDeviceName) + 1);
#endif

        wcsncpy(
            pszDevice,
            pDevice->wszDeviceName,
            MAX_DEVICE_NAME);

        pszDevice[MAX_DEVICE_NAME] = L'\0';            
    }

    // For direct connections, be sure to display the name of the com port
    // in addition to the name of the null modem.
    if (dwType == INCOMING_TYPE_DIRECT) 
    {
        // Calculate the size
        dwSize = wcslen(pszDevice) * sizeof(WCHAR)  + // device
                 wcslen(pszPort)   * sizeof(WCHAR)  + // com port
                 wcslen(pszDccFmt) * sizeof(WCHAR)  + // oth chars
                 sizeof(WCHAR);                       // null 

        // Allocate the new string
        if ((pszReturn = RassrvAlloc (dwSize, FALSE)) == NULL)   
        {
            return pszReturn;
        }

        wsprintfW(pszReturn, pszDccFmt, pszDevice, pszPort);
    }

    //
    // If it's a modem device with multilple end points (such as isdn) 
    // display the endpoints in parenthesis
    //
    else if ((dwType == INCOMING_TYPE_PHONE) &&
             (pDevice->dwNumEndPoints > 1))
    {
        // Calculate the size
        dwSize = wcslen(pszDevice)   * sizeof(WCHAR) + // device
                 wcslen(pszMultiFmt) * sizeof(WCHAR) + // channels
                 20 * sizeof (WCHAR)                 + // oth chars
                 sizeof(WCHAR);                        // null

        // Allocate the new string
        if ((pszReturn = RassrvAlloc(dwSize, FALSE)) == NULL)
        {
            return pszReturn;
        }

        wsprintfW(
            pszReturn, 
            pszMultiFmt, 
            pszDevice, 
            pDevice->dwNumEndPoints);        
    }

    // Otherwise, this is a modem device with one endpoint.  
    // All that needs to be done here is to copy in the name.
    //
    else 
    {
        // Calculate the size
        dwSize = (wcslen(pszDevice) + 1) * sizeof(WCHAR);
        
        // Allocate the new string
        if ((pszReturn = RassrvAlloc(dwSize, FALSE)) == NULL)
        {
            return pszReturn;
        }

        wcscpy(pszReturn, pszDevice);
    }

    return pszReturn;
}

//
// Commits changes to device configuration to the system.  The call 
// to RasSetDeviceConfigInfo might fail if the device is in the process 
// of being configured so we implement a retry 
// mechanism here.
//
DWORD 
devCommitDeviceInfo(
    IN RAS_DEVICE_INFO * pDevice) 
{
    DWORD dwErr, dwTimeout = 10;
    
    do {
        // Try to commit the information
        dwErr = RasSetDeviceConfigInfo(
                    NULL, 
                    1, 
                    sizeof(RAS_DEVICE_INFO), 
                    (LPBYTE)pDevice);    

        // If unable to complete, wait and try again
        if (dwErr == ERROR_CAN_NOT_COMPLETE) 
        {
            DbgOutputTrace(
                "devCommDevInfo: 0x%08x from RasSetDevCfgInfo (try again)", 
                dwErr);
            Sleep(300);
            dwTimeout--;
        }

        // If completed, return no error
        else if (dwErr == NO_ERROR)
        {
            break;
        }

        // Otherwise, return the error code.
        else 
        {
            DbgOutputTrace(
                "devCommDevInfo: can't commit %S, 0x%08x", 
                pDevice->szDeviceName, dwErr);
                
            break;
        }
        
    } while (dwTimeout);

    return dwErr;
}

//
// Opens a handle to the database of general tab values
//
DWORD 
devOpenDatabase(
    IN HANDLE * hDevDatabase) 
{
    RASSRV_DEVICEDB * This;
    DWORD dwErr, i;
    
    if (!hDevDatabase)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the database cache
    if ((This = RassrvAlloc(sizeof(RASSRV_DEVICEDB), TRUE)) == NULL) 
    {
        DbgOutputTrace("devOpenDatabase: can't allocate memory -- exiting");
        return ERROR_NOT_ENOUGH_MEMORY;
    }
        
    // Initialize the values from the system
    devReloadDatabase((HANDLE)This);

    // Return the handle
    *hDevDatabase = (HANDLE)This;
    This->bFlushOnClose = FALSE;

    return NO_ERROR;
}

//
// Closes the general database and flushes any changes 
// to the system when bFlushOnClose is TRUE
//
DWORD 
devCloseDatabase(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    DWORD i;
    
    // Flush if requested
    if (This->bFlushOnClose)
        devFlushDatabase(hDevDatabase);
    
    // Free all of the device names
    for (i = 0; i < This->dwDeviceCount; i++) 
    {
        if (This->pDeviceList[i]) 
        {
            if (This->pDeviceList[i]->pszName)
            {
                RassrvFree(This->pDeviceList[i]->pszName);
            }
            RassrvFree(This->pDeviceList[i]);
        }
    }

    // Free up the device list cache
    if (This->pDeviceList)
    {
        RassrvFree (This->pDeviceList);
    }

    // Free up the database cache
    RassrvFree(This);

    return NO_ERROR;
}

//
// Commits the changes made to a particular device
//
DWORD 
devCommitDevice (
    IN RASSRV_DEVICE * pDevice, 
    IN RAS_DEVICE_INFO * pDevices,
    IN DWORD dwCount)
{
    RAS_DEVICE_INFO *pDevInfo = NULL;
    
    devFindDevice(pDevices, dwCount, &pDevInfo, pDevice->dwId);
    if (pDevInfo) {
        pDevInfo->fWrite = TRUE;
        pDevInfo->fRasEnabled = !!(pDevice->dwFlags & DEV_FLAG_ENABLED);
        devCommitDeviceInfo(pDevInfo);
    }

    // Mark the device as not dirty
    pDevice->dwFlags &= ~DEV_FLAG_DIRTY;

    return NO_ERROR;
}


BOOL
devIsVpnEnableChanged(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * pDevDb = (RASSRV_DEVICEDB*)hDevDatabase;

    
    if ( pDevDb )
    {
        return ( pDevDb->bVpnEnabled != pDevDb->bVpnEnabledOrig? TRUE:FALSE );
    }

    return FALSE;

}//devIsVpnEnableChanged()

//
// Commits any changes made to the general tab values 
//
DWORD 
devFlushDatabase(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    DWORD dwErr = NO_ERROR, i, dwCount, dwTimeout;
    RAS_DEVICE_INFO * pDevices = NULL;
    RASSRV_DEVICE * pCur = NULL;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Get all of the system device information
    dwErr = devGetSystemDeviceInfo(&pDevices, &dwCount);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Flush all changed settings to the system
    for (i = 0; i < This->dwDeviceCount; i++) 
    {
        pCur = This->pDeviceList[i];
        
        // If this device needs to be flushed
        if (pCur->dwFlags & DEV_FLAG_DIRTY) 
        {
             // Reset the installed device's enabling if it still 
             // exists in the system
            if ((pCur->dwFlags & DEV_FLAG_DEVICE) ||
                (pCur->dwFlags & DEV_FLAG_NULL_MODEM))
            {                
                devCommitDevice(pCur, pDevices, dwCount);
            }                

            // If this is a com port, then we should enable that modem
            // installed on the port if it exists or install a null modem  
            // over it if not.
            else if (pCur->dwFlags & DEV_FLAG_PORT) 
            {
                // If this port is associated with an already installed
                // null modem, then set the enabling on this modem if 
                // it is different
                if (pCur->pModem != NULL)
                {                      
                    if ((pCur->dwFlags & DEV_FLAG_ENABLED) != 
                        (pCur->pModem->dwFlags & DEV_FLAG_ENABLED))
                    {
                        // For whistler bug 499405      gangz
                        // devCommitDevice just flush out the device info as it 
                        // is, so we have to change pCur->pModem->dwFlags 
                        // 
                        if( pCur->dwFlags & DEV_FLAG_ENABLED )
                        {
                            pCur->pModem->dwFlags |= DEV_FLAG_ENABLED;
                        }
                        else
                        {
                            pCur->pModem->dwFlags &= ~DEV_FLAG_ENABLED;
                        }
                        
                        devCommitDevice (
                            pCur->pModem, 
                            pDevices, 
                            dwCount);
                    }
                }                 

                // Otherwise, (if there is no null modem associated with 
                // this port) install a null modem over this port if 
                // it is set to enabled.
                else if (pCur->dwFlags & DEV_FLAG_ENABLED)
                {
                    dwErr = MdmInstallNullModem (pCur->pszPort);
                }                                
            }
        }
    }

    // Flush all of the changed vpn settings
    if (This->bVpnEnabled != This->bVpnEnabledOrig) 
    {
        for (i = 0; i < dwCount; i++) 
        {
            if (devIsTunnelDevice(&pDevices[i])) 
            {
                pDevices[i].fWrite = TRUE;
                pDevices[i].fRasEnabled = This->bVpnEnabled;
                devCommitDeviceInfo(&pDevices[i]);    
            }
        }
        This->bVpnEnabledOrig = This->bVpnEnabled;
    }

    // Cleanup
    if (pDevices)
    {
        devFreeSystemDeviceInfo(pDevices);
    }        

    return dwErr;
}

//
// Rollsback any changes made to the general tab values
//
DWORD 
devRollbackDatabase(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    if (This == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    This->bFlushOnClose = FALSE; 
    return NO_ERROR;
}

//
// Reloads the device database
//
DWORD 
devReloadDatabase(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    DWORD dwErr = NO_ERROR, i, j = 0, dwSize;
    RAS_DEVICE_INFO * pRasDevices; 
    RASSRV_DEVICE * pTempList, *pDevice;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize vpn status
    This->bVpnEnabled = FALSE;
    
    // Get the device information from rasman
    pRasDevices = NULL;
    dwErr = devGetSystemDeviceInfo(&pRasDevices, &This->dwDeviceCount);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }
    
    do
    {
        // Initialize the incoming ras capable devices list
        if (This->dwDeviceCount) 
        {
            dwSize = sizeof(RASSRV_DEVICE*) * This->dwDeviceCount;
            This->pDeviceList = RassrvAlloc(dwSize, TRUE);
            if (!This->pDeviceList)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Build the device array accordingly
            j = 0;
            for (i = 0; i < This->dwDeviceCount; i++) 
            {
                // If it's a physical device, fill in the appropriate 
                // fields.
                if (devIsPhysicalDevice(&pRasDevices[i])) 
                {
                    // Allocate the new device
                    pDevice = RassrvAlloc(sizeof(RASSRV_DEVICE), TRUE);
                    if (pDevice == NULL)
                    {
                        continue;
                    }

                    // Assign its values                        
                    pDevice->dwType      = devDeviceType(&pRasDevices[i]);
                    pDevice->dwId        = pRasDevices[i].dwTapiLineId;
                    pDevice->pszName     = devCopyDeviceName(
                                              &pRasDevices[i],
                                              pDevice->dwType);
                    pDevice->dwEndpoints = pRasDevices[i].dwNumEndPoints;
                    pDevice->dwFlags     = devInitFlags(&pRasDevices[i]);
                    StrCpyWFromA(
                        pDevice->pszPort, 
                        pRasDevices[i].szPortName,
                        MAX_PORT_NAME + 1);
                    This->pDeviceList[j] = pDevice;                              
                    j++;
                }

                // If any tunneling protocol is enabled, we consider all 
                // to be
                else if (devIsTunnelDevice(&pRasDevices[i])) 
                {
                    This->bVpnEnabled |= pRasDevices[i].fRasEnabled;
                    This->bVpnEnabledOrig = This->bVpnEnabled;
                }
            }

            // Set the actual size of phyiscal adapters buffer.
            This->dwDeviceCount = j;
        }

    } while (FALSE);
    
    // Cleanup 
    {
        devFreeSystemDeviceInfo(pRasDevices);
    }

    return dwErr;
}

//
// Filters out all devices in the database except those that
// meet the given type description (can be ||'d).
//
DWORD 
devFilterDevices(
    IN HANDLE hDevDatabase, 
    DWORD dwType) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    RASSRV_DEVICE * pDevice;
    DWORD i;
    
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Go through the list of marking out devices to be filtered
    for (i = 0; i < This->dwDeviceCount; i++) 
    {
        pDevice = This->pDeviceList[i];
        if (pDevice == NULL)
        {
            continue;
        }            
        if (pDevice->dwType & dwType)
        {
            pDevice->dwFlags &= ~DEV_FLAG_FILTERED;
        }
        else
        {
            pDevice->dwFlags |= DEV_FLAG_FILTERED;
        }
    }

    return NO_ERROR;
}

//
// Device enumeration function.  Returns TRUE to stop enumeration,
// FALSE to continue.
//
BOOL devAddPortToList (
        IN PWCHAR pszPort,
        IN HANDLE hData) 
{
    RASSRV_PORT_LIST * pList = (RASSRV_PORT_LIST*)hData;
    RASSRV_PORT_NODE * pNode = NULL;
    DWORD dwSize;

    // Create the new node
    pNode = (RASSRV_PORT_NODE *) RassrvAlloc(sizeof(RASSRV_PORT_NODE), TRUE);
    if (pNode == NULL)
    {
        return FALSE;
    }

    // Add it to the head
    pNode->pNext = pList->pHead;
    pList->pHead = pNode;
    pList->dwCount++;

    // Add the names of the port
    if (pszPort) 
    {
        dwSize = (wcslen(pszPort) + pList->dwFmtLen + 1) * sizeof(WCHAR);
        pNode->pszName = (PWCHAR) RassrvAlloc (dwSize, FALSE);
        if (pNode->pszName == NULL)
        {
            return TRUE;
        }
        wsprintfW (pNode->pszName, pList->pszFormat, pszPort);
        lstrcpynW(pNode->pszPort, pszPort, sizeof(pNode->pszPort) / sizeof(WCHAR));
    }            

    return FALSE;
}

//
// Cleans up the resources used in a device list
//
DWORD 
devCleanupPortList(
    IN RASSRV_PORT_LIST * pList) 
{
    RASSRV_PORT_NODE * pCur = NULL, * pNext = NULL;

    pCur = pList->pHead;
    while (pCur) 
    {
        pNext = pCur->pNext;
        RassrvFree(pCur);
        pCur = pNext;
    }

    return NO_ERROR;
}

// 
// Removes all ports from the list for which there are already
// devices installed in the database.
//
DWORD devFilterPortsInUse (
        IN RASSRV_DEVICEDB *This, 
        RASSRV_PORT_LIST *pList)
{
    RASSRV_PORT_LIST PortList, *pDelete = &PortList;
    RASSRV_PORT_NODE * pCur = NULL, * pPrev = NULL;
    RASSRV_DEVICE * pDevice;
    DWORD i;
    BOOL bDone;
    INT iCmp;

    // If the list is empty, return
    if (pList->dwCount == 0)
    {
        return NO_ERROR;
    }

    // Initailize
    ZeroMemory(pDelete, sizeof(RASSRV_PORT_LIST));
    
    // Compare all of the enumerated ports to the ports 
    // in use in the device list.
    for (i = 0; i < This->dwDeviceCount; i++) 
    {
        // Point to the current device
        pDevice = This->pDeviceList[i];
    
        // Initialize the current and previous and break if the
        // list is now empty
        pCur = pList->pHead;
        if (pCur == NULL)
        {
            break;
        }

        // Remove the head node until it doesn't match
        bDone = FALSE;
        while ((pList->pHead != NULL) && (bDone == FALSE)) 
        {
            iCmp = lstrcmpi (pDevice->pszPort,
                             pList->pHead->pszPort);
            // If a device is already using this com port
            // then remove the com port from the list since it
            // isn't available
            if ((pDevice->dwFlags & DEV_FLAG_DEVICE) && (iCmp == 0)) 
            {
                pCur = pList->pHead->pNext;
                RassrvFree(pList->pHead);
                pList->pHead = pCur;
                pList->dwCount -= 1;
            }
            else 
            {
                // If the device is a null modem, then we filter
                // it out of the list of available devices and we 
                // reference it in the com port so that we can 
                // enable/disable it later if we need to.
                if (iCmp == 0) 
                {
                   pDevice->dwFlags |= DEV_FLAG_FILTERED;
                   pList->pHead->pModem = pDevice;
                }
                bDone = TRUE;
            }
        }

        // If we've elimated everyone, return
        if (pList->dwCount == 0)
        {
            return NO_ERROR;
        }

        // Loop through all of the past the head removing those
        // that are in use by the current ras device.
        pPrev = pList->pHead;
        pCur = pPrev->pNext;
        while (pCur) 
        {
            iCmp = lstrcmpi (pDevice->pszPort,
                             pCur->pszPort);
            // If a device is already using this com port
            // that remove the com port from the list since it
            // isn't available
            if ((pDevice->dwFlags & DEV_FLAG_DEVICE) && (iCmp == 0)) 
            {
                pPrev->pNext = pCur->pNext;
                RassrvFree(pCur);
                pCur = pPrev->pNext;
                pList->dwCount -= 1;
            }
            else 
            {
                // If the device is a null modem, then we filter
                // it out of the list of available devices and we 
                // reference it in the com port so that we can 
                // enable/disable it later if we need to.
                if (iCmp == 0) 
                {
                    pDevice->dwFlags |= DEV_FLAG_FILTERED;
                    pCur->pModem = pDevice;
                }
                pCur = pCur->pNext;
                pPrev = pPrev->pNext;
            }                
        }            
    }

    return NO_ERROR;
}

//
// Adds com ports as uninstalled devices in the device database
//
DWORD 
devAddComPorts(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    RASSRV_PORT_LIST PortList, *pList = &PortList;
    RASSRV_PORT_NODE * pNode = NULL;
    RASSRV_DEVICE ** ppDevices;
    DWORD dwErr = NO_ERROR, i;
    
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize the port list
    //
    ZeroMemory (pList, sizeof(RASSRV_PORT_LIST));
    pList->dwFmtLen = LoadStringW (
                        Globals.hInstDll, 
                        SID_COMPORT_FORMAT,
                        pList->pszFormat,
                        sizeof(pList->pszFormat) / sizeof(WCHAR));

    do
    {
        // Create the list of com ports
        dwErr = MdmEnumComPorts(devAddPortToList, (HANDLE)pList);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Remove any ports that are currently in use
        if ((dwErr = devFilterPortsInUse (This, pList)) != NO_ERROR)
        {
            break;
        }
        
        // If there aren't any ports, return
        if (pList->dwCount == 0)
        {
            break;
        }

        // Resize the list of ports to include the com ports
        ppDevices = RassrvAlloc(
                        sizeof(RASSRV_DEVICE*) * 
                         (This->dwDeviceCount + pList->dwCount),
                        TRUE);
        if (ppDevices == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy over the current device information
        CopyMemory( 
            ppDevices, 
            This->pDeviceList, 
            This->dwDeviceCount * sizeof(RASSRV_DEVICE*));

        // Delete the old device list and set to the new one
        RassrvFree(This->pDeviceList);
        This->pDeviceList = ppDevices;

        // Add the ports
        pNode = pList->pHead;
        i = This->dwDeviceCount;
        while (pNode) 
        {
            // Allocate the new device
            ppDevices[i] = RassrvAlloc(sizeof(RASSRV_DEVICE), TRUE);
            if (!ppDevices[i]) 
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }            
            
            // Set all the non-zero values
            ppDevices[i]->dwType    = INCOMING_TYPE_DIRECT;
            ppDevices[i]->pszName   = pNode->pszName;
            ppDevices[i]->pModem    = pNode->pModem;
            ppDevices[i]->dwFlags   = DEV_FLAG_PORT;
            lstrcpynW(
                ppDevices[i]->pszPort, 
                pNode->pszPort,
                sizeof(ppDevices[i]->pszPort) / sizeof(WCHAR));

            // Initialize the enabling of the com port
            if (ppDevices[i]->pModem) 
            {
                ppDevices[i]->dwFlags |= 
                    (ppDevices[i]->pModem->dwFlags & DEV_FLAG_ENABLED);
            }

            // Increment
            i++;
            pNode = pNode->pNext;
        }
        
        This->dwDeviceCount = i;
        
    } while (FALSE);

    // Cleanup
    {
        devCleanupPortList(pList);
    }

    return dwErr;
}

//
// Returns whether the given index lies within the bounds of the
// list of devices store in This.
//
BOOL 
devBoundsCheck(
    IN RASSRV_DEVICEDB * This, 
    IN DWORD dwIndex) 
{
    if (This->dwDeviceCount <= dwIndex) 
    {
        DbgOutputTrace("devBoundsCheck: failed for index %d", dwIndex);
        return FALSE;
    }
    
    return TRUE;
}

// Gets a handle to a device to be displayed in the general tab
DWORD devGetDeviceHandle(
        IN  HANDLE hDevDatabase, 
        IN  DWORD dwIndex, 
        OUT HANDLE * hDevice) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    if (!This || !hDevice)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!devBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // Return nothing if device is filtered
    if (This->pDeviceList[dwIndex]->dwFlags & DEV_FLAG_FILTERED) 
    {
        *hDevice = NULL;
        return ERROR_DEVICE_NOT_AVAILABLE;
    }

    // Otherwise, return the device
    else  
    {
        *hDevice = (HANDLE)(This->pDeviceList[dwIndex]);
    }
   
    return NO_ERROR;
}

//
// Returns a count of devices to be displayed in the general tab
//
DWORD devGetDeviceCount(
        IN  HANDLE hDevDatabase, 
        OUT LPDWORD lpdwCount) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    if (!This || !lpdwCount)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwCount = This->dwDeviceCount;
    
    return NO_ERROR;
}

//
// Returns the count of enabled devices
//
DWORD devGetEndpointEnableCount(
        IN  HANDLE hDevDatabase, 
        OUT LPDWORD lpdwCount) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    DWORD i;
    
    if (!This || !lpdwCount)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwCount = 0;

    for (i = 0; i < This->dwDeviceCount; i++) 
    {
        if (This->pDeviceList[i]->dwFlags & DEV_FLAG_ENABLED)
        {
            (*lpdwCount) += This->pDeviceList[i]->dwEndpoints;
        }
    }
    
    return NO_ERROR;
}

//
// Loads the vpn enable status
//
DWORD 
devGetVpnEnable(
    IN HANDLE hDevDatabase, 
    IN BOOL * pbEnabled) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;

    if (!This || !pbEnabled)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pbEnabled = This->bVpnEnabled;
    
    return NO_ERROR;
}

//
// Saves the vpn enable status
//
DWORD 
devSetVpnEnable(
    IN HANDLE hDevDatabase, 
    IN BOOL bEnable) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;

    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }        
    
    This->bVpnEnabled = bEnable;
    
    return NO_ERROR;
}

// Saves the vpn Original value enable status
//
DWORD 
devSetVpnOrigEnable(
    IN HANDLE hDevDatabase, 
    IN BOOL bEnable) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;

    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }        
    
    This->bVpnEnabledOrig = bEnable;
    
    return NO_ERROR;
}

//
// Returns a pointer to the name of a device
//
DWORD 
devGetDeviceName(
    IN  HANDLE hDevice, 
    OUT PWCHAR * pszDeviceName) 
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This || !pszDeviceName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pszDeviceName = This->pszName;

    return NO_ERROR;
}

//
// Returns the type of a device
//
DWORD 
devGetDeviceType(
    IN  HANDLE hDevice, 
    OUT LPDWORD lpdwType) 
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This || !lpdwType)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwType = This->dwType;

    return NO_ERROR;
}

//
// Returns an identifier of the device that can be used in 
// tapi calls.
//
DWORD 
devGetDeviceId(
    IN  HANDLE hDevice, 
    OUT LPDWORD lpdwId) 
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This || !lpdwId)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwId = This->dwId;

    //
    // If this is a com port referencing a null modem,
    // then return the tapi id of the null modem
    //
    if ((This->dwFlags & DEV_FLAG_PORT) && (This->pModem))
    {
        *lpdwId = This->pModem->dwId;
    }

    return NO_ERROR;
}

//
// Returns the enable status of a device for dialin
//
DWORD 
devGetDeviceEnable(
    IN  HANDLE hDevice, 
    OUT BOOL * pbEnabled) 
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This || !pbEnabled)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pbEnabled = !!(This->dwFlags & DEV_FLAG_ENABLED);

    return NO_ERROR;
}

//
// Sets the enable status of a device for dialin
//
DWORD 
devSetDeviceEnable(
    IN HANDLE hDevice, 
    IN BOOL bEnable) 
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Mark the enabling and mark the device as dirty
    if (bEnable)
    {
        This->dwFlags |= DEV_FLAG_ENABLED;
    }
    else
    {
        This->dwFlags &= ~DEV_FLAG_ENABLED;
    }
        
    This->dwFlags |= DEV_FLAG_DIRTY;

    return NO_ERROR;
}

//
// Returns whether the given device is a com port as added
// by devAddComPorts
//
DWORD 
devDeviceIsComPort(
    IN  HANDLE hDevice, 
    OUT PBOOL pbIsComPort)
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // This is a com port if it was added by 
    // devAddComPorts and if it has no null
    // modem associated with it.
    //
    if ((This->dwFlags & DEV_FLAG_PORT) &&
        (This->pModem == NULL)
       )
    {
        *pbIsComPort = TRUE;
    }
    else
    {
        *pbIsComPort = FALSE;
    }
        
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\error.h ===
/*
	File    error.h

    Defines the error display/handling mechanisms used by the Ras Server
    UI for connections.

    10/20/97
*/

#ifndef _rassrvui_error_h
#define _rassrvui_error_h

#include <windows.h>


// Displays the error for the given catagory, subcatagory,  and code.  The 
// parameters define what error messages are loaded from the resources
// of this project.
DWORD ErrDisplayError (HWND hwndParent, 
                       DWORD dwErrCode, 
                       DWORD dwCatagory, 
                       DWORD dwSubCatagory, 
                       DWORD dwData);

// Sends debug output to a debugger terminal
DWORD ErrOutputDebugger (LPSTR szError);

// Sends trace information out
DWORD DbgOutputTrace (LPSTR pszTrace, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\error.c ===
/*
	File    error.h

    Implements the error display/handling mechanisms used by the Ras Server
    UI for connections.

    10/20/97
*/

#include "rassrv.h"

// Sends trace information
DWORD DbgOutputTrace (LPSTR pszTrace, ...) {
    va_list arglist;
    char szBuffer[1024], szTemp[1024];

    va_start(arglist, pszTrace); 
    vsprintf(szTemp, pszTrace, arglist);
    va_end(arglist);

    sprintf(szBuffer, "RasSrvUi: %s", szTemp);

    TRACE(szBuffer);
    ErrOutputDebugger(szBuffer);

    return NO_ERROR;
}

// Sends debug output to a debugger terminal
DWORD ErrOutputDebugger (LPSTR szError) {
#if DBG
    OutputDebugStringA(szError);
    OutputDebugStringA("\n");
#endif    

    return NO_ERROR;
}


// Sets error information for the user tab catagory
DWORD ErrUserCatagory(DWORD dwSubCatagory, DWORD dwErrCode, DWORD dwData) {
    return dwErrCode;
}


// Displays the error for the given catagory, subcatagory,  and code.  The 
// parameters define what error messages are loaded from the resources
// of this project.
DWORD ErrDisplayError (HWND hwndParent, 
                       DWORD dwErrCode, 
                       DWORD dwCatagory, 
                       DWORD dwSubCatagory, 
                       DWORD dwData) {

    BOOL bDisplay = TRUE;
    DWORD dwMessage, dwTitle;
    PWCHAR pszMessage, pszTitle;

    switch (dwCatagory) {
        case ERR_QUEUE_CATAGORY:
        case ERR_GLOBAL_CATAGORY:
        case ERR_RASSRV_CATAGORY:
        case ERR_MULTILINK_CATAGORY:
        case ERR_GENERIC_CATAGORY:
        case ERR_GENERALTAB_CATAGORY:
        case ERR_ADVANCEDTAB_CATAGORY:
        case ERR_IPXPROP_CATAGORY:
        case ERR_TCPIPPROP_CATAGORY:
            dwMessage = dwErrCode; 
            break;

        case ERR_USERTAB_CATAGORY:
            dwMessage = ErrUserCatagory(dwSubCatagory, dwErrCode, dwData);
            break;
    }

    if (bDisplay) {
        dwTitle = dwCatagory;
        pszMessage = (PWCHAR) PszLoadString(Globals.hInstDll, dwMessage);
        pszTitle = (PWCHAR) PszLoadString(Globals.hInstDll, dwTitle);
        MessageBoxW(hwndParent, 
                    pszMessage, 
                    pszTitle, 
                    MB_OK | MB_ICONERROR | MB_APPLMODAL);

    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\devicedb.h ===
/*
    File    devicedb.h

    Definition of the device database for the ras dialup server.

    Paul Mayfield, 10/2/97
*/

#ifndef __rassrvui_devicedb_h
#define __rassrvui_devicedb_h

#include <windows.h>

// ===================================
// Types of incoming connections
// ===================================
#define INCOMING_TYPE_PHONE 0                
#define INCOMING_TYPE_DIRECT 1
#define INCOMING_TYPE_VPN 4
#define INCOMING_TYPE_ISDN 8

// =====================================
// Device database functions
// =====================================

//
// Opens a handle to the database of devices
//
DWORD 
devOpenDatabase(
    OUT HANDLE * hDevDatabase);

//
// Closes the general database and flushes any changes 
// to the system when bFlush is TRUE
//
DWORD 
devCloseDatabase(
    IN HANDLE hDevDatabase);

//
// Commits any changes made to the general tab values 
//
DWORD 
devFlushDatabase(
    IN HANDLE hDevDatabase);

//
// Rollsback any changes made to the general tab values
//
DWORD 
devRollbackDatabase(
    IN HANDLE hDevDatabase);

//
// Reloads any values for the general tab from disk
//
DWORD 
devReloadDatabase(
    IN HANDLE hDevDatabase);

//
// Adds all com ports as devices.  If a com port gets
// enabled (devSetDeviceEnable), then it will have a 
// null modem installed over it.
//
DWORD 
devAddComPorts(
    IN HANDLE hDevDatabase);

//
// Filters out all devices in the database except those that
// meet the given type description (can be ||'d).
//
DWORD 
devFilterDevices(
    IN HANDLE hDevDatabase, 
    IN DWORD dwType);

//
// Gets a handle to a device to be displayed in the general tab
//
DWORD 
devGetDeviceHandle(
    IN  HANDLE hDevDatabase, 
    IN  DWORD dwIndex, 
    OUT HANDLE * hDevice);

//
// Returns a count of devices to be displayed in the general tab
//
DWORD 
devGetDeviceCount(
    IN  HANDLE hDevDatabase, 
    OUT LPDWORD lpdwCount);

//
// Loads the vpn enable status
//
DWORD 
devGetVpnEnable(
    IN  HANDLE hDevDatabase, 
    OUT BOOL * pbEnabled);

//
// Saves the vpn enable status
//
DWORD 
devSetVpnEnable(
    IN HANDLE hDevDatabase, 
    IN BOOL bEnable);

// Saves the vpn Original value enable status
//
DWORD 
devSetVpnOrigEnable(
    IN HANDLE hDevDatabase, 
    IN BOOL bEnable);

//
// Returns the count of enabled endpoints accross all devices
//
DWORD 
devGetEndpointEnableCount(
    IN  HANDLE hDevDatabase, 
    OUT LPDWORD lpdwCount);

//
// Returns a pointer to the name of a device
//
DWORD 
devGetDeviceName(
    IN  HANDLE hDevice, 
    OUT PWCHAR * pszDeviceName);

//
// Returns the type of a device
//
DWORD 
devGetDeviceType(
    IN  HANDLE hDevice, 
    OUT LPDWORD lpdwType);

//
// Returns an identifier of the device that can be used in conjunction 
// with tapi calls.
//
DWORD 
devGetDeviceId(
    IN  HANDLE hDevice, 
    OUT LPDWORD lpdwId);

//
// Returns the enable status of a device for dialin
//
DWORD 
devGetDeviceEnable(
    IN  HANDLE hDevice, 
    OUT BOOL * pbEnabled);

//
// Sets the enable status of a device for dialin
//
DWORD 
devSetDeviceEnable(
    IN HANDLE hDevice, 
    IN BOOL bEnable);

//
// Returns whether the given device is a com port as added
// by devAddComPorts
//
DWORD 
devDeviceIsComPort(
    IN  HANDLE hDevice, 
    OUT PBOOL pbIsComPort);

BOOL
devIsVpnEnableChanged(
    IN HANDLE hDevDatabase) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\gentab.c ===
/*
    File    gentab.c

    Implements the ui behind the general tab for the 
    connections dialup server ui.

    Paul Mayfield, 10/2/97
*/

#include "rassrv.h"
#include <tapi.h>

// Help maps
static const DWORD phmGenTab[] =
{
    CID_GenTab_LV_Devices,          IDH_GenTab_LV_Devices,
    CID_GenTab_CB_Multilink,        IDH_GenTab_CB_Multilink,
    CID_GenTab_PB_Properties,       IDH_GenTab_PB_Properties,
    CID_GenTab_CB_Vpn,              IDH_GenTab_CB_Vpn,
    CID_GenTab_CB_ShowIcons,        IDH_GenTab_CB_ShowIcons,
    0,                              0
};

// Fills in the property sheet structure with the information 
// required to display the general tab.
//
DWORD 
GenTabGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_GenTab);
    ppage->pfnDlgProc  = GenTabDialogProc;
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USECALLBACK;

    return NO_ERROR;
}

// Error reporting
//
VOID
GenTabDisplayError(
    IN HWND hwnd, 
    IN DWORD dwErr) 
{
    ErrDisplayError(
        hwnd, 
        dwErr, 
        ERR_GENERALTAB_CATAGORY, 
        0, 
        Globals.dwErrorData);
}

//
// Returns the index of an to display icon based on the type of incoming
// connection and whether or not it should be checked.
//
INT 
GenTabGetIconIndex(
    IN DWORD dwType, 
    IN BOOL bEnabled) 
{
    if (dwType == INCOMING_TYPE_PHONE)
    {
        return DI_Phone;
    }
    else
    {
        return DI_Direct;
    }
}

//
// Fills in the device list with the list of the devices stored in the 
// device database.  Also, initializes the checked/unchecked status
// of each device.
//
DWORD 
GenTabFillDeviceList(
    IN HWND hwndDlg, 
    IN HWND hwndLV, 
    IN HANDLE hDevDatabase) 
{
    LV_ITEM lvi;
    LV_COLUMN lvc;
    DWORD dwCount, i, dwErr, dwType;
    HANDLE hDevice;
    PWCHAR pszName;
    char pszAName[1024];
    BOOL bEnabled;

    // Get the count of all the users
    dwErr = devGetDeviceCount(hDevDatabase, &dwCount);
    if (dwErr != NO_ERROR) 
    {
        GenTabDisplayError(hwndLV, ERR_DEVICE_DATABASE_CORRUPT);
        return dwErr;
    }

    // Initialize the list item
    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;

    // If there are devices to display then populate the list box
    // with them
    if (dwCount > 0) 
    {
        ListView_SetDeviceImageList(hwndLV, Globals.hInstDll);

        // Looop through all of the devices adding them to the list
        for (i=0; i<dwCount; i++) 
        {
            dwErr = devGetDeviceHandle(hDevDatabase, i, &hDevice);
            if (dwErr == NO_ERROR) 
            {
                devGetDeviceName (hDevice, &pszName);
                devGetDeviceEnable (hDevice, &bEnabled);
                devGetDeviceType (hDevice, &dwType);
                lvi.iImage = GenTabGetIconIndex(dwType, bEnabled);
                lvi.iItem = i;
                lvi.pszText = pszName;
                lvi.cchTextMax = wcslen(pszName)+1;
                ListView_InsertItem(hwndLV,&lvi);
                ListView_SetCheck(hwndLV, i, bEnabled);
            }
        }

        // Select the first item in the list view if any items exist
        //
        ListView_SetItemState(
            hwndLV, 
            0, 
            LVIS_SELECTED | LVIS_FOCUSED, 
            LVIS_SELECTED | LVIS_FOCUSED);

        // Initialize the alignment of the text that gets displayed
        lvc.mask = LVCF_FMT;
        lvc.fmt = LVCFMT_LEFT;
    }

    // If there are no devices then we display a message in the big
    // white box explaining that we have no devices to show.
    else 
    {
        PWCHAR pszLine1, pszLine2;
        HWND hwndGenTab = NULL;

        pszLine1 = (PWCHAR) 
            PszLoadString(Globals.hInstDll, SID_NO_DEVICES1);
            
        pszLine2 = (PWCHAR) 
            PszLoadString(Globals.hInstDll, SID_NO_DEVICES2);
            
        lvi.mask = LVIF_TEXT;

        lvi.iItem = 0;
        lvi.pszText = pszLine1;
        lvi.cchTextMax = wcslen(pszLine1);
        ListView_InsertItem(hwndLV, &lvi);
        
        lvi.iItem = 1;
        lvi.pszText = pszLine2;
        lvi.cchTextMax = wcslen(pszLine2);
        ListView_InsertItem(hwndLV, &lvi);

        // Initialize the alignment of the text that gets displayed
        lvc.mask = LVCF_FMT;
        lvc.fmt = LVCFMT_CENTER;

        // Disable the list view
        EnableWindow(hwndLV, FALSE);

        // Disable the properties button while you're at it
        hwndGenTab = GetDlgItem(hwndDlg, CID_GenTab_PB_Properties);
        if (NULL != hwndGenTab)
        {
            EnableWindow(hwndGenTab, FALSE);
        }
    }
    
    // Add a colum so that we'll display in report view
    ListView_InsertColumn(hwndLV, 0, &lvc);
    ListView_SetColumnWidth(hwndLV, 0, LVSCW_AUTOSIZE_USEHEADER);
    
    return NO_ERROR;
}

//
// This function causes the multilink check box behave in a way that 
// allows the user to see how multilink works.
//
DWORD 
GenTabAdjustMultilinkAppearance(
    IN HWND hwndDlg, 
    IN HANDLE hDevDatabase, 
    IN HANDLE hMiscDatabase) 
{
    DWORD dwErr = NO_ERROR, i, dwEndpointsEnabled;
    HWND hwndML = GetDlgItem(hwndDlg, CID_GenTab_CB_Multilink);
    BOOL bDisable, bUncheck, bFlag = FALSE, bIsServer;

    do
    {
        // Initialize default behavior in case of an error
        //
        bDisable = TRUE;
        bUncheck = FALSE;
    
        // Find out how many endpoints are enabled for inbound calls
        //
        dwErr = devGetEndpointEnableCount(
                    hDevDatabase, 
                    &dwEndpointsEnabled);
        if (dwErr != NO_ERROR)
        {
            break;
        }
    
        // If multiple devices are not enabled for inbound calls then
        // multilink is meaningless.  Disable the multilink control and 
        // uncheck it.
        //
        if (dwEndpointsEnabled < 2) 
        {
            bUncheck = TRUE;
            bDisable = TRUE;
            dwErr = NO_ERROR;
            break;
        }
    
        // The multilink check only makes sense on NT Server.  This is 
        // based on the following assumptions
        //   1. You only disable multilink so that you can free lines 
        //      for additional callers.
        //   2. PPP will enforce that you only have one caller over 
        //      modem device on nt wks anyway.
        //
        miscGetProductType(hMiscDatabase, &bIsServer);
        if (! bIsServer) 
        {
            bDisable = TRUE;
            bUncheck = FALSE;
            dwErr = NO_ERROR;
            break;
        }

        // Otherwise, multilink makes sense.  Enable the multilink 
        // control and set its check according to what the system says
        bDisable = FALSE;
        bUncheck = FALSE;
        dwErr = miscGetMultilinkEnable(hMiscDatabase, &bFlag);
        if (dwErr != NO_ERROR) 
        {
            GenTabDisplayError(hwndDlg, ERR_DEVICE_DATABASE_CORRUPT);
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (hwndML)
        {
            EnableWindow(hwndML, !bDisable);
        
            if (bUncheck)
            {
                SendMessage(
                    hwndML, 
                    BM_SETCHECK, 
                    BST_UNCHECKED, 
                    0);
            }
            else
            {
                SendMessage(
                    hwndML, 
                    BM_SETCHECK, 
                    (bFlag) ? BST_CHECKED : BST_UNCHECKED, 
                    0);
            }
        }
    }

    return dwErr;
}

//
// Initializes the general tab.  By now a handle to the general 
// database has been placed in the user data of the dialog
//
DWORD 
GenTabInitializeDialog(
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    DWORD dwErr, dwCount;
    BOOL bFlag, bIsServer = FALSE;
    HWND hwndVPN = NULL;
    HWND hwndShowIcons = NULL;
    HANDLE hDevDatabase = NULL, hMiscDatabase = NULL;
    HWND hwndLV = GetDlgItem(hwndDlg, CID_GenTab_LV_Devices);

    // Get handles to the databases we're interested in
    //
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_DEVICE_DATABASE, 
        &hDevDatabase);
        
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_MISC_DATABASE, 
        &hMiscDatabase);

    // Set the logging level
    //
    miscSetRasLogLevel(hMiscDatabase, MISCDB_RAS_LEVEL_ERR_AND_WARN);

    // Fill in the list view will all available devices
    //
    if (hwndLV) ListView_InstallChecks(hwndLV, Globals.hInstDll);
    GenTabFillDeviceList(hwndDlg, hwndLV, hDevDatabase);

    // Adjust the multilink control
    //
    miscGetProductType(hMiscDatabase, &bIsServer);
    if (bIsServer)
    {
        GenTabAdjustMultilinkAppearance(
            hwndDlg, 
            hDevDatabase, 
            hMiscDatabase);
    }
    else
    {
        HWND hwndMultiLink = GetDlgItem(hwndDlg, CID_GenTab_CB_Multilink);
        if (hwndMultiLink)
        {
            ShowWindow(hwndMultiLink, SW_HIDE);
        }
    }

    // Initialize the vpn check
    //
    dwErr = devGetVpnEnable(hDevDatabase, &bFlag);
    if (dwErr != NO_ERROR) 
    {
        GenTabDisplayError(hwndDlg, ERR_DEVICE_DATABASE_CORRUPT);
        return dwErr;
    }
    
    hwndVPN = GetDlgItem(hwndDlg,  CID_GenTab_CB_Vpn);
    if (hwndVPN)
    {
        SendMessage(hwndVPN, 
            BM_SETCHECK,
            (bFlag) ? BST_CHECKED : BST_UNCHECKED,
            0);
    }

    // Initialize the show icons check
    //
    dwErr = miscGetIconEnable(hMiscDatabase, &bFlag);
    if (dwErr != NO_ERROR) 
    {
        GenTabDisplayError(hwndDlg, ERR_DEVICE_DATABASE_CORRUPT);
        return dwErr;
    }
    
    hwndShowIcons = GetDlgItem(hwndDlg, CID_GenTab_CB_ShowIcons);
    if (hwndShowIcons)
    {
        SendMessage(hwndShowIcons, 
            BM_SETCHECK,
            (bFlag) ? BST_CHECKED : BST_UNCHECKED,
            0);
    }

    //
    //for bug 154607 whistler, Enable/Disable Show Icon on taskbar 
    //check box according to Policy
    //
    {
        BOOL fShowStatistics = TRUE;
        HRESULT hr;
        INetConnectionUiUtilities * pNetConUtilities = NULL;        

        hr = HrCreateNetConnectionUtilities(&pNetConUtilities);
        if ( SUCCEEDED(hr))
        {
            fShowStatistics =
            INetConnectionUiUtilities_UserHasPermission(
                        pNetConUtilities, NCPERM_Statistics);

            EnableWindow( GetDlgItem(hwndDlg, CID_GenTab_CB_ShowIcons), fShowStatistics );
            INetConnectionUiUtilities_Release(pNetConUtilities);
        }
    }

    return NO_ERROR;
}

//
// Deals with changes in the check of a device
//
DWORD 
GenTabHandleDeviceCheck(
    IN HWND hwndDlg, 
    IN INT iItem) 
{
    HANDLE hDevDatabase = NULL, hMiscDatabase = NULL, hDevice = NULL;
    DWORD dwErr;
    HWND hwndLVDevices;
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);
    RasSrvGetDatabaseHandle(hwndDlg, ID_MISC_DATABASE, &hMiscDatabase);

    hwndLVDevices = GetDlgItem(hwndDlg, CID_GenTab_LV_Devices);
    // Set the enabling of the given device
    dwErr = devGetDeviceHandle(hDevDatabase, (DWORD)iItem, &hDevice);
    if ((NO_ERROR == dwErr) && hwndLVDevices)
    {
        // Set the device
        devSetDeviceEnable(
            hDevice, 
            ListView_GetCheck(hwndLVDevices, 
            iItem));
        
        // Update the multilink check
        GenTabAdjustMultilinkAppearance(
            hwndDlg, 
            hDevDatabase, 
            hMiscDatabase);
    }
    
    return NO_ERROR;
}

//
// Go through the list view and get the device enablings and 
// commit them to the database.
//
DWORD 
GenTabCommitDeviceSettings(
    IN HWND hwndLV, 
    IN HANDLE hDevDatabase) 
{
    return NO_ERROR;
}

//
// Processes the activation of the general tab.  Return TRUE to 
// report that the message has been handled.
//
BOOL 
GenTabSetActive (
    IN HWND hwndDlg) 
{
    HANDLE hDevDatabase = NULL;
    DWORD dwErr, dwCount, dwId;

    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);

    // Find out if we're the device page in the incoming wizard.
    dwErr = RasSrvGetPageId (hwndDlg, &dwId);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }
        
    if (dwId == RASSRVUI_DEVICE_WIZ_TAB) 
    {
        // Find out if there are any devices to show
        RasSrvGetDatabaseHandle(
            hwndDlg, 
            ID_DEVICE_DATABASE, 
            &hDevDatabase);
            
        dwErr = devGetDeviceCount (hDevDatabase, &dwCount);

        // If there are no devices or if there's a database problem,
        // don't allow this page to be activated.
        if ((dwErr != NO_ERROR) || (dwCount == 0))
        {
            SetWindowLongPtr (hwndDlg, DWLP_MSGRESULT, (LONG_PTR)-1);
        }
    }
    
    PropSheet_SetWizButtons(
        GetParent(hwndDlg), 
        PSWIZB_NEXT | PSWIZB_BACK);

    return TRUE;
}    

//
// Displays properties for the given device
//
DWORD 
GenTabRaiseProperties (
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    HANDLE hDevDatabase = NULL, hDevice = NULL;
    DWORD dwId, dwErr;

    // Get the device id 
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_DEVICE_DATABASE, 
        &hDevDatabase);

    dwErr = devGetDeviceHandle(hDevDatabase, dwIndex, &hDevice);
    if (dwErr != NO_ERROR)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    if (devGetDeviceId(hDevice, &dwId) != NO_ERROR)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    // Launch the device properties dialog
    dwErr = lineConfigDialogW(dwId, hwndDlg, NULL);
    if (dwErr == LINEERR_OPERATIONUNAVAIL)
    {
        GenTabDisplayError(hwndDlg, ERR_DEVICE_HAS_NO_CONFIG);
        dwErr = NO_ERROR;
    }
    
    return dwErr;
}

//
// WM_COMMAND handler 
//
DWORD
GenTabCommand(
    IN HWND hwndDlg,
    IN WPARAM wParam)
{
    HANDLE hMiscDatabase = NULL, hDevDatabase = NULL;
    
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_MISC_DATABASE, 
        &hMiscDatabase);
        
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_DEVICE_DATABASE, 
        &hDevDatabase);

    switch (wParam) 
    {
        case CID_GenTab_CB_Multilink:
            miscSetMultilinkEnable(
                hMiscDatabase,
                (BOOL)SendDlgItemMessage(
                            hwndDlg,
                            CID_GenTab_CB_Multilink,
                            BM_GETCHECK,
                            0,
                            0));
            break;
            
        case  CID_GenTab_CB_Vpn:
            devSetVpnEnable(
                hDevDatabase,
                (BOOL)SendDlgItemMessage(
                        hwndDlg, 
                        CID_GenTab_CB_Vpn,
                        BM_GETCHECK,
                        0,
                        0));
            break;
            
        case CID_GenTab_CB_ShowIcons:
            miscSetIconEnable(
                hMiscDatabase,
                (BOOL)SendDlgItemMessage(
                        hwndDlg,
                        CID_GenTab_CB_ShowIcons,
                        BM_GETCHECK,
                        0,
                        0));
            break;
        case CID_GenTab_PB_Properties:
            {
                HWND hwndLVDevices = GetDlgItem(hwndDlg, CID_GenTab_LV_Devices);
                if (hwndLVDevices)
                {
                    GenTabRaiseProperties (
                        hwndDlg, 
                        ListView_GetSelectionMark(hwndLVDevices));
                }
                break;
            }
    }

    return NO_ERROR;
}

//
// This is the dialog procedure that responds to messages sent 
// to the general tab.
//
INT_PTR 
CALLBACK 
GenTabDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam) 
{
    // Filter the customized list view messages
    if (ListView_OwnerHandler(
            hwndDlg, 
            uMsg, 
            wParam, 
            lParam, 
            LvDrawInfoCallback )
        )
    {        
        return TRUE;
    }

    // Filter the customized ras server ui page messages. By 
    // filtering messages through here, we are able to call 
    // RasSrvGetDatabaseHandle below
    //
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
    {
        return TRUE;
    }

    // Process other messages as normal
    switch (uMsg) 
    {
        case WM_INITDIALOG:
            return FALSE;
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmGenTab);
            break;

        case WM_NOTIFY:
            {
                NM_LISTVIEW* pLvNotifyData;
                NMHDR* pNotifyData = (NMHDR*)lParam;
                switch (pNotifyData->code) {
                    //
                    // Note: PSN_APPLY and PSN_CANCEL are handled 
                    // by RasSrvMessageFilter
                    //
                    case PSN_SETACTIVE:
                        // Initailize the dialog if it isn't already
                        //
                        if (! GetWindowLongPtr(hwndDlg, GWLP_USERDATA))
                        {
                            GenTabInitializeDialog(hwndDlg, wParam, lParam);
                            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)1);
                        }
                        if (GenTabSetActive (hwndDlg))
                            return TRUE;
                        break;

                    // The check of an item is changing
                    case LVXN_SETCHECK:
                        pLvNotifyData = (NM_LISTVIEW*)lParam;
                        GenTabHandleDeviceCheck(
                            hwndDlg, 
                            pLvNotifyData->iItem);
                        break;

                    case LVXN_DBLCLK:
                        pLvNotifyData = (NM_LISTVIEW*)lParam;
                        GenTabRaiseProperties(
                            hwndDlg, 
                            pLvNotifyData->iItem);
                        break;
                }
            }
            break;

        case WM_COMMAND:
            GenTabCommand(hwndDlg, wParam);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\gentab.h ===
/*
    File    gentab.h

    Definitions needed to display the dialup server ui general tab.

    Paul Mayfield, 10/10/97
*/

#ifndef __gentab_h
#define __gentab_h

// Fills a LPPROPSHEETPAGE structure with the information
// needed to display the general tab. dwUserData is ignored.
DWORD GenTabGetPropertyPage(LPPROPSHEETPAGE lpPage, LPARAM lpUserData);    

// This dialog procedure responds to messages sent to the 
// general tab.
INT_PTR CALLBACK GenTabDialogProc(HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rasscrpt\script.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    script.c
//
// History:
//  Abolade-Gbadegesin  03-29-96    Created.
//
// This file contains functions implementing the NT port
// of Win9x dial-up scripting, listed in alphabetical order.
//
// See scriptp.h for details on the NT implementation.
//============================================================================


#include <scriptp.h>
#include <lmwksta.h>        // For NetWkstaUserGetInfo
#include <lmapibuf.h>       // For NetApiBufferFree


//
// Handle of module-instance for this DLL
//
HANDLE              g_hinst;
//
// global critical section used to synhronize access to IP address strings
//
CRITICAL_SECTION    g_cs;
//
// name of file to which script syntax errors are logged
//
CHAR                c_szScriptLog[] = RASSCRIPT_LOG;
//
// event handle which would be notified in case of IPAddress Change
//
HANDLE                          hIpAddressSet = INVALID_HANDLE_VALUE;

#define NET_SVCS_GROUP      "-k netsvcs"

//----------------------------------------------------------------------------
// Function:    DLLMAIN
//
// DLL entry-point for RASSCRIPT
//----------------------------------------------------------------------------

BOOL
WINAPI
RasScriptDllMain(
    IN      HINSTANCE   hinstance,
    IN      DWORD       dwReason,
    IN      PVOID       pUnused
    ) {

    BOOL bRetVal = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH) {

        g_hinst = (HANDLE)hinstance;

        try 
        {
            InitializeCriticalSection(&g_cs);
        }
        except (EXCEPTION_EXECUTE_HANDLER) 
        {
            bRetVal = FALSE;
        }
    }
    else
    if (dwReason == DLL_PROCESS_DETACH) {

        DeleteCriticalSection(&g_cs);
    }

    return bRetVal;
}




//----------------------------------------------------------------------------
// Function:    RasScriptExecute
//
// Examines the given connection, and if there is a script for the connection,
// executes the script to completion.
// Returns the error code from script processing if a script is given,
// and returns NO_ERROR otherwise.
//----------------------------------------------------------------------------

DWORD
APIENTRY
RasScriptExecute(
    IN      HRASCONN        hrasconn,
    IN      PBENTRY*        pEntry,
    IN      CHAR*           pszUserName,
    IN      CHAR*           pszPassword,
    OUT     CHAR*           pszIpAddress
    ) {


    DWORD dwErr;
    HANDLE hevent = NULL, hscript = NULL;
    HANDLE hEvents[2];

    RASSCRPT_TRACE("RasScriptExecute");

    do {
        //
        // create event on which to receive notification
        //

        hevent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!hevent) {
            dwErr = GetLastError();
            RASSCRPT_TRACE1("error %d creating event", dwErr);
            break;
        }


                // Create a separate event for SCRIPTCODE_IpAddressSet
                // event. We hit a timing window ow where we lose this
                // event (when we get a script complete event immediately
                // after a SCRIPTCODE_IpAddressSet event. bug 75226.
                hIpAddressSet = CreateEvent (NULL, FALSE, FALSE, NULL);

                if (!hIpAddressSet) {

                    dwErr = GetLastError();
                    RASSCRPT_TRACE1("error %d creating event", dwErr);
                    break;

                }


        //
        // initialize script processing
        //

        dwErr = RasScriptInit(
                    hrasconn, pEntry, pszUserName, pszPassword, 0, hevent,
                    &hscript
                    );

        if (dwErr != NO_ERROR) {
            RASSCRPT_TRACE1("error %d initializing scripting", dwErr);
            break;
        }


        hEvents[0] = hevent;
        hEvents[1] = hIpAddressSet;

        //
        // loop waiting for script to finish running
        //

        for ( ; ; ) {

            dwErr = WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);

            if (dwErr - WAIT_OBJECT_0 == 0) {

                //
                // Retrieve the code for the event which occurred
                //

                DWORD dwCode = RasScriptGetEventCode(hscript);

                RASSCRPT_TRACE1("RasScriptExecute: eventcode %d", dwCode);


                //
                // Handle the event
                //

                if (dwCode == SCRIPTCODE_Done ||
                    dwCode == SCRIPTCODE_Halted ||
                    dwCode == SCRIPTCODE_HaltedOnError) {

                    RASSCRPT_TRACE("script processing completed");

                    dwErr = NO_ERROR;

                    break;
                }
            }

            else
            if (dwErr - WAIT_OBJECT_0 == 1) {

                    //
                    // The IP address has been changed;
                    // read the new IP address into the caller's buffer
                    //

                    RASSCRPT_TRACE("IP address changed");

                    dwErr = RasScriptGetIpAddress(hscript, pszIpAddress);
                    RASSCRPT_TRACE2("RasScriptGetIpAddress(e=%d,a=%s)",dwErr,pszIpAddress);
            }
        }

    } while(FALSE);


    if (hscript) { RasScriptTerm(hscript); }

    if (hevent) { CloseHandle(hevent); }

    if (hIpAddressSet) { CloseHandle (hIpAddressSet); }

    return dwErr;
}





//----------------------------------------------------------------------------
// Function:    RasScriptGetEventCode
//
// This function should be called to retrieve the event-code
// when the scripting thread signals an event.
// The event codes which may be returned are as follows:
//
//  NO_ERROR:                   no code has been set
//  SCRIPTCODE_Done:            the script has finished running;
//                              the thread blocks until RasScriptTerm is called.
//  SCRIPTCODE_InputNotify:     data is available in the buffer; if the buffer
//                              is full, the thread blocks until
//                              RasScriptReceive is called and the data
//                              is read successfully.
//  SCRIPTCODE_KeyboardEnable:  the keyboard should be enabled.
//  SCRIPTCODE_KeyboardDisable: the keyboard should be disabled.
//  SCRIPTCODE_IpAddressSet:    the IP address has changed; the new address
//                              can be retrieved via RasScriptGetIPAddress.
//  SCRIPTCODE_HaltedOnError:   the script has halted due to an error.
//----------------------------------------------------------------------------

DWORD
RasScriptGetEventCode(
    IN      HANDLE      hscript
    ) {

    SCRIPTCB* pscript = (SCRIPTCB *)hscript;

    RASSCRPT_TRACE("RasGetEventCode");

    if (!pscript) { return ERROR_INVALID_PARAMETER; }

    return pscript->dwEventCode;
}




//----------------------------------------------------------------------------
// Function:    RasScriptGetIpAddress
//
// This function retrieves the current IP address as set by the script.
//----------------------------------------------------------------------------

DWORD
RasScriptGetIpAddress(
    IN      HANDLE      hscript,
    OUT     CHAR*       pszIpAddress
    ) {

    SCRIPTCB* pscript = (SCRIPTCB *)hscript;

    RASSCRPT_TRACE("RasGetIpAddress");

    if (!pscript || !pszIpAddress) { return ERROR_INVALID_PARAMETER; }


    //
    // Access to the IP address string must be synchronized
    // since it may also be accessed via RxSetIPAddress
    //

    EnterCriticalSection(&g_cs);

    if (pscript->pszIpAddress) {

        lstrcpy(pszIpAddress, pscript->pszIpAddress);
    }
    else {

        lstrcpy(pszIpAddress, "0.0.0.0");
    }

    LeaveCriticalSection(&g_cs);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    RasScriptInit
//
// Initializes for script processing on the given HRASCONN.
//
// This function creates a thread which handles script input and output
// on the given connection's port.
//
// If there is no script for the connection, this function returns an error
// unless the flag RASSCRIPT_NotifyOnInput is specified, in which case
// the thread loops posting receive-data requests on the connection's port
// until RasScriptTerm is called.
//
// If there is a script for the connection, the thread runs the script
// to completion. If the flag RASSCRIPT_NotifyOnInput is specified,
// the caller is notified when data is received on the port. The caller
// can then retrieve the data by calling RasScriptReceive.
//
// Notification may be event-based or message-based. By default, notification
// is event-based, and "Hnotifier" is treated as an event-handle.
// The event is signalled to by the scripting thread, and the caller retrieves
// the event code by calling RasScriptGetEventCode.
//
// Setting the flag RASSCRIPT_HwndNotify selects message-based notification,
// and indicates that "Hnotifier" is an HWND. The WM_RASSCRIPT event is sent
// to the window by the scripting thread, and "LParam" in the message sent
// contains the event code. See RasScriptGetEventCode for descriptions
// of the codes sent by the scripting thread.
//----------------------------------------------------------------------------

DWORD
APIENTRY
RasScriptInit(
    IN      HRASCONN        hrasconn,
    IN      PBENTRY*        pEntry,
    IN      CHAR*           pszUserName,
    IN      CHAR*           pszPassword,
    IN      DWORD           dwFlags,
    IN      HANDLE          hNotifier,
    OUT     HANDLE*         phscript
    ) {

    DWORD dwErr, dwSyntaxError = NO_ERROR;
    static const CHAR szSwitch[] = MXS_SWITCH_TXT;
    SCRIPTCB* pscript = NULL;
#ifdef UNICODEUI
//
// Define structures to use depending on whether or not the RAS UI
// is being built with Unicode.
//
#define PUISTR  CHAR*
#define PUIRCS  RASCONNSTATUSA*
#define PUIRC   RASCREDENTIALSA*
    RASCONNSTATUSW rcs;
    WCHAR* pszSwitch = StrDupWFromA(MXS_SWITCH_TXT);
#else
#define PUISTR  CHAR*
#define PUIRCS  RASCONNSTATUSA*
#define PUIRC   RASCREDENTIALSA*
    RASCONNSTATUSA rcs;
    CHAR* pszSwitch = szSwitch;
#endif

    RASSCRPT_TRACE_INIT("RASSCRPT");
    
    RASSCRPT_TRACE("RasScriptInit");


    //
    // validate arguments
    //

    if (phscript) { *phscript = NULL; }

    if (!hrasconn ||
        !pEntry ||
        !pszUserName ||
        !pszPassword ||
        !hNotifier ||
        !phscript) {

        RASSCRPT_TRACE("RasScriptInit: required parameter not specified");

#ifdef UNICODEUI
        Free(pszSwitch);
#endif
        return ERROR_INVALID_PARAMETER;
    }


    //
    // initialize script processing
    //

    do {

        DWORD dwsize;
        DWORD dwthread;
        HANDLE hthread;


        //
        // Load required DLL function pointers.
        //
        dwErr = LoadRasapi32Dll();
        if (dwErr)
            break;
        dwErr = LoadRasmanDll();
        if (dwErr)
            break;
        //
        // Initialize RAS
        //
        dwErr = g_pRasInitialize();

        if ( dwErr )
            break;

        /*
        //
        // Connect to the local rasman server
        //
        dwErr = g_pRasRpcConnect ( NULL, NULL );

        if (dwErr)
            break; */

        //
        // allocate space for a control block
        //

        pscript = Malloc(sizeof(*pscript));

        if (!pscript) {
            dwErr = GetLastError();
            RASSCRPT_TRACE2("error %d allocating %d bytes", dwErr, sizeof(*pscript));
            break;
        }


        //
        // initialize the control block
        //

        ZeroMemory(pscript, sizeof(*pscript));


        //
        // copy the argument fields
        //

        pscript->hrasconn = hrasconn;
        pscript->pEntry = pEntry;
        pscript->dwFlags = dwFlags;
        pscript->hNotifier = hNotifier;
        pscript->hport = g_pRasGetHport(hrasconn);

        if (pscript->pEntry->pszIpAddress) {

            //
            // Copy the IP address for the entry
            //

            pscript->pszIpAddress =
                    Malloc(lstrlenUI(pscript->pEntry->pszIpAddress) + 1);

            if (pscript->pszIpAddress) {

                StrCpyAFromUI(
                    pscript->pszIpAddress, pscript->pEntry->pszIpAddress
                    );
            }
            else {

                RASSCRPT_TRACE("error copying entry's IP address");

                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                break;
            }
        }


        //
        // Initialize our Win9x-compatible session-config-info structure
        //

        ZeroMemory(&pscript->sci, sizeof(pscript->sci));

        pscript->sci.dwSize = sizeof(pscript->sci);
        StrCpyAFromUI(pscript->sci.szEntryName, pEntry->pszEntryName);
        lstrcpy(pscript->sci.szUserName, pszUserName);
        lstrcpy(pscript->sci.szPassword, pszPassword);


        //
        // See if the user name is missing;
        // if so, read the currently-logged on user's name
        //

        if (!pscript->sci.szUserName[0]) {

            WKSTA_USER_INFO_1* pwkui1 = NULL;

            //
            // Not all params were specified, so read the dial-params
            // for this phonebook entry
            //

            dwErr = NetWkstaUserGetInfo(NULL, 1, (LPBYTE*)&pwkui1);
            RASSCRPT_TRACE2("NetWkstaUserGetInfo(e=%d,u=(%ls))", dwErr,
                   (pwkui1) ? pwkui1->wkui1_username : L"null");

            if (dwErr == NO_ERROR && pwkui1 != NULL) {

                StrCpyAFromUI(pscript->sci.szUserName,
                    (LPCWSTR)pwkui1->wkui1_username);

                NetApiBufferFree(pwkui1);
            }
        }



        //
        // See if there is a script for this connection's state;
        // if there is one then the device-type will be "switch"
        // and the device-name will be the script path
        //

        ZeroMemory(&rcs, sizeof(rcs));

        rcs.dwSize = sizeof(rcs);

        dwErr = g_pRasGetConnectStatus(hrasconn, (PUIRCS)&rcs);

        if (dwErr != NO_ERROR) {
            RASSCRPT_TRACE1("error %d getting connect status", dwErr);
            break;
        }



        //
        // Check the device-type (will be "switch" for scripted entries)
        // and the device name (will be a filename for scripted entries)
        //

        if (lstrcmpiUI(rcs.szDeviceType, pszSwitch) == 0 &&
            GetFileAttributesUI(rcs.szDeviceName) != 0xFFFFFFFF) {

            CHAR szDevice[RAS_MaxDeviceName + 1], *pszDevice = szDevice;

            StrCpyAFromUI(szDevice, rcs.szDeviceName);


            //
            // The device-type is "Switch" and the device-name
            // contains the name of an existing file;
            // initialize the SCRIPTDATA structure.
            //

            dwErr = RsInitData(pscript, pszDevice);


            //
            // If there was a syntax error in the script, we continue
            // with the initialization, but record the error code.
            // on any other error, we immediately terminate initialization.
            //

            if (dwErr == ERROR_SCRIPT_SYNTAX) {
                dwSyntaxError = dwErr;
            }
            else
            if (dwErr != NO_ERROR) { break; }
        }



        //
        // Initialize RASMAN fields, allocating buffers for RASMAN I/O
        //

        dwsize = SIZE_RecvBuffer;
        dwErr = g_pRasGetBuffer(&pscript->pRecvBuffer, &dwsize);
        RASSCRPT_TRACE2("RasGetBuffer:e=%d,s=%d", dwErr, dwsize);

        if (dwErr != NO_ERROR) {
            RASSCRPT_TRACE1("error %d allocating receive-buffer", dwErr);
            break;
        }

        dwsize = SIZE_SendBuffer;
        dwErr = g_pRasGetBuffer(&pscript->pSendBuffer, &dwsize);
        RASSCRPT_TRACE2("RasGetBuffer:e=%d,s=%d", dwErr, dwsize);

        if (dwErr != NO_ERROR) {
            RASSCRPT_TRACE1("error %d alloacting send-buffer", dwErr);
            break;
        }



        //
        // Create synchronization events used to control the background thread
        //

        pscript->hRecvRequest = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!pscript->hRecvRequest) {
            RASSCRPT_TRACE1("error %d creating receive-event", dwErr = GetLastError());
            break;
        }

        pscript->hRecvComplete = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!pscript->hRecvComplete) {
            RASSCRPT_TRACE1("error %d creating received-event", dwErr = GetLastError());
            break;
        }

        pscript->hStopRequest = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!pscript->hStopRequest) {
            RASSCRPT_TRACE1("error %d creating stop-event", dwErr = GetLastError());
            break;
        }

        pscript->hStopComplete = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!pscript->hStopComplete) {
            RASSCRPT_TRACE1("error %d creating stopped-event", dwErr = GetLastError());
            break;
        }



        //
        // Create the thread which will receive data and process the script
        //

        hthread = CreateThread(
                    NULL, 0, RsThread, (PVOID)pscript, 0, &dwthread
                    );

        if (!hthread) {
            RASSCRPT_TRACE1("error %d creating script-thread", dwErr = GetLastError());
            break;
        }

        CloseHandle(hthread);

        pscript->dwFlags |= RASSCRIPT_ThreadCreated;


        if ((VOID*)pszSwitch != (VOID*)szSwitch) { Free0(pszSwitch); }


        //
        // we've successfully initialized, return control to caller
        //

        *phscript = (HANDLE)pscript;


        //
        // if there was a syntax error in the script, return the special
        // error code (ERROR_SCRIPT_SYNTAX) to indicate the problem;
        // otherwise return  NO_ERROR.
        //

        return (dwSyntaxError ? dwSyntaxError : NO_ERROR);

    } while(FALSE);


    //
    // an error occurred, so do cleanup
    //

    if ((VOID*)pszSwitch != (VOID*)szSwitch) { Free0(pszSwitch); }

    RasScriptTerm((HANDLE)pscript);

    return (dwErr ? dwErr : ERROR_UNKNOWN);
}




//----------------------------------------------------------------------------
// Function:    RasScriptReceive
//
// Called to retrieve the contents of the scripting thread's input buffer.
// When this function completes successfully, if the input buffer was full
// and the scripting thread was blocked, the thread continues executing.
//
// On input, "PdwBufferSize" should contain the size of "PBuffer", unless
// "PBuffer" is NULL, in which case "*PdwBufferSize" is treated as 0.
// On output, "PdwBufferSize" contains the size required to read
// the input buffer, and if the return value is NO_ERROR, then "PBuffer"
// contains the data in the input buffer. If the return value is
// ERROR_INSUFFICIENT_BUFFER, "PBuffer" was not large enough.
//----------------------------------------------------------------------------

DWORD
APIENTRY
RasScriptReceive(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN OUT  DWORD*      pdwBufferSize
    ) {

    SCRIPTCB* pscript = (SCRIPTCB *)hscript;

    RASSCRPT_TRACE("RasScriptReceive");

    //
    // return if the caller didn't request input-notification
    // or if no buffer-size is available
    //

    if (!pscript || !pdwBufferSize ||
        !(pscript->dwFlags & RASSCRIPT_NotifyOnInput)) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // return if no buffer or if buffer too small
    //

    if (!pBuffer || *pdwBufferSize < pscript->dwRecvSize) {
        *pdwBufferSize = pscript->dwRecvSize;
        return ERROR_INSUFFICIENT_BUFFER;
    }


    //
    // copy the data, and notify the thread that the data has been read
    //

    CopyMemory(pBuffer, pscript->pRecvBuffer, pscript->dwRecvSize);

    *pdwBufferSize = pscript->dwRecvSize;

    SetEvent(pscript->hRecvComplete);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    RasScriptSend
//
// This function transmits bytes over the connection's port.
//
// "DwBufferSize" contains the number of bytes to insert from "PBuffer"
//----------------------------------------------------------------------------

DWORD
APIENTRY
RasScriptSend(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN      DWORD       dwBufferSize
    ) {

    DWORD dwsize;
    DWORD dwErr;
    SCRIPTCB *pscript = (SCRIPTCB *)hscript;

    RASSCRPT_TRACE("RasScriptSend");


    if (!pscript || !pBuffer || !dwBufferSize) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // send all the data in the buffer
    //

    for (dwsize = min(dwBufferSize, SIZE_SendBuffer);
         dwBufferSize;
         dwBufferSize -= dwsize, pBuffer += dwsize,
         dwsize = min(dwBufferSize, SIZE_SendBuffer)) {

        CopyMemory(pscript->pSendBuffer, pBuffer, dwsize);

        dwErr = g_pRasPortSend(
                    pscript->hport, pscript->pSendBuffer, dwsize
                    );
        RASSCRPT_TRACE1("g_pRasPortSend=%d", dwErr);
        DUMPB(pBuffer, dwsize);
    }


    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    RasScriptTerm
//
// This function terminates script processing, stopping the scripting thread.
// The return code is the code from processing the script, and it may be
//
//  NO_ERROR:           the script had finished running, or the connection
//                      had no script and the scripting thread was acting
//                      in simple I/O mode.
//  ERROR_MORE_DATA:    the script was still running.
//----------------------------------------------------------------------------

DWORD
APIENTRY
RasScriptTerm(
    IN      HANDLE      hscript
    ) {

    SCRIPTCB* pscript = hscript;

    RASSCRPT_TRACE("RasScriptTerm");

    if (!pscript) { return ERROR_INVALID_PARAMETER; }


    //
    // stop the thread if it is running
    //

    if (pscript->dwFlags & RASSCRIPT_ThreadCreated) {

        SetEvent(pscript->hStopRequest);

        WaitForSingleObject(pscript->hStopComplete, INFINITE);
    }

    if (pscript->pdata) { RsDestroyData(pscript); }

    if (pscript->hStopRequest) { CloseHandle(pscript->hStopRequest); }

    if (pscript->hStopComplete) { CloseHandle(pscript->hStopComplete); }

    if (pscript->hRecvRequest) { CloseHandle(pscript->hRecvRequest); }

    if (pscript->hRecvComplete) { CloseHandle(pscript->hRecvComplete); }


    if (pscript->pRecvBuffer) { g_pRasFreeBuffer(pscript->pRecvBuffer); }

    if (pscript->pSendBuffer) { g_pRasFreeBuffer(pscript->pSendBuffer); }

    Free0(pscript->pszIpAddress);

    Free(pscript);

    RASSCRPT_TRACE_TERM();

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    RsDestroyData
//
// This function destroys the SCRIPTDATA portion of a SCRIPTCB.
//----------------------------------------------------------------------------

DWORD
RsDestroyData(
    IN      SCRIPTCB*   pscript
    ) {

    SCRIPTDATA* pdata = pscript->pdata;

    if (!pdata) { return ERROR_INVALID_PARAMETER; }

    if (pdata->pmoduledecl) { Decl_Delete((PDECL)pdata->pmoduledecl); }

    if (pdata->pastexec) {
        Astexec_Destroy(pdata->pastexec); Free(pdata->pastexec);
    }
    //
    // .Net bug# 522307 Specifying the dialup script file as the COM
    // Port of the Modem will cause explorer to AV.
    //
    if (pdata->pscanner)
    {
        Scanner_Destroy(pdata->pscanner);
        pdata->pscanner = NULL;
    }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    RsInitData
//
// This function initializes the SCRIPTDATA portion of a SCRIPTCB,
// preparing for script-processing.
//----------------------------------------------------------------------------

DWORD
RsInitData(
    IN      SCRIPTCB*   pscript,
    IN      LPCSTR      pszScriptPath
    ) {

    RES res;
    DWORD dwErr = ERROR_SUCCESS;
    SCRIPTDATA *pdata;

    RASSCRPT_TRACE("RsInitData");

    do {

        //
        // allocate space for the SCRIPTDATA;
        //

        pscript->pdata = pdata = Malloc(sizeof(*pdata));

        if (!pdata) {
            RASSCRPT_TRACE1("error %d allocating SCRIPTDATA", dwErr = GetLastError());
            break;
        }


        //
        // initialize the structure
        //

        ZeroMemory(pdata, sizeof(*pdata));

        pdata->hscript = (HANDLE)pscript;
        lstrcpy(pdata->script.szPath, pszScriptPath);


        //
        // create a scanner and use it to open the script
        //

        res = Scanner_Create(&pdata->pscanner, &pscript->sci);

        if (RFAILED(res)) {
            RASSCRPT_TRACE1("failure %d creating scanner", res);
            break;
        }

        res = Scanner_OpenScript(pdata->pscanner, pszScriptPath);

        if (res == RES_E_FAIL || RFAILED(res)) {
            RASSCRPT_TRACE1("failure %d opening script", res);
            //
            // .Net bug# 522307 Specifying the dialup script file as the COM
            // Port of the Modem will cause explorer to AV.
            //
            dwErr = ERROR_SCRIPT_SYNTAX;
            break;
        }


        //
        // allocate a script-execution handler
        //

        pdata->pastexec = Malloc(sizeof(*pdata->pastexec));

        if (!pdata->pastexec) {
            RASSCRPT_TRACE1("error %d allocating ASTEXEC", dwErr = GetLastError());
            break;
        }

        ZeroMemory(pdata->pastexec, sizeof(*pdata->pastexec));


        //
        // initialize the script-execution handler
        //

        res = Astexec_Init(
                pdata->pastexec, pscript, &pscript->sci,
                Scanner_GetStxerrHandle(pdata->pscanner)
                );

        if (!RSUCCEEDED(res)) {
            RASSCRPT_TRACE1("failure %d initializing ASTEXEC", res);
            break;
        }

        Astexec_SetHwnd(pdata->pastexec, (HWND)pdata);


        //
        // parse the script using the created scanner
        // and writing into the execution-handler's symbol-table
        //

        res = ModuleDecl_Parse(
                &pdata->pmoduledecl, pdata->pscanner,
                pdata->pastexec->pstSystem
                );

        if (RSUCCEEDED(res)) {

            //
            // generate code for the script
            //

            res = ModuleDecl_Codegen(pdata->pmoduledecl, pdata->pastexec);
        }


        //
        // see if anything went wrong
        //

        if (RFAILED(res)) {

            //
            // there was an error parsing the script.
            // we return the special error code ERROR_SCRIPT_SYNTAX
            // and log the errors to a file.
            //
            // This is not necessarily a fatal error, and so returning
            // the above error doesn't cause script-initialization to fail,
            // since if the user is in interactive mode, the connection
            // may be completed manually by typing into the terminal window.
            //
            // If we are not in interactive mode, this is a fatal error,
            // and RasScriptExecute handles the condition correctly
            // by terminating the script immediately
            //

            RASSCRPT_TRACE1("failure %d parsing script", res);

            RxLogErrors(
                (HANDLE)pscript, (VOID*)Scanner_GetStxerrHandle(pdata->pscanner)
                );

            Decl_Delete((PDECL)pdata->pmoduledecl);
            Astexec_Destroy(pdata->pastexec); Free(pdata->pastexec);
            Scanner_Destroy(pdata->pscanner);
            //
            // .Net bug# 522307 Specifying the dialup script file as the COM
            // Port of the Modem will cause explorer to AV.
            //
            pdata->pscanner = NULL;
            pscript->pdata = NULL;

            dwErr = ERROR_SCRIPT_SYNTAX;

            return dwErr;
        }


        //
        // all went well, return
        //

        return NO_ERROR;

    } while(FALSE);


    //
    // an error occurred, so do cleanup
    //

    if (pscript->pdata) { RsDestroyData(pscript); }

    return (dwErr ? dwErr : ERROR_UNKNOWN);
}



//----------------------------------------------------------------------------
// Function:    RsPostReceive
//
// Internal function:
// posts receive-request to RASMAN
//----------------------------------------------------------------------------

DWORD
RsPostReceive(
    IN      SCRIPTCB*   pscript
    ) {

    DWORD dwSize;
    DWORD dwErr;

    RASSCRPT_TRACE("RsPostReceive");

    dwSize = SIZE_RecvBuffer;

    dwErr = g_pRasPortReceive(
                pscript->hport, pscript->pRecvBuffer, &dwSize, SECS_RecvTimeout,
                pscript->hRecvRequest
                );

    RASSCRPT_TRACE2("RsPostReceive=%d,%d", dwErr, dwSize);

    return dwErr;
}

BOOL
IsRasmanProcess()
{
    CHAR *pszCmdLine = NULL;
    BOOL fRet = FALSE;

    pszCmdLine = GetCommandLineA();

    if(     (NULL != pszCmdLine)
        &&  (strstr(pszCmdLine, NET_SVCS_GROUP)))
    {
        fRet = TRUE;
    }

    return fRet;    
}


DWORD
RsPostReceiveEx(
    IN SCRIPTCB* pscript
    ) {

    DWORD dwSize = 0;
    DWORD dwErr = ERROR_SUCCESS;

    RASSCRPT_TRACE("RsPostReceiveEx");

    if(IsRasmanProcess())
    {
        goto done;
    }

    RASSCRPT_TRACE("Calling RsPostReceiveEx");

    dwSize = SIZE_RecvBuffer;
    dwErr = g_pRasPortReceiveEx(
            pscript->hport,
            pscript->pRecvBuffer,
            &dwSize
            );

done:

    RASSCRPT_TRACE2("RsPostReceiveEx=%d, %d",dwErr, dwSize );

    return dwErr;

}




//----------------------------------------------------------------------------
// Function:    RsSignal
//
// Internal function:
// this is called to signal the notifier for a script, which may involve
// setting an event or sending a message.
//----------------------------------------------------------------------------

VOID
RsSignal(
    IN  SCRIPTCB*   pscript,
    IN  DWORD       dwEventCode
    ) {

    RASSCRPT_TRACE1("RsSignal: %d", dwEventCode);

    InterlockedExchange(&pscript->dwEventCode, dwEventCode);

    if (pscript->dwFlags & RASSCRIPT_HwndNotify) {

        SendNotifyMessage(
            (HWND)pscript->hNotifier, WM_RASAPICOMPLETE, 0, dwEventCode
            );
    }
    else {

        SetEvent(pscript->hNotifier);
    }
}




//----------------------------------------------------------------------------
// Function:    RsThread
//
// This function is the entry-point for the script processing thread.
//
// The scripting thread operates in a loop, posting receive requests
// and receiving incoming data. If a script is associated with the port,
// the thread also runs the script.
//----------------------------------------------------------------------------

DWORD
RsThread(
    IN      PVOID       pParam
    ) {

    WORD wSize;
#define POS_STOP    0
#define POS_RECV    1
#define POS_LAST    2
    BOOL bFirstRecv = TRUE;
    HANDLE hEvents[POS_LAST];
    SCRIPTCB* pscript = (SCRIPTCB *)pParam;
    SCRIPTDATA* pdata = pscript->pdata;
    DWORD dwErr, dwTicksBefore, dwTicksAfter, dwTicksElapsed;


    RASSCRPT_TRACE("RsThread");

    //
    // post receive-request to RASMAN
    //

    dwErr = RsPostReceive(pscript);
    if (dwErr != NO_ERROR && dwErr != PENDING) {

        RASSCRPT_TRACE1("error %d posting receive to RASMAN", dwErr);

        RsPostReceiveEx ( pscript );

        RsSignal(pscript, SCRIPTCODE_Halted);

        SetEvent(pscript->hStopComplete);

        return dwErr;
    }


    //
    // set up event array; we place the stop-request event first
    // in the array since the receive-event will be signalled more often
    // and placing it first might result in starvation
    // (waits are always satisfied by the first signalled object)
    //

    hEvents[POS_STOP] = pscript->hStopRequest;
    hEvents[POS_RECV] = pscript->hRecvRequest;

    if (pdata) { pdata->dwTimeout = INFINITE; }

    while (TRUE) {


        //
        // wait for receive to complete, for stop signal,
        // or for timeout to expire
        //
        // save the tick count so we can tell how long the wait lasted
        //

        dwTicksBefore = GetTickCount();

        dwErr = WaitForMultipleObjects(
                    POS_LAST, hEvents, FALSE, pdata ? pdata->dwTimeout:INFINITE
                    );

        dwTicksAfter = GetTickCount();


        //
        // see if the tick count wrapped around, and if so
        // adjust so we always get the correct elapsed time
        // from the expression (dwTicksAfter - dwTicksBefore)
        //

        if (dwTicksAfter < dwTicksBefore) {
            dwTicksAfter += MAXDWORD - dwTicksBefore;
            dwTicksBefore = 0;
        }

        dwTicksElapsed = dwTicksAfter - dwTicksBefore;

        RASSCRPT_TRACE1("RsThread: waited for %d milliseconds", dwTicksElapsed);


        //
        // if the timeout isn't INFINITE, decrement it by
        // the amount of time we've already waited
        //

        if (pdata && pdata->dwTimeout != INFINITE) {

            if (dwTicksElapsed >= pdata->dwTimeout) {
                pdata->dwTimeout = INFINITE;
            }
            else {
                pdata->dwTimeout -= dwTicksElapsed;
            }
        }


        //
        // Handle the return-code from WaitForMultipleObjects
        //

        if (dwErr == (WAIT_OBJECT_0 + POS_STOP)) {

            //
            // stop-request signalled, break
            //

            RASSCRPT_TRACE("RsThread: stop event signalled");

            RsSignal(pscript, SCRIPTCODE_Halted);

            break;
        }
        else
        if (dwErr == WAIT_TIMEOUT) {


            if (!pdata) { continue; }


            //
            // wait timed out, so that means we were blocked
            // on a "delay" or "waitfor ... until" statement;
            //

            Astexec_ClearPause(pdata->pastexec);


            //
            // if we blocked because of a "waitfor ... until",
            // finish processing the statement
            //

            if (Astexec_IsWaitUntil(pdata->pastexec)) {

                Astexec_SetStopWaiting(pdata->pastexec);

                Astexec_ClearWaitUntil(pdata->pastexec);
            }


            //
            // continue processing the script
            //

            if (RsThreadProcess(pscript) == ERROR_NO_MORE_ITEMS) {

                //
                // the script has stopped; if done, break;
                // otherwise, continue receiving data
                //

                if (pscript->dwEventCode == SCRIPTCODE_Done) {

                    break;
                }
                else {

                    //
                    // Cleanup the script, but continue receiving data
                    //

                    RsDestroyData(pscript);

                    pdata = pscript->pdata = NULL;
                }
            }
        }
        else
        if (dwErr == (WAIT_OBJECT_0 + POS_RECV)) {

            //
            // receive completed
            //

            RASMAN_INFO info;
            DWORD dwStart, dwRead;

            RASSCRPT_TRACE("RsThread: receive event signalled");


            //
            // Get the data received
            //
            dwErr = RsPostReceiveEx ( pscript );

            if (    NO_ERROR != dwErr
                &&  PENDING  != dwErr )
            {
                RASSCRPT_TRACE1("error %d in RsPostReceiveEx", dwErr);

                RsSignal(pscript, SCRIPTCODE_Halted );

                break;
            }

            //
            // get the number of bytes received
            //

            dwErr = g_pRasGetInfo(NULL, pscript->hport, &info);

            if (dwErr != NO_ERROR) {

                RASSCRPT_TRACE1("error %d retrieving RASMAN_INFO", dwErr);

                RsSignal(pscript, SCRIPTCODE_Halted);

                break;
            }

            if(  (info.RI_LastError != NO_ERROR)
              && (info.RI_ConnState != CONNECTING))
            {
                RASSCRPT_TRACE("Link dropped! port no longer in connecting state");

                RsSignal(pscript, SCRIPTCODE_Halted);

                break;
            }
            
            if (info.RI_LastError != NO_ERROR) {
                RASSCRPT_TRACE1("last error: %d", info.RI_LastError);
                continue;
            }

            RASSCRPT_TRACE1("RsThread: received %d bytes", info.RI_BytesReceived);


            //
            // on the first receive, we proceed even if there aren't any
            // characters read, since we need to run the first script commands
            //

            if (!bFirstRecv && info.RI_BytesReceived == 0) {

                //
                // something went wrong, post another receive request
                //

                dwErr = RsPostReceive(pscript);

                if (    dwErr != NO_ERROR
                    &&  dwErr != PENDING)
                {
                    RASSCRPT_TRACE1("error %d in RsPostReceive", dwErr);

                    RsSignal(pscript, SCRIPTCODE_Halted);

                    break;
                }

                continue;
            }

            bFirstRecv = FALSE;

            pscript->dwRecvSize = info.RI_BytesReceived;
            pscript->dwRecvRead = 0;

            DUMPB(pscript->pRecvBuffer, pscript->dwRecvSize);


            //
            // if the creator wants to know when data arrives,
            // signal the creator's notification now;
            // wait till the creator reads the data before proceeding
            //

            if (info.RI_BytesReceived &&
                (pscript->dwFlags & RASSCRIPT_NotifyOnInput)) {

                RsSignal(pscript, SCRIPTCODE_InputNotify);

                WaitForSingleObject(pscript->hRecvComplete, INFINITE);
            }


            //
            // if we have no script that's all we have to do,
            // so just post another receive request and go back to waiting
            //

            if (!pdata) {

                dwErr = RsPostReceive(pscript);

                if (    dwErr != NO_ERROR
                    &&  dwErr != PENDING )
                {
                    RASSCRPT_TRACE1("error %d in RsPostReceive",dwErr);

                    RsSignal(pscript, SCRIPTCODE_Halted);

                    break;
                }

                continue;
            }


            //
            // read the data into the script's circular buffer
            //

            ReadIntoBuffer(pdata, &dwStart, &dwRead);


            //
            // do more script processing
            //

            if (RsThreadProcess(pscript) == ERROR_NO_MORE_ITEMS) {

                //
                // the script has stopped; if done, break;
                // otherwise, continue receiving data
                //

                if (pscript->dwEventCode == SCRIPTCODE_Done) {

                    break;
                }
                else {

                    //
                    // Cleanup the script, but continue receiving data
                    //

                    RsDestroyData(pscript);

                    pdata = pscript->pdata = NULL;
                }
            }
        }
    }


    //
    // cancel any pending receives
    //

    g_pRasPortCancelReceive(pscript->hport);


    SetEvent(pscript->hStopComplete);

    RASSCRPT_TRACE("RsThread done");

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    RsThreadProcess
//
// Called to process the script until it is blocked
// by a "waitfor" statement or a "delay" statement.
//----------------------------------------------------------------------------

DWORD
RsThreadProcess(
    IN      SCRIPTCB*   pscript
    ) {

    RES res;
    DWORD dwErr;
    SCRIPTDATA *pdata = pscript->pdata;

    RASSCRPT_TRACE("RsThreadProcess");


    //
    // now step through the script until we are blocked
    // by a "delay" statement or a "waitfor" statement
    //

    dwErr = NO_ERROR;

    do {

        //
        // break if its time to stop
        //

        if (WaitForSingleObject(pscript->hStopRequest, 0) == WAIT_OBJECT_0) {

            SetEvent(pscript->hStopRequest);

            break;
        }


        //
        // process next command
        //
        // .Net bug# 525233 SECURITY: Specifying the dialup script file as the
        // COM Port of the Modem and having show terminal window enabled will
        // cause explorer to AV
        //

        if (!pdata->pastexec)
        {
            dwErr = ERROR_NO_MORE_ITEMS;
            break;
        }

        res = Astexec_Next(pdata->pastexec);

        //
        // examine the resulting state
        //

        if (Astexec_IsDone(pdata->pastexec) ||
            Astexec_IsHalted(pdata->pastexec)) {

            //
            // the script has come to an end, so set our stop event
            // and break out of this loop
            //

            RASSCRPT_TRACE("RsThreadProcess: script completed");

            //
            // do stop-completion notification
            //

            if (Astexec_IsDone(pdata->pastexec)) {
                RsSignal(pscript, SCRIPTCODE_Done);
            }
            else
            if (!RFAILED(res)) {
                RsSignal(pscript, SCRIPTCODE_Halted);
            }
            else {
                RsSignal(pscript, SCRIPTCODE_HaltedOnError);
            }


            dwErr = ERROR_NO_MORE_ITEMS;

            break;
        }
        else
        if (Astexec_IsReadPending(pdata->pastexec)) {

            //
            // we're blocked waiting for input,
            // so post another receive request and go back
            // to waiting for data;
            // if we're blocked on a "waitfor ... until"
            // then the timeout will be in pdata->dwTimeout,
            // otherwise pdata->dwTimeout will be INFINITE
            // which is exactly how long we'll be waiting
            //

            RsPostReceive(pscript);

            RASSCRPT_TRACE("RsThreadProcess: script waiting for input");

            break;
        }
        else
        if (Astexec_IsPaused(pdata->pastexec)) {

            //
            // we're blocked with a timeout, so pick up
            // the timeout value from pdata->dwTimeout.
            // we don't want to listen for input
            // while we're blocked, so we don't post another receive-request
            //

            RASSCRPT_TRACE("RsThreadProcess: script paused");

            break;
        }

    } while (TRUE);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    RxLogErrors
//
// Logs script syntax errors to a file named %windir%\system32\ras\script.log
//----------------------------------------------------------------------------

DWORD
RxLogErrors(
    IN      HANDLE      hscript,
    IN      HSA         hsaStxerr
    ) {

    HANDLE hfile;
    CHAR *pszPath;
    STXERR stxerr;
    SCRIPTDATA *pdata;
    SCRIPTCB *pscript = hscript;
    DWORD i, cel, dwErr, dwSize;

    RASSCRPT_TRACE("RxLogErrors");

    if (!pscript || !pscript->pdata) { return ERROR_INVALID_PARAMETER; }

    pdata = pscript->pdata;



    //
    // get the pathname for the logfile
    //

    dwSize = ExpandEnvironmentStrings(c_szScriptLog, NULL, 0);

    pszPath = Malloc((dwSize + 1) * sizeof(CHAR));
    if (!pszPath) { return ERROR_NOT_ENOUGH_MEMORY; }

    ExpandEnvironmentStrings(c_szScriptLog, pszPath, dwSize);


    //
    // create the file, overwriting it if it already exists
    //

    hfile = CreateFile(
                pszPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL
                );
    Free(pszPath);

    if (INVALID_HANDLE_VALUE == hfile) {
        dwErr = GetLastError();
        RASSCRPT_TRACE1("error %d creating logfile", dwErr);
        return dwErr;
    }


    //
    // truncate the previous contents of the file, if any
    //

    SetFilePointer(hfile, 0, 0, FILE_BEGIN);
    SetEndOfFile(hfile);


    //
    // get the number of syntax errors
    //

    cel = SAGetCount(hsaStxerr);


    //
    // append each error to the file
    //

    for (i = 0; i < cel; i++) {

        UINT ids;
        CHAR* pszErr;
        BOOL bRet = SAGetItem(hsaStxerr, i, &stxerr);


        if (!bRet) { continue; }

        ids = IdsFromRes(Stxerr_GetRes(&stxerr));

        if (ids == 0) { continue; }


        //
        // format the error message
        //

        ConstructMessage(
            &pszErr, g_hinst, MAKEINTRESOURCE(ids), pdata->script.szPath,
            Stxerr_GetLine(&stxerr), Stxerr_GetLexeme(&stxerr)
            );

        if (!pszErr) { continue; }


        //
        // write the message to the log file
        //

        dwSize = lstrlen(pszErr);

        WriteFile(hfile, pszErr, lstrlen(pszErr), &dwSize, NULL);

        WriteFile(hfile, "\r\n", 2, &dwSize, NULL);


        //
        // free the message pointer
        //

        GFree(pszErr);
    }

    CloseHandle(hfile);

    return 0;
}



//----------------------------------------------------------------------------
// Function:    RxReadFile
//
// Transfers data out of a RASMAN buffer into the circular buffer used
// by the Win9x scripting code
//----------------------------------------------------------------------------

BOOL
RxReadFile(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN      DWORD       dwBufferSize,
    OUT     DWORD*      pdwBytesRead
    ) {

    SCRIPTCB* pscript = (SCRIPTCB*)hscript;
    DWORD dwRecvSize = pscript->dwRecvSize - pscript->dwRecvRead;

    RASSCRPT_TRACE("RxReadFile");

    if (!pdwBytesRead) { return FALSE; }

    *pdwBytesRead = 0;
    if ((INT)dwRecvSize <= 0) { return FALSE; }

    if (!dwBufferSize) { return FALSE; }

    *pdwBytesRead = min(dwBufferSize, dwRecvSize);
    CopyMemory(
        pBuffer, pscript->pRecvBuffer + pscript->dwRecvRead, *pdwBytesRead
        );
    pscript->dwRecvRead += *pdwBytesRead;

    RASSCRPT_TRACE2("RxReadFile(rr=%d,br=%d)",pscript->dwRecvRead,*pdwBytesRead);

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    RxSetIPAddress
//
// Sets the IP address for the script's RAS entry
//----------------------------------------------------------------------------

DWORD
RxSetIPAddress(
    IN      HANDLE      hscript,
    IN      LPCSTR      lpszAddress
    ) {

    DWORD dwErr = NO_ERROR;
    SCRIPTCB *pscript = (SCRIPTCB *)hscript;

    RASSCRPT_TRACE1("RxSetIPAddress: %s", lpszAddress);


    EnterCriticalSection(&g_cs);


    //
    // Free the existing IP address, if any
    //

    Free0(pscript->pszIpAddress);


    //
    // Allocate space for a copy of the address
    //

    pscript->pszIpAddress = Malloc(lstrlen(lpszAddress) + 1);

    if (!pscript->pszIpAddress) { dwErr = ERROR_NOT_ENOUGH_MEMORY; }
    else {

        //
        // Copy the new IP address
        //

        lstrcpy(pscript->pszIpAddress, lpszAddress);
    }

    LeaveCriticalSection(&g_cs);



    //
    // If successful, signal the caller that the IP address has changed
    //

    if (dwErr != NO_ERROR) {
        RASSCRPT_TRACE1("error %d writing phonebook file", dwErr);
    }
    else {


                if (    INVALID_HANDLE_VALUE != hIpAddressSet
                        &&      !(pscript->dwFlags  & RASSCRIPT_HwndNotify))
                {
                DWORD dwEventCode = SCRIPTCODE_IpAddressSet;
                        RASSCRPT_TRACE1("RxSetIPAddress: %d", dwEventCode);

                        InterlockedExchange(&pscript->dwEventCode, dwEventCode);
                        SetEvent (hIpAddressSet);

                }

                else if (pscript->dwFlags & RASSCRIPT_HwndNotify)
                RsSignal(pscript, SCRIPTCODE_IpAddressSet);
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    RxSetKeyboard
//
// Signals the script-owner to enable or disable keyboard input.
//----------------------------------------------------------------------------

DWORD
RxSetKeyboard(
    IN      HANDLE      hscript,
    IN      BOOL        bEnable
    ) {

    RASSCRPT_TRACE("RxSetKeyboard");

    RsSignal(
        (SCRIPTCB *)hscript,
        bEnable ? SCRIPTCODE_KeyboardEnable : SCRIPTCODE_KeyboardDisable
        );

    return NO_ERROR;
}

//----------------------------------------------------------------------------
// Function:    RxSendCreds
//
// Sends users password over the wire.
//----------------------------------------------------------------------------
DWORD
RxSendCreds(
    IN HANDLE hscript,
    IN CHAR controlchar
    ) {

    SCRIPTCB *pscript = (SCRIPTCB *) hscript;
    DWORD dwErr;

    RASSCRPT_TRACE("RasSendCreds");

    dwErr = RasSendCreds(pscript->hport, controlchar);

    RASSCRPT_TRACE1("RasSendCreds done. 0x%x", dwErr);

    return (dwErr == NO_ERROR) ? RES_OK : RES_E_FAIL;
    
}


//----------------------------------------------------------------------------
// Function:    RxSetPortData
//
// Changes settings for the COM port.
//----------------------------------------------------------------------------

DWORD
RxSetPortData(
    IN      HANDLE      hscript,
    IN      VOID*       pStatement
    ) {

    RES res;
    STMT* pstmt;
    RAS_PARAMS* pparam;
    DWORD dwErr, dwFlags;
    RASMAN_PORTINFO *prmpi;
    SCRIPTCB *pscript = (SCRIPTCB *)hscript;
    BYTE aBuffer[sizeof(RASMAN_PORTINFO) + sizeof(RAS_PARAMS) * 2];

    RASSCRPT_TRACE("RxSetPortData");


    //
    // Retrieve the 'set port' statement
    //

    pstmt = (STMT*)pStatement;

    dwFlags = SetPortStmt_GetFlags(pstmt);


    //
    // Set up the RASMAN_PORTINFO to be passed to RasPortSetInfo
    //

    prmpi = (RASMAN_PORTINFO*)aBuffer;

    prmpi->PI_NumOfParams = 0;

    pparam = prmpi->PI_Params;


    //
    // Collect the changes into the port-info structure
    //

    if (IsFlagSet(dwFlags, SPF_DATABITS)) {

        lstrcpyA(pparam->P_Key, SER_DATABITS_KEY);

        pparam->P_Type = Number;

        pparam->P_Attributes = 0;

        pparam->P_Value.Number = SetPortStmt_GetDatabits(pstmt);

        RASSCRPT_TRACE1("GetDatabits==%d", pparam->P_Value.Number);

        ++prmpi->PI_NumOfParams;

        ++pparam;
    }


    if (IsFlagSet(dwFlags, SPF_STOPBITS)) {

        lstrcpyA(pparam->P_Key, SER_STOPBITS_KEY);

        pparam->P_Type = Number;

        pparam->P_Attributes = 0;

        pparam->P_Value.Number = SetPortStmt_GetStopbits(pstmt);


        //
        // The only 'stopbits' settings supported are 1 and 2;
        // in order to set stopbits of 1, we need to pass 0
        // to RasPortSetInfo, so the value is adjusted here.
        //

        if (pparam->P_Value.Number == 1) { --pparam->P_Value.Number; }

        RASSCRPT_TRACE1("GetStopbits==%d", pparam->P_Value.Number);

        ++prmpi->PI_NumOfParams;

        ++pparam;
    }

    if (IsFlagSet(dwFlags, SPF_PARITY)) {

        lstrcpyA(pparam->P_Key, SER_PARITY_KEY);

        pparam->P_Type = Number;

        pparam->P_Attributes = 0;

        pparam->P_Value.Number = SetPortStmt_GetParity(pstmt);

        RASSCRPT_TRACE1("GetParity==%d", pparam->P_Value.Number);

        ++prmpi->PI_NumOfParams;

        ++pparam;
    }


    //
    // Send the changes down to RASMAN
    //

    if (!prmpi->PI_NumOfParams) { dwErr = NO_ERROR; }
    else {

        dwErr = g_pRasPortSetInfo(pscript->hport, prmpi);

        RASSCRPT_TRACE1("g_pRasPortSetInfo==%d", dwErr);

        if (dwErr != NO_ERROR) {

            Stxerr_Add(
                pscript->pdata->pastexec->hsaStxerr, "set port",
                Ast_GetLine(pstmt), RES_E_FAIL
                );
        }
    }

    return (dwErr == NO_ERROR) ? RES_OK : RES_E_FAIL;
}



//----------------------------------------------------------------------------
// Function:    RxWriteFile
//
// Transmits the given buffer thru RASMAN on a port
//----------------------------------------------------------------------------

VOID
RxWriteFile(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN      DWORD       dwBufferSize,
    OUT     DWORD*      pdwBytesWritten
    ) {

    RASSCRPT_TRACE("RxWriteFile");

    if (!pdwBytesWritten) { return; }

    RasScriptSend(hscript, pBuffer, dwBufferSize);

    *pdwBytesWritten = dwBufferSize;

    RASSCRPT_TRACE1("RxWriteFile(bw=%d)", *pdwBytesWritten);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\ipxui.c ===
/*
    File    ipxui.c

    Dialog that edits the ipx properties.
    
    Paul Mayfield, 10/9/97
*/

#include "rassrv.h"

// Help maps
static const DWORD phmIpxui[] =
{
    CID_NetTab_Ipxui_RB_AutoAssign,         IDH_NetTab_Ipxui_RB_AutoAssign,
    CID_NetTab_Ipxui_RB_ManualAssign,       IDH_NetTab_Ipxui_RB_ManualAssign,
    CID_NetTab_Ipxui_CB_AssignSame,         IDH_NetTab_Ipxui_CB_AssignSame,
    CID_NetTab_Ipxui_EB_Netnum,             IDH_NetTab_Ipxui_EB_Netnum,
    //CID_NetTab_Ipxui_ST_Network,            IDH_NetTab_Ipxui_ST_Network,
    CID_NetTab_Ipxui_CB_CallerSpec,         IDH_NetTab_Ipxui_CB_CallerSpec,
    //CID_NetTab_Ipxui_CB_ExposeNetwork,      IDH_NetTab_Ipxui_CB_ExposeNetwork,
    0,                                      0
};

void IpxUiDisplayError(HWND hwnd, DWORD dwErr) {
    ErrDisplayError(hwnd, dwErr, ERR_IPXPROP_CATAGORY, 0, Globals.dwErrorData);
}

// Enables/disables windows in the dialog box depending
// on the ipx parameters
DWORD IpxEnableWindows(HWND hwndDlg, IPX_PARAMS * pIpxParams) {
    // If auto assign is selected, disable address and global wan fields
    EnableWindow(GetDlgItem(hwndDlg, CID_NetTab_Ipxui_EB_Netnum), !pIpxParams->bAutoAssign);
    //EnableWindow(GetDlgItem(hwndDlg, CID_NetTab_Ipxui_CB_AssignSame), !pIpxParams->bAutoAssign);

    return NO_ERROR;
}

// Adjusts the label that determines whether internal net numbers
// are automatically assigned.
DWORD IpxAdjustNetNumberLabel(HWND hwndDlg, BOOL bGlobalWan) {
    PWCHAR pszManAssignLabel, pszAutoAssignLabel;

    // Modify the net num label according to the global wan setting
    if (bGlobalWan) {
        pszManAssignLabel = 
            (PWCHAR) PszLoadString(Globals.hInstDll, SID_NETWORKNUMBERLABEL);
        pszAutoAssignLabel = 
            (PWCHAR) PszLoadString(Globals.hInstDll, SID_AUTO_NETNUM_LABEL);
    }
    else {
        pszManAssignLabel = 
            (PWCHAR) PszLoadString(Globals.hInstDll, SID_STARTNETNUMLABEL);
        pszAutoAssignLabel = 
            (PWCHAR) PszLoadString(Globals.hInstDll, SID_AUTO_NETNUMS_LABEL);
    }

    SetWindowTextW(GetDlgItem(hwndDlg, CID_NetTab_Ipxui_RB_ManualAssign), pszManAssignLabel);
    SetWindowTextW(GetDlgItem(hwndDlg, CID_NetTab_Ipxui_RB_AutoAssign), pszAutoAssignLabel);

    return NO_ERROR;
}

#define isBetween(b,a,c) ((b >= a) && (b <= c))

// Filters characters that can be edited into an ipx net number control
BOOL IpxValidNetNumberChar(WCHAR wcNumChar) {
    return (iswdigit(wcNumChar)                             ||
            isBetween(wcNumChar, (WCHAR)'A', (WCHAR)'F')    ||
            isBetween(wcNumChar, (WCHAR)'a', (WCHAR)'f')    );
}

// Returns TRUE if buf points to a valid ipx net number (8 digit hex)
// Otherwise returns FALSE and puts a corrected version of the number 
// in pszCorrect.  pszCorrect will always contain the correct version.
BOOL IpxValidNetNumber(PWCHAR pszNum, PWCHAR pszCorrect) {
    BOOL cFlag = TRUE;
    int i, j=0, len = (int) wcslen(pszNum);

    // Validate the name
    if (len > 8) {
        lstrcpynW(pszCorrect, pszNum, 8);
        pszCorrect[8] = (WCHAR)0;
        return FALSE;
    }

    // Validate the characters
    for (i = 0; i < len; i++) {
        if (IpxValidNetNumberChar(pszNum[i]))
            pszCorrect[j++] = pszNum[i];
        else
            cFlag = FALSE;
    }
    pszCorrect[j] = (WCHAR)0;

    return cFlag;
}

// We subclass the ipx address text fields so that they don't
// allow bogus values to be typed.
LRESULT CALLBACK IpxNetNumProc (HWND hwnd,
                            UINT uMsg,
                            WPARAM wParam,
                            LPARAM lParam) {

    WNDPROC wProc = (WNDPROC) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (uMsg == WM_CHAR) {
        if ((wParam != VK_BACK) && (!IpxValidNetNumberChar((WCHAR)wParam)))
            return FALSE;
    }

    return CallWindowProc(wProc, hwnd, uMsg, wParam, lParam);
}

// Initializes the Ipx Properties Dialog
DWORD IpxInitDialog(HWND hwndDlg, LPARAM lParam) {
    WCHAR pszAddr[16];
    IPX_PARAMS * pIpxParams = (IPX_PARAMS *)(((PROT_EDIT_DATA*)lParam)->pbData);
    ULONG_PTR pOldWndProc;
    HWND hwndEdit;
                                                   
    // Store the parameters with the window handle
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);

    // Subclass the edit control(s)
    hwndEdit = GetDlgItem(hwndDlg, CID_NetTab_Ipxui_EB_Netnum);
    pOldWndProc = SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)IpxNetNumProc);
    SetWindowLongPtr(hwndEdit, GWLP_USERDATA, (LONG_PTR)pOldWndProc);
    
    // Set the network exposure check
    SendDlgItemMessage(hwndDlg, 
                       CID_NetTab_Ipxui_CB_ExposeNetwork,
                       BM_SETCHECK, 
                       (((PROT_EDIT_DATA*)lParam)->bExpose) ? BST_CHECKED : BST_UNCHECKED,
                       0);

    // Set the address assignmnet radio buttons
    SendDlgItemMessage(hwndDlg, 
                       CID_NetTab_Ipxui_RB_AutoAssign, 
                       BM_SETCHECK, 
                       (pIpxParams->bAutoAssign) ? BST_CHECKED : BST_UNCHECKED,
                       0);
    
    // Set the address assignmnet radio buttons
    SendDlgItemMessage(hwndDlg, 
                       CID_NetTab_Ipxui_RB_ManualAssign, 
                       BM_SETCHECK, 
                       (pIpxParams->bAutoAssign) ? BST_UNCHECKED : BST_CHECKED,
                       0);
    
    // Set the "allow caller to request an ipx node number" check
    SendDlgItemMessage(hwndDlg, 
                       CID_NetTab_Ipxui_CB_CallerSpec, 
                       BM_SETCHECK, 
                       (pIpxParams->bCaller) ? BST_CHECKED : BST_UNCHECKED,
                       0);

    // Set the global wan number check
    SendDlgItemMessage(hwndDlg, 
                       CID_NetTab_Ipxui_CB_AssignSame, 
                       BM_SETCHECK, 
                       (pIpxParams->bGlobalWan) ? BST_CHECKED : BST_UNCHECKED,
                       0);

    // Set the maximum amount of text that can be entered into the edit control
    SendDlgItemMessage(hwndDlg, CID_NetTab_Ipxui_EB_Netnum, EM_SETLIMITTEXT , 8, 0);
    
    // Set the text of the ip addresses
    wsprintfW(pszAddr, L"%x", pIpxParams->dwIpxAddress);
    SetDlgItemTextW(hwndDlg, CID_NetTab_Ipxui_EB_Netnum, pszAddr);

    // Enable/disable windows as per the settings
    IpxEnableWindows(hwndDlg, pIpxParams);
    IpxAdjustNetNumberLabel(hwndDlg, pIpxParams->bGlobalWan);

    return NO_ERROR;
}

// Gets the settings from the ui and puts them into 
// the ipx parameter structure.
DWORD IpxGetUISettings(HWND hwndDlg, PROT_EDIT_DATA * pEditData) {
    IPX_PARAMS * pIpxParams = (IPX_PARAMS *) pEditData->pbData;
    WCHAR pszAddr[10];
    GetDlgItemTextW(hwndDlg, CID_NetTab_Ipxui_EB_Netnum, pszAddr, 10);

    pIpxParams->dwIpxAddress = wcstoul(pszAddr, (WCHAR)NULL, 16);

    // A configuration that specificies a wan net pool begining with
    // zero or 0xffffffff is illegal.  Force the user to enter a 
    // valid config
    if ((!pIpxParams->bAutoAssign) &&
           ((pIpxParams->dwIpxAddress == 0x0) ||
            (pIpxParams->dwIpxAddress == 0xFFFFFFFF)))
    {
        IpxUiDisplayError(hwndDlg, ERR_IPX_BAD_POOL_CONFIG);
        return ERROR_CAN_NOT_COMPLETE;
    }

    pEditData->bExpose = SendDlgItemMessage(hwndDlg, CID_NetTab_Ipxui_CB_ExposeNetwork, BM_GETCHECK, 0, 0) == BST_CHECKED;

    return NO_ERROR;
}

// Dialog proc that governs the ipx settings dialog
INT_PTR CALLBACK IpxSettingsDialogProc (HWND hwndDlg,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam) {
    switch (uMsg) {
        case WM_INITDIALOG:
            IpxInitDialog(hwndDlg, lParam);
            return FALSE;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmIpxui);
            break;
        }

        case WM_DESTROY:                           
            // Cleanup the work done at WM_INITDIALOG 
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);
            break;
        
        case WM_COMMAND:
            {
                IPX_PARAMS * pIpxParams = (IPX_PARAMS *)(((PROT_EDIT_DATA*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA))->pbData);
                switch (wParam) {
                    case IDOK:
                        if (IpxGetUISettings(hwndDlg, (PROT_EDIT_DATA*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA)) == NO_ERROR)
                            EndDialog(hwndDlg, 1);
                        break;
                    case IDCANCEL:
                        EndDialog(hwndDlg, 0);
                        break;
                    case CID_NetTab_Ipxui_RB_AutoAssign:
                        pIpxParams->bAutoAssign = TRUE;
                        IpxEnableWindows(hwndDlg, pIpxParams);
                        break;
                    case CID_NetTab_Ipxui_RB_ManualAssign:
                        pIpxParams->bAutoAssign = FALSE;
                        IpxEnableWindows(hwndDlg, pIpxParams);
                        break;
                    case CID_NetTab_Ipxui_CB_CallerSpec:
                        pIpxParams->bCaller = (BOOL)SendDlgItemMessage(hwndDlg, 
                                                                   CID_NetTab_Ipxui_CB_CallerSpec, 
                                                                   BM_GETCHECK, 
                                                                   0,
                                                                   0);
                        break;
                    case CID_NetTab_Ipxui_CB_AssignSame:
                        pIpxParams->bGlobalWan = (BOOL)SendDlgItemMessage(hwndDlg, 
                                                                   CID_NetTab_Ipxui_CB_AssignSame, 
                                                                   BM_GETCHECK, 
                                                                   0,
                                                                   0);
                        IpxAdjustNetNumberLabel(hwndDlg, pIpxParams->bGlobalWan);                                           
                        break;
                }
                // Adjust the values written to the ipx address edit control
                if (HIWORD(wParam) == EN_UPDATE) {
                    WCHAR wbuf[10], wcorrect[10];
                    POINT pt;
                    GetWindowTextW((HWND)lParam, wbuf, 10);
                    if (!IpxValidNetNumber(wbuf, wcorrect)) {
                        GetCaretPos(&pt);
                        SetWindowTextW((HWND)lParam, wcorrect);
                        SetCaretPos(pt.x, pt.y);
                    }
                }
                break;
            }
    }

    return FALSE;
}

// Edits tcp ip protocol properties
DWORD IpxEditProperties(HWND hwndParent, PROT_EDIT_DATA * pEditData, BOOL * pbCommit) {
    DWORD dwErr;
    int ret;

    // Popup the dialog box
    ret = (int) DialogBoxParam(Globals.hInstDll,
                             MAKEINTRESOURCE(DID_NetTab_Ipxui),
                             hwndParent,
                             IpxSettingsDialogProc,
                             (LPARAM)pEditData);
    if (ret == -1) {
        IpxUiDisplayError(hwndParent, ERR_IPX_CANT_DISPLAY);
    }

    // If ok was pressed, save off the new settings
    *pbCommit = FALSE;
    if (ret && ret != -1)
        *pbCommit = TRUE;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\ipxui.h ===
/*
    File    Ipxui.c

    Dialog that edits the Ipx properties.
    
    Paul Mayfield, 10/9/97
*/

#ifndef __rassrvui_ipxui_h
#define __rassrvui_ipxui_h

#include "protedit.h"

// Brings up a modal dialog that allows the editing of Ipx parameters
// specific to the dialup server.  When this function completes, the 
// parameters are stored in pParams, and pbCommit is set to TRUE if the
// parameters are supposed to be saved to the system (i.e. OK was pressed)
DWORD IpxEditProperties(HWND hwndParent, PROT_EDIT_DATA * pEditData, BOOL * pbCommit);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\miscdb.c ===
/*
    File    Miscdb.c

    Implementation of the miscellaneous settings database.

    Paul Mayfield, 10/8/97
*/

#include "rassrv.h"
#include "miscdb.h"
#include <stdlib.h>

// ===================================
// Definitions of the database objects
// ===================================
#define FLAG_MULTILINK 1
#define FLAG_SHOWICON 2

typedef struct _RASSRV_MISCDB {
    BOOL bMultilinkEnabled;
    BOOL bShowIcons;
    BOOL bFlushOnClose;
    BOOL bIsServer;
    DWORD dwOrigFlags;
    DWORD dwLogLevel;
    BOOL bLogLevelDirty;
} RASSRV_MISCDB;

// Opens a handle to the database of general tab values
DWORD miscOpenDatabase(HANDLE * hMiscDatabase) {
    RASSRV_MISCDB * This;
    DWORD dwErr, i;
    
    if (!hMiscDatabase)
        return ERROR_INVALID_PARAMETER;

    // Allocate the database cache
    if ((This = RassrvAlloc (sizeof(RASSRV_MISCDB), TRUE)) == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Initialize the values from the system
    miscReloadDatabase((HANDLE)This);

    // Record the original flag state for efficiency
    This->dwOrigFlags = 0;
    if (This->bMultilinkEnabled)
        This->dwOrigFlags |= FLAG_MULTILINK;
    if (This->bShowIcons)
        This->dwOrigFlags |= FLAG_SHOWICON;

    // Return the handle
    *hMiscDatabase = (HANDLE)This;
    This->bFlushOnClose = FALSE;

    return NO_ERROR;
}

// Closes the general database and flushes any changes 
// to the system when bFlushOnClose is TRUE
DWORD miscCloseDatabase(HANDLE hMiscDatabase) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    
    // Flush if requested
    if (This->bFlushOnClose)
        miscFlushDatabase(hMiscDatabase);
    
    // Free up the database cache
    RassrvFree(This);

    return NO_ERROR;
}

BOOL miscFlagsAreSame(BOOL bVal, DWORD dwFlags, DWORD dwFlag) {
    if ((bVal != 0) && ((dwFlags & dwFlag) != 0))
        return TRUE;
    if ((bVal == 0) && ((dwFlags & dwFlag) == 0))
        return TRUE;
    return FALSE;
}


//for whistler bug 143344       gangz
//
DWORD
miscTrayNotifyIconChangeCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    HnPMParamsConnectionCleanUp(pInfo);

    return NO_ERROR;
}//miscTrayNotifyIconChangeCleanUp()


//Notify that the "Show Icon in Notification area" has changed
//Used by GenCommand() in GenTab.c
//
DWORD
miscTrayNotifyIconChange()
{
    INetConnectionSysTray * pSysTray = NULL;
    HNPMParams Info;
    LPHNPMParams pInfo;
    HRESULT hr;
    DWORD dwErr = NO_ERROR, i;
    static const CLSID CLSID_InboundConnection=
    {0xBA126AD9,0x2166,0x11D1,{0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E}};


    TRACE("miscTrayNotifyIconChanged");

    ZeroMemory(&Info, sizeof(Info));
    pInfo = &Info;

    do{
        dwErr = HnPMConnectionEnum(pInfo);

        if ( NO_ERROR != dwErr )
        {
            TRACE("miscTrayNotifyIconChange: HnPMConnectionEnum failed!");
            break;
        }

        TRACE1("miscTrayNotifyIconChange: %l Connections detected", pInfo->ConnCount);

        //Set up PortMapping for each connection
        //
        for ( i = 0; i < pInfo->ConnCount; i++ )
        {
            //won't do PortMapping for Incoming connections
            //
            if ( pInfo->ConnPropTable )
            {
            //define the class id for Incoming connections
            // reference to /nt/net/config/shell/wanui/rasui.cpp

               if( IsEqualCLSID( 
                    &CLSID_InboundConnection, 
                    &(pInfo->ConnPropTable[i].clsidThisObject) ) )
               {
                    hr = INetConnection_QueryInterface(
                            pInfo->ConnArray[i],
                            &IID_INetConnectionSysTray,
                            &pSysTray);

                    ASSERT(pSysTray);

                    if ( !SUCCEEDED(hr))
                    {
                        TRACE("miscTrayNotifyIconChange: Query pSysTray failed!");
                        dwErr = ERROR_CAN_NOT_COMPLETE;
                        break;
                    }

                    if( !pSysTray )
                    {
                        TRACE("miscTrayNotifyIconChange: pSysTray get NULL pointer!");
                        dwErr = ERROR_CAN_NOT_COMPLETE;
                        break;
                    }

                    INetConnectionSysTray_IconStateChanged(pSysTray);
                    break;
               }
            }
        }//end of for(;;)

        if(pSysTray)
        {
            INetConnectionSysTray_Release(pSysTray);
        }

    }
    while(FALSE);

    miscTrayNotifyIconChangeCleanUp(pInfo);

    return dwErr;
}//end of miscTrayNotifyIconChange()


// Commits any changes made to the general tab values 
DWORD miscFlushDatabase(HANDLE hMiscDatabase) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    //For whistler bug 524777
    DWORD dwErr = NO_ERROR, dwRet = NO_ERROR;

    // Flush out the multilink value
    if (!miscFlagsAreSame(This->bMultilinkEnabled, This->dwOrigFlags,  FLAG_MULTILINK)) {
        dwErr = RasSrvSetMultilink(This->bMultilinkEnabled);
        if (dwErr != NO_ERROR) {
            DbgOutputTrace("miscFlushDatabase: Can't commit multilink 0x%08x", dwErr);
            dwRet = dwErr;
        }
    }

    // Flush the show icon setting
    if (!miscFlagsAreSame(This->bShowIcons, This->dwOrigFlags,  FLAG_SHOWICON)) 
    {
        dwErr = RasSrvSetIconShow(This->bShowIcons);
        if (dwErr != NO_ERROR) {
            DbgOutputTrace("miscFlushDatabase: Can't commit show icons 0x%08x", dwErr);
            dwRet = dwErr;
        }

       //for whistler bug 143344    gangz
       //update the tray icon on the taskbar
       //This notification should be done after RasSrvSetIconShow()
       //
       dwErr = miscTrayNotifyIconChange();
        
       TRACE1("miscFlushDatabase: %s", NO_ERROR == dwErr ?
                                   "miscTrayNotifyIconChange succeeded!" :
                                   "miscTrayNotifyIconChange failed!");
    }

    // Flush the log level setting as appropriate
    if (This->bLogLevelDirty)
    {
        RasSrvSetLogLevel(This->dwLogLevel); 
    }

    return dwRet;
}

// Rollsback any changes made to the general tab values
DWORD miscRollbackDatabase(HANDLE hMiscDatabase) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    This->bFlushOnClose = FALSE;
    return NO_ERROR;
}

// Reloads any values for the general tab from disk
DWORD miscReloadDatabase(HANDLE hMiscDatabase) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    DWORD dwRet = NO_ERROR, dwErr, dwFlags = 0;

    // Initialize the product type
    dwErr = RasSrvGetMachineFlags (&dwFlags);
    if (dwErr != NO_ERROR) 
    {
        DbgOutputTrace("RasSrvGetMachineFlags: Failed %x", dwErr);
        dwRet = dwErr;
    }

    // Initialize what we can from the flags
    //
    This->bIsServer = !!(dwFlags & RASSRVUI_MACHINE_F_Server);

    // Initialize the show icons setting
    //
    dwErr = RasSrvGetIconShow(&This->bShowIcons);
    if (dwErr != NO_ERROR) 
    {
        DbgOutputTrace("miscReloadDatabase: Can't get iconshow 0x%08x", dwErr);
        dwRet = dwErr;
    }
    
    // Initialize multilink setting
    //
    dwErr = RasSrvGetMultilink(&(This->bMultilinkEnabled));
    if (dwErr != NO_ERROR) 
    {
        DbgOutputTrace("miscReloadDatabase: Can't get encryption 0x%08x", dwErr);
        dwRet = dwErr;
    }

    return dwRet;
}

// Gets the multilink enable status
DWORD miscGetMultilinkEnable(HANDLE hMiscDatabase, BOOL * pbEnabled) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This || !pbEnabled)
        return ERROR_INVALID_PARAMETER;
    
    if (!pbEnabled)
        return ERROR_INVALID_HANDLE;

    *pbEnabled = This->bMultilinkEnabled;

    return NO_ERROR;
}

// Sets the multilink enable status
DWORD miscSetMultilinkEnable(HANDLE hMiscDatabase, BOOL bEnable) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    This->bMultilinkEnabled = bEnable;

    return NO_ERROR;
}

// Gets the enable status of the "Show icons in the task bar" check box
DWORD miscGetIconEnable(HANDLE hMiscDatabase, BOOL * pbEnabled) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This || !pbEnabled)
        return ERROR_INVALID_PARAMETER;

    *pbEnabled = This->bShowIcons;

    return NO_ERROR;
}

// Sets the enable status of the "Show icons in the task bar" check box
DWORD miscSetIconEnable(HANDLE hMiscDatabase, BOOL bEnable) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    This->bShowIcons = bEnable;

    return NO_ERROR;
}

// Tells whether this is nt workstation or nt server
DWORD miscGetProductType(HANDLE hMiscDatabase, PBOOL pbIsServer) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This || !pbIsServer)
        return ERROR_INVALID_PARAMETER;

    *pbIsServer = This->bIsServer;

    return NO_ERROR;
}

// Turns on ras error and warning logging
DWORD 
miscSetRasLogLevel(
    IN HANDLE hMiscDatabase,
    IN DWORD dwLevel)
{
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    This->dwLogLevel = dwLevel;
    This->bLogLevelDirty = TRUE;

    return NO_ERROR;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\miscdb.h ===
/*
	File	miscdb

	The miscellaneous settings database definition for the dialup server ui.

	Paul Mayfield, 10/8/97
*/

#ifndef __miscdb_h
#define __miscdb_h

#include <windows.h>

#define MISCDB_RAS_LEVEL_ERR_AND_WARN 0x2

// Opens a handle to the database of devices
DWORD miscOpenDatabase(HANDLE * hMiscDatabase);

// Closes the general database and flushes any changes 
// to the system when bFlush is TRUE
DWORD miscCloseDatabase(HANDLE hMiscDatabase);

// Commits any changes made to the general tab values 
DWORD miscFlushDatabase(HANDLE hMiscDatabase);

// Rollsback any changes made to the general tab values
DWORD miscRollbackDatabase(HANDLE hMiscDatabase);

// Reloads any values for the general tab from disk
DWORD miscReloadDatabase(HANDLE hMiscDatabase);

// Gets the multilink enable status
DWORD miscGetMultilinkEnable(HANDLE hMiscDatabase, BOOL * pbEnabled);

// Sets the multilink enable status
DWORD miscSetMultilinkEnable(HANDLE hMiscDatabase, BOOL bEnable);

// Gets the enable status of the "Show icons in the task bar" check box
DWORD miscGetIconEnable(HANDLE hMiscDatabase, BOOL * pbEnabled);

// Sets the enable status of the "Show icons in the task bar" check box
DWORD miscSetIconEnable(HANDLE hMiscDatabase, BOOL bEnable);

// Tells whether this is nt workstation or nt server
DWORD miscGetProductType(HANDLE hMiscDatabase, PBOOL pbIsServer);

// Turns on ras error and warning logging
DWORD miscSetRasLogLevel(HANDLE hMiscDatabase, DWORD dwLevel);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\multilink.c ===
/*
    File    multilink.c

    Implements the multilink dialog display by the connections
    status monitor

    Paul Mayfield 10/17/97
*/

#include "rassrv.h"

#define MTL_TIMER_ID 1

typedef struct _MULTILINKDATA {
    HANDLE hConn;
    RAS_PORT_0 * pPorts;
    RAS_PORT_0 * pCurPort0;
    RAS_PORT_1 * pCurPort1;
    DWORD dwCurPort;
    DWORD dwPortCount;
} MULTILINKDATA;

// This dialog procedure responds to messages send to the 
// mtleral tab.
BOOL CALLBACK mtlUiDialogProc(HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

// Fills in the property sheet structure with the information required to display
// the multilink tab.
DWORD mtlUiGetPropertyPage(LPPROPSHEETPAGE ppage, DWORD dwUserData) {
    MULTILINKDATA * mld;

    // Create the multilink data to send
    mld = (MULTILINKDATA*) malloc (sizeof (MULTILINKDATA));
    if (mld)
    {
        ZeroMemory(mld, sizeof(MULTILINKDATA));
        mld->hConn = (HANDLE)dwUserData;

        // Initialize
        ZeroMemory(ppage, sizeof(LPPROPSHEETPAGE));

        // Fill in the values
        ppage->dwSize      = sizeof(PROPSHEETPAGE);
        ppage->hInstance   = Globals.hInstDll;
        ppage->pszTemplate = MAKEINTRESOURCE(IDD_MULTILINKTAB);
        ppage->pfnDlgProc  = mtlUiDialogProc;
        ppage->pfnCallback = NULL;
        ppage->dwFlags     = 0;
        ppage->lParam      = (LPARAM)mld;
    }
    else
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}

// Error reporting
void mtlUiErrorMessageBox(HWND hwnd, DWORD err) {
    WCHAR buf[1024];
    FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,NULL,err,(DWORD)NULL,buf,1024,NULL);
    MessageBoxW(hwnd, 
                buf, 
                L"Dialup Server Configuration Error", 
                MB_OK | MB_ICONERROR | MB_APPLMODAL);
}

// Formats an unsigned number with commas, etc.  
PWCHAR mtlFormatDword(DWORD dwVal) {
    static WCHAR ret[64];
    WCHAR num[64];
    int i = 0, tmp, j, k;

    if (dwVal == 0) {
        ret[0] = (WCHAR)'0';
        ret[1] = (WCHAR)0;
        return ret;
    }

    // Get the value in reverse order
    while (dwVal) {
        tmp = dwVal % 10;
        dwVal /= 10;
        num[i++] = (WCHAR)('0' + tmp);
    }
    num[i] = (WCHAR)0;
    
    // Add commas
    k = 0;
    for (j = 0; j < i; j++) {
        if (k%4 == 3)
            ret[k++] = (WCHAR)',';
        ret[k++] = num[j];
    }
    ret[k] = 0;
    k--;
        
    // reverse the string
    for (j=0; j < (k+1)/2; j++) {
        tmp = ret[j];
        ret[j] = ret[k-j];
        ret[k-j] = tmp;
    }

    return ret;
}

// Formats a string representing the time that a connection is connected
PWCHAR mtlFormatTime(DWORD dwSeconds) {
    DWORD dwSec, dwHr, dwMin;
    static WCHAR ret[16];

    dwSec = dwSeconds % 60;
    dwMin = dwSeconds / 60;
    dwHr  = dwSeconds / 3600;
    
    wsprintfW(ret, L"%02d:%02d:%02d", dwHr, dwMin, dwSec);

    return ret;
}

// Formats a string to display connection speed
PWCHAR mtlFormatSpeed(DWORD dwBps) {
    static WCHAR ret[64];

    wsprintfW(ret, L"%s bps", mtlFormatDword(dwBps));
    return ret;
}

// The list view control requires the list of icons it will display
// to be provided up front.  This function initializes and presents
// this list.
DWORD mtlUiInitializeListViewIcons(HWND hwndLV) {
    return NO_ERROR;
}

// Returns the index of an to display icon based on the type of incoming
// connection and whether or not it should be checked.
int mtlGetIconIndex(DWORD dwType, BOOL bEnabled) {
    if (bEnabled)
        return dwType + 1;
    return dwType;
}

// Fills in the user list view with the names of the users stored in the 
// user database provide.  Also, initializes the checked/unchecked status
// of each user.
DWORD mtlUiFillPortList(HWND hwndLV, MULTILINKDATA * mld) {
    LV_ITEM lvi;
    DWORD i, dwErr, dwType;
    char pszAName[1024];

    // Add the images that this list item will display
    dwErr = mtlUiInitializeListViewIcons(hwndLV);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Initialize the list item
    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_TEXT;
    // lvi.mask = LVIF_TEXT | LVIF_IMAGE;

    // Looop through all of the users adding their names as we go
    for (i=0; i<mld->dwPortCount; i++) {
        //WideCharToMultiByte(CP_ACP,0,mld->pPorts[i].wszPortName,-1,pszAName,1024,NULL,NULL);
        lvi.iItem = i;
        //lvi.pszText = pszAName;
        lvi.pszText = mld->pPorts[i].wszPortName;
        //lvi.cchTextMax = strlen(pszAName) + 1;
        lvi.cchTextMax = wcslen(mld->pPorts[i].wszPortName) + 1;
        ListView_InsertItem(hwndLV,&lvi);
    }
    
    return NO_ERROR;
}

// Loads the current port
DWORD mtlLoadCurrentPort(MULTILINKDATA * mld) {
    DWORD dwErr;

    // Cleanup the old data
    if (mld->pCurPort0)
        MprAdminBufferFree(mld->pCurPort0);
    if (mld->pCurPort1)
        MprAdminBufferFree(mld->pCurPort1);

    dwErr = MprAdminPortGetInfo(Globals.hRasServer,
                                1,
                                mld->pPorts[mld->dwCurPort].hPort,
                                (LPBYTE*)&mld->pCurPort1);

    dwErr = MprAdminPortGetInfo(Globals.hRasServer,
                                0,
                                mld->pPorts[mld->dwCurPort].hPort,
                                (LPBYTE*)&mld->pCurPort0);

    return dwErr;
}

// Initializes the multilink data
DWORD mtlLoadPortData(MULTILINKDATA * mld, DWORD dwCur) {
    DWORD dwTot, dwErr;

    // Set the current port and load the data
    mld->dwCurPort = dwCur;

    // Cleanup
    if (mld->pPorts)
        MprAdminBufferFree(mld->pPorts);

    // Get the count of ports
    dwErr = MprAdminPortEnum (Globals.hRasServer, 
                              0, 
                              mld->hConn, 
                              (LPBYTE*)&mld->pPorts,
                              1024*1024,
                              &mld->dwPortCount,
                              &dwTot,
                              NULL);
    if (dwErr != NO_ERROR)
        return dwErr;

    if (mld->dwPortCount) {
        dwErr = mtlLoadCurrentPort(mld);
        if (dwErr != NO_ERROR) 
            return NO_ERROR;
    }

    return NO_ERROR;
}

// Updates the dialog with the current statistics stored in mld
DWORD mtlUpdateStats(HWND hwndDlg, MULTILINKDATA * mld) {
    WCHAR buf[128];
    DWORD dwErr = 0;

    // Mark the bytes in and out
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_BYTESIN), mtlFormatDword(mld->pCurPort1->dwBytesRcved));
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_BYTESOUT), mtlFormatDword(mld->pCurPort1->dwBytesXmited));

    // Mark the compression ratios
    wsprintfW(buf, L"%d%%", mld->pCurPort1->dwCompressionRatioIn);
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_COMPIN), buf); 
    wsprintfW(buf, L"%d%%", mld->pCurPort1->dwCompressionRatioOut);
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_COMPOUT), buf); 

    // Mark the errors
    dwErr = mld->pCurPort1->dwCrcErr +
            mld->pCurPort1->dwTimeoutErr +
            mld->pCurPort1->dwAlignmentErr +
            mld->pCurPort1->dwHardwareOverrunErr +
            mld->pCurPort1->dwFramingErr +
            mld->pCurPort1->dwBufferOverrunErr;
    wsprintfW(buf, L"%d", dwErr);
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_ERRORIN), buf);
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_ERROROUT), L"0");

    // Mark the duration
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_DURATION), 
                   mtlFormatTime(mld->pCurPort0->dwConnectDuration));

    // Mark the speed
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_SPEED), 
                   mtlFormatSpeed(mld->pCurPort1->dwLineSpeed));

    return NO_ERROR;
}

// Initializes the mtleral tab.  By now a handle to the mtleral database
// has been placed in the user data of the dialog
DWORD mtlUiInitializeDialog(HWND hwndDlg, WPARAM wParam, LPARAM lParam) {
    DWORD dwErr, dwCount;
    BOOL bFlag;
    HANDLE hConn, hMiscDatabase;
    HWND hwndLV;
    LV_COLUMN lvc;
    MULTILINKDATA * mld;
    LPPROPSHEETPAGE ppage;
 
    // Set the Timer
    SetTimer(hwndDlg, MTL_TIMER_ID, 500, NULL);

    // Set the data for this dialog
    ppage = (LPPROPSHEETPAGE)lParam;
    mld = (MULTILINKDATA*)(ppage->lParam);
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)mld);

    // Initialize all of the values in the multilink data structure
    mtlLoadPortData(mld, 0);

    // Cause the list view to send LV_EXTENSION_??? messages and to do full
    // row select
    hwndLV = GetDlgItem(hwndDlg, IDC_PORTLIST);
    if (hwndLV)
    {
        lvxExtend(hwndLV);
        ListView_SetExtendedListViewStyle(hwndLV, LVS_EX_FULLROWSELECT);

        // Fill in the list view will all available mtlices
        mtlUiFillPortList(hwndLV, mld);

        // Select the first item in the list view if any items exist
        dwCount = mld->dwPortCount;
        if (dwCount)
            ListView_SetItemState(hwndLV, 0, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);

        // Add a colum so that we'll display in report view
        lvc.mask = LVCF_FMT;
        lvc.fmt = LVCFMT_LEFT;
        ListView_InsertColumn(hwndLV,0,&lvc);
        ListView_SetColumnWidth(hwndLV, 0, LVSCW_AUTOSIZE_USEHEADER);
    }

    // Update the statistics
    mtlUpdateStats(hwndDlg, mld);

    return NO_ERROR;
}

// Updates the current port 
DWORD mtlUpdateCurPort(MULTILINKDATA * mld, DWORD dwNewPort) {
    mld->dwCurPort = dwNewPort;
    return mtlLoadCurrentPort(mld);
}

// Hangsup the current port
DWORD mtlHangup(HWND hwndDlg, MULTILINKDATA * mld) {
    DWORD dwErr;
    HWND hwndLV = GetDlgItem(hwndDlg, IDC_PORTLIST);

    if ((dwErr = MprAdminPortDisconnect(Globals.hRasServer, mld->pCurPort0->hPort)) != NO_ERROR)
        return dwErr;

    // There are no more ports if mtlLoadPortData returns an error
    if ((dwErr = mtlLoadPortData(mld, 0)) != NO_ERROR) 
        DestroyWindow(hwndDlg);
    else {
        if (hwndLV)
        {
            ListView_DeleteAllItems(hwndLV);
            mtlUiFillPortList(hwndLV, mld);
            ListView_SetItemState(hwndLV, 0, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);
        }
        mtlUpdateStats(hwndDlg, mld);
    }

    return NO_ERROR;
}


// Cleansup the mtleral tab as it is being destroyed
DWORD mtlUiCleanupDialog(HWND hwndDlg, WPARAM wParam, LPARAM lParam) {
    // Cleanup the data
    MULTILINKDATA * mld = (MULTILINKDATA *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    if (mld) {
        if (mld->pCurPort0)
            MprAdminBufferFree(mld->pCurPort0);
        if (mld->pCurPort1)
            MprAdminBufferFree(mld->pCurPort1);
        free(mld);
    }

    // Stop the timer
    KillTimer(hwndDlg, MTL_TIMER_ID);

    return NO_ERROR;
}

// This is the dialog procedure that responds to messages sent to the 
// mtleral tab.
BOOL CALLBACK mtlUiDialogProc(HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam) {
    NMHDR* pNotifyData;
    NM_LISTVIEW* pLvNotifyData;
    LV_KEYDOWN* pLvKeyDown;
    MULTILINKDATA * mld = (MULTILINKDATA*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    // Process other messages as normal
    switch (uMsg) {
        case WM_INITDIALOG:
            return mtlUiInitializeDialog(hwndDlg, wParam, lParam);

        case WM_NOTIFY:
            pNotifyData = (NMHDR*)lParam;
            switch (pNotifyData->code) {
                // The property sheet apply button was pressed
                case PSN_APPLY:                    
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;

                // The property sheet cancel was pressed
                case PSN_RESET:                    
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                    break;

                // An item is changing state, keep track of any newly
                // selected item so space bar can toggle him.
                case LVN_ITEMCHANGING:
                    pLvNotifyData = (NM_LISTVIEW*)lParam;
                    if (pLvNotifyData->uNewState & LVIS_SELECTED) {
                        mtlUpdateCurPort(mld, pLvNotifyData->iItem);
                        mtlUpdateStats(hwndDlg, mld);
                    }
                    break;
            }
            break;

        // Called when the timer expires
        case WM_TIMER:
            mtlLoadCurrentPort(mld);
            mtlUpdateStats(hwndDlg, mld);
            break;

        // This is a custom message that we defined to toggle dialin permission
        // when the mouse is clicked on a user.
        case LV_EXTENSION_ITEMCLICKED:
        case LV_EXTENSION_ITEMDBLCLICKED:
            mtlUpdateCurPort(mld, wParam);
            mtlUpdateStats(hwndDlg, mld);
            break;

        case WM_COMMAND:
            if (wParam == IDC_HANGUP) 
                mtlHangup(hwndDlg, mld);
            break;

        // Cleanup the work done at WM_INITDIALOG 
        case WM_DESTROY:                           
            mtlUiCleanupDialog(hwndDlg, wParam, lParam);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\hnportmapping.h ===
/*
    File    hnportmapping.h

    Definition of the set port mapping functions for intergrating incoming
    connection with personal firewall, for whistler bug#123769

    Gang Zhao 11/6/2000
*/

#ifndef __rassrvui_hnportmapping_h
#define __rassrvui_hnportmapping_h

#include <windows.h>
#include <hnetcfg.h>


typedef struct {
    //An Array to store Connections of INetConnection * type
    //
    INetConnection  **      ConnArray;

    //Number of Connections found
    DWORD       ConnCount;

    //An Array to store connection properties
    //
    NETCON_PROPERTIES*      ConnPropTable;

    //Connection Manager used to generate another member EnumCon
    //
    INetConnectionManager*  ConnMan;

    //Connection Enumerator
    //
    IEnumNetConnection*     EnumCon;

    //Connection on which to Set Up PortMapping right now
    // pNetConnection and pGuid can both represent connections
    //but only one of them is used and valid for portmapping at each time
    //
    INetConnection    *     pNetConnection;

    //The Guid of the current connection on which to Set Up PortMapping right now
    //
    GUID *      pGuid;

    //Converted from pNetConnection, the PortMapping needs
    //the connection to be of type (IHNetConnection *)
    //In all, Enumerate Connection will return connections of
    // INetConnection * type, PortMapping operations require 
    //IHNetConnection * type
    //
    IHNetConnection   *     pHNetConn;

    //High level COM interface to generate pSettings
    //
    IHNetCfgMgr           * pHNetCfgMgr;

    //Used to generate pEnumPMP(PortMapping protocol enumerator)
    //
    IHNetProtocolSettings * pSettings;
    
    //PortMapping protocol enumerator, to enumerate existing
    //PortMapping protocols like (PPTP, L2TP, IKE (if exist)), FTP, ....
    //
    IEnumHNetPortMappingProtocols* pEnumPMP;


    //PortMapping Protocol for PPTP
    //
    IHNetPortMappingProtocol * pProtocolPPTP;

    //PortMapping Protocol for L2TP
    //
    IHNetPortMappingProtocol * pProtocolL2TP;
    
    //PortMapping Protocol for IKE
    //
    IHNetPortMappingProtocol * pProtocolIKE;

    //PortMapping Protocol for IKE
    //
    IHNetPortMappingProtocol * pProtocolNAT_T;  // IKE Negotiation
    
    //Title for PPTP, read from resource file
    //
    WCHAR * pwszTitlePPTP;

    //Title for L2TP, read from resource file
    //
    WCHAR * pwszTitleL2TP;

    //Title for IKE, read from resource file
    //
    WCHAR * pwszTitleIKE;

    //Title for Nat-Traveral, read from resource file
    WCHAR * pwszTitleNAT_T;

    //Title for PortMapping address, read from resource file
    //currently, it is always 127.0.0.1 loopback address
    //
    TCHAR * pszLoopbackAddr;

    //Indicating if COM is already initialized
    //
    BOOL fComInitialized;

    //Indicating if we need to do the COM un-initialization
    BOOL fCleanupOle;

} HNPMParams, * LPHNPMParams;


//Define callback function type for Pick Protocol 
typedef  DWORD (APIENTRY * PFNHNPMPICKPROTOCOL) ( LPHNPMParams, IHNetPortMappingProtocol* , WCHAR *, UCHAR, USHORT );


//When Using CoSetProxyBlanket, we should set both the interface 
//and the IUnknown interface queried from it
//
HRESULT
HnPMSetProxyBlanket (
    IUnknown* pUnk);


//Do the CoInitialize() COM if necessary
//Set up cleanup flag and initialized flag
//
DWORD
HnPMInit(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMCleanUp(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMParamsInitParameterCheck(
    IN  LPHNPMParams pInfo);

HnPMParamsInit(
    IN OUT  LPHNPMParams pInfo);

DWORD
HnPMParamsCleanUp(
    IN OUT  LPHNPMParams pInfo);

DWORD
HnPMCfgMgrInit(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMCfgMgrCleanUp(
        IN OUT LPHNPMParams pInfo);


DWORD
HnPMConnectionEnumInit(
    IN LPHNPMParams pInfo);

DWORD
HnPMConnectionEnumCleanUp(
    IN LPHNPMParams pInfo);

//Return all the connections like DUN, VPN, LAN and Incoming Connection
//and the properties of them
//
DWORD
HnPMConnectionEnum(
    IN LPHNPMParams pInfo);



DWORD
HnPMPickProtcolParameterCheck(
    IN LPHNPMParams pInfo);

//Pick PortMapping protocols: PPTP, L2TP, IKE
//
DWORD
HnPMPickProtocol(
    IN OUT LPHNPMParams pInfo,
    IN IHNetPortMappingProtocol * pProtocolTemp,
    IN WCHAR * pszwName,
    IN UCHAR   uchIPProtocol,
    IN USHORT  usPort );


DWORD
HnPMPProtoclEnumParameterCheck(
    IN LPHNPMParams pInfo);

//Enumerate all existing Port Mapping protocols
//
DWORD
HnPMProtocolEnum(
        IN OUT LPHNPMParams pInfo,
        IN PFNHNPMPICKPROTOCOL pfnPickProtocolCallBack
        );

DWORD
HnPMCreatePorotocolParameterCheck(
        IN LPHNPMParams pInfo);

//Create PortMapping Protocols for PPTP, L2TP, IKE
// if they are not found by HnPMPProtocolEnum()
//
DWORD
HnPMCreateProtocol(
        IN OUT LPHNPMParams pInfo);


//Set up a single PortMapping protocol on
//a single connection
//
DWORD
HnPMSetSinglePMForSingleConnection(
    IN  IHNetConnection * pHNetConn,
    IN  IHNetPortMappingProtocol * pProtocol,
    IN  TCHAR * pszLoopbackAddr,
    IN  BOOL fEnabled);


//Clean up the ConnArray and ConnPropTable items
//in the HNPMParams struct
//
DWORD
HnPMParamsConnectionCleanUp(
        IN OUT LPHNPMParams pInfo);


//Set up the PortMapping of PPTP, L2TP for a single
//Connection
//
DWORD
HnPMConfigureAllPMForSingleConnection(
        IN OUT LPHNPMParams pInfo,
        BOOL fEnabled);

DWORD
HnPMConfigureAllPMForSingleConnectionParameterCheck(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMConfigureSingleConnectionInitParameterCheck(
    IN LPHNPMParams pInfo );

DWORD
HnPMConfigureSingleConnectionInit(
    IN OUT  LPHNPMParams pInfo);

DWORD
HnPMConfigureSingleConnectionCleanUp(
        IN OUT LPHNPMParams pInfo);

//Set the PortMapping on a single connection
//According to pInfo->pNetConnection 
//
DWORD
HnPMConfigureSingleConnection(
        IN OUT LPHNPMParams pInfo,
        BOOL fEnabled);

//Delete the PortMapping protocols:PPTP, L2TP, IKE
//
DWORD
HnPMDeletePortMapping();

DWORD
HnPMDeletePortMappingInit(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMDeletePortMappingCleanUp(
        IN OUT LPHNPMParams pInfo);


DWORD
HnPMConfigureAllConnectionsInit(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMConfigureAllConnectionsCleanUp(
        IN OUT LPHNPMParams pInfo);

//
//Set up the PortMapping of PPTP, L2TP for a 
//group of Connections
//
DWORD
HnPMConfigureAllConnections( 
    IN BOOL fEnabled );


//Configure Port Mapping on a single connection
//
DWORD
HnPMConfigureSingleConnectionGUID(
    IN GUID * pGuid,
    IN BOOL fEnabled);


DWORD
HnPMConfigureSingleConnectionGUIDInit(
        IN OUT LPHNPMParams pInfo,
        GUID * pGuid);


DWORD
HnPMConfigureSingleConnectionGUIDCleanUp(
        IN OUT LPHNPMParams pInfo);


//Set up the port mapping for only one
//connection according to its GUID only when
//Incoming Connection exists and
//the VPN is enabled
//
DWORD
HnPMConfigureSingleConnectionGUIDIfVpnEnabled(
     GUID* pGuid,
     BOOL fDual,
     HANDLE hDatabase);

//Set up the port mapping on all connections
//only when Incoming Connection exists and
//the VPN is enabled
//
DWORD
HnPMConfigureIfVpnEnabled(
     BOOL fDual,
     HANDLE hDatabase);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\hnportmapping.c ===
/*
    File    hnportmapping.c

    Definition of the set port mapping functions for intergrating incoming
    connection with personal firewall, for whistler bug#123769

    Gang Zhao 11/6/2000
*/

#include "rassrv.h"
#include "precomp.h"

//When Using CoSetProxyBlanket, we should set both the interface 
//and the IUnknown interface queried from it
HRESULT
HnPMSetProxyBlanket (
    IUnknown* pUnk)
{
    HRESULT hr;
    TRACE("HnPMSetProxyBlanket()");

    hr = CoSetProxyBlanket (
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE);

    if(SUCCEEDED(hr)) 
    {
        IUnknown * pUnkSet = NULL;
        hr = IUnknown_QueryInterface(pUnk, &IID_IUnknown, (void**)&pUnkSet);
        if(SUCCEEDED(hr)) 
        {
            hr = CoSetProxyBlanket (
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE);
			if (pUnkSet)
			{
            	IUnknown_Release(pUnk);
            }
        }
    }


    return hr;
}
//end of HnPMSetProxyBlanket()

//Initialize function to do COM initialization
//
DWORD
HnPMInit(
        IN OUT LPHNPMParams pInfo)
{        
    HRESULT hr;
    DWORD dwErr = NO_ERROR;

    TRACE("HnPMInit");
        if( !pInfo->fComInitialized )
        {
            hr = CoInitializeEx(NULL, COINIT_MULTITHREADED|COINIT_DISABLE_OLE1DDE);
            if ( RPC_E_CHANGED_MODE == hr )
            {
                hr = CoInitializeEx (NULL, 
                        COINIT_APARTMENTTHREADED |COINIT_DISABLE_OLE1DDE);
            }
            
            if (FAILED(hr)) 
            {
                TRACE1("HnPMCfgMgrInit: CoInitializeEx=%x", hr);
                pInfo->fCleanupOle = FALSE;
                pInfo->fComInitialized = FALSE;
                dwErr= HRESULT_CODE(hr);
             }
             else
             {
                pInfo->fCleanupOle = TRUE;
                pInfo->fComInitialized = TRUE;
             }
        }

        return dwErr;
}//HnPMInit()


//CleanUp function to UnInitialize Com
//If needed
//
DWORD
HnPMCleanUp(
        IN OUT LPHNPMParams pInfo)
{

    if (pInfo->fCleanupOle)
    {
        CoUninitialize();
        pInfo->fComInitialized = FALSE;
        pInfo->fCleanupOle = FALSE;
    }

    return NO_ERROR;

}//HnPMCleanUp()


//Parameter Validation for pHNetCfgMgr
//
DWORD
HnPMParamsInitParameterCheck(
    IN  LPHNPMParams pInfo)
{
    ASSERT(pInfo->pHNetCfgMgr);

    if( !pInfo->pHNetCfgMgr )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

//Function:
//Initialize some members of HNPMParams structure
//pSettings, pEnumPMP, Read Title for PPTP, L2TP, IKE
//from resource file
//
//Requirements:
//pHNetCfgMgr should be valid
//
HnPMParamsInit(
    IN OUT  LPHNPMParams pInfo)
{

    HRESULT hr;
    DWORD dwErr = NO_ERROR;

    dwErr = HnPMParamsInitParameterCheck(pInfo);
    if ( NO_ERROR != dwErr)
    {
        TRACE("HnPMParamsInit: HnPMParamsInitParameterCheck failed!");
        return dwErr;
    }

    do{
        hr = IHNetCfgMgr_QueryInterface(
                pInfo->pHNetCfgMgr,
                &IID_IHNetProtocolSettings,
                &pInfo->pSettings
                );

        if (!SUCCEEDED(hr) )
        {
            TRACE("HnPMParamsInit: IHNetCfgMgr_QueryInterface failed");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }


        hr = IHNetProtocolSettings_EnumPortMappingProtocols(
                pInfo->pSettings,
                &pInfo->pEnumPMP
                );

        if ( !SUCCEEDED( hr ) )
        {
            TRACE("HnPMParamsInit: IHNetProtocolSettings_EnumPortMappingProotocols failed");

            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }


        //Get title, address information from resource
        //
        {
            TCHAR * pszTmp = NULL;

            pszTmp = PszFromId(Globals.hInstDll, SID_PPTP_Title);

            if(!pszTmp)
            {
                TRACE("HnPMParamsInit: Get PPTP_Title string failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pInfo->pwszTitlePPTP = StrDupWFromT(pszTmp);
            Free0(pszTmp);

            if( !pInfo->pwszTitlePPTP )
            {
                TRACE("HnPMParamsInit: PPTP_Title string Conversion failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pszTmp = PszFromId(Globals.hInstDll, SID_L2TP_Title);

            if(!pszTmp)
            {
                TRACE("HnPMParamsInit: Get L2TP_Title string failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pInfo->pwszTitleL2TP = StrDupWFromT(pszTmp);
            Free0(pszTmp);

            if( !pInfo->pwszTitleL2TP )
            {
                TRACE("HnPMParamsInit: L2TP_Title string Conversion failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pszTmp = PszFromId(Globals.hInstDll, SID_IKE_Title);

            if(!pszTmp)
            {
                TRACE("HnPMParamsInit: Get IKE_Title string failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pInfo->pwszTitleIKE = StrDupWFromT(pszTmp);
            Free0(pszTmp);

            if( !pInfo->pwszTitleIKE )
            {
                TRACE("HnPMParamsInit: IKE_Title string Conversion failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

	    //for .Net 690343
            pszTmp = PszFromId(Globals.hInstDll, SID_NAT_T_Title);

            if(!pszTmp)
            {
                TRACE("HnPMParamsInit: Get IKE_Title string failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pInfo->pwszTitleNAT_T= StrDupWFromT(pszTmp);
            Free0(pszTmp);

            if( !pInfo->pwszTitleNAT_T )
            {
                TRACE("HnPMParamsInit: NAT_T string Conversion failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pInfo->pszLoopbackAddr = PszFromId(Globals.hInstDll, SID_LoopbackAddr);

            if(!pInfo->pszLoopbackAddr)
            {
                TRACE("HnPMParamsInit: Get IKE_Title string failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }

    }while(FALSE);

    return dwErr;
}//HnPMParamsInit()

//Release pEnumPMP, pSettings
//Free memory for titles for PPTP, L2TP, IKE
//if allocated before
//
DWORD
HnPMParamsCleanUp(
    IN OUT  LPHNPMParams pInfo)
{
    if ( pInfo->pEnumPMP )
    {
        IEnumHNetPortMappingProtocols_Release( pInfo->pEnumPMP );
        pInfo->pEnumPMP = NULL;
    }

    if ( pInfo->pSettings ) 
    {
        IHNetProtocolSettings_Release( pInfo->pSettings );
        pInfo->pSettings = NULL;
    }


    if (pInfo->pwszTitlePPTP)
    {
        Free0(pInfo->pwszTitlePPTP);
        pInfo->pwszTitlePPTP = NULL;
    }

    if (pInfo->pwszTitleL2TP)
    {
        Free0(pInfo->pwszTitleL2TP);
        pInfo->pwszTitleL2TP = NULL;
    }

    if (pInfo->pwszTitleIKE)
    {
        Free0(pInfo->pwszTitleIKE);
        pInfo->pwszTitleIKE = NULL;
    }

   // for .net 690343
    if (pInfo->pwszTitleNAT_T)
    {
        Free0(pInfo->pwszTitleNAT_T);
        pInfo->pwszTitleNAT_T = NULL;
    }

    if (pInfo->pszLoopbackAddr)
    {
        Free0(pInfo->pszLoopbackAddr);
        pInfo->pszLoopbackAddr = NULL;
    }

    return NO_ERROR;
} //HnPMParamsCleanUp()


//Initialization function before Enumerate all connections of
// type (INetConnection * )
//
//Init connection manager ConnMan,
//Init Connection Enumerator EnumCon
//
DWORD
HnPMConnectionEnumInit(
    IN LPHNPMParams pInfo)
{
    DWORD dwErr = NO_ERROR;
    HRESULT hr;

    TRACE("HnPMConnectionEnumInit");
    do{
        //Do Com Initialization
        //
        dwErr = HnPMInit(pInfo);

        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConnectionEnumInit: HnPMCfgMgrInit failed!");
            break;
        }
            
        // Instantiate the connection manager
        //

        hr = CoCreateInstance(
                &CLSID_ConnectionManager,
                NULL,
                CLSCTX_SERVER,
                &IID_INetConnectionManager,
                (PVOID*)&pInfo->ConnMan
                );
     
        if (!SUCCEEDED(hr)) 
        {
            TRACE1("HnPMConnectionEnumInit: CoCreateInstance=%x", hr);
            pInfo->ConnMan = NULL; 
            dwErr = ERROR_CAN_NOT_COMPLETE; 
            break;
        }

        hr = HnPMSetProxyBlanket( (IUnknown*)pInfo->ConnMan );

        if (!SUCCEEDED(hr) && ( E_NOINTERFACE != hr )) 
        {
            TRACE1("HnPMConnectionEnumInit: HnPMSetProxyBlanket=%x for ConnMan", hr);
//            dwErr = ERROR_CAN_NOT_COMPLETE; 
//            break;
        }

        //
        // Instantiate a connection-enumerator
        //

        hr =
            INetConnectionManager_EnumConnections(
                pInfo->ConnMan,
                NCME_DEFAULT,
                &pInfo->EnumCon
                );

        if (!SUCCEEDED(hr)) 
        {
            TRACE1("HnPMConnectionEnumInit: EnumConnections=%x", hr);
            pInfo->EnumCon = NULL; 
            dwErr = ERROR_CAN_NOT_COMPLETE; 
            break;
        }


        hr = HnPMSetProxyBlanket( (IUnknown*)pInfo->EnumCon );

        if (!SUCCEEDED(hr) && ( E_NOINTERFACE != hr ) ) 
        {
            TRACE1("HnPMConnectionEnumInit: HnPMSetProxyBlanket=%x for EnumCon", hr);
         //   dwErr = ERROR_CAN_NOT_COMPLETE; 
         //   break;
        }
     }
     while(FALSE);

     return dwErr;
} //HnPMConnectionEnumInit()

//Connection Enumeration CleanUp
//Release EnumCon, and ConnMan
DWORD
HnPMConnectionEnumCleanUp(
    IN LPHNPMParams pInfo)
{
    TRACE("HnPMConnectionEnumCleanUp");
    if (pInfo->EnumCon) 
    { 
        IEnumNetConnection_Release(pInfo->EnumCon);
        pInfo->EnumCon = NULL;
    }

    if (pInfo->ConnMan) 
    { 
        INetConnectionManager_Release(pInfo->ConnMan); 
        pInfo->ConnMan = NULL;
    }

    HnPMCleanUp(pInfo);

    return NO_ERROR;
}


//Connection Enumeration function:
//Its Initialize function will do: 
//          COM initialized if needed
//          Init Connection Manager-- ConnMan
//          Init Connection Enumerator--EnumCon
//
//It returns: Array of connections found--ConnArray
//            Array of connection properties--ConnPropTable

//Its CleanUp function will do: 
//          COM un-initialize if needed
//          Release ConnMan
//          Release EnumCon
//                              
DWORD
HnPMConnectionEnum(
    IN LPHNPMParams pInfo)
{
    INetConnection *     ConnArray[32];
    INetConnection **    LocalConnArray = NULL;
    NETCON_PROPERTIES *  LocalConnPropTable = NULL;
    NETCON_PROPERTIES *  ConnProps = NULL;
    ULONG   LocalConnCount = 0, PerConnCount, i;
    DWORD   dwErr= NO_ERROR;
    HRESULT hr;

    TRACE("HnPMConnectionEnum() begins");

    i = 0;
    do {
        dwErr = HnPMConnectionEnumInit(pInfo);
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConnectionEnum: HnPMConnectionEnumInit failed!");
            break;
        }

        // Enumerate the connections of INetConnection type
        //
        for ( ; ; ) 
        {
            hr = IEnumNetConnection_Next(
                    pInfo->EnumCon,
                    Dimension(ConnArray),
                    ConnArray,
                    &PerConnCount
                    );

            if (!SUCCEEDED(hr) || !PerConnCount) 
            { 
                hr = S_OK; 
                break; 
            }
            // Allocate or reallocate the memory for storing
            // connections properties which we will return to the caller.
            //

            TRACE("Allocating memory for LocalConnPropTable");
            if (!LocalConnPropTable) 
            {
                LocalConnPropTable =
                    (NETCON_PROPERTIES*)
                        GlobalAlloc(
                            0,
                            PerConnCount * sizeof(NETCON_PROPERTIES)
                            );
            } 
            else 
            {
                PVOID Temp =
                    GlobalAlloc(
                        0,
                        (LocalConnCount + PerConnCount) * sizeof(NETCON_PROPERTIES) );

                if (Temp) 
                {
                    CopyMemory(
                        Temp,
                        LocalConnPropTable,
                        LocalConnCount * sizeof(NETCON_PROPERTIES));
                }

                GlobalFree(LocalConnPropTable);
                LocalConnPropTable = Temp;
            }

            // Allocate or reallocate the memory for storing
            // connections which we will return to the caller.
            //

            TRACE("Allocating memory for LocalConnArray");
            if (!LocalConnArray ) 
            {
                LocalConnArray = 
                (INetConnection**) GlobalAlloc( 0,
                            PerConnCount * sizeof(INetConnection *) );
            } 
            else 
            {
               INetConnection** Temp = 
                 (INetConnection**) GlobalAlloc( 0,
                             (LocalConnCount + PerConnCount) * 
                                sizeof(INetConnection *));

                if (Temp) 
                {
                    CopyMemory(
                        Temp,
                        LocalConnArray,
                        LocalConnCount * sizeof(INetConnection *) );
                }

                GlobalFree(LocalConnArray);
                LocalConnArray = Temp;
            }

            if (!LocalConnPropTable) 
            { 
                TRACE("No memory for LocalConnPropTable");
                dwErr = ERROR_NOT_ENOUGH_MEMORY; 
                break; 
            }

            if (!LocalConnArray) 
            { 
                TRACE("No memeory for LocalConnArray");
                dwErr = ERROR_NOT_ENOUGH_MEMORY; 
                break; 
            }

            TRACE1("HnPMConnectionEnum: PerConnCount=(%d)",PerConnCount);
            for (i=0; i< PerConnCount; i++)
            {
                LocalConnArray[LocalConnCount+i] = ConnArray[i];

                //Need to set up the proxy blanket for each conneciton
                //
                TRACE1("SetProxyBlanket for (%d) i", i);
                hr = HnPMSetProxyBlanket( (IUnknown*)ConnArray[i] );
                
                if (!SUCCEEDED(hr) && ( E_NOINTERFACE != hr ) ) 
                {
                    TRACE1("HnPMConnectionEnum:HnPMSetProxyBlanket error at (%d) connection!", i );
                    //Commented out for whistler bug 256921
                    //dwErr = ERROR_CAN_NOT_COMPLETE;
                    //break;
                }
                
                TRACE1("GetProperty for (%d)",i);

                hr = INetConnection_GetProperties(ConnArray[i], &ConnProps);

                ASSERT(ConnProps);
                if(!SUCCEEDED(hr))
                {
                    TRACE1("HnPMConnectionEnum:INetConnection_GetProperties error at (%d) connection!", i );
                    dwErr = ERROR_CAN_NOT_COMPLETE;
                    break;
                }

                LocalConnPropTable[LocalConnCount+i] = *ConnProps;
                LocalConnPropTable[LocalConnCount+i].pszwName = 
                                        StrDup(ConnProps->pszwName);

                LocalConnPropTable[LocalConnCount+i].pszwDeviceName =
                                        StrDup(ConnProps->pszwDeviceName);
                CoTaskMemFree(ConnProps);
                ConnProps = NULL;
            }

            if( dwErr )
            {
                break;
            }

            LocalConnCount += PerConnCount;

        } // end Enumerate items

        //
        //Add this line just in case we will add more code in the future
        //and to break out of the do...while block
        //
        if ( dwErr )
        {
           // For whistler bug 428307
           //
           if ( LocalConnArray )
           {
                GlobalFree(LocalConnArray);
           }

           if ( LocalConnPropTable )
           {
                GlobalFree(LocalConnPropTable);
           }
           
           break;
        }

    } while (FALSE);

    //Save connection Info
    if ( NO_ERROR == dwErr )
    {
        pInfo->ConnPropTable = LocalConnPropTable; 
        pInfo->ConnArray = LocalConnArray; 
        pInfo->ConnCount = LocalConnCount; 
    }


    HnPMConnectionEnumCleanUp(pInfo);

    TRACE("HnPMConnectionEnum ends");
    return dwErr;

}//end of HnPMConnectionEnum()

//Input parameter check for HnPMPickProtocol
//Requirement: 
//          All the protocol titles are valid
//
DWORD
HnPMPickProtcolParameterCheck(
    IN LPHNPMParams pInfo)
{
    ASSERT( pInfo->pwszTitlePPTP );
    ASSERT( pInfo->pwszTitleL2TP );
    ASSERT( pInfo->pwszTitleIKE );
    ASSERT( pInfo->pwszTitleNAT_T);

    if ( !pInfo->pwszTitlePPTP ||
         !pInfo->pwszTitleL2TP ||
         !pInfo->pwszTitleIKE  ||
         !pInfo->pwszTitleNAT_T )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    return NO_ERROR;
}


//Pick the PortMapping Protocols needed from all
//the PortMapping Protocols founded by HnPMProtocolEnum()
//
//Criteria: Match the---
//                  Protocol title
//                  IPProtocol values: TCP 6, UDP 17
//                  Transport Layer Port number: PPTP--1723
//                                               L2TP--1701
//                                               IKE---500
//
DWORD
HnPMPickProtocol(
    IN OUT LPHNPMParams pInfo,
    IN IHNetPortMappingProtocol * pProtocolTemp,
    IN WCHAR * pszwName,
    IN UCHAR   uchIPProtocol,
    IN USHORT  usPort )
{
    DWORD dwErr = NO_ERROR;
    
    dwErr = HnPMPickProtcolParameterCheck(pInfo);
    if ( NO_ERROR != dwErr )
    {
        TRACE("HnPMPickProtocol: HnPMPickProtcolParameterCheck failed!");
        return dwErr;
    }

    dwErr = ERROR_CONTINUE;

    if ( !pInfo->pProtocolPPTP &&
         NAT_PROTOCOL_TCP == uchIPProtocol   && 
         !lstrcmpW( pszwName, pInfo->pwszTitlePPTP ) &&
         1723 == usPort )
    {
        pInfo->pProtocolPPTP = pProtocolTemp;
        IHNetPortMappingProtocol_AddRef(pInfo->pProtocolPPTP);
        dwErr = ERROR_CONTINUE;
    }
    else if ( !pInfo->pProtocolL2TP &&
         NAT_PROTOCOL_UDP == uchIPProtocol   && 
         !lstrcmpW( pszwName, pInfo->pwszTitleL2TP ) &&
         1701 == usPort )
    {
        pInfo->pProtocolL2TP = pProtocolTemp;
        IHNetPortMappingProtocol_AddRef(pInfo->pProtocolL2TP);
        dwErr = ERROR_CONTINUE;
    }
    else if ( !pInfo->pProtocolIKE &&
         NAT_PROTOCOL_UDP == uchIPProtocol   && 
         !lstrcmpW( pszwName, pInfo->pwszTitleIKE ) &&
         500 == usPort )
    {
        pInfo->pProtocolIKE = pProtocolTemp;
        IHNetPortMappingProtocol_AddRef(pInfo->pProtocolIKE);
        dwErr = ERROR_CONTINUE;
    }
    else if ( !pInfo->pProtocolNAT_T &&
         NAT_PROTOCOL_UDP == uchIPProtocol   && 
         !lstrcmpW( pszwName, pInfo->pwszTitleNAT_T) &&
         4500 == usPort )
    {
        pInfo->pProtocolNAT_T = pProtocolTemp;
        IHNetPortMappingProtocol_AddRef(pInfo->pProtocolNAT_T);
        dwErr = ERROR_CONTINUE;
    }

    if ( pInfo->pProtocolPPTP && 
         pInfo->pProtocolL2TP && 
         pInfo->pProtocolIKE  &&
         pInfo->pProtocolNAT_T)
    {
        dwErr = NO_ERROR;
    }

    return dwErr;

}//HnPMPickProtocol()


//Parameter check for HnPMPProtocolEnum()
//
DWORD
HnPMPProtoclEnumParameterCheck(
    IN LPHNPMParams pInfo)
{
    ASSERT(pInfo->pEnumPMP);
    if( !pInfo->pEnumPMP )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

//Function:
//          (1) Enumerate all existing PortMappingProtocol
//          (2) then use the CallBack function or the defaulet HnPMPickProtocol
//              to pick suitable protocols
//              
//Requrement:
//           pInfo->pEnumPMP is valid
//
DWORD
HnPMProtocolEnum(
        IN OUT LPHNPMParams pInfo,
        IN PFNHNPMPICKPROTOCOL pfnPickProtocolCallBack
        )
{
    IHNetPortMappingProtocol *pProtocolTemp = NULL;
    ULONG PerProtocolCount;
    DWORD dwErr = NO_ERROR;
    HRESULT hr;
    UCHAR uchIPProtocol;
    USHORT usPort;
    WCHAR * pszwName = NULL;


    dwErr = HnPMPProtoclEnumParameterCheck(pInfo);
    if( NO_ERROR != dwErr )
    {
        TRACE("HnPMPProtocolEnum: HnPMPProtoclEnumParameterCheck failed!");
        return dwErr;
    }

    dwErr = ERROR_CONTINUE;
    do {
        hr = IEnumHNetPortMappingProtocols_Next(
                pInfo->pEnumPMP,
                1,
                &pProtocolTemp,
                &PerProtocolCount
                );

        if ( !SUCCEEDED(hr) || 1 != PerProtocolCount ) 
        { 
            TRACE("HnPMPProtocolEnum: EnumHNetPortMappingProtocols_Next failed");

            hr = S_OK; 
            break; 
         }

        hr = IHNetPortMappingProtocol_GetIPProtocol(
                pProtocolTemp,
                &uchIPProtocol
                );

        if (SUCCEEDED(hr) )
        {
            hr = IHNetPortMappingProtocol_GetPort(
                    pProtocolTemp,
                    &usPort
                    );
        }

        if ( SUCCEEDED(hr) )
        {
            hr = IHNetPortMappingProtocol_GetName(
                    pProtocolTemp,
                    &pszwName
                    );
        }

        if ( SUCCEEDED(hr) )
        {
          if(pfnPickProtocolCallBack)
          {
              dwErr = pfnPickProtocolCallBack(
                                       pInfo, 
                                       pProtocolTemp, 
                                       pszwName, 
                                       uchIPProtocol, 
                                       ntohs(usPort) );
          }
          else
          {
              dwErr = HnPMPickProtocol(
                                       pInfo, 
                                       pProtocolTemp, 
                                       pszwName, 
                                       uchIPProtocol, 
                                       ntohs(usPort) );

          }
        }

        if ( pszwName )
        {
            Free(pszwName);
            pszwName = NULL;
        }

        IHNetPortMappingProtocol_Release(pProtocolTemp);

        if ( NO_ERROR == dwErr )
        {
              break;
        }

    }while(TRUE);

    return dwErr;
}//HnPMProtocolEnum()


DWORD
HnPMCreatePorotocolParameterCheck(
        IN LPHNPMParams pInfo)
{

    ASSERT( pInfo->pSettings );
    ASSERT( pInfo->pwszTitlePPTP );
    ASSERT( pInfo->pwszTitleL2TP );
    ASSERT( pInfo->pwszTitleIKE );
    ASSERT( pInfo->pwszTitleNAT_T);

    if ( !pInfo->pSettings ||
         !pInfo->pwszTitlePPTP ||
         !pInfo->pwszTitleL2TP ||
         !pInfo->pwszTitleIKE   ||
         !pInfo->pwszTitleNAT_T)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}


//Create PortMapping Protocols
//Function:
//      If one or more of PPTP, L2TP and IKE PortMapping protocols are not existing
//      create the missing ones.
//
//Requirement: 
//      pSettings is valid
//      All the portmapping protocol titles are valid
//
DWORD
HnPMCreateProtocol(
        IN OUT LPHNPMParams pInfo)
{
    DWORD dwErr=NO_ERROR;
    HRESULT hr;

    dwErr = HnPMCreatePorotocolParameterCheck(pInfo);

    if( NO_ERROR != dwErr )
    {
        TRACE("HnPMCreateProtocol: HnPMCreatePorotocolParameterCheck failed!");
        return dwErr;
    }

    do {
        if ( !pInfo->pProtocolPPTP )
        {
            //
            //Do port Mapping for PPTP
            //Get PortMapping protocol
            //the tile should be with WCHAR or OLECHAR type
            //any numerical values are in network byte order
            //and the type of port is USHORT, so I use htons
            //here
            //
            hr = IHNetProtocolSettings_CreatePortMappingProtocol(
                        pInfo->pSettings,
                        pInfo->pwszTitlePPTP,
                        NAT_PROTOCOL_TCP,
                        htons(1723),
                        &pInfo->pProtocolPPTP
                        );

            //If the protocol has already been defined, the CreatePortMapping
            //above will fail and returns ERROR_OBJECT_ALREADY_EXISTS
            //
            if ( ERROR_OBJECT_ALREADY_EXISTS == (DWORD) hr )
            {
                TRACE("HnPMCreateProtocol: The PortMapping for PPTP is already defined");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            if (!SUCCEEDED(hr) )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }// end of assigning PPTP protocol
    
        //Create a new PortMappingProtocol for L2TP
        if ( !pInfo->pProtocolL2TP)
        {
            //
            //Do port Mapping for L2TP
            //Get PortMapping protocol
            //the tile should be with WCHAR or OLECHAR type
            //any numerical values are in network byte order
            //and the type of port is USHORT, so I use htons
            //here
            //
            hr = IHNetProtocolSettings_CreatePortMappingProtocol(
                        pInfo->pSettings,
                        pInfo->pwszTitleL2TP,
                        NAT_PROTOCOL_UDP,
                        htons(1701),
                        &pInfo->pProtocolL2TP
                        );

            //If the protocol has already been defined, the CreatePortMapping
            //above will fail and returns ERROR_OBJECT_ALREADY_EXISTS
            //
            if ( ERROR_OBJECT_ALREADY_EXISTS == (DWORD)hr )
            {
                TRACE("HnPMCreateProtocol: The PortMapping for L2TP is already defined!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            if (!SUCCEEDED(hr) )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }// end of assigning L2TP protocol
    
        //Create a new PortMappingProtocol for IKE
        if ( !pInfo->pProtocolIKE )
        {
            //
            //Do port Mapping for IKE
            //Get PortMapping protocol
            //the tile should be with WCHAR or OLECHAR type
            //any numerical values are in network byte order
            //and the type of port is USHORT, so I use htons
            //here
            //
            hr = IHNetProtocolSettings_CreatePortMappingProtocol(
                        pInfo->pSettings,
                        pInfo->pwszTitleIKE,
                        NAT_PROTOCOL_UDP,
                        htons(500),
                        &pInfo->pProtocolIKE
                        );

            //If the protocol has already been defined, the CreatePortMapping
            //above will fail and returns ERROR_OBJECT_ALREADY_EXISTS
            //
            if ( ERROR_OBJECT_ALREADY_EXISTS == (DWORD)hr )
            {
                TRACE("HnPMCreateProtocol: The PortMapping for IKE is already defined!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            if (!SUCCEEDED(hr) )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }// end of assigning IKE protocol

	 // For .Net 690343
        //Create a new PortMappingProtocol for IKE NAT-T
        if ( !pInfo->pProtocolNAT_T)
        {
            //
            //Do port Mapping for IKE NAT-T
            //Get PortMapping protocol
            //the tile should be with WCHAR or OLECHAR type
            //any numerical values are in network byte order
            //and the type of port is USHORT, so I use htons
            //here
            //
            hr = IHNetProtocolSettings_CreatePortMappingProtocol(
                        pInfo->pSettings,
                        pInfo->pwszTitleNAT_T,
                        NAT_PROTOCOL_UDP,
                        htons(4500),
                        &pInfo->pProtocolNAT_T
                        );

            //If the protocol has already been defined, the CreatePortMapping
            //above will fail and returns ERROR_OBJECT_ALREADY_EXISTS
            //
            if ( ERROR_OBJECT_ALREADY_EXISTS == (DWORD)hr )
            {
                TRACE("HnPMCreateProtocol: The PortMapping for NAT-T is already defined!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            if (!SUCCEEDED(hr) )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }// end of assigning IKE protocol

    }while (FALSE);

    return dwErr;

} //HnPMCreateProtocol()


//Function: Enable/Disable a single portmapping Protocol  on a Single
//          Connection of type IHNetConnection
//
DWORD
HnPMSetSinglePMForSingleConnection(
    IN  IHNetConnection * pHNetConn,
    IN  IHNetPortMappingProtocol * pProtocol,
    IN  TCHAR * pszLoopbackAddr,
    IN  BOOL fEnabled)
{
    IHNetPortMappingBinding * pBinding = NULL;
    HRESULT hr;
    DWORD dwErr = NO_ERROR;
    ULONG ulAddress = INADDR_NONE;

    do {
        hr = IHNetConnection_GetBindingForPortMappingProtocol(
                    pHNetConn,
                    pProtocol,
                    &pBinding
                    );

        if (!SUCCEEDED(hr) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        ulAddress = IpPszToHostAddr( pszLoopbackAddr ); 

        hr = IHNetPortMappingBinding_SetTargetComputerAddress(
                    pBinding,
                    htonl(ulAddress)
                    );

        if (!SUCCEEDED(hr) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        hr = IHNetPortMappingBinding_SetEnabled(
                    pBinding,
                    !!fEnabled
                    );

        if (!SUCCEEDED(hr) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

    } while(FALSE);

    if (pBinding)
    {
        IHNetPortMappingBinding_Release(pBinding);
    }

    return dwErr;
} //HnPMSetSinglePMForSingleConnection()


DWORD
HnPMConfigureAllPMForSingleConnectionParameterCheck(
        IN OUT LPHNPMParams pInfo)
{
    ASSERT( pInfo->pHNetConn );
    ASSERT( pInfo->pProtocolPPTP );
    ASSERT( pInfo->pProtocolL2TP );
    ASSERT( pInfo->pProtocolIKE );
    ASSERT( pInfo->pProtocolNAT_T);
    ASSERT( pInfo->pszLoopbackAddr );

    if ( !pInfo->pHNetConn ||
         !pInfo->pProtocolPPTP ||
         !pInfo->pProtocolL2TP ||
         !pInfo->pszLoopbackAddr )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

//Function:
//      Enable/Disable all the PortMapping protocols inside pInfo 
//      (currently PPTP, L2TP, IKE)  on a single connection
//
//Requirement:
//      pHNetConn is valid
//      All the portmapping protocols inside pInfo are valid
//
DWORD
HnPMConfigureAllPMForSingleConnection(
        IN OUT LPHNPMParams pInfo,
        BOOL fEnabled)
{
    DWORD dwErr = NO_ERROR;

    dwErr = HnPMConfigureAllPMForSingleConnectionParameterCheck(pInfo);
    if( NO_ERROR != dwErr )
    {
        TRACE("HnPMConfigureAllPMForSingleConnection: parameter check failed!");
        return dwErr;
    }

    do{
        dwErr = HnPMSetSinglePMForSingleConnection(
                           pInfo->pHNetConn,
                           pInfo->pProtocolPPTP,
                           pInfo->pszLoopbackAddr,
                           fEnabled);

        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllPMForSingleConnection: PortMapping failed for PPTP!");
            break;
        }

        dwErr = HnPMSetSinglePMForSingleConnection(
                           pInfo->pHNetConn,
                           pInfo->pProtocolL2TP,
                           pInfo->pszLoopbackAddr,
                           fEnabled);

        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllPMForSingleConnection: PortMapping failed for L2TP!");
            break;
        }

        dwErr = HnPMSetSinglePMForSingleConnection(
                           pInfo->pHNetConn,
                           pInfo->pProtocolIKE,
                           pInfo->pszLoopbackAddr,
                           fEnabled);

        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllPMForSingleConnection: PortMapping failed for IKE!");
            break;
        }

	// For .Net 690343
        dwErr = HnPMSetSinglePMForSingleConnection(
                           pInfo->pHNetConn,
                           pInfo->pProtocolNAT_T,
                           pInfo->pszLoopbackAddr,
                           fEnabled);

        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllPMForSingleConnection: PortMapping failed for NAT-T!");
            break;
        }

    } while(FALSE);

    return dwErr;
} //HnPMConfigureAllPMForSingleConnection()


//Make sure:
//      pHNetCfgMgr is valid
//      one and only one of pNetConnection and pGuid is valid
//
DWORD
HnPMConfigureSingleConnectionInitParameterCheck(
    IN LPHNPMParams pInfo )
{
    ASSERT( pInfo->pHNetCfgMgr );
    ASSERT( pInfo->pNetConnection || pInfo->pGuid );

    if ( !pInfo->pHNetCfgMgr || 
         ( !pInfo->pNetConnection && !pInfo->pGuid ) ||
         ( pInfo->pNetConnection && pInfo->pGuid ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}//HnPMConfigureSingleConnectionInitParameterCheck()


// (1) Call Parameter checking function
//          pHNetCfgMgr is valid
//          one and only one of pNetConnection and pGuid is valid
//
// (2) init pHNetConn by converting from pNetConnection or pGuid
//
// (3) call HnPMParamsInit()
//          Initialize some members of HNPMParams structure
//          pSettings, pEnumPMP, Read Title for PPTP, L2TP, IKE
//          from resource file
//
DWORD
HnPMConfigureSingleConnectionInit(
    IN OUT  LPHNPMParams pInfo)
{
    
    DWORD dwErr = NO_ERROR;
    HRESULT hr;

    dwErr = HnPMConfigureSingleConnectionInitParameterCheck(pInfo);
    if ( NO_ERROR != dwErr )
    {
        return  dwErr;
    }

    do {
        if ( pInfo->pNetConnection )
            {
                hr = IHNetCfgMgr_GetIHNetConnectionForINetConnection(
                                pInfo->pHNetCfgMgr,
                                pInfo->pNetConnection,
                                &pInfo->pHNetConn
                                );

                if (!SUCCEEDED(hr) )
                {
                    TRACE("HnPMConfigureSingleConnection: GetIHNetConnectionForINetConnection failed");
                    dwErr = ERROR_CAN_NOT_COMPLETE;
                    break;
                }
            }
            else
            {
                hr = IHNetCfgMgr_GetIHNetConnectionForGuid(
                                            pInfo->pHNetCfgMgr,
                                            pInfo->pGuid,
                                            FALSE,//This is not for Lan Connection
                                            TRUE, //This should always be TRUE
                                            &pInfo->pHNetConn
                                            );

                            if (!SUCCEEDED(hr) )
                            {
                                TRACE("HnPMConfigureSingleConnection: GetIHNetConnectionForGuid failed");
                                dwErr = ERROR_CAN_NOT_COMPLETE;
                                break;
                            }

              }

              dwErr = HnPMParamsInit(pInfo);

        }while(FALSE);

    return dwErr;
} //HnPMConfigureSingleConnectionInit()

// (1) Release all PortMapping Protocols
// (2) release the connection just configured
// (3) call HnPMParamsCleanUp()
//          Release pEnumPMP, pSettings
//          Free memory for titles for PPTP, L2TP, IKE if allocated before
//

DWORD
HnPMConfigureSingleConnectionCleanUp(
        IN OUT LPHNPMParams pInfo)
{

    if ( pInfo->pProtocolPPTP ) 
    {
        IHNetPortMappingProtocol_Release( pInfo->pProtocolPPTP );
        pInfo->pProtocolPPTP = NULL;
    }

    if ( pInfo->pProtocolL2TP ) 
    {
       IHNetPortMappingProtocol_Release( pInfo->pProtocolL2TP ); 
       pInfo->pProtocolL2TP = NULL;
    }

    if ( pInfo->pHNetConn ) 
    {
        IHNetConnection_Release( pInfo->pHNetConn );
        pInfo->pHNetConn = NULL;
    }

    if ( pInfo->pProtocolIKE ) 
    {
        IHNetPortMappingProtocol_Release( pInfo->pProtocolIKE ); 
        pInfo->pProtocolIKE = NULL;
    }

   // For .Net 690343
    if ( pInfo->pProtocolNAT_T) 
    {
        IHNetPortMappingProtocol_Release( pInfo->pProtocolNAT_T ); 
        pInfo->pProtocolNAT_T = NULL;
    }

    HnPMParamsCleanUp(pInfo);

    return NO_ERROR;
}//HnPMConfigureSingleConnectionCleanUp

//Function:
//      Enable/Disable PortMappping(PPTP, L2TP, IKE) on a single connection
//Step:
//  (1) Initialization
//  (2) Enumerate all existing portmapping protocols
//  (3) Pick PPTP, L2TP, IKE from them
//  (4) If not all of them exist, Create the missing ones
//  (5) Configure each protocol on this connection
//
DWORD
HnPMConfigureSingleConnection(
        IN OUT LPHNPMParams pInfo,
        BOOL fEnabled)
{
    DWORD dwErr = NO_ERROR;

    do{
        //Init the value needed in this function
        //
        dwErr = HnPMConfigureSingleConnectionInit(pInfo);

        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnection: Init failed!");
            break;
        }

        //Enumerate all PortMapping Protocls and 
        //pick the PPTP, L2TP, IKE, NAT-T from them
        //
         dwErr = HnPMProtocolEnum(pInfo, HnPMPickProtocol);

        //Create a new PortMappingProtocol for PPTP
        //if didnt find the PPTP protocl and it is to
        //Enable it
        //

        if ( NO_ERROR != dwErr )
        {
            dwErr = HnPMCreateProtocol(pInfo);
        }

        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnection: HnPMCreateProtocol failed!");
            break;
        }

        dwErr = HnPMConfigureAllPMForSingleConnection(pInfo, fEnabled);
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnection: HnPMConfigureAllPMForSingleConnection failed!");
            break;
        }

    }
    while( FALSE );

    //clean up the structure changed in this function
    //
    HnPMConfigureSingleConnectionCleanUp(pInfo);

    return dwErr;
} //HnPMConfigureSingleConnection()

DWORD
HnPMDeletePortMappingInit(
        IN OUT LPHNPMParams pInfo)
{
    HRESULT hr;
    DWORD dwErr = NO_ERROR;

    do{
        dwErr = HnPMCfgMgrInit(pInfo);
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMDeletePortMappingInit: HnPMCfgMgrInit failed!");
            break;
        }

        dwErr = HnPMParamsInit(pInfo);

    }while(FALSE);

    return dwErr;
} //HnPMDeletePortMappingInit()

DWORD
HnPMDeletePortMappingCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    HnPMParamsCleanUp(pInfo);

    HnPMCfgMgrCleanUp(pInfo);

    return NO_ERROR;
}

//Function:
//      Delete the PortMapping Protocols (PPTP, L2TP, IKE)
//Step:
//  (1)Initialization:
//          Get all the protocol names, IP protocol number, 
//          Transport Layer port number (PPTP: TCP/1723
//          L2TP:UDP/1701, IKE (UDP:500)
//  (2)Enumerate all existing portmapping protocols
//  (3) Pick the protocols to delete and store them in pInfo
//  (4) delete protocols
//
DWORD
HnPMDeletePortMapping()
{
    HNPMParams Info;
    LPHNPMParams pInfo;
    DWORD dwErr;
    HRESULT hr;

    dwErr = NO_ERROR;

    ZeroMemory(&Info, sizeof(Info) );
    pInfo = &Info;

    do{
        dwErr = HnPMDeletePortMappingInit(pInfo);
        if (NO_ERROR != dwErr)
        {
            TRACE("HnPMDeletePortMapping: HnPMDeletePortMappingInit failed!");
            break;
        }

        //Enumerate all PortMapping Protocls and 
        //pick the PPTP, L2TP, IKE from them
        //
        dwErr = HnPMProtocolEnum(pInfo, HnPMPickProtocol);
        if (NO_ERROR != dwErr)
        {
            TRACE("HnPMDeletePortMapping: HnPMProtocolEnum failed!");
            break;
        }

        //Delete All Port Mapping protocols
        if ( pInfo->pProtocolPPTP ) 
        {
            hr = IHNetPortMappingProtocol_Delete( pInfo->pProtocolPPTP );
            pInfo->pProtocolPPTP = NULL;
            ASSERT(SUCCEEDED(hr));
            if (!SUCCEEDED(hr))
            {
                TRACE1("HnPMDeletePortMapping: delete PPTP portmaping failed = %x!", hr);
            }
        }

        if ( pInfo->pProtocolL2TP ) 
        {
           hr = IHNetPortMappingProtocol_Delete( pInfo->pProtocolL2TP ); 
           pInfo->pProtocolL2TP = NULL;
           ASSERT(SUCCEEDED(hr));
            if (!SUCCEEDED(hr))
            {
                TRACE1("HnPMDeletePortMapping: delete L2TP portmaping failed = %x!", hr);
            }
        }

        if ( pInfo->pProtocolIKE ) 
        {
            hr = IHNetPortMappingProtocol_Delete( pInfo->pProtocolIKE ); 
            pInfo->pProtocolIKE = NULL;
            ASSERT(SUCCEEDED(hr));
            if (!SUCCEEDED(hr))
            {
                TRACE1("HnPMDeletePortMapping: delete IKE portmaping failed = %x!", hr);
            }
        }

	// For .Net 690343
        if ( pInfo->pProtocolNAT_T) 
        {
            hr = IHNetPortMappingProtocol_Delete( pInfo->pProtocolNAT_T ); 
            pInfo->pProtocolNAT_T = NULL;
            ASSERT(SUCCEEDED(hr));
            if (!SUCCEEDED(hr))
            {
                TRACE1("HnPMDeletePortMapping: delete NAT-T portmaping failed = %x!", hr);
            }
        }

    }while(FALSE);

    HnPMDeletePortMappingCleanUp(pInfo);

    return dwErr;
}//DeletePortMapping()

DWORD
HnPMConfigureAllConnectionsInit(
        IN OUT LPHNPMParams pInfo)
{
    DWORD dwErr = NO_ERROR;

    dwErr = HnPMCfgMgrInit(pInfo);
        
    return NO_ERROR;
}

DWORD
HnPMParamsConnectionCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    DWORD i;

    if ( pInfo->ConnArray )
    {
        for ( i = 0; i < pInfo->ConnCount; i++ )
        {
            INetConnection_Release(pInfo->ConnArray[i]);
        }

        GlobalFree( pInfo->ConnArray );
        pInfo->ConnArray = NULL;
    }

    if ( pInfo->ConnPropTable )
    {
        for ( i = 0; i < pInfo->ConnCount; i++ )
        {
           Free0(pInfo->ConnPropTable[i].pszwName);
           pInfo->ConnPropTable[i].pszwName = NULL;
           Free0(pInfo->ConnPropTable[i].pszwDeviceName);
           pInfo->ConnPropTable[i].pszwDeviceName = NULL;
        }

        GlobalFree( pInfo->ConnPropTable );
        pInfo->ConnPropTable = NULL;
        pInfo->ConnCount = 0;
    }

    return NO_ERROR;
}//HnPMParamsConnectionCleanUp()


DWORD
HnPMConfigureAllConnectionsCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    HnPMParamsConnectionCleanUp(pInfo);

    HnPMCfgMgrCleanUp(pInfo);

    return NO_ERROR;
}


//  Enable/Disable portmapping on all connections except incoming connection
//  PortMapping protocols: PPTP, L2TP, IKE
//  If there are no such protocols, create them first
//  Steps:
//      (1) Initialization
//      (2) Enumerate all connections of type INetConnection *
//      (3) If it is not an incomming connection set the portmapping protocols
//              on it.

DWORD
HnPMConfigureAllConnections( 
    IN BOOL fEnabled )
{
    DWORD  dwErr = NO_ERROR, i;
    HNPMParams Info;
    LPHNPMParams pInfo;
    static const CLSID CLSID_InboundConnection=
    {0xBA126AD9,0x2166,0x11D1,{0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

    TRACE1("HnPMConfigureAllConnections: fEnabled = %d", fEnabled);
    TRACE1("%s", fEnabled ? "Enable PortMaping on all connections." :
                            "Diable PortMaping on all connections.");

    ZeroMemory(&Info, sizeof(Info));
    pInfo = &Info;

    do {
        dwErr = HnPMConfigureAllConnectionsInit(pInfo);
        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllConnections: Init failed!");
            break;
        }

        //Get All Connections
        //
        dwErr = HnPMConnectionEnum(pInfo);

        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllConnections: HnPMConnectionEnum() failed!");
            break;
        }

        TRACE1("HnPMConfigureAllConnections: %l Connections detected", pInfo->ConnCount);

        //Set up PortMapping for each connection
        //
        for ( i = 0; i < pInfo->ConnCount; i++ )
        {
            //won't do PortMapping for Incoming connections
            //
            if ( pInfo->ConnPropTable )
            {
            //define the class id for Incoming connections
            // reference to /nt/net/config/shell/wanui/rasui.cpp


               if( IsEqualCLSID( 
                    &CLSID_InboundConnection, 
                    &(pInfo->ConnPropTable[i].clsidThisObject) ) )
               {
                continue;
               }
            }

            pInfo->pNetConnection = pInfo->ConnArray[i];

            if ( NO_ERROR != HnPMConfigureSingleConnection(pInfo, fEnabled) )
            {
                TRACE1("HnPMConfigureAllConnections: HnPMConfigureSingleConnection failed for %lth connection",i);
            }
        }

    }
    while (FALSE);

    //Clean Up
    //
    HnPMConfigureAllConnectionsCleanUp(pInfo);

    return dwErr;
}//end of HnPMConfigureAllConnections()


// do the COM initialization and create pHNetCfgMgr
DWORD
HnPMCfgMgrInit(
        IN OUT LPHNPMParams pInfo)
{        
    HRESULT hr;
    DWORD dwErr = NO_ERROR;
        
    do{
        dwErr = HnPMInit(pInfo);

        if (NO_ERROR != dwErr )
        {
            TRACE("HnPMCfgMgrInit: HnPMInit failed!");
            break;
        }

        hr = CoCreateInstance(
                &CLSID_HNetCfgMgr,
                NULL,
                CLSCTX_ALL,
                &IID_IHNetCfgMgr,
                (VOID**) &pInfo->pHNetCfgMgr
                );

        if ( !SUCCEEDED(hr) )
        {
            TRACE("HnPMCfgMgrInit: CoCreateInstance failed");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
    }while(FALSE);

    return dwErr;
}//HnPMCfgMgrInit()


DWORD
HnPMCfgMgrCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    if ( pInfo->pHNetCfgMgr )
    {
        IHNetCfgMgr_Release(pInfo->pHNetCfgMgr);
        pInfo->pHNetCfgMgr = NULL;
    }

    HnPMCleanUp(pInfo);

    return NO_ERROR;
}


DWORD
HnPMConfigureSingleConnectionGUIDInit(
        IN OUT LPHNPMParams pInfo,
        GUID * pGuid)
{
    DWORD dwErr = NO_ERROR;

    do{
        dwErr = HnPMCfgMgrInit(pInfo);
        if ( NO_ERROR != dwErr )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        //Use Guid to indentify the connection
        pInfo->pGuid = pGuid;
        pInfo->pNetConnection = NULL;

    }while(FALSE);

    return dwErr;
}


DWORD
HnPMConfigureSingleConnectionGUIDCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    pInfo->pGuid = NULL;
    pInfo->pNetConnection = NULL;

    HnPMCfgMgrCleanUp(pInfo);

    return NO_ERROR;
}

//Setup PortMapping protocols on a single connection
//represented by its GUID
//
DWORD
HnPMConfigureSingleConnectionGUID(
    IN GUID * pGuid,
    IN BOOL fEnabled)
{
    HNPMParams Info;
    LPHNPMParams pInfo;
    DWORD dwErr = NO_ERROR;
   
    TRACE1("HnPMConfigureSingleConnectionGUID: fEnabled = %d", fEnabled);

    TRACE1("%s", fEnabled ? "Enable PortMapping on this Connection" :
                            "Diable PortMapping on this Connection");
    ASSERT( pGuid );
    if ( !pGuid )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory(&Info, sizeof(Info) );
    pInfo = &Info;


    dwErr = NO_ERROR;

    do{
        dwErr = HnPMConfigureSingleConnectionGUIDInit(pInfo, pGuid);
        if (NO_ERROR != dwErr)
        {
            TRACE("HnPMConfigureSingleConnectionGUID: Init failed!");
            break;
        }

        dwErr = HnPMConfigureSingleConnection(pInfo, fEnabled);
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnectionGUID: SetPortMappingForSingleConnection failed ");
            break;
        }
    }
    while (FALSE);

    HnPMConfigureSingleConnectionGUIDCleanUp(pInfo);

    return dwErr;
}//HnPMConfigureSingleConnectionGUID()



//Set up the port mapping for only one
//connection according to its GUID only when
//Incoming Connection exists and
//the VPN is enabled
//
DWORD
HnPMConfigureSingleConnectionGUIDIfVpnEnabled(
     GUID* pGuid,
     BOOL fDual,
     HANDLE hDatabase)
{
    HANDLE hDevDatabase = NULL;
    DWORD dwErr;
    BOOL  fEnabled = FALSE;

    dwErr = NO_ERROR;
    do 
    {
        // Get handles to the databases we're interested in
        //
        if ( !hDatabase )
        {
            dwErr = devOpenDatabase( &hDevDatabase );
            if ( NO_ERROR != dwErr )
            {
                TRACE("HnPMConfigureSingleConnectionGUIDIfVpnEnabled: devOpenDatabase failed!");
                break;
            }
        }
        else
        {
            hDevDatabase = hDatabase;
        }

        dwErr = devGetVpnEnable(hDevDatabase, &fEnabled );
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnectionGUIDIfVpnEnabled: devGetVpnEnable failed!");
            break;
        }

        //if fDual == TRUE, can disable/enable the portmapping 
        //according to if VPN is enabled or not
        //otherwise, dont do anything if VPN is not enabled.
        if ( !fEnabled && !fDual)
        {
            dwErr = NO_ERROR;
            break;
        }

        dwErr = HnPMConfigureSingleConnectionGUID( pGuid, fEnabled );
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnectionGUIDIfVpnEnabled: HnPMConfigureSingleConnectionGUID failed!");
            break;
        }
    }
    while (FALSE);

    if ( !hDatabase && hDevDatabase )
    {
        devCloseDatabase( hDevDatabase );
    }
 
    return dwErr;

}//HnPMConfigureSingleConnectionGUIDIfVpnEnabled()

//whistler bug 123769, 
//when Incoming Connection is running
//if VPN enabled, go to set up port mapping
//
DWORD
HnPMConfigureIfVpnEnabled(
     BOOL fDual,
     HANDLE hDatabase)
{
    HANDLE hDevDatabase = NULL;
    DWORD dwErr;
    BOOL  fEnabled = FALSE;

    dwErr = NO_ERROR;
    do 
    {
        // Get handles to the databases we're interested in
        //
        if ( !hDatabase )
        {
            dwErr = devOpenDatabase( &hDevDatabase );
            if ( NO_ERROR != dwErr )
            {
                TRACE("HnPMConfigureIfVpnEnabled: devOpenDatabase failed!");
                break;
            }
        }
        else
        {
            hDevDatabase = hDatabase;
        }

        dwErr = devGetVpnEnable(hDevDatabase, &fEnabled );
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureIfVpnEnabled: devGetVpnEnable failed!");
            break;
        }

        //if fDual == TRUE, can disable/enable the portmapping 
        //according to if VPN is enabled or not
        //otherwise, dont do anything if VPN is not enabled.
        if ( !fEnabled && !fDual)
        {
            dwErr = NO_ERROR;
            break;
        }

        dwErr = HnPMConfigureAllConnections( fEnabled );
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureIfVpnEnabled: SetPortMapingForICVpn failed!");
            break;
        }
    }
    while (FALSE);

    if ( !hDatabase && hDevDatabase )
    {
        devCloseDatabase( hDevDatabase );
    }
 
    return dwErr;

}//End of HnPMConfigureIfVpnEnabled()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\netcfgdb.h ===
/*
    File    netcfgdb.h

    Implements a database abstraction on top of the net config
    items needed by the ras server ui for connections.

    Paul Mayfield, 12/15/97
*/

#ifndef _rassrvui_netcfg_h
#define _rassrvui_netcfg_h

//
// Network component types
//
#define NETCFGDB_SERVICE        0x1
#define NETCFGDB_CLIENT         0x2
#define NETCFGDB_PROTOCOL       0x4

//
// Identifiers for net components.
//
// These will be sorted in numerical order
// of these identifiers.
//
#define NETCFGDB_ID_IP          0x1
#define NETCFGDB_ID_IPX         0x2
#define NETCFGDB_ID_NETBUI      0x4
#define NETCFGDB_ID_ARAP        0x8
#define NETCFGDB_ID_FILEPRINT   0x10
#define NETCFGDB_ID_OTHER       0xf0000000

//
// Parameters that can be set for tcpip on the dialin
// server.
//
#define TCPIP_ADDR_LEN 20
typedef struct _TCPIP_PARAMS 
{
    DWORD dwPoolStart;  // Start ip addr of the static pool (host order)
    DWORD dwPoolEnd;    // End ip addr of the static pool (host order)
    BOOL bCaller;       // Whether caller can specify addr
    BOOL bUseDhcp;      // TRUE =  Use dhcp to assign addr
                        // FALSE = Use a pool to assign addr
} TCPIP_PARAMS;

// Parameters that can be set for Ipx on the dialin
// server.
//
typedef struct _IPX_PARAMS 
{
    DWORD dwIpxAddress;   // Beginning ipx address to allocate        
    BOOL bCaller;         // Whether to allow the caller to specify addr
    BOOL bAutoAssign;     // Whether to automatically assign node nums
    BOOL bGlobalWan;      // Whether to assign same net node to all clients
    
} IPX_PARAMS;

DWORD 
netDbOpen (
    OUT HANDLE * phNetCompDatabase, 
    IN  PWCHAR pszClientName);
    
DWORD 
netDbClose (
    IN HANDLE hNetCompDatabase);

DWORD 
netDbFlush (
    IN HANDLE hNetCompDatabase);
    
DWORD 
netDbLoad (
    IN HANDLE hNetCompDatabase);
    
DWORD 
netDbReload (
    IN HANDLE hNetCompDatabase);

DWORD
netDbReloadComponent (
    IN HANDLE hNetCompDatabase,
    IN DWORD dwComponentId);
    
DWORD 
netDbRollback (
    IN HANDLE hNetCompDatabase);

BOOL 
netDbIsLoaded(
    IN HANDLE hNetCompDatabase);

DWORD 
netDbGetCompCount(
    IN HANDLE hNetCompDatabase, 
    OUT LPDWORD lpdwCount);

DWORD 
netDbGetName(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT PWCHAR* pszName);

DWORD 
netDbGetDesc(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT PWCHAR* pszName);

DWORD 
netDbGetType(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT LPDWORD lpdwType);

DWORD
netDbGetId(
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT LPDWORD lpdwId);

DWORD 
netDbGetEnable(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT PBOOL pbEnabled);

DWORD 
netDbSetEnable(
    IN HANDLE hNetCompDatabase, 
    IN DWORD dwIndex, 
    IN BOOL bEnabled);

DWORD 
netDbIsRasManipulatable(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT PBOOL pbManip);

//For whistler bug 347355
//
DWORD
netDbHasRemovePermission(
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    OUT PBOOL pbHasPermit);

DWORD 
netDbHasPropertiesUI(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT PBOOL pbHasUi);

DWORD 
netDbRaisePropertiesDialog(
    IN HANDLE hNetCompDatabase, 
    IN DWORD dwIndex, 
    IN HWND hwndParent);

DWORD 
netDbRaiseInstallDialog(
    IN HANDLE hNetCompDatabase, 
    IN HWND hwndParent);

DWORD 
netDbRaiseRemoveDialog(
    IN HANDLE hNetCompDatabase, 
    IN DWORD dwIndex, 
    IN HWND hwndParent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\nettab.h ===
/*
    File    advantab.h

    Definitions needed to display the dialup server ui networking tab.

    Paul Mayfield, 10/10/97
*/

#ifndef __advantab_h
#define __advantab_h

#include <windows.h>
#include <prsht.h>

// Fills a LPPROPSHEETPAGE structure with the information
// needed to display the advanced tab.  dwUserData is ignored.
DWORD NetTabGetPropertyPage(LPPROPSHEETPAGE lpPage, LPARAM lpUserData);     

// This dialog procedure responds to messages send to the 
// advanced tab.
INT_PTR CALLBACK NetTabDialogProc(HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\multilink.h ===
/*
    File    multilink.h

    Definitions required to display the multilink page.

    Paul Mayfield, 10/17/97
*/

#ifndef __rassrvui_multilink_h
#define __rassrvui_multilink_h

#include <windows.h>
#include <prsht.h>

// Fills in the property sheet structure with the information required to display
// the multilink tab.
DWORD mtlUiGetPropertyPage(LPPROPSHEETPAGE ppage, DWORD dwUserData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\nettab.c ===
/*
    File    nettab.c

    Implementation of the ui behind the networking tab in the dialup server
    ui.

    Paul Mayfield 10/8/97.
*/

#include <rassrv.h>

// Help maps
static const DWORD phmNetTab[] =
{
    CID_NetTab_LV_Components,       IDH_NetTab_LV_Components,
    CID_NetTab_PB_Add,              IDH_NetTab_PB_Add,
    CID_NetTab_PB_Remove,           IDH_NetTab_PB_Remove,
    CID_NetTab_PB_Properties,       IDH_NetTab_PB_Properties,
    0,                              0
};

//
// Fills in the property sheet structure with the information 
// required to display the networking tab.
//
DWORD 
NetTabGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_NetTab);
    ppage->pfnDlgProc  = NetTabDialogProc;
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->dwFlags     = PSP_USECALLBACK;
    ppage->lParam      = lpUserData;

    return NO_ERROR;
}

// Error reporting
VOID 
NetTabDisplayError(
    IN HWND hwnd, 
    IN DWORD dwErr) 
{
    ErrDisplayError(
        hwnd, 
        dwErr, 
        ERR_ADVANCEDTAB_CATAGORY, 
        0, 
        Globals.dwErrorData);
}

//
// Returns the index of an to display icon based on the 
// type of incoming connection.
//
INT 
NetTabGetIconIndex(
    IN DWORD dwType) 
{
    switch (dwType) 
    {
        case NETCFGDB_SERVICE:
            return NI_Service;
            
        case NETCFGDB_CLIENT:
            return NI_Client;
            
        case NETCFGDB_PROTOCOL:
            return NI_Protocol;
    }
    
    return 0;
}

//
// Sets up the UI so that the user is forced to complete the 
// config they've started.  Triggered when a non-reversable option 
// is taken such as adding/removing a networking component.
//
DWORD
NetTabDisableRollback(
    IN HWND hwndDlg)
{
    DWORD dwErr, dwId = 0; 

    do
    {
        dwErr = RasSrvGetPageId (hwndDlg, &dwId);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        if (dwId == RASSRVUI_ADVANCED_TAB)
        {
            PropSheet_CancelToClose(GetParent(hwndDlg));
        }
        
    } while (FALSE);

    // Cleanup
    {
    }
    
    return dwErr;
}

//
// Fills in the given list view with the names of the components 
// stored in the  database provided.  
//
DWORD 
NetTabFillComponentList(
    IN HWND hwndLV, 
    IN HANDLE hNetCompDatabase) 
{
    LV_ITEM lvi;
    DWORD dwCount, i, dwErr, dwProtCount, dwType;
    PWCHAR pszName;
    BOOL bManip, bEnabled;

    // Get the count of all the components
    //
    dwErr = netDbGetCompCount (hNetCompDatabase, &dwCount);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Initialize the list item
    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;

    // Looop through all of the network components 
    // adding their names as we go
    for (i = 0; i < dwCount; i++) 
    {
        netDbGetType (hNetCompDatabase, i, &dwType);
        netDbIsRasManipulatable (hNetCompDatabase, i, &bManip);
        netDbGetEnable (hNetCompDatabase, i, &bEnabled);

        // Fill in the data
        //
        netDbGetName (hNetCompDatabase, i, &pszName);
        lvi.iImage = NetTabGetIconIndex(dwType);
        lvi.iItem = i;
        lvi.pszText = pszName;
        lvi.cchTextMax = wcslen(pszName)+1;
        ListView_InsertItem(hwndLV,&lvi);
        ListView_SetCheck(hwndLV, i, bEnabled);

        // If this is not a ras manipulateable component, 
        // disable the check since it can't be set anyway.
        if (!bManip) 
        {
            ListView_DisableCheck(hwndLV, i);
        }
    }
    
    return NO_ERROR;
}

//
// Updates the description of the currently selected protocol
//
DWORD 
NetTabUpdateDescription(
    IN HWND hwndDlg, 
    IN DWORD i) 
{
    HANDLE hNetCompDatabase = NULL, hProt = NULL;
    PWCHAR pszDesc;
    DWORD dwErr = NO_ERROR;

    // Get handles to the databases we're interested in
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    do
    {
        dwErr = netDbGetDesc(hNetCompDatabase, i, &pszDesc);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Set the description
        SetDlgItemTextW(
            hwndDlg, 
            CID_NetTab_ST_Description, 
            pszDesc);
        
    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            SetDlgItemTextW(
                hwndDlg, 
                CID_NetTab_ST_Description, 
                L"");
        }
    }

    return dwErr;
}


//
//When an Item in the listview is selected, check if the user can Uninstall it
//for whistler bug 347355           gangz
//
DWORD
NetTabEnableDisableRemoveButton (
    IN HWND hwndDlg,
    IN DWORD iItem)
{
  HANDLE hNetCompDatabase = NULL;
  DWORD  dwErr;
  HWND   hwndRemove = NULL;
  BOOL   bHasPermit = FALSE;

  if ( !hwndDlg )
  {
    return ERROR_INVALID_PARAMETER;
  }
  
  hwndRemove = GetDlgItem(hwndDlg, CID_NetTab_PB_Remove);

  dwErr = RasSrvGetDatabaseHandle(
                hwndDlg, 
                ID_NETCOMP_DATABASE, 
                &hNetCompDatabase);

  if ( NO_ERROR != dwErr || 
       NULL == hwndRemove )
  {
    return ERROR_CAN_NOT_COMPLETE;
  }

  dwErr = netDbHasRemovePermission(
             hNetCompDatabase,
             iItem,
             &bHasPermit);

  if( NO_ERROR == dwErr )
  {
       EnableWindow( hwndRemove, bHasPermit);
  }

  return dwErr;

}


//
// Enables or disables the properties button based on whether
// the index of the given item in the list view can have properties
// invoked on it.  Currently, only non-ras-manaipulatable protocols 
// can not have their properties invoked.
//
DWORD 
NetTabEnableDisablePropButton(
    IN HWND hwndDlg, 
    IN INT iItem) 
{
    HANDLE hNetCompDatabase = NULL;
    DWORD dwErr;
    BOOL bHasUi;
    HWND hwndProps;

    // Get a reference to the network component database
    //
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    // Get the type and whether it is manipulatable
    //
    dwErr = netDbHasPropertiesUI (hNetCompDatabase, iItem, &bHasUi);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Enable or disable properties
    hwndProps = GetDlgItem(hwndDlg, CID_NetTab_PB_Properties);
    if (hwndProps)
    {
        EnableWindow(hwndProps, bHasUi);
    }
        
    return NO_ERROR;
}

//
// Refreshes the list view
//
DWORD 
NetTabRefreshListView(
    IN HWND hwndLV, 
    IN HANDLE hNetCompDatabase) 
{
    DWORD dwCount, dwErr; 
    HWND hwndDlg = GetParent(hwndLV);   
    // For whistler bug 440167      gangz
    //
    int iSelect = -1;

    iSelect = ListView_GetSelectionMark(
            GetDlgItem(hwndDlg, CID_NetTab_LV_Components)
                                        );
    
    // Get rid of all of the old elements in the list view
    //
    ListView_DeleteAllItems(hwndLV);
    
    // Re-stock the list views
    //
    dwErr = NetTabFillComponentList(hwndLV, hNetCompDatabase);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Select the first protocol in the list view if any items exist.  
    // Also in this case, make sure that "remove" is enabled/disabled
    // according to the the first item in the list view
    //
    netDbGetCompCount(hNetCompDatabase, &dwCount);
    if (dwCount) 
    {
        // For whistler bug 440167      gangz
        //
        if ( 0 > iSelect ||
             dwCount <= (DWORD)iSelect )
        {
            iSelect = 0;
        }
        
        ListView_SetItemState(
            hwndLV, 
            iSelect, 
            LVIS_SELECTED | LVIS_FOCUSED, 
            LVIS_SELECTED | LVIS_FOCUSED);

       ListView_EnsureVisible(hwndLV,
                              iSelect,
                              FALSE
                              );
       
      //for whistler bug 406698       gangz
      //
      NetTabEnableDisableRemoveButton (
                           hwndDlg,
                           iSelect); // For whistler bug 440167
    }

    // If there are no components, disable the properties 
    // and remove buttons
    else 
    {
        HWND hwndControl = GetDlgItem(hwndDlg, CID_NetTab_PB_Properties);
        if (hwndControl)
        {
            EnableWindow(hwndControl, FALSE);
        }
         
        hwndControl = GetDlgItem(hwndDlg, CID_NetTab_PB_Remove);
        if (hwndControl)
        {
            EnableWindow(hwndControl, FALSE);
        }
    }

    return NO_ERROR;
}

//
// Initializes the networking tab.  By now a handle to the advanced 
// database has been placed in the user data of the dialog
//
DWORD 
NetTabInitializeDialog(
    HWND hwndDlg, 
    WPARAM wParam)
{
    DWORD dwErr, dwCount, i;
    BOOL bFlag;
    HANDLE hNetCompDatabase = NULL, hMiscDatabase = NULL;
    HWND hwndLV;
    LV_COLUMN lvc;
    BOOL bExpose = FALSE, bIsServer;
    
    // Get handles to the databases we're interested in
    //
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_MISC_DATABASE, 
        &hMiscDatabase);
        
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    // Fill in the list view will all available protocols followed 
    // by all of the installed network components.
    //
    hwndLV = GetDlgItem(hwndDlg, CID_NetTab_LV_Components);
    if (hwndLV)
    {
        ListView_InstallChecks(hwndLV, Globals.hInstDll);
        ListView_SetNetworkComponentImageList(hwndLV, Globals.hInstDll);

        // Fill the list view
        NetTabRefreshListView(hwndLV, hNetCompDatabase);
    }

    //for whistler bug 347355       gangz
    //
    NetTabEnableDisablePropButton(
         hwndDlg, 
         0);

    NetTabEnableDisableRemoveButton (
         hwndDlg,
         0);

    if (hwndLV)
    {
        // Add a colum so that we'll display in report view
        lvc.mask = LVCF_FMT;
        lvc.fmt = LVCFMT_LEFT;
        ListView_InsertColumn(hwndLV,0,&lvc);
        ListView_SetColumnWidth(hwndLV, 0, LVSCW_AUTOSIZE_USEHEADER);
    }

    return NO_ERROR;
}

// Handles a check being made
DWORD 
NetTabHandleProtCheck(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    BOOL bEnable = FALSE, bEnabled = FALSE;
    DWORD dwErr = NO_ERROR, dwId = 0;
    HANDLE hNetCompDatabase = NULL;
    HWND hwndLV = 
        GetDlgItem(hwndDlg, CID_NetTab_LV_Components);
    MSGARGS MsgArgs;
    INT iRet;
    PWCHAR pszName = NULL;
    
    // Initailize the message arguments
    //
    ZeroMemory(&MsgArgs, sizeof(MsgArgs));

    // Find out whether the component is being enabled or
    // disabled
    if (hwndLV)
    {
        bEnable = !!ListView_GetCheck(hwndLV, dwIndex);
    }

    // Get the handle for the Prot database
    //
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    // Get component id
    //
    dwErr = netDbGetId(
                hNetCompDatabase,
                dwIndex,
                &dwId);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Get component name
    //
    dwErr = netDbGetName(
                hNetCompDatabase,
                dwIndex,
                &pszName);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Get component enabling
    //
    dwErr = netDbGetEnable(
                hNetCompDatabase,
                dwIndex,
                &bEnabled);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // If F&P is being unchecked, then popup the mmc warning
    //
    if ((dwId == NETCFGDB_ID_FILEPRINT) &&
        (bEnable == FALSE)              && 
        (bEnabled == TRUE))
    {
        // Ask the user whether we should bring up the 
        // mmc console to allow him/her to stop FPS.
        //
        MsgArgs.apszArgs[0] = pszName;
        MsgArgs.dwFlags = MB_YESNO;

        iRet = MsgDlgUtil(
                    GetActiveWindow(),
                    SID_STOP_FP_SERVICE,
                    &MsgArgs,
                    Globals.hInstDll,
                    WRN_TITLE);

        // If the user agrees, bring up the console
        //
        if (iRet == IDYES)
        {
            dwErr = RassrvLaunchMMC(RASSRVUI_SERVICESCONSOLE);
            if (dwErr != NO_ERROR)
            {
                return dwErr;
            }
        }
    }

    // If F&P is not being unchecked, treat the component
    // normally.
    //
    else
    {
        // Update the check
        dwErr = netDbSetEnable(hNetCompDatabase, dwIndex, bEnable);
                    
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
    }
    
    return NO_ERROR;
}

//
// Adds networking components
//
DWORD 
NetTabAddComponent(
    IN HWND hwndDlg) 
{
    HANDLE hNetCompDatabase = NULL;
    DWORD dwErr;

    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    dwErr = netDbRaiseInstallDialog(hNetCompDatabase, hwndDlg);
    if (dwErr == NO_ERROR || dwErr == NETCFG_S_REBOOT)
    {
        HWND hwndLVComp = GetDlgItem(hwndDlg, CID_NetTab_LV_Components);
        if (hwndLVComp)
        {
            NetTabRefreshListView(hwndLVComp, hNetCompDatabase);
        }

        NetTabDisableRollback(hwndDlg);            
    }
    if (dwErr == NETCFG_S_REBOOT)
    {
        RasSrvReboot(hwndDlg);
    }
    
    return dwErr;
}

//
// Removes networking components
//
DWORD 
NetTabRemoveComponent(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    HANDLE hNetCompDatabase = NULL;
    DWORD dwCount, dwErr;

    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    // or else, remove the requested component
    //
    dwErr = netDbRaiseRemoveDialog(
                hNetCompDatabase, 
                dwIndex, 
                hwndDlg);
                
    if (dwErr == NO_ERROR || dwErr == NETCFG_S_REBOOT) 
    {
        HWND hwndLVComp = GetDlgItem(hwndDlg, CID_NetTab_LV_Components);
        if (hwndLVComp)
        {
            NetTabRefreshListView(hwndLVComp, hNetCompDatabase);
        }

        NetTabDisableRollback(hwndDlg);            
    }
    if (dwErr == NETCFG_S_REBOOT)
    {
        RasSrvReboot(hwndDlg);
    }
    
    return dwErr;
}

// Edits network component properties
//
DWORD 
NetTabEditProperties(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    HANDLE hNetCompDatabase = NULL;
    DWORD dwCount, dwErr;

    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    dwErr = netDbRaisePropertiesDialog (
                hNetCompDatabase, 
                dwIndex, 
                hwndDlg);
                
    if (dwErr == NETCFG_S_REBOOT)
    {
        RasSrvReboot(hwndDlg);
    }

    return dwErr;
}

//
// Switch to mmc
//
DWORD 
NetTabSwitchToMMC(
    IN HWND hwndDlg) 
{
    if (RassrvWarnMMCSwitch(hwndDlg)) 
    {
        // Commit the changes to this property sheet 
        // and close it
        PropSheet_PressButton(GetParent(hwndDlg), PSBTN_OK);
        
        return RassrvLaunchMMC(RASSRVUI_NETWORKCONSOLE);
    }
    
    return ERROR_CANCELLED;
}    

//
// Handles the activation call
//
BOOL 
NetTabSetActive(
    IN HWND hwndDlg,
    IN WPARAM wParam)
{
    HANDLE hNetCompDatabase = NULL;
    DWORD dwErr;
    BOOL bRet = FALSE;
    
    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);

    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);
        
    if (! netDbIsLoaded(hNetCompDatabase)) 
    {
        dwErr = netDbLoad(hNetCompDatabase);
        if (dwErr == NO_ERROR)
        {
            NetTabInitializeDialog(
                hwndDlg, 
                wParam);
        }
        else 
        {
            NetTabDisplayError(
                hwndDlg, 
                ERR_CANT_SHOW_NETTAB_INETCFG);
                
            // reject activation
            SetWindowLongPtr(
                hwndDlg, 
                DWLP_MSGRESULT,
                -1);   
                
            bRet = TRUE;
        }
    }

    PropSheet_SetWizButtons(
        GetParent(hwndDlg), 
        PSWIZB_NEXT | PSWIZB_BACK);		

    return bRet;
}

//
// When the net tab receives WM_ACTIVATE, it means that 
// the user left the IC property sheet/wizard and is now coming back
// to it.  Since this occurs when switching to MMC update the UI as 
// here appropriate.
//
DWORD
NetTabActivate(
    IN HWND hwndDlg, 
    IN WPARAM wParam)
{    
    HANDLE hNetCompDatabase = NULL;
    DWORD dwErr = NO_ERROR;
    HWND hwndLVComp;

    if (LOWORD(wParam) == WA_INACTIVE)
    {
        return NO_ERROR;
    }

    DbgOutputTrace("NetTabActivate: updating components.");

    // Get the database handle
    //
    dwErr = RasSrvGetDatabaseHandle(
                hwndDlg, 
                ID_NETCOMP_DATABASE, 
                &hNetCompDatabase);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Update the appropriate components
    //
    dwErr = netDbReloadComponent(hNetCompDatabase, NETCFGDB_ID_FILEPRINT);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }
    
    // Refresh the net component list view
    //
    hwndLVComp = GetDlgItem(hwndDlg, CID_NetTab_LV_Components);
    if (hwndLVComp)
    {
        NetTabRefreshListView(hwndLVComp,hNetCompDatabase);
    }

    return NO_ERROR;        
}

//
// Handles commands
//
DWORD 
NetTabCommand(
    IN HWND hwndDlg,
    IN WPARAM wParam)
{
    HWND hwndControl = NULL;

    switch (wParam) 
    {
        case CID_NetTab_PB_Properties:
            hwndControl = GetDlgItem(hwndDlg, CID_NetTab_LV_Components);
            if (hwndControl)
            {
                NetTabEditProperties(hwndDlg, ListView_GetSelectionMark(hwndControl));
            }
            break;
            
        case CID_NetTab_PB_Add:
            NetTabAddComponent(hwndDlg);
            break;
            
        case CID_NetTab_PB_Remove:
            hwndControl = GetDlgItem(hwndDlg, CID_NetTab_LV_Components);
            if (hwndControl)
            {
                NetTabRemoveComponent(hwndDlg, ListView_GetSelectionMark(hwndControl));
            }
            break;
            
        case CID_NetTab_PB_SwitchToMMC:
            NetTabSwitchToMMC(hwndDlg);
            break;
    }

    return NO_ERROR;
}

//
// This is the dialog procedure that responds to messages sent 
// to the networking tab.
//
INT_PTR 
CALLBACK 
NetTabDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam) 
{
    // Filter the customized list view messages
    if (ListView_OwnerHandler(
            hwndDlg, 
            uMsg, 
            wParam, 
            lParam, 
            LvDrawInfoCallback )
        )
    {        
        return TRUE;
    }

    // Filter the customized ras server ui page messages. 
    // By filtering messages through here, we are able to 
    // call RasSrvGetDatabaseHandle below
    //
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch (uMsg) 
    {
        case WM_INITDIALOG:
            return 0;

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmNetTab);
            break;
        }


        case WM_NOTIFY:
            {
                NMHDR* pNotifyData;
                NM_LISTVIEW* pLvNotifyData;
    
                pNotifyData = (NMHDR*)lParam;
                switch (pNotifyData->code) 
                {
                    //
                    // Note: PSN_APPLY and PSN_CANCEL are handled
                    // by RasSrvMessageFilter
                    //
                    
                    // The item focus is changing -- update the 
                    // protocol description
                    case LVN_ITEMCHANGING:
                        pLvNotifyData = (NM_LISTVIEW*)lParam;
                        if (pLvNotifyData->uNewState & LVIS_SELECTED) 
                        {
                            NetTabUpdateDescription(
                                hwndDlg, 
                                pLvNotifyData->iItem);
                                
                            NetTabEnableDisablePropButton(
                                hwndDlg, 
                                pLvNotifyData->iItem);

                            //for whistler bug 347355       gangz
                            //
                            NetTabEnableDisableRemoveButton (
                                hwndDlg,
                                (DWORD)pLvNotifyData->iItem);

                        }
                        break;     

                    // The check of an item is changing
                    case LVXN_SETCHECK:
                        pLvNotifyData = (NM_LISTVIEW*)lParam;
                        NetTabHandleProtCheck(
                            hwndDlg, 
                            (DWORD)pLvNotifyData->iItem);
                        break;

                    case LVXN_DBLCLK:
                        pLvNotifyData = (NM_LISTVIEW*)lParam;
                        NetTabEditProperties(
                            hwndDlg, 
                            pLvNotifyData->iItem);
                        break;
                        
                    // The networking tab is becoming active.  
                    // Attempt to load the netcfg database at 
                    // this time.  If unsuccessful, pop up a  
                    // message and don't allow the activation.
                    case PSN_SETACTIVE:
                        return NetTabSetActive(hwndDlg, wParam);
                        break;
                }
            }
            break;

        case WM_ACTIVATE:
            NetTabActivate(hwndDlg, wParam);
            break;

        case WM_COMMAND:
            NetTabCommand(hwndDlg, wParam);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\rassrv.c ===
/*
    File    Rassrv.h

    Functions that perform ras server operations that can be implemented 
    independent of the ui.

    Paul Mayfield, 10/7/97
*/

#include "rassrv.h"

// ============================================================
// ============================================================
// Functions to maintain data accross property sheet pages.
// ============================================================
// ============================================================

// This message queries all other pages to find out if 
// any other ras server pages exist.  If this message is
// not responded to, then we know it's safe to cleanup
// any global context in the wizard/property sheet.
#define RASSRV_CMD_QUERY_LIVING     237     

// These commands hide and show ras server pages.
#define RASSRV_CMD_HIDE_PAGES       238
#define RASSRV_CMD_SHOW_PAGES       239

//
// Reasons for RasSrvSErviceInitialize to fail
//
#define RASSRV_REASON_SvcError     0
#define RASSRV_REASON_Pending      1

// 
// This structure defines the data that needs to be stored
// for each set of related property pages.  Multiple instances
// of this context can exist for each wizard/propsheet.
//
typedef struct _RASSRV_PAGESET_CONTEXT 
{
    HWND hwndSheet;
    HWND hwndFirstPage; // first to be activated in the set
    
    HANDLE hDeviceDatabase;
    HANDLE hUserDatabase;
    HANDLE hNetCompDatabase;
    HANDLE hMiscDatabase;

    DWORD dwPagesInited;  // Acts as a reference-count mechansim so we know
                          // what set of pages in the wizard/propsheet are
                          // referencing this context.
                                    
    BOOL bShow;           // Whether pages that ref this context show be vis.
    BOOL bCommitOnClose;  // Whether to commit settings changes on close
} RASSRV_PAGESET_CONTEXT;

//
// This structure defines the global context that is available on a 
// per-wizard/propsheet basis.  Even pages that don't share the same
// RASSRV_PAGESET_CONTEXT context will share this structure if they
// are owned by the same wizard/propsheet.
//
typedef struct _RASSRV_PROPSHEET_CONTEXT 
{
    BOOL  bRemoteAccessWasStarted;    
    BOOL  bRemoteAccessIsRunning;    
    BOOL  bLeaveRemoteAccessRunning; 
    DWORD dwServiceErr;
} RASSRV_PROPSHEET_CONTEXT;

DWORD 
APIENTRY 
RassrvCommitSettings (
    IN PVOID pvContext, 
    IN DWORD dwRasWizType);


DWORD
RassrvICConfigAccess(
    IN BOOL fSet,
    IN DWORD * pdwValue );


//
// Verifies that the current state of services in the system
// is condusive to configuring incoming connectins starting 
// services as needed.
//
DWORD 
RasSrvServiceInitialize(
    IN  RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx, 
    IN  HWND hwndSheet, 
    OUT LPDWORD lpdwReason)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hDialupService = NULL;
    BOOL bPending = FALSE;

    // If we already know there's an error, then there's no
    // need to proceed.
    //
    if (pPropSheetCtx->dwServiceErr)
    {
        return pPropSheetCtx->dwServiceErr;
    }

    // If we already started the service or if we already know the 
    // service is running, then there's nothing to do.
    //
    if (pPropSheetCtx->bRemoteAccessWasStarted || 
        pPropSheetCtx->bRemoteAccessIsRunning
       )
    {
        return NO_ERROR;
    }

    do 
    {
        // Get a reference to the service
        //
        dwErr = SvcOpenRemoteAccess(&hDialupService);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // See if we're pending something.
        //
        dwErr = SvcIsPending(hDialupService, &bPending);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // If the service is stopping, then we can't continue
        //
        if (bPending)
        {
            *lpdwReason = RASSRV_REASON_Pending;
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // See if we're started
        //
        dwErr = SvcIsStarted(
                    hDialupService, 
                    &(pPropSheetCtx->bRemoteAccessIsRunning));
        if (dwErr != NO_ERROR)
        {
            *lpdwReason = RASSRV_REASON_SvcError;
            pPropSheetCtx->dwServiceErr = dwErr;
            break;
        }
            
        // If we find out the service is running, there's nothing to do
        if (pPropSheetCtx->bRemoteAccessIsRunning) 
        {
            pPropSheetCtx->bLeaveRemoteAccessRunning = TRUE;
            break;
        }        

        // Start the service since it's not running.
        dwErr = RasSrvInitializeService();
        if (dwErr != NO_ERROR)
        {
            *lpdwReason = RASSRV_REASON_SvcError;
            pPropSheetCtx->dwServiceErr = dwErr;
            break;
        }

        // Record the fact that we did so.
        pPropSheetCtx->bRemoteAccessWasStarted = TRUE;
        pPropSheetCtx->bRemoteAccessIsRunning = TRUE;
        
    } while (FALSE);        

    // Cleanup
    {
        // Cleanup the reference to the dialup service
        //
        if (hDialupService)
        {
            SvcClose(hDialupService);
        }            
    }
    
    return dwErr;
}

//
// Abort any changes to the remoteaccess service that were made
// during RasSrvServiceInitialize
//
DWORD 
RasSrvServiceCleanup(
    IN HWND hwndPage) 
{
    DWORD dwErr;
    RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx = NULL;

    pPropSheetCtx = (RASSRV_PROPSHEET_CONTEXT *) 
        GetProp(GetParent(hwndPage), Globals.atmRassrvPageData);
        
    if (pPropSheetCtx == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // If we started the modified the remote access service, reverse 
    // the changes and record the fact that we did
    if (pPropSheetCtx->bRemoteAccessWasStarted) 
    {
        if ((dwErr = RasSrvCleanupService()) != NO_ERROR)
        {
            return dwErr;
        }
        
        pPropSheetCtx->bRemoteAccessWasStarted = FALSE;
        pPropSheetCtx->bLeaveRemoteAccessRunning = FALSE;
        pPropSheetCtx->bRemoteAccessIsRunning = FALSE;
    }

    return NO_ERROR;
}

//
// Intializes a property sheet.  This causes a handle to the 
// property sheet data object to be placed in the GWLP_USERDATA
// section of the window handle to the page.
//
DWORD 
RasSrvPropsheetInitialize(
    IN HWND hwndPage, 
    IN LPPROPSHEETPAGE pPropPage) 
{
    DWORD dwErr, dwPageId, dwShowCommand;
    RASSRV_PAGE_CONTEXT * pPageCtx = NULL;
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = NULL; 
    HWND hwndSheet = GetParent(hwndPage);
    int ret;
    
    // 
    // Retrieve the per page context as well as the per-page-set context.
    // these will have been provided by the caller and are placed in the
    // lparam.
    // 
    pPageCtx = (RASSRV_PAGE_CONTEXT *) pPropPage->lParam;
    pPageSetCtx = (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;
    
    // Associate the page's context with the page.
    //
    SetProp(hwndPage, Globals.atmRassrvPageData, (HANDLE)pPageCtx);

    // Record the handle to the property sheet.
    pPageSetCtx->hwndSheet = hwndSheet;

    return NO_ERROR;
}

//
// Callback occurs whenever a page is being created or 
// destroyed.
//
UINT 
CALLBACK 
RasSrvInitDestroyPropSheetCb(
    IN HWND hwndPage,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE pPropPage) 
{
    RASSRV_PAGE_CONTEXT * pPageCtx = NULL;
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = NULL;
    HWND hwndSheet = GetParent(hwndPage);
    BOOL bLastPage = FALSE, bStopService = FALSE;

    // Retrieve the per-page context
    //pPageCtx = (RASSRV_PAGE_CONTEXT *) 
    //    GetProp(hwndPage, Globals.atmRassrvPageData);
    pPageCtx = (RASSRV_PAGE_CONTEXT *) pPropPage->lParam;
    if (pPageCtx == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Get the per-group-of-related-pages context.  There may be multiple
    // instances of this context per wizard/property sheet.  For example, 
    // the Incoming connections wizard and the DCC host wizard both have 
    // sets of pages that share different contexts.  
    // 
    pPageSetCtx = (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;
    
    // This callback is only used for cleanup
    if (uMsg != PSPCB_RELEASE)
    {
        // Record that the given page is referencing
        // the given pageset context.
        pPageSetCtx->dwPagesInited |= pPageCtx->dwId;

        // Return true to indicate that the page should
        // be created.
        return TRUE;
    }

    // Cleanup the page set information.
    //
    if (pPageSetCtx != NULL)
    {
        // Record that this page is cleaned up
        pPageSetCtx->dwPagesInited &= ~(pPageCtx->dwId);

        // When the dwPagesInited variable hits zero,
        // it means that no other pages in the current
        // wizard/propsheet are referencing this propsheet
        // context.  Now is the time to cleanup all resources
        // held by the context.
        if (pPageSetCtx->dwPagesInited == 0) 
        {
            // Commit the settings if we are supposed to do 
            // so
            if (pPageSetCtx->bCommitOnClose) 
            {
                DbgOutputTrace("RasSrvCleanPropSht commit dbs.");
                RassrvCommitSettings ((PVOID)pPageSetCtx, pPageCtx->dwType);
            }

            // Close the databases
            DbgOutputTrace("RasSrvCleanPropSht closing dbs.");
            if (pPageSetCtx->hUserDatabase)
            {
                usrCloseLocalDatabase(pPageSetCtx->hUserDatabase);
            }
                
            if (pPageSetCtx->hDeviceDatabase)
            {
                devCloseDatabase(pPageSetCtx->hDeviceDatabase);
            }
                
            if (pPageSetCtx->hMiscDatabase)
            {
                miscCloseDatabase(pPageSetCtx->hMiscDatabase);
            }
                
            if (pPageSetCtx->hNetCompDatabase)
            {
                netDbClose(pPageSetCtx->hNetCompDatabase);
            }

            // Since there are no other pages referencing this property
            // sheet context, go ahead and free it.
            DbgOutputTrace (
                "RasSrvCleanPropSht %d freeing pageset data.", 
                pPageCtx->dwId);
            RassrvFree(pPageSetCtx);
        }
    }

    // Mark the page as dead
    SetProp (hwndPage, Globals.atmRassrvPageData, NULL);
    
    // This page is gone, so clear its context
    DbgOutputTrace (
        "RasSrvCleanPropSht %d freeing page data.", 
        pPageCtx->dwId);
    RassrvFree(pPageCtx);

    return NO_ERROR;
}

// For whistler 480871
//
DWORD
RasSrvIsICConfigured(
    OUT BOOL * pfConfig)
{
    DWORD dwErr = NO_ERROR, dwValue;

    if( NULL == pfConfig )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    dwErr = RassrvICConfigAccess( FALSE,   // Query Value
                                  &dwValue );
    if( NO_ERROR == dwErr )
    {
        *pfConfig = ( dwValue > 0 )? TRUE : FALSE;
    }
    
    return dwErr;
}

DWORD
RassrvSetICConfig(
    IN DWORD dwValue
        )
{
    return RassrvICConfigAccess( TRUE,  // Set Value
                                 &dwValue );
}

DWORD
RassrvICConfigAccess(
    IN BOOL fSet,
    IN DWORD * pdwValue
        )
{
    DWORD dwErr = NO_ERROR;
    const WCHAR pwszServiceKey[] =
        L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters";
    const WCHAR pwszValue[] = L"IcConfigured";
    HKEY hkParam = NULL;

    if ( NULL == pdwValue )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    do
    {
        // Attempt to open the service registry key
        dwErr = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    pwszServiceKey,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hkParam);

        // If we opened the key ok, then we can assume
        // that the service is installed
        if ( ERROR_SUCCESS != dwErr )
        {
            break;
        }

        // Set or Clear the IcConfigured Value
        //
        if ( fSet )
        {
            dwErr = RegSetValueExW( hkParam,
                                    pwszValue,
                                    0,
                                    REG_DWORD,
                                    (BYTE*)pdwValue,
                                    sizeof(DWORD)
                                   );
       }
       else // Query the IcConfigured Value
       {
       
            DWORD dwType, dwSize;

            dwSize = sizeof(DWORD);
            *pdwValue = 0;  
            RegQueryValueEx( hkParam,
                             pwszValue,
                             0,
                             &dwType,
                             (BYTE*)pdwValue,
                             &dwSize
                            );

       }
    }
    while(FALSE);

    if ( hkParam )
    {
        RegCloseKey( hkParam );
    }
    
    return dwErr;
}

// Commits any settings in the given context.
// 
DWORD 
APIENTRY 
RassrvCommitSettings (
    IN PVOID pvContext, 
    IN DWORD dwRasWizType) 
{
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *)pvContext;
        
    RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx = NULL;
    
    DbgOutputTrace ("RassrvCommitSettings entered : %x", dwRasWizType);

    if (pPageSetCtx) 
    {
        BOOL fCallSetPortMapping = TRUE;

        // Flush all appropriate settings
        if (pPageSetCtx->hUserDatabase)
        {
            usrFlushLocalDatabase(pPageSetCtx->hUserDatabase);
        }

        if (pPageSetCtx->hDeviceDatabase)
        {
            //This must be called before devFlushDatabase
            //for whistler bug 123769
            //
            fCallSetPortMapping = devIsVpnEnableChanged( pPageSetCtx->hDeviceDatabase );

            devFlushDatabase(pPageSetCtx->hDeviceDatabase);
        }
            
        if (pPageSetCtx->hMiscDatabase)
        {
            miscFlushDatabase(pPageSetCtx->hMiscDatabase);
        }
            
        if (pPageSetCtx->hNetCompDatabase)
        {
            netDbFlush(pPageSetCtx->hNetCompDatabase);
        }
            
        // Set state so that the service will not be stopped.
        if (pPageSetCtx->hwndSheet) 
        {
            DbgOutputTrace ("RassrvCommitSettings: keep svc running.");
            pPropSheetCtx = (RASSRV_PROPSHEET_CONTEXT *) 
                GetProp(pPageSetCtx->hwndSheet, Globals.atmRassrvPageData);
                
            if (pPropSheetCtx)
            {
                pPropSheetCtx->bLeaveRemoteAccessRunning = TRUE;
            }
        }
        
        //whistler bug 123769, 
        //<one of the scenarios>
        //Set up PortMapping for all possible connections
        //when we are going to create a Incoming Connection
        //with VPN enabled

        if ( fCallSetPortMapping &&
             FIsUserAdminOrPowerUser() &&
             IsFirewallAvailablePlatform() && //Add this for bug 342810
             IsGPAEnableFirewall() )  
        {
            HnPMConfigureIfVpnEnabled( TRUE, pPageSetCtx->hDeviceDatabase );
        }

        // For whistler 480871
        // Mark the registry if IC is configured
        RassrvSetICConfig( 1 ); 
    }

    return NO_ERROR;
}

//
// Causes the remoteaccess service to not be stopped even if the context
// associated with the given property sheet page is never committed.
//
DWORD 
RasSrvLeaveServiceRunning (
    IN HWND hwndPage) 
{
    RASSRV_PAGE_CONTEXT * pPageCtx = 
        (RASSRV_PAGE_CONTEXT *)GetProp(hwndPage, Globals.atmRassrvPageData);
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;
    RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx = NULL;
    
    DbgOutputTrace ("RasSrvLeaveServiceRunning entered for type");

    if (! pPageSetCtx)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // Let the property sheet know that some settings have been committed
    // so that it will not stop the remoteaccess service when it closes.
    if (pPageSetCtx->hwndSheet) 
    {
        DbgOutputTrace ("RasSrvLeaveServiceRunning: keep svc running.");
        pPropSheetCtx = (RASSRV_PROPSHEET_CONTEXT *) 
            GetProp(pPageSetCtx->hwndSheet, Globals.atmRassrvPageData);
        if (pPropSheetCtx)
        {
            pPropSheetCtx->bLeaveRemoteAccessRunning = TRUE;
        }
    }

    return NO_ERROR;
}

// Called just before a page is activated.  Return NO_ERROR to allow the 
// activation and an error code to reject it.
DWORD 
RasSrvActivatePage (
    IN HWND hwndPage, 
    IN NMHDR *pData) 
{
    BOOL fAdminOrPower;
    MSGARGS MsgArgs;


    RASSRV_PAGE_CONTEXT * pPageCtx = 
        (RASSRV_PAGE_CONTEXT *) 
            GetProp(hwndPage, Globals.atmRassrvPageData);
            
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;
        
    RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx = NULL;
    HWND hwndSheet = GetParent(hwndPage);
    DWORD dwErr, dwReason = 0;

    DbgOutputTrace("RasSrvActivatePage: Entered for %x", pPageCtx->dwId);

    ZeroMemory(&MsgArgs, sizeof(MsgArgs));
    MsgArgs.dwFlags = MB_OK;

    // Make sure we have a context for this page.
    if (!pPageSetCtx)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Record the first page in the page set if needed
    //
    if (pPageSetCtx->hwndFirstPage == NULL)
    {
        pPageSetCtx->hwndFirstPage = hwndPage;
    }

    // Make sure that we can show
    if (pPageSetCtx->bShow == FALSE) 
    {
        DbgOutputTrace("RasSrvActivatePage: Show turned off");
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Manipulate settings in the property sheet
    // context
    pPropSheetCtx = GetProp(hwndSheet, Globals.atmRassrvPageData);
       


    // Make sure everything's ok with the services we rely on.
    //
    if (pPropSheetCtx != NULL) 
    {

        //Check if the current user has enough privileges
        //For Whistler Bug #235091
        //
        fAdminOrPower = FIsUserAdminOrPowerUser();
        if ( !fAdminOrPower )
        {
            if (hwndPage == pPageSetCtx->hwndFirstPage)
            {
                MsgDlgUtil(
                    GetActiveWindow(),
                    ERR_SERVICE_NOT_GRANTED,
                    &MsgArgs,
                    Globals.hInstDll,
                    WRN_TITLE);

                PostMessage(hwndSheet, PSM_SETCURSEL, 0, 0);
            }

            return ERROR_CAN_NOT_COMPLETE;
        }

        dwErr = RasSrvServiceInitialize(
                    pPropSheetCtx, 
                    hwndPage,
                    &dwReason);

        if (dwErr != NO_ERROR)
        {
            if (hwndPage == pPageSetCtx->hwndFirstPage)
            {
                // Display the appropriate message
                //
                MsgDlgUtil(
                    GetActiveWindow(),
                    (dwReason == RASSRV_REASON_Pending) ? 
                        SID_SERVICE_StopPending          :
                        ERR_SERVICE_CANT_START,
                    &MsgArgs,
                    Globals.hInstDll,
                    WRN_TITLE);

                PostMessage(hwndSheet, PSM_SETCURSEL, 0, 0);
                PostMessage(hwndSheet, PSM_PRESSBUTTON, (WPARAM)PSBTN_NEXT, 0);
            }
                        
            return dwErr;
        }
    }        

    return NO_ERROR;
}

//
// Flags the context associated with the given page to have its settings 
// committed when the dialog closes
//
DWORD 
RasSrvCommitSettingsOnClose (
    IN HWND hwndPage) 
{
    RASSRV_PAGE_CONTEXT * pPageCtx = 
        (RASSRV_PAGE_CONTEXT *) GetProp(hwndPage, Globals.atmRassrvPageData);
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;

    pPageSetCtx->bCommitOnClose = TRUE;
    
    return NO_ERROR;
}

//
// Returns the id of the page whose handle is hwndPage
// 
DWORD 
RasSrvGetPageId (
    IN  HWND hwndPage, 
    OUT LPDWORD lpdwId) 
{
    RASSRV_PAGE_CONTEXT * pPageCtx = 
        (RASSRV_PAGE_CONTEXT *)GetProp(hwndPage, Globals.atmRassrvPageData);

    if (!lpdwId)
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    if (!pPageCtx)
    {
        return ERROR_NOT_FOUND;
    }

    *lpdwId = pPageCtx->dwId;

    return NO_ERROR;
}

// 
// Gets a handle to a particular database, opening the database
// as needed.
// 
DWORD 
RasSrvGetDatabaseHandle(
    IN  HWND hwndPage, 
    IN  DWORD dwDatabaseId, 
    OUT HANDLE * hDatabase) 
{
    RASSRV_PAGE_CONTEXT * pPageCtx = 
        (RASSRV_PAGE_CONTEXT *)GetProp(hwndPage, Globals.atmRassrvPageData);
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;
    
    if (!pPageSetCtx || !hDatabase)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Key off of the database id, opening databases as needed
    switch (dwDatabaseId) 
    {
        case ID_DEVICE_DATABASE:
            if (pPageSetCtx->hDeviceDatabase == NULL) 
            {
                devOpenDatabase(&(pPageSetCtx->hDeviceDatabase));    
            }
            *hDatabase = pPageSetCtx->hDeviceDatabase;
            break;
            
        case ID_USER_DATABASE:
            if (pPageSetCtx->hUserDatabase == NULL) 
            {
                usrOpenLocalDatabase(&(pPageSetCtx->hUserDatabase));    
            }
            *hDatabase = pPageSetCtx->hUserDatabase;
            break;
            
        case ID_MISC_DATABASE:
            if (pPageSetCtx->hMiscDatabase == NULL) 
            {
                miscOpenDatabase(&(pPageSetCtx->hMiscDatabase));    
            }
            *hDatabase = pPageSetCtx->hMiscDatabase;
            break;
            
        case ID_NETCOMP_DATABASE:
            {
                if (pPageSetCtx->hNetCompDatabase == NULL) 
                {
                    WCHAR buf[64], *pszString = NULL;
                    DWORD dwCount;

                    dwCount = GetWindowTextW(
                                GetParent(hwndPage), 
                                (PWCHAR)buf, 
                                sizeof(buf)/sizeof(WCHAR));
                    if (dwCount == 0)
                    {
                        pszString = (PWCHAR) PszLoadString(
                                        Globals.hInstDll, 
                                        SID_DEFAULT_CONNECTION_NAME);
                        lstrcpynW(
                            (PWCHAR)buf, 
                            pszString, 
                            sizeof(buf) / sizeof(WCHAR));
                    }
                    netDbOpen(&(pPageSetCtx->hNetCompDatabase), (PWCHAR)buf); 
                    
                 }
                *hDatabase = pPageSetCtx->hNetCompDatabase;
            }
            break;
            
        default:
            return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
}

// 
// Creates a context to associate with a set of 
// related pages in a property sheet or wizard.
// 
DWORD 
RassrvCreatePageSetCtx(
    OUT PVOID * ppvContext) 
{
    RASSRV_PAGESET_CONTEXT * pPageCtx = NULL;
    
    if (ppvContext == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate enough memory for a RASSRV_PAGESET_CONTEXT structure
    *ppvContext = RassrvAlloc (sizeof(RASSRV_PAGESET_CONTEXT), TRUE);
    if (*ppvContext == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize the page set context
    pPageCtx = ((RASSRV_PAGESET_CONTEXT*)(*ppvContext));
    pPageCtx->bShow = TRUE;
        
    return NO_ERROR;
}

// 
// Function causes the ras-server specific pages to allow 
// activation or not
//
DWORD 
APIENTRY 
RassrvShowWizPages (
    IN PVOID pvContext, 
    IN BOOL bShow) 
{
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *) pvContext;
    
    if (pPageSetCtx)
    {
        pPageSetCtx->bShow = bShow;
    }
                
    return NO_ERROR;
}

// 
// Returns the maximum number of pages for the
// a ras server wizard of the given type.  Return
// 0 to specify that a wizard not be run.
//
DWORD 
APIENTRY 
RassrvQueryMaxPageCount(
    IN DWORD dwRasWizType)
{
    BOOL bAllowWizard;
    DWORD dwErr;
    HANDLE hRasman;
    BOOL bTemp;

    // Find out if displaying the incoming connections wizard
    // is allowed.
    if (RasSrvAllowConnectionsWizard (&bAllowWizard) != NO_ERROR)
    {
        return 0;
    }

    // If the wizard is not to be run, return the appropriate 
    // count.
    if (! bAllowWizard)
    {
        return RASSRVUI_WIZ_PAGE_COUNT_SWITCH;                   
    }

    // At this point, we know that everything's kosher.  Return 
    // the number of pages that we support.
    switch (dwRasWizType) 
    {
        case RASWIZ_TYPE_INCOMING:
            return RASSRVUI_WIZ_PAGE_COUNT_INCOMING;
            break;
            
        case RASWIZ_TYPE_DIRECT:
            return RASSRVUI_WIZ_PAGE_COUNT_DIRECT;
            break;
    }
    
    return 0;
}

//
// Filters messages for RasSrv Property Pages.  If this function returns 
// true, the window proc of the dialog window should return true without
// processing the message.
//
// This message filter does the following:
//      1. Maintains databases and grants access to them.
//      2. Starts/stops remoteaccess service as needed.
//      3. Maintains the per-page, per-pageset, and per-wizard contexts.
//
BOOL 
RasSrvMessageFilter(
    IN HWND hwndDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx = NULL;
    
    switch (uMsg) 
    {
        // A page is being created.  Initailizes all contexts with respect
        // to this page and start services as needed.
        case WM_INITDIALOG:
            // Initialize and add the per-propsheet context if another
            // page has not already done so.
            // 
            {
                HWND hwndSheet = GetParent(hwndDlg);
                pPropSheetCtx = (RASSRV_PROPSHEET_CONTEXT *) 
                                    GetProp (
                                        hwndSheet, 
                                        Globals.atmRassrvPageData);
                if (!pPropSheetCtx) 
                {
                    pPropSheetCtx = 
                        RassrvAlloc(
                            sizeof(RASSRV_PROPSHEET_CONTEXT), 
                            TRUE);
                        
                    SetProp (
                        hwndSheet, 
                        Globals.atmRassrvPageData, 
                        (HANDLE)pPropSheetCtx);
                }        

                // Initialize the page
                RasSrvPropsheetInitialize(
                    hwndDlg, 
                    (LPPROPSHEETPAGE)lParam);
            }
            break;

        case WM_DESTROY:
            // WM_DESTROY is sent for each page that has been activated.
            // Cleanup the global data if it hasn't already been
            // cleaned up on a previous call to WM_DESTROY.
            // 
            {
                HWND hwndSheet = GetParent(hwndDlg);
                pPropSheetCtx = (RASSRV_PROPSHEET_CONTEXT *) 
                            GetProp(hwndSheet, Globals.atmRassrvPageData);
                if (pPropSheetCtx) 
                {
                    if (!pPropSheetCtx->bLeaveRemoteAccessRunning)
                    {
                        DbgOutputTrace("Stop service.");
                        RasSrvServiceCleanup(hwndDlg);
                    }                
                    DbgOutputTrace ("Free propsht data.");
                    RassrvFree (pPropSheetCtx);
                    
                    // Reset the global data
                    SetProp (hwndSheet, Globals.atmRassrvPageData, NULL);
                }  
            }
            break;

        case WM_NOTIFY: 
        {
            NMHDR * pNotifyData = (NMHDR*)lParam;
            
            switch (pNotifyData->code) 
            {
                // The page is becoming active.  
                case PSN_SETACTIVE:
                    DbgOutputTrace(
                        "SetActive: %x %x",
                        pNotifyData->hwndFrom,
                        pNotifyData->idFrom);
                        
                    if (RasSrvActivatePage(hwndDlg, pNotifyData) != NO_ERROR) 
                    {
                        // reject activation
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);   
                        return TRUE;
                    }
                    break;

                // Ok was pressed on the property sheet
                case PSN_APPLY:                    
                    RasSrvCommitSettingsOnClose (hwndDlg);
                    break;
            }
       }
       break;
        
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\rassrv.h ===
/*
    File    Rassrv.h

    Functions that perform ras server operations that can be implemented 
    independent of the ui.

    Paul Mayfield, 10/7/97
*/

#ifndef __rassrv_h
#define __rassrv_h

// Standard includes
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>	    // Windows base lib
#include <windowsx.h>
#include <mprapi.h>	        // Public router api's
#include <mprapip.h>        // Private router api's
#include <commctrl.h>	    // Common controls header
#include <lmaccess.h>	    // Needed to add new users
#include <lmapibuf.h>	    // " "         "  "
#include <lmerr.h>	        // " "         "  "
#include <stdlib.h>	        // duh
#include <uiutil.h>	        // Common ui utilities
#include <popupdlg.h>       // Msg box utilities
#include <debug.h>          // Trace/assert library
#include <inetcfgp.h>       // INetCfg interfaces
#include <rasman.h>         // rasman stuff used in devicedb
#include <dsrole.h>         // is this machine ntw, nts, dc, etc?
#include <raserror.h>		// some ras error codes we return
#include <devguid.h>


#define _PNP_POWER_
#include <ntdef.h>
#include "ndispnp.h"
#include "ntddip.h"			// IP_PNP_RECONFIG_REQUEST



// temporary
#include <stdio.h>	  // duh

// Definition of interface between shell and ras server ui
#include <rasuip.h>

// The resource file is in a common directory so that it gets
// built into rasdlg.dll.  Also, the help id file.
#include <rassrvrc.h>
#include <rassrvrh.h>

// Includes within the project
#include "utils.h"
#include "devicedb.h"
#include "hnportmapping.h"
#include "miscdb.h"
#include "userdb.h"
#include "netcfgdb.h"
#include "gentab.h"
#include "usertab.h"
#include "nettab.h"
#include "wizard.h"
#include "service.h"
#include "error.h"
#include "ipxui.h"
#include "tcpipui.h"
#include "mdm.h"

//gangz
//For secure password bug .Net 754400
#include "pwutil.h"

// ============================================================
// ============================================================
// Tab and property sheet identifiers.
// ============================================================
// ============================================================

// Property Sheet Page ID's
#define RASSRVUI_GENERAL_TAB        1
#define RASSRVUI_USER_TAB           2
#define RASSRVUI_ADVANCED_TAB       4
#define RASSRVUI_MULTILINK_TAB      8

// Wizard Page ID's
#define RASSRVUI_DEVICE_WIZ_TAB     16
#define RASSRVUI_VPN_WIZ_TAB        32
#define RASSRVUI_USER_WIZ_TAB       64
#define RASSRVUI_PROT_WIZ_TAB       128
#define RASSRVUI_FINISH_WIZ_TAB     256

// Wizard Page ID's for the direct connect wizard (host)
#define RASSRVUI_DCC_DEVICE_WIZ_TAB 512

// Wizard Page ID that allows us to pop up warning and 
// switch to mmc
#define RASSRVUI_SWITCHMMC_WIZ_TAB  1024

// Console page id's to be used for launching mmc consoles.
#define RASSRVUI_NETWORKCONSOLE     1
#define RASSRVUI_USERCONSOLE        2
#define RASSRVUI_MPRCONSOLE         3
#define RASSRVUI_SERVICESCONSOLE    4

// Wizard page counts to report to the shell
#define RASSRVUI_WIZ_PAGE_COUNT_INCOMING 5
#define RASSRVUI_WIZ_PAGE_COUNT_SWITCH   1
#define RASSRVUI_WIZ_PAGE_COUNT_DIRECT   2

// Reasons for restarting remoteaccess at commit time
#define RASSRVUI_RESTART_REASON_NONE            0
#define RASSRVUI_RESTART_REASON_NBF_ADDED       1
#define RASSRVUI_RESTART_REASON_NBF_REMOVED     2

// ============================================================
// ============================================================
// Functions to maintain data accross property sheet pages.
// ============================================================
// ============================================================

//
// This structure defines the information that needs 
// to be provided for each property sheet (wizard) page
// that uses the RasSrvMessageFilter.  The structure must be 
// passed in as the lParam member of the PROPSHEETPAGE of the page.
// 
typedef struct _RASSRV_PAGE_CONTEXT {
    DWORD dwId;         // ID_XXX value below
    DWORD dwType;       // RASWIZ_TYPE_XXX value
    PVOID pvContext;    // Created with RasSrvCreateContext
} RASSRV_PAGE_CONTEXT;

#define ID_DEVICE_DATABASE 1
#define ID_USER_DATABASE 2
#define ID_PROTOCOL_DATABASE 4
#define ID_MISC_DATABASE 8
#define ID_NETCOMP_DATABASE 16

// Helper function lets us know if we should display the
// connections ras server wizard.
DWORD 
APIENTRY
RasSrvAllowConnectionsWizard (
    OUT BOOL* pfAllow);
    
// Creates a context to be used to manage information associated 
// with a given page.
DWORD 
RassrvCreatePageSetCtx(
    OUT PVOID * ppvContext);

// Causes the remoteaccess service to not be stopped even if the context
// associated with the given property sheet page is never committed.
DWORD 
RasSrvLeaveServiceRunning (
    IN HWND hwndPage);

// Gets a handle to a particular database.  If this database needs 
// to be opened, it will be opened.  In order to use this function, 
// the window proc of hwndPage must first call into RasSrvMessageFilter.
DWORD 
RasSrvGetDatabaseHandle(
    IN HWND hwndPage, 
    IN DWORD dwDatabaseId, 
    IN HANDLE * hDatabase);

// Returns the id of the page whose handle is hwndPage
DWORD 
RasSrvGetPageId (
    IN  HWND hwndPage, 
    OUT LPDWORD lpdwId);

//
// Callback function for property sheet pages that cleans up 
// the page.
//
UINT 
CALLBACK 
RasSrvInitDestroyPropSheetCb(
    IN HWND hwndPage,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE pPropPage);

// Filters messages for RasSrv Property Pages.  If this function returns 
// true, the winproc of the dialog window should return true immediately.  
// Otherwise message processing may continue as normal.
BOOL 
RasSrvMessageFilter(
    IN HWND hwndDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam);

DWORD
RassrvSetICConfig(
    IN DWORD dwValue );

DWORD
RasSrvIsICConfigured(
    OUT BOOL * pfConfig);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\netcfgdb.c ===
/*
    File    netcfgdb.c

    Implements a database abstraction on top of the net config
    items needed by the ras server ui for connections.

    Paul Mayfield, 12/15/97
*/

#include <rassrv.h>
#include "protedit.h"

// Macro for bounds checking
#define netDbBoundsCheck(db, ind) (((ind) < (db)->dwCompCount) ? TRUE : FALSE)

//
// Defines function that sends pnp event through ndis
//
typedef
UINT
(* pNdisHandlePnpEventFunc)(
    IN      UINT                    Layer,
    IN      UINT                    Operation,
    IN      PUNICODE_STRING         LowerComponent,
    IN      PUNICODE_STRING         UpperComponent,
    IN      PUNICODE_STRING         BindList,
    IN      PVOID                   ReConfigBuffer,
    IN      UINT                    ReConfigBufferSize);

//
// Maps a protocol string to its integer id
//
typedef struct _COMP_MAPPING
{
    LPCTSTR pszId;
    DWORD   dwId;

} COMP_MAPPING;

//
// Defines attributes of a network component
//
typedef struct _RASSRV_NET_COMPONENT
{
    DWORD dwType;           // Is it client/service/protocol
    PWCHAR pszName;         // Display name
    PWCHAR pszDesc;         // Display description
    PWCHAR pszId;           // Id to destinguish which client/service, etc
    BOOL bManip;            // Whether is manipulatable by ras (ip, ipx, etc.)
    BOOL bHasUi;            // For whether has properties ui (non-manip only)
    INetCfgComponent * pINetCfgComp;

    // The following fields only apply to manipulatable
    // components (bManip == TRUE)
    //
    DWORD dwId;             // DWORD counterpart to pszId.
    BOOL bEnabled;          // whether it is enabled for dialin
    BOOL bEnabledOrig;      // original value of bEnabled (optimization)
    BOOL bExposes;          // whether it exposes the network its on
    LPBYTE pbData;          // pointer to protocol specific data
    BOOL bDataDirty;        // should the protocol specific data be flushed?

    //For whistler bug 347355
    //
    BOOL bRemovable;       //If this component removable //TCP/IP is not user removable
    
} RASSRV_NET_COMPONENT;

//
// Defines attributes of a network component database
//
typedef struct _RASSRV_COMPONENT_DB
{
    INetCfg * pINetCfg;
    BOOL bHasINetCfgLock;
    BOOL bInitCom;
    DWORD dwCompCount;
    BOOL bFlushOnClose;
    RASSRV_NET_COMPONENT ** pComps;
    PWCHAR pszClientName;
    INetConnectionUiUtilities * pNetConUtilities;

} RASSRV_COMPONENT_DB;

//
// Definitions of functions taken from ndis
//
const static WCHAR pszNdispnpLib[]  = L"ndispnp.dll";
const static CHAR  pszNidspnpFunc[] =  "NdisHandlePnPEvent";

// Parameters for the protocols
const static WCHAR pszRemoteAccessParamStub[]   =
    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\";
static WCHAR pszIpParams[]                      = L"Ip";
static WCHAR pszIpxParams[]                     = L"Ipx";
static WCHAR pszNetBuiParams[]                  = L"Nbf";
static WCHAR pszArapParams[]                    = L"AppleTalk";
static WCHAR pszShowNetworkToClients[]          = L"AllowNetworkAccess";
static WCHAR pszShowNetworkArap[]               = L"NetworkAccess";
static WCHAR pszEnableForDialin[]               = L"EnableIn";
static WCHAR pszIpPoolSubKey[]                  = L"\\StaticAddressPool\\0";

// Ip specific registry parameters
const static WCHAR pszIpFrom[]                  = L"From";
const static WCHAR pszIpTo[]                    = L"To";
const static WCHAR pszIpAddress[]               = L"IpAddress";
const static WCHAR pszIpMask[]                  = L"IpMask";
const static WCHAR pszIpClientSpec[]            = L"AllowClientIpAddresses";
const static WCHAR pszIpShowNetworkToClients[]  = L"AllowNetworkAccess";
const static WCHAR pszIpUseDhcp[]               = L"UseDhcpAddressing";

// Ipx specific registry paramters
const static WCHAR pszIpxAddress[]              = L"FirstWanNet";
const static WCHAR pszIpxClientSpec[]           = L"AcceptRemoteNodeNumber";
const static WCHAR pszIpxAutoAssign[]           = L"AutoWanNetAllocation";
const static WCHAR pszIpxAssignSame[]           = L"GlobalWanNet";

// Tcp specific registry parameters
const static WCHAR pszTcpipParamsKey[]
    = L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\";
const static WCHAR pszTcpEnableRouter[]         = L"IPEnableRouter";

const static WCHAR pszEmptyString[]             = L"";

//
// Initializes a unicode string
//
VOID SetUnicodeString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          psz )
{
    pustr->Buffer = (PWSTR)(psz);
    pustr->Length = (USHORT)(lstrlenW(pustr->Buffer) * sizeof(WCHAR));
    pustr->MaximumLength = pustr->Length + sizeof(WCHAR);
}

//
// Sets the expose property of a protocol
//
DWORD
protSetExpose(
    IN BOOL bExposes,
    IN DWORD dwId)
{
    PWCHAR pszProtocol = NULL, pszKey = NULL;
    PWCHAR pszAccess = pszShowNetworkToClients;
    DWORD dwErr;
    WCHAR pszProtKey[1024];

   bExposes = (bExposes) ? 1 : 0;

   // Base the registry location on the
   // id of the protocol
   switch (dwId)
   {
        case NETCFGDB_ID_IP:
            pszProtocol = (PWCHAR)pszIpParams;
            break;

        case NETCFGDB_ID_IPX:
            pszProtocol = (PWCHAR)pszIpxParams;
            break;

        case NETCFGDB_ID_NETBUI:
            pszProtocol = (PWCHAR)pszNetBuiParams;
            break;

        case NETCFGDB_ID_ARAP:
            pszProtocol = (PWCHAR)pszArapParams;
            pszAccess = (PWCHAR)pszShowNetworkArap;
            break;

        default:
            return ERROR_CAN_NOT_COMPLETE;
    }

    // Generate the registry key
    //
    wsprintfW(pszProtKey, L"%s%s", pszRemoteAccessParamStub, pszProtocol);
    if (! pszKey)
    {
        pszKey = pszProtKey;
    }

    // Set the value and return
    //
    dwErr = RassrvRegSetDw(bExposes, pszKey, pszAccess);

    return dwErr;
}

//
// Gets the expose property of a protocol
//
DWORD
protGetExpose(
    OUT BOOL* pbExposed,
    IN  DWORD dwId)
{
    PWCHAR pszProtocol = NULL, pszKey = NULL;
    PWCHAR pszAccess = pszShowNetworkToClients;
    DWORD dwErr;
    WCHAR pszProtKey[1024];

    switch (dwId)
    {
        case NETCFGDB_ID_IP:
            pszProtocol = (PWCHAR)pszIpParams;
            break;

        case NETCFGDB_ID_IPX:
            pszProtocol = (PWCHAR)pszIpxParams;
            break;

        case NETCFGDB_ID_NETBUI:
            pszProtocol = (PWCHAR)pszNetBuiParams;
            break;

        case NETCFGDB_ID_ARAP:
            pszProtocol = (PWCHAR)pszArapParams;
            pszAccess = (PWCHAR)pszShowNetworkArap;
            break;

        default:
            return ERROR_CAN_NOT_COMPLETE;
    }

    // Generate the registry key if needed
    if (! pszKey)
    {
        wsprintfW(
            pszProtKey,
            L"%s%s",
            pszRemoteAccessParamStub,
            pszProtocol);
        pszKey = pszProtKey;
    }

    // Get the value and return it
    dwErr = RassrvRegGetDw(pbExposed, TRUE, pszKey, pszAccess);

    return dwErr;
}

//
// Sets the enable property of a protocol
//
DWORD
protSetEnabling(
    IN BOOL bExposes,
    IN DWORD dwId)
{
    PWCHAR pszProtocol = NULL;
    DWORD dwErr;
    bExposes = (bExposes) ? 1 : 0;

    if (dwId == NETCFGDB_ID_IP)
    {
        pszProtocol = pszIpParams;
    }
    else if (dwId == NETCFGDB_ID_IPX)
    {
        pszProtocol = pszIpxParams;
    }
    else if (dwId == NETCFGDB_ID_NETBUI)
    {
        pszProtocol = pszNetBuiParams;
    }
    else if (dwId == NETCFGDB_ID_ARAP)
    {
        pszProtocol = pszArapParams;
    }

    if (pszProtocol)
    {
        WCHAR pszProtKey[512];

        wsprintfW(
            pszProtKey,
            L"%s%s",
            pszRemoteAccessParamStub,
            pszProtocol);

        dwErr = RassrvRegSetDw(bExposes, pszProtKey, pszEnableForDialin);
        if (dwErr != NO_ERROR)
        {
            DbgOutputTrace(
                "protSetEnabling: Failed for %S:  0x%08x",
                pszProtocol,
                dwErr);
        }

        return dwErr;
    }

    return ERROR_CAN_NOT_COMPLETE;
}

//
// Gets the Enabling property of a protocol
//
DWORD
protGetEnabling(
    OUT BOOL* pbExposed,
    IN  DWORD dwId)
{
    PWCHAR pszProtocol = NULL;
    DWORD dwErr;

    if (dwId == NETCFGDB_ID_IP)
    {
        pszProtocol = pszIpParams;
    }
    else if (dwId == NETCFGDB_ID_IPX)
    {
        pszProtocol = pszIpxParams;
    }
    else if (dwId == NETCFGDB_ID_NETBUI)
    {
        pszProtocol = pszNetBuiParams;
    }
    else if (dwId == NETCFGDB_ID_ARAP)
    {
        pszProtocol = pszArapParams;
    }

    if (pszProtocol)
    {
        WCHAR pszProtKey[512];

        wsprintfW(
            pszProtKey,
            L"%s%s",
            pszRemoteAccessParamStub,
            pszProtocol);

        dwErr = RassrvRegGetDw(
                    pbExposed,
                    TRUE,
                    pszProtKey,
                    pszEnableForDialin);
        if (dwErr != NO_ERROR)
        {
            DbgOutputTrace(
                "protGetEnabling: Failed for %S:  0x%08x",
                pszProtocol,
                dwErr);
        }

        return dwErr;
    }

    return ERROR_CAN_NOT_COMPLETE;
}

//
// Saves the enabling of a service out to the
// system.
//
DWORD
svcSetEnabling(
    IN RASSRV_NET_COMPONENT* pComp)
{
    HANDLE hService = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        // Or enable the component
        //
        if (pComp->bEnabled)
        {
            if (pComp->dwId == NETCFGDB_ID_FILEPRINT)
            {
                // Start the service
                //
                dwErr = SvcOpenServer(&hService);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
                dwErr = SvcStart(hService, 10);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
            }
        }

    } while (FALSE);

    // Cleanup
    {
        if (hService)
        {
            SvcClose(hService);
        }
    }

    return dwErr;
}

//
// Gets the enabling property of a service
//
DWORD
svcGetEnabling(
    OUT BOOL* pbExposed,
    IN  DWORD dwId)
{
    HANDLE hService = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        dwErr = SvcOpenServer(&hService);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        dwErr = SvcIsStarted(hService, pbExposed);
        if (dwErr != NO_ERROR)
        {
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hService)
        {
            SvcClose(hService);
        }
    }

    return dwErr;
}

//
// Loads the tcpip parameters from the system
//
DWORD
TcpipLoadParamsFromSystem(
    OUT TCPIP_PARAMS *pTcpipParams)
{
    WCHAR buf[256], pszKey[512];
    DWORD dwRet = NO_ERROR, dwErr;
    DWORD dwNet = 0, dwMask = 0;

    wsprintfW(pszKey, L"%s%s", pszRemoteAccessParamStub, pszIpParams);

    // Load the params from the various registry locations.
    dwErr = RassrvRegGetDw(
                &pTcpipParams->bUseDhcp,
                TRUE,
                pszKey,
                (const PWCHAR)pszIpUseDhcp);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipLoad: dhcp fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegGetDw(
                &pTcpipParams->bCaller,
                TRUE,
                pszKey,
                (const PWCHAR)pszIpClientSpec);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipLoad: clientspec fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    // Read in the "legacy" pool values (w2k RC1, w2k Beta3)
    //
    {
        WCHAR pszNet[256]=L"0.0.0.0", pszMask[256]=L"0.0.0.0";
        
        RassrvRegGetStr(
            pszNet,
            L"0.0.0.0",
            pszKey,
            (PWCHAR)pszIpAddress);
            
        RassrvRegGetStr(
            pszMask,
            L"0.0.0.0",
            pszKey,
            (PWCHAR)pszIpMask);

        dwNet = IpPszToHostAddr(pszNet);
        dwMask = IpPszToHostAddr(pszMask);
    }

    // Generate the path the the new registry values
    //
    wcscat(pszKey, pszIpPoolSubKey);

    // See if new info is stored by reading the "from"
    // value
    //
    dwErr = RassrvRegGetDwEx(
                &pTcpipParams->dwPoolStart,
                0,
                pszKey,
                (const PWCHAR)pszIpFrom,
                FALSE);

    // There is new info in the registry -- use it
    //
    if (dwErr == ERROR_SUCCESS)
    {
        // Read in the "to" value
        //
        dwErr = RassrvRegGetDwEx(
                    &pTcpipParams->dwPoolEnd,
                    0,
                    pszKey,
                    (const PWCHAR)pszIpTo,
                    FALSE);
        if (dwErr != NO_ERROR)
        {
            DbgOutputTrace("TcpipLoad: mask fail 0x%08x", dwErr);
            dwRet = dwErr;
        }
    }

    // There is not new data in the new section -- use legacy
    // values
    //
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        pTcpipParams->dwPoolStart = dwNet;
        pTcpipParams->dwPoolEnd = (dwNet + ~dwMask);
    }

    // An unexpected error occured
    //
    else if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipLoad: pool fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    return dwRet;
}

//
// Commits the given tcpip parameters to the system.
//
DWORD
TcpipSaveParamsToSystem(
    IN TCPIP_PARAMS * pTcpipParams)
{
    WCHAR pszKey[512];
    DWORD dwRet = NO_ERROR, dwErr;

    wsprintfW(pszKey, L"%s%s", pszRemoteAccessParamStub, pszIpParams);

    // Load the params from the various registry locations.
    dwErr = RassrvRegSetDw(
                pTcpipParams->bUseDhcp,
                pszKey,
                (const PWCHAR)pszIpUseDhcp);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipSave: dhcp fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegSetDw(
                pTcpipParams->bCaller,
                pszKey,
                (const PWCHAR)pszIpClientSpec);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipSave: callerspec fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    wcscat(pszKey, pszIpPoolSubKey);

    dwErr = RassrvRegSetDwEx(
                pTcpipParams->dwPoolStart,
                pszKey,
                (const PWCHAR)pszIpFrom,
                TRUE);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipSave: from fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegSetDwEx(
                pTcpipParams->dwPoolEnd,
                pszKey,
                (const PWCHAR)pszIpTo,
                TRUE);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipSave: to fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    return dwRet;
}

//
// Loads the ipx parameters from the system
//
DWORD
IpxLoadParamsFromSystem(
    OUT IPX_PARAMS *pIpxParams)
{
    WCHAR pszKey[512];
    DWORD dwRet = NO_ERROR, dwErr;

    wsprintfW(pszKey, L"%s%s", pszRemoteAccessParamStub, pszIpxParams);

    // Load the params from the various registry locations.
    dwErr = RassrvRegGetDw(
                &pIpxParams->bAutoAssign,
                TRUE,
                pszKey,
                (const PWCHAR)pszIpxAutoAssign);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxLoad: auto-assign fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegGetDw(
                &pIpxParams->bCaller,
                TRUE,
                pszKey,
                (const PWCHAR)pszIpxClientSpec);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxLoad: client-spec fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegGetDw(
                &pIpxParams->dwIpxAddress,
                0,
                pszKey,
                (const PWCHAR)pszIpxAddress);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxLoad: address fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegGetDw(
                &pIpxParams->bGlobalWan,
                0,
                pszKey,
                (const PWCHAR)pszIpxAssignSame);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxLoad: same-addr fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    return dwRet;
}

//
// Commits the given ipx parameters to the system.
//
DWORD
IpxSaveParamsToSystem(
    IN IPX_PARAMS * pIpxParams)
{
    WCHAR pszKey[512];
    DWORD dwRet = NO_ERROR, dwErr;

    wsprintfW(pszKey, L"%s%s", pszRemoteAccessParamStub, pszIpxParams);

    // Save params to the various registry locations.
    dwErr = RassrvRegSetDw(
                pIpxParams->bAutoAssign,
                pszKey,
                (const PWCHAR)pszIpxAutoAssign);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxSave: auto-addr save 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegSetDw(
                pIpxParams->bCaller,
                pszKey,
                (const PWCHAR)pszIpxClientSpec);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxSave: client-spec fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegSetDw(
                pIpxParams->dwIpxAddress,
                pszKey,
                (const PWCHAR)pszIpxAddress);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxSave: addr save 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegSetDw(
                pIpxParams->bGlobalWan,
                pszKey,
                (const PWCHAR)pszIpxAssignSame);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxSave: assign-same fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    return dwRet;
}

//
// Dialog procedure that handles the editing of generic protocol
// information. Dialog proc that governs the ipx settings dialog
//
INT_PTR
CALLBACK
GenericProtSettingsDialogProc (
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            PROT_EDIT_DATA* pEditData = ((PROT_EDIT_DATA*)lParam);

            // Set the network exposure check
            SendDlgItemMessage(
                hwndDlg,
                CID_NetTab_GenProt_CB_ExposeNetwork,
                BM_SETCHECK,
                (pEditData->bExpose) ? BST_CHECKED : BST_UNCHECKED,
                0);
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
            return FALSE;
        }
        break;

        case WM_DESTROY:
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);
            break;

        case WM_COMMAND:
            {
                PROT_EDIT_DATA * pEditData = (PROT_EDIT_DATA*)
                    GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

                switch (wParam)
                {
                    case IDOK:
                        pEditData->bExpose =
                            SendDlgItemMessage(
                                hwndDlg,
                                CID_NetTab_GenProt_CB_ExposeNetwork,
                                BM_GETCHECK,
                                0,
                                0) == BST_CHECKED;
                        EndDialog(hwndDlg, 1);
                        break;

                    case IDCANCEL:
                        EndDialog(hwndDlg, 0);
                        break;
                }
            }
            break;
    }

    return FALSE;
}

//
// Function edits the properties of a generic protocol,
// that is a protocol that has no ras-specific properties.
//
DWORD
GenericProtocolEditProperties(
    IN HWND hwndParent,
    IN OUT PROT_EDIT_DATA * pEditData,
    IN OUT BOOL * pbCommit)
{
    DWORD dwErr;
    INT_PTR iRet;

    // Popup the dialog box
    iRet = DialogBoxParam(
            Globals.hInstDll,
            MAKEINTRESOURCE(DID_NetTab_GenProt),
            hwndParent,
            GenericProtSettingsDialogProc,
            (LPARAM)pEditData);

    // If ok was pressed, save off the new settings
    *pbCommit = FALSE;
    if ( (iRet) && (iRet != -1) )
    {
        *pbCommit = TRUE;
    }

    return NO_ERROR;
}

//
// Releases resources reserved by this
// network component database.
//
DWORD
netDbCleanup(
    RASSRV_COMPONENT_DB* This)
{
    DWORD i, dwCount;

    // Free all of the strings
    if (This->pComps)
    {
        for (i = 0; i < This->dwCompCount; i++)
        {
            if (This->pComps[i])
            {
                if (This->pComps[i]->pINetCfgComp)
                {
                    dwCount = INetCfgComponent_Release(
                                This->pComps[i]->pINetCfgComp);
                                
                    DbgOutputTrace(
                        "netDbCleanup: %ls ref=%x", 
                        This->pComps[i]->pszId,
                        dwCount);
                }
                if (This->pComps[i]->pszName)
                {
                    CoTaskMemFree(This->pComps[i]->pszName);
                }
                if (This->pComps[i]->pszDesc)
                {
                    CoTaskMemFree(This->pComps[i]->pszDesc);
                }
                if (This->pComps[i]->pszId)
                {
                    CoTaskMemFree(This->pComps[i]->pszId);
                }
                RassrvFree(This->pComps[i]);
            }
        }
        RassrvFree(This->pComps);
    }

    // Reset all of the values
    This->dwCompCount = 0;
    This->pComps = 0;

    return NO_ERROR;
}

//
// Loads in the netshell library which is responsible for adding
// and removing network components
//
DWORD
netDbLoadNetShell (
    RASSRV_COMPONENT_DB* This)
{
    if (!This->pNetConUtilities)
    {
        HRESULT hr;

        hr = HrCreateNetConnectionUtilities(&This->pNetConUtilities);
        if (FAILED(hr))
        {
            DbgOutputTrace("LoadNetShell: loadlib fial 0x%08x", hr);
        }
    }

    return NO_ERROR;
}

//
// Loads protocol specific info for a ras-manipulatable protocol.  This
// function assumes that the component passed in is a ras-manipulatable
// component. (tcpip, ipx, nbf, arap)
//
DWORD
netDbLoadProtcolInfo(
    IN OUT RASSRV_NET_COMPONENT * pNetComp)
{
    LPBYTE pbData;

    // Initialize the dirty bit and the data
    pNetComp->bDataDirty = FALSE;
    pNetComp->pbData = NULL;

    // Get the enabled and exposed properties
    protGetEnabling(&(pNetComp->bEnabled), pNetComp->dwId);
    protGetExpose(&(pNetComp->bExposes), pNetComp->dwId);
    pNetComp->bEnabledOrig = pNetComp->bEnabled;

    // Load protocol specific data
    //
    switch (pNetComp->dwId)
    {
        case NETCFGDB_ID_IP:
            pNetComp->pbData = RassrvAlloc(sizeof(TCPIP_PARAMS), TRUE);
            if (pNetComp->pbData == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            TcpipLoadParamsFromSystem((TCPIP_PARAMS*)(pNetComp->pbData));
            break;

        case NETCFGDB_ID_IPX:
            pNetComp->pbData = RassrvAlloc(sizeof(IPX_PARAMS), TRUE);
            if (pNetComp->pbData == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            IpxLoadParamsFromSystem((IPX_PARAMS*)(pNetComp->pbData));
            break;
    }

    return NO_ERROR;
}

//
// Loads service specific info for a ras-manipulatable service.  This
// function assumes that the component passed in is a ras-manipulatable
// component.
//
DWORD
netDbLoadServiceInfo(
    IN OUT RASSRV_NET_COMPONENT * pNetComp)
{
    // Get the enabled property
    //
    svcGetEnabling(&(pNetComp->bEnabled), pNetComp->dwId);
    pNetComp->bEnabledOrig = pNetComp->bEnabled;

    return NO_ERROR;
}

//
// Returns the protol id of the given component
//
DWORD
netDbLoadCompId (
    IN OUT RASSRV_NET_COMPONENT * pNetComp)
{
    DWORD i;
    static const COMP_MAPPING pManipCompMap [] =
    {
        { NETCFG_TRANS_CID_MS_TCPIP,     NETCFGDB_ID_IP },
        { NETCFG_TRANS_CID_MS_NWIPX,     NETCFGDB_ID_IPX },
        { NETCFG_TRANS_CID_MS_NETBEUI,   NETCFGDB_ID_NETBUI },
        { NETCFG_TRANS_CID_MS_APPLETALK, NETCFGDB_ID_ARAP },
        { NETCFG_SERVICE_CID_MS_SERVER,  NETCFGDB_ID_FILEPRINT }
    };

    // See if the id matches any of the protocols that we manage.
    //
    pNetComp->dwId = NETCFGDB_ID_OTHER;
    for (i = 0; i < sizeof(pManipCompMap)/sizeof(*pManipCompMap); i++)
    {
        if (lstrcmpi(pNetComp->pszId, pManipCompMap[i].pszId) == 0)
        {
            pNetComp->dwId = pManipCompMap[i].dwId;
            break;
        }
    }

    return pNetComp->dwId;
}

//
// Returns TRUE if this iNetCfg component is not hidden and if
// it successfully yeilds it's information.
//
BOOL
netDbGetCompInfo(
    IN INetCfgComponent * pComponent,
    IN OUT RASSRV_NET_COMPONENT * pNetComp,
    IN RASSRV_COMPONENT_DB * pCompDb )
{
    DWORD dwCharacter;
    GUID Guid;
    WCHAR * pszwId = NULL;
    HRESULT hr = S_OK, hr2;

    // Make sure that this is not a "hidden" component
    //
    hr = INetCfgComponent_GetCharacteristics (pComponent, &dwCharacter);
    if ( (FAILED(hr)) || (dwCharacter & NCF_HIDDEN) )
    {
        return FALSE;
    }
    
    // 
    //for .Net 605988 filter out IPX, at this point
    //pNetComp->pszId should be valid
    //
    if ( SUCCEEDED(INetCfgComponent_GetId (pComponent, &pszwId) ) )
    {
        WCHAR * pszwTmpId = NULL;

        pszwTmpId  = StrDupWFromT(NETCFG_TRANS_CID_MS_NWIPX);
            
        if(pszwTmpId)
        {
            if ( 0 == lstrcmpW(pszwId, pszwTmpId))
            {
                Free0(pszwTmpId);
                CoTaskMemFree(pszwId);
                return FALSE;
            }
            
            Free0(pszwTmpId);
       }

        pszwTmpId  = StrDupWFromT( TEXT("ms_nwnb") );
            
        if(pszwTmpId)
        {
            if ( 0 == lstrcmpW(pszwId, pszwTmpId))
            {
                Free0(pszwTmpId);
                CoTaskMemFree(pszwId);
                return FALSE;
            }
            
            Free0(pszwTmpId);
       }


       CoTaskMemFree(pszwId);
    }



    // Get the display name
    hr = INetCfgComponent_GetDisplayName (pComponent, &pNetComp->pszName);
    if (FAILED(hr))
    {
        return FALSE;
    }

    // Assign the has properties value
    pNetComp->bHasUi = !!(dwCharacter & NCF_HAS_UI);

    // pmay: 323274
    //
    // Make sure that the component can display properties without
    // a context if it claims to support displaying properties.
    //
    if (pNetComp->bHasUi)
    {
        hr2 = INetCfgComponent_RaisePropertyUi(
                    pComponent,
                    GetActiveWindow(),
                    NCRP_QUERY_PROPERTY_UI,
                    NULL);
        pNetComp->bHasUi = !!(hr2 == S_OK);
    }
    
    // Load the rest of the props
    if (FAILED(INetCfgComponent_GetClassGuid (pComponent, &Guid))         ||
        FAILED(INetCfgComponent_GetId (pComponent, &pNetComp->pszId))     ||
        FAILED(INetCfgComponent_GetHelpText(pComponent, &pNetComp->pszDesc))
       )
    {
        DbgOutputTrace("GetCompInfo: fail %S", pNetComp->pszName);
        return FALSE;
    }
  
    // Assign the type
    if (memcmp(&Guid, &GUID_DEVCLASS_NETCLIENT, sizeof(GUID)) == 0)
    {
        pNetComp->dwType = NETCFGDB_CLIENT;
    }
    else if (memcmp(&Guid, &GUID_DEVCLASS_NETSERVICE, sizeof(GUID)) == 0)
    {
        pNetComp->dwType = NETCFGDB_SERVICE;
    }
    else
    {
        pNetComp->dwType = NETCFGDB_PROTOCOL;
    }

    // If this is a protocol that ras server can manipulate,
    // initailize its additional fields here.
    pNetComp->dwId = netDbLoadCompId(pNetComp);
    if (pNetComp->dwId != NETCFGDB_ID_OTHER)
    {
        if (pNetComp->dwType == NETCFGDB_PROTOCOL)
        {
            netDbLoadProtcolInfo(pNetComp);
        }
        else if (pNetComp->dwType == NETCFGDB_SERVICE)
        {
            netDbLoadServiceInfo(pNetComp);
        }

        pNetComp->bManip = TRUE;
    }

    // Assign the inetcfg component
    pNetComp->pINetCfgComp = pComponent;
    INetCfgComponent_AddRef(pComponent);

    //For whistler bug  347355
    //
    {
        BOOL fEnableRemove=FALSE;
        DWORD dwFlags;
      
        fEnableRemove = INetConnectionUiUtilities_UserHasPermission(
                                       pCompDb->pNetConUtilities,
                                       NCPERM_AddRemoveComponents);

        hr = INetCfgComponent_GetCharacteristics(pComponent, &dwFlags );
        if( SUCCEEDED(hr) && (NCF_NOT_USER_REMOVABLE & dwFlags) )
        {
            fEnableRemove = FALSE;
        }

        pNetComp->bRemovable = fEnableRemove;
    }

    return TRUE;
}

//
// Raise the ui for a ras-manipulatable protocol
//
DWORD
netDbRaiseRasProps(
    IN RASSRV_NET_COMPONENT * pNetComp,
    IN HWND hwndParent)
{
    PROT_EDIT_DATA ProtEditData;
    TCPIP_PARAMS TcpParams;
    IPX_PARAMS IpxParams;
    BOOL bOk;
    DWORD dwErr;

    // Initialize the protocol data properties structure
    //
    ProtEditData.bExpose = pNetComp->bExposes;
    ProtEditData.pbData = NULL;

    // Launch the appropriate ui
    switch (pNetComp->dwId)
    {
        case NETCFGDB_ID_IP:
            CopyMemory(&TcpParams, pNetComp->pbData, sizeof(TCPIP_PARAMS));
            ProtEditData.pbData = (LPBYTE)(&TcpParams);
            dwErr = TcpipEditProperties(hwndParent, &ProtEditData, &bOk);
            if (dwErr != NO_ERROR)
            {
                return dwErr;
            }
            if (bOk)
            {
                pNetComp->bDataDirty = TRUE;
                CopyMemory(
                    pNetComp->pbData,
                    &TcpParams,
                    sizeof(TCPIP_PARAMS));
                pNetComp->bExposes = ProtEditData.bExpose;;
            }
            break;

        case NETCFGDB_ID_IPX:
            CopyMemory(&IpxParams, pNetComp->pbData, sizeof(IPX_PARAMS));
            ProtEditData.pbData = (LPBYTE)(&IpxParams);
            dwErr = IpxEditProperties(hwndParent, &ProtEditData, &bOk);
            if (dwErr != NO_ERROR)
            {
                return dwErr;
            }
            if (bOk)
            {
                pNetComp->bDataDirty = TRUE;
                CopyMemory(pNetComp->pbData, &IpxParams, sizeof(IPX_PARAMS));
                pNetComp->bExposes = ProtEditData.bExpose;;
            }
            break;

        default:
            dwErr = GenericProtocolEditProperties(
                        hwndParent,
                        &ProtEditData,
                        &bOk);
            if (dwErr != NO_ERROR)
            {
                return dwErr;
            }
            if (bOk)
            {
                pNetComp->bDataDirty = TRUE;
                pNetComp->bExposes = ProtEditData.bExpose;;
            }
            break;
    }

    return NO_ERROR;
}

//
// Comparison function used to sort the network components
// It's easier to implement here rather than the UI
//
int
__cdecl
netDbCompare (
    CONST VOID* pElem1,
    CONST VOID* pElem2)
{
    RASSRV_NET_COMPONENT * pc1 = *((RASSRV_NET_COMPONENT **)pElem1);
    RASSRV_NET_COMPONENT * pc2 = *((RASSRV_NET_COMPONENT **)pElem2);

    if (pc1->bManip == pc2->bManip)
    {
        if (pc1->bManip == FALSE)
        {
            return 0;
        }

        if (pc1->dwId == pc2->dwId)
        {
            return 0;
        }
        else if (pc1->dwId < pc2->dwId)
        {
            return -1;
        }

        return 1;
    }
    else if (pc1->bManip)
    {
        return -1;
    }

    return 1;
}

//
// Opens the database of network config components
//
DWORD
netDbOpen (
    OUT PHANDLE phNetCompDatabase,
    IN  PWCHAR pszClientName)
{
    RASSRV_COMPONENT_DB * This;
    DWORD dwLength;

    // Validate parameters
    if (! phNetCompDatabase || !pszClientName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the database
    This = RassrvAlloc (sizeof(RASSRV_COMPONENT_DB), TRUE);
    if (This == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize
    dwLength = wcslen(pszClientName);
    if (dwLength)
    {
        This->pszClientName =
            RassrvAlloc((dwLength + 1) * sizeof(WCHAR), FALSE);
        if (This->pszClientName)
        {
            wcscpy(This->pszClientName, pszClientName);
        }
    }
    This->bFlushOnClose = FALSE;
    *phNetCompDatabase = (HANDLE)This;

    // Load the net shell library
    netDbLoadNetShell(This);

    return NO_ERROR;
}

//
// Cleans up all resources held by the database
//
DWORD
netDbClose (
    IN HANDLE hNetCompDatabase)
{
    RASSRV_COMPONENT_DB* This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate parameters
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Flush if needed
    if (This->bFlushOnClose)
    {
        netDbFlush(hNetCompDatabase);
    }
    else
    {
        // If we've made changes to inetcfg that require backing out,
        // do so now.
        if (This->pINetCfg)
        {
            INetCfg_Cancel(This->pINetCfg);
        }
    }
    netDbCleanup(This);

    // Free the client name
    if (This->pszClientName)
    {
        RassrvFree(This->pszClientName);
    }

    // Release our reference to inetcfg.  We will still have it
    // at this point if a protocol/client/service was added.
    if (This->pINetCfg)
    {
        HrUninitializeAndReleaseINetCfg (
            This->bInitCom,
            This->pINetCfg,
            This->bHasINetCfgLock);
    }

    // Free the netshell library if appropriate
    if (This->pNetConUtilities)
    {
        INetConnectionUiUtilities_Release(This->pNetConUtilities);
    }

    // Free this
    RassrvFree(This);

    return NO_ERROR;
}

// Commits all changes to the database to the system
DWORD
netDbFlush (
    IN HANDLE hNetCompDatabase)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    RASSRV_NET_COMPONENT* pComp = NULL;
    DWORD i;

    // Validate parameters
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Flush any ras-manipulatable's data if dirty
    for (i = 0; i < This->dwCompCount; i++)
    {
        pComp = This->pComps[i];

        // If the enabling of this component has changed, commit
        // that change
        if ((pComp->bEnabled != pComp->bEnabledOrig) && (pComp->bManip))
        {
            if (pComp ->dwType == NETCFGDB_PROTOCOL)
            {
                protSetEnabling(
                    pComp->bEnabled,
                    pComp->dwId);
            }
            else if (pComp->dwType == NETCFGDB_SERVICE)
            {
                svcSetEnabling(pComp);
            }
        }

        // If the ras-server-specific properties of the component
        // have changed, commit the changes.
        if (pComp->bDataDirty)
        {
            protSetExpose(pComp->bExposes, pComp->dwId);

            switch (pComp->dwId)
            {
                case NETCFGDB_ID_IP:
                {
                    TCPIP_PARAMS* pTcpParams =
                        (TCPIP_PARAMS*)(pComp->pbData);

                    TcpipSaveParamsToSystem(pTcpParams);
                }
                break;

                case NETCFGDB_ID_IPX:
                {
                    IPX_PARAMS* pIpxParams =
                        (IPX_PARAMS*)(pComp->pbData);

                    IpxSaveParamsToSystem(pIpxParams);
                }
                break;
            }
        }
    }

    // If we have a pointer to the inetcfg instance then we can
    // commit the changes now
    if (This->pINetCfg)
    {
        INetCfg_Apply(This->pINetCfg);
    }

    return NO_ERROR;
}

//
// Loads the net config database for the first time.  Because inetcfg
// requires time to load and be manipulated, we delay the load of this
// database until it is explicitly requested.
//
DWORD
netDbLoad(
    IN HANDLE hNetCompDatabase)
{
    return netDbReload(hNetCompDatabase);
}

//
// Reloads net information from system
//
DWORD
netDbReload(
    IN HANDLE hNetCompDatabase)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    DWORD i, j, dwProtCount = 0, dwRefCount;
    HRESULT hr;
    RASSRV_NET_COMPONENT TempComp;
    INetCfgComponent* pComponents [256];
    PWCHAR pszName = NULL;
    static const GUID* c_apguidClasses [] =
    {
        &GUID_DEVCLASS_NETTRANS,
        &GUID_DEVCLASS_NETCLIENT,
        &GUID_DEVCLASS_NETSERVICE,
    };

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DbgOutputTrace(
        "netDbReload %x %x %x %x %x %x %x %x", 
        This->pINetCfg, 
        This->bHasINetCfgLock,
        This->bInitCom,
        This->dwCompCount,
        This->bFlushOnClose,
        This->pComps,
        This->pszClientName,
        This->pNetConUtilities);

    // Cleanup any previous values
    netDbCleanup(This);

    // If we don't have a reference to inetcfg yet, get it
    // here.
    if (This->pINetCfg == NULL)
    {
        This->bInitCom = TRUE;
        This->bHasINetCfgLock = TRUE;
        hr = HrCreateAndInitializeINetCfg(
                &This->bInitCom,
                &This->pINetCfg,
                TRUE,
                0,
                This->pszClientName,
                NULL);
        // Handle error conditions here
        if (S_FALSE == hr)
        {
            return ERROR_CAN_NOT_COMPLETE;
        }
        else if (FAILED(hr))
        {
            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    //
    // Enumerate all of the client and service components in the system.
    //
    hr = HrEnumComponentsInClasses (
            This->pINetCfg,
            sizeof(c_apguidClasses) / sizeof(c_apguidClasses[0]),
            (GUID**)c_apguidClasses,
            sizeof(pComponents) / sizeof(pComponents[0]),
            pComponents,
            &This->dwCompCount);
    if (!SUCCEEDED(hr))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Initialize the array of internal objects
    This->pComps = RassrvAlloc (
                    This->dwCompCount * sizeof (RASSRV_NET_COMPONENT*),
                    TRUE);
    if (!This->pComps)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize the installed component array
    //
    j = 0;
    ZeroMemory(&TempComp, sizeof(TempComp));
    for (i = 0; i < This->dwCompCount; i++)
    {
        pszName = L"";

        //Add this (RASSRV_COMPONENT_DB *) for whistler bug 347355
        //
        if (netDbGetCompInfo(pComponents[i], &TempComp, This))
        {
            //
            //  Currently we do not support IPv6 for incoming connections.
            //  If this component is IPv6, skip it
            //
            if ((TempComp.dwType == NETCFGDB_PROTOCOL) &&
                (lstrcmpi(TempComp.pszId, TEXT("ms_tcpip6")) == 0))
            {
                dwRefCount = INetCfgComponent_Release(pComponents[i]);
                DbgOutputTrace(
                    "netDbReload: skipping %ls ref=%d", pszName, dwRefCount);
                continue;
            }
            
            This->pComps[j] =
                RassrvAlloc (sizeof(RASSRV_NET_COMPONENT), FALSE);
            if (!This->pComps[j])
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            // Fill in the fields
            CopyMemory(This->pComps[j], &TempComp, sizeof(TempComp));
            ZeroMemory(&TempComp, sizeof(TempComp));
            if (This->pComps[j]->dwType == NETCFGDB_PROTOCOL)
            {
                dwProtCount++;
            }
            pszName = This->pComps[j]->pszName;
            j++;
        }
        dwRefCount = INetCfgComponent_Release(pComponents[i]);
        DbgOutputTrace(
            "netDbReload: %ls ref=%d", pszName, dwRefCount);
    }
    This->dwCompCount = j;

    // Sort the array.
    //
    qsort(
        This->pComps,
        This->dwCompCount,
        sizeof(This->pComps[0]),
        netDbCompare);

    return NO_ERROR;
}

//
// Reload the status of a given component
//
DWORD
netDbReloadComponent (
    IN HANDLE hNetCompDatabase,
    IN DWORD dwComponentId)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    RASSRV_NET_COMPONENT* pComp = NULL;
    DWORD i;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Currently, we only need to support the fileprint
    // component
    //
    if (dwComponentId != NETCFGDB_ID_FILEPRINT)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Find the appropriate component
    //
    for (i = 0; i < This->dwCompCount; i++)
    {
        if (This->pComps[i]->dwId == dwComponentId)
        {
            pComp = This->pComps[i];
            break;
        }
    }

    // Nothing to do if we can't find the component
    //
    if (pComp == NULL)
    {
        return ERROR_NOT_FOUND;
    }

    // Reload the component information
    //
    if (dwComponentId == NETCFGDB_ID_FILEPRINT)
    {
        svcGetEnabling(&(pComp->bEnabled), NETCFGDB_ID_FILEPRINT);
    }

    return NO_ERROR;
}


//
// Reverts the database to the state it was in when opened
//
DWORD
netDbRollback (
    IN HANDLE hNetCompDatabase)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    This->bFlushOnClose = FALSE;

    return NO_ERROR;
}

//
// Special function denotes whether the network tab has been
// loaded
//
BOOL
netDbIsLoaded (
    IN HANDLE hNetCompDatabase)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return (!!(This->pINetCfg));// || (This->bHasINetCfgLock));
}

//
// Gets the number of components in the database
//
DWORD
netDbGetCompCount (
    IN  HANDLE hNetCompDatabase,
    OUT LPDWORD lpdwCount)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    DWORD i;

    // Validate parameters
    if (!This || !lpdwCount)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwCount = This->dwCompCount;

    return NO_ERROR;
}

//
// Returns a pointer to the name of a component (don't alter it)
//
DWORD
netDbGetName(
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT PWCHAR* pszName)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !pszName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    *pszName = This->pComps[dwIndex]->pszName;

    return NO_ERROR;
}

//
// Returns a description of a component (don't alter it)
//
DWORD
netDbGetDesc(
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    IN PWCHAR* pszName)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !pszName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    *pszName = This->pComps[dwIndex]->pszDesc;

    return NO_ERROR;
}

//
// Returns a type of a component (don't alter it)
//
DWORD
netDbGetType (
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT LPDWORD lpdwType)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !lpdwType)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    *lpdwType = This->pComps[dwIndex]->dwType;

    return NO_ERROR;
}

//
// Get a component id
//
DWORD
netDbGetId(
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT LPDWORD lpdwId)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !lpdwId)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    *lpdwId = This->pComps[dwIndex]->dwId;

    return NO_ERROR;
}

//
// Gets whether the given component is enabled.  For non-ras-manipulatable
// components, this yields TRUE
//
DWORD
netDbGetEnable(
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT PBOOL pbEnabled)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !pbEnabled)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    if (This->pComps[dwIndex]->bManip)
    {
        *pbEnabled = This->pComps[dwIndex]->bEnabled;
    }
    else
    {
        *pbEnabled = TRUE;
    }

    return NO_ERROR;
}

//
// Gets whether the given component is enabled. This function only has
// effect on ras-manipulatable components.
//
DWORD
netDbSetEnable(
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    IN BOOL bEnabled)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    This->pComps[dwIndex]->bEnabled = bEnabled;

    return NO_ERROR;
}

//
// Returns whether the given network component can
// be manipulated by ras server.
//
DWORD
netDbIsRasManipulatable (
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT PBOOL pbManip)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !pbManip)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (! netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    *pbManip = This->pComps[dwIndex]->bManip;

    return NO_ERROR;
}


//
////Disable/Enable the Uninstall button for whislter bug 347355     gangz
//
DWORD
netDbHasRemovePermission(
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    OUT PBOOL pbHasPermit)
{
    RASSRV_COMPONENT_DB * This = NULL;
    INetCfgComponent*   pComponent = NULL;
    BOOL fEnableRemove = FALSE;
    HRESULT hr  = S_OK;
    DWORD dwErr = NO_ERROR, dwFlags;
    
    //Disable/Enable Uninstall button according to its user permission and user 
    // removability
    //
    do
    {
        This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

        // Validate pointer
        if (!This || !pbHasPermit || ( -1 == dwIndex ))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        // Make sure that netshell library has been opened
        if (!This->pNetConUtilities)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        if (dwIndex >= This->dwCompCount)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        ASSERT(This->pComps[dwIndex]);
        if( !(This->pComps[dwIndex]) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        fEnableRemove = This->pComps[dwIndex]->bRemovable;

        *pbHasPermit = fEnableRemove;
    }
    while(FALSE);
  
    return dwErr;
}


//
// Returns whether the given network component has
// a properties ui that it can raise
//
DWORD
netDbHasPropertiesUI(
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT PBOOL pbHasUi)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    RASSRV_NET_COMPONENT* pComp = NULL;

    // Validate
    if (!This || !pbHasUi)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    pComp = This->pComps[dwIndex];

    if ((pComp->bManip) && (pComp->dwType == NETCFGDB_PROTOCOL))
    {
        *pbHasUi = TRUE;
    }
    else
    {
        *pbHasUi = pComp->bHasUi;
    }

    return NO_ERROR;
}

//
// Raises the properties of the component at the given index
//
DWORD
netDbRaisePropertiesDialog (
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    IN HWND hwndParent)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    RASSRV_NET_COMPONENT* pComp = NULL;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (dwIndex >= This->dwCompCount)
    {
        return ERROR_INVALID_INDEX;
    }

    pComp = This->pComps[dwIndex];

    // If this is a ras-manipulatable protocol, raise its
    // properties manually.
    if ((pComp->bManip) && (pComp->dwType == NETCFGDB_PROTOCOL))
    {
        netDbRaiseRasProps(This->pComps[dwIndex], hwndParent);
    }

    // Otherwise, let inetcfg do the work
    else
    {
        return INetCfgComponent_RaisePropertyUi (
                    pComp->pINetCfgComp,
                    hwndParent,
                    NCRP_SHOW_PROPERTY_UI,
                    NULL);
    }

    return NO_ERROR;
}

//
// Brings up the UI that allows a user to install a component
//
DWORD
netDbRaiseInstallDialog(
    IN HANDLE hNetCompDatabase,
    IN HWND hwndParent)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    HRESULT hr = S_OK; // For whistler 524777

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Make sure that netshell library has been opened
    if (!This->pNetConUtilities)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    else
    {
        // If we have our pointer to the function used to bring up the add
        // component dialog (obtained above only once), call it.

        // We want to filter out protocols that RAS does not care about
        // We do this by sending in a CI_FILTER_INFO structure indicating
        // we want non-RAS protocols filtered out
        //
        CI_FILTER_INFO cfi = {0};
        cfi.eFilter = FC_RASSRV;
        hr = INetConnectionUiUtilities_DisplayAddComponentDialog(
                        This->pNetConUtilities,
                        hwndParent,
                        This->pINetCfg,
                        &cfi);

        // Ui will handle reboot
        if (hr == NETCFG_S_REBOOT)
        {
            netDbReload(hNetCompDatabase);
            return hr;
        }

        // If the user didn't cancel, refresh the database.
        if (S_FALSE != hr)
        {
            if (SUCCEEDED (hr))
            {
                netDbReload(hNetCompDatabase);
                return NO_ERROR;
            }
            else
            {
                return hr;
            }
        }
    }

    return ERROR_CANCELLED;
}


//
// Uninstalls the given component
//
DWORD
netDbRaiseRemoveDialog (
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    IN HWND hwndParent)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    HRESULT hr;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Make sure that netshell library has been opened
    if (!This->pNetConUtilities)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // If we have our pointer to the function used to bring up the add
    // component dialog (obtained above only once), call it.
    if (dwIndex < This->dwCompCount)
    {
        if (This->pComps[dwIndex]->pINetCfgComp)
        {
            hr = INetConnectionUiUtilities_QueryUserAndRemoveComponent(
                            This->pNetConUtilities,
                            hwndParent,
                            This->pINetCfg,
                            This->pComps[dwIndex]->pINetCfgComp);

            // Ui will handle reboot
            if (hr == NETCFG_S_REBOOT)
            {
                netDbReload(hNetCompDatabase);
                return hr;
            }

            // If the user didn't cancel, refresh the database.
            else if (S_FALSE != hr)
            {
                if (SUCCEEDED (hr))
                {
                    netDbReload(hNetCompDatabase);
                    return NO_ERROR;
                }
                else
                {
                    return hr;
                }
            }
        }
    }

    return ERROR_CANCELLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\protedit.h ===
/*
    File    protedit.h

    Defines mechanisms for editing protocols.

    Paul Mayfield, 11/11/97
*/

#ifndef __rassrvui_protedit_h
#define __rassrvui_protedit_h

#include <windows.h>
#include "rassrv.h"

// Structure that defines data that is needed in order to 
// edit the properties of a given protocol for the ras server
// ui under connections.
typedef struct _PROT_EDIT_DATA {
    BOOL bExpose;       // whether to expose the network the ras server is
                        // connected to for the given protocol.
    LPBYTE pbData;      // Data specific to the protocol in question.
} PROT_EDIT_DATA;

#include "ipxui.h"
#include "tcpipui.h"

// Function edits the properties of a generic protocol, that is a protocol that
// has no ras-specific properties.
DWORD GenericProtocolEditProperties(IN HWND hwndParent,                 // Parent window
                                    IN OUT PROT_EDIT_DATA * pEditData,  // Edit data
                                    IN OUT BOOL * pbOk);                // Was ok pressed?

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\service.h ===
/*
    File    service.h

    Defines Dialup Server Service Object.

    Paul Mayfield, 11/3/97
*/

#ifndef __rassrvui_service
#define __rassrvui_service

// Creates/destroys instances of dialup server service objects
DWORD SvcOpenRemoteAccess(HANDLE * phService);
DWORD SvcOpenRasman(HANDLE * phService);
DWORD SvcOpenServer(HANDLE * phService);
DWORD SvcClose(HANDLE hService);

// Gets the status of a dialup server service object.  If the service
// is in the process of being started or stopped or paused, then only
// SvcIsPending will return TRUE.
DWORD SvcIsStarted (HANDLE hService, PBOOL pbStarted);
DWORD SvcIsStopped (HANDLE hService, PBOOL pbStopped);
DWORD SvcIsPaused  (HANDLE hService, PBOOL pbPaused );
DWORD SvcIsPending (HANDLE hService, PBOOL pbPending);

// Start and stop the service.  Both functions block until the service
// completes startup/stop or until dwTimeout (in seconds) expires.
DWORD SvcStart(HANDLE hService, DWORD dwTimeout);
DWORD SvcStop(HANDLE hService, DWORD dwTimeout);

// Changes the configuration of the service
DWORD SvcMarkAutoStart(HANDLE hService);
DWORD SvcMarkDisabled(HANDLE hService);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\tcpipui.h ===
/*
    File    tcpipui.c

    Dialog that edits the tcpip properties.
    
    Paul Mayfield, 10/9/97
*/

#ifndef __rassrvui_tcpipui_h
#define __rassrvui_tcpipui_h

#include "protedit.h"

// Brings up a modal dialog that allows the editing of tcpip parameters
// specific to the dialup server.  When this function completes, the 
// parameters are stored in pParams, and pbCommit is set to TRUE if the
// parameters are supposed to be saved to the system (i.e. OK was pressed)
DWORD TcpipEditProperties(HWND hwndParent, PROT_EDIT_DATA * pEditData, BOOL * pbCommit);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\service.c ===
/*
    File    service.c

    Handles requests to deal with the remote access service as neccessary for
    the dialup-server ui.

    Paul Mayfield, 11/3/97
*/

#include "rassrv.h"

// Data used for the dialup server 
typedef struct _SERVICE_DATA {
    HANDLE hSC;
    HANDLE hService;
    SERVICE_STATUS Status;
} SERVICE_DATA;

// This is the string that holds the name of the remote access service
static WCHAR pszRemoteAccess[] = L"remoteaccess";
static WCHAR pszRasman[] = L"rasman";
static WCHAR pszServer[] = L"lanmanserver";

// Opens a named dialup service object
//
DWORD 
DialupOpenNamedService(
    IN WCHAR* pszService,
    OUT HANDLE * phDialup)
{
    SERVICE_DATA * pServData;
    BOOL bOk = FALSE;
    DWORD dwErr = NO_ERROR;

    // Validate parameters
    if (!phDialup)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Create the data structure
    if ((pServData = RassrvAlloc(sizeof(SERVICE_DATA), TRUE)) == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {
        // Open the service manager
        pServData->hSC = OpenSCManager(
                            NULL, 
                            SERVICES_ACTIVE_DATABASE, 
                            GENERIC_EXECUTE);
        if (! pServData->hSC) 
        {
            dwErr = GetLastError();
            break;
        }

        // Open the dialup service
        pServData->hService = OpenServiceW(
                                pServData->hSC, 
                                pszService, 
                                SERVICE_START         | 
                                SERVICE_STOP          | 
                                SERVICE_CHANGE_CONFIG | 
                                SERVICE_QUERY_STATUS);
        if (! pServData->hService) 
        {
            dwErr = GetLastError();
            break;
        }

        // Assign the handle
        *phDialup = (HANDLE)pServData;
        bOk = TRUE;
        
    } while (FALSE);
    
    // Cleanup 
    {
        if (! bOk) 
        {
            if (pServData->hService)
            {
                CloseServiceHandle(pServData->hService);
            }
            if (pServData->hSC)
            {
                CloseServiceHandle(pServData->hSC);
            }
            
            RassrvFree(pServData);
            *phDialup = NULL;
        }
    }

    return NO_ERROR;
}

// Opens a reference to the server service object
DWORD SvcOpenServer(HANDLE * phDialup) {
    return DialupOpenNamedService(pszServer, phDialup);
}

// Opens a reference to the rasman service object
DWORD SvcOpenRasman(HANDLE * phDialup) {
    return DialupOpenNamedService(pszRasman, phDialup);
}

// Creates/destroys instances of the dialup server service object
DWORD SvcOpenRemoteAccess(HANDLE * phDialup) { 
    return DialupOpenNamedService(pszRemoteAccess, phDialup);
}

// Close up the references to the dialup service object
DWORD SvcClose(HANDLE hDialup) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    if (! pServData)
        return ERROR_INVALID_PARAMETER;

    if (pServData->hService)
        CloseServiceHandle(pServData->hService);
    if (pServData->hSC)
        CloseServiceHandle(pServData->hSC);

    RassrvFree(pServData);

    return NO_ERROR;
}

// Gets the status of a dialup server service object.  
DWORD SvcIsStarted (HANDLE hDialup, PBOOL pbStarted) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Verify parameters
    if (!pServData || !pbStarted)
        return ERROR_INVALID_PARAMETER;

    // Get the status
    bOk = QueryServiceStatus (pServData->hService, &pServData->Status);
    if (! bOk) 
        return GetLastError();

    // Return the status
    *pbStarted = (BOOL)(pServData->Status.dwCurrentState == SERVICE_RUNNING);       

    return NO_ERROR;
}

// Gets the status of a dialup server service object.  
DWORD SvcIsStopped (HANDLE hDialup, PBOOL pbStopped) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Verify parameters
    if (!pServData || !pbStopped)
        return ERROR_INVALID_PARAMETER;

    // Get the status
    bOk = QueryServiceStatus (pServData->hService, &pServData->Status);
    if (! bOk) 
        return GetLastError();

    // Return the status
    *pbStopped = (BOOL)(pServData->Status.dwCurrentState == SERVICE_STOPPED);       

    return NO_ERROR;
}

// Gets the status of a dialup server service object.  
DWORD SvcIsPaused  (HANDLE hDialup, PBOOL pbPaused) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Verify parameters
    if (!pServData || !pbPaused)
        return ERROR_INVALID_PARAMETER;

    // Get the status
    bOk = QueryServiceStatus (pServData->hService, &pServData->Status);
    if (! bOk) 
        return GetLastError();

    // Return the status
    *pbPaused = (BOOL)(pServData->Status.dwCurrentState ==  SERVICE_PAUSED);       

    return NO_ERROR;
}

//
// Returns whether the given state is a pending state
//
BOOL DialupIsPendingState (DWORD dwState) {
    return (BOOL) ((dwState == SERVICE_START_PENDING)    ||
                   (dwState == SERVICE_STOP_PENDING)     ||
                   (dwState == SERVICE_CONTINUE_PENDING) ||
                   (dwState == SERVICE_PAUSE_PENDING)    
                   ); 
}

// Gets the status of a dialup server service object.  
DWORD SvcIsPending (HANDLE hDialup, PBOOL pbPending) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Verify parameters
    if (!pServData || !pbPending)
        return ERROR_INVALID_PARAMETER;

    // Get the status
    bOk = QueryServiceStatus (pServData->hService, &pServData->Status);
    if (! bOk) 
        return GetLastError();

    // Return the status
    *pbPending = DialupIsPendingState (pServData->Status.dwCurrentState);

    return NO_ERROR;
}

// Start and stop the service.  Both functions block until the service
// completes startup/stop or until dwTimeout (in seconds) expires.
DWORD SvcStart(HANDLE hDialup, DWORD dwTimeout) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    DWORD dwErr, dwState;
    BOOL bStarted, bOk;

    // See if we're already started
    if ((dwErr = SvcIsStarted(hDialup, &bStarted)) != NO_ERROR)
        return dwErr;
    if (bStarted)
        return NO_ERROR;

    // Put the service in a state that so that 
    // it is trying to start.  (continue if paused,
    // start if stopped)
    dwState = pServData->Status.dwCurrentState;
    switch (dwState) {
        case SERVICE_STOPPED:
            bOk = StartService(pServData->hService, 0, NULL);
            if (! bOk)
                return GetLastError();
            break;
        case SERVICE_PAUSED:
            bOk = ControlService(pServData->hService, 
                                 SERVICE_CONTROL_CONTINUE, 
                                 &(pServData->Status));
            if (! bOk)
                return GetLastError();
            break;
    }

    // Wait for the service to change states or for the timeout to
    // expire.
    while (dwTimeout != 0) {
        // Wait for something to happen
        Sleep(1000);
        dwTimeout--;

        // Get the status of the service
        bOk = QueryServiceStatus (pServData->hService, 
                                  &(pServData->Status));
        if (! bOk) 
            return GetLastError();

        // See if the state changed
        if (dwState != pServData->Status.dwCurrentState) {
            // If the service changed to a pending state, continue
            if (DialupIsPendingState (pServData->Status.dwCurrentState))
                dwState = pServData->Status.dwCurrentState;

            // Otherwise, we're either stopped or running
            else
                break;
        }
    }

    // Return a timeout error if appropriate
    if (dwTimeout == 0)
        return ERROR_TIMEOUT;

    // If the service is now running, then everything
    if (pServData->Status.dwCurrentState == SERVICE_RUNNING)
        return NO_ERROR;

    // Otherwise, return the fact that we were'nt able to 
    // get to a running state
    if (pServData->Status.dwWin32ExitCode != NO_ERROR)
        return pServData->Status.dwWin32ExitCode;

    return ERROR_CAN_NOT_COMPLETE;
}

// Stops the service.
DWORD SvcStop(HANDLE hDialup, DWORD dwTimeout) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    DWORD dwErr, dwState;
    BOOL bStopped, bOk;

    // See if we're already stopped
    if ((dwErr = SvcIsStopped(hDialup, &bStopped)) != NO_ERROR)
        return dwErr;
    if (bStopped)
        return NO_ERROR;

    // Stop the service
    dwState = pServData->Status.dwCurrentState;
    bOk = ControlService(pServData->hService, SERVICE_CONTROL_STOP, &pServData->Status);
    if (! bOk)
        return GetLastError();

    // Wait for the service to change states or for the timeout to
    // expire.
    while (dwTimeout != 0) {
        // Wait for something to happen
        Sleep(1000);
        dwTimeout--;

        // Get the status of the service
        bOk = QueryServiceStatus (pServData->hService, 
                                  &(pServData->Status));
        if (! bOk) 
            return GetLastError();

        // See if the state changed
        if (dwState != pServData->Status.dwCurrentState) {
            // If the service changed to a pending state, continue
            if (DialupIsPendingState (pServData->Status.dwCurrentState))
                dwState = pServData->Status.dwCurrentState;

            // Otherwise, we're either stopped or running
            else
                break;
        }
    }

    // Report a timeout
    if (dwTimeout == 0)
        return ERROR_TIMEOUT;

    // If the service is now stopped, then everything is great
    if (pServData->Status.dwCurrentState == SERVICE_STOPPED)
        return NO_ERROR;

    // Otherwise report that we're unable to stop the service
    return ERROR_CAN_NOT_COMPLETE;
}

// Marks the dialup service as autostart
DWORD SvcMarkAutoStart(HANDLE hDialup) {
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Validate the parameters
    if (! pServData)
        return ERROR_INVALID_PARAMETER;

    // Stop the service
    bOk = ChangeServiceConfig(pServData->hService, 
                              SERVICE_NO_CHANGE, 
                              SERVICE_AUTO_START,
                              SERVICE_NO_CHANGE,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
    if (! bOk)
        return GetLastError();

    return NO_ERROR;
}

// Marks the service as disabled.
DWORD SvcMarkDisabled(HANDLE hDialup) {
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Validate the parameters
    if (! pServData)
        return ERROR_INVALID_PARAMETER;

    // Stop the service
    bOk = ChangeServiceConfig(pServData->hService, 
                              SERVICE_NO_CHANGE, 
                              SERVICE_DISABLED,
                              SERVICE_NO_CHANGE,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
    if (! bOk)
        return GetLastError();

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\rassrvui.c ===
/*
    File    rassrvui.c

    Entry point implementation for the connections dialup server ui dll.

    Paul Mayfield, 9/29/97
    Much code was borrowed from stevec's rasdlg.
*/

#include "rassrv.h"

//
// Called to add property pages for the dialup server property sheet
//
DWORD
RasSrvAddPropPage(
    IN LPPROPSHEETPAGE lpPage,
    IN RASSRV_PAGE_CONTEXT * pPageData)
{
    DWORD dwErr = ERROR_UNKNOWN_PROPERTY;

    switch(pPageData->dwId)
    {
        case RASSRVUI_GENERAL_TAB:
            dwErr = GenTabGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_USER_TAB:
            dwErr = UserTabGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_ADVANCED_TAB:
            dwErr = NetTabGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_DEVICE_WIZ_TAB:
            dwErr = DeviceWizGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_VPN_WIZ_TAB:
            dwErr = VpnWizGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_USER_WIZ_TAB:
            dwErr = UserWizGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_PROT_WIZ_TAB:
            dwErr = ProtWizGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_DCC_DEVICE_WIZ_TAB:
            dwErr = DccdevWizGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_SWITCHMMC_WIZ_TAB:
            dwErr = SwitchMmcWizGetProptertyPage (lpPage, (LPARAM)pPageData);
            break;
    }

    return dwErr;
}

//
// Helper function might make code easier to read.
//
DWORD
AddPageHelper (
    IN DWORD dwPageId,
    IN DWORD dwType,
    IN PVOID pvContext,
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM lParam)
{
    DWORD dwErr;
    HPROPSHEETPAGE hPropPage;
    PROPSHEETPAGE PropPage;
    RASSRV_PAGE_CONTEXT * pPageCtx = NULL;

    // Initialize the page data to send.  RassrvMessageFilter will
    // clean this stuff up.
    pPageCtx = RassrvAlloc(sizeof (RASSRV_PAGE_CONTEXT), TRUE);
    if (pPageCtx == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pPageCtx->dwId = dwPageId;
    pPageCtx->dwType = dwType;
    pPageCtx->pvContext = pvContext;

    // Create the tab and add it to the property sheet
    if ((dwErr = RasSrvAddPropPage(&PropPage, pPageCtx)) != NO_ERROR)
    {
        return dwErr;
    }

    if ((hPropPage = CreatePropertySheetPage(&PropPage)) == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    if (! (*pfnAddPage)(hPropPage, lParam))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
}

//
// Helper function generates a connection name based on the data
// returned from MprApi calls.
//
DWORD
GenerateConnectionName(
    IN  RAS_CONNECTION_2 * pConn,
    OUT PWCHAR pszNameBuffer)
{
    NET_API_STATUS nStatus;
    USER_INFO_2 * pUserInfo;
    DWORD dwFullNameLength;

    // Get the full name
    nStatus = NetUserGetInfo(
                    NULL,
                    pConn->wszUserName,
                    2,
                    (LPBYTE*)&pUserInfo);

    if (nStatus == NERR_Success)
    {
        dwFullNameLength = wcslen(pUserInfo->usri2_full_name);
        if (dwFullNameLength)
        {
            wsprintfW(
                pszNameBuffer,
                L"%s (%s)",
                pConn->wszUserName,
                pUserInfo->usri2_full_name);
        }
        else
        {
            lstrcpynW(
                pszNameBuffer,
                pConn->wszUserName,
                sizeof(pConn->wszUserName) / sizeof(WCHAR));
        }

        NetApiBufferFree((LPBYTE)pUserInfo);
    }
    else
    {
        lstrcpynW(
            pszNameBuffer,
            pConn->wszUserName,
            sizeof(pConn->wszUserName) / sizeof(WCHAR));
    }

    return NO_ERROR;
}

//
// Generate the connection type and device name
//
DWORD
GenerateConnectionDeviceInfo (
    RAS_CONNECTION_2 * pConn,
    LPDWORD lpdwType,
    PWCHAR pszDeviceName)
{
    DWORD dwErr, dwRead, dwTot, dwType, dwClass;
    RAS_PORT_0 * pPort = NULL;
    RASMAN_INFO Info;

    // Initialize the variables
    *lpdwType = 0;
    *pszDeviceName = (WCHAR)0;

    gblConnectToRasServer();

    do
    {
        // Enumerate the ports
        //
        dwErr = MprAdminPortEnum(
                    Globals.hRasServer,
                    0,
                    pConn->hConnection,
                    (LPBYTE*)&pPort,
                    sizeof(RAS_PORT_0) * 2,
                    &dwRead,
                    &dwTot,
                    NULL);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        if (dwRead == 0)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get extended information about the first
        // port
        //
        dwErr = RasGetInfo(NULL, pPort->hPort, &Info);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        dwClass = RAS_DEVICE_CLASS(Info.RI_rdtDeviceType);
        dwType = RAS_DEVICE_TYPE(Info.RI_rdtDeviceType);

        lstrcpynW(
            pszDeviceName,
            pPort[0].wszDeviceName,
            MAX_DEVICE_NAME + 1);
        if ((dwClass & RDT_Direct) || (dwClass & RDT_Null_Modem))
        {
            *lpdwType = RASSRVUI_DCC;
        }
        else if (dwClass & RDT_Tunnel)
        {
            *lpdwType = RASSRVUI_VPN;
        }
        else
        {
            *lpdwType = RASSRVUI_MODEM;
        }

    } while (FALSE);

    // Cleanup
    {
        if (pPort)
        {
            MprAdminBufferFree((LPBYTE)pPort);
        }
    }

    return dwErr;
}

//
// Starts the remote access service and marks it as autostart
//
DWORD
RasSrvInitializeService()
{
    DWORD dwErr = NO_ERROR, dwTimeout = 60*2;
    HANDLE hDialupService, hData = NULL;
    BOOL bInitialized = FALSE;

    // Get a reference to the service
    if ((dwErr = SvcOpenRemoteAccess(&hDialupService)) != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        RasSrvShowServiceWait(
            Globals.hInstDll,
            GetActiveWindow(),
            &hData);

        // First, mark the service as autostart
        if ((dwErr = SvcMarkAutoStart(hDialupService)) != NO_ERROR)
        {
            break;
        }

        // Start it (with a 5 minute timeout)
        dwErr = SvcStart(hDialupService, 60*5);
        if (dwErr == ERROR_TIMEOUT)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Wait for the service to complete initialization
        //
        while (dwTimeout)
        {
            bInitialized = MprAdminIsServiceRunning(NULL);
            if (bInitialized)
            {
                break;
            }
            Sleep(1000);
            dwTimeout--;
        }
        if (dwTimeout == 0)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

    } while (FALSE);

    // Cleanup
    //
    {
        RasSrvFinishServiceWait(hData);

        // Cleanup the reference to the dialup service
        SvcClose(hDialupService);
    }

    return dwErr;
}

//
// Stops and marks the remote access service as disabled.
//
DWORD
RasSrvCleanupService()
{
    DWORD dwErr = NO_ERROR;
    HANDLE hDialupService, hData = NULL;
    BOOL fIcRunningBefore = FALSE;
    BOOL fIcRunningAfter = FALSE;

    RasSrvIsServiceRunning( &fIcRunningBefore );

    // Get a reference to the service
    if ((dwErr = SvcOpenRemoteAccess(&hDialupService)) != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        RasSrvShowServiceWait(
            Globals.hInstDll,
            GetActiveWindow(),
            &hData);

        // First, stop the service (with a 5 minute timeout)
        //
        dwErr = SvcStop(hDialupService, 60*5);
        if (dwErr == ERROR_TIMEOUT)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // For whistler 480871
        // Mark the registry if IC is deleted
        RassrvSetICConfig( 0 ); 

        // Mark it as disabled
        if ((dwErr = SvcMarkDisabled(hDialupService)) != NO_ERROR)
        {
            break;
        }

    } while (FALSE);

    // Cleanup
    //
    {
        RasSrvFinishServiceWait(hData);
        SvcClose(hDialupService);
    }

    //For whistler bug 123769
    //If the this connection to be deleted is Incoming connection
    //go to disable PortMapping

    if ( NO_ERROR == RasSrvIsServiceRunning( &fIcRunningAfter ) )
     {
        if ( fIcRunningBefore && !fIcRunningAfter )
        {
            dwErr = HnPMConfigureAllConnections( FALSE );

		//this is taken out because we decide not to delete the portmappings,
		//just disable them instead. I keep this just for future reference.  gangz
		//
		
        //    if (NO_ERROR == dwErr )
        //    {
        //        dwErr = HnPMDeletePortMapping();
        //    }
        }
      }

    return dwErr;
}

//
// Reports whether the dialup service is running
//
DWORD
APIENTRY
RasSrvIsServiceRunning (
    OUT BOOL* pfIsRunning)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hDialupService = NULL;

    // Get a reference to the service
    if ((dwErr = SvcOpenRemoteAccess(&hDialupService)) != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        // Get the current status.  SvcIsStarted checks the validity
        // of the pfIsRunning parameter.
        dwErr = SvcIsStarted(hDialupService, pfIsRunning);
        if (dwErr != NO_ERROR)
        {
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        // Cleanup the reference to the dialup service
        SvcClose(hDialupService);
    }

    return NO_ERROR;
}

//
// Returns whether the conenctions wizard should be allowed to show.
//
DWORD
APIENTRY
RasSrvAllowConnectionsWizard (
    OUT BOOL* pfAllow)
{
    DWORD dwErr = NO_ERROR, dwFlags = 0;
    BOOL fConfig = FALSE;

    if (!pfAllow)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize the product type
    if ((dwErr = RasSrvGetMachineFlags (&dwFlags)) != NO_ERROR)
    {
        return dwErr;
    }

    
    if( NO_ERROR != RasSrvIsRRASConfigured( & fConfig ) )
    {
        *pfAllow = TRUE;
    }
    else
    {
        *pfAllow = fConfig ? FALSE : TRUE ;
    }

    return NO_ERROR;
}

//
// On ntw or standalone nts, returns result of RasSrvIsServiceRunning.
// Otherwise returns false.
//
DWORD
APIENTRY
RasSrvAllowConnectionsConfig (
    OUT BOOL* pfAllow)
{
    BOOL bAllowWizard;
    DWORD dwErr;

    if ((dwErr = RasSrvAllowConnectionsWizard (&bAllowWizard)) != NO_ERROR)
    {
        return dwErr;
    }

    if (bAllowWizard)
    {
        return RasSrvIsServiceRunning(pfAllow);
    }

    *pfAllow = FALSE;
    return NO_ERROR;
}

//
// Checks to see if remote access service is installed
//
BOOL
RasSrvIsRemoteAccessInstalled ()
{
    const WCHAR pszServiceKey[] =
        L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess";
    HKEY hkService = NULL;
    DWORD dwErr = NO_ERROR;

    // Attempt to open the service registry key
    dwErr = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                pszServiceKey,
                0,
                KEY_READ | KEY_WRITE,
                &hkService);

    // If we opened the key ok, then we can assume
    // that the service is installed
    if (dwErr == ERROR_SUCCESS)
    {
        RegCloseKey(hkService);
        return TRUE;
    }

    return FALSE;
}

//
// Adds the required tabs to the incoming connections property sheet.
//
DWORD
APIENTRY
RasSrvAddPropPages (
    IN HRASSRVCONN          hRasSrvConn,
    IN HWND                 hwndParent,
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext)
{
    DWORD dwErr;

    // Check parameters
    if (!pfnAddPage || !ppvContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Make sure remote access is installed
    if (!RasSrvIsRemoteAccessInstalled())
    {
        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }

    // Create the context for this page
    if ((dwErr = RassrvCreatePageSetCtx(ppvContext)) != NO_ERROR)
    {
        return dwErr;
    }

    // Add the tabs
    AddPageHelper(RASSRVUI_GENERAL_TAB,
                  RASWIZ_TYPE_INCOMING,
                  *ppvContext,
                  pfnAddPage,
                  lParam);

    AddPageHelper(RASSRVUI_USER_TAB,
                  RASWIZ_TYPE_INCOMING,
                  *ppvContext,
                  pfnAddPage,
                  lParam);

    AddPageHelper(RASSRVUI_ADVANCED_TAB,
                  RASWIZ_TYPE_INCOMING,
                  *ppvContext,
                  pfnAddPage,
                  lParam);

    return NO_ERROR;
}

//
// Adds the required tabs to the incoming connections wizard
//
DWORD
APIENTRY
RasSrvAddWizPages (
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext)
{
    DWORD dwErr;
    BOOL bAllowWizard;

    // Check parameters
    if (!pfnAddPage || !ppvContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Make sure remote access is installed
    if (!RasSrvIsRemoteAccessInstalled())
    {
        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }

    // Find out if configuration through connections is allowed
    dwErr = RasSrvAllowConnectionsWizard (&bAllowWizard);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Create the context for this page
    if ((dwErr = RassrvCreatePageSetCtx(ppvContext)) != NO_ERROR)
    {
        return dwErr;
    }

    // If configuration is allowed, add the wizard pages as normal
    if (bAllowWizard)
    {
        // Add the tabs
        AddPageHelper(RASSRVUI_DEVICE_WIZ_TAB,
                      RASWIZ_TYPE_INCOMING,
                      *ppvContext,
                      pfnAddPage,
                      lParam);

        AddPageHelper(RASSRVUI_VPN_WIZ_TAB,
                      RASWIZ_TYPE_INCOMING,
                      *ppvContext,
                      pfnAddPage,
                      lParam);

        AddPageHelper(RASSRVUI_USER_WIZ_TAB,
                      RASWIZ_TYPE_INCOMING,
                      *ppvContext,
                      pfnAddPage,
                      lParam);

        AddPageHelper(RASSRVUI_PROT_WIZ_TAB,
                      RASWIZ_TYPE_INCOMING,
                      *ppvContext,
                      pfnAddPage,
                      lParam);
    }

    // Otherwise, add the bogus page that
    // switches to mmc.
    else
    {
        // Add the tabs
        AddPageHelper(RASSRVUI_SWITCHMMC_WIZ_TAB,
                      RASWIZ_TYPE_INCOMING,
                      *ppvContext,
                      pfnAddPage,
                      lParam);
    }

    return NO_ERROR;
}

//
// Function adds the host-side direct connect wizard pages
//
DWORD
APIENTRY
RassrvAddDccWizPages(
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext)
{
    DWORD dwErr;
    BOOL bAllowWizard;

    // Check parameters
    if (!pfnAddPage || !ppvContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Make sure remote access is installed
    if (!RasSrvIsRemoteAccessInstalled())
    {
        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }

    // Find out if configuration through connections is allowed
    dwErr = RasSrvAllowConnectionsWizard (&bAllowWizard);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Create the context for this page
    if ((dwErr = RassrvCreatePageSetCtx(ppvContext)) != NO_ERROR)
    {
        return dwErr;
    }

    if (bAllowWizard)
    {
        // Add the tabs
        AddPageHelper(RASSRVUI_DCC_DEVICE_WIZ_TAB,
                      RASWIZ_TYPE_DIRECT,
                      *ppvContext,
                      pfnAddPage,
                      lParam);

        AddPageHelper(RASSRVUI_USER_WIZ_TAB,
                      RASWIZ_TYPE_DIRECT,
                      *ppvContext,
                      pfnAddPage,
                      lParam);
    }

    // Otherwise, add the bogus page that
    // switches to mmc.
    else
    {
        // Add the tabs
        AddPageHelper(RASSRVUI_SWITCHMMC_WIZ_TAB,
                      RASWIZ_TYPE_DIRECT,
                      *ppvContext,
                      pfnAddPage,
                      lParam);
    }

    return NO_ERROR;
}

//
// Function returns the suggested name for an incoming connection.
//
DWORD
APIENTRY
RassrvGetDefaultConnectionName (
    IN OUT PWCHAR pszBuffer,
    IN OUT LPDWORD lpdwBufSize)
{
    PWCHAR pszName;
    DWORD dwLen;

    // Load the resource string
    pszName = (PWCHAR) PszLoadString(
                            Globals.hInstDll,
                            SID_DEFAULT_CONNECTION_NAME);

    // Calculate length
    dwLen = wcslen(pszName);
    if (dwLen > *lpdwBufSize)
    {
        *lpdwBufSize = dwLen;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // Return the result
    wcscpy(pszBuffer, pszName);
    *lpdwBufSize = dwLen;

    return NO_ERROR;
}

//
// Function behaves anagolously to the WIN32 function RasEnumConnections
// but for client connections instead of dialout connections.
//
DWORD
RasSrvEnumConnections(
    IN  LPRASSRVCONN pRasSrvCon,
    OUT LPDWORD lpcb,
    OUT LPDWORD lpcConnections)
{
    DWORD dwErr = NO_ERROR, dwEntriesRead, dwTotal, dwFlags = 0;
    DWORD dwPrefMax = 1000000, i, dwSizeNeeded = 0;
    RAS_CONNECTION_2 * pConnList = NULL;
    BOOL bCopy = TRUE, fConfig = FALSE, fAllow = FALSE;
    
    // Sanity Check
    if (!pRasSrvCon || !lpcb || !lpcConnections)
    {
        return ERROR_INVALID_PARAMETER;
    }


   // For .Net 690392
    if( NO_ERROR == RasSrvIsRRASConfigured( & fConfig ) )
    {
        fAllow = fConfig ? FALSE : TRUE;
    }

    //
    // We do not allow IC ui for member servers when rras is configured
    //
    RasSrvGetMachineFlags(&dwFlags);
    if ((dwFlags & RASSRVUI_MACHINE_F_Server) &&
        (dwFlags & RASSRVUI_MACHINE_F_Member) &&
        (!fAllow)
       )
    {
        *lpcb = 0;
        *lpcConnections = 0;
        return NO_ERROR;
    }

    //
    // Get the MprAdmin handle
    //
    do
    {
        // for .Net 606857
        dwErr = gblConnectToRasServer();
        if (dwErr != NO_ERROR)
        {
            DbgOutputTrace ("gblConnectToRasServer failed %x\n", dwErr);
            break;
        }

        // Enumerate the structures
        dwErr = MprAdminConnectionEnum (
                    Globals.hRasServer,
                    2,
                    (LPBYTE *)&pConnList,
                    dwPrefMax,
                    &dwEntriesRead,
                    &dwTotal,
                    NULL);
        if (dwErr != NO_ERROR)
        {
            pConnList = NULL;
            DbgOutputTrace ("MprAdminEnum failed %x\n", dwErr);
            break;
        }

        // Reuse the dwTotal variable
        dwTotal = 0;
        dwSizeNeeded = 0;

        // Copy over the pertanent information
        for (i = 0; i < dwEntriesRead; i++)
        {
            if (pConnList[i].dwInterfaceType == ROUTER_IF_TYPE_CLIENT)
            {
                dwSizeNeeded += sizeof (RASSRVCONN);
                if (dwSizeNeeded > *lpcb)
                {
                    bCopy = FALSE;
                }
                if (bCopy)
                {
                    // Connection handle
                    pRasSrvCon[dwTotal].hRasSrvConn =
                        pConnList[i].hConnection;

                    // Name
                    dwErr = GenerateConnectionName(
                                &pConnList[i],
                                pRasSrvCon[dwTotal].szEntryName);
                    if (dwErr != NO_ERROR)
                    {
                        continue;
                    }

                    // Type and Device Name
                    dwErr = GenerateConnectionDeviceInfo(
                                &pConnList[i],
                                &(pRasSrvCon[dwTotal].dwType),
                                pRasSrvCon[dwTotal].szDeviceName);
                    if (dwErr != NO_ERROR)
                    {
                        continue;
                    }

                    // Guid
                    pRasSrvCon[dwTotal].Guid = pConnList[i].guid;

                    dwTotal++;
                }
            }
        }

        *lpcb = dwSizeNeeded;
        *lpcConnections = dwTotal;

    } while (FALSE);

    // Cleanup
    if(pConnList)
    {
        MprAdminBufferFree((LPBYTE)pConnList);
    }

    if (!bCopy)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    return dwErr;
}

//
// Gets the status of a Ras Server Connection
//
DWORD
APIENTRY
RasSrvIsConnectionConnected (
    IN  HRASSRVCONN hRasSrvConn,
    OUT BOOL*       pfConnected)
{
    RAS_CONNECTION_2 * pConn;
    DWORD dwErr;

    // Sanity check the parameters
    if (!pfConnected)
    {
        return ERROR_INVALID_PARAMETER;
    }

    gblConnectToRasServer();

    // Query rasman for the connection information
    dwErr = MprAdminConnectionGetInfo(
                Globals.hRasServer,
                0,
                hRasSrvConn,
                (LPBYTE*)&pConn);
    if (dwErr != NO_ERROR)
    {
        *pfConnected = FALSE;
    }
    else
    {
        *pfConnected = TRUE;
    }

    if (pfConnected)
    {
        MprAdminBufferFree((LPBYTE)pConn);
    }

    return NO_ERROR;
}

//
// Hangs up the given connection
//
DWORD
RasSrvHangupConnection(
    IN HRASSRVCONN hRasSrvConn)
{
     RAS_PORT_0 * pPorts;
     DWORD dwRead, dwTot, dwErr, i, dwRet = NO_ERROR;

    gblConnectToRasServer();

    // Enumerate all of the ports on this connection
    dwErr = MprAdminPortEnum(
                Globals.hRasServer,
                0,
                hRasSrvConn,
                (LPBYTE*)&pPorts,
                4096,
                &dwRead,
                &dwTot,
                NULL);
     if (dwErr != NO_ERROR)
     {
        return dwErr;
     }

    // Hang up each of the ports individually
    for (i = 0; i < dwRead; i++)
    {
        dwErr = MprAdminPortDisconnect(
                    Globals.hRasServer,
                    pPorts[i].hPort);

        if (dwErr != NO_ERROR)
        {
            dwRet = dwErr;
        }
    }
    MprAdminBufferFree((LPBYTE)pPorts);

    return dwRet;
}

//
// Queries whether to show icons in the task bar.
//
DWORD
APIENTRY
RasSrvQueryShowIcon (
    OUT BOOL* pfShowIcon)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hMiscDatabase = NULL;

    if (!pfShowIcon)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        // Open a copy of the miscellaneous database
        dwErr = miscOpenDatabase(&hMiscDatabase);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Return the status
        dwErr = miscGetIconEnable(hMiscDatabase, pfShowIcon);
        if (dwErr != NO_ERROR)
        {
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hMiscDatabase)
        {
            miscCloseDatabase(hMiscDatabase);
        }
    }

    return dwErr;
}

// ===================================
// ===================================
// Dll entry management
// ===================================
// ===================================

//
// Called when another process attaches to this dll
//
DWORD
RassrvHandleProcessAttach(
    IN HINSTANCE hInstDll,
    IN LPVOID pReserved)
{
    // Initialize global variables
    //
    return gblInit(hInstDll, &Globals);
}

//
// Called when process detaches from this dll
//
DWORD
RassrvHandleProcessDetach(
    IN HINSTANCE hInstDll,
    IN LPVOID pReserved)
{
    // Cleanup global variables
    //
    return gblCleanup(&Globals);
}

//
// Called when thread attaches to this dll
//
DWORD
RassrvHandleThreadAttach(
    IN HINSTANCE hInstDll,
    IN LPVOID pReserved)
{
    return NO_ERROR;
}

//
// Called when thread detaches from this dll
//
DWORD
RassrvHandleThreadDetach(
    IN HINSTANCE hInstDll,
    IN LPVOID pReserved)
{
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\userdb.c ===
/*
    File    userdb.c

    Implementation of the local user database object.

    Paul Mayfield, 10/8/97
*/

#include "rassrv.h"

// Registry values
extern WCHAR pszregRasParameters[];
extern WCHAR pszregServerFlags[];
extern WCHAR pszregPure[];

// Cached values for users
typedef struct _RASSRV_USERINFO 
{
    HANDLE hUser;        // Handle to user
    PWCHAR pszName;
    PWCHAR pszFullName;  // Only loaded if requested

    //gangz for secure password bug
    //Change this for the new safe encoding password functions
    WCHAR szPassword[PWLEN+1];  // Only non-null if this is new password to be committed
    WCHAR wszPhoneNumber[MAX_PHONE_NUMBER_LEN + 1];
    BYTE bfPrivilege;
    BYTE bDirty;
    
} RASSRV_USERINFO;

// Structure used to implement/manipulate the local user database
typedef struct _RASSRV_USERDB 
{
    HANDLE hServer;                 // Handle to user server
    DWORD dwUserCount;              // Number of users in the database
    DWORD dwCacheSize;              // Number of users can be stored in cache
    BOOL bEncrypt;                  // Whether encryption should be used
    BOOL bDccBypass;                // Whether dcc connections can bypass auth.
    BOOL bPure;                     // Whether database is "Pure"
    BOOL bEncSettingLoaded;         // Whether we've read in the enc setting
    BOOL bFlushOnClose;
    RASSRV_USERINFO ** pUserCache;  // Cache of users
    
} RASSRV_USERDB;

// Defines a callback for enumerating users.  Returns TRUE to continue the enueration
// FALSE to stop it.
typedef 
BOOL 
(* pEnumUserCb)(
    IN NET_DISPLAY_USER* pUser, 
    IN HANDLE hData);

// We use this to guess the size of the the user array 
// (so we can grow it when new users are added)
#define USR_ARRAY_GROW_SIZE 50

// Dirty flags
#define USR_RASPROPS_DIRTY 0x1  // whether callback is dirty
#define USR_FULLNAME_DIRTY 0x2  // whether full name needs to be flushed
#define USR_PASSWORD_DIRTY 0x4  // whether password needs to be flushed
#define USR_ADD_DIRTY      0x8  // whether user needs to be added

// Helper macros for dealing with dirty flags
#define usrDirtyRasProps(pUser) ((pUser)->bDirty |= USR_RASPROPS_DIRTY)
#define usrDirtyFullname(pUser) ((pUser)->bDirty |= USR_FULLNAME_DIRTY)
#define usrDirtyPassword(pUser) ((pUser)->bDirty |= USR_PASSWORD_DIRTY)
#define usrDirtyAdd(pUser) ((pUser)->bDirty |= USR_ADD_DIRTY)

#define usrIsDirty(pUser) ((pUser)->bDirty)
#define usrIsRasPropsDirty(pUser) ((pUser)->bDirty & USR_RASPROPS_DIRTY) 
#define usrIsFullNameDirty(pUser) ((pUser)->bDirty & USR_FULLNAME_DIRTY) 
#define usrIsPasswordDirty(pUser) ((pUser)->bDirty & USR_PASSWORD_DIRTY) 
#define usrIsAddDirty(pUser) ((pUser)->bDirty & USR_ADD_DIRTY) 

#define usrClearDirty(pUser) ((pUser)->bDirty = 0)
#define usrClearRasPropsDirty(pUser) ((pUser)->bDirty &= ~USR_CALLBACK_DIRTY) 
#define usrClearFullNameDirty(pUser) ((pUser)->bDirty &= ~USR_FULLNAME_DIRTY) 
#define usrClearPasswordDirty(pUser) ((pUser)->bDirty &= ~USR_PASSWORD_DIRTY) 
#define usrClearAddDirty(pUser) ((pUser)->bDirty &= ~USR_ADD_DIRTY) 

#define usrFlagIsSet(_val, _flag) (((_val) & (_flag)) != 0)
#define usrFlagIsClear(_val, _flag) (((_val) & (_flag)) == 0)

//
// Reads in server flags and determines whether encrypted 
// password and data are required.  
// 
// lpdwFlags is assigned one of the following on success
//      0               = data and pwd enc not required
//      MPR_USER_PROF_FLAG_SECURE = data and pwd enc required
//      MPR_USER_PROF_FLAG_UNDETERMINED = Can't say for sure
//
DWORD 
usrGetServerEnc(
    OUT  LPDWORD lpdwFlags) 
{
    DWORD dwFlags = 0;

    if (!lpdwFlags)
        return ERROR_INVALID_PARAMETER;

    // Read in the flags
    RassrvRegGetDw(&dwFlags, 
                   0, 
                   (const PWCHAR)pszregRasParameters, 
                   (const PWCHAR)pszregServerFlags);

    // The following bits will be set for secure auth.
    //
    if (
        (usrFlagIsSet   (dwFlags, PPPCFG_NegotiateMSCHAP))       &&
        (usrFlagIsSet   (dwFlags, PPPCFG_NegotiateStrongMSCHAP)) &&
        (usrFlagIsClear (dwFlags, PPPCFG_NegotiateMD5CHAP))      &&
        (usrFlagIsClear (dwFlags, PPPCFG_NegotiateSPAP))         &&
        (usrFlagIsClear (dwFlags, PPPCFG_NegotiateEAP))          &&
        (usrFlagIsClear (dwFlags, PPPCFG_NegotiatePAP))        
       )
    {
        *lpdwFlags = MPR_USER_PROF_FLAG_SECURE; 
        return NO_ERROR;
    }

    // The following bits will be set for insecure auth.
    //
    else if (
            (usrFlagIsSet   (dwFlags, PPPCFG_NegotiateMSCHAP))       &&
            (usrFlagIsSet   (dwFlags, PPPCFG_NegotiateStrongMSCHAP)) &&
            (usrFlagIsSet   (dwFlags, PPPCFG_NegotiateSPAP))         &&
            (usrFlagIsSet   (dwFlags, PPPCFG_NegotiatePAP))          &&
            (usrFlagIsClear (dwFlags, PPPCFG_NegotiateEAP))          &&
            (usrFlagIsClear (dwFlags, PPPCFG_NegotiateMD5CHAP))      
           )
        {
            *lpdwFlags = 0;  // data and pwd enc not required
            return NO_ERROR;
        }

    // Otherwise, we are undetermined
    *lpdwFlags = MPR_USER_PROF_FLAG_UNDETERMINED;
    return NO_ERROR;
}

//
// Sets the encryption policy for the server
//
DWORD 
usrSetServerEnc(
    IN DWORD dwFlags) 
{
    DWORD dwSvrFlags = 0;

    // Read in the old flags
    RassrvRegGetDw(&dwSvrFlags, 
                   0, 
                   (const PWCHAR)pszregRasParameters, 
                   (const PWCHAR)pszregServerFlags);

    // If the user requires encryption then set MSCHAP
    // and CHAP as the only authentication types and 
    // set the ipsec flag.
    if (dwFlags & MPR_USER_PROF_FLAG_SECURE) 
    {
        dwSvrFlags |= PPPCFG_NegotiateMSCHAP;
        dwSvrFlags |= PPPCFG_NegotiateStrongMSCHAP;
        dwSvrFlags &= ~PPPCFG_NegotiateMD5CHAP;
        dwSvrFlags &= ~PPPCFG_NegotiateSPAP;
        dwSvrFlags &= ~PPPCFG_NegotiateEAP;
        dwSvrFlags &= ~PPPCFG_NegotiatePAP;
    }

    // Otherwise, the user does require encryption,
    // so enable all authentication types and disable
    // the requirement to use IPSEC
    else 
    {
        dwSvrFlags &= ~PPPCFG_NegotiateMD5CHAP;
        dwSvrFlags &= ~PPPCFG_NegotiateEAP;
        dwSvrFlags |= PPPCFG_NegotiateMSCHAP;
        dwSvrFlags |= PPPCFG_NegotiateStrongMSCHAP;
        dwSvrFlags |= PPPCFG_NegotiateSPAP;
        dwSvrFlags |= PPPCFG_NegotiatePAP;
    }

    // Commit changes to the registry
    RassrvRegSetDw(dwSvrFlags, 
                   (const PWCHAR)pszregRasParameters, 
                   (const PWCHAR)pszregServerFlags);
   
    return NO_ERROR;
}

// Enumerates the local users
//
DWORD 
usrEnumLocalUsers(
    IN pEnumUserCb pCbFunction,
    IN HANDLE hData)
{
    DWORD dwErr, dwIndex = 0, dwCount = 100, dwEntriesRead, i;
    NET_DISPLAY_USER  * pUsers;
    NET_API_STATUS nStatus;
    RAS_USER_0 RasUser0;
    HANDLE hUser = NULL, hServer = NULL;
    
    // Enumerate the users, 
    while (TRUE) 
    {
        // Read in the first block of user names
        nStatus = NetQueryDisplayInformation(
                    NULL,
                    1,
                    dwIndex,
                    dwCount,
                    dwCount * sizeof(NET_DISPLAY_USER),    
                    &dwEntriesRead,
                    &pUsers);
                    
        // Get out if there's an error getting user names
        if ((nStatus != NERR_Success) &&
            (nStatus != ERROR_MORE_DATA))
        {
            break;
        }

        // For each user read in, call the callback function
        for (i = 0; i < dwEntriesRead; i++) 
        {
            BOOL bOk;

            //For whistler bug 243874 gangz
            //On whistler Personal version, we wont show the Administrator
            //in the user's listview on the Incoming connection's User Tab
            //

            if ( (DOMAIN_USER_RID_ADMIN == pUsers[i].usri1_user_id) &&
                  IsPersonalPlatform() )
            {
                continue;
            }
			
            bOk = (*pCbFunction)(&(pUsers[i]), hData);
            if (bOk == FALSE)
            {
                nStatus = NERR_Success;
                break;
            }
        }

        // Set the index to read in the next set of users
        dwIndex = pUsers[dwEntriesRead - 1].usri1_next_index;  
        
        // Free the users buffer
        NetApiBufferFree (pUsers);

        // If we've read in everybody, go ahead and break
        if (nStatus != ERROR_MORE_DATA)
        {
            break;
        }
    }
    
    return NO_ERROR;
}

// Copies the data in pRassrvUser to its equivalent in UserInfo
DWORD 
usrSyncRasProps(
    IN  RASSRV_USERINFO * pRassrvUser, 
    OUT RAS_USER_0 * UserInfo) 
{
    UserInfo->bfPrivilege = pRassrvUser->bfPrivilege;
    lstrcpynW( UserInfo->wszPhoneNumber, 
             pRassrvUser->wszPhoneNumber, 
             MAX_PHONE_NUMBER_LEN);
    UserInfo->wszPhoneNumber[MAX_PHONE_NUMBER_LEN] = (WCHAR)0;
    return NO_ERROR;
}

// Commits the data for the given user to the local user database
DWORD 
usrCommitRasProps(
    IN RASSRV_USERINFO * pRassrvUser) 
{
    DWORD dwErr = NO_ERROR;
    RAS_USER_0 UserInfo;

    dwErr = usrSyncRasProps(pRassrvUser, &UserInfo);
    if (dwErr != NO_ERROR)
        return dwErr;

    dwErr = MprAdminUserWrite(pRassrvUser->hUser, 0, (LPBYTE)&UserInfo);
    if (dwErr != NO_ERROR) 
        DbgOutputTrace ("usrCommitRasProps: unable to commit %S (0x%08x)", 
                        pRassrvUser->pszName, dwErr);
    
    return dwErr;
}

// Simple bounds checking
BOOL 
usrBoundsCheck(
    IN RASSRV_USERDB * This, 
    IN DWORD dwIndex) 
{
    // Dwords are unsigned, so no need to check < 0
    if (This->dwUserCount <= dwIndex)
        return FALSE;
        
    return TRUE;
}

// Frees an array of users
DWORD 
usrFreeUserArray(
    IN RASSRV_USERINFO ** pUsers, 
    IN DWORD dwCount) 
{
    DWORD i;

    if (!pUsers)
        return ERROR_INVALID_PARAMETER;

    for (i=0; i < dwCount; i++) {
        if (pUsers[i]) {
            if (pUsers[i]->hUser)
                MprAdminUserClose(pUsers[i]->hUser);
            if (pUsers[i]->pszName)
                RassrvFree (pUsers[i]->pszName);
            if (pUsers[i]->pszFullName)
                RassrvFree (pUsers[i]->pszFullName);

            //Wipe password before free memory, if CryptProtectData() is used
            //this will also release the memory allocated by it
            SafeWipePasswordBuf(pUsers[i]->szPassword);

            RassrvFree(pUsers[i]);
        }
        
    }

    return NO_ERROR;
}

// Standard user comparison function used for sorting
int _cdecl 
usrCompareUsers(
    IN const void * elem1, 
    IN const void * elem2) 
{
    RASSRV_USERINFO* p1 = *((RASSRV_USERINFO**)elem1);
    RASSRV_USERINFO* p2 = *((RASSRV_USERINFO**)elem2);

    return lstrcmpi(p1->pszName, p2->pszName);
}

// Returns whether a given user exists
BOOL 
usrUserExists (
    IN RASSRV_USERDB * This, 
    IN PWCHAR pszName) 
{
    DWORD i;
    int iCmp;

    for (i = 0; i < This->dwUserCount; i++) {
        iCmp = lstrcmpi(This->pUserCache[i]->pszName, pszName);
        if (iCmp == 0)
            return TRUE;
        if (iCmp > 0)
            return FALSE;
    }

    return FALSE;
}

// Resorts the cache
DWORD 
usrResortCache(
    IN RASSRV_USERDB * This) 
{
    qsort(
        This->pUserCache, 
        This->dwUserCount, 
        sizeof(RASSRV_USERINFO*), 
        usrCompareUsers);
        
    return NO_ERROR;
}

// Resizes the user cache to allow for added users
DWORD 
usrResizeCache(
    IN RASSRV_USERDB * This, 
    IN DWORD dwNewSize) 
{
    RASSRV_USERINFO ** pNewCache;
    DWORD i;

    // Only resize bigger (this could be changed)
    if ((!This) || (dwNewSize <= This->dwCacheSize))
        return ERROR_INVALID_PARAMETER;

    // Allocate the new cache
    pNewCache = RassrvAlloc(dwNewSize * sizeof (RASSRV_USERINFO*), TRUE);
    if (pNewCache == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Copy over the old entries and free the old cache
    if (This->pUserCache) 
    {
        CopyMemory( (PVOID)pNewCache, 
                    (CONST VOID *)(This->pUserCache), 
                    This->dwCacheSize * sizeof(RASSRV_USERINFO*));
        RassrvFree(This->pUserCache);
    }

    // Reassign the new cache and update the cache size
    This->pUserCache = pNewCache;
    This->dwCacheSize = dwNewSize;

    return NO_ERROR;
}

// Enumeration callback that adds users to the local database
// as they are read from the system.
BOOL 
usrInitializeUser(
    NET_DISPLAY_USER * pNetUser,
    HANDLE hUserDatabase)
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    RASSRV_USERINFO * pRasUser = NULL;
    DWORD dwErr = NO_ERROR, dwSize;
    RAS_USER_0 UserInfo;

    // Make sure we have a valid database
    if (!This)
    {
        return FALSE;
    }
    
    // Resize the cache to accomodate more users if needed
    if (This->dwUserCount >= This->dwCacheSize)
    {
        dwErr = usrResizeCache(
                    This, 
                    This->dwCacheSize + USR_ARRAY_GROW_SIZE);
                    
        if (dwErr != NO_ERROR)
        {
            return FALSE;
        }
    }

    // Allocate this user
    pRasUser = RassrvAlloc(sizeof(RASSRV_USERINFO), TRUE);
    if (pRasUser == NULL)
    {
        return FALSE;
    }

    do 
    {
        // Point to the user name
        dwSize = (wcslen(pNetUser->usri1_name) + 1) * sizeof(WCHAR);
        pRasUser->pszName = RassrvAlloc(dwSize, FALSE);
        if (!pRasUser->pszName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        wcscpy(pRasUser->pszName, pNetUser->usri1_name);

        // Open the user handle
        dwErr = MprAdminUserOpen (
                    This->hServer, 
                    pRasUser->pszName, 
                    &(pRasUser->hUser));
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
        // Get the ras user info
        dwErr = MprAdminUserRead(pRasUser->hUser, 0, (LPBYTE)&UserInfo);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Clear any dirty flags
        usrClearDirty(pRasUser);

        // Copy the phone number
        lstrcpynW(
            pRasUser->wszPhoneNumber, 
            UserInfo.wszPhoneNumber, 
            MAX_PHONE_NUMBER_LEN);
        pRasUser->wszPhoneNumber[MAX_PHONE_NUMBER_LEN] = (WCHAR)0;

        // Copy the privelege flags
        pRasUser->bfPrivilege = UserInfo.bfPrivilege;

        // Assign the user in the cache
        This->pUserCache[This->dwUserCount] = pRasUser;
        
        // Update the user count
        This->dwUserCount += 1;
        
    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            if (pRasUser)
            {
                if (pRasUser->pszName)
                {
                    RassrvFree(pRasUser->pszName);
                }
                
                RassrvFree(pRasUser);
            }
        }
    }

    return (dwErr == NO_ERROR) ? TRUE : FALSE;
}

// 
// Loads the global encryption setting.  Because the operation opens
// up .mdb files to read profiles, etc.  it is put in its own function
// and is called only when absolutely needed.
//
DWORD 
usrLoadEncryptionSetting(
    IN RASSRV_USERDB * This)
{
    DWORD dwErr = NO_ERROR;
    DWORD dwSvrFlags, dwProfFlags;

    if (This->bEncSettingLoaded)
    {
        return NO_ERROR;
    }
    
    // Read in the encryption setting by combining the 
    // server flags with the values in the default 
    // profile.
    dwSvrFlags  = MPR_USER_PROF_FLAG_UNDETERMINED;
    dwProfFlags = MPR_USER_PROF_FLAG_UNDETERMINED;
    
    MprAdminUserReadProfFlags (This->hServer, &dwProfFlags);
    usrGetServerEnc (&dwSvrFlags);

    // If both sources confirm the encryption requirement
    // then we require encryption
    if ((dwProfFlags & MPR_USER_PROF_FLAG_SECURE) &&
        (dwSvrFlags  & MPR_USER_PROF_FLAG_SECURE))
    {
        This->bEncrypt = TRUE;
    }
    else
    {
        This->bEncrypt = FALSE;
    }

    This->bEncSettingLoaded = TRUE;

    return dwErr;
}
    
// Creates a user data base object, initializing it from the local 
// user database and returning a handle to it.
DWORD 
usrOpenLocalDatabase (
    IN HANDLE * hUserDatabase) 
{
    RASSRV_USERDB * This = NULL;
    DWORD dwErr;

    if (!hUserDatabase)
        return ERROR_INVALID_PARAMETER;

    // Allocate the database
    if ((This = RassrvAlloc(sizeof(RASSRV_USERDB), TRUE)) == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Connect to the user server
    dwErr = MprAdminUserServerConnect(NULL, TRUE, &(This->hServer));
    if (dwErr != NO_ERROR)
    {
        RassrvFree(This);
        return dwErr;
    }

    // Load in the data from the system
    if ((dwErr = usrReloadLocalDatabase((HANDLE)This)) == NO_ERROR) {
        *hUserDatabase = (HANDLE)This;
        This->bFlushOnClose = FALSE;
        return NO_ERROR;
    }

    DbgOutputTrace ("usrOpenLocalDb: unable to load user db 0x%08x", 
                    dwErr);
                    
    RassrvFree(This);
    *hUserDatabase = NULL;
    
    return dwErr;
}

// Reloads the user information cached in the user database obj 
// from the system.  This can be used to implement a refresh in the ui.
// 
DWORD 
usrReloadLocalDatabase (
    IN HANDLE hUserDatabase) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    DWORD dwErr;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Cleanup the old database
    if (This->pUserCache) 
    {
        usrFreeUserArray(This->pUserCache, This->dwUserCount);
        RassrvFree(This->pUserCache);
    }

    // The encryption setting is loaded on demand from the
    // usrGetEncryption/usrSetEncryption api's.  This is a performance
    // tune so that the IC wizard wouldn't have to wait for
    // the profile to be loaded even though it doesn't use the result.

    // Read in the purity of the system
    {
        DWORD dwPure = 0;
        
        RassrvRegGetDw(&dwPure, 
                       0, 
                       (const PWCHAR)pszregRasParameters, 
                       (const PWCHAR)pszregPure);
                       
        if (dwPure == 1)
            This->bPure = FALSE;
        else 
            This->bPure = TRUE;
    }

    // Read in whether dcc connections can be bypassed
    {
        DWORD dwSvrFlags = 0;

        RassrvRegGetDw(
            &dwSvrFlags,
            dwSvrFlags,
            (const PWCHAR)pszregRasParameters, 
            (const PWCHAR)pszregServerFlags);

        if (dwSvrFlags & PPPCFG_AllowNoAuthOnDCPorts)
            This->bDccBypass = TRUE;
        else
            This->bDccBypass = FALSE;
    }

    // Enumerate the local users from the system adding them
    // to this database.
    dwErr = usrEnumLocalUsers(usrInitializeUser, hUserDatabase);
    if (dwErr != NO_ERROR)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}

// Frees up the resources held by a user database object.
DWORD 
usrCloseLocalDatabase (
    IN HANDLE hUserDatabase) 
{
    DWORD i;
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;

    // Make sure we were passed a valid handle
    if (!This)
        return ERROR_INVALID_PARAMETER;

    // We're done if there are no users
    if (!This->dwUserCount)
        return NO_ERROR;

    // Commit any settings as appropriate
    if (This->bFlushOnClose)
        usrFlushLocalDatabase(hUserDatabase);

    // Free the user cache 
    usrFreeUserArray(This->pUserCache, This->dwUserCount);
    RassrvFree(This->pUserCache);

    // Disconnect from the user server
    MprAdminUserServerDisconnect (This->hServer);

    // Free This
    RassrvFree(This);

    return NO_ERROR;
}

// Flushes the data written to the database object
DWORD 
usrFlushLocalDatabase (
    IN HANDLE hUserDatabase) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    RASSRV_USERINFO * pUser;
    DWORD dwErr, dwRet = NO_ERROR, dwCount, i, dwLength;

    dwErr = usrGetUserCount (This, &dwCount);
    if (dwErr != NO_ERROR)
        return dwErr;

    for (i=0; i<dwCount; i++) {
        pUser = This->pUserCache[i];
        // Flush any dirty settings
        if (usrIsDirty(pUser)) {
            // Add the user to the local user database if it hasn't 
            // already been done
            if (usrIsAddDirty(pUser)) 
            {

                //For secure password bug .Net 754400
                SafeDecodePasswordBuf(pUser->szPassword);
                dwErr = RasSrvAddUser (
                            pUser->pszName,
                            (pUser->pszFullName) ? pUser->pszFullName : L"",
                            (L'\0'!=pUser->szPassword[0]) ? pUser->szPassword : L"");
                SafeEncodePasswordBuf(pUser->szPassword);
                            
                if (dwErr != NO_ERROR)
                    dwRet = dwErr;

                // Now get the SDO handle to the user
                // so we can commit ras properties below.
                dwErr = MprAdminUserOpen (
                            This->hServer, 
                            pUser->pszName, 
                            &(pUser->hUser));
                if (dwErr != NO_ERROR)
                    continue;
            }
        
            // Flush dirty callback properties
            if (usrIsRasPropsDirty(pUser)) {
                if ((dwErr = usrCommitRasProps(This->pUserCache[i])) != NO_ERROR)
                    dwRet = dwErr;
            }

            // Flush dirty password and full name settings
            if (usrIsFullNameDirty(pUser) || usrIsPasswordDirty(pUser)) {

                SafeDecodePasswordBuf(pUser->szPassword);
                RasSrvEditUser (
                    pUser->pszName,
                    (usrIsFullNameDirty(pUser)) ? pUser->pszFullName : NULL,
                    (usrIsPasswordDirty(pUser)) ? pUser->szPassword : NULL);

                SafeEncodePasswordBuf(pUser->szPassword);
            }

            // Reset the user as not being dirty
            usrClearDirty(pUser);
        }
    }

    // Flush the encryption setting if it has been read
    if (This->bEncSettingLoaded)
    {
        DWORD dwFlags;

        if (This->bEncrypt)
            dwFlags = MPR_USER_PROF_FLAG_SECURE;
        else
            dwFlags = 0;
            
        MprAdminUserWriteProfFlags (This->hServer, dwFlags);
        usrSetServerEnc(dwFlags);
    }

    // Flush out the purity of the system
    {
        DWORD dwPure = 0;
        
        if (This->bPure)
            dwPure = 0;
        else 
            dwPure = 1;
            
        RassrvRegSetDw(dwPure, 
                       (const PWCHAR)pszregRasParameters, 
                       (const PWCHAR)pszregPure);
    }

    // Flush out whether dcc connections can be bypassed
    {
        DWORD dwSvrFlags = 0;

        RassrvRegGetDw(
            &dwSvrFlags,
            dwSvrFlags,
            (const PWCHAR)pszregRasParameters, 
            (const PWCHAR)pszregServerFlags);

        if (This->bDccBypass)
             dwSvrFlags |= PPPCFG_AllowNoAuthOnDCPorts;
        else
             dwSvrFlags &= ~PPPCFG_AllowNoAuthOnDCPorts;

        RassrvRegSetDw(
            dwSvrFlags,
            (const PWCHAR)pszregRasParameters, 
            (const PWCHAR)pszregServerFlags);
    }


    return dwRet;
}

// Rolls back the local user database so that no
// changes will be committed when Flush is called.
DWORD 
usrRollbackLocalDatabase (
    IN HANDLE hUserDatabase) 
{
    DWORD i, dwIndex, dwErr;
    BOOL bCommit;
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;

    if (!This)
        return ERROR_INVALID_PARAMETER;
        
    if (!This->dwUserCount)
        return NO_ERROR;

    // Go through the database, marking each user as not dirty
    for (i = 0; i < This->dwUserCount; i++) 
        usrClearDirty(This->pUserCache[i]);

    This->bFlushOnClose = FALSE;
    
    return NO_ERROR;
}

//
// Determines whether all users are required to encrypt
// their data and passwords.
//
DWORD usrGetEncryption (
        IN  HANDLE hUserDatabase, 
        OUT PBOOL pbEncrypted)
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Load in the encryption setting
    usrLoadEncryptionSetting(This);

    *pbEncrypted = This->bEncrypt;

    return NO_ERROR;
}

// Gets user encryption setting
DWORD 
usrSetEncryption (
    IN HANDLE hUserDatabase, 
    IN BOOL bEncrypt) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Load in the encryption setting
    usrLoadEncryptionSetting(This);

    This->bEncrypt = bEncrypt;

    return NO_ERROR;
}

// Returns whether dcc connections are allowed to 
// bypass authentication
DWORD 
usrGetDccBypass (
    IN  HANDLE hUserDatabase, 
    OUT PBOOL pbBypass)
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    *pbBypass = This->bDccBypass;

    return NO_ERROR;
}

// Sets whether dcc connections are allowed to 
// bypass authentication
DWORD 
usrSetDccBypass (
    IN HANDLE hUserDatabase, 
    IN BOOL bBypass)
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    This->bDccBypass = bBypass;

    return NO_ERROR;
}

// Reports whether the user database is pure. (i.e. nobody has
// gone into MMC and messed with it).
DWORD 
usrIsDatabasePure (
    IN  HANDLE hUserDatabase, 
    OUT PBOOL pbPure) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    *pbPure = This->bPure;

    return NO_ERROR;
}

// Marks the user database's purity
DWORD 
usrSetDatabasePure(
    IN HANDLE hUserDatabase, 
    IN BOOL bPure) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    This->bPure = bPure;

    return NO_ERROR;
}

// Returns the number of users cached in this database
DWORD 
usrGetUserCount (
    IN  HANDLE hUserDatabase, 
    OUT LPDWORD lpdwCount) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This || !lpdwCount)
        return ERROR_INVALID_PARAMETER;

    *lpdwCount = This->dwUserCount;
    return NO_ERROR;
}

// Adds a user to the given database.  This user will not be 
// added to the system's local user database until this database
// object is flushed (and as long as Rollback is not called on 
// this database object)
//
// On success, an optional handle to the user is returned 
//
DWORD usrAddUser (
        IN  HANDLE hUserDatabase, 
        IN  PWCHAR pszName, 
        OUT OPTIONAL HANDLE * phUser) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    RASSRV_USERINFO * pUser;
    DWORD dwErr, dwLength;

    // Validate the parameters
    if (!This || !pszName)
        return ERROR_INVALID_PARAMETER;

    // If the user already exists, don't add him
    if (usrUserExists(This, pszName))
        return ERROR_ALREADY_EXISTS;

    // Resize the cache to accomodate if neccessary
    if (This->dwUserCount + 1 >= This->dwCacheSize) {
        dwErr = usrResizeCache(This, This->dwCacheSize + USR_ARRAY_GROW_SIZE);
        if (dwErr != NO_ERROR)
            return dwErr;
    }

    // Allocate the new user control block
    if ((pUser = RassrvAlloc(sizeof(RASSRV_USERINFO), TRUE)) == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Allocate space for the name
    dwLength = wcslen(pszName);
    pUser->pszName = RassrvAlloc((dwLength + 1) * sizeof(WCHAR), FALSE);
    if (pUser->pszName == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Copy the name
    wcscpy(pUser->pszName, pszName);

    // Enable the user for dialin by default
    usrEnableDialin ((HANDLE)pUser, TRUE);
    
    // Dirty the user
    usrDirtyAdd(pUser);
    usrDirtyRasProps(pUser);

    // Put the user in the array and re-sort it
    This->pUserCache[This->dwUserCount++] = pUser;
    usrResortCache(This);

    // Return the handle
    if (phUser)
        *phUser = (HANDLE)pUser;

    //Need this zero memory to tell if a password is set in the future.
    RtlSecureZeroMemory(pUser->szPassword,sizeof(pUser->szPassword));
    
    //Other place will always assume the password is encrypted
    //So encrypt even the empty password
    SafeEncodePasswordBuf(pUser->szPassword);
    
    return NO_ERROR;
}

// Gives the count of users stored in the user database object
// Deletes the given user
DWORD 
usrDeleteUser (
        IN HANDLE hUserDatabase, 
        IN DWORD dwIndex) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    RASSRV_USERINFO * pUser;
    DWORD dwErr, dwMoveElemCount;
    
    // Validate the parameters
    if (!This)
        return ERROR_INVALID_PARAMETER;

    // Bounds Check
    if (!usrBoundsCheck(This, dwIndex))
        return ERROR_INVALID_INDEX;

    // Get a reference to the user in question and remove him
    // from the cache
    pUser = This->pUserCache[dwIndex];

    //Need this to clear password area and any memory allocated(if CryptProtectData() is used)
    //
    SafeWipePasswordBuf(pUser->szPassword);
    
    // Attempt to delete the user from the system
    if ((dwErr = RasSrvDeleteUser(pUser->pszName)) != NO_ERROR)
        return dwErr;

    // Remove the user from the cache
    This->pUserCache[dwIndex] = NULL;

    // Pull down every thing in the cache so that there are no holes
    dwMoveElemCount = This->dwUserCount - dwIndex; 
    if (dwMoveElemCount) {
        MoveMemory(&(This->pUserCache[dwIndex]),
                   &(This->pUserCache[dwIndex + 1]), 
                   dwMoveElemCount * sizeof(RASSRV_USERINFO*));
    }

    // Decrement the number of users
    This->dwUserCount--;

    // Cleanup the user
    usrFreeUserArray(&pUser, 1);

    return NO_ERROR;
}

// Gives a handle to the user at the given index
DWORD 
usrGetUserHandle (
    IN  HANDLE hUserDatabase, 
    IN  DWORD dwIndex, 
    OUT HANDLE * hUser) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This || !hUser)
        return ERROR_INVALID_PARAMETER;

    if (!usrBoundsCheck(This, dwIndex))
        return ERROR_INVALID_INDEX;

    *hUser = (HANDLE)(This->pUserCache[dwIndex]);
    
    return NO_ERROR;
}

// Gets a pointer to the name of the user (do not modify this)
DWORD 
usrGetName (
    IN HANDLE hUser, 
    OUT PWCHAR* pszName) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    
    if (!pRassrvUser || !pszName)
        return ERROR_INVALID_PARAMETER;

    *pszName = pRassrvUser->pszName;
    
    return NO_ERROR;
}

// Fills the given buffer with a friendly display name 
// (in the form username (fullname))
//*lpdwBuffSize is the number of Characters, NOT including the ending NULL
DWORD 
usrGetDisplayName (
    IN HANDLE hUser, 
    IN PWCHAR pszBuffer, 
    IN OUT LPDWORD lpdwBufSize) 
{
    RASSRV_USERINFO * pRassrvUser = (RASSRV_USERINFO*)hUser;
    NET_API_STATUS nStatus;
    DWORD dwUserNameLength, dwFullLength, dwSizeRequired;
    WCHAR pszTemp[IC_USERFULLNAME]; // For whistler bug 39081   gangz
    DWORD dwErr = NO_ERROR;

    // Sanity check the params
    if (!pRassrvUser || !pszBuffer || !lpdwBufSize)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    do
    {
        // Get the full name of the user
        // For whistler bug 39081   gangz
        // This is size in bytes 
        dwFullLength = sizeof(pszTemp)/sizeof(pszTemp[0]); 
        dwErr = usrGetFullName(hUser, pszTemp, &dwFullLength);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
        // Make sure the buffer is big enough
        dwUserNameLength = wcslen(pRassrvUser->pszName);
        dwSizeRequired = dwUserNameLength + 
                         dwFullLength +  
                         ((dwFullLength) ? 3 : 0);
        if (*lpdwBufSize < dwSizeRequired) 
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            break;
        }
            
        if (dwFullLength)
        {
            wsprintfW(
                pszBuffer, 
                L"%s (%s)", 
                pRassrvUser->pszName, 
                pszTemp);
        }
        else
        {
            wcscpy(pszBuffer, pRassrvUser->pszName);
        }
        
    } while (FALSE);

    // Cleanup
    {
        // The number of characters required, NOT including ending NULL
        *lpdwBufSize = dwSizeRequired;
    }

    return dwErr;
}
// Fills the given buffer with a friendly display name 
// (in the form username (fullname))
// *lpdwBufSize is the number of characters, NOT including ending NULL
DWORD 
usrGetFullName (
    IN HANDLE hUser, 
    IN PWCHAR pszBuffer, 
    IN OUT LPDWORD lpdwBufSize) 
{
    RASSRV_USERINFO * pRassrvUser = (RASSRV_USERINFO*)hUser;
    NET_API_STATUS nStatus;
    USER_INFO_2 * pUserInfo = NULL;
    DWORD dwLength;
    PWCHAR pszFullName;
    DWORD dwErr = NO_ERROR;
    
    // Sanity check the params
    if (!pRassrvUser || !pszBuffer || !lpdwBufSize)
        return ERROR_INVALID_PARAMETER;

    // If the full name is already loaded, return it
    if (pRassrvUser->pszFullName)
        pszFullName = pRassrvUser->pszFullName;

    // or if this is a new user, get the name from memory
    else if (usrIsAddDirty(pRassrvUser)) {
        pszFullName = (pRassrvUser->pszFullName) ? 
                          pRassrvUser->pszFullName : L"";        
    }
    
    // Load the full name of the user
    else {    
        nStatus = NetUserGetInfo(
                    NULL, 
                    pRassrvUser->pszName, 
                    2, 
                    (LPBYTE*)&pUserInfo);
        if (nStatus != NERR_Success) {
            DbgOutputTrace (
                "usrGetFullName: %x returned from NetUserGetInfo for %S", 
                nStatus, 
                pRassrvUser->pszName);
            return nStatus;
        }
        pszFullName = (PWCHAR)pUserInfo->usri2_full_name;
    }

    do
    {
        // Make sure the length is ok
        dwLength = wcslen(pszFullName);

        // Assign the full name here if it hasn't already been done
        if (dwLength && !pRassrvUser->pszFullName) 
        {
            DWORD dwSize = dwLength * sizeof(WCHAR) + sizeof(WCHAR);
            pRassrvUser->pszFullName = RassrvAlloc(dwSize, FALSE);
            if (pRassrvUser->pszFullName)
            {
                wcscpy(pRassrvUser->pszFullName, pszFullName);
            }
        }

        // Check the size NOT including ending NULL
        if (*lpdwBufSize < dwLength )
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        // Copy in the full name
        wcscpy(pszBuffer, pszFullName);
        
   } while (FALSE);

   // Cleanup
   {
        // report the size in number of characters ( NOT include ending NULL)
       *lpdwBufSize = dwLength;
        if (pUserInfo)
        {
            NetApiBufferFree((LPBYTE)pUserInfo);
        }
   }

   return dwErr;
}

// Commits the full name of a user
DWORD usrSetFullName (
        IN HANDLE hUser, 
        IN PWCHAR pszFullName) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwLength;

    if (!pRassrvUser || !pszFullName)
        return ERROR_INVALID_PARAMETER;

    // If this is not a new name, don't do anything
    if (pRassrvUser->pszFullName) {
        if (wcscmp(pRassrvUser->pszFullName, pszFullName) == 0)
            return NO_ERROR;
        RassrvFree(pRassrvUser->pszFullName);
    }

    // Allocate a new one
    dwLength = wcslen(pszFullName);
    pRassrvUser->pszFullName = RassrvAlloc(dwLength * sizeof(WCHAR) + sizeof(WCHAR), 
                                           FALSE);
    if (!pRassrvUser->pszFullName)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Copy it over
    wcscpy(pRassrvUser->pszFullName, pszFullName);

    // Mark it dirty -- a newly added user has his/her full name commited
    // whenever it exists automatically
    if (!usrIsAddDirty(pRassrvUser))
        usrDirtyFullname(pRassrvUser);
    
    return NO_ERROR;
}

// Commits the password of a user
//pszNewPassword is not encoded
DWORD 
usrSetPassword (
    IN HANDLE hUser, 
    IN PWCHAR pszNewPassword) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwLength;

    if (!pRassrvUser || !pszNewPassword)
        return ERROR_INVALID_PARAMETER;

    // Cleanup the old password if it exists
    SafeWipePasswordBuf(pRassrvUser->szPassword);

    // Allocate a new one
    dwLength = wcslen(pszNewPassword);
    
    // Copy it over
    lstrcpynW(pRassrvUser->szPassword, pszNewPassword,
        sizeof(pRassrvUser->szPassword)/sizeof(pRassrvUser->szPassword[0])  );

    // Encrypt it
    SafeEncodePasswordBuf( pRassrvUser->szPassword );

    // Mark it dirty -- a newly added user has his/her full name commited
    // whenever it exists automatically
    if (!usrIsAddDirty(pRassrvUser))
        usrDirtyPassword(pRassrvUser);
    
    return NO_ERROR;
}

// Determines whether users have callback/dialin priveleges.
DWORD 
usrGetDialin (
    IN HANDLE hUser, 
    OUT BOOL* bEnabled) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwErr;
    RAS_USER_0 UserInfo;

    if (!pRassrvUser || !bEnabled)
        return ERROR_INVALID_PARAMETER;

    // Get the user info
    *bEnabled = (pRassrvUser->bfPrivilege & RASPRIV_DialinPrivilege);
    
    return NO_ERROR;
}

// Determines which if any callback priveleges are granted to a given user.  
// Either (or both) of bAdminOnly and bUserSettable can be null
DWORD 
usrGetCallback (
    IN  HANDLE hUser, 
    OUT BOOL* bAdminOnly, 
    OUT BOOL* bUserSettable) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwErr;

    if (!pRassrvUser || !bAdminOnly || !bUserSettable)
        return ERROR_INVALID_PARAMETER;
    
    // Return whether we have callback privelege
    if (bAdminOnly)
    {
        *bAdminOnly = 
            (pRassrvUser->bfPrivilege & RASPRIV_AdminSetCallback);
    }
    
    if (bUserSettable)
    {
        *bUserSettable = 
            (pRassrvUser->bfPrivilege & RASPRIV_CallerSetCallback);
    }
    
    return NO_ERROR;
}

// Enable/disable dialin privelege.
DWORD 
usrEnableDialin (
    IN HANDLE hUser, 
    IN BOOL bEnable) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwErr = NO_ERROR;
    BOOL bIsEnabled;

    if (!pRassrvUser)
        return ERROR_INVALID_PARAMETER;

    // If the dialin privelege is already set as requested return success
    bIsEnabled = pRassrvUser->bfPrivilege & RASPRIV_DialinPrivilege;
    if ((!!bIsEnabled) == (!!bEnable))
        return NO_ERROR;

    // Otherwise reset the privelege
    if (bEnable)
        pRassrvUser->bfPrivilege |= RASPRIV_DialinPrivilege;
    else
        pRassrvUser->bfPrivilege &= ~RASPRIV_DialinPrivilege;
    
    // Dirty the user (cause him/her to be flushed at apply time)
    usrDirtyRasProps(pRassrvUser);

    return dwErr;
}

// The flags are evaluated in the following order with whichever condition
// being satisfied fist defining the behavior of the function.
// bNone == TRUE => Callback is disabled for the user
// bCaller == TRUE => Callback is set to caller-settable
// bAdmin == TRUE => Callback is set to a predefine callback number set 
// All 3 are FALSE => No op
DWORD 
usrEnableCallback (
    IN HANDLE hUser, 
    IN BOOL bNone, 
    IN BOOL bCaller, 
    IN BOOL bAdmin) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwErr = NO_ERROR;
    BOOL bIsEnabled;

    if (!pRassrvUser)
        return ERROR_INVALID_PARAMETER;

    if (bNone) {
        pRassrvUser->bfPrivilege |= RASPRIV_NoCallback;         
        pRassrvUser->bfPrivilege &= ~RASPRIV_CallerSetCallback; 
        pRassrvUser->bfPrivilege &= ~RASPRIV_AdminSetCallback;  
    }
    else if (bCaller) {
        pRassrvUser->bfPrivilege &= ~RASPRIV_NoCallback;         
        pRassrvUser->bfPrivilege |= RASPRIV_CallerSetCallback; 
        pRassrvUser->bfPrivilege &= ~RASPRIV_AdminSetCallback;  
    }
    else if (bAdmin) {
        pRassrvUser->bfPrivilege &= ~RASPRIV_NoCallback;         
        pRassrvUser->bfPrivilege &= ~RASPRIV_CallerSetCallback; 
        pRassrvUser->bfPrivilege |= RASPRIV_AdminSetCallback;  
    }
    else 
        return NO_ERROR;

    // Dirty the user (cause him/her to be flushed at apply time)
    usrDirtyRasProps(pRassrvUser);

    return dwErr;
}

// Retreives a pointer to the callback number of the given user
DWORD 
usrGetCallbackNumber(
    IN  HANDLE hUser, 
    OUT PWCHAR * lpzNumber) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    
    if (!pRassrvUser || !lpzNumber)
        return ERROR_INVALID_PARAMETER;

    // Return the pointer to the callback number
    *lpzNumber = pRassrvUser->wszPhoneNumber;

    return NO_ERROR;
}

// Sets the callback number of the given user.  If lpzNumber is NULL, 
// an empty phone number is copied.
DWORD 
usrSetCallbackNumber(
    IN HANDLE hUser, 
    IN PWCHAR lpzNumber) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwErr = NO_ERROR;

    if (!pRassrvUser)
        return ERROR_INVALID_PARAMETER;
    
    // Modify the phone number appropriately
    if (!lpzNumber)
        wcscpy(pRassrvUser->wszPhoneNumber, L"");
    else {
        lstrcpynW(pRassrvUser->wszPhoneNumber, lpzNumber, MAX_PHONE_NUMBER_LEN);
        pRassrvUser->wszPhoneNumber[MAX_PHONE_NUMBER_LEN] = (WCHAR)0;
    }

    // Dirty the user (cause him/her to be flushed at apply time)
    usrDirtyRasProps(pRassrvUser);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\userdb.h ===
/*
    File    userdb.h

    Definition of the local user database object.

    Paul Mayfield, 10/8/97
*/


#ifndef __userdb_h
#define __userdb_h

#include <windows.h>

// Creates a user data base object, initializing it from the local user database
// and returning a handle to it.
DWORD usrOpenLocalDatabase (HANDLE * hUserDatabase);

// Frees up the resources held by a user database object flushing all 
// changes to the system.
DWORD usrCloseLocalDatabase (HANDLE hUserDatabase);

// Flushes the data written to the database object to the system
DWORD usrFlushLocalDatabase (HANDLE hUserDatabase);

// Rolls back the local user database so that it is in 
// the same state it was in when usrOpenLocalDatabase was
// called. The rollback is automatically flushed to the 
// system. (i.e. usrFlushLocalDatabase doesn't need to follow)
DWORD usrRollbackLocalDatabase (HANDLE hUserDatabase);

// Reloads the local user database from the system 
DWORD usrReloadLocalDatabase (HANDLE hUserDatabase);

// Gets global user data
DWORD usrGetEncryption (HANDLE hUserDatabase, PBOOL pbEncrypted);

// Gets user encryption setting
DWORD usrSetEncryption (HANDLE hUserDatabase, BOOL bEncrypt);

// Returns whether dcc connections are allowed to bypass authentication
DWORD usrGetDccBypass (HANDLE hUserDatabase, PBOOL pbBypass);

// Sets whether dcc connections are allowed to bypass authentication
DWORD usrSetDccBypass (HANDLE hUserDatabase, BOOL bBypass);

// Reports whether the user database is pure. (i.e. nobody has
// gone into MMC and messed with it).
DWORD usrIsDatabasePure (HANDLE hUserdatabase, PBOOL pbPure);

// Marks the user database's purity
DWORD usrSetDatabasePure(HANDLE hUserDatabase, BOOL bPure);

// Gives the count of users stored in the user database object
DWORD usrGetUserCount (HANDLE hUserDatabase, LPDWORD lpdwCount);

// Adds a user to the given database.  This user will not be 
// added to the system's local user database until this database
// object is flushed (and as long as Rollback is not called on 
// this database object)
//
// On success, an optional handle to the user is returned 
//
DWORD usrAddUser (HANDLE hUserDatabase, PWCHAR pszName, OPTIONAL HANDLE * phUser);

// Deletes the user at the given index 
DWORD usrDeleteUser (HANDLE hUserDatabase, DWORD dwIndex);

// Gives a handle to the user at the given index
DWORD usrGetUserHandle (HANDLE hUserDatabase, DWORD dwIndex, HANDLE * hUser);

// Gets a pointer to the name of the user (do not modify this)
DWORD usrGetName (HANDLE hUser, PWCHAR* pszName);

// Fills the given buffer with the full name of the user
DWORD usrGetFullName (HANDLE hUser, IN PWCHAR pszBuffer, IN OUT LPDWORD lpdwBufSize);

// Commits the full name of a user
DWORD usrSetFullName (HANDLE hUser, PWCHAR pszFullName);

// Commits the password of a user
DWORD usrSetPassword (HANDLE hUser, PWCHAR pszNewPassword);

// Fills the given buffer with a friendly display name (in the form username (fullname))
DWORD usrGetDisplayName (HANDLE hUser, IN PWCHAR pszBuffer, IN OUT LPDWORD lpdwBufSize);

// Determines whether users has callback/dialin priveleges.
DWORD usrGetDialin (HANDLE hUser, BOOL* bEnabled);

// Determines which if any callback priveleges are granted to a given user.  Either (or both) of 
// bAdminOnly and bCallerSettable can be NULL
DWORD usrGetCallback (HANDLE hUser, BOOL* bAdminOnly, BOOL * bCallerSettable);

// Enable/disable dialin privelege.
DWORD usrEnableDialin (HANDLE hUser, BOOL bEnable);

// The flags are evaluated in the following order with whichever condition
// being satisfied fist defining the behavior of the function.
// bNone == TRUE => Callback is disabled for the user
// bCaller == TRUE => Callback is set to caller-settable
// bAdmin == TRUE => Callback is set to a predefine callback number set in usrSetCallbackNumer
// All 3 are FALSE => No op
DWORD usrEnableCallback (HANDLE hUser, BOOL bNone, BOOL bCaller, BOOL bAdmin);

// Retreives a pointer to the callback number of the given user
DWORD usrGetCallbackNumber(HANDLE hUser, PWCHAR * lpzNumber);

// Sets the callback number of the given user.  If lpzNumber is NULL, an empty phone number
// is copied.
DWORD usrSetCallbackNumber(HANDLE hUser, PWCHAR lpzNumber);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\tcpipui.c ===
/*
    File    tcpipui.c

    Dialog that edits the tcpip properties.
    
    Paul Mayfield, 10/9/97
*/

#include "rassrv.h"

#define IDH_DISABLEHELP	((DWORD)-1)

// Help maps
static const DWORD phmTcpipui[] =
{
    CID_NetTab_Tcpipui_CB_ExposeNetwork,    IDH_NetTab_Tcpipui_CB_ExposeNetwork, 
    CID_NetTab_Tcpipui_EB_Start,            IDH_NetTab_Tcpipui_EB_Start,
    CID_NetTab_Tcpipui_RB_Dhcp,             IDH_NetTab_Tcpipui_RB_Dhcp,
    CID_NetTab_Tcpipui_RB_StaticPool,       IDH_NetTab_Tcpipui_RB_StaticPool, 
    CID_NetTab_Tcpipui_EB_Mask,             IDH_NetTab_Tcpipui_EB_Mask,      
    CID_NetTab_Tcpipui_CB_CallerSpec,       IDH_NetTab_Tcpipui_CB_CallerSpec, 
    CID_NetTab_Tcpipui_EB_Range,            IDH_DISABLEHELP,          
    CID_NetTab_Tcpipui_EB_Total,            IDH_DISABLEHELP,
    0,                                      0
};

// Error reporting
void 
TcpipUiDisplayError(
    HWND hwnd, 
    DWORD dwErr) 
{
    ErrDisplayError(
        hwnd, 
        dwErr, 
        ERR_TCPIPPROP_CATAGORY, 
        0, 
        Globals.dwErrorData);
}

// Converts a dword ip address (in host order) to a wide character string 
//
DWORD 
TcpipDwordToAddr(
    DWORD dwAddr, 
    PWCHAR pszAddr) 
{
    wsprintfW(
        pszAddr, 
        L"%d.%d.%d.%d", 
        FIRST_IPADDRESS (dwAddr),
        SECOND_IPADDRESS(dwAddr),
        THIRD_IPADDRESS (dwAddr),
        FOURTH_IPADDRESS(dwAddr));
        
    return NO_ERROR;
}

// 
// Returns NO_ERROR if the given address is a valid IP pool.
// The offending component is returned in lpdwErrReason.  
// See RASIP_F_* values
//
DWORD
TcpipUiValidatePool(
    IN  DWORD dwAddress, 
    IN  DWORD dwEnd, 
    OUT LPDWORD lpdwErrReason 
    )
{
    DWORD i, dwMaskMask;
    DWORD dwLowIp, dwHighIp, dwErr;

    // Initialize
    //
    dwLowIp = MAKEIPADDRESS(1,0,0,0);
    dwHighIp = MAKEIPADDRESS(224,0,0,0);

    // Make sure that the netId is a valid class 
    //
    if ((dwAddress < dwLowIp)               || 
        (dwAddress >= dwHighIp)             ||
        (FIRST_IPADDRESS(dwAddress) == 127))
    {
        *lpdwErrReason = SID_TCPIP_InvalidNetId;
        return ERROR_BAD_FORMAT;
    }

    // Make sure the pool base is not more specific than
    // the mask
    //
    if (dwAddress >= dwEnd)
    {
        *lpdwErrReason = SID_TCPIP_NetidMaskSame;
        return ERROR_BAD_FORMAT;
    }

    return NO_ERROR;
}


// Enables/disables windows in the dialog box depending
// on the tcpip parameters
//
DWORD 
TcpipEnableWindows(
    HWND hwndDlg, 
    TCPIP_PARAMS * pTcpipParams) 
{
    HWND hwndStart = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Start);
    HWND hwndMask = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Mask);

    if (hwndStart)
    {
        EnableWindow(hwndStart, !pTcpipParams->bUseDhcp);
    }
         
    if (hwndMask)
    {
        EnableWindow(hwndMask, !pTcpipParams->bUseDhcp);
    }
    
    return NO_ERROR;
}

// Generates number formatting data
//
DWORD 
TcpipGenerateNumberFormatter (
    NUMBERFMT * pNumFmt) 
{
    CHAR pszNeg[64], pszLz[2];

    ZeroMemory (pNumFmt->lpDecimalSep, 4);
    pNumFmt->NumDigits = 0;
    pNumFmt->Grouping = 3;
    
    GetLocaleInfoA (LOCALE_SYSTEM_DEFAULT, 
                   LOCALE_ILZERO, 
                   pszLz, 
                   2);
                   
    GetLocaleInfoW (LOCALE_SYSTEM_DEFAULT, 
                   LOCALE_STHOUSAND, 
                   pNumFmt->lpThousandSep, 
                   2);
                   
    GetLocaleInfoA (LOCALE_SYSTEM_DEFAULT, 
                   LOCALE_INEGNUMBER, 
                   pszNeg, 
                   2);

    pNumFmt->LeadingZero = atoi(pszLz);
    pNumFmt->NegativeOrder = atoi(pszNeg);
    
    return NO_ERROR;
}

// Formats an unsigned number with commas, etc.  
//
PWCHAR 
TcpipFormatDword(
    DWORD dwVal) 
{
    static WCHAR pszRet[64], pszDSep[2], pszTSep[2] = {0,0};
    static NUMBERFMT NumberFmt = {0,0,0,pszDSep,pszTSep,0};
    static BOOL bInitialized = FALSE;
    WCHAR pszNum[64];
    
    // Stringize the number
    wsprintfW (pszNum, L"%u", dwVal);
    pszRet[0] = (WCHAR)0;

    // Initialize number formatting
    if (!bInitialized) 
    {
        TcpipGenerateNumberFormatter (&NumberFmt);
        bInitialized = TRUE;
    }        
    
    // Get the local version of this
    GetNumberFormatW (
        LOCALE_SYSTEM_DEFAULT,    
        0,
        pszNum,
        &NumberFmt,
        pszRet,
        sizeof(pszRet) / sizeof(WCHAR));
                     
    return pszRet;                     
}

// Sets the range and total incoming clients fields of the tcpip properties
// dialog.
//
DWORD 
TcpipReCalcPoolSize(
    HWND hwndDlg) 
{
    HWND hwndStart, hwndEnd, hwndTotal;
    DWORD dwStart = 0, dwEnd = 0, dwTotal=0;
    WCHAR pszBuf[256];

    hwndStart = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Start);
    hwndEnd   = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Mask);
    hwndTotal = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Total);

    if (hwndStart) 
    {
        SendMessage(hwndStart, IP_GETADDRESS, 0, (LPARAM)&dwStart);
    }

    if (hwndEnd)
    {
        SendMessage(hwndEnd, IP_GETADDRESS, 0, (LPARAM)&dwEnd);
    }

    //For whistler bug 281545   gangz
    //
    if ( 0 == dwStart )
    {
        dwTotal = dwEnd - dwStart;
    }
    else
    {
        if (dwEnd >= dwStart) 
        {
            dwTotal = dwEnd - dwStart + 1;
        }
        else
        {
            dwTotal = 0;
        }
    }
    
    if (hwndTotal)
    {
        SetWindowTextW(hwndTotal, TcpipFormatDword(dwTotal) );
    }

    return NO_ERROR;
}

// Initializes the Tcpip Properties Dialog
//
DWORD 
TcpipInitDialog(
    HWND hwndDlg, 
    LPARAM lParam) 
{
    LPSTR pszAddr;
    TCPIP_PARAMS * pTcpipParams = (TCPIP_PARAMS *)
        (((PROT_EDIT_DATA*)lParam)->pbData);
    HWND hwndFrom, hwndTo;
    WCHAR pszAddrW[256];
                                                   
    // Store the parameters with the window handle
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
    
    // Set the network exposure check
    SendDlgItemMessage(
        hwndDlg, 
        CID_NetTab_Tcpipui_CB_ExposeNetwork,
        BM_SETCHECK, 
        (((PROT_EDIT_DATA*)lParam)->bExpose) ? BST_CHECKED : BST_UNCHECKED,
        0);

    // Set the address assignmnet radio buttons
    SendDlgItemMessage(
        hwndDlg, 
        CID_NetTab_Tcpipui_RB_Dhcp, 
        BM_SETCHECK, 
        (pTcpipParams->bUseDhcp) ? BST_CHECKED : BST_UNCHECKED,
        0);
    
    // Set the address assignmnet radio buttons
    SendDlgItemMessage(
        hwndDlg, 
        CID_NetTab_Tcpipui_RB_StaticPool, 
        BM_SETCHECK, 
        (pTcpipParams->bUseDhcp) ? BST_UNCHECKED : BST_CHECKED,
        0);
    
    // Set the "allow caller to specify ip address" check
    SendDlgItemMessage(
        hwndDlg, 
        CID_NetTab_Tcpipui_CB_CallerSpec, 
        BM_SETCHECK, 
        (pTcpipParams->bCaller) ? BST_CHECKED : BST_UNCHECKED,
        0);

    // Set the text of the ip addresses
    if (pTcpipParams->dwPoolStart != 0)
    {
        hwndFrom = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Start);
        hwndTo = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Mask);
        TcpipDwordToAddr(pTcpipParams->dwPoolStart, pszAddrW);
        if (hwndFrom) 
        {   
            SetWindowText(hwndFrom, pszAddrW);
        }
        TcpipDwordToAddr(pTcpipParams->dwPoolEnd, pszAddrW);
        if (hwndTo) 
        {
            SetWindowText(hwndTo, pszAddrW);
        }
    }        

    // Enable/disable windows as per the settings
    TcpipEnableWindows(hwndDlg, pTcpipParams);

    return NO_ERROR;
}

// Gets the settings from the ui and puts them into 
// the tcpip parameter structure.
//
DWORD 
TcpipGetUISettings(
    IN  HWND hwndDlg,  
    OUT PROT_EDIT_DATA * pEditData,
    OUT LPDWORD lpdwFrom,
    OUT LPDWORD lpdwTo) 
{
    TCPIP_PARAMS * pTcpipParams = 
        (TCPIP_PARAMS *) pEditData->pbData;
    HWND hwndFrom, hwndTo;

    hwndFrom = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Start);
    hwndTo = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Mask);
        
    pEditData->bExpose = 
        SendDlgItemMessage(
            hwndDlg, 
            CID_NetTab_Tcpipui_CB_ExposeNetwork, 
            BM_GETCHECK, 
            0, 
            0) == BST_CHECKED;

    if (hwndFrom)
    {
        SendMessage(
            hwndFrom, 
            IP_GETADDRESS, 
            0, 
            (LPARAM)&pTcpipParams->dwPoolStart);
    }

    if (hwndTo)
    {
        SendMessage(
            hwndTo, 
            IP_GETADDRESS, 
            0, 
            (LPARAM)&pTcpipParams->dwPoolEnd);
    }

    *lpdwFrom = pTcpipParams->dwPoolStart;
    *lpdwTo = pTcpipParams->dwPoolEnd;

    return NO_ERROR;
}

DWORD
TcpipUiHandleOk(
    IN HWND hwndDlg)
{
    PROT_EDIT_DATA* pData = NULL;
    TCPIP_PARAMS * pParams = NULL;
    DWORD dwErr, dwId = SID_TCPIP_InvalidPool;
    DWORD dwStart = 0, dwEnd = 0;
    PWCHAR pszMessage = NULL;
    MSGARGS MsgArgs;

    // Get the context
    //
    pData = (PROT_EDIT_DATA*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    if (pData == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Read values from the UI
    //
    dwErr = TcpipGetUISettings(hwndDlg, pData, &dwStart, &dwEnd);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Validate the pool if one was entered
    //
    pParams = (TCPIP_PARAMS *)pData->pbData;    
    if (pParams->bUseDhcp == FALSE)
    {
        dwErr = TcpipUiValidatePool(
                    dwStart,
                    dwEnd,
                    &dwId);
        if (dwErr != NO_ERROR)
        {
            ZeroMemory(&MsgArgs, sizeof(MsgArgs));                            
            MsgArgs.dwFlags = MB_OK;

            MsgDlgUtil(
                hwndDlg,
                dwId,
                &MsgArgs,
                Globals.hInstDll,
                SID_DEFAULT_MSG_TITLE);
        }
    }

    return dwErr;
}        

// Dialog proc that governs the tcpip settings dialog
INT_PTR 
CALLBACK 
TcpipSettingsDialogProc (
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam) 
{
    switch (uMsg) {
        case WM_INITDIALOG:
            TcpipInitDialog(hwndDlg, lParam);
            return FALSE;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmTcpipui);
            break;
        }

        case WM_DESTROY:                           
            // Cleanup the work done at WM_INITDIALOG 
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);
            break;
        
        case WM_COMMAND:
            {
                TCPIP_PARAMS * pTcpipParams = (TCPIP_PARAMS *)
                    (((PROT_EDIT_DATA*)
                        GetWindowLongPtr(hwndDlg, GWLP_USERDATA))->pbData);
                switch (wParam) 
                {
                    case IDOK:
                        if (TcpipUiHandleOk(hwndDlg) == NO_ERROR)
                        {
                            EndDialog(hwndDlg, 1);
                        }
                        break;
                        
                    case IDCANCEL:
                        EndDialog(hwndDlg, 0);
                        break;
                        
                    case CID_NetTab_Tcpipui_RB_Dhcp:
                        pTcpipParams->bUseDhcp = TRUE;
                        TcpipEnableWindows(hwndDlg, pTcpipParams);
                        break;
                        
                    case CID_NetTab_Tcpipui_RB_StaticPool:
                        pTcpipParams->bUseDhcp = FALSE;
                        TcpipEnableWindows(hwndDlg, pTcpipParams);
                        break;
                        
                    case CID_NetTab_Tcpipui_CB_CallerSpec:
                        pTcpipParams->bCaller = (BOOL)
                            SendDlgItemMessage(
                                hwndDlg, 
                                CID_NetTab_Tcpipui_CB_CallerSpec, 
                                BM_GETCHECK, 
                                0,
                                0);
                        break;
                }
                
                // Recal the pool size as appropriate
                // 
                if (HIWORD(wParam) == EN_CHANGE) 
                {
                    if (LOWORD(wParam) == CID_NetTab_Tcpipui_EB_Start || 
                        LOWORD(wParam) == CID_NetTab_Tcpipui_EB_Mask)
                    {                        
                        TcpipReCalcPoolSize(hwndDlg);
                    }
                }
                break;
            }
    }

    return FALSE;
}

// Edits tcp ip protocol properties
//
DWORD 
TcpipEditProperties(
    HWND hwndParent, 
    PROT_EDIT_DATA * pEditData, 
    BOOL * pbCommit) 
{
    DWORD dwErr;
    int ret;

    // Initialize the ip address custom controls
    IpAddrInit(Globals.hInstDll, SID_TCPIP_TITLE, SID_TCPIP_BADRANGE);

    // Popup the dialog box
    ret = (int) DialogBoxParam(
                    Globals.hInstDll,
                    MAKEINTRESOURCE(DID_NetTab_Tcpipui),
                    hwndParent,
                    TcpipSettingsDialogProc,
                    (LPARAM)pEditData);
    if (ret == -1) 
    {
        TcpipUiDisplayError(hwndParent, ERR_TCPIP_CANT_DISPLAY);
    }

    // If ok was pressed, save off the new settings
    *pbCommit = FALSE;
    if (ret && ret != -1)
    {
        *pbCommit = TRUE;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\usertab.c ===
/*
    File    usertab.c

    Implementation of the users dialog tab for the dialup server ui.

    Paul Mayfield, 9/29/97
*/

#include "rassrv.h"
#include "usertab.h"
#include <htmlhelp.h>

#define USERTAB_PASSWORD_BUFFER_SIZE (PWLEN+1)
static const WCHAR pszDummyPassword[] = L"XXXXXXXXXXXXXXX";

// Help maps
static const DWORD phmUserTab[] =
{
    CID_UserTab_LV_Users,           IDH_UserTab_LV_Users,
    CID_UserTab_PB_New,             IDH_UserTab_PB_New,
    CID_UserTab_PB_Delete,          IDH_UserTab_PB_Delete,
    CID_UserTab_PB_Properties,      IDH_UserTab_PB_Properties,
    CID_UserTab_PB_SwitchToMMC,     IDH_UserTab_PB_SwitchToMMC,
    CID_UserTab_CB_BypassDcc,       IDH_UserTab_CB_BypassDcc,
    0,                              0
};

static const DWORD phmCallback[] =
{
    CID_UserTab_Callback_RB_Caller, IDH_UserTab_Callback_RB_Caller,
    CID_UserTab_Callback_RB_Admin,  IDH_UserTab_Callback_RB_Admin,
    CID_UserTab_Callback_EB_Number, IDH_UserTab_Callback_EB_Number,
    CID_UserTab_Callback_RB_No,     IDH_UserTab_Callback_RB_No,
    0,                              0
};

static const DWORD phmNewUser[] =
{
    CID_UserTab_New_EB_Username,    IDH_UserTab_New_EB_Username,
    CID_UserTab_New_EB_Fullname,    IDH_UserTab_New_EB_Fullname,
    CID_UserTab_New_EB_Password1,   IDH_UserTab_New_EB_Password1,
    CID_UserTab_New_EB_Password2,   IDH_UserTab_New_EB_Password2,
    0,                              0
};

// Parameters to track net users
//
typedef struct _RASSRV_USER_PARAMS 
{
    BOOL bCanceled;         // Set by property sheets when cancel pressed
    BOOL bNewUser;	    // for .Net 691639, the password change warning dialog won't pop up when creating new users. gangz

    // General properties
    //For whistler bug 210032 to allow username be 20 characters long
    WCHAR pszLogonName[IC_USERNAME];
    WCHAR pszFullName [IC_USERFULLNAME+1];   // For whistler bug 39081    gangz
    WCHAR pszPassword1[USERTAB_PASSWORD_BUFFER_SIZE];
    WCHAR pszPassword2[USERTAB_PASSWORD_BUFFER_SIZE];
    DWORD dwErrorCode;

    // Callback properties
    HANDLE hUser;      
    BOOL bNone; 
    BOOL bCaller; 
    BOOL bAdmin;    
    WCHAR pszNumber[MAX_PHONE_NUMBER_LEN];
} RASSRV_USER_PARAMS;

// Fills in the property sheet structure with the information 
// required to display the user database tab.
//
DWORD 
UserTabGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_UserTab);
    ppage->pfnDlgProc  = UserTabDialogProc;
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->dwFlags     = PSP_USECALLBACK;
    ppage->lParam      = lpUserData;

    return NO_ERROR;
}

//
// Error reporting
//
VOID 
UserTabDisplayError(
    IN HWND hwnd, 
    IN DWORD err) 
{
    ErrDisplayError(
        hwnd, 
        err, 
        ERR_USERTAB_CATAGORY, 
        ERR_USERDB_SUBCAT, 
        Globals.dwErrorData);
}

// Fills in the user list view with the names of the users stored in the 
// user database provide.  Also, initializes the checked/unchecked status
// of each user.
DWORD 
UserTabFillUserList(
    IN HWND hwndLV, 
    IN HANDLE hUserDatabase) 
{
    LV_ITEM lvi;
    DWORD dwCount, i, dwErr, dwSize;
    HANDLE hUser;
    WCHAR pszName[IC_USERFULLNAME+IC_USERNAME+3];  
//    char pszAName[512];
    HIMAGELIST checks;
    BOOL bDialinEnabled;

    // Get the count of all the users
    if ((dwErr = usrGetUserCount(hUserDatabase, &dwCount)) != NO_ERROR) 
    {
        UserTabDisplayError(hwndLV, ERR_USER_DATABASE_CORRUPT);
        return dwErr;
    }

    ListView_SetUserImageList(hwndLV, Globals.hInstDll);

    // Initialize the list item
    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;

    // Looop through all of the users adding their names as we go
    for (i=0; i<dwCount; i++) 
    {
        dwSize = sizeof(pszName)/sizeof(pszName[0]);   // For whistler bug 39081   gangz
        if ((dwErr = usrGetUserHandle(hUserDatabase, i, &hUser)) == NO_ERROR) 
        {
            usrGetDisplayName (hUser, pszName, &dwSize);
            usrGetDialin(hUser, &bDialinEnabled);
            lvi.iImage = UI_Connections_User;
            lvi.iItem = i;
            lvi.pszText = pszName;
            lvi.cchTextMax = wcslen(pszName)+1;
            ListView_InsertItem(hwndLV,&lvi);
            ListView_SetCheck(hwndLV, i, bDialinEnabled);
        }
    }
    
    // Select the first item in the list view
    ListView_SetItemState(
        hwndLV, 
        0, 
        LVIS_SELECTED | LVIS_FOCUSED, 
        LVIS_SELECTED | LVIS_FOCUSED);

    return NO_ERROR;
}

//
// Initialize the user tab, returns false if focus was set, 
// true otherwise.
//
DWORD 
UserTabInitializeDialog(
    HWND hwndDlg, 
    WPARAM wParam, 
    LPARAM lParam) 
{
    HANDLE hUserDatabase = NULL;
    HWND hwndLV, hwndEnc, hwndBypass;
    LV_COLUMN lvc;
    RECT r;
    DWORD dwErr;
    BOOL bPure = FALSE, bBypass = FALSE;

    // Obtain handle to user database
    RasSrvGetDatabaseHandle(hwndDlg, ID_USER_DATABASE, &hUserDatabase);

    // Figure out if MMC has been used.
    dwErr = usrIsDatabasePure (hUserDatabase, &bPure);
    if ((dwErr == NO_ERROR) && (bPure == FALSE)) 
    {
        PWCHAR pszWarning, pszTitle;

        pszWarning = (PWCHAR) PszLoadString(
                                Globals.hInstDll,
                                WRN_USERS_CONFIGURED_MMC);

        pszTitle = (PWCHAR) PszLoadString(
                                Globals.hInstDll,
                                ERR_USERTAB_CATAGORY);

        MessageBox(hwndDlg, pszWarning, pszTitle, MB_OK | MB_ICONWARNING);
        usrSetDatabasePure(hUserDatabase, TRUE);
    }

    // Fill in the user list if it's not already filled
    hwndLV = GetDlgItem(hwndDlg, CID_UserTab_LV_Users);
    if (ListView_GetItemCount (hwndLV) == 0) 
    {
        ListView_InstallChecks(hwndLV, Globals.hInstDll);
        UserTabFillUserList(hwndLV, hUserDatabase);

        // Add a colum so that we'll display in report view
        GetClientRect(hwndLV, &r);
        lvc.mask = LVCF_FMT;
        lvc.fmt = LVCFMT_LEFT;
        ListView_InsertColumn(hwndLV,0,&lvc);
        ListView_SetColumnWidth(hwndLV, 0, LVSCW_AUTOSIZE_USEHEADER);

        // Initialize the encryption check box
        // For .Net 554416, removed the Require Encryption check box
        // For security, the default is require secured password and encrytpion 
        // now
        
        
        // Initialize the "bypass dcc" checkbox
        hwndBypass = GetDlgItem(hwndDlg, CID_UserTab_CB_BypassDcc);
        if (hwndBypass != NULL)
        {
            usrGetDccBypass(hUserDatabase, &bBypass);
            SendMessage(
                hwndBypass, 
                BM_SETCHECK,
                (bBypass) ? BST_CHECKED : BST_UNCHECKED,
                0);
        }                
    }
    
    return TRUE;
}

// 
// Cleanup anything done in the initialization function
//
DWORD 
UserTabCleanupDialog(
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    // Restore the user data
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);

    return NO_ERROR;
}

//
// Grants/revokes the dialin privelege of a user and reflects this 
// in the UI
//
DWORD 
UserTabHandleUserCheck(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    DWORD dwErr;
    HANDLE hUser = NULL, hUserDatabase = NULL;
    HWND hwndLV = GetDlgItem(hwndDlg, CID_UserTab_LV_Users);

    // Get the user handle from the user database
    RasSrvGetDatabaseHandle(hwndDlg, ID_USER_DATABASE, &hUserDatabase);
    dwErr = usrGetUserHandle(hUserDatabase, dwIndex, &hUser);
    if (dwErr != NO_ERROR) 
    {
        UserTabDisplayError(hwndDlg, ERR_USER_DATABASE_CORRUPT);
        return dwErr;
    }

    if (hwndLV)
    {
        // Set the dialin permission of the given user
        usrEnableDialin(hUser, ListView_GetCheck(hwndLV, dwIndex));
    }

    return NO_ERROR;
}
    
// .Net 660285
// Add password change warning dialogbox
// Because the resource files are all locked down, I have to borrow
// the resource localsec.dll for .Net and XPSP
// 
// In longhorn, I will create our own resource file
//
BOOL
PwInit(
    IN HWND hwndDlg )
{
    PWCHAR pszTitle = NULL;
    
    pszTitle = (PWCHAR) PszLoadString (
                            Globals.hInstDll, 
                            WRN_TITLE);
    
    SetWindowTextW (hwndDlg, pszTitle);
    
    return FALSE;
}

BOOL
PwCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )
{
    DWORD dwErr;

    switch (wId)
    {
      case IDC_HELP_BUTTON:
      {
         HtmlHelp(
            hwnd,
            TEXT("password.chm::/datalos.htm"),
            HH_DISPLAY_TOPIC,
            0);
         
         break;
      }
    
      case IDOK:
      case IDCANCEL:
      {
          EndDialog( hwnd, (wId == IDOK) );
          return TRUE;
      }
    }

    return FALSE;
}

INT_PTR CALLBACK
PwDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return PwInit( hwnd );
        }

        case WM_COMMAND:
        {
            return PwCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
            
        }
    }

    return FALSE;

}

DWORD WarnPasswordChange( 
    IN BOOL * pfChange )
{
    HMODULE hModule = NULL;
    DWORD dwErr = NO_ERROR;
    INT_PTR nStatus;

    do
    {
        if( NULL == pfChange )
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        *pfChange = FALSE;
        
        hModule = LoadLibrary(TEXT("LocalSec.dll"));
        if ( NULL == hModule )
        {
            dwErr = GetLastError();
            break;
        }

        // Look up the IDD_SET_PASSWORD_WARNING_OTHER_FRIENDLY resource
        // whose id values is 5174 in the localsec.dll
        //
        nStatus =
            (BOOL )DialogBox(
                hModule,
                MAKEINTRESOURCE(IDD_SET_PASSWORD_WARNING_OTHER_FRIENDLY),
                NULL,
                PwDlgProc);
        
        if (nStatus == -1)
        {
            dwErr = GetLastError();
            break;
        }

        *pfChange = (BOOL )nStatus;
    
    }
    while(FALSE);

    if( NULL != hModule )
    {
        FreeLibrary( hModule );
    }

    return dwErr;
}


//
// Loads the New User parameters and returns whether they
// have been correctly entered or not.
//
//Assume passwords in the input params are already encoded
BOOL 
UserTabNewUserParamsOk(
    IN HWND hwndDlg, 
    IN RASSRV_USER_PARAMS * pNuParams)
{
    USER_MODALS_INFO_0 * pModInfo;
    NET_API_STATUS nStatus;
    DWORD dwMinPasswordLength=0, dwLength;
    BOOL bOk = FALSE;
    HWND hwndControl = NULL;

    // Find the minium password length
    nStatus = NetUserModalsGet(NULL, 0, (LPBYTE*)&pModInfo);
    if (nStatus == NERR_Success) 
    {
        dwMinPasswordLength = pModInfo->usrmod0_min_passwd_len;
        NetApiBufferFree((LPBYTE)pModInfo);
    }

    // Load the parameters
    hwndControl = GetDlgItem(hwndDlg, CID_UserTab_New_EB_Username);
    if (hwndControl)
    {
        GetWindowTextW(
            hwndControl,
            pNuParams->pszLogonName, 
            (sizeof(pNuParams->pszLogonName)/sizeof(WCHAR)) - 1);
    }

    hwndControl = GetDlgItem(hwndDlg, CID_UserTab_New_EB_Fullname);
    if (hwndControl)
    {
        GetWindowTextW(
            hwndControl,
            pNuParams->pszFullName,  
            (sizeof(pNuParams->pszFullName)/sizeof(WCHAR)) - 1);
    }

    hwndControl = GetDlgItem(hwndDlg, CID_UserTab_New_EB_Password1);

    //gangz
    //For secure password bug .Net 754400
    SafeWipePasswordBuf(pNuParams->pszPassword1 );
    SafeWipePasswordBuf(pNuParams->pszPassword2 );
    if (hwndControl)
    {
        GetWindowTextW(
            hwndControl,
            pNuParams->pszPassword1, 
            (sizeof(pNuParams->pszPassword1)/sizeof(WCHAR)) - 1);
    }
     
    hwndControl = GetDlgItem(hwndDlg, CID_UserTab_New_EB_Password2);
    if (hwndControl)
    {
        GetWindowTextW(
            hwndControl,
            pNuParams->pszPassword2, 
            (sizeof(pNuParams->pszPassword2)/sizeof(WCHAR)) - 1);
    }

    do
    {
        bOk = TRUE;
    
        // Verify that we have a login name
        dwLength = wcslen(pNuParams->pszLogonName);
        if (dwLength < 1) 
        {
            pNuParams->dwErrorCode = ERR_LOGON_NAME_TOO_SMALL;
            bOk = FALSE;
            break;
        }
    
        // Verify the minimum password length
        dwLength = wcslen(pNuParams->pszPassword1);
        if (dwLength < dwMinPasswordLength) 
        {
            pNuParams->dwErrorCode = ERR_PASSWORD_TOO_SMALL;
            bOk = FALSE;
            break;
        }
        
        // Verify the passwords was entered correctly
        if (wcscmp(pNuParams->pszPassword1, pNuParams->pszPassword2)) 
        {
            pNuParams->dwErrorCode = ERR_PASSWORD_MISMATCH;
            bOk = FALSE;
            break;
        }


        // For .Net 660285
        // Give warning if the password has been changed
        // for .Net 691639, the password change warning dialog won't pop up when creating new users. gangz
        //
        if ( !pNuParams->bNewUser  &&
                wcscmp(pszDummyPassword, pNuParams->pszPassword1) )
        {
            BOOL fChange = FALSE;
            DWORD dwErr = NO_ERROR;

            dwErr = WarnPasswordChange( &fChange );
            if( NO_ERROR != dwErr )
            {
                break;
            }

            bOk = fChange;
            if( !bOk )
            {
                pNuParams->dwErrorCode = ERROR_CAN_NOT_COMPLETE;
            }
        }
        
        
    } while (FALSE);

    // Cleanup
    {
        if (!bOk) 
        {
           //reset password buffer so that other know password is not set yet.
           //
           SafeWipePasswordBuf(
                pNuParams->pszPassword1);
                
            SafeWipePasswordBuf(
                pNuParams->pszPassword2);
        }
    }
    
    // Keep the password field in encrypted status to be logic safe
    // Even it is wiped out
    SafeEncodePasswordBuf( pNuParams->pszPassword1 );
    SafeEncodePasswordBuf( pNuParams->pszPassword2 );
    
    return bOk;
}

//
// Initialize the callback properties of the given user
//
//Passwords are encrypted when passing in
DWORD 
UserTabLoadUserProps (
    IN RASSRV_USER_PARAMS * pParams) 
{
    PWCHAR pszName;
    DWORD dwErr, dwSize; 
    PWCHAR pszNumber;

    if (!pParams)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // If this is a new user, default to user specified callback 
    // (convienience mode)
    if (!pParams->hUser) 
    {
        SafeWipePasswordBuf( pParams->pszPassword1);
        SafeWipePasswordBuf( pParams->pszPassword2);

        ZeroMemory(pParams, sizeof(*pParams));

        SafeEncodePasswordBuf( pParams->pszPassword1);
        SafeEncodePasswordBuf( pParams->pszPassword2);

        pParams->bNone = TRUE;
        pParams->bCaller = FALSE;
        pParams->bAdmin = FALSE;
    }

    // Otherwise, load the user parameters from the user database
    else 
    {
        pParams->bCanceled = FALSE;
        dwSize = sizeof(pParams->pszFullName)/sizeof(pParams->pszFullName[0]);
        usrGetFullName (pParams->hUser, pParams->pszFullName, &dwSize);
        usrGetName(pParams->hUser, &pszName);
        lstrcpynW(
            pParams->pszLogonName, 
            pszName, 
            sizeof(pParams->pszLogonName) / sizeof(WCHAR));

        SafeWipePasswordBuf( pParams->pszPassword1);
        SafeWipePasswordBuf( pParams->pszPassword2);

        lstrcpynW(
            pParams->pszPassword1, 
            pszDummyPassword,
            sizeof(pParams->pszPassword1) / sizeof(WCHAR));
        lstrcpynW(
            pParams->pszPassword2, 
            pszDummyPassword,
            sizeof(pParams->pszPassword2) / sizeof(WCHAR));

        SafeEncodePasswordBuf( pParams->pszPassword1);
        SafeEncodePasswordBuf( pParams->pszPassword2);

        dwErr = usrGetCallback(
                    pParams->hUser, 
                    &pParams->bAdmin, 
                    &pParams->bCaller);
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }

        dwErr = usrGetCallbackNumber(pParams->hUser, &pszNumber);
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
        lstrcpynW(
            pParams->pszNumber, 
            pszNumber,
            sizeof(pParams->pszNumber) / sizeof(WCHAR));
    }

    return NO_ERROR;
}

//
// Commit the call back properties of the given user. 
//
DWORD 
UserTabSaveCallbackProps (
    IN RASSRV_USER_PARAMS * pParams) 
{
    if (!pParams)
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    // If we have a valid handle to the user, set his/her
    // properties
    if (pParams->hUser) 
    {
        pParams->bNone = 
            (pParams->bCaller == FALSE && pParams->bAdmin == FALSE);
        
        // Set the enabling and number
        usrEnableCallback(
            pParams->hUser, 
            pParams->bNone, 
            pParams->bCaller, 
            pParams->bAdmin);
            
        if (pParams->bAdmin)
        {
            usrSetCallbackNumber(pParams->hUser, pParams->pszNumber);
        }
    }
        
    return NO_ERROR;
}

// Commit the parameters of the given user.  If pOrig is non-null, then all
// fields of pParams will be compare against pOrig and only those that have changed
// will be committed. (optimization)
//
//passwords in the input structure are encoded
DWORD 
UserTabSaveUserProps (
    IN RASSRV_USER_PARAMS * pParams, 
    IN RASSRV_USER_PARAMS * pOrig, 
    IN PBOOL pbChanged) 
{
    if (!pParams || !pOrig || !pbChanged)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pbChanged = FALSE;
    
    // Commit the full name if changed
    if (wcscmp(pParams->pszFullName, pOrig->pszFullName)) 
    {
        usrSetFullName(pParams->hUser, pParams->pszFullName);
        *pbChanged = TRUE;
    }

    // Commit the password if changed
    SafeDecodePasswordBuf(pParams->pszPassword1);
    
    if (wcscmp(pParams->pszPassword1, pszDummyPassword))
    {
        usrSetPassword(pParams->hUser, pParams->pszPassword1);
    }
    SafeEncodePasswordBuf(pParams->pszPassword1);
        
    UserTabSaveCallbackProps(pParams);
    return NO_ERROR;
}

DWORD
UserTabCallbackApply(
    IN HWND hwndDlg)
{
    RASSRV_USER_PARAMS * pParams = NULL;
    LONG dwResult = PSNRET_NOERROR;
    HWND hwndControl = NULL;

    pParams = (RASSRV_USER_PARAMS *)
        GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    hwndControl = GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_No);
    if (hwndControl)
    {
        pParams->bNone = (BOOL)
            SendMessage(
                hwndControl,
                BM_GETCHECK,
                0,
                0);
    }
    
    hwndControl = GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_Caller);
    if (hwndControl)
    {
        pParams->bCaller = (BOOL)
            SendMessage(
                hwndControl,
                BM_GETCHECK,
                0,
                0);
    }
     
    hwndControl = GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_Admin);
    if (hwndControl)
    {
        pParams->bAdmin = (BOOL)
            SendMessage(
                hwndControl,
                BM_GETCHECK,
                0,
                0);
    }
                
    if (pParams->bAdmin) 
    {
        hwndControl = GetDlgItem(hwndDlg,CID_UserTab_Callback_EB_Number);
        if (hwndControl)
        {
            GetWindowTextW(
                hwndControl, 
                pParams->pszNumber, 
                MAX_PHONE_NUMBER_LEN);
        }

        // If admin callback was set, but no admin callback number was set,
        // then popup an error and don't to refuse the apply
        //
        if (wcslen(pParams->pszNumber) == 0) 
        {
            UserTabDisplayError(hwndDlg, ERR_CALLBACK_NUM_REQUIRED);
            PropSheet_SetCurSel ( GetParent(hwndDlg), hwndDlg, 0 );
            dwResult = PSNRET_INVALID;
        }
    }                                
    
    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, dwResult);
    return TRUE;
}

//
// Dialog procedure that implements getting callback properties 
//
INT_PTR 
CALLBACK 
UserTabCallbackDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam) 
{
    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            PWCHAR lpzNumber, lpzName;
            HWND hwndControl = NULL;
            HWND hwCb = GetDlgItem(hwndDlg, CID_UserTab_Callback_EB_Number);
            RASSRV_USER_PARAMS * pu = 
                (RASSRV_USER_PARAMS *)(((PROPSHEETPAGE*)lParam)->lParam);
            
            // Initialize
            if (hwCb)
            {
                SendMessage(
                    hwCb, 
                    EM_SETLIMITTEXT, 
                    sizeof(pu->pszNumber)/2 - 1, 0);
            }
                
            SetWindowLongPtr(
                hwndDlg, 
                GWLP_USERDATA, 
                (LONG_PTR)pu);
            
            // Display the callback properties
            if (!pu->bAdmin && !pu->bCaller) 
            {
                hwndControl = GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_No);
                if (hwndControl)
                {
                    SendMessage(
                        hwndControl,
                        BM_SETCHECK,BST_CHECKED,
                        0);
                        
                    SetFocus(
                        hwndControl);
                }
            }
            else if (pu->bCaller) 
            {
                hwndControl = GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_Caller);
                if (hwndControl)
                {
                    SendMessage(
                        hwndControl,
                        BM_SETCHECK,BST_CHECKED,
                        0);
                        
                    SetFocus(
                        hwndControl);
                }
            }
            else 
            {
                hwndControl = GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_Admin);
                if (hwndControl)
                {
                    SendMessage(
                        hwndControl,
                        BM_SETCHECK,BST_CHECKED,
                        0);
                    
                    SetFocus(
                        hwndControl);
                }
            }
            
            SetWindowTextW(hwCb, pu->pszNumber);
            EnableWindow(hwCb, !!pu->bAdmin);
        }
        return TRUE;

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmCallback);
            break;
        }

        case WM_DESTROY:                           
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);
            break;
        
        case WM_NOTIFY:
            {
                NMHDR* pNotifyData;
                NM_LISTVIEW* pLvNotifyData;
    
                pNotifyData = (NMHDR*)lParam;
                switch (pNotifyData->code) 
                {
                    // The property sheet apply button was pressed
                    case PSN_APPLY:
                        return UserTabCallbackApply(hwndDlg);
                        break;
                        
                    // The property sheet cancel was pressed
                    case PSN_RESET:                    
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                        break;
               }
           }
           break;
           
        case WM_COMMAND:
            switch (wParam) 
            {
                case CID_UserTab_Callback_RB_No:
                case CID_UserTab_Callback_RB_Caller:
                case CID_UserTab_Callback_RB_Admin:
                {
                    HWND hwndNumber = NULL;
                    HWND hwndAdmin = NULL;

                    hwndNumber = 
                        GetDlgItem(hwndDlg, CID_UserTab_Callback_EB_Number);

                    hwndAdmin = 
                        GetDlgItem(hwndDlg, CID_UserTab_Callback_RB_Admin);
                        
                    if (hwndNumber && hwndAdmin)
                    {
                        EnableWindow(
                            hwndNumber,
                            (BOOL) SendMessage(
                                        hwndAdmin,
                                        BM_GETCHECK, 
                                        0, 
                                        0));
                    }
                }
                break;
            }
            break;
    }

    return FALSE;
}

// 
// Initializes the user properties dialog procedure. 
//
// Return TRUE if focus is set, false otherwise.
//
BOOL
UserTabInitUserPropsDlg(
    IN HWND hwndDlg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    HWND hwLogon, hwFull, hwPass1, hwPass2, hwOk, hwCancel;
    
    RASSRV_USER_PARAMS * pu = 
        (RASSRV_USER_PARAMS *)(((PROPSHEETPAGE*)lParam)->lParam);
        
    hwLogon = GetDlgItem(
                hwndDlg, 
                CID_UserTab_New_EB_Username);
    hwFull = GetDlgItem(
                hwndDlg, 
                CID_UserTab_New_EB_Fullname);
    hwPass1 = GetDlgItem(
                hwndDlg, 
                CID_UserTab_New_EB_Password1);
    hwPass2 = GetDlgItem(
                hwndDlg, 
                CID_UserTab_New_EB_Password2);
    hwOk = GetDlgItem(
                hwndDlg, 
                IDOK);
    hwCancel = GetDlgItem(
                hwndDlg, 
                IDCANCEL);

    // Store the parameters with the window handle
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)pu);

    // Set limits to the text that can be entered
    if (hwLogon)
    {
        SendMessage(
            hwLogon, 
            EM_SETLIMITTEXT, 
            sizeof(pu->pszLogonName)/2 - 2, 
            0);
        SetWindowTextW(hwLogon, pu->pszLogonName); 
    }

    if (hwFull)
    {
        SendMessage(
            hwFull,  
            EM_SETLIMITTEXT, 
            sizeof(pu->pszFullName)/2 - 2, 
            0);
        SetWindowTextW(hwFull,  pu->pszFullName); 
    }

    if (hwPass1)
    {
        SendMessage(
            hwPass1, 
            EM_SETLIMITTEXT, 
            sizeof(pu->pszPassword1)/2 - 2 , 
            0);
        SafeDecodePasswordBuf(pu->pszPassword1);
        SetWindowTextW(hwPass1, pu->pszPassword1);
        SafeEncodePasswordBuf(pu->pszPassword1);
    }

    if (hwPass2)
    {
        SendMessage(
            hwPass2, 
            EM_SETLIMITTEXT, 
            sizeof(pu->pszPassword2)/2 - 2, 
            0);
        SafeDecodePasswordBuf(pu->pszPassword2);
        SetWindowTextW(hwPass2, pu->pszPassword2);
        SafeEncodePasswordBuf(pu->pszPassword2);
    }

    // Don't allow editing of the logon name if user already exists
    // Also, don't show the ok and cancel buttons if the user already 
    // exits (because it's a property sheet with its own buttons)
    if (pu->hUser) {
        if (hwLogon)
        {
            EnableWindow(hwLogon, FALSE);
        }

        if (hwOk)
        {
            ShowWindow(hwOk, SW_HIDE);
        }

        if (hwCancel)
        {
            ShowWindow(hwCancel, SW_HIDE);
        }
    }

    // Otherwise, we are creating a new user.  Change the window 
    // title to other than "General".  Also disable the ok button
    // since it will be enabled when a user name is typed in.
    else {
        PWCHAR pszTitle;
        pszTitle = (PWCHAR) PszLoadString (
                                Globals.hInstDll, 
                                SID_NEWUSER);
        SetWindowTextW (hwndDlg, pszTitle);
        EnableWindow(hwOk, FALSE);
    }

    return FALSE;
}
    

// Dialog procedure that implements the new user 
INT_PTR 
CALLBACK 
UserTabGenUserPropsDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam) 
{
    switch (uMsg) {
        case WM_INITDIALOG:
            return UserTabInitUserPropsDlg(hwndDlg, wParam, lParam);
            break;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmNewUser);
            break;
        }

       case WM_DESTROY:                           
            // Cleanup the work done at WM_INITDIALOG 
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);
            break;

        case WM_NOTIFY:
            {
                NMHDR* pNotifyData;
                NM_LISTVIEW* pLvNotifyData;
    
                pNotifyData = (NMHDR*)lParam;
                switch (pNotifyData->code) {
                    // The property sheet apply button was pressed
                    case PSN_APPLY:                    
                        {
                            RASSRV_USER_PARAMS * pParams;
                            pParams = (RASSRV_USER_PARAMS *)
                                GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                            if (UserTabNewUserParamsOk(hwndDlg, pParams))
                            {
                                SetWindowLongPtr(
                                    hwndDlg, 
                                    DWLP_MSGRESULT, 
                                    PSNRET_NOERROR);
                            }
                            else 
                            {
                                if( ERROR_CAN_NOT_COMPLETE !=  pParams->dwErrorCode )
                                {
                                    ErrDisplayError(
                                        hwndDlg, 
                                        pParams->dwErrorCode, 
                                        ERR_USERTAB_CATAGORY,ERR_USERDB_SUBCAT,
                                        0);
                                 }    
                                    SetWindowLongPtr(
                                        hwndDlg, 
                                        DWLP_MSGRESULT, 
                                        PSNRET_INVALID_NOCHANGEPAGE);
                                    
                            }
                        }
                        return TRUE;
                        
                    // The property sheet cancel was pressed
                    case PSN_RESET:                    
                        {
                            RASSRV_USER_PARAMS * pParams;
                            pParams = (RASSRV_USER_PARAMS *)
                                GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                            pParams->bCanceled = TRUE;
                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                            break;
                        }
               }
           }
           break;

        case WM_COMMAND:
            // Handle ok being pressed
            //
            if (wParam == IDOK) 
            {
                RASSRV_USER_PARAMS * pParams;
                pParams = (RASSRV_USER_PARAMS *)
                    GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (UserTabNewUserParamsOk(hwndDlg, pParams))
                {
                    EndDialog(hwndDlg, 1);
                }
                else
                {
                    if( ERROR_CAN_NOT_COMPLETE !=  pParams->dwErrorCode )
                    {
                        ErrDisplayError(
                            hwndDlg, 
                            pParams->dwErrorCode, 
                            ERR_USERTAB_CATAGORY,ERR_USERDB_SUBCAT,
                            0);
                    }
                }
            }

            // And cancel being pressed
            else if (wParam == IDCANCEL) 
            {
                EndDialog(hwndDlg, 0);
            }
            
            // Notice whether the user name has been updated and 
            // if so enable/disable the "Ok" button according to 
            // whether a name has been entered.
            if (HIWORD(wParam) == EN_UPDATE) 
            {
                WCHAR pszName[256];
                HWND hwndName;
                BOOL bEnable = FALSE;

                if (CID_UserTab_New_EB_Username == LOWORD(wParam))
                {
                    // Get the current name
                    hwndName = (HWND)lParam;
                    pszName[0] = (WCHAR)0;
                    GetWindowTextW(
                        hwndName, 
                        pszName, 
                        sizeof(pszName)/sizeof(WCHAR));

                    // If the length is greater than 1, enable the 
                    // ok button.  Otherwise, disable it.
                    bEnable = pszName[0] != (WCHAR)0;
                    EnableWindow(GetDlgItem(hwndDlg, IDOK), bEnable);
                }
            }
            break;
    }

    return FALSE;
}

// Brings up the new user/properties property sheet.
//
// If bNewUser is set, this is a new user, otherwise pUserParams
// contains the pertanent user information.
//
// Returns:
//      NO_ERROR on success, pUserParams will be filled in 
//      ERROR_CANCELLED if cancel was pressed
//      win32 error otherwise
//
// the password in pUserParams are assumed to be encoded
DWORD 
UserTabRaiseProperties (
    IN HWND hwndParent, 
    IN RASSRV_USER_PARAMS * pUserParams) 
{
    PROPSHEETPAGE Pages[2];
    PROPSHEETHEADER Header;
    INT_PTR ret;

    if (!pUserParams)
        return ERROR_INVALID_PARAMETER;
        
    // Initialize
    // For whistler 524777
    ZeroMemory(Pages, sizeof(Pages));
    ZeroMemory(&Header, sizeof(Header));

    // Fill in the values for the general tab
    Pages[0].dwSize      = sizeof(PROPSHEETPAGE);
    Pages[0].hInstance   = Globals.hInstDll;
    Pages[0].pszTemplate = MAKEINTRESOURCE(DID_UserTab_New);
    Pages[0].pfnDlgProc  = UserTabGenUserPropsDlgProc;
    Pages[0].pfnCallback = NULL;
    Pages[0].dwFlags     = 0;
    Pages[0].lParam      = (LPARAM)pUserParams;

    // Fill in the values for the callback tab
    Pages[1].dwSize      = sizeof(PROPSHEETPAGE);
    Pages[1].hInstance   = Globals.hInstDll;
    Pages[1].pszTemplate = MAKEINTRESOURCE(DID_UserTab_Callback);
    Pages[1].pfnDlgProc  = UserTabCallbackDialogProc;
    Pages[1].pfnCallback = NULL;
    Pages[1].dwFlags     = 0;
    Pages[1].lParam      = (LPARAM)pUserParams;

    // Fill in the values for the header
    Header.dwSize = sizeof(Header);    
    Header.dwFlags = PSH_DEFAULT       | 
                     PSH_PROPSHEETPAGE | 
                     PSH_PROPTITLE     | 
                     PSH_NOAPPLYNOW;    
    Header.hwndParent = hwndParent;
    Header.hInstance = Globals.hInstDll;    
    Header.pszCaption = (pUserParams->hUser)      ? 
                        pUserParams->pszLogonName : 
                        pUserParams->pszFullName;
    Header.nPages = sizeof(Pages) / sizeof(Pages[0]);
    Header.ppsp = Pages;
    
    // Popup the dialog box
    if ((ret = PropertySheet(&Header)) == -1)
    {
        return GetLastError();
    }

    if (pUserParams->bCanceled)
    {
        return ERROR_CANCELLED;
    }

    return NO_ERROR;
}

//
// Raises the new user dialog
//
DWORD 
UserTabRaiseNewUserDialog(
    IN HWND hwndDlg, 
    IN RASSRV_USER_PARAMS * pParams) 
{
    PROPSHEETPAGE Pages;
    INT_PTR iRet = 0;

    if (!pParams)
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    // Initialize
    ZeroMemory(&Pages, sizeof(Pages));
    Pages.lParam = (LPARAM)pParams;

    // Raise the dialog
    iRet = DialogBoxParam(
                Globals.hInstDll, 
                MAKEINTRESOURCE(DID_UserTab_New),
                hwndDlg, 
                UserTabGenUserPropsDlgProc,
                (LPARAM)&Pages);

    if (iRet == -1)
    {
        return GetLastError();
    }

    if (iRet == 0)
    {
        return ERROR_CANCELLED;
    }

    return NO_ERROR;
}

//
// Handles a request to add a new user
//
DWORD 
UserTabHandleNewUserRequest(
    IN HWND hwndDlg) 
{
    RASSRV_USER_PARAMS Params;
    DWORD dwErr = NO_ERROR, dwLength;
    HANDLE hUserDatabase = NULL;
    HWND hwndLV;

    //Encode the password area before leave the password buffer alone
    //and any future error return after this should goto directly to :done
    SafeEncodePasswordBuf(Params.pszPassword1);
    SafeEncodePasswordBuf(Params.pszPassword2);
    
    // Initializes the callback properties
    Params.hUser = NULL;
    
    //Password filds are encrypted when passing in and are encrypted when function return
    UserTabLoadUserProps (&Params);

    // Show the new user property sheet
    Params.bNewUser = TRUE;   // For .Net 691639, won't raise password change warning dialog when creating new users

    
    dwErr = UserTabRaiseNewUserDialog(hwndDlg, &Params);
    if (dwErr != NO_ERROR)
    {
        goto done;
    }

    // Flush any changes to the local user database.  These can be 
    // rolled back later with usrRollbackLocalDatabase
    RasSrvGetDatabaseHandle(hwndDlg, ID_USER_DATABASE, &hUserDatabase);


    SafeDecodePasswordBuf(Params.pszPassword1);
    // Make sure you can add the user

   dwErr = RasSrvAddUser (
                Params.pszLogonName,
                Params.pszFullName,
                Params.pszPassword1);

    SafeEncodePasswordBuf(Params.pszPassword1);
                          
    // Figure out whether the user was added successfully                          
    if (dwErr != NO_ERROR) 
    {
        switch (dwErr) {
            case ERROR_ACCESS_DENIED:
                UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_ACCESS);
                break;
                
            case ERROR_USER_EXISTS:
                UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_DUPLICATE);
                break;
                
            case ERROR_INVALID_PASSWORDNAME:
                UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_PASSWORD);
                break;
                
            default:
                UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_GENERIC);
        }
        
        goto done;
    }

    // Delete the user (since he/she will be added later when the database
    // is flushed
    RasSrvDeleteUser(Params.pszLogonName);

    // Add the user to the database
    dwErr = usrAddUser(hUserDatabase, Params.pszLogonName, &(Params.hUser)); 
    if (dwErr == ERROR_ALREADY_EXISTS) 
    {
        UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_DUPLICATE);
        goto done;
    }
    if (dwErr != NO_ERROR) 
    {
        UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_GENERIC);
        goto done;
    }

    // Commit the parameters of this user
    if (wcslen(Params.pszFullName) > 0)
    {
        usrSetFullName (Params.hUser, Params.pszFullName);
    }

    SafeDecodePasswordBuf(Params.pszPassword1);
    dwLength = wcslen(Params.pszPassword1);
    if (dwLength > 0) 
    {
        usrSetPassword (Params.hUser, Params.pszPassword1);
    }
    SafeEncodePasswordBuf(Params.pszPassword1);
    
    UserTabSaveCallbackProps (&Params);

    // Delete all of the old items from the list view
    hwndLV = GetDlgItem(hwndDlg, CID_UserTab_LV_Users);
    if (hwndLV)
    {
        if (!ListView_DeleteAllItems(hwndLV)) 
        {
            UserTabDisplayError(hwndDlg, ERR_GENERIC_CODE);
            dwErr = ERR_GENERIC_CODE;
            goto done;
        }

        // Finally, restock the list view
        UserTabFillUserList(hwndLV, hUserDatabase);
    }

done:

    SafeWipePasswordBuf(Params.pszPassword1);
    SafeWipePasswordBuf(Params.pszPassword2);
    
    return dwErr;
}

DWORD 
UserTabHandleProperties(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    HANDLE hUser = NULL, hUserDatabase = NULL;
    RASSRV_USER_PARAMS Params, Orig;
    DWORD dwErr = NO_ERROR;
    BOOL bNameChanged;

    SafeEncodePasswordBuf(Params.pszPassword1);
    SafeEncodePasswordBuf(Params.pszPassword2);

    // Get a handle to the user in question
    RasSrvGetDatabaseHandle(hwndDlg, ID_USER_DATABASE, &hUserDatabase);
    dwErr = usrGetUserHandle (hUserDatabase, dwIndex, &hUser);
    if (dwErr != NO_ERROR) 
    {
        UserTabDisplayError(hwndDlg, ERR_USER_DATABASE_CORRUPT);
        goto done;
    }

    // Initializes the callback properties
    Params.hUser = hUser;

    //UserTabLoadUserProps() assume the input password is encoded and will return
    // the password encoded.
    if ((dwErr = UserTabLoadUserProps (&Params)) != NO_ERROR)
    {
        goto done;
    }

    SafeDecodePasswordBuf(Params.pszPassword1);
    SafeDecodePasswordBuf(Params.pszPassword2);
    
    CopyMemory( &Orig, &Params, sizeof(Params) );

    SafeEncodePasswordBuf(Params.pszPassword1);
    SafeEncodePasswordBuf(Params.pszPassword2);
    SafeEncodePasswordBuf(Orig.pszPassword1);
    SafeEncodePasswordBuf(Orig.pszPassword2);

    // Show the user property sheet
    Params.bNewUser = FALSE; // for .Net 691639

    //Passwords in the Params are already encoded, functions inside
    //UserTabRaiseProperties will assume it that way
    if ((dwErr = UserTabRaiseProperties(hwndDlg, &Params)) != NO_ERROR)
    {
        goto done;
    }

    // Commit any changes needed
    // passwords in the input param structures are already encoded
    // and will remain encoded when return.
    UserTabSaveUserProps(&Params, &Orig, &bNameChanged);

    // If the name changed, update the list view
    if (bNameChanged) 
    {
        LV_ITEM lvi;
        
        // the 3 is for the '(' ')' and ' '
        // like foo (foo)
        //
        WCHAR pszDispName[IC_USERFULLNAME+IC_USERNAME+3]; 
        DWORD dwSize = sizeof(pszDispName)/sizeof(pszDispName[0]);
        HWND hwndLV = GetDlgItem(hwndDlg, CID_UserTab_LV_Users);

        // Initialize the list item
        ZeroMemory(&lvi, sizeof(LV_ITEM));
        lvi.mask = LVIF_TEXT;
        lvi.iItem = dwIndex;
        lvi.pszText = pszDispName;
        usrGetDisplayName(hUser, pszDispName, &dwSize); 

        if (hwndLV)
        {
            ListView_SetItem(hwndLV, &lvi);
            ListView_RedrawItems(hwndLV, dwIndex, dwIndex);
        }
    }

done:

    SafeWipePasswordBuf(Params.pszPassword1);
    SafeWipePasswordBuf(Params.pszPassword2);
    SafeWipePasswordBuf(Orig.pszPassword1);
    SafeWipePasswordBuf(Orig.pszPassword2);
    
    return NO_ERROR;
}

//
// Handles the request to delete the user at index dwIndex
//
DWORD 
UserTabHandleDeleteUser(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    WCHAR *pszCapString, pszCaption[512];
    WCHAR *pszTitle, *pszName, pszFullName[IC_USERFULLNAME];
    HANDLE hUserDatabase = NULL, hUser = NULL;
    DWORD dwErr= NO_ERROR, dwSize = sizeof(pszFullName)/sizeof(pszFullName[0]);
    HWND hwndLV = NULL;
    INT iRet;

    // Get a handle to the user in question
    RasSrvGetDatabaseHandle(hwndDlg, ID_USER_DATABASE, &hUserDatabase);
    dwErr = usrGetUserHandle (hUserDatabase, dwIndex, &hUser);
    if (dwErr != NO_ERROR) 
    {
        UserTabDisplayError(hwndDlg, ERR_USER_DATABASE_CORRUPT);
        return dwErr;
    }
    
    if ((dwErr = usrGetName(hUser, &pszName)) != NO_ERROR)
    {
        return dwErr;
    }
    if ((dwErr = usrGetFullName(hUser, pszFullName, &dwSize)) != NO_ERROR)
    {
        return dwErr;
    }

    // Load resources
    pszCapString = 
        (PWCHAR) PszLoadString (Globals.hInstDll, WRN_DELETE_USER_PERMANENT);
    pszTitle = 
        (PWCHAR) PszLoadString (Globals.hInstDll, WRN_TITLE);

    // Format the caption
    if (wcslen(pszFullName))
        wsprintfW(pszCaption, pszCapString, pszFullName);
    else
        wsprintfW(pszCaption, pszCapString, pszName);
    
    // Advertise the warning
    iRet = MessageBox(
                hwndDlg, 
                pszCaption, 
                pszTitle, 
                MB_YESNO | MB_ICONWARNING);
    if (iRet == IDNO)
    {
        return NO_ERROR;
    }

    // Delete the user
    if ((dwErr = usrDeleteUser(hUserDatabase, dwIndex)) != NO_ERROR) 
    {
        UserTabDisplayError(hwndDlg, ERR_CANT_DELETE_USER_GENERAL);
        return dwErr;
    }

    // Remove all items from the list view
    hwndLV = GetDlgItem(hwndDlg, CID_UserTab_LV_Users);
    if (hwndLV)
    {
        if (!ListView_DeleteAllItems(hwndLV)) 
        {
            UserTabDisplayError(hwndDlg, ERR_GENERIC_CODE);
            return ERR_GENERIC_CODE;
        }

        // Finally, restock the list view
        UserTabFillUserList(hwndLV, hUserDatabase);
    }

    return NO_ERROR;
}

//
// Saves the dcc bypass setting
//
DWORD 
UserTabSaveBypassDcc(
    IN HWND hwndDlg) 
{
    HANDLE hUserDatabase = NULL;
    BOOL bBypass = FALSE;
    HWND hwndCtrl;

    // Get reference to the misc database
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_USER_DATABASE, 
        &hUserDatabase);

    hwndCtrl = GetDlgItem(hwndDlg, CID_UserTab_CB_BypassDcc);
    if (hwndCtrl != NULL) 
    {
        // Get the setting of the checkbox and commit it
        bBypass = SendMessage(
                        hwndCtrl, 
                        BM_GETCHECK,
                        0,
                        0) == BST_CHECKED;
                                      
        usrSetDccBypass(hUserDatabase, bBypass);
    }
    
    return NO_ERROR;
}

//
// Handles WM_COMMAND messages on the user tab.
//
DWORD 
UserTabCommand (
    HWND hwndDlg, 
    WPARAM wParam, 
    LPARAM lParam) 
{
    DWORD dwIndex;

    dwIndex = 
        ListView_GetSelectionMark(
            GetDlgItem(hwndDlg, CID_UserTab_LV_Users));
    
    switch (wParam) {
        case CID_UserTab_PB_New:
            UserTabHandleNewUserRequest(hwndDlg);
            break;
            
        case CID_UserTab_PB_Properties:
            dwIndex = 
            UserTabHandleProperties(hwndDlg, dwIndex);
            break;
            
        case CID_UserTab_PB_Delete:
            UserTabHandleDeleteUser(hwndDlg, dwIndex);
            break;
            
        case CID_UserTab_CB_BypassDcc:
            UserTabSaveBypassDcc (hwndDlg);
            break;
            
        case CID_UserTab_PB_SwitchToMMC:
            if (RassrvWarnMMCSwitch(hwndDlg)) 
            {
                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_OK);
                RassrvLaunchMMC(RASSRVUI_USERCONSOLE);
            }    
            break;
    }

    return NO_ERROR;
}    

//
// This dialog procedure responds to messages sent to the 
// user tab.
//
INT_PTR 
CALLBACK 
UserTabDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam) 
{
    // Filter the customized list view messages
    if (ListView_OwnerHandler(
            hwndDlg, 
            uMsg, 
            wParam, 
            lParam, 
            LvDrawInfoCallback)
       )
    {
        return TRUE;
    }

    // Filter the customized ras server ui page messages. 
    // By filtering messages through here, we are able to 
    // call RasSrvGetDatabaseHandle below
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch (uMsg) 
    {
        case WM_INITDIALOG:
            return FALSE;

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmUserTab);
            break;
        }

        case WM_NOTIFY:
        {
            NMHDR* pNotifyData;
            NM_LISTVIEW* pLvNotifyData;

            pNotifyData = (NMHDR*)lParam;
            switch (pNotifyData->code) {
                //
                // Note: PSN_APPLY and PSN_CANCEL are handled 
                // by RasSrvMessageFilter
                //
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
                    if (! GetWindowLongPtr(hwndDlg, GWLP_USERDATA))
                    {
                        UserTabInitializeDialog(
                            hwndDlg, 
                            wParam, 
                            lParam);
                            
                        SetWindowLongPtr(
                            hwndDlg, 
                            GWLP_USERDATA, 
                            (LONG_PTR)1);
                    }
                    PropSheet_SetWizButtons(
                        GetParent(hwndDlg), 
                        PSWIZB_NEXT | PSWIZB_BACK);		
                    break;
                    
                // The check of an item is changing
                case LVXN_SETCHECK:
                    pLvNotifyData = (NM_LISTVIEW*)lParam;
                    UserTabHandleUserCheck(
                        hwndDlg, 
                        (DWORD)pLvNotifyData->iItem);
                    break;

                case LVXN_DBLCLK:
                    pLvNotifyData = (NM_LISTVIEW*)lParam;
                    UserTabHandleProperties(
                        hwndDlg, 
                        pLvNotifyData->iItem);
                    break;
            }
        }
        break;

        case WM_COMMAND:
            UserTabCommand (hwndDlg, wParam, lParam);
            break;

        // Cleanup the work done at WM_INITDIALOG 
        case WM_DESTROY:                           
            UserTabCleanupDialog(hwndDlg, wParam, lParam);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\utils.h ===
/*
    File    utils.h

    Defines utility declarations that facilitate the implementation of the 
    connections ras dialup server ui.

    Paul Mayfield, 9/29/97
*/

#ifndef _rassrvui_utils_h
#define _rassrvui_utils_h

#include "rassrv.h"

//
// Global flags that tag the current state of this 
// machine
//
#define RASSRVUI_MACHINE_F_Initialized  0x1
#define RASSRVUI_MACHINE_F_Server       0x2
#define RASSRVUI_MACHINE_F_Member       0x4
#define RASSRVUI_MACHINE_F_ShowIcon     0x8

//
// Defines the global variables data structure
//
typedef struct _RASSRVUI_GLOBALS 
{
    // 
    // The following should only be accessed when the
    // csLock is held.
    //
    MPR_SERVER_HANDLE hRasServer;   
    DWORD dwMachineFlags;           
    
    //
    // The following do not need to be protected by the
    // csLock as they are initialized at process attach
    // and thereafter are only read.
    //
    HINSTANCE hInstDll;             
    HANDLE hPrivateHeap;            
    LPCTSTR atmRassrvPageData;      
    LPCTSTR atmRassrvPageId;        
    DWORD dwErrorData;              
                                    
    //
    // Locks (some) global variables
    //
    CRITICAL_SECTION csLock;        

} RASSRVUI_GLOBALS;

extern RASSRVUI_GLOBALS Globals;

// ======================================
// Methods to operate on global variables
// ======================================

#define GBL_LOCK EnterCriticalSection(&(Globals.csLock))
#define GBL_UNLOCK LeaveCriticalSection(&(Globals.csLock))

//
// Initializes the global variables
//
DWORD 
gblInit(
    IN  HINSTANCE hInstDll,
    OUT RASSRVUI_GLOBALS * Globs);

//
// Loads the machine flags         
//
DWORD 
gblLoadMachineFlags(
    IN RASSRVUI_GLOBALS * Globs);

//
// Frees resources held by global variables
//
DWORD 
gblCleanup(
    IN RASSRVUI_GLOBALS * Globs);

//
// Establishes communication with the ras server if
// not already established
//
DWORD 
gblConnectToRasServer();    

/* Enhanced list view callback to report drawing information.  'HwndLv' is
** the handle of the list view control.  'DwItem' is the index of the item
** being drawn.
**
** Returns the address of standard draw information.
*/
LVXDRAWINFO*
LvDrawInfoCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

// ============================================================
// ============================================================
// Special purpose ras server functions.
// ============================================================
// ============================================================

//
// Allocates and Zeros memory.  Returns pointer to allocated memory
// or NULL if ERROR_NOT_ENOUGH_MEMORY
//
PVOID 
RassrvAlloc (
    IN DWORD dwSize, 
    IN BOOL bZero);
    
VOID 
RassrvFree(
    IN PVOID pvBuf);

//
// Adds a new user to the system local user database.
//
DWORD 
RasSrvAddUser (
    IN PWCHAR pszUserLogonName,
    IN PWCHAR pszUserComment,
    IN PWCHAR pszUserPassword);

//
// Deletes a user from the system local user datbase
//
DWORD 
RasSrvDeleteUser(
    IN PWCHAR pszUserLogonName);

//
// Changes the full name and password of a user.  If 
// either of pszFullName or pszPassword is null, it is
// ignored.
//
DWORD 
RasSrvEditUser (
    IN PWCHAR pszLogonName,
    IN OPTIONAL PWCHAR pszFullName,
    IN OPTIONAL PWCHAR pszPassword);

//
// Warns the user that he/she is about to swith to mmc
//
BOOL 
RassrvWarnMMCSwitch(
    IN HWND hwndDlg);

//
// Launches the given console in MMC
//
DWORD 
RassrvLaunchMMC(
    IN DWORD dwConsoleId);

//
// Returns RASSRVUI_MACHINE_F_* values for the current machine
//
DWORD 
RasSrvGetMachineFlags(
    OUT LPDWORD lpdwFlags);

//
// Manipulate the enabling/disabling of multilink
//
DWORD 
RasSrvGetMultilink(
    OUT BOOL * bEnabled);
    
DWORD 
RasSrvSetMultilink(
    IN BOOL bEnable);

//
// Manipulate the showing of ras server icons in the task bar
//
DWORD 
RasSrvGetIconShow(
    OUT BOOL * pbEnabled);
    
DWORD 
RasSrvSetIconShow(
    IN BOOL bEnable);

// 
// Set the logging level
//
DWORD
RasSrvSetLogLevel(
    IN DWORD dwLevel);

//
// Manipulate the forcing of data and password encryption'
//
DWORD 
RasSrvGetEncryption(
    OUT BOOL * pbEncrypted);
    
DWORD 
RasSrvSetEncryption(
    IN BOOL bEncrypted);

// Displays context sensitive help
DWORD 
RasSrvHelp(
    IN HWND hwndDlg,          // Dialog needing help
    IN UINT uMsg,             // Help message
    IN WPARAM wParam,         // parameter
    IN LPARAM lParam,         // parameter
    IN const DWORD* pdwMap);  // map control id to help id

//
// Registry helper functions. All string buffers must be 
// at least 256 chars long.
//
DWORD 
RassrvRegGetDw(
    DWORD * pdwVal, 
    DWORD dwDefault, 
    const PWCHAR pszKeyName, 
    const PWCHAR pszValueName);
    
DWORD 
RassrvRegSetDw(
    DWORD dwVal, 
    const PWCHAR pszKeyName, 
    const PWCHAR pszValueName);

DWORD 
RassrvRegGetDwEx(
    DWORD * pdwVal, 
    DWORD dwDefault, 
    const PWCHAR pszKeyName, 
    const PWCHAR pszValueName,
    IN BOOL bCreate);
    
DWORD 
RassrvRegSetDwEx(
    IN DWORD dwFlag, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName, 
    IN BOOL bCreate);
    
DWORD 
RassrvRegGetStr(
    PWCHAR pszBuf, 
    PWCHAR pszDefault, 
    const PWCHAR pszKeyName, 
    const PWCHAR pszValueName);
    
DWORD 
RassrvRegSetStr(
    PWCHAR pszStr, 
    const PWCHAR pszKeyName, 
    const PWCHAR pszValueName);

// Api shows whatever ui is neccessary to inform the user that 
// he/she should wait while services are started.
DWORD 
RasSrvShowServiceWait( 
    IN HINSTANCE hInst, 
    IN HWND hwndParent, 
    OUT HANDLE * phData);
                             
DWORD 
RasSrvFinishServiceWait (
    IN HANDLE hData);

// Pops up a warning with the given parent window and reboots
// windows
DWORD 
RasSrvReboot(
    IN HWND hwndParent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\utils.c ===
/*
    File    utils.c

    Contains common utilities for the ras dialup server ui.

    Paul Mayfield, 9/30/97
*/

#include "rassrv.h"

// Remoteaccess parameters key
const WCHAR pszregRasParameters[] 
    = L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters";

// Registry key values
const WCHAR pszregServerFlags[]  = L"ServerFlags";
const WCHAR pszregShowIcon[]     = L"Rassrv_EnableIconsInTray";
const WCHAR pszregPure[]         = L"UsersConfiguredWithMMC";
const WCHAR pszregLogLevel[]        = L"LoggingFlags";

// Here is the instance of the global variables
RASSRVUI_GLOBALS Globals; 

DWORD 
gblInit(
    IN  HINSTANCE hInstDll,
    OUT RASSRVUI_GLOBALS * pGlobs) 
{
    // Clear out the memory
    ZeroMemory(pGlobs, sizeof(RASSRVUI_GLOBALS));

    // Record the module for use in future resource fuction calls.
    Globals.hInstDll = hInstDll;

    // Initialize the global variable lock
    InitializeCriticalSection(&(pGlobs->csLock));

    // Create the global heap
    pGlobs->hPrivateHeap = HeapCreate(0, 4096, 0);
    if (NULL == pGlobs->hPrivateHeap)
    {
        return GetLastError();
    }

    // Register the context ID atom for use in the Windows XxxProp calls
    // which are used to associate a context with a dialog window handle.
    Globals.atmRassrvPageData = 
        (LPCTSTR)GlobalAddAtom(TEXT("RASSRVUI_PAGE_DATA"));
    if (!Globals.atmRassrvPageData)
    {
        return GetLastError();
    }
    Globals.atmRassrvPageId = 
        (LPCTSTR)GlobalAddAtom(TEXT("RASSRVUI_PAGE_ID"));
    if (!Globals.atmRassrvPageId)
    {
        return GetLastError();
    }

    return NO_ERROR;
}

DWORD 
gblCleanup(
    IN RASSRVUI_GLOBALS * Globs) 
{
    if (Globs->hRasServer != NULL) 
    {
        MprAdminServerDisconnect(Globs->hRasServer); 
        Globs->hRasServer = NULL;
    }

    if (Globs->hPrivateHeap) 
    {
        HeapDestroy(Globs->hPrivateHeap);
    }

    GlobalDeleteAtom(LOWORD(Globals.atmRassrvPageData));
    GlobalDeleteAtom(LOWORD(Globals.atmRassrvPageId));

    DeleteCriticalSection(&(Globs->csLock));
            
    return NO_ERROR;
}

//
// Loads the machine flags         
//
DWORD 
gblLoadMachineFlags(
    IN RASSRVUI_GLOBALS * pGlobs)
{
    DWORD dwErr = NO_ERROR;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pInfo = NULL;
    BOOL bEnabled, bDefault;
    
    // If we're already initialized, there's nothing to
    // do
    //
    if (pGlobs->dwMachineFlags & RASSRVUI_MACHINE_F_Initialized)
    {
        return NO_ERROR;
    }

    do 
    {
        // Find out what kind of machine we are
        //
        dwErr = DsRoleGetPrimaryDomainInformation(
                            NULL,   
                            DsRolePrimaryDomainInfoBasic,
                            (LPBYTE *)&pInfo );

        if (dwErr != NO_ERROR) 
        {
            break;
        }

        if ((pInfo->MachineRole != DsRole_RoleStandaloneWorkstation) &&
            (pInfo->MachineRole != DsRole_RoleMemberWorkstation))
        {
            pGlobs->dwMachineFlags |= RASSRVUI_MACHINE_F_Server;
        }

        if ((pInfo->MachineRole != DsRole_RoleStandaloneWorkstation) &&
            (pInfo->MachineRole != DsRole_RoleStandaloneServer))
        {
            pGlobs->dwMachineFlags |= RASSRVUI_MACHINE_F_Member;
        }

        // Record that we've been initailized
        //
        pGlobs->dwMachineFlags |= RASSRVUI_MACHINE_F_Initialized;
        
    } while (FALSE);
    
    // Cleanup
    {
        if (pInfo)
        {
            DsRoleFreeMemory (pInfo);
        }
    }            

    return dwErr;
}

//
// Establishes communication with the ras server if
// not already established
//
DWORD 
gblConnectToRasServer() 
{
    DWORD dwErr = NO_ERROR;

    EnterCriticalSection(&(Globals.csLock));

    if (Globals.hRasServer == NULL) 
    {
        dwErr = MprAdminServerConnect(NULL, &Globals.hRasServer);
    }

    LeaveCriticalSection(&(Globals.csLock));

    return dwErr;
}

/* Enhanced list view callback to report drawing information.  'HwndLv' is
** the handle of the list view control.  'DwItem' is the index of the item
** being drawn.
**
** Returns the address of the draw information.
*/
LVXDRAWINFO*
LvDrawInfoCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )
{
    /* The enhanced list view is used only to get the "wide selection bar"
    ** feature so our option list is not very interesting.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info = { 1, 0, 0, { 0 } };

    return &info;
}

//
// Allocates memory.  If bZero is TRUE, it also zeros the memory.  
//
PVOID 
RassrvAlloc (
    IN DWORD dwSize, 
    IN BOOL bZero) 
{
    PVOID pvRet = NULL;
    HANDLE hHeap = NULL;
    
    hHeap = 
        (Globals.hPrivateHeap) ? Globals.hPrivateHeap : GetProcessHeap();
        
    pvRet = HeapAlloc(
                hHeap, 
                (bZero) ? HEAP_ZERO_MEMORY: 0,
                dwSize);
    
    return pvRet;
}

//
// Frees memory allocated by RassrvAlloc
//
VOID 
RassrvFree (
    IN PVOID pvBuf) 
{
    PVOID pvRet;
    HANDLE hHeap;
    
    hHeap = 
        (Globals.hPrivateHeap) ? Globals.hPrivateHeap : GetProcessHeap();
    
    if (pvBuf)
    {
        HeapFree(hHeap, 0, pvBuf);
    }
}        

//
// Adds a user to the local machine
//
DWORD 
RasSrvAddUser (
    IN PWCHAR pszUserLogonName,
    IN PWCHAR pszUserComment,
    IN PWCHAR pszUserPassword) 
{
    NET_API_STATUS nStatus;
    WCHAR pszDomainUser[1024];
    WCHAR pszCompName[1024];
    LOCALGROUP_MEMBERS_INFO_3 meminfo;
    DWORD dwSize = 1024, dwErr;
    USER_INFO_2 * pUser2;
    RAS_USER_0 UserInfo;

    // Initialize the base user information
    USER_INFO_1 User = 
    {
        pszUserLogonName,
        pszUserPassword,
        0,
        USER_PRIV_USER,
        L"",
        L"",
        UF_SCRIPT | UF_DONT_EXPIRE_PASSWD | UF_NORMAL_ACCOUNT,
        L""
    };

    // Add the user
    nStatus = NetUserAdd(
                NULL,
                1,
                (LPBYTE)&User,
                NULL);

    // If the user wasn't added, find out why
    if (nStatus != NERR_Success) 
    {
        switch (nStatus) 
        {
            case ERROR_ACCESS_DENIED:
                return ERROR_ACCESS_DENIED;
                
            case NERR_UserExists:
                return ERROR_USER_EXISTS;
                
            case NERR_PasswordTooShort:
                return ERROR_INVALID_PASSWORDNAME;
                
            case NERR_InvalidComputer:   
            case NERR_NotPrimary:        
            case NERR_GroupExists:
            default:
                return ERROR_CAN_NOT_COMPLETE;
        }
    }

    // Now that the user is added, add the user's full name
    nStatus = NetUserGetInfo(NULL, pszUserLogonName, 2, (LPBYTE*)&pUser2);
    if (nStatus == NERR_Success) 
    {
        // Modify the full name in the structure
        pUser2->usri2_full_name = pszUserComment;
        NetUserSetInfo(NULL, pszUserLogonName, 2, (LPBYTE)pUser2, NULL);
        NetApiBufferFree((LPBYTE)pUser2);
    }

    return NO_ERROR;
}

//
// Deletes a user from the system local user datbase
//
DWORD 
RasSrvDeleteUser(
    PWCHAR pszUserLogonName) 
{
    NET_API_STATUS nStatus;
    
    // Delete the user and return the status code.  If the
    // specified user is not in the user database, consider
    // it a success
    nStatus = NetUserDel(NULL, pszUserLogonName);
    if (nStatus != NERR_Success) 
    {
        switch (nStatus) 
        {
            case ERROR_ACCESS_DENIED:
                return ERROR_ACCESS_DENIED;
                
            case NERR_UserNotFound:
                return NO_ERROR;
        }
        return nStatus;
    }

    return NO_ERROR;
}

//
// Changes the full name and password of a user.  If 
// either of pszFullName or pszPassword is null, it is
// ignored.
//
DWORD 
RasSrvEditUser (
    IN PWCHAR pszLogonName,
    IN OPTIONAL PWCHAR pszFullName,
    IN OPTIONAL PWCHAR pszPassword)
{
    NET_API_STATUS nStatus;
    DWORD dwSize = 1024, dwErr = NO_ERROR, dwParamErr;
    USER_INFO_2 * pUser2;

    // if nothing to set, return
    if (!pszFullName && !pszPassword)
    {
        return NO_ERROR;
    }

    // First, get this user's data so that we can manipulate it.
    //
    nStatus = NetUserGetInfo(
                NULL,
                pszLogonName,
                2,
                (LPBYTE*)(&pUser2));
    if (nStatus != NERR_Success)
    {
        return nStatus;
    }

    dwErr = NO_ERROR;
    do 
    {
        // Fill in the blanks accordingly
        if (pszFullName)
        {
            pUser2->usri2_full_name = pszFullName;
        }
            
        if (pszPassword)
        {
            pUser2->usri2_password = pszPassword;
        }

        // Add the user
        nStatus = NetUserSetInfo(
                        NULL,           // server name
                        pszLogonName,   // user name
                        2,              // level
                        (LPBYTE)pUser2, // buf
                        &dwParamErr);   // param error
        if (nStatus != NERR_Success)
        {
            dwErr = nStatus;
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        NetApiBufferFree(pUser2);
    }

    return dwErr;
}

// Returns whether a dword registry value was set or not.  If the named 
// value does not exist, the value of bDefault is assigned.
DWORD 
RassrvRegGetDwEx(
    IN DWORD * lpdwFlag, 
    IN DWORD dwDefault, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName, 
    IN BOOL bCreate) 
{
    DWORD dwErr, dwVal, dwType = REG_DWORD, dwSize = sizeof(DWORD);
    HKEY hKey = NULL;

    if (!lpdwFlag)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        if (bCreate)
        {
            DWORD dwDisposition;
            
            dwErr = RegCreateKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pszKeyName,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hKey,
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }
        else
        {
            // Open the registry key
            dwErr = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pszKeyName,
                        0,
                        KEY_READ,
                        &hKey);
            if (dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }
        
        // Read the value
        dwErr = RegQueryValueExW(
                    hKey,
                    pszValueName,
                    0,
                    &dwType,
                    (BYTE *)&dwVal,
                    &dwSize);
        if (dwErr != ERROR_SUCCESS)
        {
            dwErr = NO_ERROR;
            dwVal = dwDefault;
        }

        // Return the value read
        *lpdwFlag = dwVal;
        
    } while (FALSE);
    
    // Cleanup
    {
        if (hKey) 
        {
            RegCloseKey(hKey);
        }
    }
    
    return dwErr;
}


// Returns whether a dword registry value was set or not.  If the named 
// value does not exist, the value of bDefault is assigned.
DWORD 
RassrvRegGetDw(
    IN DWORD * lpdwFlag, 
    IN DWORD dwDefault, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName) 
{
    return RassrvRegGetDwEx(
                lpdwFlag, 
                dwDefault, 
                pszKeyName, 
                pszValueName, 
                FALSE);
}

//
// Sets a dword registry value.  If the named value does not exist, 
// it is automatically created.
//
DWORD 
RassrvRegSetDwEx(
    IN DWORD dwFlag, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName, 
    IN BOOL bCreate) 
{
    DWORD dwErr = NO_ERROR, dwVal, dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    HKEY hKey = NULL;

    dwVal = dwFlag;

    do 
    {
        if (bCreate)
        {
            DWORD dwDisposition;
            
            dwErr = RegCreateKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pszKeyName,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hKey,
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }
        else
        {
            // Open the registry key
            dwErr = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pszKeyName,
                        0,
                        KEY_WRITE,
                        &hKey);
            if (dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }

        // Set the value
        dwErr = RegSetValueExW(
                    hKey,
                    pszValueName,
                    0,
                    dwType,
                    (CONST BYTE *)&dwVal,
                    dwSize);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (hKey) 
        {
            RegCloseKey(hKey);
        }
    }
    
    return dwErr;
}

DWORD 
RassrvRegSetDw(
    IN DWORD dwFlag, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName)
{
    return RassrvRegSetDwEx(dwFlag, pszKeyName, pszValueName, FALSE);
}

//
// Warns the user that we are about to switch to MMC returning TRUE if 
// user agrees to this and FALSE otherwise
//
BOOL 
RassrvWarnMMCSwitch(
    IN HWND hwndDlg) 
{
    PWCHAR pszWarning, pszTitle;

    pszWarning = 
        (PWCHAR) PszLoadString(Globals.hInstDll, WRN_SWITCHING_TO_MMC);
    pszTitle = 
        (PWCHAR) PszLoadString(Globals.hInstDll, WRN_TITLE);
    
    if (MessageBox(
            hwndDlg, 
            pszWarning, 
            pszTitle, 
            MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
    {            
        return TRUE;
    }
    
    return FALSE;
}

//
// Switches to mmc based on the console identifier passed in
//
DWORD 
RassrvLaunchMMC (
    IN DWORD dwConsoleId) 
{
    STARTUPINFOA startupinfo;
    PROCESS_INFORMATION procinfo;
    CHAR * pszConsole;
    CHAR pszBuf[1024], pszDir[1024];
    BOOL bSuccess = FALSE;		
    DWORD dwErr = NO_ERROR;

    // Set the command line accordingly
    switch (dwConsoleId) 
    {
        case RASSRVUI_NETWORKCONSOLE:
            pszConsole = "netmgmt.msc";
            break;

        case RASSRVUI_USERCONSOLE:
            pszConsole = NULL;
            break;

        case RASSRVUI_SERVICESCONSOLE:
            pszConsole = "compmgmt.msc";
            break;

        case RASSRVUI_MPRCONSOLE:
        default:
            pszConsole = "rrasmgmt.msc";
            break;
    }

    if (pszConsole) 
    {
        GetSystemDirectoryA (pszDir, sizeof(pszDir));
        sprintf (pszBuf, "mmc %s\\%s", pszDir, pszConsole);
    }
    else
    {
        strcpy (pszBuf, "mmc.exe");
    }
            
    // Launch MMC
    ZeroMemory(&startupinfo, sizeof(startupinfo));
    startupinfo.cb = sizeof(startupinfo);

   // for .Net 704458, close process and thread handle
   bSuccess = CreateProcessA(
        NULL,                   // name of executable module 
        pszBuf,                 // command line string
        NULL,                   // process security attributes 
        NULL,                   // thread security attributes 
        FALSE,                  // handle inheritance flag 
        NORMAL_PRIORITY_CLASS,  // creation flags 
        NULL,                   // new environment block 
        NULL,                   // current directory name 
        &startupinfo,           // STARTUPINFO 
        &procinfo);             // PROCESS_INFORMATION 

   if( bSuccess )
   {
	 CloseHandle( procinfo.hThread);
	 CloseHandle( procinfo.hProcess);
   }
   else
   {
        dwErr = GetLastError();
   }


   return dwErr;

}

//
// Retrieve a string from the registry
//
DWORD 
RassrvRegGetStr(
    OUT PWCHAR pszBuf, 
    IN  PWCHAR pszDefault, 
    IN  CONST PWCHAR pszKeyName, 
    IN  CONST PWCHAR pszValueName) 
{
    DWORD dwErr = NO_ERROR, dwVal, dwType = REG_SZ, dwSize = 512;
    HKEY hKey = NULL;

    do
    {
        // Open the registry key
        dwErr = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    pszKeyName,
                    0,
                    KEY_READ,
                    &hKey);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }

        // Read the value
        dwErr = RegQueryValueExW(
                    hKey,
                    pszValueName,
                    0,
                    &dwType,
                    (BYTE *)pszBuf,
                    &dwSize);
        if (dwErr != ERROR_SUCCESS) 
        {
            dwErr = NO_ERROR;
            wcscpy(pszBuf, pszDefault);
        }
        
    } while (FALSE);
    
    // Cleanup
    {
        if (hKey) 
        {
            RegCloseKey(hKey);
        }
    }
    
    return NO_ERROR;
}

//
// Save a string to the registry
//
DWORD 
RassrvRegSetStr(
    IN PWCHAR pszStr, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName) 
{
    DWORD dwErr = NO_ERROR, dwVal, dwType = REG_SZ, dwSize;
    HKEY hKey = NULL;

    dwSize = wcslen(pszStr)*sizeof(WCHAR) + sizeof(WCHAR);

    do
    {
        // Open the registry key
        dwErr = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    pszKeyName,
                    0,
                    KEY_WRITE,
                    &hKey);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }

        // Set the value
        dwErr = RegSetValueExW(
                    hKey,
                    pszValueName,
                    0,
                    dwType,
                    (CONST BYTE *)pszStr,
                    dwSize);

        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }
            
    } while (FALSE);

    // Cleanup
    {
        if (hKey) 
        {
            RegCloseKey(hKey);
        }
    }
    
    return dwErr;
}

//
// Gets the machine flags
//
DWORD 
RasSrvGetMachineFlags(
    OUT LPDWORD lpdwFlags)
{
    GBL_LOCK;

    gblLoadMachineFlags(&Globals);
    *lpdwFlags = Globals.dwMachineFlags;

    GBL_UNLOCK;

    return NO_ERROR;
}

//
// Get multilink status
//
DWORD 
RasSrvGetMultilink(
    OUT BOOL * pbEnabled) 
{
    DWORD dwFlags = PPPCFG_NegotiateMultilink;

    if (!pbEnabled)
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    // Read the flags
    RassrvRegGetDw(
        &dwFlags, 
        PPPCFG_NegotiateMultilink, 
        (const PWCHAR)pszregRasParameters, 
        (const PWCHAR)pszregServerFlags);

    // Assign the enable state accordingly
    if (dwFlags & PPPCFG_NegotiateMultilink)
    {
        *pbEnabled = TRUE;
    }
    else
    {
        *pbEnabled = FALSE;
    }

    return NO_ERROR;
}

//
// Private internal function that enables/disables multilink
//
DWORD 
RasSrvSetMultilink(
    IN BOOL bEnable) 
{
    DWORD dwFlags = PPPCFG_NegotiateMultilink;

    // Read the flags
    RassrvRegGetDw(
        &dwFlags, 
        PPPCFG_NegotiateMultilink, 
        (const PWCHAR)pszregRasParameters, 
        (const PWCHAR)pszregServerFlags);

    // Assign the enable state accordingly
    if (bEnable)
    {
        dwFlags |= PPPCFG_NegotiateMultilink;
    }
    else
    {
        dwFlags &= ~PPPCFG_NegotiateMultilink;
    }

    // Set the flags
    RassrvRegSetDw(
        dwFlags, 
        (CONST PWCHAR)pszregRasParameters, 
        (CONST PWCHAR)pszregServerFlags);

    return NO_ERROR;
}

//
// Initialize the show icon setting
//
DWORD 
RasSrvGetIconShow(
    OUT BOOL * pbEnabled)
{
    DWORD dwErr = NO_ERROR, dwFlags = 0;
    BOOL bDefault = TRUE;

    // Get machine flags
    //
    dwErr = RasSrvGetMachineFlags(&dwFlags);
    if (dwErr != NO_ERROR)
    {
        *pbEnabled = FALSE;
        return dwErr;
    }

    // Always off for member server
    //
    if ((dwFlags & RASSRVUI_MACHINE_F_Server) &&
        (dwFlags & RASSRVUI_MACHINE_F_Member))
    {
        *pbEnabled = FALSE;
        return NO_ERROR;
    }

    // Set default
    //
    if (dwFlags & RASSRVUI_MACHINE_F_Server)
    {
        bDefault = FALSE;
    }
    else
    {
        bDefault = TRUE;
    }

    // Load the machine flags and return accordingly
    //
    *pbEnabled = bDefault;
    dwErr = RassrvRegGetDw(
                pbEnabled, 
                bDefault, 
                (CONST PWCHAR)pszregRasParameters,
                (CONST PWCHAR)pszregShowIcon);

    return dwErr;
}

//
// Save the show icon setting
//
DWORD 
RasSrvSetIconShow(
    IN BOOL bEnable) 
{
    return RassrvRegSetDw(
                bEnable, 
                (CONST PWCHAR)pszregRasParameters,
                (CONST PWCHAR)pszregShowIcon);
}

// 
// Save the log level
//
DWORD
RasSrvSetLogLevel(
    IN DWORD dwLevel)
{
    return RassrvRegSetDw(
                dwLevel, 
                (CONST PWCHAR)pszregRasParameters,
                (CONST PWCHAR)pszregLogLevel);
}

// Calls WinHelp to popup context sensitive help.  'pdwMap' is an array
// of control-ID help-ID pairs terminated with a 0,0 pair.  'UnMsg' is
// WM_HELP or WM_CONTEXTMENU indicating the message received requesting
// help.  'Wparam' and 'lparam' are the parameters of the message received
// requesting help.
DWORD 
RasSrvHelp (
    IN HWND hwndDlg,          
    IN UINT unMsg,             
    IN WPARAM wparam,         
    IN LPARAM lparam,         
    IN const DWORD* pdwMap)   
{
    HWND hwnd;
    UINT unType;
    TCHAR pszHelpFile[] = TEXT("Netcfg.hlp");

    // Validate parameters
    if (! (unMsg==WM_HELP || unMsg==WM_CONTEXTMENU))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // If no map is provided, no help will show
    if (!pdwMap)
    {
        return NO_ERROR;
    }
        
    // If an actual help topic is request...
    if (unMsg == WM_HELP) 
    {
        LPHELPINFO p = (LPHELPINFO )lparam;

        TRACE4( "ContextHelp(WM_HELP,t=%d,id=%d,h=$%08x,s=$%08x)",
            p->iContextType, p->iCtrlId,p->hItemHandle ,hwndDlg );

        if (p->iContextType != HELPINFO_WINDOW)
        {
            return NO_ERROR;
        }

        hwnd = p->hItemHandle;
        unType = HELP_WM_HELP;
    }
    
    // Standard Win95 method that produces a one-item "What's This?" 
    // menu that user must click to get help.
    else  
    {
        TRACE1( "ContextHelp(WM_CONTEXTMENU,h=$%08x)", wparam );
        
        hwnd = (HWND )wparam;
        unType = HELP_CONTEXTMENU;
    }

    WinHelp( hwnd, pszHelpFile, unType, (ULONG_PTR)pdwMap );

    return NO_ERROR;
}

BOOL CALLBACK
WSDlgProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam )

    /* Standard Win32 dialog procedure.
    */
{
    if (unMsg == WM_INITDIALOG)
    {
        HMENU hmenu;
        RECT r1, r2;

        /* Remove Close from the system menu since some people think it kills
        ** the app and not just the popup.
        */
        hmenu = GetSystemMenu( hwnd, FALSE );
        if (hmenu && DeleteMenu( hmenu, SC_CLOSE, MF_BYCOMMAND ))
        {
            DrawMenuBar( hwnd );
        }

        // Center the window
        GetWindowRect(hwnd, &r1);
        GetWindowRect(GetDesktopWindow(), &r2);
        MoveWindow(
            hwnd, 
            (r2.right - r2.left)/2 - (r1.right - r1.left)/2,
            (r2.bottom - r2.top)/2 - (r1.bottom - r1.top)/2,   
            r1.right - r1.left,
            r1.bottom - r1.top,
            TRUE);
            
        return TRUE;
    }

    return FALSE;
}

//
// Bring up the start waiting for services dialog
//
DWORD 
RasSrvShowServiceWait( 
    IN HINSTANCE hInst, 
    IN HWND hwndParent, 
    OUT HANDLE * phData)
{                             
    // Set the hourglass cursor
    *phData = (HANDLE) SetCursor (LoadCursor (NULL, IDC_WAIT));
    ShowCursor (TRUE);
    
    return NO_ERROR;
}

//
// Bring down wait for services dialog                            
//
DWORD 
RasSrvFinishServiceWait (
    IN HANDLE hData) 
{
    HICON hIcon = (HICON)hData;
    
    if (hIcon == NULL)
    {
        hIcon = LoadCursor (NULL, IDC_ARROW);
    }
    
    SetCursor (hIcon);
    ShowCursor (TRUE);
    
    return NO_ERROR;
}

//-----------------------------------------------------------------------
// Function:    EnableBackupPrivilege
//
// Enables/disables backup privilege for the current process.
//-----------------------------------------------------------------------

DWORD
EnableRebootPrivilege(
    IN BOOL bEnable)
{
    LUID luid;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tp;
    BOOL bOk;

    // We first have to try to get the token of the current
    // thread since if it is impersonating, adjusting the
    // privileges of the process will have no affect.
    bOk = OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            TRUE,
            &hToken);
    if (bOk == FALSE)
    {
        // There is no thread token -- open it up for the
        // process instead.
        OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken
            );
    }

    // Get the LUID of the privilege
    if (!LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &luid)) 
    {

        DWORD dwErr = GetLastError();
        if(NULL != hToken)
        {
            CloseHandle(hToken);
        }
        return dwErr;
    }

    // Adjust the token privileges
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // Commit changes to the system
    if (!AdjustTokenPrivileges(
            hToken, !bEnable, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL
            ))
    {
        DWORD dwErr = GetLastError();
        if(NULL != hToken)
        {
            CloseHandle(hToken);
        }
        return dwErr;
    }

    // Even if AdjustTokenPrivileges succeeded (see MSDN) you still
    // need to verify success by calling GetLastError.
    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
    {
        if(NULL != hToken)
        {
            CloseHandle(hToken);
        }
        return ERROR_NOT_ALL_ASSIGNED;
    }

    if(NULL != hToken)
    {
        CloseHandle(hToken);
    }
    
    return NO_ERROR;
}

// Pops up a warning with the given parent window and reboots
// windows
DWORD RasSrvReboot(HWND hwndParent) 
{
    DWORD dwOldState;
    INT iRet;
    PWCHAR pszWarn, pszTitle;

    // Load the strings
    pszWarn = 
        (PWCHAR) PszLoadString(Globals.hInstDll, WRN_REBOOT_REQUIRED);
    pszTitle = 
        (PWCHAR) PszLoadString(Globals.hInstDll, WRN_TITLE);

    // Display the warning
    iRet = MessageBoxW(
                hwndParent, 
                pszWarn, 
                pszTitle, 
                MB_YESNO | MB_APPLMODAL);
    if (iRet != IDYES)
    {
        return ERROR_CANCELLED;
    }
        
    // Enable the reboot privelege    
    EnableRebootPrivilege(TRUE);

    ExitWindowsEx(EWX_REBOOT, 0);

    // Restore the reboot privelege    
    EnableRebootPrivilege(FALSE);
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\usertab.h ===
/*
    File    usertab.h

    Defines structures/methods for operating on the local user database.

    Paul Mayfield, 9/29/97
*/

#ifndef _usertab_h
#define _usertab_h

// For whistler bug 39081   458513    gangz
// The maximum number of chars show on the edit box
#define IC_USERFULLNAME    257  // Because in the user management, it could be 
                                // 256 characters long for the full name
#define IC_USERNAME        22


// ======================================
//  Structures
// ======================================

// Fills a LPPROPSHEETPAGE structure with the information
// needed to display the user tab. dwUserData is ignored.
DWORD UserTabGetPropertyPage(LPPROPSHEETPAGE lpPage, LPARAM lpUserData);     

// Function is the window procedure of the user tab in the incoming connections
// property sheet and wizard.
INT_PTR CALLBACK UserTabDialogProc(HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\wizard.h ===
/*
    File    wizard.c

    Declarations for the incoming connections wizard.

    Paul Mayfield, 10/30/97
*/

#ifndef __rassrvui_wizard_h
#define __rassrvui_wizard_h

// Fills in the property sheet structure with the information required to display
// the device tab in the incoming connections wizard.
DWORD DeviceWizGetPropertyPage(LPPROPSHEETPAGE ppage, LPARAM lpUserData);

// Fills in the property sheet structure with the information required to display
// the virtual networking tab in the incoming connections wizard.
DWORD VpnWizGetPropertyPage(LPPROPSHEETPAGE ppage, LPARAM lpUserData);

// Function fills in the given LPPROPSHEETPAGE structure with the information needed
// to run the user tab in the incoming connections wizard.
DWORD UserWizGetPropertyPage(LPPROPSHEETPAGE lpPage, LPARAM lpUserData);

// Fills a LPPROPSHEETPAGE structure with the information
// needed to display the protocol tab in the incoming connections wizard.
DWORD ProtWizGetPropertyPage(LPPROPSHEETPAGE lpPage, LPARAM lpUserData);

// Function fills in the given LPPROPSHEETPAGE structure with the information needed
// to run the dcc device tab in the incoming connections wizard.
DWORD DccdevWizGetPropertyPage (LPPROPSHEETPAGE lpPage, LPARAM lpUserData);

// Function fills in the given LPPROPSHEETPAGE structure with the information needed
// to run the dummy wizard page that switches to mmc.
DWORD SwitchMmcWizGetProptertyPage (LPPROPSHEETPAGE lpPage, LPARAM lpUserData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\test\temp.c ===
/*
	File	Temp.c

	Does temporary stuff.
*/

#include "..\\error.h"
#include <stdio.h>
#include <windows.h>
#include <commctrl.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <winsvc.h>
#include <rasuip.h>

#define MPR50 1

#include <mprapi.h>
#include <rtinfo.h>
#include <ipxrtdef.h>
#include <routprot.h>

// Error reporting
void PrintErr(DWORD err);

// [pmay] This will be removed when the router is modified to use MprInfo api's
typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;
typedef RTR_TOC_ENTRY IPX_TOC_ENTRY, *PIPX_TOC_ENTRY;

// Prototypes of functions that may be temporarily used for test.exe
void FixFwd();
DWORD DispPorts();
DWORD EnumGroups ();
DWORD Service();
void Crash();

// Return true if you want this function to implement test.exe
BOOL TempFunc(int argc, char ** argv) {
    //Service();
    //return TRUE;
    return FALSE;
}

// Display ports
DWORD DispPorts() {
    DWORD dwErr;
	HANDLE	hRouterAdmin;

    if ((dwErr = MprAdminServerConnect(NULL, &hRouterAdmin)) != NO_ERROR)
        return dwErr;

}

PIPX_TOC_ENTRY
GetIPXTocEntry (
	IN PIPX_INFO_BLOCK_HEADER	pInterfaceInfo,
	IN ULONG					InfoEntryType
	) {
    UINT			i;
	PIPX_TOC_ENTRY	pTocEntry;

    for (i=0, pTocEntry = pInterfaceInfo->TocEntry;
				i<pInterfaceInfo->TocEntriesCount;
					i++, pTocEntry++) {
		if (pTocEntry->InfoType == InfoEntryType) {
			return pTocEntry;
		}
	}

	SetLastError (ERROR_FILE_NOT_FOUND);
	return NULL;
}

DWORD GetNbIpxClientIf (LPTSTR		InterfaceName,
	                    UINT		msg)
{
	DWORD	rc, sz;
	LPBYTE	pClBlock;
	HANDLE	hTrCfg, hRouterAdmin;

    if ((rc = MprAdminServerConnect(NULL, &hRouterAdmin)) != NO_ERROR)
        return rc;

	hTrCfg = NULL;
	rc = MprAdminTransportGetInfo (
			hRouterAdmin,
			PID_IPX,
            NULL, NULL,
			&pClBlock,
            &sz);

    if (rc==NO_ERROR) {
		PIPX_TOC_ENTRY pIpxToc, pSapToc, pRipToc;

        // Netbios
		pIpxToc = GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)pClBlock,
					              IPX_INTERFACE_INFO_TYPE);
		if (pIpxToc!=NULL) {
			PIPX_IF_INFO	pIpxInfo;
			pIpxInfo = (PIPX_IF_INFO)(pClBlock+pIpxToc->Offset);
            printf("\nDial-in\n");
            printf("Accept  = %d\n", pIpxInfo->NetbiosAccept);
            printf("Deliver = %d\n\n", pIpxInfo->NetbiosDeliver);
            pIpxInfo->NetbiosDeliver = 1;
		}

        // rip
		pRipToc = GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)pClBlock,IPX_PROTOCOL_RIP);
		if (pIpxToc!=NULL) {
			PRIP_IF_CONFIG	pRipCfg;
            pRipCfg = (PRIP_IF_CONFIG)(pClBlock+pRipToc->Offset);
            printf("\nDial-in\n");
            printf("Rip   = %d\n", pRipCfg->RipIfInfo.UpdateMode);
            pRipCfg->RipIfInfo.UpdateMode = 2;
		}

        // sap
		pSapToc = GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)pClBlock,IPX_PROTOCOL_SAP);
		if (pIpxToc!=NULL) {
			PSAP_IF_CONFIG	pSapCfg;
			pSapCfg = (PSAP_IF_CONFIG)(pClBlock+pSapToc->Offset);
            printf("\nDial-in\n");
            printf("Sap Mode = %d\n\n\n", pSapCfg->SapIfInfo.UpdateMode);
            pSapCfg->SapIfInfo.UpdateMode = 2;
		}

        MprAdminTransportSetInfo(
            hRouterAdmin,
            PID_IPX,
            (LPBYTE)NULL, 
            0, 
            pClBlock, 
            sz);
        
        MprAdminBufferFree (pClBlock);
	}

	return rc;
}

void FixFwd() {
    GetNbIpxClientIf(NULL, 0);
    GetNbIpxClientIf(NULL, 0);
}

// Enumerates the local groups on the local machine
DWORD EnumGroups () {
    NET_API_STATUS nStatus;
    GROUP_INFO_0 * buf;
    DWORD i, dwMax = 2000000, dwTot, dwRead=0;

    nStatus =  NetLocalGroupEnum(NULL,
                            0,
                            (LPBYTE*)&buf,
                            dwMax,
                            &dwRead,
                            &dwTot,
                            NULL);

    if (nStatus != NERR_Success) {
        switch (nStatus) {
            case ERROR_ACCESS_DENIED:
                return ERROR_ACCESS_DENIED;
            case NERR_UserExists:
                return ERROR_USER_EXISTS;
            case NERR_PasswordTooShort:
                return ERROR_INVALID_PASSWORDNAME;
            case NERR_InvalidComputer:          // These should never happen because
            case NERR_NotPrimary:               // we deal with local user database
            case NERR_GroupExists:
            default:
                return ERROR_CAN_NOT_COMPLETE;
        }
    }

    for (i=0; i<dwRead; i++) 
        wprintf(L"Group Name: %s\n", buf[i].grpi0_name);

    return NO_ERROR;
}


// Runs tests on starting/stopping services, etc.
DWORD Service() {
    SC_HANDLE hServiceController = NULL, hService = NULL;
    WCHAR pszRemoteAccess[] = L"remoteaccess";
    SERVICE_STATUS ServiceStatus;
    BOOL bOk;
   
    __try {
        // Open the service manager
        hServiceController = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, GENERIC_EXECUTE);
        if (! hServiceController) {
            PrintErr(GetLastError());
            return 0;
        }

        // Open the service
        hService = OpenServiceW(hServiceController, 
                               pszRemoteAccess, 
                               SERVICE_START | SERVICE_STOP | SERVICE_QUERY_STATUS);
        if (! hService) {
            PrintErr(GetLastError());
            return 0;
        }

        // Get the service status
        bOk = QueryServiceStatus (hService, 
                                  &ServiceStatus);
        if (! bOk) {
            PrintErr(GetLastError());
            return 0;
        }

        // Find out if the service is running
        if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
            printf("\nRemote access service is stopped, attempting to start it...");
            bOk = StartService(hService, 0, NULL);
            if (! bOk) {
                PrintErr(GetLastError());
                return 0;
            }
            // Wait for the service to stop
            while (ServiceStatus.dwCurrentState != SERVICE_RUNNING) {
                Sleep(1000);
                bOk = QueryServiceStatus (hService, 
                                          &ServiceStatus);
                if (! bOk) {
                    PrintErr(GetLastError());
                    return 0;
                }
                printf(".");
            }
            printf("\nService Started.\n\n");
        }
        else if (ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
            printf("\nRemote access service is started, attempting to stop it...");
            bOk = ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus);
            if (! bOk) {
                PrintErr(GetLastError());
                return 0;
            }

            // Wait for the service to stop
            while (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                Sleep(1000);
                bOk = QueryServiceStatus (hService, 
                                          &ServiceStatus);
                if (! bOk) {
                    PrintErr(GetLastError());
                    return 0;
                }
                printf(".");
            }
            printf("\nService Stopped.\n\n");
        }
    }
    __finally {
        if (hServiceController)
            CloseServiceHandle(hServiceController);
        if (hService)
            CloseServiceHandle(hService);
    }

    return 0;
}

/*
char x [5] = { 0xf0, 0x0f, 0xc7, 0xc8 };

void Crash() {
{
    void (*f)() = x;
    f();
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\routemon\comstrs.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by comstrs.rc
//
#define TOKEN_IPX                       1
#define TOKEN_IP                        2
#define TOKEN_HELP1                     3
#define TOKEN_HELP2                     4
#define TOKEN_HELP3                     5
#define TOKEN_ROUTER                    6
#define TOKEN_INTERFACECMD              7
#define TOKEN_CREATE                    8
#define TOKEN_DELETE                    9
#define TOKEN_SHOW                      10
#define TOKEN_INTERFACE                 11
#define TOKEN_SCRIPT                    13
#define TOKEN_UPDATE                    14
#define TOKEN_CONNECT                   15
#define TOKEN_DISCONNECT                16
#define TOKEN_SET                       17
#define TOKEN_PERSISTENT                18
#define TOKEN_ENABLE                    18
#define TOKEN_DISABLE                   19
#define TOKEN_LOAD                      20
#define TOKEN_SAVE                      21
#define TOKEN_REGISTER                  22
#define TOKEN_USER				        23
#define TOKEN_UPGRADE                   24
#define TOKEN_NONE                      25
#define TOKEN_CALLER                    26
#define TOKEN_ADMIN                     27
#define TOKEN_TUNNEL1                   201
#define VAL_IFTYPE_CLIENT               401
#define VAL_IFTYPE_HOME_ROUTER          402
#define VAL_IFTYPE_FULL_ROUTER          403
#define VAL_IFTYPE_DEDICATED            404
#define VAL_IFTYPE_INTERNAL             405
#define VAL_IFSTATE_CONNECTED           406
#define VAL_IFSTATE_DISCONNECTED        407
#define VAL_YES                         408
#define VAL_NO                          409
#define VAL_NA                          410
#define VAL_ENABLED                     411
#define VAL_DISABLED                    412
#define VAL_IFSTATE_CONNECTING          413
#define VAL_IFTYPE_LOOPBACK             414
#define VAL_IFTYPE_TUNNEL1              415
#define VAL_LOCAL                       416
#define VAL_DOMAIN                      417

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\rras\ras\ui\rassrvui\wizard.c ===
/*
    File    wizard.c

    Implementation of the incoming connections wizard.

    Paul Mayfield, 10/30/97
*/

#include "rassrv.h"
#include <tapi.h>

// Help maps
static const DWORD phmWizardDccdev[] =
{
    CID_Wizard_Dccdev_LB_Devices,   IDH_Wizard_Dccdev_LB_Devices,
    0,                              0
};

static const DWORD phmWizardVpn[] =
{
    0,                              0
};

#define RASSRV_WIZTITLE_SIZE    256
#define RASSRV_WIZSUBTITLE_SIZE 256

// This structure let's us remember information needed
// to keep our device data page in sync
typedef struct _DCCDEV_DATA 
{
    HANDLE hDevice;
    BOOL bEnabled;
} DCCDEV_DATA;

//
// This dialog proc implements the vpn tab on the incoming connections
// wizard.
//
INT_PTR 
CALLBACK 
VpnWizDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

//
// Dialog procedure that handles the host dcc wizard device page
//
INT_PTR 
CALLBACK 
DccdevWizDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

//
// This dialog procedure responds to messages sent to the 
// switch to mmc wizard tab.
//
INT_PTR 
CALLBACK 
SwitchMmcWizDialogProc (
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
                                      
//
// Fills in the property sheet structure with the information required to 
// display the device tab in the incoming connections wizard.
//
DWORD 
DeviceWizGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    LPCTSTR pszHeader, pszSubHeader;

    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Load the string resources
    pszHeader = PszLoadString(
                    Globals.hInstDll, 
                    SID_WIZDEVICETITLE);
    pszSubHeader = PszLoadString(
                        Globals.hInstDll, 
                        SID_WIZDEVICESUBTITLE);

    // The General Properties dialog procedure also implements the device 
    // tab in the incoming connections wizard
    ppage->pfnDlgProc  = GenTabDialogProc;       

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_GenTab);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->pszHeaderTitle = (PWCHAR)pszHeader;
    ppage->pszHeaderSubTitle = (PWCHAR)pszSubHeader;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}

//
// Fills in the property sheet structure with the information required 
// to display the vpn tab in the incoming connections wizard.
//
DWORD 
VpnWizGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    LPCTSTR pszHeader, pszSubHeader;

    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Load the string resources
    pszHeader = PszLoadString(
                    Globals.hInstDll, 
                    SID_WIZVPNTITLE);
    pszSubHeader = PszLoadString(
                        Globals.hInstDll, 
                        SID_WIZVPNSUBTITLE);

    // I could have used the general tab dialog procedure to implement the
    // vpn tab.  The only problem is that the general tab has a single 
    // check to enable vpn while the vpn tab in the wizard has a yes/no 
    // radio check group.  For this reason, I made the vpn tab its very 
    // own dialog proc.
    ppage->pfnDlgProc  = VpnWizDialogProc;
    
    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_Vpn);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->pszHeaderTitle = (PWCHAR)pszHeader;
    ppage->pszHeaderSubTitle = (PWCHAR)pszSubHeader;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}

// 
// Function fills in the given lpPage structure with the information needed
// to run the user tab in the incoming connections wizard.
//
DWORD 
UserWizGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    LPCTSTR pszHeader, pszSubHeader;

    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Load the string resources
    pszHeader = PszLoadString(Globals.hInstDll, SID_WIZUSERTITLE);
    pszSubHeader = PszLoadString(Globals.hInstDll, SID_WIZUSERSUBTITLE);

    // The User Properties dialog procedure also implements the user tab
    // in the incoming connections wizard
    ppage->pfnDlgProc  = UserTabDialogProc;

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_UserTab);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->pszHeaderTitle = (PWCHAR)pszHeader;
    ppage->pszHeaderSubTitle = (PWCHAR)pszSubHeader;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}


// 
// Fills a LPPROPSHEETPAGE structure with the information
// needed to display the protocol tab in the incoming connections wizard.
//
DWORD 
ProtWizGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    LPCTSTR pszHeader, pszSubHeader;

    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Load the string resources
    pszHeader = PszLoadString(Globals.hInstDll, SID_WIZPROTTITLE);
    pszSubHeader = PszLoadString(Globals.hInstDll, SID_WIZPROTSUBTITLE);

    // The Advanced Properties dialog procedure also implements the net tab
    // in the incoming connections wizard
    ppage->pfnDlgProc  = NetTabDialogProc;

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_NetTab);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->pszHeaderTitle = (PWCHAR)pszHeader;
    ppage->pszHeaderSubTitle = (PWCHAR)pszSubHeader;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}

// 
// Function fills in the given LPPROPSHEETPAGE structure with the info 
// needed to run the dcc device tab in the incoming connections wizard.
// 
DWORD 
DccdevWizGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    LPCTSTR pszHeader, pszSubHeader;

    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Load the string resources
    pszHeader = PszLoadString(Globals.hInstDll, SID_WIZDCCDEVTITLE);
    pszSubHeader = PszLoadString(Globals.hInstDll, SID_WIZDCCDEVSUBTITLE);

    // The Advanced Properties dialog procedure also implements the protocol 
    // tab in the incoming connections wizard
    ppage->pfnDlgProc  = DccdevWizDialogProc;

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_Dccdev);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->pszHeaderTitle = (PWCHAR)pszHeader;
    ppage->pszHeaderSubTitle = (PWCHAR)pszSubHeader;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}

// 
// Function fills in the given LPPROPSHEETPAGE structure with the 
// information needed to run the dummy wizard page that switches to mmc.
//
DWORD 
SwitchMmcWizGetProptertyPage (
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // The Advanced Properties dialog procedure also implements 
    // the protocol tab in the incoming connections wizard
    ppage->pfnDlgProc  = SwitchMmcWizDialogProc;

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_SwitchMmc);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}

// 
// Initializes the vpn wizard tab.
// 
DWORD 
VpnWizInitializeDialog(
    IN HWND hwndDlg, 
    IN WPARAM wParam) 
{
    DWORD dwErr;
    BOOL bFlag;
    HANDLE hDevDatabase = NULL;
    
    // Get handles to the databases we're interested in
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);

    // Initialize the vpn check
    dwErr = devGetVpnEnable(hDevDatabase, &bFlag);
    if (dwErr != NO_ERROR)
    {
        ErrDisplayError(
            hwndDlg, 
            ERR_DEVICE_DATABASE_CORRUPT, 
            ERR_GENERALTAB_CATAGORY, 
            0, 
            Globals.dwErrorData);
        return dwErr;
    }
    
    SendMessage(GetDlgItem(hwndDlg, CID_Wizard_Vpn_RB_Yes), 
                BM_SETCHECK,
                (bFlag) ? BST_CHECKED : BST_UNCHECKED,
                0);
                
    SendMessage(GetDlgItem(hwndDlg, CID_Wizard_Vpn_RB_No), 
                BM_SETCHECK,
                (!bFlag) ? BST_CHECKED : BST_UNCHECKED,
                0);

    return NO_ERROR;
}

//
// Handles cancel button being pressed for the vpn wizard page
//
DWORD 
VpnWizCancelEdit(
    IN HWND hwndDlg, 
    IN NMHDR* pNotifyData) 
{
    HANDLE hDevDatabase = NULL;
    DWORD dwErr;
    
    DbgOutputTrace("Rolling back vpn wizard tab.");
    
    // Cancel flush of database
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);
    dwErr = devRollbackDatabase(hDevDatabase);
    if (dwErr != NO_ERROR)
    {
        ErrDisplayError(
            hwndDlg, 
            ERR_GENERAL_CANT_ROLLBACK_CHANGES, 
            ERR_GENERALTAB_CATAGORY, 
            0, 
            Globals.dwErrorData);
    }
        
    return NO_ERROR;
}

//
// Handles having the vpn wizard come active
//
DWORD 
VpnWizSetActive (
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
    return NO_ERROR;
}

// 
// Handles vpn loose activation messages
//
DWORD 
VpnWizKillActive (
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    HANDLE hDevDatabase = NULL;
    BOOL bEnable;
    
    //For Whistler bug#123769
    //In order to let the SetPortMapping commit
    //when creating a new IC connection, we set
    //the fVpnEnabledOrig to be different from
    // the fVpnEnable
    //
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);

    bEnable = IsDlgButtonChecked( hwndDlg, CID_Wizard_Vpn_RB_Yes );
                
    devSetVpnOrigEnable(hDevDatabase, !bEnable);

    return NO_ERROR;
}    

// 
// Processes command messages for the vpn wizard page
// 
DWORD 
VpnWizCommand(
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    HANDLE hDevDatabase = NULL;
    BOOL bEnable;
    
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);

    if (wParam == CID_Wizard_Vpn_RB_Yes || wParam == CID_Wizard_Vpn_RB_No) 
    {
        HWND hwndVPNRB = GetDlgItem(hwndDlg, CID_Wizard_Vpn_RB_Yes);
        if (hwndVPNRB)
        {
            bEnable = (BOOL) SendMessage(
                        hwndVPNRB,
                        BM_GETCHECK,
                        0,
                        0);
        }

        devSetVpnEnable(hDevDatabase, bEnable);
    }
    
    return NO_ERROR;
}

//
// This dialog procedure responds to messages sent to the 
// vpn wizard tab.
//
INT_PTR CALLBACK 
VpnWizDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam) 
{
    // Filter the customized ras server ui page messages. By filtering 
    // messages through here, we are able to call RasSrvGetDatabaseHandle 
    // below
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
        return TRUE;

    // Process other messages as normal
    switch (uMsg) 
    {
        case WM_INITDIALOG:

            
            // For whislter bug 417039      gangz
            // Firewall is taken out of 64bit build or server build
            // 
            if( !IsFirewallAvailablePlatform() )
            {
                ShowWindow(GetDlgItem(hwndDlg,CID_Wizard_Vpn_ST_Firewall),
                           SW_HIDE);
            }
            
            return FALSE;
            break;

        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code) 
            {
                case PSN_RESET:                    
                    VpnWizCancelEdit(hwndDlg, (NMHDR*)lParam);
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                    break;
                    
                case PSN_SETACTIVE:
                    if (! GetWindowLongPtr(hwndDlg, GWLP_USERDATA))
                    {
                        VpnWizInitializeDialog(hwndDlg, wParam);
                        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 1);
                    }
                    VpnWizSetActive (hwndDlg, wParam, lParam);
                    break;
                    
                case PSN_KILLACTIVE:
                    VpnWizKillActive (hwndDlg, wParam, lParam);
                    break;
            }

        case WM_COMMAND:
            VpnWizCommand(hwndDlg, wParam, lParam);
            break;
    }

    return FALSE;
}

// Fill the device combo box
DWORD 
DccdevFillDeviceList(
    IN HWND hwndDlg, 
    IN HANDLE hDevDatabase, 
    IN HANDLE hDevSelect) 
{
    HWND hwndCb = GetDlgItem(hwndDlg, CID_Wizard_Dccdev_LB_Devices);
    DWORD dwCount, dwIndex, dwErr, i, j=0, dwSelect = 0;
    HANDLE hDevice;
    PWCHAR pszName = NULL;
    
    if (hwndCb)
    {
        // Delete anything that was in the combo box
        SendMessage(hwndCb, CB_RESETCONTENT, 0, 0);
    }

    // Get the count of devices
    if ((dwErr = devGetDeviceCount(hDevDatabase, &dwCount)) != NO_ERROR)
    {
        return dwErr;
    }

    // Add them to the device combo box
    for (i = 0; i < dwCount; i++) 
    {
        // If the device wasn